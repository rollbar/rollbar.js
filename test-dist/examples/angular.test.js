(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/rollbar.umd.js":
/*!*****************************!*\
  !*** ./dist/rollbar.umd.js ***!
  \*****************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{}
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 1:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__) {

"use strict";
/**
 * @module hrtime
 *
 * @description Methods for handling OpenTelemetry hrtime.
 */

/**
 * Convert a duration in milliseconds to an OpenTelemetry hrtime tuple.
 *
 * @param {number} millis - The duration in milliseconds.
 * @returns {[number, number]} An array where the first element is seconds
 *   and the second is nanoseconds.
 */
function fromMillis(millis) {
  return [Math.trunc(millis / 1000), Math.round(millis % 1000 * 1e6)];
}

/**
 * Convert an OpenTelemetry hrtime tuple back to a duration in milliseconds.
 *
 * @param {[number, number]} hrtime - The hrtime tuple [seconds, nanoseconds].
 * @returns {number} The total duration in milliseconds.
 */
function toMillis(hrtime) {
  return hrtime[0] * 1e3 + Math.round(hrtime[1] / 1e6);
}

/**
 * Convert an OpenTelemetry hrtime tuple back to a duration in nanoseconds.
 *
 * @param {[number, number]} hrtime - The hrtime tuple [seconds, nanoseconds].
 * @returns {number} The total duration in nanoseconds.
 */
function toNanos(hrtime) {
  return hrtime[0] * 1e9 + hrtime[1];
}

/**
 * Adds two OpenTelemetry hrtime tuples.
 *
 * @param {[number, number]} a - The first hrtime tuple [s, ns].
 * @param {[number, number]} b - The second hrtime tuple [s, ns].
 * @returns {[number, number]} Summed hrtime tuple, normalized.
 *
 */
function add(a, b) {
  return [a[0] + b[0] + Math.trunc((a[1] + b[1]) / 1e9), (a[1] + b[1]) % 1e9];
}

/**
 * Get the current high-resolution time as an OpenTelemetry hrtime tuple.
 *
 * Uses the Performance API (timeOrigin + now()).
 *
 * @returns {[number, number]} The current hrtime tuple [s, ns].
 */
function now() {
  return add(fromMillis(performance.timeOrigin), fromMillis(performance.now()));
}

/**
 * Check if a value is a valid OpenTelemetry hrtime tuple.
 *
 * An hrtime tuple is an Array of exactly two numbers:
 *   [seconds, nanoseconds]
 *
 * @param {*} value â€“ anything to test
 * @returns {boolean} true if `value` is a [number, number] array of length 2
 *
 * @example
 * isHrTime([ 1, 500 ]);         // true
 * isHrTime([ 0, 1e9 ]);         // true
 * isHrTime([ '1', 500 ]);       // false
 * isHrTime({ 0: 1, 1: 500 });   // false
 */
function isHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}

/**
 * Methods for handling hrtime. OpenTelemetry uses the [seconds, nanoseconds]
 * format for hrtime in the `ReadableSpan` interface.
 *
 * @example
 * import hrtime from '@tracing/hrtime.js';
 *
 * hrtime.fromMillis(1000);
 * hrtime.toMillis([0, 1000]);
 * hrtime.add([0, 0], [0, 1000]);
 * hrtime.now();
 * hrtime.isHrTime([0, 1000]);
 */
/* harmony default export */ __nested_webpack_exports__.A = ({
  fromMillis: fromMillis,
  toMillis: toMillis,
  toNanos: toNanos,
  add: add,
  now: now,
  isHrTime: isHrTime
});

/***/ }),

/***/ 14:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_3430__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var _ = __nested_webpack_require_3430__(585);

/*
 * Queue - an object which handles which handles a queue of items to be sent to Rollbar.
 *   This object handles rate limiting via a passed in rate limiter, retries based on connection
 *   errors, and filtering of items based on a set of configurable predicates. The communication to
 *   the backend is performed via a given API object.
 *
 * @param rateLimiter - An object which conforms to the interface
 *    rateLimiter.shouldSend(item) -> bool
 * @param api - An object which conforms to the interface
 *    api.postItem(payload, function(err, response))
 * @param logger - An object used to log verbose messages if desired
 * @param options - see Queue.prototype.configure
 * @param replayMap - Optional ReplayMap for coordinating session replay with error occurrences
 */
function Queue(rateLimiter, api, logger, options, replayMap) {
  this.rateLimiter = rateLimiter;
  this.api = api;
  this.logger = logger;
  this.options = options;
  this.replayMap = replayMap;
  this.predicates = [];
  this.pendingItems = [];
  this.pendingRequests = [];
  this.retryQueue = [];
  this.retryHandle = null;
  this.waitCallback = null;
  this.waitIntervalID = null;
}

/*
 * configure - updates the options this queue uses
 *
 * @param options
 */
Queue.prototype.configure = function (options) {
  this.api && this.api.configure(options);
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  return this;
};

/*
 * addPredicate - adds a predicate to the end of the list of predicates for this queue
 *
 * @param predicate - function(item, options) -> (bool|{err: Error})
 *  Returning true means that this predicate passes and the item is okay to go on the queue
 *  Returning false means do not add the item to the queue, but it is not an error
 *  Returning {err: Error} means do not add the item to the queue, and the given error explains why
 *  Returning {err: undefined} is equivalent to returning true but don't do that
 */
Queue.prototype.addPredicate = function (predicate) {
  if (_.isFunction(predicate)) {
    this.predicates.push(predicate);
  }
  return this;
};
Queue.prototype.addPendingItem = function (item) {
  this.pendingItems.push(item);
};
Queue.prototype.removePendingItem = function (item) {
  var idx = this.pendingItems.indexOf(item);
  if (idx !== -1) {
    this.pendingItems.splice(idx, 1);
  }
};

/*
 * addItem - Send an item to the Rollbar API if all of the predicates are satisfied
 *
 * @param item - The payload to send to the backend
 * @param callback - function(error, repsonse) which will be called with the response from the API
 *  in the case of a success, otherwise response will be null and error will have a value. If both
 *  error and response are null then the item was stopped by a predicate which did not consider this
 *  to be an error condition, but nonetheless did not send the item to the API.
 *  @param originalError - The original error before any transformations that is to be logged if any
 */
Queue.prototype.addItem = function (item, callback, originalError, originalItem) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {
      return;
    };
  }
  var predicateResult = this._applyPredicates(item);
  if (predicateResult.stop) {
    this.removePendingItem(originalItem);
    callback(predicateResult.err);
    return;
  }
  this._maybeLog(item, originalError);
  this.removePendingItem(originalItem);
  if (!this.options.transmit) {
    callback(new Error('Transmit disabled'));
    return;
  }
  if (this.replayMap && item.body) {
    var replayId = this.replayMap.add(item.uuid);
    item.replayId = replayId;
  }
  this.pendingRequests.push(item);
  try {
    this._makeApiRequest(item, function (err, resp) {
      this._dequeuePendingRequest(item);
      if (!err && resp && item.replayId) {
        this._handleReplayResponse(item.replayId, resp);
      }
      callback(err, resp);
    }.bind(this));
  } catch (e) {
    this._dequeuePendingRequest(item);
    callback(e);
  }
};

/*
 * wait - Stop any further errors from being added to the queue, and get called back when all items
 *   currently processing have finished sending to the backend.
 *
 * @param callback - function() called when all pending items have been sent
 */
Queue.prototype.wait = function (callback) {
  if (!_.isFunction(callback)) {
    return;
  }
  this.waitCallback = callback;
  if (this._maybeCallWait()) {
    return;
  }
  if (this.waitIntervalID) {
    this.waitIntervalID = clearInterval(this.waitIntervalID);
  }
  this.waitIntervalID = setInterval(function () {
    this._maybeCallWait();
  }.bind(this), 500);
};

/* _applyPredicates - Sequentially applies the predicates that have been added to the queue to the
 *   given item with the currently configured options.
 *
 * @param item - An item in the queue
 * @returns {stop: bool, err: (Error|null)} - stop being true means do not add item to the queue,
 *   the error value should be passed up to a callbak if we are stopping.
 */
Queue.prototype._applyPredicates = function (item) {
  var p = null;
  for (var i = 0, len = this.predicates.length; i < len; i++) {
    p = this.predicates[i](item, this.options);
    if (!p || p.err !== undefined) {
      return {
        stop: true,
        err: p.err
      };
    }
  }
  return {
    stop: false,
    err: null
  };
};

/*
 * _makeApiRequest - Send an item to Rollbar, callback when done, if there is an error make an
 *   effort to retry if we are configured to do so.
 *
 * @param item - an item ready to send to the backend
 * @param callback - function(err, response)
 */
Queue.prototype._makeApiRequest = function (item, callback) {
  var rateLimitResponse = this.rateLimiter.shouldSend(item);
  if (rateLimitResponse.shouldSend) {
    this.api.postItem(item, function (err, resp) {
      if (err) {
        this._maybeRetry(err, item, callback);
      } else {
        callback(err, resp);
      }
    }.bind(this));
  } else if (rateLimitResponse.error) {
    callback(rateLimitResponse.error);
  } else {
    this.api.postItem(rateLimitResponse.payload, callback);
  }
};

// These are errors basically mean there is no internet connection
var RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE', 'EAI_AGAIN'];

/*
 * _maybeRetry - Given the error returned by the API, decide if we should retry or just callback
 *   with the error.
 *
 * @param err - an error returned by the API transport
 * @param item - the item that was trying to be sent when this error occured
 * @param callback - function(err, response)
 */
Queue.prototype._maybeRetry = function (err, item, callback) {
  var shouldRetry = false;
  if (this.options.retryInterval) {
    for (var i = 0, len = RETRIABLE_ERRORS.length; i < len; i++) {
      if (err.code === RETRIABLE_ERRORS[i]) {
        shouldRetry = true;
        break;
      }
    }
    if (shouldRetry && _.isFiniteNumber(this.options.maxRetries)) {
      item.retries = item.retries ? item.retries + 1 : 1;
      if (item.retries > this.options.maxRetries) {
        shouldRetry = false;
      }
    }
  }
  if (shouldRetry) {
    this._retryApiRequest(item, callback);
  } else {
    callback(err);
  }
};

/*
 * _retryApiRequest - Add an item and a callback to a queue and possibly start a timer to process
 *   that queue based on the retryInterval in the options for this queue.
 *
 * @param item - an item that failed to send due to an error we deem retriable
 * @param callback - function(err, response)
 */
Queue.prototype._retryApiRequest = function (item, callback) {
  this.retryQueue.push({
    item: item,
    callback: callback
  });
  if (!this.retryHandle) {
    this.retryHandle = setInterval(function () {
      while (this.retryQueue.length) {
        var retryObject = this.retryQueue.shift();
        this._makeApiRequest(retryObject.item, retryObject.callback);
      }
    }.bind(this), this.options.retryInterval);
  }
};

/*
 * _dequeuePendingRequest - Removes the item from the pending request queue, this queue is used to
 *   enable to functionality of providing a callback that clients can pass to `wait` to be notified
 *   when the pending request queue has been emptied. This must be called when the API finishes
 *   processing this item. If a `wait` callback is configured, it is called by this function.
 *
 * @param item - the item previously added to the pending request queue
 */
Queue.prototype._dequeuePendingRequest = function (item) {
  var idx = this.pendingRequests.indexOf(item);
  if (idx !== -1) {
    this.pendingRequests.splice(idx, 1);
    this._maybeCallWait();
  }
};
Queue.prototype._maybeLog = function (data, originalError) {
  if (this.logger && this.options.verbose) {
    var message = originalError;
    message = message || _.get(data, 'body.trace.exception.message');
    message = message || _.get(data, 'body.trace_chain.0.exception.message');
    if (message) {
      this.logger.error(message);
      return;
    }
    message = _.get(data, 'body.message.body');
    if (message) {
      this.logger.log(message);
    }
  }
};
Queue.prototype._maybeCallWait = function () {
  if (_.isFunction(this.waitCallback) && this.pendingItems.length === 0 && this.pendingRequests.length === 0) {
    if (this.waitIntervalID) {
      this.waitIntervalID = clearInterval(this.waitIntervalID);
    }
    this.waitCallback();
    return true;
  }
  return false;
};

/**
 * Handles the API response for an item with a replay ID.
 * Based on the success or failure status of the response,
 * it either sends or discards the associated session replay.
 *
 * @param {string} replayId - The ID of the replay to handle
 * @param {Object} response - The API response
 * @returns {Promise<boolean>} A promise that resolves to true if replay was sent successfully,
 *                             false if replay was discarded or an error occurred
 * @private
 */
Queue.prototype._handleReplayResponse = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(replayId, response) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (this.replayMap) {
            _context.next = 3;
            break;
          }
          console.warn('Queue._handleReplayResponse: ReplayMap not available');
          return _context.abrupt("return", false);
        case 3:
          if (replayId) {
            _context.next = 6;
            break;
          }
          console.warn('Queue._handleReplayResponse: No replayId provided');
          return _context.abrupt("return", false);
        case 6:
          _context.prev = 6;
          if (!(response && response.err === 0)) {
            _context.next = 14;
            break;
          }
          _context.next = 10;
          return this.replayMap.send(replayId);
        case 10:
          result = _context.sent;
          return _context.abrupt("return", result);
        case 14:
          this.replayMap.discard(replayId);
          return _context.abrupt("return", false);
        case 16:
          _context.next = 22;
          break;
        case 18:
          _context.prev = 18;
          _context.t0 = _context["catch"](6);
          console.error('Error handling replay response:', _context.t0);
          return _context.abrupt("return", false);
        case 22:
        case "end":
          return _context.stop();
      }
    }, _callee, this, [[6, 18]]);
  }));
  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
module.exports = Queue;

/***/ }),

/***/ 49:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_25116__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var _ = __nested_webpack_require_25116__(585);
var helpers = __nested_webpack_require_25116__(93);
var defaultOptions = {
  hostname: 'api.rollbar.com',
  path: '/api/1/item/',
  search: null,
  version: '1',
  protocol: 'https:',
  port: 443
};
var OTLPDefaultOptions = {
  hostname: 'api.rollbar.com',
  path: '/api/1/session/',
  search: null,
  version: '1',
  protocol: 'https:',
  port: 443
};

/**
 * Api is an object that encapsulates methods of communicating with
 * the Rollbar API.  It is a standard interface with some parts implemented
 * differently for server or browser contexts.  It is an object that should
 * be instantiated when used so it can contain non-global options that may
 * be different for another instance of RollbarApi.
 *
 * @param options {
 *    accessToken: the accessToken to use for posting items to rollbar
 *    endpoint: an alternative endpoint to send errors to
 *        must be a valid, fully qualified URL.
 *        The default is: https://api.rollbar.com/api/1/item
 *    proxy: if you wish to proxy requests provide an object
 *        with the following keys:
 *          host or hostname (required): foo.example.com
 *          port (optional): 123
 *          protocol (optional): https
 * }
 */
function Api(options, transport, urllib, truncation) {
  this.options = options;
  this.transport = transport;
  this.url = urllib;
  this.truncation = truncation;
  this.accessToken = options.accessToken;
  this.transportOptions = _getTransport(options, urllib);
  this.OTLPTransportOptions = _getOTLPTransport(options, urllib);
}

/**
 * Wraps transport.post in a Promise to support async/await
 *
 * @param {Object} options - Options for the API request
 * @param {string} options.accessToken - The access token for authentication
 * @param {Object} options.transportOptions - Options for the transport
 * @param {Object} options.payload - The data payload to send
 * @returns {Promise} A promise that resolves with the response or rejects with an error
 * @private
 */
Api.prototype._postPromise = function (_ref) {
  var accessToken = _ref.accessToken,
    transportOptions = _ref.transportOptions,
    payload = _ref.payload;
  var self = this;
  return new Promise(function (resolve, reject) {
    self.transport.post(accessToken, transportOptions, payload, function (err, resp) {
      return err ? reject(err) : resolve(resp);
    });
  });
};

/**
 *
 * @param data
 * @param callback
 */
Api.prototype.postItem = function (data, callback) {
  var transportOptions = helpers.transportOptions(this.transportOptions, 'POST');
  var payload = helpers.buildPayload(data);
  var self = this;

  // ensure the network request is scheduled after the current tick.
  setTimeout(function () {
    self.transport.post(self.accessToken, transportOptions, payload, callback);
  }, 0);
};

/**
 * Posts spans to the Rollbar API using the session endpoint
 *
 * @param {Array} payload - The spans to send
 * @returns {Promise<Object>} A promise that resolves with the API response
 */
Api.prototype.postSpans = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(payload) {
    var transportOptions;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          transportOptions = helpers.transportOptions(this.OTLPTransportOptions, 'POST');
          _context.next = 3;
          return this._postPromise({
            accessToken: this.accessToken,
            transportOptions: transportOptions,
            payload: payload
          });
        case 3:
          return _context.abrupt("return", _context.sent);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  }));
  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 *
 * @param data
 * @param callback
 */
Api.prototype.buildJsonPayload = function (data, callback) {
  var payload = helpers.buildPayload(data);
  var stringifyResult;
  if (this.truncation) {
    stringifyResult = this.truncation.truncate(payload);
  } else {
    stringifyResult = _.stringify(payload);
  }
  if (stringifyResult.error) {
    if (callback) {
      callback(stringifyResult.error);
    }
    return null;
  }
  return stringifyResult.value;
};

/**
 *
 * @param jsonPayload
 * @param callback
 */
Api.prototype.postJsonPayload = function (jsonPayload, callback) {
  var transportOptions = helpers.transportOptions(this.transportOptions, 'POST');
  this.transport.postJsonPayload(this.accessToken, transportOptions, jsonPayload, callback);
};
Api.prototype.configure = function (options) {
  var oldOptions = this.oldOptions;
  this.options = _.merge(oldOptions, options);
  this.transportOptions = _getTransport(this.options, this.url);
  this.OTLPTransportOptions = _getOTLPTransport(this.options, this.url);
  if (this.options.accessToken !== undefined) {
    this.accessToken = this.options.accessToken;
  }
  return this;
};
function _getTransport(options, url) {
  return helpers.getTransportFromOptions(options, defaultOptions, url);
}
function _getOTLPTransport(options, url) {
  var _options$tracing;
  options = _objectSpread(_objectSpread({}, options), {}, {
    endpoint: (_options$tracing = options.tracing) === null || _options$tracing === void 0 ? void 0 : _options$tracing.endpoint
  });
  return helpers.getTransportFromOptions(options, OTLPDefaultOptions, url);
}
module.exports = Api;

/***/ }),

/***/ 93:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_41874__) {

var _ = __nested_webpack_require_41874__(585);
function buildPayload(data) {
  if (!_.isType(data.context, 'string')) {
    var contextResult = _.stringify(data.context);
    if (contextResult.error) {
      data.context = "Error: could not serialize 'context'";
    } else {
      data.context = contextResult.value || '';
    }
    if (data.context.length > 255) {
      data.context = data.context.substr(0, 255);
    }
  }
  return {
    data: data
  };
}
function getTransportFromOptions(options, defaults, url) {
  var hostname = defaults.hostname;
  var protocol = defaults.protocol;
  var port = defaults.port;
  var path = defaults.path;
  var search = defaults.search;
  var timeout = options.timeout;
  var transport = detectTransport(options);
  var proxy = options.proxy;
  if (options.endpoint) {
    var opts = url.parse(options.endpoint);
    hostname = opts.hostname;
    protocol = opts.protocol;
    port = opts.port;
    path = opts.pathname;
    search = opts.search;
  }
  return {
    timeout: timeout,
    hostname: hostname,
    protocol: protocol,
    port: port,
    path: path,
    search: search,
    proxy: proxy,
    transport: transport
  };
}
function detectTransport(options) {
  var gWindow = typeof window != 'undefined' && window || typeof self != 'undefined' && self;
  var transport = options.defaultTransport || 'xhr';
  if (typeof gWindow.fetch === 'undefined') transport = 'xhr';
  if (typeof gWindow.XMLHttpRequest === 'undefined') transport = 'fetch';
  return transport;
}
function transportOptions(transport, method) {
  var protocol = transport.protocol || 'https:';
  var port = transport.port || (protocol === 'http:' ? 80 : protocol === 'https:' ? 443 : undefined);
  var hostname = transport.hostname;
  var path = transport.path;
  var timeout = transport.timeout;
  var transportAPI = transport.transport;
  if (transport.search) {
    path = path + transport.search;
  }
  if (transport.proxy) {
    path = protocol + '//' + hostname + path;
    hostname = transport.proxy.host || transport.proxy.hostname;
    port = transport.proxy.port;
    protocol = transport.proxy.protocol || protocol;
  }
  return {
    timeout: timeout,
    protocol: protocol,
    hostname: hostname,
    path: path,
    port: port,
    method: method,
    transport: transportAPI
  };
}
function appendPathToPath(base, path) {
  var baseTrailingSlash = /\/$/.test(base);
  var pathBeginningSlash = /^\//.test(path);
  if (baseTrailingSlash && pathBeginningSlash) {
    path = path.substring(1);
  } else if (!baseTrailingSlash && !pathBeginningSlash) {
    path = '/' + path;
  }
  return base + path;
}
module.exports = {
  buildPayload: buildPayload,
  getTransportFromOptions: getTransportFromOptions,
  transportOptions: transportOptions,
  appendPathToPath: appendPathToPath
};

/***/ }),

/***/ 98:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_44772__) {

var _ = __nested_webpack_require_44772__(585);
function traverse(obj, func, seen) {
  var k, v, i;
  var isObj = _.isType(obj, 'object');
  var isArray = _.isType(obj, 'array');
  var keys = [];
  var seenIndex;

  // Best might be to use Map here with `obj` as the keys, but we want to support IE < 11.
  seen = seen || {
    obj: [],
    mapped: []
  };
  if (isObj) {
    seenIndex = seen.obj.indexOf(obj);
    if (isObj && seenIndex !== -1) {
      // Prefer the mapped object if there is one.
      return seen.mapped[seenIndex] || seen.obj[seenIndex];
    }
    seen.obj.push(obj);
    seenIndex = seen.obj.length - 1;
  }
  if (isObj) {
    for (k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, k)) {
        keys.push(k);
      }
    }
  } else if (isArray) {
    for (i = 0; i < obj.length; ++i) {
      keys.push(i);
    }
  }
  var result = isObj ? {} : [];
  var same = true;
  for (i = 0; i < keys.length; ++i) {
    k = keys[i];
    v = obj[k];
    result[k] = func(k, v, seen);
    same = same && result[k] === obj[k];
  }
  if (isObj && !same) {
    seen.mapped[seenIndex] = result;
  }
  return !same ? result : obj;
}
module.exports = traverse;

/***/ }),

/***/ 108:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ 136:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_51323__) {

var ErrorStackParser = __nested_webpack_require_51323__(263);
var UNKNOWN_FUNCTION = '?';
var ERR_CLASS_REGEXP = new RegExp('^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ');
function guessFunctionName() {
  return UNKNOWN_FUNCTION;
}
function gatherContext() {
  return null;
}
function Frame(stackFrame) {
  var data = {};
  data._stackFrame = stackFrame;
  data.url = stackFrame.fileName;
  data.line = stackFrame.lineNumber;
  data.func = stackFrame.functionName;
  data.column = stackFrame.columnNumber;
  data.args = stackFrame.args;
  data.context = gatherContext();
  return data;
}
function Stack(exception, skip) {
  function getStack() {
    var parserStack = [];
    skip = skip || 0;
    try {
      parserStack = ErrorStackParser.parse(exception);
    } catch (e) {
      parserStack = [];
    }
    var stack = [];
    for (var i = skip; i < parserStack.length; i++) {
      stack.push(new Frame(parserStack[i]));
    }
    return stack;
  }
  return {
    stack: getStack(),
    message: exception.message,
    name: _mostSpecificErrorName(exception),
    rawStack: exception.stack,
    rawException: exception
  };
}
function parse(e, skip) {
  var err = e;
  if (err.nested || err.cause) {
    var traceChain = [];
    while (err) {
      traceChain.push(new Stack(err, skip));
      err = err.nested || err.cause;
      skip = 0; // Only apply skip value to primary error
    }

    // Return primary error with full trace chain attached.
    traceChain[0].traceChain = traceChain;
    return traceChain[0];
  } else {
    return new Stack(err, skip);
  }
}
function guessErrorClass(errMsg) {
  if (!errMsg || !errMsg.match) {
    return ['Unknown error. There was no error message to display.', ''];
  }
  var errClassMatch = errMsg.match(ERR_CLASS_REGEXP);
  var errClass = '(unknown)';
  if (errClassMatch) {
    errClass = errClassMatch[errClassMatch.length - 1];
    errMsg = errMsg.replace((errClassMatch[errClassMatch.length - 2] || '') + errClass + ':', '');
    errMsg = errMsg.replace(/(^[\s]+|[\s]+$)/g, '');
  }
  return [errClass, errMsg];
}

// * Prefers any value over an empty string
// * Prefers any value over 'Error' where possible
// * Prefers name over constructor.name when both are more specific than 'Error'
function _mostSpecificErrorName(error) {
  var name = error.name && error.name.length && error.name;
  var constructorName = error.constructor.name && error.constructor.name.length && error.constructor.name;
  if (!name || !constructorName) {
    return name || constructorName;
  }
  if (name === 'Error') {
    return constructorName;
  }
  return name;
}
module.exports = {
  guessFunctionName: guessFunctionName,
  guessErrorClass: guessErrorClass,
  gatherContext: gatherContext,
  parse: parse,
  Stack: Stack,
  Frame: Frame
};

/***/ }),

/***/ 144:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_54204__) {

/* eslint-disable no-console */
__nested_webpack_require_54204__(738);
var detection = __nested_webpack_require_54204__(629);
var _ = __nested_webpack_require_54204__(585);
function error() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.error(_.formatArgsAsString(args));
  } else {
    console.error.apply(console, args);
  }
}
function info() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.info(_.formatArgsAsString(args));
  } else {
    console.info.apply(console, args);
  }
}
function log() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.log(_.formatArgsAsString(args));
  } else {
    console.log.apply(console, args);
  }
}

/* eslint-enable no-console */

module.exports = {
  error: error,
  info: info,
  log: log
};

/***/ }),

/***/ 262:
/***/ (function(module) {

function captureUncaughtExceptions(window, handler, shim) {
  if (!window) {
    return;
  }
  var oldOnError;
  if (typeof handler._rollbarOldOnError === 'function') {
    oldOnError = handler._rollbarOldOnError;
  } else if (window.onerror) {
    oldOnError = window.onerror;
    while (oldOnError._rollbarOldOnError) {
      oldOnError = oldOnError._rollbarOldOnError;
    }
    handler._rollbarOldOnError = oldOnError;
  }
  handler.handleAnonymousErrors();
  var fn = function fn() {
    var args = Array.prototype.slice.call(arguments, 0);
    _rollbarWindowOnError(window, handler, oldOnError, args);
  };
  if (shim) {
    fn._rollbarOldOnError = oldOnError;
  }
  window.onerror = fn;
}
function _rollbarWindowOnError(window, r, old, args) {
  if (window._rollbarWrappedError) {
    if (!args[4]) {
      args[4] = window._rollbarWrappedError;
    }
    if (!args[5]) {
      args[5] = window._rollbarWrappedError._rollbarContext;
    }
    window._rollbarWrappedError = null;
  }
  var ret = r.handleUncaughtException.apply(r, args);
  if (old) {
    old.apply(window, args);
  }

  // Let other chained onerror handlers above run before setting this.
  // If an error is thrown and caught within a chained onerror handler,
  // Error.prepareStackTrace() will see that one before the one we want.
  if (ret === 'anonymous') {
    r.anonymousErrorsPending += 1; // See Rollbar.prototype.handleAnonymousErrors()
  }
}
function captureUnhandledRejections(window, handler, shim) {
  if (!window) {
    return;
  }
  if (typeof window._rollbarURH === 'function' && window._rollbarURH.belongsToShim) {
    window.removeEventListener('unhandledrejection', window._rollbarURH);
  }
  var rejectionHandler = function rejectionHandler(evt) {
    var reason, promise, detail;
    try {
      reason = evt.reason;
    } catch (e) {
      reason = undefined;
    }
    try {
      promise = evt.promise;
    } catch (e) {
      promise = '[unhandledrejection] error getting `promise` from event';
    }
    try {
      detail = evt.detail;
      if (!reason && detail) {
        reason = detail.reason;
        promise = detail.promise;
      }
    } catch (e) {
      // Ignore
    }
    if (!reason) {
      reason = '[unhandledrejection] error getting `reason` from event';
    }
    if (handler && handler.handleUnhandledRejection) {
      handler.handleUnhandledRejection(reason, promise);
    }
  };
  rejectionHandler.belongsToShim = shim;
  window._rollbarURH = rejectionHandler;
  window.addEventListener('unhandledrejection', rejectionHandler);
}
module.exports = {
  captureUncaughtExceptions: captureUncaughtExceptions,
  captureUnhandledRejections: captureUnhandledRejections
};

/***/ }),

/***/ 263:
/***/ (function(module, exports, __nested_webpack_require_57970__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_57970__(108)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                    .replace(/<anonymous function(: (\w+))?>/, '$2')
                    .replace(/\([^)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ 269:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_67021__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_67021__.r(__nested_webpack_exports__);

// EXPORTS
__nested_webpack_require_67021__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ Tracing; }
});

;// ./src/tracing/context.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Context = /*#__PURE__*/function () {
  function Context(parentContext) {
    _classCallCheck(this, Context);
    this._currentContext = parentContext ? new Map(parentContext) : new Map();
  }
  return _createClass(Context, [{
    key: "getValue",
    value: function getValue(key) {
      return this._currentContext.get(key);
    }
  }, {
    key: "setValue",
    value: function setValue(key, value) {
      var context = new Context(this._currentContext);
      context._currentContext.set(key, value);
      return context;
    }
  }, {
    key: "deleteValue",
    value: function deleteValue(key) {
      var context = new Context(self._currentContext);
      context._currentContext["delete"](key);
      return context;
    }
  }]);
}();
var ROOT_CONTEXT = new Context();
;// ./src/tracing/contextManager.js
function contextManager_typeof(o) { "@babel/helpers - typeof"; return contextManager_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, contextManager_typeof(o); }
function contextManager_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function contextManager_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, contextManager_toPropertyKey(o.key), o); } }
function contextManager_createClass(e, r, t) { return r && contextManager_defineProperties(e.prototype, r), t && contextManager_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function contextManager_toPropertyKey(t) { var i = contextManager_toPrimitive(t, "string"); return "symbol" == contextManager_typeof(i) ? i : i + ""; }
function contextManager_toPrimitive(t, r) { if ("object" != contextManager_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != contextManager_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var ContextManager = /*#__PURE__*/function () {
  function ContextManager() {
    contextManager_classCallCheck(this, ContextManager);
    this.currentContext = ROOT_CONTEXT;
  }
  return contextManager_createClass(ContextManager, [{
    key: "active",
    value: function active() {
      return this.currentContext;
    }
  }, {
    key: "enterContext",
    value: function enterContext(context) {
      var previousContext = this.currentContext;
      this.currentContext = context || ROOT_CONTEXT;
      return previousContext;
    }
  }, {
    key: "exitContext",
    value: function exitContext(context) {
      this.currentContext = context;
      return this.currentContext;
    }
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var previousContext = this.enterContext(context);
      try {
        for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          args[_key - 3] = arguments[_key];
        }
        return fn.call.apply(fn, [thisArg].concat(args));
      } finally {
        this.exitContext(previousContext);
      }
    }
  }]);
}();
function createContextKey(key) {
  // Use Symbol for OpenTelemetry compatibility.
  return Symbol["for"](key);
}
// EXTERNAL MODULE: ./src/tracing/id.js
var id = __nested_webpack_require_67021__(767);
;// ./src/tracing/session.js
function session_typeof(o) { "@babel/helpers - typeof"; return session_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, session_typeof(o); }
function session_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function session_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, session_toPropertyKey(o.key), o); } }
function session_createClass(e, r, t) { return r && session_defineProperties(e.prototype, r), t && session_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function session_toPropertyKey(t) { var i = session_toPrimitive(t, "string"); return "symbol" == session_typeof(i) ? i : i + ""; }
function session_toPrimitive(t, r) { if ("object" != session_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != session_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var SESSION_KEY = 'RollbarSession';
var Session = /*#__PURE__*/function () {
  function Session(tracing, options) {
    session_classCallCheck(this, Session);
    this.options = options;
    this.tracing = tracing;
    this.window = tracing.window;
    this.session = null;
  }
  return session_createClass(Session, [{
    key: "init",
    value: function init() {
      if (this.session) {
        return this;
      }
      return this.getSession() || this.createSession();
    }
  }, {
    key: "getSession",
    value: function getSession() {
      try {
        var serializedSession = this.window.sessionStorage.getItem(SESSION_KEY);
        if (!serializedSession) {
          return null;
        }
        this.session = JSON.parse(serializedSession);
      } catch (_unused) {
        return null;
      }
      return this;
    }
  }, {
    key: "createSession",
    value: function createSession() {
      this.session = {
        id: id/* default */.A.gen(),
        createdAt: Date.now()
      };
      return this.setSession(this.session);
    }
  }, {
    key: "setSession",
    value: function setSession(session) {
      var sessionString = JSON.stringify(session);
      try {
        this.window.sessionStorage.setItem(SESSION_KEY, sessionString);
      } catch (_unused2) {
        return null;
      }
      return this;
    }
  }]);
}();
// EXTERNAL MODULE: ./src/tracing/hrtime.js
var hrtime = __nested_webpack_require_67021__(1);
;// ./src/tracing/exporter.js
function exporter_typeof(o) { "@babel/helpers - typeof"; return exporter_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, exporter_typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function exporter_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function exporter_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, exporter_toPropertyKey(o.key), o); } }
function exporter_createClass(e, r, t) { return r && exporter_defineProperties(e.prototype, r), t && exporter_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function exporter_toPropertyKey(t) { var i = exporter_toPrimitive(t, "string"); return "symbol" == exporter_typeof(i) ? i : i + ""; }
function exporter_toPrimitive(t, r) { if ("object" != exporter_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != exporter_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


/**
 * SpanExporter is responsible for exporting ReadableSpan objects
 * and transforming them into the OTLP-compatible format.
 */
var SpanExporter = /*#__PURE__*/function () {
  function SpanExporter() {
    exporter_classCallCheck(this, SpanExporter);
  }
  return exporter_createClass(SpanExporter, [{
    key: "export",
    value:
    /**
     * Export spans to the span export queue
     *
     * @param {Array} spans - Array of ReadableSpan objects to export
     * @param {Function} _resultCallback - Optional callback (not used)
     */
    function _export(spans, _resultCallback) {
      console.log(spans); // console exporter, TODO: make optional
      spanExportQueue.push.apply(spanExportQueue, _toConsumableArray(spans));
    }

    /**
     * Transforms an array of ReadableSpan objects into the OTLP format payload
     * compatible with the Rollbar API. This follows the OpenTelemetry protocol
     * specification for traces.
     *
     * @returns {Object} OTLP format payload for API transmission
     */
  }, {
    key: "toPayload",
    value: function toPayload() {
      var _this = this;
      var spans = spanExportQueue.slice();
      spanExportQueue.length = 0;
      if (!spans || !spans.length) {
        return {
          resourceSpans: []
        };
      }
      var resource = spans[0] && spans[0].resource || {};
      var scopeMap = new Map();
      var _iterator = _createForOfIteratorHelper(spans),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var span = _step.value;
          var scopeKey = span.instrumentationScope ? "".concat(span.instrumentationScope.name, ":").concat(span.instrumentationScope.version) : 'default:1.0.0';
          if (!scopeMap.has(scopeKey)) {
            scopeMap.set(scopeKey, {
              scope: span.instrumentationScope || {
                name: 'default',
                version: '1.0.0',
                attributes: []
              },
              spans: []
            });
          }
          scopeMap.get(scopeKey).spans.push(this._transformSpan(span));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        resourceSpans: [{
          resource: this._transformResource(resource),
          scopeSpans: Array.from(scopeMap.values()).map(function (scopeData) {
            return {
              scope: _this._transformInstrumentationScope(scopeData.scope),
              spans: scopeData.spans
            };
          })
        }]
      };
    }

    /**
     * Transforms a ReadableSpan into the OTLP Span format
     *
     * @private
     * @param {Object} span - ReadableSpan object to transform
     * @returns {Object} OTLP Span format
     */
  }, {
    key: "_transformSpan",
    value: function _transformSpan(span) {
      var _this2 = this;
      var transformAttributes = function transformAttributes(attributes) {
        return Object.entries(attributes || {}).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return {
            key: key,
            value: _this2._transformAnyValue(value)
          };
        });
      };
      var transformEvents = function transformEvents(events) {
        return (events || []).map(function (event) {
          return {
            timeUnixNano: hrtime/* default */.A.toNanos(event.time),
            name: event.name,
            attributes: transformAttributes(event.attributes)
          };
        });
      };
      return {
        traceId: span.spanContext.traceId,
        spanId: span.spanContext.spanId,
        parentSpanId: span.parentSpanId || '',
        name: span.name,
        kind: span.kind || 1,
        // INTERNAL by default
        startTimeUnixNano: hrtime/* default */.A.toNanos(span.startTime),
        endTimeUnixNano: hrtime/* default */.A.toNanos(span.endTime),
        attributes: transformAttributes(span.attributes),
        events: transformEvents(span.events)
      };
    }

    /**
     * Transforms a resource object into OTLP Resource format
     *
     * @private
     * @param {Object} resource - Resource information
     * @returns {Object} OTLP Resource format
     */
  }, {
    key: "_transformResource",
    value: function _transformResource(resource) {
      var _this3 = this;
      var attributes = resource.attributes || {};
      var keyValues = Object.entries(attributes).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];
        return {
          key: key,
          value: _this3._transformAnyValue(value)
        };
      });
      return {
        attributes: keyValues
      };
    }

    /**
     * Transforms an instrumentation scope into OTLP InstrumentationScope format
     *
     * @private
     * @param {Object} scope - Instrumentation scope information
     * @returns {Object} OTLP InstrumentationScope format
     */
  }, {
    key: "_transformInstrumentationScope",
    value: function _transformInstrumentationScope(scope) {
      var _this4 = this;
      return {
        name: scope.name || '',
        version: scope.version || '',
        attributes: (scope.attributes || []).map(function (attr) {
          return {
            key: attr.key,
            value: _this4._transformAnyValue(attr.value)
          };
        })
      };
    }

    /**
     * Transforms a JavaScript value into an OTLP AnyValue
     *
     * @private
     * @param {any} value - Value to transform
     * @returns {Object} OTLP AnyValue format
     */
  }, {
    key: "_transformAnyValue",
    value: function _transformAnyValue(value) {
      var _this5 = this;
      if (value === null || value === undefined) {
        return {
          stringValue: ''
        };
      }
      var type = exporter_typeof(value);
      if (type === 'string') {
        return {
          stringValue: value
        };
      } else if (type === 'number') {
        if (Number.isInteger(value)) {
          return {
            intValue: value.toString()
          };
        } else {
          return {
            doubleValue: value
          };
        }
      } else if (type === 'boolean') {
        return {
          boolValue: value
        };
      } else if (Array.isArray(value)) {
        return {
          arrayValue: {
            values: value.map(function (v) {
              return _this5._transformAnyValue(v);
            })
          }
        };
      } else if (type === 'object') {
        return {
          kvlistValue: {
            values: Object.entries(value).map(function (_ref5) {
              var _ref6 = _slicedToArray(_ref5, 2),
                k = _ref6[0],
                v = _ref6[1];
              return {
                key: k,
                value: _this5._transformAnyValue(v)
              };
            })
          }
        };
      }
      return {
        stringValue: String(value)
      };
    }
  }]);
}();
var spanExportQueue = [];
;// ./src/tracing/spanProcessor.js
function spanProcessor_typeof(o) { "@babel/helpers - typeof"; return spanProcessor_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, spanProcessor_typeof(o); }
function spanProcessor_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function spanProcessor_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, spanProcessor_toPropertyKey(o.key), o); } }
function spanProcessor_createClass(e, r, t) { return r && spanProcessor_defineProperties(e.prototype, r), t && spanProcessor_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function spanProcessor_toPropertyKey(t) { var i = spanProcessor_toPrimitive(t, "string"); return "symbol" == spanProcessor_typeof(i) ? i : i + ""; }
function spanProcessor_toPrimitive(t, r) { if ("object" != spanProcessor_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != spanProcessor_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SpanProcessor = /*#__PURE__*/function () {
  function SpanProcessor(exporter) {
    spanProcessor_classCallCheck(this, SpanProcessor);
    this.exporter = exporter;
    this.pendingSpans = new Map();
  }
  return spanProcessor_createClass(SpanProcessor, [{
    key: "onStart",
    value: function onStart(span, _parentContext) {
      this.pendingSpans.set(span.span.spanContext.spanId, span);
    }
  }, {
    key: "onEnd",
    value: function onEnd(span) {
      this.exporter["export"]([span["export"]()]);
      this.pendingSpans["delete"](span.span.spanContext.spanId);
    }
  }]);
}();
;// ./src/tracing/span.js
function span_typeof(o) { "@babel/helpers - typeof"; return span_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, span_typeof(o); }
function span_slicedToArray(r, e) { return span_arrayWithHoles(r) || span_iterableToArrayLimit(r, e) || span_unsupportedIterableToArray(r, e) || span_nonIterableRest(); }
function span_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function span_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return span_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? span_arrayLikeToArray(r, a) : void 0; } }
function span_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function span_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function span_arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function span_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function span_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, span_toPropertyKey(o.key), o); } }
function span_createClass(e, r, t) { return r && span_defineProperties(e.prototype, r), t && span_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function span_toPropertyKey(t) { var i = span_toPrimitive(t, "string"); return "symbol" == span_typeof(i) ? i : i + ""; }
function span_toPrimitive(t, r) { if ("object" != span_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != span_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Span = /*#__PURE__*/function () {
  function Span(options) {
    span_classCallCheck(this, Span);
    this.initReadableSpan(options);
    this.spanProcessor = options.spanProcessor;
    this.spanProcessor.onStart(this, options.context);
    if (options.attributes) {
      this.setAttributes(options.attributes);
    }
    return this;
  }
  return span_createClass(Span, [{
    key: "initReadableSpan",
    value: function initReadableSpan(options) {
      this.span = {
        name: options.name,
        kind: options.kind,
        spanContext: options.spanContext,
        parentSpanId: options.parentSpanId,
        startTime: options.startTime || hrtime/* default */.A.now(),
        endTime: [0, 0],
        status: {
          code: 0,
          message: ''
        },
        attributes: {
          'session.id': options.session.id
        },
        links: [],
        events: [],
        duration: 0,
        ended: false,
        resource: options.resource,
        instrumentationScope: options.scope,
        droppedAttributesCount: 0,
        droppedEventsCount: 0,
        droppedLinksCount: 0
      };
    }
  }, {
    key: "spanContext",
    value: function spanContext() {
      return this.span.spanContext;
    }
  }, {
    key: "spanId",
    get: function get() {
      return this.span.spanContext.spanId;
    }
  }, {
    key: "traceId",
    get: function get() {
      return this.span.spanContext.traceId;
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(key, value) {
      if (value == null || this.ended) return this;
      if (key.length === 0) return this;
      this.span.attributes[key] = value;
      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = span_slicedToArray(_Object$entries[_i], 2),
          k = _Object$entries$_i[0],
          v = _Object$entries$_i[1];
        this.setAttribute(k, v);
      }
      return this;
    }
  }, {
    key: "addEvent",
    value: function addEvent(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var time = arguments.length > 2 ? arguments[2] : undefined;
      if (this.span.ended) return this;
      this.span.events.push({
        name: name,
        attributes: attributes,
        time: time || hrtime/* default */.A.now(),
        droppedAttributesCount: 0
      });
      return this;
    }
  }, {
    key: "isRecording",
    value: function isRecording() {
      return this.span.ended === false;
    }
  }, {
    key: "end",
    value: function end(attributes, time) {
      if (attributes) this.setAttributes(attributes);
      this.span.endTime = time || hrtime/* default */.A.now();
      this.span.ended = true;
      this.spanProcessor.onEnd(this);
    }
  }, {
    key: "export",
    value: function _export() {
      return this.span;
    }
  }]);
}();
;// ./src/tracing/tracer.js
function tracer_typeof(o) { "@babel/helpers - typeof"; return tracer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, tracer_typeof(o); }
function tracer_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function tracer_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, tracer_toPropertyKey(o.key), o); } }
function tracer_createClass(e, r, t) { return r && tracer_defineProperties(e.prototype, r), t && tracer_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function tracer_toPropertyKey(t) { var i = tracer_toPrimitive(t, "string"); return "symbol" == tracer_typeof(i) ? i : i + ""; }
function tracer_toPrimitive(t, r) { if ("object" != tracer_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != tracer_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var Tracer = /*#__PURE__*/function () {
  function Tracer(tracing, spanProcessor) {
    tracer_classCallCheck(this, Tracer);
    this.spanProcessor = spanProcessor;
    this.tracing = tracing;
  }
  return tracer_createClass(Tracer, [{
    key: "startSpan",
    value: function startSpan(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tracing.contextManager.active();
      var parentSpan = this.tracing.getSpan(context);
      var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
      var spanId = id/* default */.A.gen(8);
      var traceId;
      var traceFlags = 0;
      var traceState = null;
      var parentSpanId;
      if (parentSpanContext) {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        parentSpanId = parentSpanContext.spanId;
      } else {
        traceId = id/* default */.A.gen(16);
      }
      var kind = 0;
      var spanContext = {
        traceId: traceId,
        spanId: spanId,
        traceFlags: traceFlags,
        traceState: traceState
      };
      var span = new Span({
        resource: this.tracing.resource,
        scope: this.tracing.scope,
        session: this.tracing.session.session,
        context: context,
        spanContext: spanContext,
        name: name,
        kind: kind,
        parentSpanId: parentSpanId,
        spanProcessor: this.spanProcessor
      });
      return span;
    }
  }]);
}();
;// ./src/tracing/tracing.js
function tracing_typeof(o) { "@babel/helpers - typeof"; return tracing_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, tracing_typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = tracing_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function tracing_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function tracing_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, tracing_toPropertyKey(o.key), o); } }
function tracing_createClass(e, r, t) { return r && tracing_defineProperties(e.prototype, r), t && tracing_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function tracing_toPropertyKey(t) { var i = tracing_toPrimitive(t, "string"); return "symbol" == tracing_typeof(i) ? i : i + ""; }
function tracing_toPrimitive(t, r) { if ("object" != tracing_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != tracing_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





var SPAN_KEY = createContextKey('Rollbar Context Key SPAN');
var Tracing = /*#__PURE__*/function () {
  function Tracing(gWindow, options) {
    tracing_classCallCheck(this, Tracing);
    this.options = options;
    this.window = gWindow;
    this.session = new Session(this, options);
    this.createTracer();
  }
  return tracing_createClass(Tracing, [{
    key: "initSession",
    value: function initSession() {
      if (this.session) {
        this.session.init();
      }
    }
  }, {
    key: "sessionId",
    get: function get() {
      if (this.session) {
        return this.session.session.id;
      }
      return null;
    }
  }, {
    key: "resource",
    get: function get() {
      var _this$options$payload, _this$options$payload2;
      return {
        attributes: _objectSpread(_objectSpread({}, this.options.resource || {}), {}, {
          'rollbar.environment': (_this$options$payload = (_this$options$payload2 = this.options.payload) === null || _this$options$payload2 === void 0 ? void 0 : _this$options$payload2.environment) !== null && _this$options$payload !== void 0 ? _this$options$payload : this.options.environment
        })
      };
    }
  }, {
    key: "scope",
    get: function get() {
      return {
        name: 'rollbar-browser-js',
        version: this.options.version
      };
    }
  }, {
    key: "createTracer",
    value: function createTracer() {
      this.contextManager = new ContextManager();
      this.exporter = new SpanExporter();
      this.spanProcessor = new SpanProcessor(this.exporter);
      this.tracer = new Tracer(this, this.spanProcessor);
    }
  }, {
    key: "getTracer",
    value: function getTracer() {
      return this.tracer;
    }
  }, {
    key: "getSpan",
    value: function getSpan() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextManager.active();
      return context.getValue(SPAN_KEY);
    }
  }, {
    key: "setSpan",
    value: function setSpan() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextManager.active();
      var span = arguments.length > 1 ? arguments[1] : undefined;
      return context.setValue(SPAN_KEY, span);
    }
  }, {
    key: "startSpan",
    value: function startSpan(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.contextManager.active();
      return this.tracer.startSpan(name, options, context);
    }
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var _this$contextManager;
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      return (_this$contextManager = this.contextManager)["with"].apply(_this$contextManager, [context, fn, thisArg].concat(args));
    }
  }, {
    key: "withSpan",
    value: function withSpan(name, options, fn, thisArg) {
      var span = this.startSpan(name, options);
      return this["with"](this.setSpan(this.contextManager.active(), span), fn, thisArg, span);
    }
  }]);
}();


/***/ }),

/***/ 287:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_103007__) {

"use strict";
/* harmony export */ __nested_webpack_require_103007__.d(__nested_webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ ReplayMap; }
/* harmony export */ });
/* harmony import */ var _tracing_id_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_103007__(767);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }


/**
 * ReplayMap - Manages the mapping between error occurrences and their associated
 * session recordings. This class handles the coordination between when recordings
 * are dumped and when they are eventually sent to the backend.
 */
var _map = /*#__PURE__*/new WeakMap();
var _recorder = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _tracing = /*#__PURE__*/new WeakMap();
var ReplayMap = /*#__PURE__*/function () {
  /**
   * Creates a new ReplayMap instance
   *
   * @param {Object} props - Configuration props
   * @param {Object} props.recorder - The recorder instance that dumps replay data into spans
   * @param {Object} props.api - The API instance used to send replay payloads to the backend
   * @param {Object} props.tracing - The tracing instance used to create spans and manage context
   */
  function ReplayMap(_ref) {
    var recorder = _ref.recorder,
      api = _ref.api,
      tracing = _ref.tracing;
    _classCallCheck(this, ReplayMap);
    _classPrivateFieldInitSpec(this, _map, void 0);
    _classPrivateFieldInitSpec(this, _recorder, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _tracing, void 0);
    if (!recorder) {
      throw new TypeError("Expected 'recorder' to be provided");
    }
    if (!api) {
      throw new TypeError("Expected 'api' to be provided");
    }
    if (!tracing) {
      throw new TypeError("Expected 'tracing' to be provided");
    }
    _classPrivateFieldSet(_map, this, new Map());
    _classPrivateFieldSet(_recorder, this, recorder);
    _classPrivateFieldSet(_api, this, api);
    _classPrivateFieldSet(_tracing, this, tracing);
  }

  /**
   * Processes a replay by converting recorder events into a transport-ready payload.
   *
   * Calls recorder.dump() to capture events as spans, formats them into a proper payload,
   * and stores the result in the map using replayId as the key.
   *
   * @param {string} replayId - The unique ID for this replay
   * @returns {Promise<string>} A promise resolving to the processed replayId
   * @private
   */
  return _createClass(ReplayMap, [{
    key: "_processReplay",
    value: (function () {
      var _processReplay2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(replayId, occurrenceUuid) {
        var payload;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              try {
                payload = _classPrivateFieldGet(_recorder, this).dump(_classPrivateFieldGet(_tracing, this), replayId, occurrenceUuid);
                _classPrivateFieldGet(_map, this).set(replayId, payload);
              } catch (transformError) {
                console.error('Error transforming spans:', transformError);
                _classPrivateFieldGet(_map, this).set(replayId, null); // TODO(matux): Error span?
              }
              return _context.abrupt("return", replayId);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _processReplay(_x, _x2) {
        return _processReplay2.apply(this, arguments);
      }
      return _processReplay;
    }()
    /**
     * Adds a replay to the map and returns a uniquely generated replay ID.
     *
     * This method immediately returns the replayId and asynchronously processes
     * the replay data in the background. The processing involves converting
     * recorder events into a payload format and storing it in the map.
     *
     * @returns {string} A unique identifier for this replay
     */
    )
  }, {
    key: "add",
    value: function add(occurrenceUuid) {
      var replayId = _tracing_id_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.gen(8);
      this._processReplay(replayId, occurrenceUuid)["catch"](function (error) {
        console.error('Failed to process replay:', error);
      });
      return replayId;
    }

    /**
     * Sends the replay payload associated with the given replayId to the backend
     * and removes it from the map.
     *
     * Retrieves the payload from the map, checks if it's valid, then sends it
     * to the API endpoint for processing. The payload can be either a spans array
     * or a formatted OTLP payload object.
     *
     * @param {string} replayId - The ID of the replay to send
     * @returns {Promise<boolean>} A promise that resolves to true if the payload was found and sent, false otherwise
     */
  }, {
    key: "send",
    value: (function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(replayId) {
        var payload, isEmpty;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (replayId) {
                _context2.next = 3;
                break;
              }
              console.warn('ReplayMap.send: No replayId provided');
              return _context2.abrupt("return", false);
            case 3:
              if (_classPrivateFieldGet(_map, this).has(replayId)) {
                _context2.next = 6;
                break;
              }
              console.warn("ReplayMap.send: No replay found for replayId: ".concat(replayId));
              return _context2.abrupt("return", false);
            case 6:
              payload = _classPrivateFieldGet(_map, this).get(replayId);
              _classPrivateFieldGet(_map, this)["delete"](replayId);

              // Check if payload is empty (could be raw spans array or OTLP payload)
              isEmpty = !payload || Array.isArray(payload) && payload.length === 0 || payload.resourceSpans && payload.resourceSpans.length === 0;
              if (!isEmpty) {
                _context2.next = 12;
                break;
              }
              console.warn("ReplayMap.send: No payload found for replayId: ".concat(replayId));
              return _context2.abrupt("return", false);
            case 12:
              _context2.prev = 12;
              _context2.next = 15;
              return _classPrivateFieldGet(_api, this).postSpans(payload);
            case 15:
              return _context2.abrupt("return", true);
            case 18:
              _context2.prev = 18;
              _context2.t0 = _context2["catch"](12);
              console.error('Error sending replay:', _context2.t0);
              return _context2.abrupt("return", false);
            case 22:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[12, 18]]);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
    /**
     * Discards the replay associated with the given replay ID by removing
     * it from the map without sending it.
     *
     * @param {string} replayId - The ID of the replay to discard
     * @returns {boolean} True if a replay was found and discarded, false otherwise
     */
    )
  }, {
    key: "discard",
    value: function discard(replayId) {
      if (!replayId) {
        console.warn('ReplayMap.discard: No replayId provided');
        return false;
      }
      if (!_classPrivateFieldGet(_map, this).has(replayId)) {
        console.warn("ReplayMap.discard: No replay found for replayId: ".concat(replayId));
        return false;
      }
      _classPrivateFieldGet(_map, this)["delete"](replayId);
      return true;
    }

    /**
     * Gets spans for the given replay ID
     *
     * @param {string} replayId - The ID to retrieve spans for
     * @returns {Array|null} The spans array or null if not found
     */
  }, {
    key: "getSpans",
    value: function getSpans(replayId) {
      var _classPrivateFieldGet2;
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_map, this).get(replayId)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
    }

    /**
     * Sets spans for a given replay ID
     *
     * @param {string} replayId - The ID to set spans for
     * @param {Array} spans - The spans to set
     */
  }, {
    key: "setSpans",
    value: function setSpans(replayId, spans) {
      _classPrivateFieldGet(_map, this).set(replayId, spans);
    }

    /**
     * Returns the size of the map (number of stored replays)
     *
     * @returns {number} The number of replays currently stored
     */
  }, {
    key: "size",
    get: function get() {
      return _classPrivateFieldGet(_map, this).size;
    }

    /**
     * Clears all stored replays without sending them
     */
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldGet(_map, this).clear();
    }
  }]);
}();


/***/ }),

/***/ 299:
/***/ (function(module) {

module.exports = {
  version: '3.0.0-alpha.0',
  endpoint: 'api.rollbar.com/api/1/item/',
  logLevel: 'debug',
  reportLevel: 'debug',
  uncaughtErrorLevel: 'error',
  maxItems: 0,
  itemsPerMin: 60
};

/***/ }),

/***/ 379:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_123862__) {

var _ = __nested_webpack_require_123862__(585);
function checkLevel(item, settings) {
  var level = item.level;
  var levelVal = _.LEVELS[level] || 0;
  var reportLevel = settings.reportLevel;
  var reportLevelVal = _.LEVELS[reportLevel] || 0;
  if (levelVal < reportLevelVal) {
    return false;
  }
  return true;
}
function userCheckIgnore(logger) {
  return function (item, settings) {
    var isUncaught = !!item._isUncaught;
    delete item._isUncaught;
    var args = item._originalArgs;
    delete item._originalArgs;
    try {
      if (_.isFunction(settings.onSendCallback)) {
        settings.onSendCallback(isUncaught, args, item);
      }
    } catch (e) {
      settings.onSendCallback = null;
      logger.error('Error while calling onSendCallback, removing', e);
    }
    try {
      if (_.isFunction(settings.checkIgnore) && settings.checkIgnore(isUncaught, args, item)) {
        return false;
      }
    } catch (e) {
      settings.checkIgnore = null;
      logger.error('Error while calling custom checkIgnore(), removing', e);
    }
    return true;
  };
}
function urlIsNotBlockListed(logger) {
  return function (item, settings) {
    return !urlIsOnAList(item, settings, 'blocklist', logger);
  };
}
function urlIsSafeListed(logger) {
  return function (item, settings) {
    return urlIsOnAList(item, settings, 'safelist', logger);
  };
}
function matchFrames(trace, list, block) {
  if (!trace) {
    return !block;
  }
  var frames = trace.frames;
  if (!frames || frames.length === 0) {
    return !block;
  }
  var frame, filename, url, urlRegex;
  var listLength = list.length;
  var frameLength = frames.length;
  for (var i = 0; i < frameLength; i++) {
    frame = frames[i];
    filename = frame.filename;
    if (!_.isType(filename, 'string')) {
      return !block;
    }
    for (var j = 0; j < listLength; j++) {
      url = list[j];
      urlRegex = new RegExp(url);
      if (urlRegex.test(filename)) {
        return true;
      }
    }
  }
  return false;
}
function urlIsOnAList(item, settings, safeOrBlock, logger) {
  // safelist is the default
  var block = false;
  if (safeOrBlock === 'blocklist') {
    block = true;
  }
  var list, traces;
  try {
    list = block ? settings.hostBlockList : settings.hostSafeList;
    traces = _.get(item, 'body.trace_chain') || [_.get(item, 'body.trace')];

    // These two checks are important to come first as they are defaults
    // in case the list is missing or the trace is missing or not well-formed
    if (!list || list.length === 0) {
      return !block;
    }
    if (traces.length === 0 || !traces[0]) {
      return !block;
    }
    var tracesLength = traces.length;
    for (var i = 0; i < tracesLength; i++) {
      if (matchFrames(traces[i], list, block)) {
        return true;
      }
    }
  } catch (e
  /* istanbul ignore next */) {
    if (block) {
      settings.hostBlockList = null;
    } else {
      settings.hostSafeList = null;
    }
    var listName = block ? 'hostBlockList' : 'hostSafeList';
    logger.error("Error while reading your configuration's " + listName + ' option. Removing custom ' + listName + '.', e);
    return !block;
  }
  return false;
}
function messageIsIgnored(logger) {
  return function (item, settings) {
    var i, j, ignoredMessages, len, messageIsIgnored, rIgnoredMessage, messages;
    try {
      messageIsIgnored = false;
      ignoredMessages = settings.ignoredMessages;
      if (!ignoredMessages || ignoredMessages.length === 0) {
        return true;
      }
      messages = messagesFromItem(item);
      if (messages.length === 0) {
        return true;
      }
      len = ignoredMessages.length;
      for (i = 0; i < len; i++) {
        rIgnoredMessage = new RegExp(ignoredMessages[i], 'gi');
        for (j = 0; j < messages.length; j++) {
          messageIsIgnored = rIgnoredMessage.test(messages[j]);
          if (messageIsIgnored) {
            return false;
          }
        }
      }
    } catch (e
    /* istanbul ignore next */) {
      settings.ignoredMessages = null;
      logger.error("Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.");
    }
    return true;
  };
}
function messagesFromItem(item) {
  var body = item.body;
  var messages = [];

  // The payload schema only allows one of trace_chain, message, or trace.
  // However, existing test cases are based on having both trace and message present.
  // So here we preserve the ability to collect strings from any combination of these keys.
  if (body.trace_chain) {
    var traceChain = body.trace_chain;
    for (var i = 0; i < traceChain.length; i++) {
      var trace = traceChain[i];
      messages.push(_.get(trace, 'exception.message'));
    }
  }
  if (body.trace) {
    messages.push(_.get(body, 'trace.exception.message'));
  }
  if (body.message) {
    messages.push(_.get(body, 'message.body'));
  }
  return messages;
}
module.exports = {
  checkLevel: checkLevel,
  userCheckIgnore: userCheckIgnore,
  urlIsNotBlockListed: urlIsNotBlockListed,
  urlIsSafeListed: urlIsSafeListed,
  messageIsIgnored: messageIsIgnored
};

/***/ }),

/***/ 392:
/***/ (function(module) {

function getElementType(e) {
  return (e.getAttribute('type') || '').toLowerCase();
}
function isDescribedElement(element, type, subtypes) {
  if (element.tagName.toLowerCase() !== type.toLowerCase()) {
    return false;
  }
  if (!subtypes) {
    return true;
  }
  element = getElementType(element);
  for (var i = 0; i < subtypes.length; i++) {
    if (subtypes[i] === element) {
      return true;
    }
  }
  return false;
}
function getElementFromEvent(evt, doc) {
  if (evt.target) {
    return evt.target;
  }
  if (doc && doc.elementFromPoint) {
    return doc.elementFromPoint(evt.clientX, evt.clientY);
  }
  return undefined;
}
function treeToArray(elem) {
  var MAX_HEIGHT = 5;
  var out = [];
  var nextDescription;
  for (var height = 0; elem && height < MAX_HEIGHT; height++) {
    nextDescription = describeElement(elem);
    if (nextDescription.tagName === 'html') {
      break;
    }
    out.unshift(nextDescription);
    elem = elem.parentNode;
  }
  return out;
}
function elementArrayToString(a) {
  var MAX_LENGTH = 80;
  var separator = ' > ',
    separatorLength = separator.length;
  var out = [],
    len = 0,
    nextStr,
    totalLength;
  for (var i = a.length - 1; i >= 0; i--) {
    nextStr = descriptionToString(a[i]);
    totalLength = len + out.length * separatorLength + nextStr.length;
    if (i < a.length - 1 && totalLength >= MAX_LENGTH + 3) {
      out.unshift('...');
      break;
    }
    out.unshift(nextStr);
    len += nextStr.length;
  }
  return out.join(separator);
}
function descriptionToString(desc) {
  if (!desc || !desc.tagName) {
    return '';
  }
  var out = [desc.tagName];
  if (desc.id) {
    out.push('#' + desc.id);
  }
  if (desc.classes) {
    out.push('.' + desc.classes.join('.'));
  }
  for (var i = 0; i < desc.attributes.length; i++) {
    out.push('[' + desc.attributes[i].key + '="' + desc.attributes[i].value + '"]');
  }
  return out.join('');
}

/**
 * Input: a dom element
 * Output: null if tagName is falsey or input is falsey, else
 *  {
 *    tagName: String,
 *    id: String | undefined,
 *    classes: [String] | undefined,
 *    attributes: [
 *      {
 *        key: OneOf(type, name, title, alt),
 *        value: String
 *      }
 *    ]
 *  }
 */
function describeElement(elem) {
  if (!elem || !elem.tagName) {
    return null;
  }
  var out = {},
    className,
    key,
    attr,
    i;
  out.tagName = elem.tagName.toLowerCase();
  if (elem.id) {
    out.id = elem.id;
  }
  className = elem.className;
  if (className && typeof className === 'string') {
    out.classes = className.split(/\s+/);
  }
  var attributes = ['type', 'name', 'title', 'alt'];
  out.attributes = [];
  for (i = 0; i < attributes.length; i++) {
    key = attributes[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.attributes.push({
        key: key,
        value: attr
      });
    }
  }
  return out;
}
module.exports = {
  describeElement: describeElement,
  descriptionToString: descriptionToString,
  elementArrayToString: elementArrayToString,
  treeToArray: treeToArray,
  getElementFromEvent: getElementFromEvent,
  isDescribedElement: isDescribedElement,
  getElementType: getElementType
};

/***/ }),

/***/ 398:
/***/ (function(module) {

function replace(obj, name, replacement, replacements, type) {
  var orig = obj[name];
  obj[name] = replacement(orig);
  if (replacements) {
    replacements[type].push([obj, name, orig]);
  }
}
module.exports = replace;

/***/ }),

/***/ 402:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_132578__) {

var Rollbar = __nested_webpack_require_132578__(583);
var telemeter = __nested_webpack_require_132578__(618);
var instrumenter = __nested_webpack_require_132578__(705);
var polyfillJSON = __nested_webpack_require_132578__(657);
var wrapGlobals = __nested_webpack_require_132578__(706);
var scrub = __nested_webpack_require_132578__(922);
var truncation = __nested_webpack_require_132578__(622);
var Tracing = __nested_webpack_require_132578__(269);
var Recorder = __nested_webpack_require_132578__(918);
Rollbar.setComponents({
  telemeter: telemeter,
  instrumenter: instrumenter,
  polyfillJSON: polyfillJSON,
  wrapGlobals: wrapGlobals,
  scrub: scrub,
  truncation: truncation,
  tracing: Tracing["default"],
  recorder: Recorder["default"]
});
module.exports = Rollbar;

/***/ }),

/***/ 428:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_133324__) {

var rollbar = __nested_webpack_require_133324__(402);
var options = typeof window !== 'undefined' && window._rollbarConfig;
var alias = options && options.globalAlias || 'Rollbar';
var shimRunning = typeof window !== 'undefined' && window[alias] && typeof window[alias].shimId === 'function' && window[alias].shimId() !== undefined;
if (typeof window !== 'undefined' && !window._rollbarStartTime) {
  window._rollbarStartTime = new Date().getTime();
}
if (!shimRunning && options) {
  var Rollbar = new rollbar(options);
  window[alias] = Rollbar;
} else if (typeof window !== 'undefined') {
  window.rollbar = rollbar;
  window._rollbarDidLoad = true;
} else if (typeof self !== 'undefined') {
  self.rollbar = rollbar;
  self._rollbarDidLoad = true;
}
module.exports = rollbar;

/***/ }),

/***/ 436:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_134199__) {

"use strict";
__nested_webpack_require_134199__.r(__nested_webpack_exports__);
/**
 * Default tracing options
 */
/* harmony default export */ __nested_webpack_exports__["default"] = ({
  enabled: false,
  endpoint: 'api.rollbar.com/api/1/session/'
});

/***/ }),

/***/ 472:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_134521__) {

var logger = __nested_webpack_require_134521__(144);
var _ = __nested_webpack_require_134521__(585);
function makeFetchRequest(accessToken, url, method, data, callback, timeout) {
  var controller;
  var timeoutId;
  if (_.isFiniteNumber(timeout)) {
    controller = new AbortController();
    timeoutId = setTimeout(function () {
      controller.abort();
    }, timeout);
  }
  fetch(url, {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-Rollbar-Access-Token': accessToken,
      signal: controller && controller.signal
    },
    body: data
  }).then(function (response) {
    if (timeoutId) clearTimeout(timeoutId);
    return response.json();
  }).then(function (data) {
    callback(null, data);
  })["catch"](function (error) {
    logger.error(error.message);
    callback(error);
  });
}
module.exports = makeFetchRequest;

/***/ }),

/***/ 485:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_135461__) {

var _ = __nested_webpack_require_135461__(585);
var errorParser = __nested_webpack_require_135461__(136);
var logger = __nested_webpack_require_135461__(144);
function handleDomException(item, options, callback) {
  if (item.err && errorParser.Stack(item.err).name === 'DOMException') {
    var originalError = new Error();
    originalError.name = item.err.name;
    originalError.message = item.err.message;
    originalError.stack = item.err.stack;
    originalError.nested = item.err;
    item.err = originalError;
  }
  callback(null, item);
}
function handleItemWithError(item, options, callback) {
  item.data = item.data || {};
  if (item.err) {
    try {
      item.stackInfo = item.err._savedStackTrace || errorParser.parse(item.err, item.skipFrames);
      if (options.addErrorContext) {
        addErrorContext(item);
      }
    } catch (e) {
      logger.error('Error while parsing the error object.', e);
      try {
        item.message = item.err.message || item.err.description || item.message || String(item.err);
      } catch (e2) {
        item.message = String(item.err) || String(e2);
      }
      delete item.err;
    }
  }
  callback(null, item);
}
function addErrorContext(item) {
  var chain = [];
  var err = item.err;
  chain.push(err);
  while (err.nested || err.cause) {
    err = err.nested || err.cause;
    chain.push(err);
  }
  _.addErrorContext(item, chain);
}
function ensureItemHasSomethingToSay(item, options, callback) {
  if (!item.message && !item.stackInfo && !item.custom) {
    callback(new Error('No message, stack info, or custom data'), null);
  }
  callback(null, item);
}
function addBaseInfo(item, options, callback) {
  var environment = options.payload && options.payload.environment || options.environment;
  item.data = _.merge(item.data, {
    environment: environment,
    level: item.level,
    endpoint: options.endpoint,
    platform: 'browser',
    framework: 'browser-js',
    language: 'javascript',
    server: {},
    uuid: item.uuid,
    notifier: {
      name: 'rollbar-browser-js',
      version: options.version
    },
    custom: item.custom
  });
  callback(null, item);
}
function addRequestInfo(window) {
  return function (item, options, callback) {
    var requestInfo = {};
    if (window && window.location) {
      requestInfo.url = window.location.href;
      requestInfo.query_string = window.location.search;
    }
    var remoteString = '$remote_ip';
    if (!options.captureIp) {
      remoteString = null;
    } else if (options.captureIp !== true) {
      remoteString += '_anonymize';
    }
    if (remoteString) requestInfo.user_ip = remoteString;
    if (Object.keys(requestInfo).length > 0) {
      _.set(item, 'data.request', requestInfo);
    }
    callback(null, item);
  };
}
function addClientInfo(window) {
  return function (item, options, callback) {
    if (!window) {
      return callback(null, item);
    }
    var nav = window.navigator || {};
    var scr = window.screen || {};
    _.set(item, 'data.client', {
      runtime_ms: item.timestamp - window._rollbarStartTime,
      timestamp: Math.round(item.timestamp / 1000),
      javascript: {
        browser: nav.userAgent,
        language: nav.language,
        cookie_enabled: nav.cookieEnabled,
        screen: {
          width: scr.width,
          height: scr.height
        }
      }
    });
    callback(null, item);
  };
}
function addPluginInfo(window) {
  return function (item, options, callback) {
    if (!window || !window.navigator) {
      return callback(null, item);
    }
    var plugins = [];
    var navPlugins = window.navigator.plugins || [];
    var cur;
    for (var i = 0, l = navPlugins.length; i < l; ++i) {
      cur = navPlugins[i];
      plugins.push({
        name: cur.name,
        description: cur.description
      });
    }
    _.set(item, 'data.client.javascript.plugins', plugins);
    callback(null, item);
  };
}
function addBody(item, options, callback) {
  if (item.stackInfo) {
    if (item.stackInfo.traceChain) {
      addBodyTraceChain(item, options, callback);
    } else {
      addBodyTrace(item, options, callback);
    }
  } else {
    addBodyMessage(item, options, callback);
  }
}
function addBodyMessage(item, options, callback) {
  var message = item.message;
  var custom = item.custom;
  if (!message) {
    message = 'Item sent with null or missing arguments.';
  }
  var result = {
    body: message
  };
  if (custom) {
    result.extra = _.merge(custom);
  }
  _.set(item, 'data.body', {
    message: result
  });
  callback(null, item);
}
function stackFromItem(item) {
  // Transform a TraceKit stackInfo object into a Rollbar trace
  var stack = item.stackInfo.stack;
  if (stack && stack.length === 0 && item._unhandledStackInfo && item._unhandledStackInfo.stack) {
    stack = item._unhandledStackInfo.stack;
  }
  return stack;
}
function addBodyTraceChain(item, options, callback) {
  var traceChain = item.stackInfo.traceChain;
  var traces = [];
  var traceChainLength = traceChain.length;
  for (var i = 0; i < traceChainLength; i++) {
    var trace = buildTrace(item, traceChain[i], options);
    traces.push(trace);
  }
  _.set(item, 'data.body', {
    trace_chain: traces
  });
  callback(null, item);
}
function addBodyTrace(item, options, callback) {
  var stack = stackFromItem(item);
  if (stack) {
    var trace = buildTrace(item, item.stackInfo, options);
    _.set(item, 'data.body', {
      trace: trace
    });
    callback(null, item);
  } else {
    var stackInfo = item.stackInfo;
    var guess = errorParser.guessErrorClass(stackInfo.message);
    var className = errorClass(stackInfo, guess[0], options);
    var message = guess[1];
    item.message = className + ': ' + message;
    addBodyMessage(item, options, callback);
  }
}
function buildTrace(item, stackInfo, options) {
  var description = item && item.data.description;
  var custom = item && item.custom;
  var stack = stackFromItem(item);
  var guess = errorParser.guessErrorClass(stackInfo.message);
  var className = errorClass(stackInfo, guess[0], options);
  var message = guess[1];
  var trace = {
    exception: {
      "class": className,
      message: message
    }
  };
  if (description) {
    trace.exception.description = description;
  }
  if (stack) {
    if (stack.length === 0) {
      trace.exception.stack = stackInfo.rawStack;
      trace.exception.raw = String(stackInfo.rawException);
    }
    var stackFrame;
    var frame;
    var code;
    var pre;
    var post;
    var contextLength;
    var i, mid;
    trace.frames = [];
    for (i = 0; i < stack.length; ++i) {
      stackFrame = stack[i];
      frame = {
        filename: stackFrame.url ? _.sanitizeUrl(stackFrame.url) : '(unknown)',
        lineno: stackFrame.line || null,
        method: !stackFrame.func || stackFrame.func === '?' ? '[anonymous]' : stackFrame.func,
        colno: stackFrame.column
      };
      if (options.sendFrameUrl) {
        frame.url = stackFrame.url;
      }
      if (frame.method && frame.method.endsWith && frame.method.endsWith('_rollbar_wrapped')) {
        continue;
      }
      code = pre = post = null;
      contextLength = stackFrame.context ? stackFrame.context.length : 0;
      if (contextLength) {
        mid = Math.floor(contextLength / 2);
        pre = stackFrame.context.slice(0, mid);
        code = stackFrame.context[mid];
        post = stackFrame.context.slice(mid);
      }
      if (code) {
        frame.code = code;
      }
      if (pre || post) {
        frame.context = {};
        if (pre && pre.length) {
          frame.context.pre = pre;
        }
        if (post && post.length) {
          frame.context.post = post;
        }
      }
      if (stackFrame.args) {
        frame.args = stackFrame.args;
      }
      trace.frames.push(frame);
    }

    // NOTE(cory): reverse the frames since rollbar.com expects the most recent call last
    trace.frames.reverse();
    if (custom) {
      trace.extra = _.merge(custom);
    }
  }
  return trace;
}
function errorClass(stackInfo, guess, options) {
  if (stackInfo.name) {
    return stackInfo.name;
  } else if (options.guessErrorClass) {
    return guess;
  } else {
    return '(unknown)';
  }
}
function addScrubber(scrubFn) {
  return function (item, options, callback) {
    if (scrubFn) {
      var scrubFields = options.scrubFields || [];
      var scrubPaths = options.scrubPaths || [];
      item.data = scrubFn(item.data, scrubFields, scrubPaths);
    }
    callback(null, item);
  };
}
module.exports = {
  handleDomException: handleDomException,
  handleItemWithError: handleItemWithError,
  ensureItemHasSomethingToSay: ensureItemHasSomethingToSay,
  addBaseInfo: addBaseInfo,
  addRequestInfo: addRequestInfo,
  addClientInfo: addClientInfo,
  addPluginInfo: addPluginInfo,
  addBody: addBody,
  addScrubber: addScrubber
};

/***/ }),

/***/ 511:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_144370__) {

var _ = __nested_webpack_require_144370__(585);

/*
 * RateLimiter - an object that encapsulates the logic for counting items sent to Rollbar
 *
 * @param options - the same options that are accepted by configureGlobal offered as a convenience
 */
function RateLimiter(options) {
  this.startTime = _.now();
  this.counter = 0;
  this.perMinCounter = 0;
  this.platform = null;
  this.platformOptions = {};
  this.configureGlobal(options);
}
RateLimiter.globalSettings = {
  startTime: _.now(),
  maxItems: undefined,
  itemsPerMinute: undefined
};

/*
 * configureGlobal - set the global rate limiter options
 *
 * @param options - Only the following values are recognized:
 *    startTime: a timestamp of the form returned by (new Date()).getTime()
 *    maxItems: the maximum items
 *    itemsPerMinute: the max number of items to send in a given minute
 */
RateLimiter.prototype.configureGlobal = function (options) {
  if (options.startTime !== undefined) {
    RateLimiter.globalSettings.startTime = options.startTime;
  }
  if (options.maxItems !== undefined) {
    RateLimiter.globalSettings.maxItems = options.maxItems;
  }
  if (options.itemsPerMinute !== undefined) {
    RateLimiter.globalSettings.itemsPerMinute = options.itemsPerMinute;
  }
};

/*
 * shouldSend - determine if we should send a given item based on rate limit settings
 *
 * @param item - the item we are about to send
 * @returns An object with the following structure:
 *  error: (Error|null)
 *  shouldSend: bool
 *  payload: (Object|null)
 *  If shouldSend is false, the item passed as a parameter should not be sent to Rollbar, and
 *  exactly one of error or payload will be non-null. If error is non-null, the returned Error will
 *  describe the situation, but it means that we were already over a rate limit (either globally or
 *  per minute) when this item was checked. If error is null, and therefore payload is non-null, it
 *  means this item put us over the global rate limit and the payload should be sent to Rollbar in
 *  place of the passed in item.
 */
RateLimiter.prototype.shouldSend = function (item, now) {
  now = now || _.now();
  var elapsedTime = now - this.startTime;
  if (elapsedTime < 0 || elapsedTime >= 60000) {
    this.startTime = now;
    this.perMinCounter = 0;
  }
  var globalRateLimit = RateLimiter.globalSettings.maxItems;
  var globalRateLimitPerMin = RateLimiter.globalSettings.itemsPerMinute;
  if (checkRate(item, globalRateLimit, this.counter)) {
    return shouldSendValue(this.platform, this.platformOptions, globalRateLimit + ' max items reached', false);
  } else if (checkRate(item, globalRateLimitPerMin, this.perMinCounter)) {
    return shouldSendValue(this.platform, this.platformOptions, globalRateLimitPerMin + ' items per minute reached', false);
  }
  this.counter++;
  this.perMinCounter++;
  var shouldSend = !checkRate(item, globalRateLimit, this.counter);
  var perMinute = shouldSend;
  shouldSend = shouldSend && !checkRate(item, globalRateLimitPerMin, this.perMinCounter);
  return shouldSendValue(this.platform, this.platformOptions, null, shouldSend, globalRateLimit, globalRateLimitPerMin, perMinute);
};
RateLimiter.prototype.setPlatformOptions = function (platform, options) {
  this.platform = platform;
  this.platformOptions = options;
};

/* Helpers */

function checkRate(item, limit, counter) {
  return !item.ignoreRateLimit && limit >= 1 && counter > limit;
}
function shouldSendValue(platform, options, error, shouldSend, globalRateLimit, limitPerMin, perMinute) {
  var payload = null;
  if (error) {
    error = new Error(error);
  }
  if (!error && !shouldSend) {
    payload = rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute);
  }
  return {
    error: error,
    shouldSend: shouldSend,
    payload: payload
  };
}
function rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute) {
  var environment = options.environment || options.payload && options.payload.environment;
  var msg;
  if (perMinute) {
    msg = 'item per minute limit reached, ignoring errors until timeout';
  } else {
    msg = 'maxItems has been hit, ignoring errors until reset.';
  }
  var item = {
    body: {
      message: {
        body: msg,
        extra: {
          maxItems: globalRateLimit,
          itemsPerMinute: limitPerMin
        }
      }
    },
    language: 'javascript',
    environment: environment,
    notifier: {
      version: options.notifier && options.notifier.version || options.version
    }
  };
  if (platform === 'browser') {
    item.platform = 'browser';
    item.framework = 'browser-js';
    item.notifier.name = 'rollbar-browser-js';
  } else if (platform === 'server') {
    item.framework = options.framework || 'node-js';
    item.notifier.name = options.notifier.name;
  } else if (platform === 'react-native') {
    item.framework = options.framework || 'react-native';
    item.notifier.name = options.notifier.name;
  }
  return item;
}
module.exports = RateLimiter;

/***/ }),

/***/ 538:
/***/ (function(module) {

//  json3.js
//  2017-02-21
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.
//          This has been modified to use JSON-js/json_parse_state.js as the
//          parser instead of the one built around eval found in JSON-js/json2.js

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
  for, this
  */

/*property
  JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
  getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
  lastIndex, length, parse, prototype, push, replace, slice, stringify,
  test, toJSON, toString, valueOf
  */

var setupCustomJSON = function(JSON) {

  var rx_one = /^[\],:{}\s]*$/;
  var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
  var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
  var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

  function f(n) {
    // Format integers to have at least two digits.
    return n < 10
      ? "0" + n
      : n;
  }

  function this_value() {
    return this.valueOf();
  }

  if (typeof Date.prototype.toJSON !== "function") {

    Date.prototype.toJSON = function () {

      return isFinite(this.valueOf())
        ? this.getUTCFullYear() + "-" +
        f(this.getUTCMonth() + 1) + "-" +
        f(this.getUTCDate()) + "T" +
        f(this.getUTCHours()) + ":" +
        f(this.getUTCMinutes()) + ":" +
        f(this.getUTCSeconds()) + "Z"
        : null;
    };

    Boolean.prototype.toJSON = this_value;
    Number.prototype.toJSON = this_value;
    String.prototype.toJSON = this_value;
  }

  var gap;
  var indent;
  var meta;
  var rep;


  function quote(string) {

    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.

    rx_escapable.lastIndex = 0;
    return rx_escapable.test(string)
      ? "\"" + string.replace(rx_escapable, function (a) {
        var c = meta[a];
        return typeof c === "string"
          ? c
          : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + "\""
    : "\"" + string + "\"";
  }


  function str(key, holder) {

    // Produce a string from holder[key].

    var i;          // The loop counter.
    var k;          // The member key.
    var v;          // The member value.
    var length;
    var mind = gap;
    var partial;
    var value = holder[key];

    // If the value has a toJSON method, call it to obtain a replacement value.

    if (value && typeof value === "object" &&
        typeof value.toJSON === "function") {
      value = value.toJSON(key);
    }

    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.

    if (typeof rep === "function") {
      value = rep.call(holder, key, value);
    }

    // What happens next depends on the value's type.

    switch (typeof value) {
      case "string":
        return quote(value);

      case "number":

        // JSON numbers must be finite. Encode non-finite numbers as null.

        return isFinite(value)
          ? String(value)
          : "null";

      case "boolean":
      case "null":

        // If the value is a boolean or null, convert it to a string. Note:
        // typeof null does not produce "null". The case is included here in
        // the remote chance that this gets fixed someday.

        return String(value);

        // If the type is "object", we might be dealing with an object or an array or
        // null.

      case "object":

        // Due to a specification blunder in ECMAScript, typeof null is "object",
        // so watch out for that case.

        if (!value) {
          return "null";
        }

        // Make an array to hold the partial results of stringifying this object value.

        gap += indent;
        partial = [];

        // Is the value an array?

        if (Object.prototype.toString.apply(value) === "[object Array]") {

          // The value is an array. Stringify every element. Use null as a placeholder
          // for non-JSON values.

          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || "null";
          }

          // Join all of the elements together, separated with commas, and wrap them in
          // brackets.

          v = partial.length === 0
            ? "[]"
            : gap
            ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
            : "[" + partial.join(",") + "]";
          gap = mind;
          return v;
        }

        // If the replacer is an array, use it to select the members to be stringified.

        if (rep && typeof rep === "object") {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === "string") {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (
                      gap
                      ? ": "
                      : ":"
                      ) + v);
              }
            }
          }
        } else {

          // Otherwise, iterate through all of the keys in the object.

          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (
                      gap
                      ? ": "
                      : ":"
                      ) + v);
              }
            }
          }
        }

        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0
          ? "{}"
          : gap
          ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
          : "{" + partial.join(",") + "}";
        gap = mind;
        return v;
    }
  }

  // If the JSON object does not yet have a stringify method, give it one.

  if (typeof JSON.stringify !== "function") {
    meta = {    // table of character substitutions
      "\b": "\\b",
      "\t": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      "\"": "\\\"",
      "\\": "\\\\"
    };
    JSON.stringify = function (value, replacer, space) {

      // The stringify method takes a value and an optional replacer, and an optional
      // space parameter, and returns a JSON text. The replacer can be a function
      // that can replace values, or an array of strings that will select the keys.
      // A default replacer method can be provided. Use of the space parameter can
      // produce text that is more easily readable.

      var i;
      gap = "";
      indent = "";

      // If the space parameter is a number, make an indent string containing that
      // many spaces.

      if (typeof space === "number") {
        for (i = 0; i < space; i += 1) {
          indent += " ";
        }

        // If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === "string") {
        indent = space;
      }

      // If there is a replacer, it must be a function or an array.
      // Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== "function" &&
          (typeof replacer !== "object" ||
           typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }

      // Make a fake root object containing our value under the key of "".
      // Return the result of stringifying the value.

      return str("", {"": value});
    };
  }


  // If the JSON object does not yet have a parse method, give it one.

  if (typeof JSON.parse !== "function") {
    JSON.parse = (function () {

      // This function creates a JSON parse function that uses a state machine rather
      // than the dangerous eval function to parse a JSON text.

      var state;      // The state of the parser, one of
      // 'go'         The starting state
      // 'ok'         The final, accepting state
      // 'firstokey'  Ready for the first key of the object or
      //              the closing of an empty object
      // 'okey'       Ready for the next key of the object
      // 'colon'      Ready for the colon
      // 'ovalue'     Ready for the value half of a key/value pair
      // 'ocomma'     Ready for a comma or closing }
      // 'firstavalue' Ready for the first value of an array or
      //              an empty array
      // 'avalue'     Ready for the next value of an array
      // 'acomma'     Ready for a comma or closing ]
      var stack;      // The stack, for controlling nesting.
      var container;  // The current container object or array
      var key;        // The current key
      var value;      // The current value
      var escapes = { // Escapement translation table
        "\\": "\\",
        "\"": "\"",
        "/": "/",
        "t": "\t",
        "n": "\n",
        "r": "\r",
        "f": "\f",
        "b": "\b"
      };
      var string = {   // The actions for string tokens
        go: function () {
          state = "ok";
        },
        firstokey: function () {
          key = value;
          state = "colon";
        },
        okey: function () {
          key = value;
          state = "colon";
        },
        ovalue: function () {
          state = "ocomma";
        },
        firstavalue: function () {
          state = "acomma";
        },
        avalue: function () {
          state = "acomma";
        }
      };
      var number = {   // The actions for number tokens
        go: function () {
          state = "ok";
        },
        ovalue: function () {
          state = "ocomma";
        },
        firstavalue: function () {
          state = "acomma";
        },
        avalue: function () {
          state = "acomma";
        }
      };
      var action = {

        // The action table describes the behavior of the machine. It contains an
        // object for each token. Each object contains a method that is called when
        // a token is matched in a state. An object will lack a method for illegal
        // states.

        "{": {
          go: function () {
            stack.push({state: "ok"});
            container = {};
            state = "firstokey";
          },
          ovalue: function () {
            stack.push({container: container, state: "ocomma", key: key});
            container = {};
            state = "firstokey";
          },
          firstavalue: function () {
            stack.push({container: container, state: "acomma"});
            container = {};
            state = "firstokey";
          },
          avalue: function () {
            stack.push({container: container, state: "acomma"});
            container = {};
            state = "firstokey";
          }
        },
        "}": {
          firstokey: function () {
            var pop = stack.pop();
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          },
          ocomma: function () {
            var pop = stack.pop();
            container[key] = value;
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          }
        },
        "[": {
          go: function () {
            stack.push({state: "ok"});
            container = [];
            state = "firstavalue";
          },
          ovalue: function () {
            stack.push({container: container, state: "ocomma", key: key});
            container = [];
            state = "firstavalue";
          },
          firstavalue: function () {
            stack.push({container: container, state: "acomma"});
            container = [];
            state = "firstavalue";
          },
          avalue: function () {
            stack.push({container: container, state: "acomma"});
            container = [];
            state = "firstavalue";
          }
        },
        "]": {
          firstavalue: function () {
            var pop = stack.pop();
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          },
          acomma: function () {
            var pop = stack.pop();
            container.push(value);
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          }
        },
        ":": {
          colon: function () {
            if (Object.hasOwnProperty.call(container, key)) {
              throw new SyntaxError("Duplicate key '" + key + "\"");
            }
            state = "ovalue";
          }
        },
        ",": {
          ocomma: function () {
            container[key] = value;
            state = "okey";
          },
          acomma: function () {
            container.push(value);
            state = "avalue";
          }
        },
        "true": {
          go: function () {
            value = true;
            state = "ok";
          },
          ovalue: function () {
            value = true;
            state = "ocomma";
          },
          firstavalue: function () {
            value = true;
            state = "acomma";
          },
          avalue: function () {
            value = true;
            state = "acomma";
          }
        },
        "false": {
          go: function () {
            value = false;
            state = "ok";
          },
          ovalue: function () {
            value = false;
            state = "ocomma";
          },
          firstavalue: function () {
            value = false;
            state = "acomma";
          },
          avalue: function () {
            value = false;
            state = "acomma";
          }
        },
        "null": {
          go: function () {
            value = null;
            state = "ok";
          },
          ovalue: function () {
            value = null;
            state = "ocomma";
          },
          firstavalue: function () {
            value = null;
            state = "acomma";
          },
          avalue: function () {
            value = null;
            state = "acomma";
          }
        }
      };

      function debackslashify(text) {

        // Remove and replace any backslash escapement.

        return text.replace(/\\(?:u(.{4})|([^u]))/g, function (ignore, b, c) {
          return b
            ? String.fromCharCode(parseInt(b, 16))
            : escapes[c];
        });
      }

      return function (source, reviver) {

        // A regular expression is used to extract tokens from the JSON text.
        // The extraction process is cautious.

        var result;
        var tx = /^[\u0020\t\n\r]*(?:([,:\[\]{}]|true|false|null)|(-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)|"((?:[^\r\n\t\\\"]|\\(?:["\\\/trnfb]|u[0-9a-fA-F]{4}))*)")/;

        // Set the starting state.

        state = "go";

        // The stack records the container, key, and state for each object or array
        // that contains another object or array while processing nested structures.

        stack = [];

        // If any error occurs, we will catch it and ultimately throw a syntax error.

        try {

          // For each token...

          while (true) {
            result = tx.exec(source);
            if (!result) {
              break;
            }

            // result is the result array from matching the tokenizing regular expression.
            //  result[0] contains everything that matched, including any initial whitespace.
            //  result[1] contains any punctuation that was matched, or true, false, or null.
            //  result[2] contains a matched number, still in string form.
            //  result[3] contains a matched string, without quotes but with escapement.

            if (result[1]) {

              // Token: Execute the action for this state and token.

              action[result[1]][state]();

            } else if (result[2]) {

              // Number token: Convert the number string into a number value and execute
              // the action for this state and number.

              value = +result[2];
              number[state]();
            } else {

              // String token: Replace the escapement sequences and execute the action for
              // this state and string.

              value = debackslashify(result[3]);
              string[state]();
            }

            // Remove the token from the string. The loop will continue as long as there
            // are tokens. This is a slow process, but it allows the use of ^ matching,
            // which assures that no illegal tokens slip through.

            source = source.slice(result[0].length);
          }

          // If we find a state/token combination that is illegal, then the action will
          // cause an error. We handle the error by simply changing the state.

        } catch (e) {
          state = e;
        }

        // The parsing is finished. If we are not in the final "ok" state, or if the
        // remaining source contains anything except whitespace, then we did not have
        //a well-formed JSON text.

        if (state !== "ok" || (/[^\u0020\t\n\r]/.test(source))) {
          throw (state instanceof SyntaxError)
            ? state
            : new SyntaxError("JSON");
        }

        // If there is a reviver function, we recursively walk the new structure,
        // passing each name/value pair to the reviver function for possible
        // transformation, starting with a temporary root object that holds the current
        // value in an empty key. If there is not a reviver function, we simply return
        // that value.

        return (typeof reviver === "function")
          ? (function walk(holder, key) {
            var k;
            var v;
            var val = holder[key];
            if (val && typeof val === "object") {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(val, k)) {
                  v = walk(val, k);
                  if (v !== undefined) {
                    val[k] = v;
                  } else {
                    delete val[k];
                  }
                }
              }
            }
            return reviver.call(holder, key, val);
          }({"": value}, ""))
        : value;
      };
    }());
  }
}

module.exports = setupCustomJSON;


/***/ }),

/***/ 583:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_174625__) {

var Client = __nested_webpack_require_174625__(949);
var _ = __nested_webpack_require_174625__(585);
var API = __nested_webpack_require_174625__(49);
var logger = __nested_webpack_require_174625__(144);
var globals = __nested_webpack_require_174625__(262);
var Transport = __nested_webpack_require_174625__(751);
var urllib = __nested_webpack_require_174625__(587);
var transforms = __nested_webpack_require_174625__(485);
var sharedTransforms = __nested_webpack_require_174625__(960);
var predicates = __nested_webpack_require_174625__(746);
var sharedPredicates = __nested_webpack_require_174625__(379);
var errorParser = __nested_webpack_require_174625__(136);
var recorderDefaults = __nested_webpack_require_174625__(792);
var tracingDefaults = __nested_webpack_require_174625__(436);
var ReplayMap = (__nested_webpack_require_174625__(287)/* ["default"] */ .A);
function Rollbar(options, client) {
  this.options = _.handleOptions(defaultOptions, options, null, logger);
  this.options._configuredOptions = options;
  var Telemeter = this.components.telemeter;
  var Instrumenter = this.components.instrumenter;
  var polyfillJSON = this.components.polyfillJSON;
  this.wrapGlobals = this.components.wrapGlobals;
  this.scrub = this.components.scrub;
  var truncation = this.components.truncation;
  var Tracing = this.components.tracing;
  var Recorder = this.components.recorder;
  var transport = new Transport(truncation);
  var api = new API(this.options, transport, urllib, truncation);
  if (Tracing) {
    this.tracing = new Tracing(_gWindow(), this.options);
    this.tracing.initSession();
  }
  if (Recorder && _.isBrowser()) {
    var recorderOptions = this.options.recorder;
    this.recorder = new Recorder(recorderOptions);
    this.replayMap = new ReplayMap({
      recorder: this.recorder,
      api: api,
      tracing: this.tracing
    });
    if (recorderOptions.enabled && recorderOptions.autoStart) {
      this.recorder.start();
    }
  }
  if (Telemeter) {
    this.telemeter = new Telemeter(this.options, this.tracing);
  }
  this.client = client || new Client(this.options, api, logger, this.telemeter, this.tracing, this.replayMap, 'browser');
  var gWindow = _gWindow();
  var gDocument = typeof document != 'undefined' && document;
  this.isChrome = gWindow.chrome && gWindow.chrome.runtime; // check .runtime to avoid Edge browsers
  this.anonymousErrorsPending = 0;
  addTransformsToNotifier(this.client.notifier, this, gWindow);
  addPredicatesToQueue(this.client.queue);
  this.setupUnhandledCapture();
  if (Instrumenter) {
    this.instrumenter = new Instrumenter(this.options, this.client.telemeter, this, gWindow, gDocument);
    this.instrumenter.instrument();
  }
  _.setupJSON(polyfillJSON);

  // Used with rollbar-react for rollbar-react-native compatibility.
  this.rollbar = this;
}
var _instance = null;
Rollbar.init = function (options, client) {
  if (_instance) {
    return _instance.global(options).configure(options);
  }
  _instance = new Rollbar(options, client);
  return _instance;
};
Rollbar.prototype.components = {};
Rollbar.setComponents = function (components) {
  Rollbar.prototype.components = components;
};
function handleUninitialized(maybeCallback) {
  var message = 'Rollbar is not initialized';
  logger.error(message);
  if (maybeCallback) {
    maybeCallback(new Error(message));
  }
}
Rollbar.prototype.global = function (options) {
  this.client.global(options);
  return this;
};
Rollbar.global = function (options) {
  if (_instance) {
    return _instance.global(options);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.configure = function (options, payloadData) {
  var _this$recorder;
  var oldOptions = this.options;
  var payload = {};
  if (payloadData) {
    payload = {
      payload: payloadData
    };
  }
  this.options = _.handleOptions(oldOptions, options, payload, logger);
  this.options._configuredOptions = _.handleOptions(oldOptions._configuredOptions, options, payload);
  (_this$recorder = this.recorder) === null || _this$recorder === void 0 || _this$recorder.configure(this.options);
  this.client.configure(this.options, payloadData);
  this.instrumenter && this.instrumenter.configure(this.options);
  this.setupUnhandledCapture();
  return this;
};
Rollbar.configure = function (options, payloadData) {
  if (_instance) {
    return _instance.configure(options, payloadData);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.lastError = function () {
  return this.client.lastError;
};
Rollbar.lastError = function () {
  if (_instance) {
    return _instance.lastError();
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.log = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.log(item);
  return {
    uuid: uuid
  };
};
Rollbar.log = function () {
  if (_instance) {
    return _instance.log.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.debug = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.debug(item);
  return {
    uuid: uuid
  };
};
Rollbar.debug = function () {
  if (_instance) {
    return _instance.debug.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.info = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.info(item);
  return {
    uuid: uuid
  };
};
Rollbar.info = function () {
  if (_instance) {
    return _instance.info.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.warn = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.warn(item);
  return {
    uuid: uuid
  };
};
Rollbar.warn = function () {
  if (_instance) {
    return _instance.warn.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.warning = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.warning(item);
  return {
    uuid: uuid
  };
};
Rollbar.warning = function () {
  if (_instance) {
    return _instance.warning.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.error = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.error(item);
  return {
    uuid: uuid
  };
};
Rollbar.error = function () {
  if (_instance) {
    return _instance.error.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.critical = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.critical(item);
  return {
    uuid: uuid
  };
};
Rollbar.critical = function () {
  if (_instance) {
    return _instance.critical.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.buildJsonPayload = function (item) {
  return this.client.buildJsonPayload(item);
};
Rollbar.buildJsonPayload = function () {
  if (_instance) {
    return _instance.buildJsonPayload.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.sendJsonPayload = function (jsonPayload) {
  return this.client.sendJsonPayload(jsonPayload);
};
Rollbar.sendJsonPayload = function () {
  if (_instance) {
    return _instance.sendJsonPayload.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.setupUnhandledCapture = function () {
  var gWindow = _gWindow();
  if (!this.unhandledExceptionsInitialized) {
    if (this.options.captureUncaught || this.options.handleUncaughtExceptions) {
      globals.captureUncaughtExceptions(gWindow, this);
      if (this.wrapGlobals && this.options.wrapGlobalEventHandlers) {
        this.wrapGlobals(gWindow, this);
      }
      this.unhandledExceptionsInitialized = true;
    }
  }
  if (!this.unhandledRejectionsInitialized) {
    if (this.options.captureUnhandledRejections || this.options.handleUnhandledRejections) {
      globals.captureUnhandledRejections(gWindow, this);
      this.unhandledRejectionsInitialized = true;
    }
  }
};
Rollbar.prototype.handleUncaughtException = function (message, url, lineno, colno, error, context) {
  if (!this.options.captureUncaught && !this.options.handleUncaughtExceptions) {
    return;
  }

  // Chrome will always send 5+ arguments and error will be valid or null, not undefined.
  // If error is undefined, we have a different caller.
  // Chrome also sends errors from web workers with null error, but does not invoke
  // prepareStackTrace() for these. Test for empty url to skip them.
  if (this.options.inspectAnonymousErrors && this.isChrome && error === null && url === '') {
    return 'anonymous';
  }
  var item;
  var stackInfo = _.makeUnhandledStackInfo(message, url, lineno, colno, error, 'onerror', 'uncaught exception', errorParser);
  if (_.isError(error)) {
    item = this._createItem([message, error, context]);
    item._unhandledStackInfo = stackInfo;
  } else if (_.isError(url)) {
    item = this._createItem([message, url, context]);
    item._unhandledStackInfo = stackInfo;
  } else {
    item = this._createItem([message, context]);
    item.stackInfo = stackInfo;
  }
  item.level = this.options.uncaughtErrorLevel;
  item._isUncaught = true;
  this.client.log(item);
};

/**
 * Chrome only. Other browsers will ignore.
 *
 * Use Error.prepareStackTrace to extract information about errors that
 * do not have a valid error object in onerror().
 *
 * In tested version of Chrome, onerror is called first but has no way
 * to communicate with prepareStackTrace. Use a counter to let this
 * handler know which errors to send to Rollbar.
 *
 * In config options, set inspectAnonymousErrors to enable.
 */
Rollbar.prototype.handleAnonymousErrors = function () {
  if (!this.options.inspectAnonymousErrors || !this.isChrome) {
    return;
  }
  var r = this;
  function prepareStackTrace(error, _stack) {
    if (r.options.inspectAnonymousErrors) {
      if (r.anonymousErrorsPending) {
        // This is the only known way to detect that onerror saw an anonymous error.
        // It depends on onerror reliably being called before Error.prepareStackTrace,
        // which so far holds true on tested versions of Chrome. If versions of Chrome
        // are tested that behave differently, this logic will need to be updated
        // accordingly.
        r.anonymousErrorsPending -= 1;
        if (!error) {
          // Not likely to get here, but calling handleUncaughtException from here
          // without an error object would throw off the anonymousErrorsPending counter,
          // so return now.
          return;
        }

        // Allow this to be tracked later.
        error._isAnonymous = true;

        // url, lineno, colno shouldn't be needed for these errors.
        // If that changes, update this accordingly, using the unused
        // _stack param as needed (rather than parse error.toString()).
        r.handleUncaughtException(error.message, null, null, null, error);
      }
    }

    // Workaround to ensure stack is preserved for normal errors.
    return error.stack;
  }

  // https://v8.dev/docs/stack-trace-api
  try {
    Error.prepareStackTrace = prepareStackTrace;
  } catch (e) {
    this.options.inspectAnonymousErrors = false;
    this.error('anonymous error handler failed', e);
  }
};
Rollbar.prototype.handleUnhandledRejection = function (reason, promise) {
  if (!this.options.captureUnhandledRejections && !this.options.handleUnhandledRejections) {
    return;
  }
  var message = 'unhandled rejection was null or undefined!';
  if (reason) {
    if (reason.message) {
      message = reason.message;
    } else {
      var reasonResult = _.stringify(reason);
      if (reasonResult.value) {
        message = reasonResult.value;
      }
    }
  }
  var context = reason && reason._rollbarContext || promise && promise._rollbarContext;
  var item;
  if (_.isError(reason)) {
    item = this._createItem([message, reason, context]);
  } else {
    item = this._createItem([message, reason, context]);
    item.stackInfo = _.makeUnhandledStackInfo(message, '', 0, 0, null, 'unhandledrejection', '', errorParser);
  }
  item.level = this.options.uncaughtErrorLevel;
  item._isUncaught = true;
  item._originalArgs = item._originalArgs || [];
  item._originalArgs.push(promise);
  this.client.log(item);
};
Rollbar.prototype.wrap = function (f, context, _before) {
  try {
    var ctxFn;
    if (_.isFunction(context)) {
      ctxFn = context;
    } else {
      ctxFn = function ctxFn() {
        return context || {};
      };
    }
    if (!_.isFunction(f)) {
      return f;
    }
    if (f._isWrap) {
      return f;
    }
    if (!f._rollbar_wrapped) {
      f._rollbar_wrapped = function () {
        if (_before && _.isFunction(_before)) {
          _before.apply(this, arguments);
        }
        try {
          return f.apply(this, arguments);
        } catch (exc) {
          var e = exc;
          if (e && window._rollbarWrappedError !== e) {
            if (_.isType(e, 'string')) {
              e = new String(e);
            }
            e._rollbarContext = ctxFn() || {};
            e._rollbarContext._wrappedSource = f.toString();
            window._rollbarWrappedError = e;
          }
          throw e;
        }
      };
      f._rollbar_wrapped._isWrap = true;
      if (f.hasOwnProperty) {
        for (var prop in f) {
          if (f.hasOwnProperty(prop) && prop !== '_rollbar_wrapped') {
            f._rollbar_wrapped[prop] = f[prop];
          }
        }
      }
    }
    return f._rollbar_wrapped;
  } catch (e) {
    // Return the original function if the wrap fails.
    return f;
  }
};
Rollbar.wrap = function (f, context) {
  if (_instance) {
    return _instance.wrap(f, context);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.captureEvent = function () {
  var event = _.createTelemetryEvent(arguments);
  return this.client.captureEvent(event.type, event.metadata, event.level);
};
Rollbar.captureEvent = function () {
  if (_instance) {
    return _instance.captureEvent.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};

// The following two methods are used internally and are not meant for public use
Rollbar.prototype.captureDomContentLoaded = function (e, ts) {
  if (!ts) {
    ts = new Date();
  }
  return this.client.captureDomContentLoaded(ts);
};
Rollbar.prototype.captureLoad = function (e, ts) {
  if (!ts) {
    ts = new Date();
  }
  return this.client.captureLoad(ts);
};

/* Internal */

function addTransformsToNotifier(notifier, rollbar, gWindow) {
  notifier.addTransform(transforms.handleDomException).addTransform(transforms.handleItemWithError).addTransform(transforms.ensureItemHasSomethingToSay).addTransform(transforms.addBaseInfo).addTransform(transforms.addRequestInfo(gWindow)).addTransform(transforms.addClientInfo(gWindow)).addTransform(transforms.addPluginInfo(gWindow)).addTransform(transforms.addBody).addTransform(sharedTransforms.addMessageWithError).addTransform(sharedTransforms.addTelemetryData).addTransform(sharedTransforms.addConfigToPayload).addTransform(transforms.addScrubber(rollbar.scrub)).addTransform(sharedTransforms.addPayloadOptions).addTransform(sharedTransforms.userTransform(logger)).addTransform(sharedTransforms.addConfiguredOptions).addTransform(sharedTransforms.addDiagnosticKeys).addTransform(sharedTransforms.itemToPayload);
}
function addPredicatesToQueue(queue) {
  queue.addPredicate(sharedPredicates.checkLevel).addPredicate(predicates.checkIgnore).addPredicate(sharedPredicates.userCheckIgnore(logger)).addPredicate(sharedPredicates.urlIsNotBlockListed(logger)).addPredicate(sharedPredicates.urlIsSafeListed(logger)).addPredicate(sharedPredicates.messageIsIgnored(logger));
}
Rollbar.prototype.loadFull = function () {
  logger.info('Unexpected Rollbar.loadFull() called on a Notifier instance. This can happen when Rollbar is loaded multiple times.');
};
Rollbar.prototype._createItem = function (args) {
  return _.createItem(args, logger, this);
};
function _getFirstFunction(args) {
  for (var i = 0, len = args.length; i < len; ++i) {
    if (_.isFunction(args[i])) {
      return args[i];
    }
  }
  return undefined;
}
function _gWindow() {
  return typeof window != 'undefined' && window || typeof self != 'undefined' && self;
}
var defaults = __nested_webpack_require_174625__(299);
var scrubFields = __nested_webpack_require_174625__(699);
var defaultOptions = {
  version: defaults.version,
  scrubFields: scrubFields.scrubFields,
  logLevel: defaults.logLevel,
  reportLevel: defaults.reportLevel,
  uncaughtErrorLevel: defaults.uncaughtErrorLevel,
  endpoint: defaults.endpoint,
  verbose: false,
  enabled: true,
  transmit: true,
  sendConfig: false,
  includeItemsInTelemetry: true,
  captureIp: true,
  inspectAnonymousErrors: true,
  ignoreDuplicateErrors: true,
  wrapGlobalEventHandlers: false,
  recorder: recorderDefaults,
  tracing: tracingDefaults
};
module.exports = Rollbar;

/***/ }),

/***/ 585:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_192038__) {

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var merge = __nested_webpack_require_192038__(965);
var RollbarJSON = {};
function setupJSON(polyfillJSON) {
  if (isFunction(RollbarJSON.stringify) && isFunction(RollbarJSON.parse)) {
    return;
  }
  if (isDefined(JSON)) {
    // If polyfill is provided, prefer it over existing non-native shims.
    if (polyfillJSON) {
      if (isNativeFunction(JSON.stringify)) {
        RollbarJSON.stringify = JSON.stringify;
      }
      if (isNativeFunction(JSON.parse)) {
        RollbarJSON.parse = JSON.parse;
      }
    } else {
      // else accept any interface that is present.
      if (isFunction(JSON.stringify)) {
        RollbarJSON.stringify = JSON.stringify;
      }
      if (isFunction(JSON.parse)) {
        RollbarJSON.parse = JSON.parse;
      }
    }
  }
  if (!isFunction(RollbarJSON.stringify) || !isFunction(RollbarJSON.parse)) {
    polyfillJSON && polyfillJSON(RollbarJSON);
  }
}

/*
 * isType - Given a Javascript value and a string, returns true if the type of the value matches the
 * given string.
 *
 * @param x - any value
 * @param t - a lowercase string containing one of the following type names:
 *    - undefined
 *    - null
 *    - error
 *    - number
 *    - boolean
 *    - string
 *    - symbol
 *    - function
 *    - object
 *    - array
 * @returns true if x is of type t, otherwise false
 */
function isType(x, t) {
  return t === typeName(x);
}

/*
 * typeName - Given a Javascript value, returns the type of the object as a string
 */
function typeName(x) {
  var name = _typeof(x);
  if (name !== 'object') {
    return name;
  }
  if (!x) {
    return 'null';
  }
  if (x instanceof Error) {
    return 'error';
  }
  return {}.toString.call(x).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}

/* isFunction - a convenience function for checking if a value is a function
 *
 * @param f - any value
 * @returns true if f is a function, otherwise false
 */
function isFunction(f) {
  return isType(f, 'function');
}

/* isNativeFunction - a convenience function for checking if a value is a native JS function
 *
 * @param f - any value
 * @returns true if f is a native JS function, otherwise false
 */
function isNativeFunction(f) {
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var funcMatchString = Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?');
  var reIsNative = RegExp('^' + funcMatchString + '$');
  return isObject(f) && reIsNative.test(f);
}

/* isObject - Checks if the argument is an object
 *
 * @param value - any value
 * @returns true is value is an object function is an object)
 */
function isObject(value) {
  var type = _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

/* isString - Checks if the argument is a string
 *
 * @param value - any value
 * @returns true if value is a string
 */
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}

/**
 * isFiniteNumber - determines whether the passed value is a finite number
 *
 * @param {*} n - any value
 * @returns true if value is a finite number
 */
function isFiniteNumber(n) {
  return Number.isFinite(n);
}

/*
 * isDefined - a convenience function for checking if a value is not equal to undefined
 *
 * @param u - any value
 * @returns true if u is anything other than undefined
 */
function isDefined(u) {
  return !isType(u, 'undefined');
}

/*
 * isIterable - convenience function for checking if a value can be iterated, essentially
 * whether it is an object or an array.
 *
 * @param i - any value
 * @returns true if i is an object or an array as determined by `typeName`
 */
function isIterable(i) {
  var type = typeName(i);
  return type === 'object' || type === 'array';
}

/*
 * isError - convenience function for checking if a value is of an error type
 *
 * @param e - any value
 * @returns true if e is an error
 */
function isError(e) {
  // Detect both Error and Firefox Exception type
  return isType(e, 'error') || isType(e, 'exception');
}

/* isPromise - a convenience function for checking if a value is a promise
 *
 * @param p - any value
 * @returns true if f is a function, otherwise false
 */
function isPromise(p) {
  return isObject(p) && isType(p.then, 'function');
}

/**
 * isBrowser - a convenience function for checking if the code is running in a browser
 *
 * @returns true if the code is running in a browser environment
 */
function isBrowser() {
  return typeof window !== 'undefined';
}
function redact() {
  return '********';
}

// from http://stackoverflow.com/a/8809472/1138191
function uuid4() {
  var d = now();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
  });
  return uuid;
}
var LEVELS = {
  debug: 0,
  info: 1,
  warning: 2,
  error: 3,
  critical: 4
};
function sanitizeUrl(url) {
  var baseUrlParts = parseUri(url);
  if (!baseUrlParts) {
    return '(unknown)';
  }

  // remove a trailing # if there is no anchor
  if (baseUrlParts.anchor === '') {
    baseUrlParts.source = baseUrlParts.source.replace('#', '');
  }
  url = baseUrlParts.source.replace('?' + baseUrlParts.query, '');
  return url;
}
var parseUriOptions = {
  strictMode: false,
  key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
  q: {
    name: 'queryKey',
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};
function parseUri(str) {
  if (!isType(str, 'string')) {
    return undefined;
  }
  var o = parseUriOptions;
  var m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str);
  var uri = {};
  for (var i = 0, l = o.key.length; i < l; ++i) {
    uri[o.key[i]] = m[i] || '';
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) {
      uri[o.q.name][$1] = $2;
    }
  });
  return uri;
}
function addParamsAndAccessTokenToPath(accessToken, options, params) {
  params = params || {};
  params.access_token = accessToken;
  var paramsArray = [];
  var k;
  for (k in params) {
    if (Object.prototype.hasOwnProperty.call(params, k)) {
      paramsArray.push([k, params[k]].join('='));
    }
  }
  var query = '?' + paramsArray.sort().join('&');
  options = options || {};
  options.path = options.path || '';
  var qs = options.path.indexOf('?');
  var h = options.path.indexOf('#');
  var p;
  if (qs !== -1 && (h === -1 || h > qs)) {
    p = options.path;
    options.path = p.substring(0, qs) + query + '&' + p.substring(qs + 1);
  } else {
    if (h !== -1) {
      p = options.path;
      options.path = p.substring(0, h) + query + p.substring(h);
    } else {
      options.path = options.path + query;
    }
  }
}
function formatUrl(u, protocol) {
  protocol = protocol || u.protocol;
  if (!protocol && u.port) {
    if (u.port === 80) {
      protocol = 'http:';
    } else if (u.port === 443) {
      protocol = 'https:';
    }
  }
  protocol = protocol || 'https:';
  if (!u.hostname) {
    return null;
  }
  var result = protocol + '//' + u.hostname;
  if (u.port) {
    result = result + ':' + u.port;
  }
  if (u.path) {
    result = result + u.path;
  }
  return result;
}
function stringify(obj, backup) {
  var value, error;
  try {
    value = RollbarJSON.stringify(obj);
  } catch (jsonError) {
    if (backup && isFunction(backup)) {
      try {
        value = backup(obj);
      } catch (backupError) {
        error = backupError;
      }
    } else {
      error = jsonError;
    }
  }
  return {
    error: error,
    value: value
  };
}
function maxByteSize(string) {
  // The transport will use utf-8, so assume utf-8 encoding.
  //
  // This minimal implementation will accurately count bytes for all UCS-2 and
  // single code point UTF-16. If presented with multi code point UTF-16,
  // which should be rare, it will safely overcount, not undercount.
  //
  // While robust utf-8 encoders exist, this is far smaller and far more performant.
  // For quickly counting payload size for truncation, smaller is better.

  var count = 0;
  var length = string.length;
  for (var i = 0; i < length; i++) {
    var code = string.charCodeAt(i);
    if (code < 128) {
      // up to 7 bits
      count = count + 1;
    } else if (code < 2048) {
      // up to 11 bits
      count = count + 2;
    } else if (code < 65536) {
      // up to 16 bits
      count = count + 3;
    }
  }
  return count;
}
function jsonParse(s) {
  var value, error;
  try {
    value = RollbarJSON.parse(s);
  } catch (e) {
    error = e;
  }
  return {
    error: error,
    value: value
  };
}
function makeUnhandledStackInfo(message, url, lineno, colno, error, mode, backupMessage, errorParser) {
  var location = {
    url: url || '',
    line: lineno,
    column: colno
  };
  location.func = errorParser.guessFunctionName(location.url, location.line);
  location.context = errorParser.gatherContext(location.url, location.line);
  var href = typeof document !== 'undefined' && document && document.location && document.location.href;
  var useragent = typeof window !== 'undefined' && window && window.navigator && window.navigator.userAgent;
  return {
    mode: mode,
    message: error ? String(error) : message || backupMessage,
    url: href,
    stack: [location],
    useragent: useragent
  };
}
function wrapCallback(logger, f) {
  return function (err, resp) {
    try {
      f(err, resp);
    } catch (e) {
      logger.error(e);
    }
  };
}
function nonCircularClone(obj) {
  var seen = [obj];
  function clone(obj, seen) {
    var value,
      name,
      newSeen,
      result = {};
    try {
      for (name in obj) {
        value = obj[name];
        if (value && (isType(value, 'object') || isType(value, 'array'))) {
          if (seen.includes(value)) {
            result[name] = 'Removed circular reference: ' + typeName(value);
          } else {
            newSeen = seen.slice();
            newSeen.push(value);
            result[name] = clone(value, newSeen);
          }
          continue;
        }
        result[name] = value;
      }
    } catch (e) {
      result = 'Failed cloning custom data: ' + e.message;
    }
    return result;
  }
  return clone(obj, seen);
}
function createItem(args, logger, notifier, requestKeys, lambdaContext) {
  var message, err, custom, callback, request;
  var arg;
  var extraArgs = [];
  var diagnostic = {};
  var argTypes = [];
  for (var i = 0, l = args.length; i < l; ++i) {
    arg = args[i];
    var typ = typeName(arg);
    argTypes.push(typ);
    switch (typ) {
      case 'undefined':
        break;
      case 'string':
        message ? extraArgs.push(arg) : message = arg;
        break;
      case 'function':
        callback = wrapCallback(logger, arg);
        break;
      case 'date':
        extraArgs.push(arg);
        break;
      case 'error':
      case 'domexception':
      case 'exception':
        // Firefox Exception type
        err ? extraArgs.push(arg) : err = arg;
        break;
      case 'object':
      case 'array':
        if (arg instanceof Error || typeof DOMException !== 'undefined' && arg instanceof DOMException) {
          err ? extraArgs.push(arg) : err = arg;
          break;
        }
        if (requestKeys && typ === 'object' && !request) {
          for (var j = 0, len = requestKeys.length; j < len; ++j) {
            if (arg[requestKeys[j]] !== undefined) {
              request = arg;
              break;
            }
          }
          if (request) {
            break;
          }
        }
        custom ? extraArgs.push(arg) : custom = arg;
        break;
      default:
        if (arg instanceof Error || typeof DOMException !== 'undefined' && arg instanceof DOMException) {
          err ? extraArgs.push(arg) : err = arg;
          break;
        }
        extraArgs.push(arg);
    }
  }

  // if custom is an array this turns it into an object with integer keys
  if (custom) custom = nonCircularClone(custom);
  if (extraArgs.length > 0) {
    if (!custom) custom = nonCircularClone({});
    custom.extraArgs = nonCircularClone(extraArgs);
  }
  var item = {
    message: message,
    err: err,
    custom: custom,
    timestamp: now(),
    callback: callback,
    notifier: notifier,
    diagnostic: diagnostic,
    uuid: uuid4()
  };
  item.data = item.data || {};
  setCustomItemKeys(item, custom);
  if (requestKeys && request) {
    item.request = request;
  }
  if (lambdaContext) {
    item.lambdaContext = lambdaContext;
  }
  item._originalArgs = args;
  item.diagnostic.original_arg_types = argTypes;
  return item;
}
function setCustomItemKeys(item, custom) {
  if (custom && custom.level !== undefined) {
    item.level = custom.level;
    delete custom.level;
  }
  if (custom && custom.skipFrames !== undefined) {
    item.skipFrames = custom.skipFrames;
    delete custom.skipFrames;
  }
}
function addErrorContext(item, errors) {
  var custom = item.data.custom || {};
  var contextAdded = false;
  try {
    for (var i = 0; i < errors.length; ++i) {
      if (errors[i].hasOwnProperty('rollbarContext')) {
        custom = merge(custom, nonCircularClone(errors[i].rollbarContext));
        contextAdded = true;
      }
    }

    // Avoid adding an empty object to the data.
    if (contextAdded) {
      item.data.custom = custom;
    }
  } catch (e) {
    item.diagnostic.error_context = 'Failed: ' + e.message;
  }
}
var TELEMETRY_TYPES = ['log', 'network', 'dom', 'navigation', 'error', 'manual'];
var TELEMETRY_LEVELS = ['critical', 'error', 'warning', 'info', 'debug'];
function arrayIncludes(arr, val) {
  for (var k = 0; k < arr.length; ++k) {
    if (arr[k] === val) {
      return true;
    }
  }
  return false;
}
function createTelemetryEvent(args) {
  var type, metadata, level;
  var arg;
  for (var i = 0, l = args.length; i < l; ++i) {
    arg = args[i];
    var typ = typeName(arg);
    switch (typ) {
      case 'string':
        if (!type && arrayIncludes(TELEMETRY_TYPES, arg)) {
          type = arg;
        } else if (!level && arrayIncludes(TELEMETRY_LEVELS, arg)) {
          level = arg;
        }
        break;
      case 'object':
        metadata = arg;
        break;
      default:
        break;
    }
  }
  var event = {
    type: type || 'manual',
    metadata: metadata || {},
    level: level
  };
  return event;
}
function addItemAttributes(item, attributes) {
  item.data.attributes = item.data.attributes || [];
  if (attributes) {
    var _item$data$attributes;
    (_item$data$attributes = item.data.attributes).push.apply(_item$data$attributes, _toConsumableArray(attributes));
  }
}

/*
 * get - given an obj/array and a keypath, return the value at that keypath or
 *       undefined if not possible.
 *
 * @param obj - an object or array
 * @param path - a string of keys separated by '.' such as 'plugin.jquery.0.message'
 *    which would correspond to 42 in `{plugin: {jquery: [{message: 42}]}}`
 */
function get(obj, path) {
  if (!obj) {
    return undefined;
  }
  var keys = path.split('.');
  var result = obj;
  try {
    for (var i = 0, len = keys.length; i < len; ++i) {
      result = result[keys[i]];
    }
  } catch (e) {
    result = undefined;
  }
  return result;
}
function set(obj, path, value) {
  if (!obj) {
    return;
  }
  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {
    obj[keys[0]] = value;
    return;
  }
  try {
    var temp = obj[keys[0]] || {};
    var replacement = temp;
    for (var i = 1; i < len - 1; ++i) {
      temp[keys[i]] = temp[keys[i]] || {};
      temp = temp[keys[i]];
    }
    temp[keys[len - 1]] = value;
    obj[keys[0]] = replacement;
  } catch (e) {
    return;
  }
}
function formatArgsAsString(args) {
  var i, len, arg;
  var result = [];
  for (i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    switch (typeName(arg)) {
      case 'object':
        arg = stringify(arg);
        arg = arg.error || arg.value;
        if (arg.length > 500) {
          arg = arg.substr(0, 497) + '...';
        }
        break;
      case 'null':
        arg = 'null';
        break;
      case 'undefined':
        arg = 'undefined';
        break;
      case 'symbol':
        arg = arg.toString();
        break;
    }
    result.push(arg);
  }
  return result.join(' ');
}
function now() {
  if (Date.now) {
    return +Date.now();
  }
  return +new Date();
}
function filterIp(requestData, captureIp) {
  if (!requestData || !requestData['user_ip'] || captureIp === true) {
    return;
  }
  var newIp = requestData['user_ip'];
  if (!captureIp) {
    newIp = null;
  } else {
    try {
      var parts;
      if (newIp.indexOf('.') !== -1) {
        parts = newIp.split('.');
        parts.pop();
        parts.push('0');
        newIp = parts.join('.');
      } else if (newIp.indexOf(':') !== -1) {
        parts = newIp.split(':');
        if (parts.length > 2) {
          var beginning = parts.slice(0, 3);
          var slashIdx = beginning[2].indexOf('/');
          if (slashIdx !== -1) {
            beginning[2] = beginning[2].substring(0, slashIdx);
          }
          var terminal = '0000:0000:0000:0000:0000';
          newIp = beginning.concat(terminal).join(':');
        }
      } else {
        newIp = null;
      }
    } catch (e) {
      newIp = null;
    }
  }
  requestData['user_ip'] = newIp;
}
function handleOptions(current, input, payload, logger) {
  var result = merge(current, input, payload);
  result = updateDeprecatedOptions(result, logger);
  if (!input || input.overwriteScrubFields) {
    return result;
  }
  if (input.scrubFields) {
    result.scrubFields = (current.scrubFields || []).concat(input.scrubFields);
  }
  return result;
}
function updateDeprecatedOptions(options, logger) {
  if (options.hostWhiteList && !options.hostSafeList) {
    options.hostSafeList = options.hostWhiteList;
    options.hostWhiteList = undefined;
    logger && logger.log('hostWhiteList is deprecated. Use hostSafeList.');
  }
  if (options.hostBlackList && !options.hostBlockList) {
    options.hostBlockList = options.hostBlackList;
    options.hostBlackList = undefined;
    logger && logger.log('hostBlackList is deprecated. Use hostBlockList.');
  }
  return options;
}
module.exports = {
  addParamsAndAccessTokenToPath: addParamsAndAccessTokenToPath,
  createItem: createItem,
  addErrorContext: addErrorContext,
  createTelemetryEvent: createTelemetryEvent,
  addItemAttributes: addItemAttributes,
  filterIp: filterIp,
  formatArgsAsString: formatArgsAsString,
  formatUrl: formatUrl,
  get: get,
  handleOptions: handleOptions,
  isError: isError,
  isFiniteNumber: isFiniteNumber,
  isFunction: isFunction,
  isIterable: isIterable,
  isNativeFunction: isNativeFunction,
  isObject: isObject,
  isString: isString,
  isType: isType,
  isPromise: isPromise,
  isBrowser: isBrowser,
  jsonParse: jsonParse,
  LEVELS: LEVELS,
  makeUnhandledStackInfo: makeUnhandledStackInfo,
  merge: merge,
  now: now,
  redact: redact,
  RollbarJSON: RollbarJSON,
  sanitizeUrl: sanitizeUrl,
  set: set,
  setupJSON: setupJSON,
  stringify: stringify,
  maxByteSize: maxByteSize,
  typeName: typeName,
  uuid4: uuid4
};

/***/ }),

/***/ 587:
/***/ (function(module) {

// See https://nodejs.org/docs/latest/api/url.html
function parse(url) {
  var result = {
    protocol: null,
    auth: null,
    host: null,
    path: null,
    hash: null,
    href: url,
    hostname: null,
    port: null,
    pathname: null,
    search: null,
    query: null
  };
  var i, last;
  i = url.indexOf('//');
  if (i !== -1) {
    result.protocol = url.substring(0, i);
    last = i + 2;
  } else {
    last = 0;
  }
  i = url.indexOf('@', last);
  if (i !== -1) {
    result.auth = url.substring(last, i);
    last = i + 1;
  }
  i = url.indexOf('/', last);
  if (i === -1) {
    i = url.indexOf('?', last);
    if (i === -1) {
      i = url.indexOf('#', last);
      if (i === -1) {
        result.host = url.substring(last);
      } else {
        result.host = url.substring(last, i);
        result.hash = url.substring(i);
      }
      result.hostname = result.host.split(':')[0];
      result.port = result.host.split(':')[1];
      if (result.port) {
        result.port = parseInt(result.port, 10);
      }
      return result;
    } else {
      result.host = url.substring(last, i);
      result.hostname = result.host.split(':')[0];
      result.port = result.host.split(':')[1];
      if (result.port) {
        result.port = parseInt(result.port, 10);
      }
      last = i;
    }
  } else {
    result.host = url.substring(last, i);
    result.hostname = result.host.split(':')[0];
    result.port = result.host.split(':')[1];
    if (result.port) {
      result.port = parseInt(result.port, 10);
    }
    last = i;
  }
  i = url.indexOf('#', last);
  if (i === -1) {
    result.path = url.substring(last);
  } else {
    result.path = url.substring(last, i);
    result.hash = url.substring(i);
  }
  if (result.path) {
    var pathParts = result.path.split('?');
    result.pathname = pathParts[0];
    result.query = pathParts[1];
    result.search = result.query ? '?' + result.query : null;
  }
  return result;
}
module.exports = {
  parse: parse
};

/***/ }),

/***/ 618:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_215300__) {

var _ = __nested_webpack_require_215300__(585);
var MAX_EVENTS = 100;

// Temporary workaround while solving commonjs -> esm issues in Node 18 - 20.
function fromMillis(millis) {
  return [Math.trunc(millis / 1000), Math.round(millis % 1000 * 1e6)];
}
function Telemeter(options, tracing) {
  var _this$tracing;
  this.queue = [];
  this.options = _.merge(options);
  var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
  this.maxQueueSize = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
  this.tracing = tracing;
  this.telemetrySpan = (_this$tracing = this.tracing) === null || _this$tracing === void 0 ? void 0 : _this$tracing.startSpan('rollbar-telemetry', {});
}
Telemeter.prototype.configure = function (options) {
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
  var newMaxEvents = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
  var deleteCount = 0;
  if (this.queue.length > newMaxEvents) {
    deleteCount = this.queue.length - newMaxEvents;
  }
  this.maxQueueSize = newMaxEvents;
  this.queue.splice(0, deleteCount);
};
Telemeter.prototype.copyEvents = function () {
  var events = Array.prototype.slice.call(this.queue, 0);
  if (_.isFunction(this.options.filterTelemetry)) {
    try {
      var i = events.length;
      while (i--) {
        if (this.options.filterTelemetry(events[i])) {
          events.splice(i, 1);
        }
      }
    } catch (e) {
      this.options.filterTelemetry = null;
    }
  }
  return events;
};
Telemeter.prototype.capture = function (type, metadata, level, rollbarUUID, timestamp) {
  var e = {
    level: getLevel(type, level),
    type: type,
    timestamp_ms: timestamp || _.now(),
    body: metadata,
    source: 'client'
  };
  if (rollbarUUID) {
    e.uuid = rollbarUUID;
  }
  try {
    if (_.isFunction(this.options.filterTelemetry) && this.options.filterTelemetry(e)) {
      return false;
    }
  } catch (exc) {
    this.options.filterTelemetry = null;
  }
  this.push(e);
  return e;
};
Telemeter.prototype.captureEvent = function (type, metadata, level, rollbarUUID) {
  return this.capture(type, metadata, level, rollbarUUID);
};
Telemeter.prototype.captureError = function (err, level, rollbarUUID, timestamp) {
  var _this$telemetrySpan;
  var message = err.message || String(err);
  var metadata = {
    message: message
  };
  if (err.stack) {
    metadata.stack = err.stack;
  }
  (_this$telemetrySpan = this.telemetrySpan) === null || _this$telemetrySpan === void 0 || _this$telemetrySpan.addEvent('rollbar-occurrence-event', {
    message: message,
    level: level,
    type: 'error',
    uuid: rollbarUUID,
    'occurrence.type': 'error',
    // deprecated
    'occurrence.uuid': rollbarUUID // deprecated
  }, fromMillis(timestamp));
  return this.capture('error', metadata, level, rollbarUUID, timestamp);
};
Telemeter.prototype.captureLog = function (message, level, rollbarUUID, timestamp) {
  // If the uuid is present, this is a message occurrence.
  if (rollbarUUID) {
    var _this$telemetrySpan2;
    (_this$telemetrySpan2 = this.telemetrySpan) === null || _this$telemetrySpan2 === void 0 || _this$telemetrySpan2.addEvent('rollbar-occurrence-event', {
      message: message,
      level: level,
      type: 'message',
      uuid: rollbarUUID,
      'occurrence.type': 'message',
      // deprecated
      'occurrence.uuid': rollbarUUID // deprecated
    }, fromMillis(timestamp));
  } else {
    var _this$telemetrySpan3;
    (_this$telemetrySpan3 = this.telemetrySpan) === null || _this$telemetrySpan3 === void 0 || _this$telemetrySpan3.addEvent('log-event', {
      message: message,
      level: level
    }, fromMillis(timestamp));
  }
  return this.capture('log', {
    message: message
  }, level, rollbarUUID, timestamp);
};
Telemeter.prototype.captureNetwork = function (metadata, subtype, rollbarUUID, requestData) {
  subtype = subtype || 'xhr';
  metadata.subtype = metadata.subtype || subtype;
  if (requestData) {
    metadata.request = requestData;
  }
  var level = this.levelFromStatus(metadata.status_code);
  return this.capture('network', metadata, level, rollbarUUID);
};
Telemeter.prototype.levelFromStatus = function (statusCode) {
  if (statusCode >= 200 && statusCode < 400) {
    return 'info';
  }
  if (statusCode === 0 || statusCode >= 400) {
    return 'error';
  }
  return 'info';
};
Telemeter.prototype.captureDom = function (subtype, element, value, checked, rollbarUUID) {
  var metadata = {
    subtype: subtype,
    element: element
  };
  if (value !== undefined) {
    metadata.value = value;
  }
  if (checked !== undefined) {
    metadata.checked = checked;
  }
  return this.capture('dom', metadata, 'info', rollbarUUID);
};
Telemeter.prototype.captureNavigation = function (from, to, rollbarUUID, timestamp) {
  var _this$telemetrySpan4;
  (_this$telemetrySpan4 = this.telemetrySpan) === null || _this$telemetrySpan4 === void 0 || _this$telemetrySpan4.addEvent('session-navigation-event', {
    'previous.url.full': from,
    'url.full': to
  }, fromMillis(timestamp));
  return this.capture('navigation', {
    from: from,
    to: to
  }, 'info', rollbarUUID, timestamp);
};
Telemeter.prototype.captureDomContentLoaded = function (ts) {
  return this.capture('navigation', {
    subtype: 'DOMContentLoaded'
  }, 'info', undefined, ts && ts.getTime());
  /**
   * If we decide to make this a dom event instead, then use the line below:
  return this.capture('dom', {subtype: 'DOMContentLoaded'}, 'info', undefined, ts && ts.getTime());
  */
};
Telemeter.prototype.captureLoad = function (ts) {
  return this.capture('navigation', {
    subtype: 'load'
  }, 'info', undefined, ts && ts.getTime());
  /**
   * If we decide to make this a dom event instead, then use the line below:
  return this.capture('dom', {subtype: 'load'}, 'info', undefined, ts && ts.getTime());
  */
};
Telemeter.prototype.captureConnectivityChange = function (type, rollbarUUID) {
  return this.captureNetwork({
    change: type
  }, 'connectivity', rollbarUUID);
};

// Only intended to be used internally by the notifier
Telemeter.prototype._captureRollbarItem = function (item) {
  if (!this.options.includeItemsInTelemetry) {
    return;
  }
  if (item.err) {
    return this.captureError(item.err, item.level, item.uuid, item.timestamp);
  }
  if (item.message) {
    return this.captureLog(item.message, item.level, item.uuid, item.timestamp);
  }
  if (item.custom) {
    return this.capture('log', item.custom, item.level, item.uuid, item.timestamp);
  }
};
Telemeter.prototype.push = function (e) {
  this.queue.push(e);
  if (this.queue.length > this.maxQueueSize) {
    this.queue.shift();
  }
};
function getLevel(type, level) {
  if (level) {
    return level;
  }
  var defaultLevel = {
    error: 'error',
    manual: 'info'
  };
  return defaultLevel[type] || 'info';
}
module.exports = Telemeter;

/***/ }),

/***/ 622:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_222340__) {

var _ = __nested_webpack_require_222340__(585);
var traverse = __nested_webpack_require_222340__(98);
function raw(payload, jsonBackup) {
  return [payload, _.stringify(payload, jsonBackup)];
}
function selectFrames(frames, range) {
  var len = frames.length;
  if (len > range * 2) {
    return frames.slice(0, range).concat(frames.slice(len - range));
  }
  return frames;
}
function truncateFrames(payload, jsonBackup, range) {
  range = typeof range === 'undefined' ? 30 : range;
  var body = payload.data.body;
  var frames;
  if (body.trace_chain) {
    var chain = body.trace_chain;
    for (var i = 0; i < chain.length; i++) {
      frames = chain[i].frames;
      frames = selectFrames(frames, range);
      chain[i].frames = frames;
    }
  } else if (body.trace) {
    frames = body.trace.frames;
    frames = selectFrames(frames, range);
    body.trace.frames = frames;
  }
  return [payload, _.stringify(payload, jsonBackup)];
}
function maybeTruncateValue(len, val) {
  if (!val) {
    return val;
  }
  if (val.length > len) {
    return val.slice(0, len - 3).concat('...');
  }
  return val;
}
function truncateStrings(len, payload, jsonBackup) {
  function truncator(k, v, seen) {
    switch (_.typeName(v)) {
      case 'string':
        return maybeTruncateValue(len, v);
      case 'object':
      case 'array':
        return traverse(v, truncator, seen);
      default:
        return v;
    }
  }
  payload = traverse(payload, truncator);
  return [payload, _.stringify(payload, jsonBackup)];
}
function truncateTraceData(traceData) {
  if (traceData.exception) {
    delete traceData.exception.description;
    traceData.exception.message = maybeTruncateValue(255, traceData.exception.message);
  }
  traceData.frames = selectFrames(traceData.frames, 1);
  return traceData;
}
function minBody(payload, jsonBackup) {
  var body = payload.data.body;
  if (body.trace_chain) {
    var chain = body.trace_chain;
    for (var i = 0; i < chain.length; i++) {
      chain[i] = truncateTraceData(chain[i]);
    }
  } else if (body.trace) {
    body.trace = truncateTraceData(body.trace);
  }
  return [payload, _.stringify(payload, jsonBackup)];
}
function needsTruncation(payload, maxSize) {
  return _.maxByteSize(payload) > maxSize;
}
function truncate(payload, jsonBackup, maxSize) {
  maxSize = typeof maxSize === 'undefined' ? 512 * 1024 : maxSize;
  var strategies = [raw, truncateFrames, truncateStrings.bind(null, 1024), truncateStrings.bind(null, 512), truncateStrings.bind(null, 256), minBody];
  var strategy, results, result;
  while (strategy = strategies.shift()) {
    results = strategy(payload, jsonBackup);
    payload = results[0];
    result = results[1];
    if (result.error || !needsTruncation(result.value, maxSize)) {
      return result;
    }
  }
  return result;
}
module.exports = {
  truncate: truncate,
  /* for testing */
  raw: raw,
  truncateFrames: truncateFrames,
  truncateStrings: truncateStrings,
  maybeTruncateValue: maybeTruncateValue
};

/***/ }),

/***/ 629:
/***/ (function(module) {

// This detection.js module is used to encapsulate any ugly browser/feature
// detection we may need to do.

// Figure out which version of IE we're using, if any.
// This is gleaned from http://stackoverflow.com/questions/5574842/best-way-to-check-for-ie-less-than-9-in-javascript-without-library
// Will return an integer on IE (i.e. 8)
// Will return undefined otherwise
function getIEVersion() {
  var undef;
  if (typeof document === 'undefined') {
    return undef;
  }
  var v = 3,
    div = document.createElement('div'),
    all = div.getElementsByTagName('i');
  while (div.innerHTML = '<!--[if gt IE ' + ++v + ']><i></i><![endif]-->', all[0]);
  return v > 4 ? v : undef;
}
var Detection = {
  ieVersion: getIEVersion
};
module.exports = Detection;

/***/ }),

/***/ 657:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_226217__) {

var polyfillJSON = __nested_webpack_require_226217__(538);
module.exports = polyfillJSON;

/***/ }),

/***/ 699:
/***/ (function(module) {

module.exports = {
  scrubFields: ['pw', 'pass', 'passwd', 'password', 'secret', 'confirm_password', 'confirmPassword', 'password_confirmation', 'passwordConfirmation', 'access_token', 'accessToken', 'X-Rollbar-Access-Token', 'secret_key', 'secretKey', 'secretToken', 'cc-number', 'card number', 'cardnumber', 'cardnum', 'ccnum', 'ccnumber', 'cc num', 'creditcardnumber', 'credit card number', 'newcreditcardnumber', 'new credit card', 'creditcardno', 'credit card no', 'card#', 'card #', 'cc-csc', 'cvc', 'cvc2', 'cvv2', 'ccv2', 'security code', 'card verification', 'name on credit card', 'name on card', 'nameoncard', 'cardholder', 'card holder', 'name des karteninhabers', 'ccname', 'card type', 'cardtype', 'cc type', 'cctype', 'payment type', 'expiration date', 'expirationdate', 'expdate', 'cc-exp', 'ccmonth', 'ccyear']
};

/***/ }),

/***/ 705:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_227271__) {

var _ = __nested_webpack_require_227271__(585);
var headers = __nested_webpack_require_227271__(736);
var replace = __nested_webpack_require_227271__(398);
var scrub = __nested_webpack_require_227271__(922);
var urlparser = __nested_webpack_require_227271__(587);
var domUtil = __nested_webpack_require_227271__(392);
var defaults = {
  network: true,
  networkResponseHeaders: false,
  networkResponseBody: false,
  networkRequestHeaders: false,
  networkRequestBody: false,
  networkErrorOnHttp5xx: false,
  networkErrorOnHttp4xx: false,
  networkErrorOnHttp0: false,
  log: true,
  dom: true,
  navigation: true,
  connectivity: true,
  contentSecurityPolicy: true,
  errorOnContentSecurityPolicy: false
};
function restore(replacements, type) {
  var b;
  while (replacements[type].length) {
    b = replacements[type].shift();
    b[0][b[1]] = b[2];
  }
}
function nameFromDescription(description) {
  if (!description || !description.attributes) {
    return null;
  }
  var attrs = description.attributes;
  for (var a = 0; a < attrs.length; ++a) {
    if (attrs[a].key === 'name') {
      return attrs[a].value;
    }
  }
  return null;
}
function defaultValueScrubber(scrubFields) {
  var patterns = [];
  for (var i = 0; i < scrubFields.length; ++i) {
    patterns.push(new RegExp(scrubFields[i], 'i'));
  }
  return function (description) {
    var name = nameFromDescription(description);
    if (!name) {
      return false;
    }
    for (var i = 0; i < patterns.length; ++i) {
      if (patterns[i].test(name)) {
        return true;
      }
    }
    return false;
  };
}
function Instrumenter(options, telemeter, rollbar, _window, _document) {
  this.options = options;
  var autoInstrument = options.autoInstrument;
  if (options.enabled === false || autoInstrument === false) {
    this.autoInstrument = {};
  } else {
    if (!_.isType(autoInstrument, 'object')) {
      autoInstrument = defaults;
    }
    this.autoInstrument = _.merge(defaults, autoInstrument);
  }
  this.scrubTelemetryInputs = !!options.scrubTelemetryInputs;
  this.telemetryScrubber = options.telemetryScrubber;
  this.defaultValueScrubber = defaultValueScrubber(options.scrubFields);
  this.telemeter = telemeter;
  this.rollbar = rollbar;
  this.diagnostic = rollbar.client.notifier.diagnostic;
  this._window = _window || {};
  this._document = _document || {};
  this.replacements = {
    network: [],
    log: [],
    navigation: [],
    connectivity: []
  };
  this.eventRemovers = {
    dom: [],
    connectivity: [],
    contentsecuritypolicy: []
  };
  this._location = this._window.location;
  this._lastHref = this._location && this._location.href;
}
Instrumenter.prototype.configure = function (options) {
  this.options = _.merge(this.options, options);
  var autoInstrument = options.autoInstrument;
  var oldSettings = _.merge(this.autoInstrument);
  if (options.enabled === false || autoInstrument === false) {
    this.autoInstrument = {};
  } else {
    if (!_.isType(autoInstrument, 'object')) {
      autoInstrument = defaults;
    }
    this.autoInstrument = _.merge(defaults, autoInstrument);
  }
  this.instrument(oldSettings);
  if (options.scrubTelemetryInputs !== undefined) {
    this.scrubTelemetryInputs = !!options.scrubTelemetryInputs;
  }
  if (options.telemetryScrubber !== undefined) {
    this.telemetryScrubber = options.telemetryScrubber;
  }
};

// eslint-disable-next-line complexity
Instrumenter.prototype.instrument = function (oldSettings) {
  if (this.autoInstrument.network && !(oldSettings && oldSettings.network)) {
    this.instrumentNetwork();
  } else if (!this.autoInstrument.network && oldSettings && oldSettings.network) {
    this.deinstrumentNetwork();
  }
  if (this.autoInstrument.log && !(oldSettings && oldSettings.log)) {
    this.instrumentConsole();
  } else if (!this.autoInstrument.log && oldSettings && oldSettings.log) {
    this.deinstrumentConsole();
  }
  if (this.autoInstrument.dom && !(oldSettings && oldSettings.dom)) {
    this.instrumentDom();
  } else if (!this.autoInstrument.dom && oldSettings && oldSettings.dom) {
    this.deinstrumentDom();
  }
  if (this.autoInstrument.navigation && !(oldSettings && oldSettings.navigation)) {
    this.instrumentNavigation();
  } else if (!this.autoInstrument.navigation && oldSettings && oldSettings.navigation) {
    this.deinstrumentNavigation();
  }
  if (this.autoInstrument.connectivity && !(oldSettings && oldSettings.connectivity)) {
    this.instrumentConnectivity();
  } else if (!this.autoInstrument.connectivity && oldSettings && oldSettings.connectivity) {
    this.deinstrumentConnectivity();
  }
  if (this.autoInstrument.contentSecurityPolicy && !(oldSettings && oldSettings.contentSecurityPolicy)) {
    this.instrumentContentSecurityPolicy();
  } else if (!this.autoInstrument.contentSecurityPolicy && oldSettings && oldSettings.contentSecurityPolicy) {
    this.deinstrumentContentSecurityPolicy();
  }
};
Instrumenter.prototype.deinstrumentNetwork = function () {
  restore(this.replacements, 'network');
};
Instrumenter.prototype.instrumentNetwork = function () {
  var self = this;
  function wrapProp(prop, xhr) {
    if (prop in xhr && _.isFunction(xhr[prop])) {
      replace(xhr, prop, function (orig) {
        return self.rollbar.wrap(orig);
      });
    }
  }
  if ('XMLHttpRequest' in this._window) {
    var xhrp = this._window.XMLHttpRequest.prototype;
    replace(xhrp, 'open', function (orig) {
      return function (method, url) {
        var isUrlObject = _isUrlObject(url);
        if (_.isType(url, 'string') || isUrlObject) {
          url = isUrlObject ? url.toString() : url;
          if (this.__rollbar_xhr) {
            this.__rollbar_xhr.method = method;
            this.__rollbar_xhr.url = url;
            this.__rollbar_xhr.status_code = null;
            this.__rollbar_xhr.start_time_ms = _.now();
            this.__rollbar_xhr.end_time_ms = null;
          } else {
            this.__rollbar_xhr = {
              method: method,
              url: url,
              status_code: null,
              start_time_ms: _.now(),
              end_time_ms: null
            };
          }
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
    replace(xhrp, 'setRequestHeader', function (orig) {
      return function (header, value) {
        // If xhr.open is async, __rollbar_xhr may not be initialized yet.
        if (!this.__rollbar_xhr) {
          this.__rollbar_xhr = {};
        }
        if (_.isType(header, 'string') && _.isType(value, 'string')) {
          if (self.autoInstrument.networkRequestHeaders) {
            if (!this.__rollbar_xhr.request_headers) {
              this.__rollbar_xhr.request_headers = {};
            }
            this.__rollbar_xhr.request_headers[header] = value;
          }
          // We want the content type even if request header telemetry is off.
          if (header.toLowerCase() === 'content-type') {
            this.__rollbar_xhr.request_content_type = value;
          }
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
    replace(xhrp, 'send', function (orig) {
      /* eslint-disable no-unused-vars */
      return function (data) {
        /* eslint-enable no-unused-vars */
        var xhr = this;
        function onreadystatechangeHandler() {
          if (xhr.__rollbar_xhr) {
            if (xhr.__rollbar_xhr.status_code === null) {
              xhr.__rollbar_xhr.status_code = 0;
              if (self.autoInstrument.networkRequestBody) {
                xhr.__rollbar_xhr.request = data;
              }
              xhr.__rollbar_event = self.captureNetwork(xhr.__rollbar_xhr, 'xhr', undefined);
            }
            if (xhr.readyState < 2) {
              xhr.__rollbar_xhr.start_time_ms = _.now();
            }
            if (xhr.readyState > 3) {
              xhr.__rollbar_xhr.end_time_ms = _.now();
              var headers = null;
              xhr.__rollbar_xhr.response_content_type = xhr.getResponseHeader('Content-Type');
              if (self.autoInstrument.networkResponseHeaders) {
                var headersConfig = self.autoInstrument.networkResponseHeaders;
                headers = {};
                try {
                  var header, i;
                  if (headersConfig === true) {
                    var allHeaders = xhr.getAllResponseHeaders();
                    if (allHeaders) {
                      var arr = allHeaders.trim().split(/[\r\n]+/);
                      var parts, value;
                      for (i = 0; i < arr.length; i++) {
                        parts = arr[i].split(': ');
                        header = parts.shift();
                        value = parts.join(': ');
                        headers[header] = value;
                      }
                    }
                  } else {
                    for (i = 0; i < headersConfig.length; i++) {
                      header = headersConfig[i];
                      headers[header] = xhr.getResponseHeader(header);
                    }
                  }
                } catch (e) {
                  /* we ignore the errors here that could come from different
                   * browser issues with the xhr methods */
                }
              }
              var body = null;
              if (self.autoInstrument.networkResponseBody) {
                try {
                  body = xhr.responseText;
                } catch (e) {
                  /* ignore errors from reading responseText */
                }
              }
              var response = null;
              if (body || headers) {
                response = {};
                if (body) {
                  if (self.isJsonContentType(xhr.__rollbar_xhr.response_content_type)) {
                    response.body = self.scrubJson(body);
                  } else {
                    response.body = body;
                  }
                }
                if (headers) {
                  response.headers = headers;
                }
              }
              if (response) {
                xhr.__rollbar_xhr.response = response;
              }
              try {
                var code = xhr.status;
                code = code === 1223 ? 204 : code;
                xhr.__rollbar_xhr.status_code = code;
                xhr.__rollbar_event.level = self.telemeter.levelFromStatus(code);
                self.errorOnHttpStatus(xhr.__rollbar_xhr);
              } catch (e) {
                /* ignore possible exception from xhr.status */
              }
            }
          }
        }
        wrapProp('onload', xhr);
        wrapProp('onerror', xhr);
        wrapProp('onprogress', xhr);
        if ('onreadystatechange' in xhr && _.isFunction(xhr.onreadystatechange)) {
          replace(xhr, 'onreadystatechange', function (orig) {
            return self.rollbar.wrap(orig, undefined, onreadystatechangeHandler);
          });
        } else {
          xhr.onreadystatechange = onreadystatechangeHandler;
        }
        if (xhr.__rollbar_xhr && self.trackHttpErrors()) {
          xhr.__rollbar_xhr.stack = new Error().stack;
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
  }
  if ('fetch' in this._window) {
    replace(this._window, 'fetch', function (orig) {
      /* eslint-disable no-unused-vars */
      return function (fn, t) {
        /* eslint-enable no-unused-vars */
        var args = new Array(arguments.length);
        for (var i = 0, len = args.length; i < len; i++) {
          args[i] = arguments[i];
        }
        var input = args[0];
        var method = 'GET';
        var url;
        var isUrlObject = _isUrlObject(input);
        if (_.isType(input, 'string') || isUrlObject) {
          url = isUrlObject ? input.toString() : input;
        } else if (input) {
          url = input.url;
          if (input.method) {
            method = input.method;
          }
        }
        if (args[1] && args[1].method) {
          method = args[1].method;
        }
        var metadata = {
          method: method,
          url: url,
          status_code: null,
          start_time_ms: _.now(),
          end_time_ms: null
        };
        if (args[1] && args[1].headers) {
          // Argument may be a Headers object, or plain object. Ensure here that
          // we are working with a Headers object with case-insensitive keys.
          var reqHeaders = headers(args[1].headers);
          metadata.request_content_type = reqHeaders.get('Content-Type');
          if (self.autoInstrument.networkRequestHeaders) {
            metadata.request_headers = self.fetchHeaders(reqHeaders, self.autoInstrument.networkRequestHeaders);
          }
        }
        if (self.autoInstrument.networkRequestBody) {
          if (args[1] && args[1].body) {
            metadata.request = args[1].body;
          } else if (args[0] && !_.isType(args[0], 'string') && args[0].body) {
            metadata.request = args[0].body;
          }
        }
        self.captureNetwork(metadata, 'fetch', undefined);
        if (self.trackHttpErrors()) {
          metadata.stack = new Error().stack;
        }

        // Start our handler before returning the promise. This allows resp.clone()
        // to execute before other handlers touch the response.
        return orig.apply(this, args).then(function (resp) {
          metadata.end_time_ms = _.now();
          metadata.status_code = resp.status;
          metadata.response_content_type = resp.headers.get('Content-Type');
          var headers = null;
          if (self.autoInstrument.networkResponseHeaders) {
            headers = self.fetchHeaders(resp.headers, self.autoInstrument.networkResponseHeaders);
          }
          var body = null;
          if (self.autoInstrument.networkResponseBody) {
            if (typeof resp.text === 'function') {
              // Response.text() is not implemented on some platforms
              // The response must be cloned to prevent reading (and locking) the original stream.
              // This must be done before other handlers touch the response.
              body = resp.clone().text(); //returns a Promise
            }
          }
          if (headers || body) {
            metadata.response = {};
            if (body) {
              // Test to ensure body is a Promise, which it should always be.
              if (typeof body.then === 'function') {
                body.then(function (text) {
                  if (text && self.isJsonContentType(metadata.response_content_type)) {
                    metadata.response.body = self.scrubJson(text);
                  } else {
                    metadata.response.body = text;
                  }
                });
              } else {
                metadata.response.body = body;
              }
            }
            if (headers) {
              metadata.response.headers = headers;
            }
          }
          self.errorOnHttpStatus(metadata);
          return resp;
        });
      };
    }, this.replacements, 'network');
  }
};
Instrumenter.prototype.captureNetwork = function (metadata, subtype, rollbarUUID) {
  if (metadata.request && this.isJsonContentType(metadata.request_content_type)) {
    metadata.request = this.scrubJson(metadata.request);
  }
  return this.telemeter.captureNetwork(metadata, subtype, rollbarUUID);
};
Instrumenter.prototype.isJsonContentType = function (contentType) {
  return contentType && _.isType(contentType, 'string') && contentType.toLowerCase().includes('json') ? true : false;
};
Instrumenter.prototype.scrubJson = function (json) {
  return JSON.stringify(scrub(JSON.parse(json), this.options.scrubFields));
};
Instrumenter.prototype.fetchHeaders = function (inHeaders, headersConfig) {
  var outHeaders = {};
  try {
    var i;
    if (headersConfig === true) {
      if (typeof inHeaders.entries === 'function') {
        // Headers.entries() is not implemented in IE
        var allHeaders = inHeaders.entries();
        var currentHeader = allHeaders.next();
        while (!currentHeader.done) {
          outHeaders[currentHeader.value[0]] = currentHeader.value[1];
          currentHeader = allHeaders.next();
        }
      }
    } else {
      for (i = 0; i < headersConfig.length; i++) {
        var header = headersConfig[i];
        outHeaders[header] = inHeaders.get(header);
      }
    }
  } catch (e) {
    /* ignore probable IE errors */
  }
  return outHeaders;
};
Instrumenter.prototype.trackHttpErrors = function () {
  return this.autoInstrument.networkErrorOnHttp5xx || this.autoInstrument.networkErrorOnHttp4xx || this.autoInstrument.networkErrorOnHttp0;
};
Instrumenter.prototype.errorOnHttpStatus = function (metadata) {
  var status = metadata.status_code;
  if (status >= 500 && this.autoInstrument.networkErrorOnHttp5xx || status >= 400 && this.autoInstrument.networkErrorOnHttp4xx || status === 0 && this.autoInstrument.networkErrorOnHttp0) {
    var error = new Error('HTTP request failed with Status ' + status);
    error.stack = metadata.stack;
    this.rollbar.error(error, {
      skipFrames: 1
    });
  }
};
Instrumenter.prototype.deinstrumentConsole = function () {
  if (!('console' in this._window && this._window.console.log)) {
    return;
  }
  var b;
  while (this.replacements['log'].length) {
    b = this.replacements['log'].shift();
    this._window.console[b[0]] = b[1];
  }
};
Instrumenter.prototype.instrumentConsole = function () {
  if (!('console' in this._window && this._window.console.log)) {
    return;
  }
  var self = this;
  var c = this._window.console;
  function wrapConsole(method) {
    'use strict';

    // See https://github.com/rollbar/rollbar.js/pull/778
    var orig = c[method];
    var origConsole = c;
    var level = method === 'warn' ? 'warning' : method;
    c[method] = function () {
      var args = Array.prototype.slice.call(arguments);
      var message = _.formatArgsAsString(args);
      self.telemeter.captureLog(message, level, null, _.now());
      if (orig) {
        Function.prototype.apply.call(orig, origConsole, args);
      }
    };
    self.replacements['log'].push([method, orig]);
  }
  var methods = ['debug', 'info', 'warn', 'error', 'log'];
  try {
    for (var i = 0, len = methods.length; i < len; i++) {
      wrapConsole(methods[i]);
    }
  } catch (e) {
    this.diagnostic.instrumentConsole = {
      error: e.message
    };
  }
};
Instrumenter.prototype.deinstrumentDom = function () {
  if (!('addEventListener' in this._window || 'attachEvent' in this._window)) {
    return;
  }
  this.removeListeners('dom');
};
Instrumenter.prototype.instrumentDom = function () {
  if (!('addEventListener' in this._window || 'attachEvent' in this._window)) {
    return;
  }
  var clickHandler = this.handleClick.bind(this);
  var blurHandler = this.handleBlur.bind(this);
  this.addListener('dom', this._window, 'click', 'onclick', clickHandler, true);
  this.addListener('dom', this._window, 'blur', 'onfocusout', blurHandler, true);
};
Instrumenter.prototype.handleClick = function (evt) {
  try {
    var e = domUtil.getElementFromEvent(evt, this._document);
    var hasTag = e && e.tagName;
    var anchorOrButton = domUtil.isDescribedElement(e, 'a') || domUtil.isDescribedElement(e, 'button');
    if (hasTag && (anchorOrButton || domUtil.isDescribedElement(e, 'input', ['button', 'submit']))) {
      this.captureDomEvent('click', e);
    } else if (domUtil.isDescribedElement(e, 'input', ['checkbox', 'radio'])) {
      this.captureDomEvent('input', e, e.value, e.checked);
    }
  } catch (exc) {
    // TODO: Not sure what to do here
  }
};
Instrumenter.prototype.handleBlur = function (evt) {
  try {
    var e = domUtil.getElementFromEvent(evt, this._document);
    if (e && e.tagName) {
      if (domUtil.isDescribedElement(e, 'textarea')) {
        this.captureDomEvent('input', e, e.value);
      } else if (domUtil.isDescribedElement(e, 'select') && e.options && e.options.length) {
        this.handleSelectInputChanged(e);
      } else if (domUtil.isDescribedElement(e, 'input') && !domUtil.isDescribedElement(e, 'input', ['button', 'submit', 'hidden', 'checkbox', 'radio'])) {
        this.captureDomEvent('input', e, e.value);
      }
    }
  } catch (exc) {
    // TODO: Not sure what to do here
  }
};
Instrumenter.prototype.handleSelectInputChanged = function (elem) {
  if (elem.multiple) {
    for (var i = 0; i < elem.options.length; i++) {
      if (elem.options[i].selected) {
        this.captureDomEvent('input', elem, elem.options[i].value);
      }
    }
  } else if (elem.selectedIndex >= 0 && elem.options[elem.selectedIndex]) {
    this.captureDomEvent('input', elem, elem.options[elem.selectedIndex].value);
  }
};
Instrumenter.prototype.captureDomEvent = function (subtype, element, value, isChecked) {
  if (value !== undefined) {
    if (this.scrubTelemetryInputs || domUtil.getElementType(element) === 'password') {
      value = '[scrubbed]';
    } else {
      var description = domUtil.describeElement(element);
      if (this.telemetryScrubber) {
        if (this.telemetryScrubber(description)) {
          value = '[scrubbed]';
        }
      } else if (this.defaultValueScrubber(description)) {
        value = '[scrubbed]';
      }
    }
  }
  var elementString = domUtil.elementArrayToString(domUtil.treeToArray(element));
  this.telemeter.captureDom(subtype, elementString, value, isChecked);
};
Instrumenter.prototype.deinstrumentNavigation = function () {
  var chrome = this._window.chrome;
  var chromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  // See https://github.com/angular/angular.js/pull/13945/files
  var hasPushState = !chromePackagedApp && this._window.history && this._window.history.pushState;
  if (!hasPushState) {
    return;
  }
  restore(this.replacements, 'navigation');
};
Instrumenter.prototype.instrumentNavigation = function () {
  var chrome = this._window.chrome;
  var chromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  // See https://github.com/angular/angular.js/pull/13945/files
  var hasPushState = !chromePackagedApp && this._window.history && this._window.history.pushState;
  if (!hasPushState) {
    return;
  }
  var self = this;
  replace(this._window, 'onpopstate', function (orig) {
    return function () {
      var current = self._location.href;
      self.handleUrlChange(self._lastHref, current);
      if (orig) {
        orig.apply(this, arguments);
      }
    };
  }, this.replacements, 'navigation');
  replace(this._window.history, 'pushState', function (orig) {
    return function () {
      var url = arguments.length > 2 ? arguments[2] : undefined;
      if (url) {
        self.handleUrlChange(self._lastHref, url + '');
      }
      return orig.apply(this, arguments);
    };
  }, this.replacements, 'navigation');
};
Instrumenter.prototype.handleUrlChange = function (from, to) {
  var parsedHref = urlparser.parse(this._location.href);
  var parsedTo = urlparser.parse(to);
  var parsedFrom = urlparser.parse(from);
  this._lastHref = to;
  if (parsedHref.protocol === parsedTo.protocol && parsedHref.host === parsedTo.host) {
    to = parsedTo.path + (parsedTo.hash || '');
  }
  if (parsedHref.protocol === parsedFrom.protocol && parsedHref.host === parsedFrom.host) {
    from = parsedFrom.path + (parsedFrom.hash || '');
  }
  this.telemeter.captureNavigation(from, to, _.now());
};
Instrumenter.prototype.deinstrumentConnectivity = function () {
  if (!('addEventListener' in this._window || 'body' in this._document)) {
    return;
  }
  if (this._window.addEventListener) {
    this.removeListeners('connectivity');
  } else {
    restore(this.replacements, 'connectivity');
  }
};
Instrumenter.prototype.instrumentConnectivity = function () {
  if (!('addEventListener' in this._window || 'body' in this._document)) {
    return;
  }
  if (this._window.addEventListener) {
    this.addListener('connectivity', this._window, 'online', undefined, function () {
      this.telemeter.captureConnectivityChange('online');
    }.bind(this), true);
    this.addListener('connectivity', this._window, 'offline', undefined, function () {
      this.telemeter.captureConnectivityChange('offline');
    }.bind(this), true);
  } else {
    var self = this;
    replace(this._document.body, 'ononline', function (orig) {
      return function () {
        self.telemeter.captureConnectivityChange('online');
        if (orig) {
          orig.apply(this, arguments);
        }
      };
    }, this.replacements, 'connectivity');
    replace(this._document.body, 'onoffline', function (orig) {
      return function () {
        self.telemeter.captureConnectivityChange('offline');
        if (orig) {
          orig.apply(this, arguments);
        }
      };
    }, this.replacements, 'connectivity');
  }
};
Instrumenter.prototype.handleCspEvent = function (cspEvent) {
  var message = 'Security Policy Violation: ' + 'blockedURI: ' + cspEvent.blockedURI + ', ' + 'violatedDirective: ' + cspEvent.violatedDirective + ', ' + 'effectiveDirective: ' + cspEvent.effectiveDirective + ', ';
  if (cspEvent.sourceFile) {
    message += 'location: ' + cspEvent.sourceFile + ', ' + 'line: ' + cspEvent.lineNumber + ', ' + 'col: ' + cspEvent.columnNumber + ', ';
  }
  message += 'originalPolicy: ' + cspEvent.originalPolicy;
  this.telemeter.captureLog(message, 'error', null, _.now());
  this.handleCspError(message);
};
Instrumenter.prototype.handleCspError = function (message) {
  if (this.autoInstrument.errorOnContentSecurityPolicy) {
    this.rollbar.error(message);
  }
};
Instrumenter.prototype.deinstrumentContentSecurityPolicy = function () {
  if (!('addEventListener' in this._document)) {
    return;
  }
  this.removeListeners('contentsecuritypolicy');
};
Instrumenter.prototype.instrumentContentSecurityPolicy = function () {
  if (!('addEventListener' in this._document)) {
    return;
  }
  var cspHandler = this.handleCspEvent.bind(this);
  this.addListener('contentsecuritypolicy', this._document, 'securitypolicyviolation', null, cspHandler, false);
};
Instrumenter.prototype.addListener = function (section, obj, type, altType, handler, capture) {
  if (obj.addEventListener) {
    obj.addEventListener(type, handler, capture);
    this.eventRemovers[section].push(function () {
      obj.removeEventListener(type, handler, capture);
    });
  } else if (altType) {
    obj.attachEvent(altType, handler);
    this.eventRemovers[section].push(function () {
      obj.detachEvent(altType, handler);
    });
  }
};
Instrumenter.prototype.removeListeners = function (section) {
  var r;
  while (this.eventRemovers[section].length) {
    r = this.eventRemovers[section].shift();
    r();
  }
};
function _isUrlObject(input) {
  return typeof URL !== 'undefined' && input instanceof URL;
}
module.exports = Instrumenter;

/***/ }),

/***/ 706:
/***/ (function(module) {

function wrapGlobals(window, handler, shim) {
  if (!window) {
    return;
  }
  // Adapted from https://github.com/bugsnag/bugsnag-js
  var globals = 'EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload'.split(',');
  var i, global;
  for (i = 0; i < globals.length; ++i) {
    global = globals[i];
    if (window[global] && window[global].prototype) {
      _extendListenerPrototype(handler, window[global].prototype, shim);
    }
  }
}
function _extendListenerPrototype(handler, prototype, shim) {
  if (prototype.hasOwnProperty && prototype.hasOwnProperty('addEventListener')) {
    var oldAddEventListener = prototype.addEventListener;
    while (oldAddEventListener._rollbarOldAdd && oldAddEventListener.belongsToShim) {
      oldAddEventListener = oldAddEventListener._rollbarOldAdd;
    }
    var addFn = function addFn(event, callback, bubble) {
      oldAddEventListener.call(this, event, handler.wrap(callback), bubble);
    };
    addFn._rollbarOldAdd = oldAddEventListener;
    addFn.belongsToShim = shim;
    prototype.addEventListener = addFn;
    var oldRemoveEventListener = prototype.removeEventListener;
    while (oldRemoveEventListener._rollbarOldRemove && oldRemoveEventListener.belongsToShim) {
      oldRemoveEventListener = oldRemoveEventListener._rollbarOldRemove;
    }
    var removeFn = function removeFn(event, callback, bubble) {
      oldRemoveEventListener.call(this, event, callback && callback._rollbar_wrapped || callback, bubble);
    };
    removeFn._rollbarOldRemove = oldRemoveEventListener;
    removeFn.belongsToShim = shim;
    prototype.removeEventListener = removeFn;
  }
}
module.exports = wrapGlobals;

/***/ }),

/***/ 736:
/***/ (function(module) {

/*
 * headers - Detect when fetch Headers are undefined and use a partial polyfill.
 *
 * A full polyfill is not used in order to keep package size as small as possible.
 * Since this is only used internally and is not added to the window object,
 * the full interface doesn't need to be supported.
 *
 * This implementation is modified from whatwg-fetch:
 * https://github.com/github/fetch
 */
function headers(headers) {
  if (typeof Headers === 'undefined') {
    return new FetchHeaders(headers);
  }
  return new Headers(headers);
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };
  return iterator;
}
function FetchHeaders(headers) {
  this.map = {};
  if (headers instanceof FetchHeaders) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
FetchHeaders.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
FetchHeaders.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
FetchHeaders.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
FetchHeaders.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
FetchHeaders.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
module.exports = headers;

/***/ }),

/***/ 738:
/***/ (function() {

// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function(global) {
  'use strict';
  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function() {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);


/***/ }),

/***/ 746:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_259547__) {

var _ = __nested_webpack_require_259547__(585);
function checkIgnore(item, settings) {
  if (_.get(settings, 'plugins.jquery.ignoreAjaxErrors')) {
    return !_.get(item, 'body.message.extra.isAjax');
  }
  return true;
}
module.exports = {
  checkIgnore: checkIgnore
};

/***/ }),

/***/ 751:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_259901__) {

var _ = __nested_webpack_require_259901__(585);
var makeFetchRequest = __nested_webpack_require_259901__(472);
var makeXhrRequest = __nested_webpack_require_259901__(862);

/*
 * accessToken may be embedded in payload but that should not
 *   be assumed
 *
 * options: {
 *   hostname
 *   protocol
 *   path
 *   port
 *   method
 *   transport ('xhr' | 'fetch')
 * }
 *
 *  params is an object containing key/value pairs. These
 *    will be appended to the path as 'key=value&key=value'
 *
 * payload is an unserialized object
 */
function Transport(truncation) {
  this.truncation = truncation;
}
Transport.prototype.get = function (accessToken, options, params, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  _.addParamsAndAccessTokenToPath(accessToken, options, params);
  var method = 'GET';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, null, callback, requestFactory, options.timeout, options.transport);
};
Transport.prototype.post = function (accessToken, options, payload, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  if (!payload) {
    return callback(new Error('Cannot send empty request'));
  }
  var stringifyResult;
  if (this.truncation) {
    stringifyResult = this.truncation.truncate(payload);
  } else {
    stringifyResult = _.stringify(payload);
  }
  if (stringifyResult.error) {
    return callback(stringifyResult.error);
  }
  var writeData = stringifyResult.value;
  var method = 'POST';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, writeData, callback, requestFactory, options.timeout, options.transport);
};
Transport.prototype.postJsonPayload = function (accessToken, options, jsonPayload, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  var method = 'POST';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, jsonPayload, callback, requestFactory, options.timeout, options.transport);
};

// Wraps `_makeRequest` if zone.js is being used, ensuring that Rollbar
// API calls are not intercepted by any child forked zones.
// This is equivalent to `NgZone.runOutsideAngular` in Angular.
Transport.prototype._makeZoneRequest = function () {
  var gWindow = typeof window != 'undefined' && window || typeof self != 'undefined' && self;
  // Whenever zone.js is loaded and `Zone` is exposed globally, access
  // the root zone to ensure that requests are always made within it.
  // This approach is framework-agnostic, regardless of which
  // framework zone.js is used with.
  var rootZone = gWindow && gWindow.Zone && gWindow.Zone.root;
  var args = Array.prototype.slice.call(arguments);
  if (rootZone) {
    var self = this;
    rootZone.run(function () {
      self._makeRequest.apply(undefined, args);
    });
  } else {
    this._makeRequest.apply(undefined, args);
  }
};
Transport.prototype._makeRequest = function (accessToken, url, method, data, callback, requestFactory, timeout, transport) {
  if (typeof RollbarProxy !== 'undefined') {
    return _proxyRequest(data, callback);
  }
  if (transport === 'fetch') {
    makeFetchRequest(accessToken, url, method, data, callback, timeout);
  } else {
    makeXhrRequest(accessToken, url, method, data, callback, requestFactory, timeout);
  }
};

/* global RollbarProxy */
function _proxyRequest(json, callback) {
  var rollbarProxy = new RollbarProxy();
  rollbarProxy.sendJsonPayload(json, function (_msg) {
    /* do nothing */
  },
  // eslint-disable-line no-unused-vars
  function (err) {
    callback(new Error(err));
  });
}
module.exports = Transport;

/***/ }),

/***/ 767:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__) {

"use strict";
/**
 * Generate a random hexadecimal ID of specified byte length
 *
 * @param {number} bytes - Number of bytes for the ID (default: 16)
 * @returns {string} - Hexadecimal string representation
 */
function gen() {
  var bytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var randomBytes = new Uint8Array(bytes);
  crypto.getRandomValues(randomBytes);
  var randHex = Array.from(randomBytes, function (_byte) {
    return _byte.toString(16).padStart(2, '0');
  }).join('');
  return randHex;
}

/**
 * Tracing id generation utils
 *
 * @example
 * import id from './id.js';
 *
 * const spanId = id.gen(8); // => "a1b2c3d4e5f6..."
 */
/* harmony default export */ __nested_webpack_exports__.A = ({
  gen: gen
});

/***/ }),

/***/ 792:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_264583__) {

"use strict";
__nested_webpack_require_264583__.r(__nested_webpack_exports__);
/**
 * Default options for the rrweb recorder
 * See https://github.com/rrweb-io/rrweb/blob/master/guide.md#options for details
 */
/* harmony default export */ __nested_webpack_exports__["default"] = ({
  enabled: false,
  // Whether recording is enabled
  autoStart: true,
  // Start recording automatically when Rollbar initializes
  debug: {
    logEmits: false // Whether to log emitted events
  },
  // Recording options
  inlineStylesheet: true,
  // Whether to inline stylesheets to improve replay accuracy
  inlineImages: false,
  // Whether to record the image content
  collectFonts: true,
  // Whether to collect fonts in the website

  // Privacy options
  // Fine-grained control over which input types to mask
  // By default only password inputs are masked if maskInputs is true
  maskInputOptions: {
    password: true,
    email: false,
    tel: false,
    text: false,
    color: false,
    date: false,
    'datetime-local': false,
    month: false,
    number: false,
    range: false,
    search: false,
    time: false,
    url: false,
    week: false
  },
  // Remove unnecessary parts of the DOM
  // By default all removable elements are removed
  slimDOMOptions: {
    script: true,
    // Remove script elements
    comment: true,
    // Remove comments
    headFavicon: true,
    // Remove favicons in the head
    headWhitespace: true,
    // Remove whitespace in head
    headMetaDescKeywords: true,
    // Remove meta description and keywords
    headMetaSocial: true,
    // Remove social media meta tags
    headMetaRobots: true,
    // Remove robots meta directives
    headMetaHttpEquiv: true,
    // Remove http-equiv meta directives
    headMetaAuthorship: true,
    // Remove authorship meta directives
    headMetaVerification: true // Remove verification meta directives
  }

  // Custom callbacks for advanced use cases
  // These are undefined by default and can be set programmatically
  // maskInputFn: undefined,      // Custom function to mask input values
  // maskTextFn: undefined,       // Custom function to mask text content
  // errorHandler: undefined,     // Custom error handler for recording errors

  // Plugin system
  // plugins: []                  // List of plugins to use (must be set programmatically)
});

/***/ }),

/***/ 862:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_267003__) {

/*global XDomainRequest*/

var _ = __nested_webpack_require_267003__(585);
var logger = __nested_webpack_require_267003__(144);
function makeXhrRequest(accessToken, url, method, data, callback, requestFactory, timeout) {
  var request;
  if (requestFactory) {
    request = requestFactory();
  } else {
    request = _createXMLHTTPObject();
  }
  if (!request) {
    // Give up, no way to send requests
    return callback(new Error('No way to send a request'));
  }
  try {
    try {
      var _onreadystatechange = function onreadystatechange() {
        try {
          if (_onreadystatechange && request.readyState === 4) {
            _onreadystatechange = undefined;
            var parseResponse = _.jsonParse(request.responseText);
            if (_isSuccess(request)) {
              callback(parseResponse.error, parseResponse.value);
              return;
            } else if (_isNormalFailure(request)) {
              if (request.status === 403) {
                // likely caused by using a server access token
                var message = parseResponse.value && parseResponse.value.message;
                logger.error(message);
              }
              // return valid http status codes
              callback(new Error(String(request.status)));
            } else {
              // IE will return a status 12000+ on some sort of connection failure,
              // so we return a blank error
              // http://msdn.microsoft.com/en-us/library/aa383770%28VS.85%29.aspx
              var msg = 'XHR response had no status code (likely connection failure)';
              callback(_newRetriableError(msg));
            }
          }
        } catch (ex) {
          //jquery source mentions firefox may error out while accessing the
          //request members if there is a network error
          //https://github.com/jquery/jquery/blob/a938d7b1282fc0e5c52502c225ae8f0cef219f0a/src/ajax/xhr.js#L111
          var exc;
          if (ex && ex.stack) {
            exc = ex;
          } else {
            exc = new Error(ex);
          }
          callback(exc);
        }
      };
      request.open(method, url, true);
      if (request.setRequestHeader) {
        request.setRequestHeader('Content-Type', 'application/json');
        request.setRequestHeader('X-Rollbar-Access-Token', accessToken);
      }
      if (_.isFiniteNumber(timeout)) {
        request.timeout = timeout;
      }
      request.onreadystatechange = _onreadystatechange;
      request.send(data);
    } catch (e1) {
      // Sending using the normal xmlhttprequest object didn't work, try XDomainRequest
      if (typeof XDomainRequest !== 'undefined') {
        // Assume we are in a really old browser which has a bunch of limitations:
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

        // Extreme paranoia: if we have XDomainRequest then we have a window, but just in case
        if (!window || !window.location) {
          return callback(new Error('No window available during request, unknown environment'));
        }

        // If the current page is http, try and send over http
        if (window.location.href.substring(0, 5) === 'http:' && url.substring(0, 5) === 'https') {
          url = 'http' + url.substring(5);
        }
        var xdomainrequest = new XDomainRequest();
        xdomainrequest.onprogress = function () {};
        xdomainrequest.ontimeout = function () {
          var msg = 'Request timed out';
          var code = 'ETIMEDOUT';
          callback(_newRetriableError(msg, code));
        };
        xdomainrequest.onerror = function () {
          callback(new Error('Error during request'));
        };
        xdomainrequest.onload = function () {
          var parseResponse = _.jsonParse(xdomainrequest.responseText);
          callback(parseResponse.error, parseResponse.value);
        };
        xdomainrequest.open(method, url, true);
        xdomainrequest.send(data);
      } else {
        callback(new Error('Cannot find a method to transport a request'));
      }
    }
  } catch (e2) {
    callback(e2);
  }
}
function _createXMLHTTPObject() {
  /* global ActiveXObject:false */

  var factories = [function () {
    return new XMLHttpRequest();
  }, function () {
    return new ActiveXObject('Msxml2.XMLHTTP');
  }, function () {
    return new ActiveXObject('Msxml3.XMLHTTP');
  }, function () {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }];
  var xmlhttp;
  var i;
  var numFactories = factories.length;
  for (i = 0; i < numFactories; i++) {
    /* eslint-disable no-empty */
    try {
      xmlhttp = factories[i]();
      break;
    } catch (e) {
      // pass
    }
    /* eslint-enable no-empty */
  }
  return xmlhttp;
}
function _isSuccess(r) {
  return r && r.status && r.status === 200;
}
function _isNormalFailure(r) {
  return r && _.isType(r.status, 'number') && r.status >= 400 && r.status < 600;
}
function _newRetriableError(message, code) {
  var err = new Error(message);
  err.code = code || 'ENOTFOUND';
  return err;
}
module.exports = makeXhrRequest;

/***/ }),

/***/ 918:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_272218__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_272218__.r(__nested_webpack_exports__);

// EXPORTS
__nested_webpack_require_272218__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ Recorder; }
});

;// ./node_modules/@rrweb/record/dist/record.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var NodeType$3 = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType$3 || {});
const testableAccessors$1 = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
};
const testableMethods$1 = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
};
const untaintedBasePrototype$1 = {};
const isAngularZonePresent$1 = () => {
  return !!globalThis.Zone;
};
function getUntaintedPrototype$1(key) {
  if (untaintedBasePrototype$1[key])
    return untaintedBasePrototype$1[key];
  const defaultObj = globalThis[key];
  const defaultPrototype = defaultObj.prototype;
  const accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;
  const isUntaintedAccessors = Boolean(
    accessorNames && // @ts-expect-error 2345
    accessorNames.every(
      (accessor) => {
        var _a2, _b;
        return Boolean(
          (_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes("[native code]")
        );
      }
    )
  );
  const methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;
  const isUntaintedMethods = Boolean(
    methodNames && methodNames.every(
      // @ts-expect-error 2345
      (method) => {
        var _a2;
        return typeof defaultPrototype[method] === "function" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes("[native code]"));
      }
    )
  );
  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {
    untaintedBasePrototype$1[key] = defaultObj.prototype;
    return defaultObj.prototype;
  }
  try {
    const iframeEl = document.createElement("iframe");
    document.body.appendChild(iframeEl);
    const win = iframeEl.contentWindow;
    if (!win) return defaultObj.prototype;
    const untaintedObject = win[key].prototype;
    document.body.removeChild(iframeEl);
    if (!untaintedObject) return defaultPrototype;
    return untaintedBasePrototype$1[key] = untaintedObject;
  } catch {
    return defaultPrototype;
  }
}
const untaintedAccessorCache$1 = {};
function getUntaintedAccessor$1(key, instance, accessor) {
  var _a2;
  const cacheKey = `${key}.${String(accessor)}`;
  if (untaintedAccessorCache$1[cacheKey])
    return untaintedAccessorCache$1[cacheKey].call(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype$1(key);
  const untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(
    untaintedPrototype,
    accessor
  )) == null ? void 0 : _a2.get;
  if (!untaintedAccessor) return instance[accessor];
  untaintedAccessorCache$1[cacheKey] = untaintedAccessor;
  return untaintedAccessor.call(instance);
}
const untaintedMethodCache$1 = {};
function getUntaintedMethod$1(key, instance, method) {
  const cacheKey = `${key}.${String(method)}`;
  if (untaintedMethodCache$1[cacheKey])
    return untaintedMethodCache$1[cacheKey].bind(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype$1(key);
  const untaintedMethod = untaintedPrototype[method];
  if (typeof untaintedMethod !== "function") return instance[method];
  untaintedMethodCache$1[cacheKey] = untaintedMethod;
  return untaintedMethod.bind(instance);
}
function childNodes$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "childNodes");
}
function parentNode$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "parentNode");
}
function parentElement$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "parentElement");
}
function textContent$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "textContent");
}
function contains$1(n2, other) {
  return getUntaintedMethod$1("Node", n2, "contains")(other);
}
function getRootNode$1(n2) {
  return getUntaintedMethod$1("Node", n2, "getRootNode")();
}
function host$1(n2) {
  if (!n2 || !("host" in n2)) return null;
  return getUntaintedAccessor$1("ShadowRoot", n2, "host");
}
function styleSheets$1(n2) {
  return n2.styleSheets;
}
function shadowRoot$1(n2) {
  if (!n2 || !("shadowRoot" in n2)) return null;
  return getUntaintedAccessor$1("Element", n2, "shadowRoot");
}
function querySelector$1(n2, selectors) {
  return getUntaintedAccessor$1("Element", n2, "querySelector")(selectors);
}
function querySelectorAll$1(n2, selectors) {
  return getUntaintedAccessor$1("Element", n2, "querySelectorAll")(selectors);
}
function mutationObserverCtor$1() {
  return getUntaintedPrototype$1("MutationObserver").constructor;
}
const index$1 = {
  childNodes: childNodes$1,
  parentNode: parentNode$1,
  parentElement: parentElement$1,
  textContent: textContent$1,
  contains: contains$1,
  getRootNode: getRootNode$1,
  host: host$1,
  styleSheets: styleSheets$1,
  shadowRoot: shadowRoot$1,
  querySelector: querySelector$1,
  querySelectorAll: querySelectorAll$1,
  mutationObserver: mutationObserverCtor$1
};
function isElement(n2) {
  return n2.nodeType === n2.ELEMENT_NODE;
}
function isShadowRoot(n2) {
  const hostEl = (
    // anchor and textarea elements also have a `host` property
    // but only shadow roots have a `mode` property
    n2 && "host" in n2 && "mode" in n2 && index$1.host(n2) || null
  );
  return Boolean(
    hostEl && "shadowRoot" in hostEl && index$1.shadowRoot(hostEl) === n2
  );
}
function isNativeShadowDom(shadowRoot2) {
  return Object.prototype.toString.call(shadowRoot2) === "[object ShadowRoot]";
}
function fixBrowserCompatibilityIssuesInCSS(cssText) {
  if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {
    cssText = cssText.replace(
      /\sbackground-clip:\s*text;/g,
      " -webkit-background-clip: text; background-clip: text;"
    );
  }
  return cssText;
}
function escapeImportStatement(rule2) {
  const { cssText } = rule2;
  if (cssText.split('"').length < 3) return cssText;
  const statement = ["@import", `url(${JSON.stringify(rule2.href)})`];
  if (rule2.layerName === "") {
    statement.push(`layer`);
  } else if (rule2.layerName) {
    statement.push(`layer(${rule2.layerName})`);
  }
  if (rule2.supportsText) {
    statement.push(`supports(${rule2.supportsText})`);
  }
  if (rule2.media.length) {
    statement.push(rule2.media.mediaText);
  }
  return statement.join(" ") + ";";
}
function stringifyStylesheet(s2) {
  try {
    const rules2 = s2.rules || s2.cssRules;
    if (!rules2) {
      return null;
    }
    let sheetHref = s2.href;
    if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {
      sheetHref = s2.ownerNode.ownerDocument.location.href;
    }
    const stringifiedRules = Array.from(
      rules2,
      (rule2) => stringifyRule(rule2, sheetHref)
    ).join("");
    return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);
  } catch (error) {
    return null;
  }
}
function stringifyRule(rule2, sheetHref) {
  if (isCSSImportRule(rule2)) {
    let importStringified;
    try {
      importStringified = // for same-origin stylesheets,
      // we can access the imported stylesheet rules directly
      stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement
      escapeImportStatement(rule2);
    } catch (error) {
      importStringified = rule2.cssText;
    }
    if (rule2.styleSheet.href) {
      return absolutifyURLs(importStringified, rule2.styleSheet.href);
    }
    return importStringified;
  } else {
    let ruleStringified = rule2.cssText;
    if (isCSSStyleRule(rule2) && rule2.selectorText.includes(":")) {
      ruleStringified = fixSafariColons(ruleStringified);
    }
    if (sheetHref) {
      return absolutifyURLs(ruleStringified, sheetHref);
    }
    return ruleStringified;
  }
}
function fixSafariColons(cssStringified) {
  const regex = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return cssStringified.replace(regex, "$1\\$2");
}
function isCSSImportRule(rule2) {
  return "styleSheet" in rule2;
}
function isCSSStyleRule(rule2) {
  return "selectorText" in rule2;
}
class Mirror {
  constructor() {
    __publicField$1(this, "idNodeMap", /* @__PURE__ */ new Map());
    __publicField$1(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());
  }
  getId(n2) {
    var _a2;
    if (!n2) return -1;
    const id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;
    return id ?? -1;
  }
  getNode(id) {
    return this.idNodeMap.get(id) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(n2) {
    return this.nodeMetaMap.get(n2) || null;
  }
  // removes the node from idNodeMap
  // doesn't remove the node from nodeMetaMap
  removeNodeFromMap(n2) {
    const id = this.getId(n2);
    this.idNodeMap.delete(id);
    if (n2.childNodes) {
      n2.childNodes.forEach(
        (childNode) => this.removeNodeFromMap(childNode)
      );
    }
  }
  has(id) {
    return this.idNodeMap.has(id);
  }
  hasNode(node2) {
    return this.nodeMetaMap.has(node2);
  }
  add(n2, meta) {
    const id = meta.id;
    this.idNodeMap.set(id, n2);
    this.nodeMetaMap.set(n2, meta);
  }
  replace(id, n2) {
    const oldNode = this.getNode(id);
    if (oldNode) {
      const meta = this.nodeMetaMap.get(oldNode);
      if (meta) this.nodeMetaMap.set(n2, meta);
    }
    this.idNodeMap.set(id, n2);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map();
    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function createMirror$2() {
  return new Mirror();
}
function maskInputValue({
  element,
  maskInputOptions,
  tagName,
  type,
  value,
  maskInputFn
}) {
  let text = value || "";
  const actualType = type && toLowerCase(type);
  if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {
    if (maskInputFn) {
      text = maskInputFn(text, element);
    } else {
      text = "*".repeat(text.length);
    }
  }
  return text;
}
function toLowerCase(str) {
  return str.toLowerCase();
}
const ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";
function is2DCanvasBlank(canvas) {
  const ctx = canvas.getContext("2d");
  if (!ctx) return true;
  const chunkSize = 50;
  for (let x2 = 0; x2 < canvas.width; x2 += chunkSize) {
    for (let y = 0; y < canvas.height; y += chunkSize) {
      const getImageData = ctx.getImageData;
      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;
      const pixelBuffer = new Uint32Array(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        originalGetImageData.call(
          ctx,
          x2,
          y,
          Math.min(chunkSize, canvas.width - x2),
          Math.min(chunkSize, canvas.height - y)
        ).data.buffer
      );
      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;
    }
  }
  return true;
}
function getInputType(element) {
  const type = element.type;
  return element.hasAttribute("data-rr-is-password") ? "password" : type ? (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    toLowerCase(type)
  ) : null;
}
function extractFileExtension(path, baseURL) {
  let url;
  try {
    url = new URL(path, baseURL ?? window.location.href);
  } catch (err) {
    return null;
  }
  const regex = /\.([0-9a-z]+)(?:$)/i;
  const match = url.pathname.match(regex);
  return (match == null ? void 0 : match[1]) ?? null;
}
function extractOrigin(url) {
  let origin = "";
  if (url.indexOf("//") > -1) {
    origin = url.split("/").slice(0, 3).join("/");
  } else {
    origin = url.split("/")[0];
  }
  origin = origin.split("?")[0];
  return origin;
}
const URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
const URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i;
const URL_WWW_MATCH = /^www\..*/i;
const DATA_URI = /^(data:)([^,]*),(.*)/i;
function absolutifyURLs(cssText, href) {
  return (cssText || "").replace(
    URL_IN_CSS_REF,
    (origin, quote1, path1, quote2, path2, path3) => {
      const filePath = path1 || path2 || path3;
      const maybeQuote = quote1 || quote2 || "";
      if (!filePath) {
        return origin;
      }
      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (DATA_URI.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (filePath[0] === "/") {
        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;
      }
      const stack = href.split("/");
      const parts = filePath.split("/");
      stack.pop();
      for (const part of parts) {
        if (part === ".") {
          continue;
        } else if (part === "..") {
          stack.pop();
        } else {
          stack.push(part);
        }
      }
      return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;
    }
  );
}
function normalizeCssString(cssText) {
  return cssText.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "");
}
function splitCssText(cssText, style) {
  const childNodes2 = Array.from(style.childNodes);
  const splits = [];
  if (childNodes2.length > 1 && cssText && typeof cssText === "string") {
    const cssTextNorm = normalizeCssString(cssText);
    for (let i2 = 1; i2 < childNodes2.length; i2++) {
      if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === "string") {
        const textContentNorm = normalizeCssString(childNodes2[i2].textContent);
        for (let j = 3; j < textContentNorm.length; j++) {
          const bit = textContentNorm.substring(0, j);
          if (cssTextNorm.split(bit).length === 2) {
            const splitNorm = cssTextNorm.indexOf(bit);
            for (let k = splitNorm; k < cssText.length; k++) {
              if (normalizeCssString(cssText.substring(0, k)).length === splitNorm) {
                splits.push(cssText.substring(0, k));
                cssText = cssText.substring(k);
                break;
              }
            }
            break;
          }
        }
      }
    }
  }
  splits.push(cssText);
  return splits;
}
function markCssSplits(cssText, style) {
  return splitCssText(cssText, style).join("/* rr_split */");
}
let _id = 1;
const tagNameRegex = new RegExp("[^a-z0-9-_:]");
const IGNORED_NODE = -2;
function genId() {
  return _id++;
}
function getValidTagName$1(element) {
  if (element instanceof HTMLFormElement) {
    return "form";
  }
  const processedTagName = toLowerCase(element.tagName);
  if (tagNameRegex.test(processedTagName)) {
    return "div";
  }
  return processedTagName;
}
let canvasService;
let canvasCtx;
const SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
const SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
function getAbsoluteSrcsetString(doc, attributeValue) {
  if (attributeValue.trim() === "") {
    return attributeValue;
  }
  let pos = 0;
  function collectCharacters(regEx) {
    let chars2;
    const match = regEx.exec(attributeValue.substring(pos));
    if (match) {
      chars2 = match[0];
      pos += chars2.length;
      return chars2;
    }
    return "";
  }
  const output = [];
  while (true) {
    collectCharacters(SRCSET_COMMAS_OR_SPACES);
    if (pos >= attributeValue.length) {
      break;
    }
    let url = collectCharacters(SRCSET_NOT_SPACES);
    if (url.slice(-1) === ",") {
      url = absoluteToDoc(doc, url.substring(0, url.length - 1));
      output.push(url);
    } else {
      let descriptorsStr = "";
      url = absoluteToDoc(doc, url);
      let inParens = false;
      while (true) {
        const c2 = attributeValue.charAt(pos);
        if (c2 === "") {
          output.push((url + descriptorsStr).trim());
          break;
        } else if (!inParens) {
          if (c2 === ",") {
            pos += 1;
            output.push((url + descriptorsStr).trim());
            break;
          } else if (c2 === "(") {
            inParens = true;
          }
        } else {
          if (c2 === ")") {
            inParens = false;
          }
        }
        descriptorsStr += c2;
        pos += 1;
      }
    }
  }
  return output.join(", ");
}
const cachedDocument = /* @__PURE__ */ new WeakMap();
function absoluteToDoc(doc, attributeValue) {
  if (!attributeValue || attributeValue.trim() === "") {
    return attributeValue;
  }
  return getHref(doc, attributeValue);
}
function isSVGElement(el) {
  return Boolean(el.tagName === "svg" || el.ownerSVGElement);
}
function getHref(doc, customHref) {
  let a2 = cachedDocument.get(doc);
  if (!a2) {
    a2 = doc.createElement("a");
    cachedDocument.set(doc, a2);
  }
  if (!customHref) {
    customHref = "";
  } else if (customHref.startsWith("blob:") || customHref.startsWith("data:")) {
    return customHref;
  }
  a2.setAttribute("href", customHref);
  return a2.href;
}
function transformAttribute(doc, tagName, name, value) {
  if (!value) {
    return value;
  }
  if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {
    return absoluteToDoc(doc, value);
  } else if (name === "xlink:href" && value[0] !== "#") {
    return absoluteToDoc(doc, value);
  } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {
    return absoluteToDoc(doc, value);
  } else if (name === "srcset") {
    return getAbsoluteSrcsetString(doc, value);
  } else if (name === "style") {
    return absolutifyURLs(value, getHref(doc));
  } else if (tagName === "object" && name === "data") {
    return absoluteToDoc(doc, value);
  }
  return value;
}
function ignoreAttribute(tagName, name, _value) {
  return (tagName === "video" || tagName === "audio") && name === "autoplay";
}
function _isBlockedElement(element, blockClass, blockSelector) {
  try {
    if (typeof blockClass === "string") {
      if (element.classList.contains(blockClass)) {
        return true;
      }
    } else {
      for (let eIndex = element.classList.length; eIndex--; ) {
        const className = element.classList[eIndex];
        if (blockClass.test(className)) {
          return true;
        }
      }
    }
    if (blockSelector) {
      return element.matches(blockSelector);
    }
  } catch (e2) {
  }
  return false;
}
function classMatchesRegex(node2, regex, checkAncestors) {
  if (!node2) return false;
  if (node2.nodeType !== node2.ELEMENT_NODE) {
    if (!checkAncestors) return false;
    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);
  }
  for (let eIndex = node2.classList.length; eIndex--; ) {
    const className = node2.classList[eIndex];
    if (regex.test(className)) {
      return true;
    }
  }
  if (!checkAncestors) return false;
  return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);
}
function needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {
  let el;
  if (isElement(node2)) {
    el = node2;
    if (!index$1.childNodes(el).length) {
      return false;
    }
  } else if (index$1.parentElement(node2) === null) {
    return false;
  } else {
    el = index$1.parentElement(node2);
  }
  try {
    if (typeof maskTextClass === "string") {
      if (checkAncestors) {
        if (el.closest(`.${maskTextClass}`)) return true;
      } else {
        if (el.classList.contains(maskTextClass)) return true;
      }
    } else {
      if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;
    }
    if (maskTextSelector) {
      if (checkAncestors) {
        if (el.closest(maskTextSelector)) return true;
      } else {
        if (el.matches(maskTextSelector)) return true;
      }
    }
  } catch (e2) {
  }
  return false;
}
function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
  const win = iframeEl.contentWindow;
  if (!win) {
    return;
  }
  let fired = false;
  let readyState;
  try {
    readyState = win.document.readyState;
  } catch (error) {
    return;
  }
  if (readyState !== "complete") {
    const timer = setTimeout(() => {
      if (!fired) {
        listener();
        fired = true;
      }
    }, iframeLoadTimeout);
    iframeEl.addEventListener("load", () => {
      clearTimeout(timer);
      fired = true;
      listener();
    });
    return;
  }
  const blankUrl = "about:blank";
  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {
    setTimeout(listener, 0);
    return iframeEl.addEventListener("load", listener);
  }
  iframeEl.addEventListener("load", listener);
}
function onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {
  let fired = false;
  let styleSheetLoaded;
  try {
    styleSheetLoaded = link.sheet;
  } catch (error) {
    return;
  }
  if (styleSheetLoaded) return;
  const timer = setTimeout(() => {
    if (!fired) {
      listener();
      fired = true;
    }
  }, styleSheetLoadTimeout);
  link.addEventListener("load", () => {
    clearTimeout(timer);
    fired = true;
    listener();
  });
}
function serializeNode(n2, options) {
  const {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions = {},
    maskTextFn,
    maskInputFn,
    dataURLOptions = {},
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement = false,
    cssCaptured = false
  } = options;
  const rootId = getRootId(doc, mirror2);
  switch (n2.nodeType) {
    case n2.DOCUMENT_NODE:
      if (n2.compatMode !== "CSS1Compat") {
        return {
          type: NodeType$3.Document,
          childNodes: [],
          compatMode: n2.compatMode
          // probably "BackCompat"
        };
      } else {
        return {
          type: NodeType$3.Document,
          childNodes: []
        };
      }
    case n2.DOCUMENT_TYPE_NODE:
      return {
        type: NodeType$3.DocumentType,
        name: n2.name,
        publicId: n2.publicId,
        systemId: n2.systemId,
        rootId
      };
    case n2.ELEMENT_NODE:
      return serializeElementNode(n2, {
        doc,
        blockClass,
        blockSelector,
        inlineStylesheet,
        maskInputOptions,
        maskInputFn,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        keepIframeSrcFn,
        newlyAddedElement,
        rootId
      });
    case n2.TEXT_NODE:
      return serializeTextNode(n2, {
        doc,
        needsMask,
        maskTextFn,
        rootId,
        cssCaptured
      });
    case n2.CDATA_SECTION_NODE:
      return {
        type: NodeType$3.CDATA,
        textContent: "",
        rootId
      };
    case n2.COMMENT_NODE:
      return {
        type: NodeType$3.Comment,
        textContent: index$1.textContent(n2) || "",
        rootId
      };
    default:
      return false;
  }
}
function getRootId(doc, mirror2) {
  if (!mirror2.hasNode(doc)) return void 0;
  const docId = mirror2.getId(doc);
  return docId === 1 ? void 0 : docId;
}
function serializeTextNode(n2, options) {
  const { needsMask, maskTextFn, rootId, cssCaptured } = options;
  const parent = index$1.parentNode(n2);
  const parentTagName = parent && parent.tagName;
  let textContent2 = "";
  const isStyle = parentTagName === "STYLE" ? true : void 0;
  const isScript = parentTagName === "SCRIPT" ? true : void 0;
  if (isScript) {
    textContent2 = "SCRIPT_PLACEHOLDER";
  } else if (!cssCaptured) {
    textContent2 = index$1.textContent(n2);
    if (isStyle && textContent2) {
      textContent2 = absolutifyURLs(textContent2, getHref(options.doc));
    }
  }
  if (!isStyle && !isScript && textContent2 && needsMask) {
    textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\S]/g, "*");
  }
  return {
    type: NodeType$3.Text,
    textContent: textContent2 || "",
    rootId
  };
}
function serializeElementNode(n2, options) {
  const {
    doc,
    blockClass,
    blockSelector,
    inlineStylesheet,
    maskInputOptions = {},
    maskInputFn,
    dataURLOptions = {},
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement = false,
    rootId
  } = options;
  const needBlock = _isBlockedElement(n2, blockClass, blockSelector);
  const tagName = getValidTagName$1(n2);
  let attributes = {};
  const len = n2.attributes.length;
  for (let i2 = 0; i2 < len; i2++) {
    const attr = n2.attributes[i2];
    if (!ignoreAttribute(tagName, attr.name, attr.value)) {
      attributes[attr.name] = transformAttribute(
        doc,
        tagName,
        toLowerCase(attr.name),
        attr.value
      );
    }
  }
  if (tagName === "link" && inlineStylesheet) {
    const stylesheet = Array.from(doc.styleSheets).find((s2) => {
      return s2.href === n2.href;
    });
    let cssText = null;
    if (stylesheet) {
      cssText = stringifyStylesheet(stylesheet);
    }
    if (cssText) {
      delete attributes.rel;
      delete attributes.href;
      attributes._cssText = cssText;
    }
  }
  if (tagName === "style" && n2.sheet) {
    let cssText = stringifyStylesheet(
      n2.sheet
    );
    if (cssText) {
      if (n2.childNodes.length > 1) {
        cssText = markCssSplits(cssText, n2);
      }
      attributes._cssText = cssText;
    }
  }
  if (tagName === "input" || tagName === "textarea" || tagName === "select") {
    const value = n2.value;
    const checked = n2.checked;
    if (attributes.type !== "radio" && attributes.type !== "checkbox" && attributes.type !== "submit" && attributes.type !== "button" && value) {
      attributes.value = maskInputValue({
        element: n2,
        type: getInputType(n2),
        tagName,
        value,
        maskInputOptions,
        maskInputFn
      });
    } else if (checked) {
      attributes.checked = checked;
    }
  }
  if (tagName === "option") {
    if (n2.selected && !maskInputOptions["select"]) {
      attributes.selected = true;
    } else {
      delete attributes.selected;
    }
  }
  if (tagName === "dialog" && n2.open) {
    attributes.rr_open_mode = n2.matches("dialog:modal") ? "modal" : "non-modal";
  }
  if (tagName === "canvas" && recordCanvas) {
    if (n2.__context === "2d") {
      if (!is2DCanvasBlank(n2)) {
        attributes.rr_dataURL = n2.toDataURL(
          dataURLOptions.type,
          dataURLOptions.quality
        );
      }
    } else if (!("__context" in n2)) {
      const canvasDataURL = n2.toDataURL(
        dataURLOptions.type,
        dataURLOptions.quality
      );
      const blankCanvas = doc.createElement("canvas");
      blankCanvas.width = n2.width;
      blankCanvas.height = n2.height;
      const blankCanvasDataURL = blankCanvas.toDataURL(
        dataURLOptions.type,
        dataURLOptions.quality
      );
      if (canvasDataURL !== blankCanvasDataURL) {
        attributes.rr_dataURL = canvasDataURL;
      }
    }
  }
  if (tagName === "img" && inlineImages) {
    if (!canvasService) {
      canvasService = doc.createElement("canvas");
      canvasCtx = canvasService.getContext("2d");
    }
    const image = n2;
    const imageSrc = image.currentSrc || image.getAttribute("src") || "<unknown-src>";
    const priorCrossOrigin = image.crossOrigin;
    const recordInlineImage = () => {
      image.removeEventListener("load", recordInlineImage);
      try {
        canvasService.width = image.naturalWidth;
        canvasService.height = image.naturalHeight;
        canvasCtx.drawImage(image, 0, 0);
        attributes.rr_dataURL = canvasService.toDataURL(
          dataURLOptions.type,
          dataURLOptions.quality
        );
      } catch (err) {
        if (image.crossOrigin !== "anonymous") {
          image.crossOrigin = "anonymous";
          if (image.complete && image.naturalWidth !== 0)
            recordInlineImage();
          else image.addEventListener("load", recordInlineImage);
          return;
        } else {
          console.warn(
            `Cannot inline img src=${imageSrc}! Error: ${err}`
          );
        }
      }
      if (image.crossOrigin === "anonymous") {
        priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute("crossorigin");
      }
    };
    if (image.complete && image.naturalWidth !== 0) recordInlineImage();
    else image.addEventListener("load", recordInlineImage);
  }
  if (tagName === "audio" || tagName === "video") {
    const mediaAttributes = attributes;
    mediaAttributes.rr_mediaState = n2.paused ? "paused" : "played";
    mediaAttributes.rr_mediaCurrentTime = n2.currentTime;
    mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;
    mediaAttributes.rr_mediaMuted = n2.muted;
    mediaAttributes.rr_mediaLoop = n2.loop;
    mediaAttributes.rr_mediaVolume = n2.volume;
  }
  if (!newlyAddedElement) {
    if (n2.scrollLeft) {
      attributes.rr_scrollLeft = n2.scrollLeft;
    }
    if (n2.scrollTop) {
      attributes.rr_scrollTop = n2.scrollTop;
    }
  }
  if (needBlock) {
    const { width, height } = n2.getBoundingClientRect();
    attributes = {
      class: attributes.class,
      rr_width: `${width}px`,
      rr_height: `${height}px`
    };
  }
  if (tagName === "iframe" && !keepIframeSrcFn(attributes.src)) {
    if (!n2.contentDocument) {
      attributes.rr_src = attributes.src;
    }
    delete attributes.src;
  }
  let isCustomElement;
  try {
    if (customElements.get(tagName)) isCustomElement = true;
  } catch (e2) {
  }
  return {
    type: NodeType$3.Element,
    tagName,
    attributes,
    childNodes: [],
    isSVG: isSVGElement(n2) || void 0,
    needBlock,
    rootId,
    isCustom: isCustomElement
  };
}
function lowerIfExists(maybeAttr) {
  if (maybeAttr === void 0 || maybeAttr === null) {
    return "";
  } else {
    return maybeAttr.toLowerCase();
  }
}
function slimDOMExcluded(sn, slimDOMOptions) {
  if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {
    return true;
  } else if (sn.type === NodeType$3.Element) {
    if (slimDOMOptions.script && // script tag
    (sn.tagName === "script" || // (module)preload link
    sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") && sn.attributes.as === "script" || // prefetch link
    sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && extractFileExtension(sn.attributes.href) === "js")) {
      return true;
    } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(
      /^msapplication-tile(image|color)$/
    ) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {
      return true;
    } else if (sn.tagName === "meta") {
      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
        return true;
      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)
      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {
        return true;
      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {
        return true;
      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {
        return true;
      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {
        return true;
      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {
        return true;
      }
    }
  }
  return false;
}
function serializeNodeWithId(n2, options) {
  const {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild = false,
    inlineStylesheet = true,
    maskInputOptions = {},
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions = {},
    inlineImages = false,
    recordCanvas = false,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout = 5e3,
    onStylesheetLoad,
    stylesheetLoadTimeout = 5e3,
    keepIframeSrcFn = () => false,
    newlyAddedElement = false,
    cssCaptured = false
  } = options;
  let { needsMask } = options;
  let { preserveWhiteSpace = true } = options;
  if (!needsMask) {
    const checkAncestors = needsMask === void 0;
    needsMask = needMaskingText(
      n2,
      maskTextClass,
      maskTextSelector,
      checkAncestors
    );
  }
  const _serializedNode = serializeNode(n2, {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement,
    cssCaptured
  });
  if (!_serializedNode) {
    console.warn(n2, "not serialized");
    return null;
  }
  let id;
  if (mirror2.hasNode(n2)) {
    id = mirror2.getId(n2);
  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\s+|\s+$/gm, "").length) {
    id = IGNORED_NODE;
  } else {
    id = genId();
  }
  const serializedNode = Object.assign(_serializedNode, { id });
  mirror2.add(n2, serializedNode);
  if (id === IGNORED_NODE) {
    return null;
  }
  if (onSerialize) {
    onSerialize(n2);
  }
  let recordChild = !skipChild;
  if (serializedNode.type === NodeType$3.Element) {
    recordChild = recordChild && !serializedNode.needBlock;
    delete serializedNode.needBlock;
    const shadowRootEl = index$1.shadowRoot(n2);
    if (shadowRootEl && isNativeShadowDom(shadowRootEl))
      serializedNode.isShadowHost = true;
  }
  if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {
    if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === "head") {
      preserveWhiteSpace = false;
    }
    const bypassOptions = {
      doc,
      mirror: mirror2,
      blockClass,
      blockSelector,
      needsMask,
      maskTextClass,
      maskTextSelector,
      skipChild,
      inlineStylesheet,
      maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOMOptions,
      dataURLOptions,
      inlineImages,
      recordCanvas,
      preserveWhiteSpace,
      onSerialize,
      onIframeLoad,
      iframeLoadTimeout,
      onStylesheetLoad,
      stylesheetLoadTimeout,
      keepIframeSrcFn,
      cssCaptured: false
    };
    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "textarea" && serializedNode.attributes.value !== void 0) ;
    else {
      if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === "string") {
        bypassOptions.cssCaptured = true;
      }
      for (const childN of Array.from(index$1.childNodes(n2))) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
    let shadowRootEl = null;
    if (isElement(n2) && (shadowRootEl = index$1.shadowRoot(n2))) {
      for (const childN of Array.from(index$1.childNodes(shadowRootEl))) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          isNativeShadowDom(shadowRootEl) && (serializedChildNode.isShadow = true);
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
  }
  const parent = index$1.parentNode(n2);
  if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {
    serializedNode.isShadow = true;
  }
  if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "iframe") {
    onceIframeLoaded(
      n2,
      () => {
        const iframeDoc = n2.contentDocument;
        if (iframeDoc && onIframeLoad) {
          const serializedIframeNode = serializeNodeWithId(iframeDoc, {
            doc: iframeDoc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            needsMask,
            maskTextClass,
            maskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedIframeNode) {
            onIframeLoad(
              n2,
              serializedIframeNode
            );
          }
        }
      },
      iframeLoadTimeout
    );
  }
  if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "link" && typeof serializedNode.attributes.rel === "string" && (serializedNode.attributes.rel === "stylesheet" || serializedNode.attributes.rel === "preload" && typeof serializedNode.attributes.href === "string" && extractFileExtension(serializedNode.attributes.href) === "css")) {
    onceStylesheetLoaded(
      n2,
      () => {
        if (onStylesheetLoad) {
          const serializedLinkNode = serializeNodeWithId(n2, {
            doc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            needsMask,
            maskTextClass,
            maskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedLinkNode) {
            onStylesheetLoad(
              n2,
              serializedLinkNode
            );
          }
        }
      },
      stylesheetLoadTimeout
    );
  }
  return serializedNode;
}
function snapshot(n2, options) {
  const {
    mirror: mirror2 = new Mirror(),
    blockClass = "rr-block",
    blockSelector = null,
    maskTextClass = "rr-mask",
    maskTextSelector = null,
    inlineStylesheet = true,
    inlineImages = false,
    recordCanvas = false,
    maskAllInputs = false,
    maskTextFn,
    maskInputFn,
    slimDOM = false,
    dataURLOptions,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn = () => false
  } = options || {};
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : maskAllInputs === false ? {
    password: true
  } : maskAllInputs;
  const slimDOMOptions = slimDOM === true || slimDOM === "all" ? (
    // if true: set of sensible options that should not throw away any information
    {
      script: true,
      comment: true,
      headFavicon: true,
      headWhitespace: true,
      headMetaDescKeywords: slimDOM === "all",
      // destructive
      headMetaSocial: true,
      headMetaRobots: true,
      headMetaHttpEquiv: true,
      headMetaAuthorship: true,
      headMetaVerification: true
    }
  ) : slimDOM === false ? {} : slimDOM;
  return serializeNodeWithId(n2, {
    doc: n2,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild: false,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn,
    newlyAddedElement: false
  });
}
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace$1(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var picocolors_browser$1 = { exports: {} };
var x$1 = String;
var create$1 = function() {
  return { isColorSupported: false, reset: x$1, bold: x$1, dim: x$1, italic: x$1, underline: x$1, inverse: x$1, hidden: x$1, strikethrough: x$1, black: x$1, red: x$1, green: x$1, yellow: x$1, blue: x$1, magenta: x$1, cyan: x$1, white: x$1, gray: x$1, bgBlack: x$1, bgRed: x$1, bgGreen: x$1, bgYellow: x$1, bgBlue: x$1, bgMagenta: x$1, bgCyan: x$1, bgWhite: x$1 };
};
picocolors_browser$1.exports = create$1();
picocolors_browser$1.exports.createColors = create$1;
var picocolors_browserExports$1 = picocolors_browser$1.exports;
const __viteBrowserExternal$2 = {};
const __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal$2
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);
let pico$1 = picocolors_browserExports$1;
let terminalHighlight$1$1 = require$$2$1;
let CssSyntaxError$3$1 = class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin22) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin22) {
      this.plugin = plugin22;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css = this.source;
    if (color == null) color = pico$1.isColorSupported;
    if (terminalHighlight$1$1) {
      if (color) css = terminalHighlight$1$1(css);
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold, gray, red } = pico$1.createColors(true);
      mark = (text) => bold(red(text));
      aside = (text) => gray(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index2) => {
      let number = start + 1 + index2;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join("\n");
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = "\n\n" + code + "\n";
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError$1 = CssSyntaxError$3$1;
CssSyntaxError$3$1.default = CssSyntaxError$3$1;
var symbols$1 = {};
symbols$1.isClean = Symbol("isClean");
symbols$1.my = Symbol("my");
const DEFAULT_RAW$1 = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize$1(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2$1 = class Stringifier {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node2, semicolon) {
    let name = "@" + node2.name;
    let params = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name += node2.raws.afterName;
    } else if (params) {
      name += " ";
    }
    if (node2.nodes) {
      this.block(node2, name + params);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name + params + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last = node2.nodes.length - 1;
    while (last > 0) {
      if (node2.nodes[last].type !== "comment") break;
      last -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW$1[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize$1(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW$1[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier$1 = Stringifier$2$1;
Stringifier$2$1.default = Stringifier$2$1;
let Stringifier$1$1 = stringifier$1;
function stringify$4$1(node2, builder) {
  let str = new Stringifier$1$1(builder);
  str.stringify(node2);
}
var stringify_1$1 = stringify$4$1;
stringify$4$1.default = stringify$4$1;
let { isClean: isClean$2$1, my: my$2$1 } = symbols$1;
let CssSyntaxError$2$1 = cssSyntaxError$1;
let Stringifier2$1 = stringifier$1;
let stringify$3$1 = stringify_1$1;
function cloneNode$1(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode$1(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode$1(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
let Node$4$1 = class Node2 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2$1] = false;
    this[my$2$1] = true;
    for (let name in defaults) {
      if (name === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s2 = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode$1(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2$1(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2$1]) {
      this[isClean$2$1] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2$1] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
    }
    return pos;
  }
  positionInside(index2, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i2 = 0; i2 < index2; i2++) {
      if (string[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) {
        start = this.positionInside(index2, stringRepresentation);
        end = this.positionInside(index2 + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier2$1();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        continue;
      }
      if (name === "parent" || name === "proxyCache") continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3$1) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node$1 = Node$4$1;
Node$4$1.default = Node$4$1;
let Node$3$1 = node$1;
let Declaration$4$1 = class Declaration extends Node$3$1 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration$1 = Declaration$4$1;
Declaration$4$1.default = Declaration$4$1;
let urlAlphabet$1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet$1 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1$1 = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet$1[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure$1 = { nanoid: nanoid$1$1, customAlphabet: customAlphabet$1 };
let { SourceMapConsumer: SourceMapConsumer$2$1, SourceMapGenerator: SourceMapGenerator$2$1 } = require$$2$1;
let { existsSync: existsSync$1, readFileSync: readFileSync$1 } = require$$2$1;
let { dirname: dirname$1$1, join: join$1 } = require$$2$1;
function fromBase64$1(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2$1 = class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1$1(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2$1(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64$1(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map) {
    if (typeof map !== "object") return false;
    return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments) return;
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname$1$1(path);
    if (existsSync$1(path)) {
      this.mapFile = path;
      return readFileSync$1(path, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer$2$1) {
        return SourceMapGenerator$2$1.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2$1) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join$1(dirname$1$1(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap$1 = PreviousMap$2$1;
PreviousMap$2$1.default = PreviousMap$2$1;
let { SourceMapConsumer: SourceMapConsumer$1$1, SourceMapGenerator: SourceMapGenerator$1$1 } = require$$2$1;
let { fileURLToPath: fileURLToPath$1, pathToFileURL: pathToFileURL$1$1 } = require$$2$1;
let { isAbsolute: isAbsolute$1, resolve: resolve$1$1 } = require$$2$1;
let { nanoid: nanoid$2 } = nonSecure$1;
let terminalHighlight$2 = require$$2$1;
let CssSyntaxError$1$1 = cssSyntaxError$1;
let PreviousMap$1$1 = previousMap$1;
let fromOffsetCache$1 = Symbol("fromOffsetCache");
let sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);
let pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);
let Input$4$1 = class Input {
  constructor(css, opts = {}) {
    if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1$1 || /^\w+:\/\//.test(opts.from) || isAbsolute$1(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1$1(opts.from);
      }
    }
    if (pathAvailable$1$1 && sourceMapAvailable$1$1) {
      let map = new PreviousMap$1$1(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid$2(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result2, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1$1) {
        result2.input.url = pathToFileURL$1$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache$1]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache$1] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache$1];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({ column, line });
    if (!from.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute$1(from.source)) {
      fromUrl = pathToFileURL$1$1(from.source);
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath$1) {
        result2.file = fileURLToPath$1(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name of ["hasBOM", "css", "file", "id"]) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input$1 = Input$4$1;
Input$4$1.default = Input$4$1;
if (terminalHighlight$2 && terminalHighlight$2.registerInput) {
  terminalHighlight$2.registerInput(Input$4$1);
}
let { SourceMapConsumer: SourceMapConsumer$3, SourceMapGenerator: SourceMapGenerator$3 } = require$$2$1;
let { dirname: dirname$2, relative: relative$1, resolve: resolve$2, sep: sep$1 } = require$$2$1;
let { pathToFileURL: pathToFileURL$2 } = require$$2$1;
let Input$3$1 = input$1;
let sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);
let pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);
let MapGenerator$2$1 = class MapGenerator {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname$2(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer$3(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator$3.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator$3({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator$3({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf("\n");
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname$2(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from = dirname$2(resolve$2(from, this.mapOpts.annotation));
    }
    let path = relative$1(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map = node2.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input2 = new Input$3$1(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from = node2.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL$2) {
      let fileURL = pathToFileURL$2(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep$1 === "\\") {
      path = path.replace(/\\/g, "/");
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
};
var mapGenerator$1 = MapGenerator$2$1;
let Node$2$1 = node$1;
let Comment$4$1 = class Comment extends Node$2$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment$1 = Comment$4$1;
Comment$4$1.default = Comment$4$1;
let { isClean: isClean$1$1, my: my$1$1 } = symbols$1;
let Declaration$3$1 = declaration$1;
let Comment$3$1 = comment$1;
let Node$1$1 = node$1;
let parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;
function cleanSource$1(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markDirtyUp$1(node2) {
  node2[isClean$1$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markDirtyUp$1(i2);
    }
  }
}
let Container$7$1 = class Container extends Node$1$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index2, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index2 = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index2], index2);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index2) => i2(child.toProxy(), index2);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex < index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex <= index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource$1(parse$4$1(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3$1(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4$1(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4$1(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3$1(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1$1]) Container.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1$1]) markDirtyUp$1(i2);
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (index2 >= child) {
        this.indexes[id] = index2 - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7$1.registerParse = (dependant) => {
  parse$4$1 = dependant;
};
Container$7$1.registerRule = (dependant) => {
  Rule$4$1 = dependant;
};
Container$7$1.registerAtRule = (dependant) => {
  AtRule$4$1 = dependant;
};
Container$7$1.registerRoot = (dependant) => {
  Root$6$1 = dependant;
};
var container$1 = Container$7$1;
Container$7$1.default = Container$7$1;
Container$7$1.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4$1.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4$1.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3$1.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3$1.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6$1.prototype);
  }
  node2[my$1$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7$1.rebuild(child);
    });
  }
};
let Container$6$1 = container$1;
let LazyResult$4$1, Processor$3$1;
let Document$3$1 = class Document2 extends Container$6$1 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);
    return lazy.stringify();
  }
};
Document$3$1.registerLazyResult = (dependant) => {
  LazyResult$4$1 = dependant;
};
Document$3$1.registerProcessor = (dependant) => {
  Processor$3$1 = dependant;
};
var document$1$1 = Document$3$1;
Document$3$1.default = Document$3$1;
let printed$1 = {};
var warnOnce$2$1 = function warnOnce(message) {
  if (printed$1[message]) return;
  printed$1[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Warning$2$1 = class Warning {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning$1 = Warning$2$1;
Warning$2$1.default = Warning$2$1;
let Warning$1$1 = warning$1;
let Result$3$1 = class Result {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result$1 = Result$3$1;
Result$3$1.default = Result$3$1;
const SINGLE_QUOTE$1 = "'".charCodeAt(0);
const DOUBLE_QUOTE$1 = '"'.charCodeAt(0);
const BACKSLASH$1 = "\\".charCodeAt(0);
const SLASH$1 = "/".charCodeAt(0);
const NEWLINE$1 = "\n".charCodeAt(0);
const SPACE$1 = " ".charCodeAt(0);
const FEED$1 = "\f".charCodeAt(0);
const TAB$1 = "	".charCodeAt(0);
const CR$1 = "\r".charCodeAt(0);
const OPEN_SQUARE$1 = "[".charCodeAt(0);
const CLOSE_SQUARE$1 = "]".charCodeAt(0);
const OPEN_PARENTHESES$1 = "(".charCodeAt(0);
const CLOSE_PARENTHESES$1 = ")".charCodeAt(0);
const OPEN_CURLY$1 = "{".charCodeAt(0);
const CLOSE_CURLY$1 = "}".charCodeAt(0);
const SEMICOLON$1 = ";".charCodeAt(0);
const ASTERISK$1 = "*".charCodeAt(0);
const COLON$1 = ":".charCodeAt(0);
const AT$1 = "@".charCodeAt(0);
const RE_AT_END$1 = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END$1 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET$1 = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE$1 = /[\da-f]/i;
var tokenize$1 = function tokenizer(input2, options = {}) {
  let css = input2.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, next, quote, content, escape;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE$1:
      case SPACE$1:
      case TAB$1:
      case CR$1:
      case FEED$1: {
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);
        currentToken = ["space", css.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE$1:
      case CLOSE_SQUARE$1:
      case OPEN_CURLY$1:
      case CLOSE_CURLY$1:
      case COLON$1:
      case SEMICOLON$1:
      case CLOSE_PARENTHESES$1: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES$1: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH$1) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css.indexOf(")", pos + 1);
          content = css.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET$1.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE$1:
      case DOUBLE_QUOTE$1: {
        quote = code === SINGLE_QUOTE$1 ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === BACKSLASH$1) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT$1: {
        RE_AT_END$1.lastIndex = pos + 1;
        RE_AT_END$1.test(css);
        if (RE_AT_END$1.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END$1.lastIndex - 2;
        }
        currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH$1: {
        next = pos;
        escape = true;
        while (css.charCodeAt(next + 1) === BACKSLASH$1) {
          next += 1;
          escape = !escape;
        }
        code = css.charCodeAt(next + 1);
        if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {
          next += 1;
          if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE$1.test(css.charAt(next + 1))) {
              next += 1;
            }
            if (css.charCodeAt(next + 1) === SPACE$1) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {
          next = css.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END$1.lastIndex = pos + 1;
          RE_WORD_END$1.test(css);
          if (RE_WORD_END$1.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END$1.lastIndex - 2;
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let Container$5$1 = container$1;
let AtRule$3$1 = class AtRule extends Container$5$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule$1 = AtRule$3$1;
AtRule$3$1.default = AtRule$3$1;
Container$5$1.registerAtRule(AtRule$3$1);
let Container$4$1 = container$1;
let LazyResult$3$1, Processor$2$1;
let Root$5$1 = class Root extends Container$4$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index2 = this.index(child);
    if (!ignore && index2 === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index2].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);
    return lazy.stringify();
  }
};
Root$5$1.registerLazyResult = (dependant) => {
  LazyResult$3$1 = dependant;
};
Root$5$1.registerProcessor = (dependant) => {
  Processor$2$1 = dependant;
};
var root$1 = Root$5$1;
Root$5$1.default = Root$5$1;
Container$4$1.registerRoot(Root$5$1);
let list$2$1 = {
  comma(string) {
    return list$2$1.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2$1.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === "\\") {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1$1 = list$2$1;
list$2$1.default = list$2$1;
let Container$3$1 = container$1;
let list$1$1 = list_1$1;
let Rule$3$1 = class Rule extends Container$3$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule$1 = Rule$3$1;
Rule$3$1.default = Rule$3$1;
Container$3$1.registerRule(Rule$3$1);
let Declaration$2$1 = declaration$1;
let tokenizer2$1 = tokenize$1;
let Comment$2$1 = comment$1;
let AtRule$2$1 = atRule$1;
let Root$4$1 = root$1;
let Rule$2$1 = rule$1;
const SAFE_COMMENT_NEIGHBOR$1 = {
  empty: true,
  space: true
};
function findLastWithPosition$1(tokens) {
  for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
    let token = tokens[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1$1 = class Parser {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4$1();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$2$1();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node2, "params", params);
      if (last) {
        token = params[params.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens) {
    let brackets = 0;
    let token, type, prev;
    for (let [i2, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$2$1();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node2.text = "";
      node2.raws.left = text;
      node2.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer2$1(this.input);
  }
  decl(tokens, customProperty) {
    let node2 = new Declaration$2$1();
    this.init(node2, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node2.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition$1(tokens)
    );
    node2.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1) this.unknownWord(tokens);
      node2.raws.before += tokens.shift()[1];
    }
    node2.source.start = this.getPosition(tokens[0][2]);
    node2.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens, i2);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node2.important = true;
          node2.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$2$1();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length; i2 += 1) {
      token = tokens[i2];
      type = token[0];
      if (type === "space" && i2 === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
        next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node2 = new Rule$2$1();
    this.init(node2, tokens[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node2, "selector", tokens);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result2 = "";
    for (let i2 = from; i2 < tokens.length; i2++) {
      result2 += tokens[i2][1];
    }
    tokens.splice(from, tokens.length - from);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser$1 = Parser$1$1;
let Container$2$1 = container$1;
let Parser2$1 = parser$1;
let Input$2$1 = input$1;
function parse$3$1(css, opts) {
  let input2 = new Input$2$1(css, opts);
  let parser2 = new Parser2$1(input2);
  try {
    parser2.parse();
  } catch (e2) {
    if (false) // removed by dead control flow
{}
    throw e2;
  }
  return parser2.root;
}
var parse_1$1 = parse$3$1;
parse$3$1.default = parse$3$1;
Container$2$1.registerParse(parse$3$1);
let { isClean: isClean$3, my: my$3 } = symbols$1;
let MapGenerator$1$1 = mapGenerator$1;
let stringify$2$1 = stringify_1$1;
let Container$1$1 = container$1;
let Document$2$1 = document$1$1;
let warnOnce$1$1 = (/* unused pure expression or super */ null && (0));
let Result$2$1 = result$1;
let parse$2$1 = parse_1$1;
let Root$3$1 = root$1;
const TYPE_TO_CLASS_NAME$1 = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS$1 = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS$1 = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN$1 = 0;
function isPromise$1(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents$1(node2) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME$1[node2.type];
  if (node2.type === "decl") {
    key = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key = node2.name.toLowerCase();
  }
  if (key && node2.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN$1,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node2.append) {
    return [type, CHILDREN$1, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack$1(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN$1, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN$1, "RootExit"];
  } else {
    events = getEvents$1(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks$1(node2) {
  node2[isClean$3] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks$1(i2));
  return node2;
}
let postcss$2$1 = {};
let LazyResult$2$1 = class LazyResult {
  constructor(processor2, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
      root2 = cleanMarks$1(css);
    } else if (css instanceof LazyResult || css instanceof Result$2$1) {
      root2 = cleanMarks$1(css.root);
      if (css.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser2 = parse$2$1;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my$3]) {
        Container$1$1.rebuild(root2);
      }
    }
    this.result = new Result$2$1(processor2, root2, opts);
    this.helpers = { ...postcss$2$1, postcss: postcss$2$1, result: this.result };
    this.plugins = this.processor.plugins.map((plugin22) => {
      if (typeof plugin22 === "object" && plugin22.prepare) {
        return { ...plugin22, ...plugin22.prepare(this.result) };
      } else {
        return plugin22;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin22 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin22.postcssPlugin;
        error.setMessage();
      } else if (plugin22.postcssVersion) {
        if (false) // removed by dead control flow
{}
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin22, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin22, cb]);
    };
    for (let plugin22 of this.plugins) {
      if (typeof plugin22 === "object") {
        for (let event in plugin22) {
          if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin22.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS$1[event]) {
            if (typeof plugin22[event] === "object") {
              for (let filter in plugin22[event]) {
                if (filter === "*") {
                  add(plugin22, event, plugin22[event][filter]);
                } else {
                  add(
                    plugin22,
                    event + "-" + filter.toLowerCase(),
                    plugin22[event][filter]
                  );
                }
              }
            } else if (typeof plugin22[event] === "function") {
              add(plugin22, event, plugin22[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin22 = this.plugins[i2];
      let promise = this.runOnRoot(plugin22);
      if (isPromise$1(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean$3]) {
        root2[isClean$3] = true;
        let stack = [toStack$1(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise$1(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e2, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin22, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin22;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin22) {
    this.result.lastPlugin = plugin22;
    try {
      if (typeof plugin22 === "object" && plugin22.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin22.Once(root2, this.helpers)
          );
          if (isPromise$1(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin22.Once(this.result.root, this.helpers);
      } else if (typeof plugin22 === "function") {
        return plugin22(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2$1;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator$1$1(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin22 of this.plugins) {
      let promise = this.runOnRoot(plugin22);
      if (isPromise$1(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean$3]) {
        root2[isClean$3] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (false) // removed by dead control flow
{}
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin22, visitor] of visitors) {
      this.result.lastPlugin = plugin22;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise$1(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit2 = stack[stack.length - 1];
    let { node: node2, visitors } = visit2;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
      let [plugin22, visitor] = visitors[visit2.visitorIndex];
      visit2.visitorIndex += 1;
      if (visit2.visitorIndex === visitors.length) {
        visit2.visitors = [];
        visit2.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin22;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2);
      }
    }
    if (visit2.iterator !== 0) {
      let iterator = visit2.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean$3]) {
          child[isClean$3] = true;
          stack.push(toStack$1(child));
          return;
        }
      }
      visit2.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit2.events;
    while (visit2.eventIndex < events.length) {
      let event = events[visit2.eventIndex];
      visit2.eventIndex += 1;
      if (event === CHILDREN$1) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean$3] = true;
          visit2.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit2.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean$3] = true;
    let events = getEvents$1(node2);
    for (let event of events) {
      if (event === CHILDREN$1) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean$3]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2$1.registerPostcss = (dependant) => {
  postcss$2$1 = dependant;
};
var lazyResult$1 = LazyResult$2$1;
LazyResult$2$1.default = LazyResult$2$1;
Root$3$1.registerLazyResult(LazyResult$2$1);
Document$2$1.registerLazyResult(LazyResult$2$1);
let MapGenerator2$1 = mapGenerator$1;
let stringify$1$1 = stringify_1$1;
let warnOnce2$1 = (/* unused pure expression or super */ null && (0));
let parse$1$1 = parse_1$1;
const Result$1$1 = result$1;
let NoWorkResult$1$1 = class NoWorkResult {
  constructor(processor2, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1$1;
    this.result = new Result$1$1(this._processor, root2, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator2$1(str, root2, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (false) // removed by dead control flow
{}
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult$1 = NoWorkResult$1$1;
NoWorkResult$1$1.default = NoWorkResult$1$1;
let NoWorkResult2$1 = noWorkResult$1;
let LazyResult$1$1 = lazyResult$1;
let Document$1$1 = document$1$1;
let Root$2$1 = root$1;
let Processor$1$1 = class Processor {
  constructor(plugins = []) {
    this.version = "8.4.38";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (false) // removed by dead control flow
{}
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult2$1(this, css, opts);
    } else {
      return new LazyResult$1$1(this, css, opts);
    }
  }
  use(plugin22) {
    this.plugins = this.plugins.concat(this.normalize([plugin22]));
    return this;
  }
};
var processor$1 = Processor$1$1;
Processor$1$1.default = Processor$1$1;
Root$2$1.registerProcessor(Processor$1$1);
Document$1$1.registerProcessor(Processor$1$1);
let Declaration$1$1 = declaration$1;
let PreviousMap2$1 = previousMap$1;
let Comment$1$1 = comment$1;
let AtRule$1$1 = atRule$1;
let Input$1$1 = input$1;
let Root$1$1 = root$1;
let Rule$1$1 = rule$1;
function fromJSON$1$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n2) => fromJSON$1$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap2$1.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$1$1(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1$1 = fromJSON$1$1;
fromJSON$1$1.default = fromJSON$1$1;
let CssSyntaxError2$1 = cssSyntaxError$1;
let Declaration2$1 = declaration$1;
let LazyResult2$1 = lazyResult$1;
let Container2$1 = container$1;
let Processor2$1 = processor$1;
let stringify$5 = stringify_1$1;
let fromJSON$2 = fromJSON_1$1;
let Document22 = document$1$1;
let Warning2$1 = warning$1;
let Comment2$1 = comment$1;
let AtRule2$1 = atRule$1;
let Result2$1 = result$1;
let Input2$1 = input$1;
let parse$5 = parse_1$1;
let list$3 = list_1$1;
let Rule2$1 = rule$1;
let Root2$1 = root$1;
let Node2$1 = node$1;
function postcss$3(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor2$1(plugins);
}
postcss$3.plugin = function plugin(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name + ": é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor2$1().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function(css, processOpts, pluginOpts) {
    return postcss$3([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss$3.stringify = stringify$5;
postcss$3.parse = parse$5;
postcss$3.fromJSON = fromJSON$2;
postcss$3.list = list$3;
postcss$3.comment = (defaults) => new Comment2$1(defaults);
postcss$3.atRule = (defaults) => new AtRule2$1(defaults);
postcss$3.decl = (defaults) => new Declaration2$1(defaults);
postcss$3.rule = (defaults) => new Rule2$1(defaults);
postcss$3.root = (defaults) => new Root2$1(defaults);
postcss$3.document = (defaults) => new Document22(defaults);
postcss$3.CssSyntaxError = CssSyntaxError2$1;
postcss$3.Declaration = Declaration2$1;
postcss$3.Container = Container2$1;
postcss$3.Processor = Processor2$1;
postcss$3.Document = Document22;
postcss$3.Comment = Comment2$1;
postcss$3.Warning = Warning2$1;
postcss$3.AtRule = AtRule2$1;
postcss$3.Result = Result2$1;
postcss$3.Input = Input2$1;
postcss$3.Rule = Rule2$1;
postcss$3.Root = Root2$1;
postcss$3.Node = Node2$1;
LazyResult2$1.registerPostcss(postcss$3);
var postcss_1$1 = postcss$3;
postcss$3.default = postcss$3;
const postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);
postcss$1$1.stringify;
postcss$1$1.fromJSON;
postcss$1$1.plugin;
postcss$1$1.parse;
postcss$1$1.list;
postcss$1$1.document;
postcss$1$1.comment;
postcss$1$1.atRule;
postcss$1$1.rule;
postcss$1$1.decl;
postcss$1$1.root;
postcss$1$1.CssSyntaxError;
postcss$1$1.Declaration;
postcss$1$1.Container;
postcss$1$1.Processor;
postcss$1$1.Document;
postcss$1$1.Comment;
postcss$1$1.Warning;
postcss$1$1.AtRule;
postcss$1$1.Result;
postcss$1$1.Input;
postcss$1$1.Rule;
postcss$1$1.Root;
postcss$1$1.Node;
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var picocolors_browser = { exports: {} };
var x = String;
var create = function() {
  return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
};
picocolors_browser.exports = create();
picocolors_browser.exports.createColors = create;
var picocolors_browserExports = picocolors_browser.exports;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
let pico = picocolors_browserExports;
let terminalHighlight$1 = require$$2;
let CssSyntaxError$3 = class CssSyntaxError2 extends Error {
  constructor(message, line, column, source, file, plugin22) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin22) {
      this.plugin = plugin22;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError2);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css = this.source;
    if (color == null) color = pico.isColorSupported;
    if (terminalHighlight$1) {
      if (color) css = terminalHighlight$1(css);
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold, gray, red } = pico.createColors(true);
      mark = (text) => bold(red(text));
      aside = (text) => gray(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index2) => {
      let number = start + 1 + index2;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join("\n");
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = "\n\n" + code + "\n";
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError = CssSyntaxError$3;
CssSyntaxError$3.default = CssSyntaxError$3;
var symbols = {};
symbols.isClean = Symbol("isClean");
symbols.my = Symbol("my");
const DEFAULT_RAW = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2 = class Stringifier2 {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node2, semicolon) {
    let name = "@" + node2.name;
    let params = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name += node2.raws.afterName;
    } else if (params) {
      name += " ";
    }
    if (node2.nodes) {
      this.block(node2, name + params);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name + params + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last = node2.nodes.length - 1;
    while (last > 0) {
      if (node2.nodes[last].type !== "comment") break;
      last -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier = Stringifier$2;
Stringifier$2.default = Stringifier$2;
let Stringifier$1 = stringifier;
function stringify$4(node2, builder) {
  let str = new Stringifier$1(builder);
  str.stringify(node2);
}
var stringify_1 = stringify$4;
stringify$4.default = stringify$4;
let { isClean: isClean$2, my: my$2 } = symbols;
let CssSyntaxError$2 = cssSyntaxError;
let Stringifier22 = stringifier;
let stringify$3 = stringify_1;
function cloneNode(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
let Node$4 = class Node3 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2] = false;
    this[my$2] = true;
    for (let name in defaults) {
      if (name === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s2 = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2]) {
      this[isClean$2] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
    }
    return pos;
  }
  positionInside(index2, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i2 = 0; i2 < index2; i2++) {
      if (string[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) {
        start = this.positionInside(index2, stringRepresentation);
        end = this.positionInside(index2 + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier22();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        continue;
      }
      if (name === "parent" || name === "proxyCache") continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node = Node$4;
Node$4.default = Node$4;
let Node$3 = node;
let Declaration$4 = class Declaration2 extends Node$3 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration = Declaration$4;
Declaration$4.default = Declaration$4;
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1 = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure = { nanoid: nanoid$1, customAlphabet };
let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require$$2;
let { existsSync, readFileSync } = require$$2;
let { dirname: dirname$1, join } = require$$2;
function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2 = class PreviousMap2 {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map) {
    if (typeof map !== "object") return false;
    return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments) return;
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname$1(path);
    if (existsSync(path)) {
      this.mapFile = path;
      return readFileSync(path, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer$2) {
        return SourceMapGenerator$2.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join(dirname$1(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap = PreviousMap$2;
PreviousMap$2.default = PreviousMap$2;
let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require$$2;
let { fileURLToPath, pathToFileURL: pathToFileURL$1 } = require$$2;
let { isAbsolute, resolve: resolve$1 } = require$$2;
let { nanoid } = nonSecure;
let terminalHighlight = require$$2;
let CssSyntaxError$1 = cssSyntaxError;
let PreviousMap$1 = previousMap;
let fromOffsetCache = Symbol("fromOffsetCache");
let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
let pathAvailable$1 = Boolean(resolve$1 && isAbsolute);
let Input$4 = class Input2 {
  constructor(css, opts = {}) {
    if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1(opts.from);
      }
    }
    if (pathAvailable$1 && sourceMapAvailable$1) {
      let map = new PreviousMap$1(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result2, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1) {
        result2.input.url = pathToFileURL$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({ column, line });
    if (!from.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL$1(from.source);
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath) {
        result2.file = fileURLToPath(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name of ["hasBOM", "css", "file", "id"]) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input = Input$4;
Input$4.default = Input$4;
if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input$4);
}
let { SourceMapConsumer, SourceMapGenerator } = require$$2;
let { dirname, relative, resolve, sep } = require$$2;
let { pathToFileURL } = require$$2;
let Input$3 = input;
let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
let pathAvailable = Boolean(dirname && resolve && relative && sep);
let MapGenerator$2 = class MapGenerator2 {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf("\n");
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from = dirname(resolve(from, this.mapOpts.annotation));
    }
    let path = relative(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map = node2.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input2 = new Input$3(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from = node2.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep === "\\") {
      path = path.replace(/\\/g, "/");
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
};
var mapGenerator = MapGenerator$2;
let Node$2 = node;
let Comment$4 = class Comment2 extends Node$2 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment = Comment$4;
Comment$4.default = Comment$4;
let { isClean: isClean$1, my: my$1 } = symbols;
let Declaration$3 = declaration;
let Comment$3 = comment;
let Node$1 = node;
let parse$4, Rule$4, AtRule$4, Root$6;
function cleanSource(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markDirtyUp(node2) {
  node2[isClean$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markDirtyUp(i2);
    }
  }
}
let Container$7 = class Container2 extends Node$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index2, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index2 = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index2], index2);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index2) => i2(child.toProxy(), index2);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex < index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex <= index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource(parse$4(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1]) Container2.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1]) markDirtyUp(i2);
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (index2 >= child) {
        this.indexes[id] = index2 - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7.registerParse = (dependant) => {
  parse$4 = dependant;
};
Container$7.registerRule = (dependant) => {
  Rule$4 = dependant;
};
Container$7.registerAtRule = (dependant) => {
  AtRule$4 = dependant;
};
Container$7.registerRoot = (dependant) => {
  Root$6 = dependant;
};
var container = Container$7;
Container$7.default = Container$7;
Container$7.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6.prototype);
  }
  node2[my$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7.rebuild(child);
    });
  }
};
let Container$6 = container;
let LazyResult$4, Processor$3;
let Document$3 = class Document23 extends Container$6 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4(new Processor$3(), this, opts);
    return lazy.stringify();
  }
};
Document$3.registerLazyResult = (dependant) => {
  LazyResult$4 = dependant;
};
Document$3.registerProcessor = (dependant) => {
  Processor$3 = dependant;
};
var document$1 = Document$3;
Document$3.default = Document$3;
let printed = {};
var warnOnce$2 = function warnOnce2(message) {
  if (printed[message]) return;
  printed[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Warning$2 = class Warning2 {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning = Warning$2;
Warning$2.default = Warning$2;
let Warning$1 = warning;
let Result$3 = class Result2 {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result = Result$3;
Result$3.default = Result$3;
const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = "\\".charCodeAt(0);
const SLASH = "/".charCodeAt(0);
const NEWLINE = "\n".charCodeAt(0);
const SPACE = " ".charCodeAt(0);
const FEED = "\f".charCodeAt(0);
const TAB = "	".charCodeAt(0);
const CR = "\r".charCodeAt(0);
const OPEN_SQUARE = "[".charCodeAt(0);
const CLOSE_SQUARE = "]".charCodeAt(0);
const OPEN_PARENTHESES = "(".charCodeAt(0);
const CLOSE_PARENTHESES = ")".charCodeAt(0);
const OPEN_CURLY = "{".charCodeAt(0);
const CLOSE_CURLY = "}".charCodeAt(0);
const SEMICOLON = ";".charCodeAt(0);
const ASTERISK = "*".charCodeAt(0);
const COLON = ":".charCodeAt(0);
const AT = "@".charCodeAt(0);
const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE = /[\da-f]/i;
var tokenize = function tokenizer2(input2, options = {}) {
  let css = input2.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, next, quote, content, escape;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
        currentToken = ["space", css.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css.indexOf(")", pos + 1);
          content = css.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT: {
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css);
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }
        currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH: {
        next = pos;
        escape = true;
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape = !escape;
        }
        code = css.charCodeAt(next + 1);
        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1;
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css);
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let Container$5 = container;
let AtRule$3 = class AtRule2 extends Container$5 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule = AtRule$3;
AtRule$3.default = AtRule$3;
Container$5.registerAtRule(AtRule$3);
let Container$4 = container;
let LazyResult$3, Processor$2;
let Root$5 = class Root2 extends Container$4 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index2 = this.index(child);
    if (!ignore && index2 === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index2].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3(new Processor$2(), this, opts);
    return lazy.stringify();
  }
};
Root$5.registerLazyResult = (dependant) => {
  LazyResult$3 = dependant;
};
Root$5.registerProcessor = (dependant) => {
  Processor$2 = dependant;
};
var root = Root$5;
Root$5.default = Root$5;
Container$4.registerRoot(Root$5);
let list$2 = {
  comma(string) {
    return list$2.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === "\\") {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1 = list$2;
list$2.default = list$2;
let Container$3 = container;
let list$1 = list_1;
let Rule$3 = class Rule2 extends Container$3 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule = Rule$3;
Rule$3.default = Rule$3;
Container$3.registerRule(Rule$3);
let Declaration$2 = declaration;
let tokenizer22 = tokenize;
let Comment$2 = comment;
let AtRule$2 = atRule;
let Root$4 = root;
let Rule$2 = rule;
const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};
function findLastWithPosition(tokens) {
  for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
    let token = tokens[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1 = class Parser2 {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$2();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node2, "params", params);
      if (last) {
        token = params[params.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens) {
    let brackets = 0;
    let token, type, prev;
    for (let [i2, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$2();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node2.text = "";
      node2.raws.left = text;
      node2.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer22(this.input);
  }
  decl(tokens, customProperty) {
    let node2 = new Declaration$2();
    this.init(node2, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node2.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    );
    node2.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1) this.unknownWord(tokens);
      node2.raws.before += tokens.shift()[1];
    }
    node2.source.start = this.getPosition(tokens[0][2]);
    node2.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens, i2);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node2.important = true;
          node2.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$2();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length; i2 += 1) {
      token = tokens[i2];
      type = token[0];
      if (type === "space" && i2 === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
        next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node2 = new Rule$2();
    this.init(node2, tokens[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node2, "selector", tokens);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result2 = "";
    for (let i2 = from; i2 < tokens.length; i2++) {
      result2 += tokens[i2][1];
    }
    tokens.splice(from, tokens.length - from);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser = Parser$1;
let Container$2 = container;
let Parser22 = parser;
let Input$2 = input;
function parse$3(css, opts) {
  let input2 = new Input$2(css, opts);
  let parser2 = new Parser22(input2);
  try {
    parser2.parse();
  } catch (e2) {
    if (false) // removed by dead control flow
{}
    throw e2;
  }
  return parser2.root;
}
var parse_1 = parse$3;
parse$3.default = parse$3;
Container$2.registerParse(parse$3);
let { isClean, my } = symbols;
let MapGenerator$1 = mapGenerator;
let stringify$2 = stringify_1;
let Container$1 = container;
let Document$2 = document$1;
let warnOnce$1 = (/* unused pure expression or super */ null && (0));
let Result$2 = result;
let parse$2 = parse_1;
let Root$3 = root;
const TYPE_TO_CLASS_NAME = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN = 0;
function isPromise(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents(node2) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME[node2.type];
  if (node2.type === "decl") {
    key = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key = node2.name.toLowerCase();
  }
  if (key && node2.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node2.append) {
    return [type, CHILDREN, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN, "RootExit"];
  } else {
    events = getEvents(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks(node2) {
  node2[isClean] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks(i2));
  return node2;
}
let postcss$2 = {};
let LazyResult$2 = class LazyResult2 {
  constructor(processor2, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
      root2 = cleanMarks(css);
    } else if (css instanceof LazyResult2 || css instanceof Result$2) {
      root2 = cleanMarks(css.root);
      if (css.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser2 = parse$2;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my]) {
        Container$1.rebuild(root2);
      }
    }
    this.result = new Result$2(processor2, root2, opts);
    this.helpers = { ...postcss$2, postcss: postcss$2, result: this.result };
    this.plugins = this.processor.plugins.map((plugin22) => {
      if (typeof plugin22 === "object" && plugin22.prepare) {
        return { ...plugin22, ...plugin22.prepare(this.result) };
      } else {
        return plugin22;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin22 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin22.postcssPlugin;
        error.setMessage();
      } else if (plugin22.postcssVersion) {
        if (false) // removed by dead control flow
{}
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin22, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin22, cb]);
    };
    for (let plugin22 of this.plugins) {
      if (typeof plugin22 === "object") {
        for (let event in plugin22) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin22.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin22[event] === "object") {
              for (let filter in plugin22[event]) {
                if (filter === "*") {
                  add(plugin22, event, plugin22[event][filter]);
                } else {
                  add(
                    plugin22,
                    event + "-" + filter.toLowerCase(),
                    plugin22[event][filter]
                  );
                }
              }
            } else if (typeof plugin22[event] === "function") {
              add(plugin22, event, plugin22[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin22 = this.plugins[i2];
      let promise = this.runOnRoot(plugin22);
      if (isPromise(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        let stack = [toStack(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e2, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin22, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin22;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin22) {
    this.result.lastPlugin = plugin22;
    try {
      if (typeof plugin22 === "object" && plugin22.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin22.Once(root2, this.helpers)
          );
          if (isPromise(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin22.Once(this.result.root, this.helpers);
      } else if (typeof plugin22 === "function") {
        return plugin22(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator$1(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin22 of this.plugins) {
      let promise = this.runOnRoot(plugin22);
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (false) // removed by dead control flow
{}
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin22, visitor] of visitors) {
      this.result.lastPlugin = plugin22;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit2 = stack[stack.length - 1];
    let { node: node2, visitors } = visit2;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
      let [plugin22, visitor] = visitors[visit2.visitorIndex];
      visit2.visitorIndex += 1;
      if (visit2.visitorIndex === visitors.length) {
        visit2.visitors = [];
        visit2.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin22;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2);
      }
    }
    if (visit2.iterator !== 0) {
      let iterator = visit2.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean]) {
          child[isClean] = true;
          stack.push(toStack(child));
          return;
        }
      }
      visit2.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit2.events;
    while (visit2.eventIndex < events.length) {
      let event = events[visit2.eventIndex];
      visit2.eventIndex += 1;
      if (event === CHILDREN) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean] = true;
          visit2.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit2.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean] = true;
    let events = getEvents(node2);
    for (let event of events) {
      if (event === CHILDREN) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2.registerPostcss = (dependant) => {
  postcss$2 = dependant;
};
var lazyResult = LazyResult$2;
LazyResult$2.default = LazyResult$2;
Root$3.registerLazyResult(LazyResult$2);
Document$2.registerLazyResult(LazyResult$2);
let MapGenerator22 = mapGenerator;
let stringify$1 = stringify_1;
let warnOnce22 = (/* unused pure expression or super */ null && (0));
let parse$1 = parse_1;
const Result$1 = result;
let NoWorkResult$1 = class NoWorkResult2 {
  constructor(processor2, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1;
    this.result = new Result$1(this._processor, root2, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator22(str, root2, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (false) // removed by dead control flow
{}
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult = NoWorkResult$1;
NoWorkResult$1.default = NoWorkResult$1;
let NoWorkResult22 = noWorkResult;
let LazyResult$1 = lazyResult;
let Document$1 = document$1;
let Root$2 = root;
let Processor$1 = class Processor2 {
  constructor(plugins = []) {
    this.version = "8.4.38";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (false) // removed by dead control flow
{}
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult22(this, css, opts);
    } else {
      return new LazyResult$1(this, css, opts);
    }
  }
  use(plugin22) {
    this.plugins = this.plugins.concat(this.normalize([plugin22]));
    return this;
  }
};
var processor = Processor$1;
Processor$1.default = Processor$1;
Root$2.registerProcessor(Processor$1);
Document$1.registerProcessor(Processor$1);
let Declaration$1 = declaration;
let PreviousMap22 = previousMap;
let Comment$1 = comment;
let AtRule$1 = atRule;
let Input$1 = input;
let Root$1 = root;
let Rule$1 = rule;
function fromJSON$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n2) => fromJSON$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap22.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$1(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1 = fromJSON$1;
fromJSON$1.default = fromJSON$1;
let CssSyntaxError22 = cssSyntaxError;
let Declaration22 = declaration;
let LazyResult22 = lazyResult;
let Container22 = container;
let Processor22 = processor;
let stringify = stringify_1;
let fromJSON = fromJSON_1;
let Document222 = document$1;
let Warning22 = warning;
let Comment22 = comment;
let AtRule22 = atRule;
let Result22 = result;
let Input22 = input;
let parse = parse_1;
let list = list_1;
let Rule22 = rule;
let Root22 = root;
let Node22 = node;
function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor22(plugins);
}
postcss.plugin = function plugin2(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name + ": é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor22().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function(css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss.stringify = stringify;
postcss.parse = parse;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = (defaults) => new Comment22(defaults);
postcss.atRule = (defaults) => new AtRule22(defaults);
postcss.decl = (defaults) => new Declaration22(defaults);
postcss.rule = (defaults) => new Rule22(defaults);
postcss.root = (defaults) => new Root22(defaults);
postcss.document = (defaults) => new Document222(defaults);
postcss.CssSyntaxError = CssSyntaxError22;
postcss.Declaration = Declaration22;
postcss.Container = Container22;
postcss.Processor = Processor22;
postcss.Document = Document222;
postcss.Comment = Comment22;
postcss.Warning = Warning22;
postcss.AtRule = AtRule22;
postcss.Result = Result22;
postcss.Input = Input22;
postcss.Rule = Rule22;
postcss.Root = Root22;
postcss.Node = Node22;
LazyResult22.registerPostcss(postcss);
var postcss_1 = postcss;
postcss.default = postcss;
const postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);
postcss$1.stringify;
postcss$1.fromJSON;
postcss$1.plugin;
postcss$1.parse;
postcss$1.list;
postcss$1.document;
postcss$1.comment;
postcss$1.atRule;
postcss$1.rule;
postcss$1.decl;
postcss$1.root;
postcss$1.CssSyntaxError;
postcss$1.Declaration;
postcss$1.Container;
postcss$1.Processor;
postcss$1.Document;
postcss$1.Comment;
postcss$1.Warning;
postcss$1.AtRule;
postcss$1.Result;
postcss$1.Input;
postcss$1.Rule;
postcss$1.Root;
postcss$1.Node;
class BaseRRNode {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  constructor(..._args) {
    __publicField2(this, "parentElement", null);
    __publicField2(this, "parentNode", null);
    __publicField2(this, "ownerDocument");
    __publicField2(this, "firstChild", null);
    __publicField2(this, "lastChild", null);
    __publicField2(this, "previousSibling", null);
    __publicField2(this, "nextSibling", null);
    __publicField2(this, "ELEMENT_NODE", 1);
    __publicField2(this, "TEXT_NODE", 3);
    __publicField2(this, "nodeType");
    __publicField2(this, "nodeName");
    __publicField2(this, "RRNodeType");
  }
  get childNodes() {
    const childNodes2 = [];
    let childIterator = this.firstChild;
    while (childIterator) {
      childNodes2.push(childIterator);
      childIterator = childIterator.nextSibling;
    }
    return childNodes2;
  }
  contains(node2) {
    if (!(node2 instanceof BaseRRNode)) return false;
    else if (node2.ownerDocument !== this.ownerDocument) return false;
    else if (node2 === this) return true;
    while (node2.parentNode) {
      if (node2.parentNode === this) return true;
      node2 = node2.parentNode;
    }
    return false;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  appendChild(_newChild) {
    throw new Error(
      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  insertBefore(_newChild, _refChild) {
    throw new Error(
      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeChild(_node) {
    throw new Error(
      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  toString() {
    return "RRNode";
  }
}
const testableAccessors = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
};
const testableMethods = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
};
const untaintedBasePrototype = {};
const isAngularZonePresent = () => {
  return !!globalThis.Zone;
};
function getUntaintedPrototype(key) {
  if (untaintedBasePrototype[key])
    return untaintedBasePrototype[key];
  const defaultObj = globalThis[key];
  const defaultPrototype = defaultObj.prototype;
  const accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;
  const isUntaintedAccessors = Boolean(
    accessorNames && // @ts-expect-error 2345
    accessorNames.every(
      (accessor) => {
        var _a2, _b;
        return Boolean(
          (_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes("[native code]")
        );
      }
    )
  );
  const methodNames = key in testableMethods ? testableMethods[key] : void 0;
  const isUntaintedMethods = Boolean(
    methodNames && methodNames.every(
      // @ts-expect-error 2345
      (method) => {
        var _a2;
        return typeof defaultPrototype[method] === "function" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes("[native code]"));
      }
    )
  );
  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {
    untaintedBasePrototype[key] = defaultObj.prototype;
    return defaultObj.prototype;
  }
  try {
    const iframeEl = document.createElement("iframe");
    document.body.appendChild(iframeEl);
    const win = iframeEl.contentWindow;
    if (!win) return defaultObj.prototype;
    const untaintedObject = win[key].prototype;
    document.body.removeChild(iframeEl);
    if (!untaintedObject) return defaultPrototype;
    return untaintedBasePrototype[key] = untaintedObject;
  } catch {
    return defaultPrototype;
  }
}
const untaintedAccessorCache = {};
function getUntaintedAccessor(key, instance, accessor) {
  var _a2;
  const cacheKey = `${key}.${String(accessor)}`;
  if (untaintedAccessorCache[cacheKey])
    return untaintedAccessorCache[cacheKey].call(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype(key);
  const untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(
    untaintedPrototype,
    accessor
  )) == null ? void 0 : _a2.get;
  if (!untaintedAccessor) return instance[accessor];
  untaintedAccessorCache[cacheKey] = untaintedAccessor;
  return untaintedAccessor.call(instance);
}
const untaintedMethodCache = {};
function getUntaintedMethod(key, instance, method) {
  const cacheKey = `${key}.${String(method)}`;
  if (untaintedMethodCache[cacheKey])
    return untaintedMethodCache[cacheKey].bind(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype(key);
  const untaintedMethod = untaintedPrototype[method];
  if (typeof untaintedMethod !== "function") return instance[method];
  untaintedMethodCache[cacheKey] = untaintedMethod;
  return untaintedMethod.bind(instance);
}
function childNodes(n2) {
  return getUntaintedAccessor("Node", n2, "childNodes");
}
function parentNode(n2) {
  return getUntaintedAccessor("Node", n2, "parentNode");
}
function parentElement(n2) {
  return getUntaintedAccessor("Node", n2, "parentElement");
}
function textContent(n2) {
  return getUntaintedAccessor("Node", n2, "textContent");
}
function contains(n2, other) {
  return getUntaintedMethod("Node", n2, "contains")(other);
}
function getRootNode(n2) {
  return getUntaintedMethod("Node", n2, "getRootNode")();
}
function host(n2) {
  if (!n2 || !("host" in n2)) return null;
  return getUntaintedAccessor("ShadowRoot", n2, "host");
}
function styleSheets(n2) {
  return n2.styleSheets;
}
function shadowRoot(n2) {
  if (!n2 || !("shadowRoot" in n2)) return null;
  return getUntaintedAccessor("Element", n2, "shadowRoot");
}
function querySelector(n2, selectors) {
  return getUntaintedAccessor("Element", n2, "querySelector")(selectors);
}
function querySelectorAll(n2, selectors) {
  return getUntaintedAccessor("Element", n2, "querySelectorAll")(selectors);
}
function mutationObserverCtor() {
  return getUntaintedPrototype("MutationObserver").constructor;
}
const index = {
  childNodes,
  parentNode,
  parentElement,
  textContent,
  contains,
  getRootNode,
  host,
  styleSheets,
  shadowRoot,
  querySelector,
  querySelectorAll,
  mutationObserver: mutationObserverCtor
};
function on(type, fn, target = document) {
  const options = { capture: true, passive: true };
  target.addEventListener(type, fn, options);
  return () => target.removeEventListener(type, fn, options);
}
const DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
let _mirror = {
  map: {},
  getId() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return -1;
  },
  getNode() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return null;
  },
  removeNodeFromMap() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  },
  has() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return false;
  },
  reset() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  }
};
if (typeof window !== "undefined" && window.Proxy && window.Reflect) {
  _mirror = new Proxy(_mirror, {
    get(target, prop, receiver) {
      if (prop === "map") {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function throttle(func, wait, options = {}) {
  let timeout = null;
  let previous = 0;
  return function(...args) {
    const now = Date.now();
    if (!previous && options.leading === false) {
      previous = now;
    }
    const remaining = wait - (now - previous);
    const context = this;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      func.apply(context, args);
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(() => {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}
function hookSetter(target, key, d, isRevoked, win = window) {
  const original = win.Object.getOwnPropertyDescriptor(target, key);
  win.Object.defineProperty(
    target,
    key,
    isRevoked ? d : {
      set(value) {
        setTimeout(() => {
          d.set.call(this, value);
        }, 0);
        if (original && original.set) {
          original.set.call(this, value);
        }
      }
    }
  );
  return () => hookSetter(target, key, original || {}, true);
}
function patch(source, name, replacement) {
  try {
    if (!(name in source)) {
      return () => {
      };
    }
    const original = source[name];
    const wrapped = replacement(original);
    if (typeof wrapped === "function") {
      wrapped.prototype = wrapped.prototype || {};
      Object.defineProperties(wrapped, {
        __rrweb_original__: {
          enumerable: false,
          value: original
        }
      });
    }
    source[name] = wrapped;
    return () => {
      source[name] = original;
    };
  } catch {
    return () => {
    };
  }
}
let nowTimestamp = Date.now;
if (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {
  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();
}
function getWindowScroll(win) {
  var _a2, _b, _c, _d;
  const doc = win.document;
  return {
    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,
    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0
  };
}
function getWindowHeight() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function getWindowWidth() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function closestElementOfNode(node2) {
  if (!node2) {
    return null;
  }
  const el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);
  return el;
}
function isBlocked(node2, blockClass, blockSelector, checkAncestors) {
  if (!node2) {
    return false;
  }
  const el = closestElementOfNode(node2);
  if (!el) {
    return false;
  }
  try {
    if (typeof blockClass === "string") {
      if (el.classList.contains(blockClass)) return true;
      if (checkAncestors && el.closest("." + blockClass) !== null) return true;
    } else {
      if (classMatchesRegex(el, blockClass, checkAncestors)) return true;
    }
  } catch (e2) {
  }
  if (blockSelector) {
    if (el.matches(blockSelector)) return true;
    if (checkAncestors && el.closest(blockSelector) !== null) return true;
  }
  return false;
}
function isSerialized(n2, mirror2) {
  return mirror2.getId(n2) !== -1;
}
function isIgnored(n2, mirror2, slimDOMOptions) {
  if (n2.tagName === "TITLE" && slimDOMOptions.headTitleMutations) {
    return true;
  }
  return mirror2.getId(n2) === IGNORED_NODE;
}
function isAncestorRemoved(target, mirror2) {
  if (isShadowRoot(target)) {
    return false;
  }
  const id = mirror2.getId(target);
  if (!mirror2.has(id)) {
    return true;
  }
  const parent = index.parentNode(target);
  if (parent && parent.nodeType === target.DOCUMENT_NODE) {
    return false;
  }
  if (!parent) {
    return true;
  }
  return isAncestorRemoved(parent, mirror2);
}
function legacy_isTouchEvent(event) {
  return Boolean(event.changedTouches);
}
function polyfill$1(win = window) {
  if ("NodeList" in win && !win.NodeList.prototype.forEach) {
    win.NodeList.prototype.forEach = Array.prototype.forEach;
  }
  if ("DOMTokenList" in win && !win.DOMTokenList.prototype.forEach) {
    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;
  }
}
function isSerializedIframe(n2, mirror2) {
  return Boolean(n2.nodeName === "IFRAME" && mirror2.getMeta(n2));
}
function isSerializedStylesheet(n2, mirror2) {
  return Boolean(
    n2.nodeName === "LINK" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute("rel") === "stylesheet" && mirror2.getMeta(n2)
  );
}
function hasShadowRoot(n2) {
  if (!n2) return false;
  if (n2 instanceof BaseRRNode && "shadowRoot" in n2) {
    return Boolean(n2.shadowRoot);
  }
  return Boolean(index.shadowRoot(n2));
}
class StyleSheetMirror {
  constructor() {
    __publicField(this, "id", 1);
    __publicField(this, "styleIDMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "idStyleMap", /* @__PURE__ */ new Map());
  }
  getId(stylesheet) {
    return this.styleIDMap.get(stylesheet) ?? -1;
  }
  has(stylesheet) {
    return this.styleIDMap.has(stylesheet);
  }
  /**
   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.
   */
  add(stylesheet, id) {
    if (this.has(stylesheet)) return this.getId(stylesheet);
    let newId;
    if (id === void 0) {
      newId = this.id++;
    } else newId = id;
    this.styleIDMap.set(stylesheet, newId);
    this.idStyleMap.set(newId, stylesheet);
    return newId;
  }
  getStyle(id) {
    return this.idStyleMap.get(id) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap();
    this.idStyleMap = /* @__PURE__ */ new Map();
    this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function getShadowHost(n2) {
  var _a2;
  let shadowHost = null;
  if ("getRootNode" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2)))
    shadowHost = index.host(index.getRootNode(n2));
  return shadowHost;
}
function getRootShadowHost(n2) {
  let rootShadowHost = n2;
  let shadowHost;
  while (shadowHost = getShadowHost(rootShadowHost))
    rootShadowHost = shadowHost;
  return rootShadowHost;
}
function shadowHostInDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc) return false;
  const shadowHost = getRootShadowHost(n2);
  return index.contains(doc, shadowHost);
}
function inDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc) return false;
  return index.contains(doc, n2) || shadowHostInDom(n2);
}
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType || {});
var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource || {});
var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(MouseInteractions || {});
var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(PointerTypes || {});
var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(CanvasContext || {});
var MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
  return MediaInteractions2;
})(MediaInteractions || {});
var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType || {});
function isNodeInLinkedList(n2) {
  return "__ln" in n2;
}
class DoubleLinkedList {
  constructor() {
    __publicField(this, "length", 0);
    __publicField(this, "head", null);
    __publicField(this, "tail", null);
  }
  get(position) {
    if (position >= this.length) {
      throw new Error("Position outside of list range");
    }
    let current = this.head;
    for (let index2 = 0; index2 < position; index2++) {
      current = (current == null ? void 0 : current.next) || null;
    }
    return current;
  }
  addNode(n2) {
    const node2 = {
      value: n2,
      previous: null,
      next: null
    };
    n2.__ln = node2;
    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {
      const current = n2.previousSibling.__ln.next;
      node2.next = current;
      node2.previous = n2.previousSibling.__ln;
      n2.previousSibling.__ln.next = node2;
      if (current) {
        current.previous = node2;
      }
    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {
      const current = n2.nextSibling.__ln.previous;
      node2.previous = current;
      node2.next = n2.nextSibling.__ln;
      n2.nextSibling.__ln.previous = node2;
      if (current) {
        current.next = node2;
      }
    } else {
      if (this.head) {
        this.head.previous = node2;
      }
      node2.next = this.head;
      this.head = node2;
    }
    if (node2.next === null) {
      this.tail = node2;
    }
    this.length++;
  }
  removeNode(n2) {
    const current = n2.__ln;
    if (!this.head) {
      return;
    }
    if (!current.previous) {
      this.head = current.next;
      if (this.head) {
        this.head.previous = null;
      } else {
        this.tail = null;
      }
    } else {
      current.previous.next = current.next;
      if (current.next) {
        current.next.previous = current.previous;
      } else {
        this.tail = current.previous;
      }
    }
    if (n2.__ln) {
      delete n2.__ln;
    }
    this.length--;
  }
}
const moveKey = (id, parentId) => `${id}@${parentId}`;
class MutationBuffer {
  constructor() {
    __publicField(this, "frozen", false);
    __publicField(this, "locked", false);
    __publicField(this, "texts", []);
    __publicField(this, "attributes", []);
    __publicField(this, "attributeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "removes", []);
    __publicField(this, "mapRemoves", []);
    __publicField(this, "movedMap", {});
    __publicField(this, "addedSet", /* @__PURE__ */ new Set());
    __publicField(this, "movedSet", /* @__PURE__ */ new Set());
    __publicField(this, "droppedSet", /* @__PURE__ */ new Set());
    __publicField(this, "removesSubTreeCache", /* @__PURE__ */ new Set());
    __publicField(this, "mutationCb");
    __publicField(this, "blockClass");
    __publicField(this, "blockSelector");
    __publicField(this, "maskTextClass");
    __publicField(this, "maskTextSelector");
    __publicField(this, "inlineStylesheet");
    __publicField(this, "maskInputOptions");
    __publicField(this, "maskTextFn");
    __publicField(this, "maskInputFn");
    __publicField(this, "keepIframeSrcFn");
    __publicField(this, "recordCanvas");
    __publicField(this, "inlineImages");
    __publicField(this, "slimDOMOptions");
    __publicField(this, "dataURLOptions");
    __publicField(this, "doc");
    __publicField(this, "mirror");
    __publicField(this, "iframeManager");
    __publicField(this, "stylesheetManager");
    __publicField(this, "shadowDomManager");
    __publicField(this, "canvasManager");
    __publicField(this, "processedNodeManager");
    __publicField(this, "unattachedDoc");
    __publicField(this, "processMutations", (mutations) => {
      mutations.forEach(this.processMutation);
      this.emit();
    });
    __publicField(this, "emit", () => {
      if (this.frozen || this.locked) {
        return;
      }
      const adds = [];
      const addedIds = /* @__PURE__ */ new Set();
      const addList = new DoubleLinkedList();
      const getNextId = (n2) => {
        let ns = n2;
        let nextId = IGNORED_NODE;
        while (nextId === IGNORED_NODE) {
          ns = ns && ns.nextSibling;
          nextId = ns && this.mirror.getId(ns);
        }
        return nextId;
      };
      const pushAdd = (n2) => {
        const parent = index.parentNode(n2);
        if (!parent || !inDom(n2)) {
          return;
        }
        let cssCaptured = false;
        if (n2.nodeType === Node.TEXT_NODE) {
          const parentTag = parent.tagName;
          if (parentTag === "TEXTAREA") {
            return;
          } else if (parentTag === "STYLE" && this.addedSet.has(parent)) {
            cssCaptured = true;
          }
        }
        const parentId = isShadowRoot(parent) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(parent);
        const nextId = getNextId(n2);
        if (parentId === -1 || nextId === -1) {
          return addList.addNode(n2);
        }
        const sn = serializeNodeWithId(n2, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: true,
          newlyAddedElement: true,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          onSerialize: (currentN) => {
            if (isSerializedIframe(currentN, this.mirror)) {
              this.iframeManager.addIframe(currentN);
            }
            if (isSerializedStylesheet(currentN, this.mirror)) {
              this.stylesheetManager.trackLinkElement(
                currentN
              );
            }
            if (hasShadowRoot(n2)) {
              this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), this.doc);
            }
          },
          onIframeLoad: (iframe, childSn) => {
            this.iframeManager.attachIframe(iframe, childSn);
            this.shadowDomManager.observeAttachShadow(iframe);
          },
          onStylesheetLoad: (link, childSn) => {
            this.stylesheetManager.attachLinkElement(link, childSn);
          },
          cssCaptured
        });
        if (sn) {
          adds.push({
            parentId,
            nextId,
            node: sn
          });
          addedIds.add(sn.id);
        }
      };
      while (this.mapRemoves.length) {
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      }
      for (const n2 of this.movedSet) {
        if (isParentRemoved(this.removesSubTreeCache, n2, this.mirror) && !this.movedSet.has(index.parentNode(n2))) {
          continue;
        }
        pushAdd(n2);
      }
      for (const n2 of this.addedSet) {
        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removesSubTreeCache, n2, this.mirror)) {
          pushAdd(n2);
        } else if (isAncestorInSet(this.movedSet, n2)) {
          pushAdd(n2);
        } else {
          this.droppedSet.add(n2);
        }
      }
      let candidate = null;
      while (addList.length) {
        let node2 = null;
        if (candidate) {
          const parentId = this.mirror.getId(index.parentNode(candidate.value));
          const nextId = getNextId(candidate.value);
          if (parentId !== -1 && nextId !== -1) {
            node2 = candidate;
          }
        }
        if (!node2) {
          let tailNode = addList.tail;
          while (tailNode) {
            const _node = tailNode;
            tailNode = tailNode.previous;
            if (_node) {
              const parentId = this.mirror.getId(index.parentNode(_node.value));
              const nextId = getNextId(_node.value);
              if (nextId === -1) continue;
              else if (parentId !== -1) {
                node2 = _node;
                break;
              } else {
                const unhandledNode = _node.value;
                const parent = index.parentNode(unhandledNode);
                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const shadowHost = index.host(parent);
                  const parentId2 = this.mirror.getId(shadowHost);
                  if (parentId2 !== -1) {
                    node2 = _node;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!node2) {
          while (addList.head) {
            addList.removeNode(addList.head.value);
          }
          break;
        }
        candidate = node2.previous;
        addList.removeNode(node2.value);
        pushAdd(node2.value);
      }
      const payload = {
        texts: this.texts.map((text) => {
          const n2 = text.node;
          const parent = index.parentNode(n2);
          if (parent && parent.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(parent);
          }
          return {
            id: this.mirror.getId(n2),
            value: text.value
          };
        }).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),
        attributes: this.attributes.map((attribute) => {
          const { attributes } = attribute;
          if (typeof attributes.style === "string") {
            const diffAsStr = JSON.stringify(attribute.styleDiff);
            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);
            if (diffAsStr.length < attributes.style.length) {
              if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {
                attributes.style = attribute.styleDiff;
              }
            }
          }
          return {
            id: this.mirror.getId(attribute.node),
            attributes
          };
        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),
        removes: this.removes,
        adds
      };
      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
        return;
      }
      this.texts = [];
      this.attributes = [];
      this.attributeMap = /* @__PURE__ */ new WeakMap();
      this.removes = [];
      this.addedSet = /* @__PURE__ */ new Set();
      this.movedSet = /* @__PURE__ */ new Set();
      this.droppedSet = /* @__PURE__ */ new Set();
      this.removesSubTreeCache = /* @__PURE__ */ new Set();
      this.movedMap = {};
      this.mutationCb(payload);
    });
    __publicField(this, "genTextAreaValueMutation", (textarea) => {
      let item = this.attributeMap.get(textarea);
      if (!item) {
        item = {
          node: textarea,
          attributes: {},
          styleDiff: {},
          _unchangedStyles: {}
        };
        this.attributes.push(item);
        this.attributeMap.set(textarea, item);
      }
      item.attributes.value = Array.from(
        index.childNodes(textarea),
        (cn) => index.textContent(cn) || ""
      ).join("");
    });
    __publicField(this, "processMutation", (m) => {
      if (isIgnored(m.target, this.mirror, this.slimDOMOptions)) {
        return;
      }
      switch (m.type) {
        case "characterData": {
          const value = index.textContent(m.target);
          if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {
            this.texts.push({
              value: needMaskingText(
                m.target,
                this.maskTextClass,
                this.maskTextSelector,
                true
                // checkAncestors
              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\S]/g, "*") : value,
              node: m.target
            });
          }
          break;
        }
        case "attributes": {
          const target = m.target;
          let attributeName = m.attributeName;
          let value = m.target.getAttribute(attributeName);
          if (attributeName === "value") {
            const type = getInputType(target);
            value = maskInputValue({
              element: target,
              maskInputOptions: this.maskInputOptions,
              tagName: target.tagName,
              type,
              value,
              maskInputFn: this.maskInputFn
            });
          }
          if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {
            return;
          }
          let item = this.attributeMap.get(m.target);
          if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {
            if (!target.contentDocument) {
              attributeName = "rr_src";
            } else {
              return;
            }
          }
          if (!item) {
            item = {
              node: m.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            };
            this.attributes.push(item);
            this.attributeMap.set(m.target, item);
          }
          if (attributeName === "type" && target.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
            target.setAttribute("data-rr-is-password", "true");
          }
          if (!ignoreAttribute(target.tagName, attributeName)) {
            item.attributes[attributeName] = transformAttribute(
              this.doc,
              toLowerCase(target.tagName),
              toLowerCase(attributeName),
              value
            );
            if (attributeName === "style") {
              if (!this.unattachedDoc) {
                try {
                  this.unattachedDoc = document.implementation.createHTMLDocument();
                } catch (e2) {
                  this.unattachedDoc = this.doc;
                }
              }
              const old = this.unattachedDoc.createElement("span");
              if (m.oldValue) {
                old.setAttribute("style", m.oldValue);
              }
              for (const pname of Array.from(target.style)) {
                const newValue = target.style.getPropertyValue(pname);
                const newPriority = target.style.getPropertyPriority(pname);
                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {
                  if (newPriority === "") {
                    item.styleDiff[pname] = newValue;
                  } else {
                    item.styleDiff[pname] = [newValue, newPriority];
                  }
                } else {
                  item._unchangedStyles[pname] = [newValue, newPriority];
                }
              }
              for (const pname of Array.from(old.style)) {
                if (target.style.getPropertyValue(pname) === "") {
                  item.styleDiff[pname] = false;
                }
              }
            } else if (attributeName === "open" && target.tagName === "DIALOG") {
              if (target.matches("dialog:modal")) {
                item.attributes["rr_open_mode"] = "modal";
              } else {
                item.attributes["rr_open_mode"] = "non-modal";
              }
            }
          }
          break;
        }
        case "childList": {
          if (isBlocked(m.target, this.blockClass, this.blockSelector, true))
            return;
          if (m.target.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(m.target);
            return;
          }
          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));
          m.removedNodes.forEach((n2) => {
            const nodeId = this.mirror.getId(n2);
            const parentId = isShadowRoot(m.target) ? this.mirror.getId(index.host(m.target)) : this.mirror.getId(m.target);
            if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n2, this.mirror, this.slimDOMOptions) || !isSerialized(n2, this.mirror)) {
              return;
            }
            if (this.addedSet.has(n2)) {
              deepDelete(this.addedSet, n2);
              this.droppedSet.add(n2);
            } else if (this.addedSet.has(m.target) && nodeId === -1) ;
            else if (isAncestorRemoved(m.target, this.mirror)) ;
            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {
              deepDelete(this.movedSet, n2);
            } else {
              this.removes.push({
                parentId,
                id: nodeId,
                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0
              });
              processRemoves(n2, this.removesSubTreeCache);
            }
            this.mapRemoves.push(n2);
          });
          break;
        }
      }
    });
    __publicField(this, "genAdds", (n2, target) => {
      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;
      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;
      if (this.mirror.hasNode(n2)) {
        if (isIgnored(n2, this.mirror, this.slimDOMOptions)) {
          return;
        }
        this.movedSet.add(n2);
        let targetId = null;
        if (target && this.mirror.hasNode(target)) {
          targetId = this.mirror.getId(target);
        }
        if (targetId && targetId !== -1) {
          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;
        }
      } else {
        this.addedSet.add(n2);
        this.droppedSet.delete(n2);
      }
      if (!isBlocked(n2, this.blockClass, this.blockSelector, false)) {
        index.childNodes(n2).forEach((childN) => this.genAdds(childN));
        if (hasShadowRoot(n2)) {
          index.childNodes(index.shadowRoot(n2)).forEach((childN) => {
            this.processedNodeManager.add(childN, this);
            this.genAdds(childN, n2);
          });
        }
      }
    });
  }
  init(options) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((key) => {
      this[key] = options[key];
    });
  }
  freeze() {
    this.frozen = true;
    this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = false;
    this.canvasManager.unfreeze();
    this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = true;
    this.canvasManager.lock();
  }
  unlock() {
    this.locked = false;
    this.canvasManager.unlock();
    this.emit();
  }
  reset() {
    this.shadowDomManager.reset();
    this.canvasManager.reset();
  }
}
function deepDelete(addsSet, n2) {
  addsSet.delete(n2);
  index.childNodes(n2).forEach((childN) => deepDelete(addsSet, childN));
}
function processRemoves(n2, cache) {
  const queue = [n2];
  while (queue.length) {
    const next = queue.pop();
    if (cache.has(next)) continue;
    cache.add(next);
    index.childNodes(next).forEach((n22) => queue.push(n22));
  }
  return;
}
function isParentRemoved(removes, n2, mirror2) {
  if (removes.size === 0) return false;
  return _isParentRemoved(removes, n2);
}
function _isParentRemoved(removes, n2, _mirror2) {
  const node2 = index.parentNode(n2);
  if (!node2) return false;
  return removes.has(node2);
}
function isAncestorInSet(set, n2) {
  if (set.size === 0) return false;
  return _isAncestorInSet(set, n2);
}
function _isAncestorInSet(set, n2) {
  const parent = index.parentNode(n2);
  if (!parent) {
    return false;
  }
  if (set.has(parent)) {
    return true;
  }
  return _isAncestorInSet(set, parent);
}
let errorHandler;
function registerErrorHandler(handler) {
  errorHandler = handler;
}
function unregisterErrorHandler() {
  errorHandler = void 0;
}
const callbackWrapper = (cb) => {
  if (!errorHandler) {
    return cb;
  }
  const rrwebWrapped = (...rest) => {
    try {
      return cb(...rest);
    } catch (error) {
      if (errorHandler && errorHandler(error) === true) {
        return;
      }
      throw error;
    }
  };
  return rrwebWrapped;
};
const mutationBuffers = [];
function getEventTarget(event) {
  try {
    if ("composedPath" in event) {
      const path = event.composedPath();
      if (path.length) {
        return path[0];
      }
    } else if ("path" in event && event.path.length) {
      return event.path[0];
    }
  } catch {
  }
  return event && event.target;
}
function initMutationObserver(options, rootEl) {
  const mutationBuffer = new MutationBuffer();
  mutationBuffers.push(mutationBuffer);
  mutationBuffer.init(options);
  const observer = new (mutationObserverCtor())(
    callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer))
  );
  observer.observe(rootEl, {
    attributes: true,
    attributeOldValue: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  });
  return observer;
}
function initMoveObserver({
  mousemoveCb,
  sampling,
  doc,
  mirror: mirror2
}) {
  if (sampling.mousemove === false) {
    return () => {
    };
  }
  const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;
  const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;
  let positions = [];
  let timeBaseline;
  const wrappedCb = throttle(
    callbackWrapper(
      (source) => {
        const totalOffset = Date.now() - timeBaseline;
        mousemoveCb(
          positions.map((p) => {
            p.timeOffset -= totalOffset;
            return p;
          }),
          source
        );
        positions = [];
        timeBaseline = null;
      }
    ),
    callbackThreshold
  );
  const updatePosition = callbackWrapper(
    throttle(
      callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;
        if (!timeBaseline) {
          timeBaseline = nowTimestamp();
        }
        positions.push({
          x: clientX,
          y: clientY,
          id: mirror2.getId(target),
          timeOffset: nowTimestamp() - timeBaseline
        });
        wrappedCb(
          typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove
        );
      }),
      threshold,
      {
        trailing: false
      }
    )
  );
  const handlers = [
    on("mousemove", updatePosition, doc),
    on("touchmove", updatePosition, doc),
    on("drag", updatePosition, doc)
  ];
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initMouseInteractionObserver({
  mouseInteractionCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  sampling
}) {
  if (sampling.mouseInteraction === false) {
    return () => {
    };
  }
  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;
  const handlers = [];
  let currentPointerType = null;
  const getHandler = (eventKey) => {
    return (event) => {
      const target = getEventTarget(event);
      if (isBlocked(target, blockClass, blockSelector, true)) {
        return;
      }
      let pointerType = null;
      let thisEventKey = eventKey;
      if ("pointerType" in event) {
        switch (event.pointerType) {
          case "mouse":
            pointerType = PointerTypes.Mouse;
            break;
          case "touch":
            pointerType = PointerTypes.Touch;
            break;
          case "pen":
            pointerType = PointerTypes.Pen;
            break;
        }
        if (pointerType === PointerTypes.Touch) {
          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {
            thisEventKey = "TouchStart";
          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {
            thisEventKey = "TouchEnd";
          }
        } else if (pointerType === PointerTypes.Pen) ;
      } else if (legacy_isTouchEvent(event)) {
        pointerType = PointerTypes.Touch;
      }
      if (pointerType !== null) {
        currentPointerType = pointerType;
        if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {
          pointerType = null;
        }
      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {
        pointerType = currentPointerType;
        currentPointerType = null;
      }
      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;
      if (!e2) {
        return;
      }
      const id = mirror2.getId(target);
      const { clientX, clientY } = e2;
      callbackWrapper(mouseInteractionCb)({
        type: MouseInteractions[thisEventKey],
        id,
        x: clientX,
        y: clientY,
        ...pointerType !== null && { pointerType }
      });
    };
  };
  Object.keys(MouseInteractions).filter(
    (key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false
  ).forEach((eventKey) => {
    let eventName = toLowerCase(eventKey);
    const handler = getHandler(eventKey);
    if (window.PointerEvent) {
      switch (MouseInteractions[eventKey]) {
        case MouseInteractions.MouseDown:
        case MouseInteractions.MouseUp:
          eventName = eventName.replace(
            "mouse",
            "pointer"
          );
          break;
        case MouseInteractions.TouchStart:
        case MouseInteractions.TouchEnd:
          return;
      }
    }
    handlers.push(on(eventName, handler, doc));
  });
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initScrollObserver({
  scrollCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  sampling
}) {
  const updatePosition = callbackWrapper(
    throttle(
      callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const id = mirror2.getId(target);
        if (target === doc && doc.defaultView) {
          const scrollLeftTop = getWindowScroll(doc.defaultView);
          scrollCb({
            id,
            x: scrollLeftTop.left,
            y: scrollLeftTop.top
          });
        } else {
          scrollCb({
            id,
            x: target.scrollLeft,
            y: target.scrollTop
          });
        }
      }),
      sampling.scroll || 100
    )
  );
  return on("scroll", updatePosition, doc);
}
function initViewportResizeObserver({ viewportResizeCb }, { win }) {
  let lastH = -1;
  let lastW = -1;
  const updateDimension = callbackWrapper(
    throttle(
      callbackWrapper(() => {
        const height = getWindowHeight();
        const width = getWindowWidth();
        if (lastH !== height || lastW !== width) {
          viewportResizeCb({
            width: Number(width),
            height: Number(height)
          });
          lastH = height;
          lastW = width;
        }
      }),
      200
    )
  );
  return on("resize", updateDimension, win);
}
const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
const lastInputValueMap = /* @__PURE__ */ new WeakMap();
function initInputObserver({
  inputCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  ignoreClass,
  ignoreSelector,
  maskInputOptions,
  maskInputFn,
  sampling,
  userTriggeredOnInput
}) {
  function eventHandler(event) {
    let target = getEventTarget(event);
    const userTriggered = event.isTrusted;
    const tagName = target && target.tagName;
    if (target && tagName === "OPTION") {
      target = index.parentElement(target);
    }
    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {
      return;
    }
    if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {
      return;
    }
    let text = target.value;
    let isChecked = false;
    const type = getInputType(target) || "";
    if (type === "radio" || type === "checkbox") {
      isChecked = target.checked;
    } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {
      text = maskInputValue({
        element: target,
        maskInputOptions,
        tagName,
        type,
        value: text,
        maskInputFn
      });
    }
    cbWithDedup(
      target,
      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }
    );
    const name = target.name;
    if (type === "radio" && name && isChecked) {
      doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el) => {
        if (el !== target) {
          const text2 = el.value;
          cbWithDedup(
            el,
            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }
          );
        }
      });
    }
  }
  function cbWithDedup(target, v2) {
    const lastInputValue = lastInputValueMap.get(target);
    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {
      lastInputValueMap.set(target, v2);
      const id = mirror2.getId(target);
      callbackWrapper(inputCb)({
        ...v2,
        id
      });
    }
  }
  const events = sampling.input === "last" ? ["change"] : ["input", "change"];
  const handlers = events.map(
    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)
  );
  const currentWindow = doc.defaultView;
  if (!currentWindow) {
    return () => {
      handlers.forEach((h) => h());
    };
  }
  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(
    currentWindow.HTMLInputElement.prototype,
    "value"
  );
  const hookProperties = [
    [currentWindow.HTMLInputElement.prototype, "value"],
    [currentWindow.HTMLInputElement.prototype, "checked"],
    [currentWindow.HTMLSelectElement.prototype, "value"],
    [currentWindow.HTMLTextAreaElement.prototype, "value"],
    // Some UI library use selectedIndex to set select value
    [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],
    [currentWindow.HTMLOptionElement.prototype, "selected"]
  ];
  if (propertyDescriptor && propertyDescriptor.set) {
    handlers.push(
      ...hookProperties.map(
        (p) => hookSetter(
          p[0],
          p[1],
          {
            set() {
              callbackWrapper(eventHandler)({
                target: this,
                isTrusted: false
                // userTriggered to false as this could well be programmatic
              });
            }
          },
          false,
          currentWindow
        )
      )
    );
  }
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function getNestedCSSRulePositions(rule2) {
  const positions = [];
  function recurse(childRule, pos) {
    if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {
      const rules2 = Array.from(
        childRule.parentRule.cssRules
      );
      const index2 = rules2.indexOf(childRule);
      pos.unshift(index2);
    } else if (childRule.parentStyleSheet) {
      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);
      const index2 = rules2.indexOf(childRule);
      pos.unshift(index2);
    }
    return pos;
  }
  return recurse(rule2, positions);
}
function getIdAndStyleId(sheet, mirror2, styleMirror) {
  let id, styleId;
  if (!sheet) return {};
  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);
  else styleId = styleMirror.getId(sheet);
  return {
    styleId,
    id
  };
}
function initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {
  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {
    return () => {
    };
  }
  const insertRule = win.CSSStyleSheet.prototype.insertRule;
  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        const [rule2, index2] = argumentsList;
        const { id, styleId } = getIdAndStyleId(
          thisArg,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id,
            styleId,
            adds: [{ rule: rule2, index: index2 }]
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2 = this.cssRules.length) {
    const rule2 = `${selector} { ${styleBlock} }`;
    return win.CSSStyleSheet.prototype.insertRule.apply(this, [rule2, index2]);
  };
  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;
  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        const [index2] = argumentsList;
        const { id, styleId } = getIdAndStyleId(
          thisArg,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id,
            styleId,
            removes: [{ index: index2 }]
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  win.CSSStyleSheet.prototype.removeRule = function(index2) {
    return win.CSSStyleSheet.prototype.deleteRule.apply(this, [index2]);
  };
  let replace;
  if (win.CSSStyleSheet.prototype.replace) {
    replace = win.CSSStyleSheet.prototype.replace;
    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {
      apply: callbackWrapper(
        (target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id, styleId } = getIdAndStyleId(
            thisArg,
            mirror2,
            stylesheetManager.styleMirror
          );
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              replace: text
            });
          }
          return target.apply(thisArg, argumentsList);
        }
      )
    });
  }
  let replaceSync;
  if (win.CSSStyleSheet.prototype.replaceSync) {
    replaceSync = win.CSSStyleSheet.prototype.replaceSync;
    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {
      apply: callbackWrapper(
        (target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id, styleId } = getIdAndStyleId(
            thisArg,
            mirror2,
            stylesheetManager.styleMirror
          );
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              replaceSync: text
            });
          }
          return target.apply(thisArg, argumentsList);
        }
      )
    });
  }
  const supportedNestedCSSRuleTypes = {};
  if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;
  } else {
    if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;
    }
  }
  const unmodifiedFunctions = {};
  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
    unmodifiedFunctions[typeKey] = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      insertRule: type.prototype.insertRule,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      deleteRule: type.prototype.deleteRule
    };
    type.prototype.insertRule = new Proxy(
      unmodifiedFunctions[typeKey].insertRule,
      {
        apply: callbackWrapper(
          (target, thisArg, argumentsList) => {
            const [rule2, index2] = argumentsList;
            const { id, styleId } = getIdAndStyleId(
              thisArg.parentStyleSheet,
              mirror2,
              stylesheetManager.styleMirror
            );
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                adds: [
                  {
                    rule: rule2,
                    index: [
                      ...getNestedCSSRulePositions(thisArg),
                      index2 || 0
                      // defaults to 0
                    ]
                  }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          }
        )
      }
    );
    type.prototype.deleteRule = new Proxy(
      unmodifiedFunctions[typeKey].deleteRule,
      {
        apply: callbackWrapper(
          (target, thisArg, argumentsList) => {
            const [index2] = argumentsList;
            const { id, styleId } = getIdAndStyleId(
              thisArg.parentStyleSheet,
              mirror2,
              stylesheetManager.styleMirror
            );
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                removes: [
                  { index: [...getNestedCSSRulePositions(thisArg), index2] }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          }
        )
      }
    );
  });
  return callbackWrapper(() => {
    win.CSSStyleSheet.prototype.insertRule = insertRule;
    win.CSSStyleSheet.prototype.deleteRule = deleteRule;
    replace && (win.CSSStyleSheet.prototype.replace = replace);
    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);
    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;
      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;
    });
  });
}
function initAdoptedStyleSheetObserver({
  mirror: mirror2,
  stylesheetManager
}, host2) {
  var _a2, _b, _c;
  let hostId = null;
  if (host2.nodeName === "#document") hostId = mirror2.getId(host2);
  else hostId = mirror2.getId(index.host(host2));
  const patchTarget = host2.nodeName === "#document" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;
  const originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(
    patchTarget == null ? void 0 : patchTarget.prototype,
    "adoptedStyleSheets"
  ) : void 0;
  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)
    return () => {
    };
  Object.defineProperty(host2, "adoptedStyleSheets", {
    configurable: originalPropertyDescriptor.configurable,
    enumerable: originalPropertyDescriptor.enumerable,
    get() {
      var _a3;
      return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);
    },
    set(sheets) {
      var _a3;
      const result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);
      if (hostId !== null && hostId !== -1) {
        try {
          stylesheetManager.adoptStyleSheets(sheets, hostId);
        } catch (e2) {
        }
      }
      return result2;
    }
  });
  return callbackWrapper(() => {
    Object.defineProperty(host2, "adoptedStyleSheets", {
      configurable: originalPropertyDescriptor.configurable,
      enumerable: originalPropertyDescriptor.enumerable,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      get: originalPropertyDescriptor.get,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      set: originalPropertyDescriptor.set
    });
  });
}
function initStyleDeclarationObserver({
  styleDeclarationCb,
  mirror: mirror2,
  ignoreCSSAttributes,
  stylesheetManager
}, { win }) {
  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;
  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        var _a2;
        const [property, value, priority] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return setProperty.apply(thisArg, [property, value, priority]);
        }
        const { id, styleId } = getIdAndStyleId(
          (_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id,
            styleId,
            set: {
              property,
              value,
              priority
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;
  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        var _a2;
        const [property] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return removeProperty.apply(thisArg, [property]);
        }
        const { id, styleId } = getIdAndStyleId(
          (_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id,
            styleId,
            remove: {
              property
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  return callbackWrapper(() => {
    win.CSSStyleDeclaration.prototype.setProperty = setProperty;
    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;
  });
}
function initMediaInteractionObserver({
  mediaInteractionCb,
  blockClass,
  blockSelector,
  mirror: mirror2,
  sampling,
  doc
}) {
  const handler = callbackWrapper(
    (type) => throttle(
      callbackWrapper((event) => {
        const target = getEventTarget(event);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const { currentTime, volume, muted, playbackRate, loop } = target;
        mediaInteractionCb({
          type,
          id: mirror2.getId(target),
          currentTime,
          volume,
          muted,
          playbackRate,
          loop
        });
      }),
      sampling.media || 500
    )
  );
  const handlers = [
    on("play", handler(MediaInteractions.Play), doc),
    on("pause", handler(MediaInteractions.Pause), doc),
    on("seeked", handler(MediaInteractions.Seeked), doc),
    on("volumechange", handler(MediaInteractions.VolumeChange), doc),
    on("ratechange", handler(MediaInteractions.RateChange), doc)
  ];
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initFontObserver({ fontCb, doc }) {
  const win = doc.defaultView;
  if (!win) {
    return () => {
    };
  }
  const handlers = [];
  const fontMap = /* @__PURE__ */ new WeakMap();
  const originalFontFace = win.FontFace;
  win.FontFace = function FontFace2(family, source, descriptors) {
    const fontFace = new originalFontFace(family, source, descriptors);
    fontMap.set(fontFace, {
      family,
      buffer: typeof source !== "string",
      descriptors,
      fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))
    });
    return fontFace;
  };
  const restoreHandler = patch(
    doc.fonts,
    "add",
    function(original) {
      return function(fontFace) {
        setTimeout(
          callbackWrapper(() => {
            const p = fontMap.get(fontFace);
            if (p) {
              fontCb(p);
              fontMap.delete(fontFace);
            }
          }),
          0
        );
        return original.apply(this, [fontFace]);
      };
    }
  );
  handlers.push(() => {
    win.FontFace = originalFontFace;
  });
  handlers.push(restoreHandler);
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initSelectionObserver(param) {
  const { doc, mirror: mirror2, blockClass, blockSelector, selectionCb } = param;
  let collapsed = true;
  const updateSelection = callbackWrapper(() => {
    const selection = doc.getSelection();
    if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;
    collapsed = selection.isCollapsed || false;
    const ranges = [];
    const count = selection.rangeCount || 0;
    for (let i2 = 0; i2 < count; i2++) {
      const range = selection.getRangeAt(i2);
      const { startContainer, startOffset, endContainer, endOffset } = range;
      const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);
      if (blocked) continue;
      ranges.push({
        start: mirror2.getId(startContainer),
        startOffset,
        end: mirror2.getId(endContainer),
        endOffset
      });
    }
    selectionCb({ ranges });
  });
  updateSelection();
  return on("selectionchange", updateSelection);
}
function initCustomElementObserver({
  doc,
  customElementCb
}) {
  const win = doc.defaultView;
  if (!win || !win.customElements) return () => {
  };
  const restoreHandler = patch(
    win.customElements,
    "define",
    function(original) {
      return function(name, constructor, options) {
        try {
          customElementCb({
            define: {
              name
            }
          });
        } catch (e2) {
          console.warn(`Custom element callback failed for ${name}`);
        }
        return original.apply(this, [name, constructor, options]);
      };
    }
  );
  return restoreHandler;
}
function mergeHooks(o2, hooks) {
  const {
    mutationCb,
    mousemoveCb,
    mouseInteractionCb,
    scrollCb,
    viewportResizeCb,
    inputCb,
    mediaInteractionCb,
    styleSheetRuleCb,
    styleDeclarationCb,
    canvasMutationCb,
    fontCb,
    selectionCb,
    customElementCb
  } = o2;
  o2.mutationCb = (...p) => {
    if (hooks.mutation) {
      hooks.mutation(...p);
    }
    mutationCb(...p);
  };
  o2.mousemoveCb = (...p) => {
    if (hooks.mousemove) {
      hooks.mousemove(...p);
    }
    mousemoveCb(...p);
  };
  o2.mouseInteractionCb = (...p) => {
    if (hooks.mouseInteraction) {
      hooks.mouseInteraction(...p);
    }
    mouseInteractionCb(...p);
  };
  o2.scrollCb = (...p) => {
    if (hooks.scroll) {
      hooks.scroll(...p);
    }
    scrollCb(...p);
  };
  o2.viewportResizeCb = (...p) => {
    if (hooks.viewportResize) {
      hooks.viewportResize(...p);
    }
    viewportResizeCb(...p);
  };
  o2.inputCb = (...p) => {
    if (hooks.input) {
      hooks.input(...p);
    }
    inputCb(...p);
  };
  o2.mediaInteractionCb = (...p) => {
    if (hooks.mediaInteaction) {
      hooks.mediaInteaction(...p);
    }
    mediaInteractionCb(...p);
  };
  o2.styleSheetRuleCb = (...p) => {
    if (hooks.styleSheetRule) {
      hooks.styleSheetRule(...p);
    }
    styleSheetRuleCb(...p);
  };
  o2.styleDeclarationCb = (...p) => {
    if (hooks.styleDeclaration) {
      hooks.styleDeclaration(...p);
    }
    styleDeclarationCb(...p);
  };
  o2.canvasMutationCb = (...p) => {
    if (hooks.canvasMutation) {
      hooks.canvasMutation(...p);
    }
    canvasMutationCb(...p);
  };
  o2.fontCb = (...p) => {
    if (hooks.font) {
      hooks.font(...p);
    }
    fontCb(...p);
  };
  o2.selectionCb = (...p) => {
    if (hooks.selection) {
      hooks.selection(...p);
    }
    selectionCb(...p);
  };
  o2.customElementCb = (...c2) => {
    if (hooks.customElement) {
      hooks.customElement(...c2);
    }
    customElementCb(...c2);
  };
}
function initObservers(o2, hooks = {}) {
  const currentWindow = o2.doc.defaultView;
  if (!currentWindow) {
    return () => {
    };
  }
  mergeHooks(o2, hooks);
  let mutationObserver;
  if (o2.recordDOM) {
    mutationObserver = initMutationObserver(o2, o2.doc);
  }
  const mousemoveHandler = initMoveObserver(o2);
  const mouseInteractionHandler = initMouseInteractionObserver(o2);
  const scrollHandler = initScrollObserver(o2);
  const viewportResizeHandler = initViewportResizeObserver(o2, {
    win: currentWindow
  });
  const inputHandler = initInputObserver(o2);
  const mediaInteractionHandler = initMediaInteractionObserver(o2);
  let styleSheetObserver = () => {
  };
  let adoptedStyleSheetObserver = () => {
  };
  let styleDeclarationObserver = () => {
  };
  let fontObserver = () => {
  };
  if (o2.recordDOM) {
    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });
    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);
    styleDeclarationObserver = initStyleDeclarationObserver(o2, {
      win: currentWindow
    });
    if (o2.collectFonts) {
      fontObserver = initFontObserver(o2);
    }
  }
  const selectionObserver = initSelectionObserver(o2);
  const customElementObserver = initCustomElementObserver(o2);
  const pluginHandlers = [];
  for (const plugin3 of o2.plugins) {
    pluginHandlers.push(
      plugin3.observer(plugin3.callback, currentWindow, plugin3.options)
    );
  }
  return callbackWrapper(() => {
    mutationBuffers.forEach((b) => b.reset());
    mutationObserver == null ? void 0 : mutationObserver.disconnect();
    mousemoveHandler();
    mouseInteractionHandler();
    scrollHandler();
    viewportResizeHandler();
    inputHandler();
    mediaInteractionHandler();
    styleSheetObserver();
    adoptedStyleSheetObserver();
    styleDeclarationObserver();
    fontObserver();
    selectionObserver();
    customElementObserver();
    pluginHandlers.forEach((h) => h());
  });
}
function hasNestedCSSRule(prop) {
  return typeof window[prop] !== "undefined";
}
function canMonkeyPatchNestedCSSRule(prop) {
  return Boolean(
    typeof window[prop] !== "undefined" && // Note: Generally, this check _shouldn't_ be necessary
    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here
    window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype
  );
}
class CrossOriginIframeMirror {
  constructor(generateIdFn) {
    __publicField(this, "iframeIdToRemoteIdMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "iframeRemoteIdToIdMap", /* @__PURE__ */ new WeakMap());
    this.generateIdFn = generateIdFn;
  }
  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {
    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);
    let id = idToRemoteIdMap.get(remoteId);
    if (!id) {
      id = this.generateIdFn();
      idToRemoteIdMap.set(remoteId, id);
      remoteIdToIdMap.set(id, remoteId);
    }
    return id;
  }
  getIds(iframe, remoteId) {
    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return remoteId.map(
      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)
    );
  }
  getRemoteId(iframe, id, map) {
    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);
    if (typeof id !== "number") return id;
    const remoteId = remoteIdToIdMap.get(id);
    if (!remoteId) return -1;
    return remoteId;
  }
  getRemoteIds(iframe, ids) {
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));
  }
  reset(iframe) {
    if (!iframe) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(iframe);
    this.iframeRemoteIdToIdMap.delete(iframe);
  }
  getIdToRemoteIdMap(iframe) {
    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);
    if (!idToRemoteIdMap) {
      idToRemoteIdMap = /* @__PURE__ */ new Map();
      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);
    }
    return idToRemoteIdMap;
  }
  getRemoteIdToIdMap(iframe) {
    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);
    if (!remoteIdToIdMap) {
      remoteIdToIdMap = /* @__PURE__ */ new Map();
      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);
    }
    return remoteIdToIdMap;
  }
}
class IframeManager {
  constructor(options) {
    __publicField(this, "iframes", /* @__PURE__ */ new WeakMap());
    __publicField(this, "crossOriginIframeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "crossOriginIframeMirror", new CrossOriginIframeMirror(genId));
    __publicField(this, "crossOriginIframeStyleMirror");
    __publicField(this, "crossOriginIframeRootIdMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "mirror");
    __publicField(this, "mutationCb");
    __publicField(this, "wrappedEmit");
    __publicField(this, "loadListener");
    __publicField(this, "stylesheetManager");
    __publicField(this, "recordCrossOriginIframes");
    this.mutationCb = options.mutationCb;
    this.wrappedEmit = options.wrappedEmit;
    this.stylesheetManager = options.stylesheetManager;
    this.recordCrossOriginIframes = options.recordCrossOriginIframes;
    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(
      this.stylesheetManager.styleMirror.generateId.bind(
        this.stylesheetManager.styleMirror
      )
    );
    this.mirror = options.mirror;
    if (this.recordCrossOriginIframes) {
      window.addEventListener("message", this.handleMessage.bind(this));
    }
  }
  addIframe(iframeEl) {
    this.iframes.set(iframeEl, true);
    if (iframeEl.contentWindow)
      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);
  }
  addLoadListener(cb) {
    this.loadListener = cb;
  }
  attachIframe(iframeEl, childSn) {
    var _a2, _b;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(iframeEl),
          nextId: null,
          node: childSn
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: true
    });
    if (this.recordCrossOriginIframes)
      (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(
        "message",
        this.handleMessage.bind(this)
      );
    (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);
    if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)
      this.stylesheetManager.adoptStyleSheets(
        iframeEl.contentDocument.adoptedStyleSheets,
        this.mirror.getId(iframeEl.contentDocument)
      );
  }
  handleMessage(message) {
    const crossOriginMessageEvent = message;
    if (crossOriginMessageEvent.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.
    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)
      return;
    const iframeSourceWindow = message.source;
    if (!iframeSourceWindow) return;
    const iframeEl = this.crossOriginIframeMap.get(message.source);
    if (!iframeEl) return;
    const transformedEvent = this.transformCrossOriginEvent(
      iframeEl,
      crossOriginMessageEvent.data.event
    );
    if (transformedEvent)
      this.wrappedEmit(
        transformedEvent,
        crossOriginMessageEvent.data.isCheckout
      );
  }
  transformCrossOriginEvent(iframeEl, e2) {
    var _a2;
    switch (e2.type) {
      case EventType.FullSnapshot: {
        this.crossOriginIframeMirror.reset(iframeEl);
        this.crossOriginIframeStyleMirror.reset(iframeEl);
        this.replaceIdOnNode(e2.data.node, iframeEl);
        const rootId = e2.data.node.id;
        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);
        this.patchRootIdOnNode(e2.data.node, rootId);
        return {
          timestamp: e2.timestamp,
          type: EventType.IncrementalSnapshot,
          data: {
            source: IncrementalSource.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(iframeEl),
                nextId: null,
                node: e2.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: true
          }
        };
      }
      case EventType.Meta:
      case EventType.Load:
      case EventType.DomContentLoaded: {
        return false;
      }
      case EventType.Plugin: {
        return e2;
      }
      case EventType.Custom: {
        this.replaceIds(
          e2.data.payload,
          iframeEl,
          ["id", "parentId", "previousId", "nextId"]
        );
        return e2;
      }
      case EventType.IncrementalSnapshot: {
        switch (e2.data.source) {
          case IncrementalSource.Mutation: {
            e2.data.adds.forEach((n2) => {
              this.replaceIds(n2, iframeEl, [
                "parentId",
                "nextId",
                "previousId"
              ]);
              this.replaceIdOnNode(n2.node, iframeEl);
              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);
              rootId && this.patchRootIdOnNode(n2.node, rootId);
            });
            e2.data.removes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["parentId", "id"]);
            });
            e2.data.attributes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            e2.data.texts.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource.Drag:
          case IncrementalSource.TouchMove:
          case IncrementalSource.MouseMove: {
            e2.data.positions.forEach((p) => {
              this.replaceIds(p, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource.ViewportResize: {
            return false;
          }
          case IncrementalSource.MediaInteraction:
          case IncrementalSource.MouseInteraction:
          case IncrementalSource.Scroll:
          case IncrementalSource.CanvasMutation:
          case IncrementalSource.Input: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            return e2;
          }
          case IncrementalSource.StyleSheetRule:
          case IncrementalSource.StyleDeclaration: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleId"]);
            return e2;
          }
          case IncrementalSource.Font: {
            return e2;
          }
          case IncrementalSource.Selection: {
            e2.data.ranges.forEach((range) => {
              this.replaceIds(range, iframeEl, ["start", "end"]);
            });
            return e2;
          }
          case IncrementalSource.AdoptedStyleSheet: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleIds"]);
            (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach((style) => {
              this.replaceStyleIds(style, iframeEl, ["styleId"]);
            });
            return e2;
          }
        }
      }
    }
    return false;
  }
  replace(iframeMirror, obj, iframeEl, keys) {
    for (const key of keys) {
      if (!Array.isArray(obj[key]) && typeof obj[key] !== "number") continue;
      if (Array.isArray(obj[key])) {
        obj[key] = iframeMirror.getIds(
          iframeEl,
          obj[key]
        );
      } else {
        obj[key] = iframeMirror.getId(iframeEl, obj[key]);
      }
    }
    return obj;
  }
  replaceIds(obj, iframeEl, keys) {
    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);
  }
  replaceStyleIds(obj, iframeEl, keys) {
    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);
  }
  replaceIdOnNode(node2, iframeEl) {
    this.replaceIds(node2, iframeEl, ["id", "rootId"]);
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.replaceIdOnNode(child, iframeEl);
      });
    }
  }
  patchRootIdOnNode(node2, rootId) {
    if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.patchRootIdOnNode(child, rootId);
      });
    }
  }
}
class ShadowDomManager {
  constructor(options) {
    __publicField(this, "shadowDoms", /* @__PURE__ */ new WeakSet());
    __publicField(this, "mutationCb");
    __publicField(this, "scrollCb");
    __publicField(this, "bypassOptions");
    __publicField(this, "mirror");
    __publicField(this, "restoreHandlers", []);
    this.mutationCb = options.mutationCb;
    this.scrollCb = options.scrollCb;
    this.bypassOptions = options.bypassOptions;
    this.mirror = options.mirror;
    this.init();
  }
  init() {
    this.reset();
    this.patchAttachShadow(Element, document);
  }
  addShadowRoot(shadowRoot2, doc) {
    if (!isNativeShadowDom(shadowRoot2)) return;
    if (this.shadowDoms.has(shadowRoot2)) return;
    this.shadowDoms.add(shadowRoot2);
    const observer = initMutationObserver(
      {
        ...this.bypassOptions,
        doc,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      },
      shadowRoot2
    );
    this.restoreHandlers.push(() => observer.disconnect());
    this.restoreHandlers.push(
      initScrollObserver({
        ...this.bypassOptions,
        scrollCb: this.scrollCb,
        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813
        // scroll is not allowed to pass the boundary, so we need to listen the shadow document
        doc: shadowRoot2,
        mirror: this.mirror
      })
    );
    setTimeout(() => {
      if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0)
        this.bypassOptions.stylesheetManager.adoptStyleSheets(
          shadowRoot2.adoptedStyleSheets,
          this.mirror.getId(index.host(shadowRoot2))
        );
      this.restoreHandlers.push(
        initAdoptedStyleSheetObserver(
          {
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          },
          shadowRoot2
        )
      );
    }, 0);
  }
  /**
   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.
   */
  observeAttachShadow(iframeElement) {
    if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;
    this.patchAttachShadow(
      iframeElement.contentWindow.Element,
      iframeElement.contentDocument
    );
  }
  /**
   * Patch 'attachShadow' to observe newly added shadow doms.
   */
  patchAttachShadow(element, doc) {
    const manager = this;
    this.restoreHandlers.push(
      patch(
        element.prototype,
        "attachShadow",
        function(original) {
          return function(option) {
            const sRoot = original.call(this, option);
            const shadowRootEl = index.shadowRoot(this);
            if (shadowRootEl && inDom(this))
              manager.addShadowRoot(shadowRootEl, doc);
            return sRoot;
          };
        }
      )
    );
  }
  reset() {
    this.restoreHandlers.forEach((handler) => {
      try {
        handler();
      } catch (e2) {
      }
    });
    this.restoreHandlers = [];
    this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) {
  lookup[chars.charCodeAt(i$1)] = i$1;
}
var encode = function(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
  for (i2 = 0; i2 < len; i2 += 3) {
    base64 += chars[bytes[i2] >> 2];
    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
    base64 += chars[bytes[i2 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
const canvasVarMap = /* @__PURE__ */ new Map();
function variableListFor$1(ctx, ctor) {
  let contextMap = canvasVarMap.get(ctx);
  if (!contextMap) {
    contextMap = /* @__PURE__ */ new Map();
    canvasVarMap.set(ctx, contextMap);
  }
  if (!contextMap.has(ctor)) {
    contextMap.set(ctor, []);
  }
  return contextMap.get(ctor);
}
const saveWebGLVar = (value, win, ctx) => {
  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === "object"))
    return;
  const name = value.constructor.name;
  const list2 = variableListFor$1(ctx, name);
  let index2 = list2.indexOf(value);
  if (index2 === -1) {
    index2 = list2.length;
    list2.push(value);
  }
  return index2;
};
function serializeArg(value, win, ctx) {
  if (value instanceof Array) {
    return value.map((arg) => serializeArg(arg, win, ctx));
  } else if (value === null) {
    return value;
  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [Object.values(value)]
    };
  } else if (
    // SharedArrayBuffer disabled on most browsers due to spectre.
    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer
    // value instanceof SharedArrayBuffer ||
    value instanceof ArrayBuffer
  ) {
    const name = value.constructor.name;
    const base64 = encode(value);
    return {
      rr_type: name,
      base64
    };
  } else if (value instanceof DataView) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [
        serializeArg(value.buffer, win, ctx),
        value.byteOffset,
        value.byteLength
      ]
    };
  } else if (value instanceof HTMLImageElement) {
    const name = value.constructor.name;
    const { src } = value;
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof HTMLCanvasElement) {
    const name = "HTMLImageElement";
    const src = value.toDataURL();
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof ImageData) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [serializeArg(value.data, win, ctx), value.width, value.height]
    };
  } else if (isInstanceOfWebGLObject(value, win) || typeof value === "object") {
    const name = value.constructor.name;
    const index2 = saveWebGLVar(value, win, ctx);
    return {
      rr_type: name,
      index: index2
    };
  }
  return value;
}
const serializeArgs = (args, win, ctx) => {
  return args.map((arg) => serializeArg(arg, win, ctx));
};
const isInstanceOfWebGLObject = (value, win) => {
  const webGLConstructorNames = [
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLFramebuffer",
    "WebGLProgram",
    "WebGLRenderbuffer",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLTexture",
    "WebGLUniformLocation",
    "WebGLVertexArrayObject",
    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.
    "WebGLVertexArrayObjectOES"
  ];
  const supportedWebGLConstructorNames = webGLConstructorNames.filter(
    (name) => typeof win[name] === "function"
  );
  return Boolean(
    supportedWebGLConstructorNames.find(
      (name) => value instanceof win[name]
    )
  );
};
function initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {
  const handlers = [];
  const props2D = Object.getOwnPropertyNames(
    win.CanvasRenderingContext2D.prototype
  );
  for (const prop of props2D) {
    try {
      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch(
        win.CanvasRenderingContext2D.prototype,
        prop,
        function(original) {
          return function(...args) {
            if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {
              setTimeout(() => {
                const recordArgs = serializeArgs(args, win, this);
                cb(this.canvas, {
                  type: CanvasContext["2D"],
                  property: prop,
                  args: recordArgs
                });
              }, 0);
            }
            return original.apply(this, args);
          };
        }
      );
      handlers.push(restoreHandler);
    } catch {
      const hookHandler = hookSetter(
        win.CanvasRenderingContext2D.prototype,
        prop,
        {
          set(v2) {
            cb(this.canvas, {
              type: CanvasContext["2D"],
              property: prop,
              args: [v2],
              setter: true
            });
          }
        }
      );
      handlers.push(hookHandler);
    }
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
function getNormalizedContextName(contextType) {
  return contextType === "experimental-webgl" ? "webgl" : contextType;
}
function initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {
  const handlers = [];
  try {
    const restoreHandler = patch(
      win.HTMLCanvasElement.prototype,
      "getContext",
      function(original) {
        return function(contextType, ...args) {
          if (!isBlocked(this, blockClass, blockSelector, true)) {
            const ctxName = getNormalizedContextName(contextType);
            if (!("__context" in this)) this.__context = ctxName;
            if (setPreserveDrawingBufferToTrue && ["webgl", "webgl2"].includes(ctxName)) {
              if (args[0] && typeof args[0] === "object") {
                const contextAttributes = args[0];
                if (!contextAttributes.preserveDrawingBuffer) {
                  contextAttributes.preserveDrawingBuffer = true;
                }
              } else {
                args.splice(0, 1, {
                  preserveDrawingBuffer: true
                });
              }
            }
          }
          return original.apply(this, [contextType, ...args]);
        };
      }
    );
    handlers.push(restoreHandler);
  } catch {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
function patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {
  const handlers = [];
  const props = Object.getOwnPropertyNames(prototype);
  for (const prop of props) {
    if (
      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky
      [
        "isContextLost",
        "canvas",
        "drawingBufferWidth",
        "drawingBufferHeight"
      ].includes(prop)
    ) {
      continue;
    }
    try {
      if (typeof prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch(
        prototype,
        prop,
        function(original) {
          return function(...args) {
            const result2 = original.apply(this, args);
            saveWebGLVar(result2, win, this);
            if ("tagName" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {
              const recordArgs = serializeArgs(args, win, this);
              const mutation = {
                type,
                property: prop,
                args: recordArgs
              };
              cb(this.canvas, mutation);
            }
            return result2;
          };
        }
      );
      handlers.push(restoreHandler);
    } catch {
      const hookHandler = hookSetter(prototype, prop, {
        set(v2) {
          cb(this.canvas, {
            type,
            property: prop,
            args: [v2],
            setter: true
          });
        }
      });
      handlers.push(hookHandler);
    }
  }
  return handlers;
}
function initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {
  const handlers = [];
  handlers.push(
    ...patchGLPrototype(
      win.WebGLRenderingContext.prototype,
      CanvasContext.WebGL,
      cb,
      blockClass,
      blockSelector,
      win
    )
  );
  if (typeof win.WebGL2RenderingContext !== "undefined") {
    handlers.push(
      ...patchGLPrototype(
        win.WebGL2RenderingContext.prototype,
        CanvasContext.WebGL2,
        cb,
        blockClass,
        blockSelector,
        win
      )
    );
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
const encodedJs = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=";
const decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0));
const blob = typeof window !== "undefined" && window.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e2) {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
class CanvasManager {
  constructor(options) {
    __publicField(this, "pendingCanvasMutations", /* @__PURE__ */ new Map());
    __publicField(this, "rafStamps", { latestId: 0, invokeId: null });
    __publicField(this, "mirror");
    __publicField(this, "mutationCb");
    __publicField(this, "resetObservers");
    __publicField(this, "frozen", false);
    __publicField(this, "locked", false);
    __publicField(this, "processMutation", (target, mutation) => {
      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
      if (newFrame || !this.rafStamps.invokeId)
        this.rafStamps.invokeId = this.rafStamps.latestId;
      if (!this.pendingCanvasMutations.has(target)) {
        this.pendingCanvasMutations.set(target, []);
      }
      this.pendingCanvasMutations.get(target).push(mutation);
    });
    const {
      sampling = "all",
      win,
      blockClass,
      blockSelector,
      recordCanvas,
      dataURLOptions
    } = options;
    this.mutationCb = options.mutationCb;
    this.mirror = options.mirror;
    if (recordCanvas && sampling === "all")
      this.initCanvasMutationObserver(win, blockClass, blockSelector);
    if (recordCanvas && typeof sampling === "number")
      this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {
        dataURLOptions
      });
  }
  reset() {
    this.pendingCanvasMutations.clear();
    this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = true;
  }
  unfreeze() {
    this.frozen = false;
  }
  lock() {
    this.locked = true;
  }
  unlock() {
    this.locked = false;
  }
  initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {
    const canvasContextReset = initCanvasContextObserver(
      win,
      blockClass,
      blockSelector,
      true
    );
    const snapshotInProgressMap = /* @__PURE__ */ new Map();
    const worker = new WorkerWrapper();
    worker.onmessage = (e2) => {
      const { id } = e2.data;
      snapshotInProgressMap.set(id, false);
      if (!("base64" in e2.data)) return;
      const { base64, type, width, height } = e2.data;
      this.mutationCb({
        id,
        type: CanvasContext["2D"],
        commands: [
          {
            property: "clearRect",
            // wipe canvas
            args: [0, 0, width, height]
          },
          {
            property: "drawImage",
            // draws (semi-transparent) image
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64 }],
                    type
                  }
                ]
              },
              0,
              0
            ]
          }
        ]
      });
    };
    const timeBetweenSnapshots = 1e3 / fps;
    let lastSnapshotTime = 0;
    let rafId;
    const getCanvas = () => {
      const matchedCanvas = [];
      win.document.querySelectorAll("canvas").forEach((canvas) => {
        if (!isBlocked(canvas, blockClass, blockSelector, true)) {
          matchedCanvas.push(canvas);
        }
      });
      return matchedCanvas;
    };
    const takeCanvasSnapshots = (timestamp) => {
      if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {
        rafId = requestAnimationFrame(takeCanvasSnapshots);
        return;
      }
      lastSnapshotTime = timestamp;
      getCanvas().forEach(async (canvas) => {
        var _a2;
        const id = this.mirror.getId(canvas);
        if (snapshotInProgressMap.get(id)) return;
        if (canvas.width === 0 || canvas.height === 0) return;
        snapshotInProgressMap.set(id, true);
        if (["webgl", "webgl2"].includes(canvas.__context)) {
          const context = canvas.getContext(canvas.__context);
          if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {
            context.clear(context.COLOR_BUFFER_BIT);
          }
        }
        const bitmap = await createImageBitmap(canvas);
        worker.postMessage(
          {
            id,
            bitmap,
            width: canvas.width,
            height: canvas.height,
            dataURLOptions: options.dataURLOptions
          },
          [bitmap]
        );
      });
      rafId = requestAnimationFrame(takeCanvasSnapshots);
    };
    rafId = requestAnimationFrame(takeCanvasSnapshots);
    this.resetObservers = () => {
      canvasContextReset();
      cancelAnimationFrame(rafId);
    };
  }
  initCanvasMutationObserver(win, blockClass, blockSelector) {
    this.startRAFTimestamping();
    this.startPendingCanvasMutationFlusher();
    const canvasContextReset = initCanvasContextObserver(
      win,
      blockClass,
      blockSelector,
      false
    );
    const canvas2DReset = initCanvas2DMutationObserver(
      this.processMutation.bind(this),
      win,
      blockClass,
      blockSelector
    );
    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(
      this.processMutation.bind(this),
      win,
      blockClass,
      blockSelector
    );
    this.resetObservers = () => {
      canvasContextReset();
      canvas2DReset();
      canvasWebGL1and2Reset();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const setLatestRAFTimestamp = (timestamp) => {
      this.rafStamps.latestId = timestamp;
      requestAnimationFrame(setLatestRAFTimestamp);
    };
    requestAnimationFrame(setLatestRAFTimestamp);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach(
      (_values, canvas) => {
        const id = this.mirror.getId(canvas);
        this.flushPendingCanvasMutationFor(canvas, id);
      }
    );
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(canvas, id) {
    if (this.frozen || this.locked) {
      return;
    }
    const valuesWithType = this.pendingCanvasMutations.get(canvas);
    if (!valuesWithType || id === -1) return;
    const values = valuesWithType.map((value) => {
      const { type: type2, ...rest } = value;
      return rest;
    });
    const { type } = valuesWithType[0];
    this.mutationCb({ id, type, commands: values });
    this.pendingCanvasMutations.delete(canvas);
  }
}
class StylesheetManager {
  constructor(options) {
    __publicField(this, "trackedLinkElements", /* @__PURE__ */ new WeakSet());
    __publicField(this, "mutationCb");
    __publicField(this, "adoptedStyleSheetCb");
    __publicField(this, "styleMirror", new StyleSheetMirror());
    this.mutationCb = options.mutationCb;
    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;
  }
  attachLinkElement(linkEl, childSn) {
    if ("_cssText" in childSn.attributes)
      this.mutationCb({
        adds: [],
        removes: [],
        texts: [],
        attributes: [
          {
            id: childSn.id,
            attributes: childSn.attributes
          }
        ]
      });
    this.trackLinkElement(linkEl);
  }
  trackLinkElement(linkEl) {
    if (this.trackedLinkElements.has(linkEl)) return;
    this.trackedLinkElements.add(linkEl);
    this.trackStylesheetInLinkElement(linkEl);
  }
  adoptStyleSheets(sheets, hostId) {
    if (sheets.length === 0) return;
    const adoptedStyleSheetData = {
      id: hostId,
      styleIds: []
    };
    const styles = [];
    for (const sheet of sheets) {
      let styleId;
      if (!this.styleMirror.has(sheet)) {
        styleId = this.styleMirror.add(sheet);
        styles.push({
          styleId,
          rules: Array.from(sheet.rules || CSSRule, (r2, index2) => ({
            rule: stringifyRule(r2, sheet.href),
            index: index2
          }))
        });
      } else styleId = this.styleMirror.getId(sheet);
      adoptedStyleSheetData.styleIds.push(styleId);
    }
    if (styles.length > 0) adoptedStyleSheetData.styles = styles;
    this.adoptedStyleSheetCb(adoptedStyleSheetData);
  }
  reset() {
    this.styleMirror.reset();
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  // TODO: take snapshot on stylesheet reload by applying event listener
  trackStylesheetInLinkElement(_linkEl) {
  }
}
class ProcessedNodeManager {
  constructor() {
    __publicField(this, "nodeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "active", false);
  }
  inOtherBuffer(node2, thisBuffer) {
    const buffers = this.nodeMap.get(node2);
    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);
  }
  add(node2, buffer) {
    if (!this.active) {
      this.active = true;
      requestAnimationFrame(() => {
        this.nodeMap = /* @__PURE__ */ new WeakMap();
        this.active = false;
      });
    }
    this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));
  }
  destroy() {
  }
}
let wrappedEmit;
let takeFullSnapshot$1;
let canvasManager;
let recording = false;
try {
  if (Array.from([1], (x2) => x2 * 2)[0] !== 2) {
    const cleanFrame = document.createElement("iframe");
    document.body.appendChild(cleanFrame);
    Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;
    document.body.removeChild(cleanFrame);
  }
} catch (err) {
  console.debug("Unable to override Array.from", err);
}
const mirror = createMirror$2();
function record(options = {}) {
  const {
    emit,
    checkoutEveryNms,
    checkoutEveryNth,
    blockClass = "rr-block",
    blockSelector = null,
    ignoreClass = "rr-ignore",
    ignoreSelector = null,
    maskTextClass = "rr-mask",
    maskTextSelector = null,
    inlineStylesheet = true,
    maskAllInputs,
    maskInputOptions: _maskInputOptions,
    slimDOMOptions: _slimDOMOptions,
    maskInputFn,
    maskTextFn,
    hooks,
    packFn,
    sampling = {},
    dataURLOptions = {},
    mousemoveWait,
    recordDOM = true,
    recordCanvas = false,
    recordCrossOriginIframes = false,
    recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load",
    userTriggeredOnInput = false,
    collectFonts = false,
    inlineImages = false,
    plugins,
    keepIframeSrcFn = () => false,
    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),
    errorHandler: errorHandler2
  } = options;
  registerErrorHandler(errorHandler2);
  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;
  let passEmitsToParent = false;
  if (!inEmittingFrame) {
    try {
      if (window.parent.document) {
        passEmitsToParent = false;
      }
    } catch (e2) {
      passEmitsToParent = true;
    }
  }
  if (inEmittingFrame && !emit) {
    throw new Error("emit function is required");
  }
  if (!inEmittingFrame && !passEmitsToParent) {
    return () => {
    };
  }
  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {
    sampling.mousemove = mousemoveWait;
  }
  mirror.reset();
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : _maskInputOptions !== void 0 ? _maskInputOptions : { password: true };
  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {
    script: true,
    comment: true,
    headFavicon: true,
    headWhitespace: true,
    headMetaSocial: true,
    headMetaRobots: true,
    headMetaHttpEquiv: true,
    headMetaVerification: true,
    // the following are off for slimDOMOptions === true,
    // as they destroy some (hidden) info:
    headMetaAuthorship: _slimDOMOptions === "all",
    headMetaDescKeywords: _slimDOMOptions === "all",
    headTitleMutations: _slimDOMOptions === "all"
  } : _slimDOMOptions ? _slimDOMOptions : {};
  polyfill$1();
  let lastFullSnapshotEvent;
  let incrementalSnapshotCount = 0;
  const eventProcessor = (e2) => {
    for (const plugin3 of plugins || []) {
      if (plugin3.eventProcessor) {
        e2 = plugin3.eventProcessor(e2);
      }
    }
    if (packFn && // Disable packing events which will be emitted to parent frames.
    !passEmitsToParent) {
      e2 = packFn(e2);
    }
    return e2;
  };
  wrappedEmit = (r2, isCheckout) => {
    var _a2;
    const e2 = r2;
    e2.timestamp = nowTimestamp();
    if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {
      mutationBuffers.forEach((buf) => buf.unfreeze());
    }
    if (inEmittingFrame) {
      emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);
    } else if (passEmitsToParent) {
      const message = {
        type: "rrweb",
        event: eventProcessor(e2),
        origin: window.location.origin,
        isCheckout
      };
      window.parent.postMessage(message, "*");
    }
    if (e2.type === EventType.FullSnapshot) {
      lastFullSnapshotEvent = e2;
      incrementalSnapshotCount = 0;
    } else if (e2.type === EventType.IncrementalSnapshot) {
      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {
        return;
      }
      incrementalSnapshotCount++;
      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
      const exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
      if (exceedCount || exceedTime) {
        takeFullSnapshot$1(true);
      }
    }
  };
  const wrappedMutationEmit = (m) => {
    wrappedEmit({
      type: EventType.IncrementalSnapshot,
      data: {
        source: IncrementalSource.Mutation,
        ...m
      }
    });
  };
  const wrappedScrollEmit = (p) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.Scroll,
      ...p
    }
  });
  const wrappedCanvasMutationEmit = (p) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.CanvasMutation,
      ...p
    }
  });
  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.AdoptedStyleSheet,
      ...a2
    }
  });
  const stylesheetManager = new StylesheetManager({
    mutationCb: wrappedMutationEmit,
    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit
  });
  const iframeManager = new IframeManager({
    mirror,
    mutationCb: wrappedMutationEmit,
    stylesheetManager,
    recordCrossOriginIframes,
    wrappedEmit
  });
  for (const plugin3 of plugins || []) {
    if (plugin3.getMirror)
      plugin3.getMirror({
        nodeMirror: mirror,
        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror
      });
  }
  const processedNodeManager = new ProcessedNodeManager();
  canvasManager = new CanvasManager({
    recordCanvas,
    mutationCb: wrappedCanvasMutationEmit,
    win: window,
    blockClass,
    blockSelector,
    mirror,
    sampling: sampling.canvas,
    dataURLOptions
  });
  const shadowDomManager = new ShadowDomManager({
    mutationCb: wrappedMutationEmit,
    scrollCb: wrappedScrollEmit,
    bypassOptions: {
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskInputOptions,
      dataURLOptions,
      maskTextFn,
      maskInputFn,
      recordCanvas,
      inlineImages,
      sampling,
      slimDOMOptions,
      iframeManager,
      stylesheetManager,
      canvasManager,
      keepIframeSrcFn,
      processedNodeManager
    },
    mirror
  });
  takeFullSnapshot$1 = (isCheckout = false) => {
    if (!recordDOM) {
      return;
    }
    wrappedEmit(
      {
        type: EventType.Meta,
        data: {
          href: window.location.href,
          width: getWindowWidth(),
          height: getWindowHeight()
        }
      },
      isCheckout
    );
    stylesheetManager.reset();
    shadowDomManager.init();
    mutationBuffers.forEach((buf) => buf.lock());
    const node2 = snapshot(document, {
      mirror,
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskAllInputs: maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOM: slimDOMOptions,
      dataURLOptions,
      recordCanvas,
      inlineImages,
      onSerialize: (n2) => {
        if (isSerializedIframe(n2, mirror)) {
          iframeManager.addIframe(n2);
        }
        if (isSerializedStylesheet(n2, mirror)) {
          stylesheetManager.trackLinkElement(n2);
        }
        if (hasShadowRoot(n2)) {
          shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);
        }
      },
      onIframeLoad: (iframe, childSn) => {
        iframeManager.attachIframe(iframe, childSn);
        shadowDomManager.observeAttachShadow(iframe);
      },
      onStylesheetLoad: (linkEl, childSn) => {
        stylesheetManager.attachLinkElement(linkEl, childSn);
      },
      keepIframeSrcFn
    });
    if (!node2) {
      return console.warn("Failed to snapshot the document");
    }
    wrappedEmit(
      {
        type: EventType.FullSnapshot,
        data: {
          node: node2,
          initialOffset: getWindowScroll(window)
        }
      },
      isCheckout
    );
    mutationBuffers.forEach((buf) => buf.unlock());
    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
      stylesheetManager.adoptStyleSheets(
        document.adoptedStyleSheets,
        mirror.getId(document)
      );
  };
  try {
    const handlers = [];
    const observe = (doc) => {
      var _a2;
      return callbackWrapper(initObservers)(
        {
          mutationCb: wrappedMutationEmit,
          mousemoveCb: (positions, source) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source,
              positions
            }
          }),
          mouseInteractionCb: (d) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MouseInteraction,
              ...d
            }
          }),
          scrollCb: wrappedScrollEmit,
          viewportResizeCb: (d) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.ViewportResize,
              ...d
            }
          }),
          inputCb: (v2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Input,
              ...v2
            }
          }),
          mediaInteractionCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MediaInteraction,
              ...p
            }
          }),
          styleSheetRuleCb: (r2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleSheetRule,
              ...r2
            }
          }),
          styleDeclarationCb: (r2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleDeclaration,
              ...r2
            }
          }),
          canvasMutationCb: wrappedCanvasMutationEmit,
          fontCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Font,
              ...p
            }
          }),
          selectionCb: (p) => {
            wrappedEmit({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.Selection,
                ...p
              }
            });
          },
          customElementCb: (c2) => {
            wrappedEmit({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.CustomElement,
                ...c2
              }
            });
          },
          blockClass,
          ignoreClass,
          ignoreSelector,
          maskTextClass,
          maskTextSelector,
          maskInputOptions,
          inlineStylesheet,
          sampling,
          recordDOM,
          recordCanvas,
          inlineImages,
          userTriggeredOnInput,
          collectFonts,
          doc,
          maskInputFn,
          maskTextFn,
          keepIframeSrcFn,
          blockSelector,
          slimDOMOptions,
          dataURLOptions,
          mirror,
          iframeManager,
          stylesheetManager,
          shadowDomManager,
          processedNodeManager,
          canvasManager,
          ignoreCSSAttributes,
          plugins: ((_a2 = plugins == null ? void 0 : plugins.filter((p) => p.observer)) == null ? void 0 : _a2.map((p) => ({
            observer: p.observer,
            options: p.options,
            callback: (payload) => wrappedEmit({
              type: EventType.Plugin,
              data: {
                plugin: p.name,
                payload
              }
            })
          }))) || []
        },
        hooks
      );
    };
    iframeManager.addLoadListener((iframeEl) => {
      try {
        handlers.push(observe(iframeEl.contentDocument));
      } catch (error) {
        console.warn(error);
      }
    });
    const init = () => {
      takeFullSnapshot$1();
      handlers.push(observe(document));
      recording = true;
    };
    if (document.readyState === "interactive" || document.readyState === "complete") {
      init();
    } else {
      handlers.push(
        on("DOMContentLoaded", () => {
          wrappedEmit({
            type: EventType.DomContentLoaded,
            data: {}
          });
          if (recordAfter === "DOMContentLoaded") init();
        })
      );
      handlers.push(
        on(
          "load",
          () => {
            wrappedEmit({
              type: EventType.Load,
              data: {}
            });
            if (recordAfter === "load") init();
          },
          window
        )
      );
    }
    return () => {
      handlers.forEach((h) => h());
      processedNodeManager.destroy();
      recording = false;
      unregisterErrorHandler();
    };
  } catch (error) {
    console.warn(error);
  }
}
record.addCustomEvent = (tag, payload) => {
  if (!recording) {
    throw new Error("please add custom event after start recording");
  }
  wrappedEmit({
    type: EventType.Custom,
    data: {
      tag,
      payload
    }
  });
};
record.freezePage = () => {
  mutationBuffers.forEach((buf) => buf.freeze());
};
record.takeFullSnapshot = (isCheckout) => {
  if (!recording) {
    throw new Error("please take full snapshot after start recording");
  }
  takeFullSnapshot$1(isCheckout);
};
record.mirror = mirror;
var n;
!function(t2) {
  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
}(n || (n = {}));

//# sourceMappingURL=record.js.map

;// ./node_modules/@rrweb/types/dist/types.js
var types_EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(types_EventType || {});
var types_IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(types_IncrementalSource || {});
var types_MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(types_MouseInteractions || {});
var types_PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(types_PointerTypes || {});
var types_CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(types_CanvasContext || {});
var types_MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
  return MediaInteractions2;
})(types_MediaInteractions || {});
var ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {
  ReplayerEvents2["Start"] = "start";
  ReplayerEvents2["Pause"] = "pause";
  ReplayerEvents2["Resume"] = "resume";
  ReplayerEvents2["Resize"] = "resize";
  ReplayerEvents2["Finish"] = "finish";
  ReplayerEvents2["FullsnapshotRebuilded"] = "fullsnapshot-rebuilded";
  ReplayerEvents2["LoadStylesheetStart"] = "load-stylesheet-start";
  ReplayerEvents2["LoadStylesheetEnd"] = "load-stylesheet-end";
  ReplayerEvents2["SkipStart"] = "skip-start";
  ReplayerEvents2["SkipEnd"] = "skip-end";
  ReplayerEvents2["MouseInteraction"] = "mouse-interaction";
  ReplayerEvents2["EventCast"] = "event-cast";
  ReplayerEvents2["CustomEvent"] = "custom-event";
  ReplayerEvents2["Flush"] = "flush";
  ReplayerEvents2["StateChange"] = "state-change";
  ReplayerEvents2["PlayBack"] = "play-back";
  ReplayerEvents2["Destroy"] = "destroy";
  return ReplayerEvents2;
})(ReplayerEvents || {});
var types_NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(types_NodeType || {});

//# sourceMappingURL=types.js.map

// EXTERNAL MODULE: ./src/tracing/hrtime.js
var hrtime = __nested_webpack_require_272218__(1);
;// ./src/browser/replay/recorder.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _options = /*#__PURE__*/new WeakMap();
var _stopFn = /*#__PURE__*/new WeakMap();
var _recordFn = /*#__PURE__*/new WeakMap();
var _events = /*#__PURE__*/new WeakMap();
var Recorder = /*#__PURE__*/function () {
  /**
   * Creates a new Recorder instance for capturing DOM events
   *
   * @param {Object} options - Configuration options for the recorder
   * @param {Function} [recordFn=rrwebRecordFn] - The recording function to use
   */
  function Recorder(options) {
    var recordFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : record;
    _classCallCheck(this, Recorder);
    _classPrivateFieldInitSpec(this, _options, void 0);
    _classPrivateFieldInitSpec(this, _stopFn, null);
    _classPrivateFieldInitSpec(this, _recordFn, void 0);
    _classPrivateFieldInitSpec(this, _events, {
      previous: [],
      current: []
    });
    if (!recordFn) {
      throw new TypeError("Expected 'recordFn' to be provided");
    }
    console.log('Recorder: Initializing...');
    console.log('options', options);
    _classPrivateFieldSet(_options, this, options !== null && options !== void 0 ? options : {});
    _classPrivateFieldSet(_recordFn, this, recordFn);
  }
  return _createClass(Recorder, [{
    key: "isRecording",
    get: function get() {
      return _classPrivateFieldGet(_stopFn, this) !== null;
    }
  }, {
    key: "options",
    get: function get() {
      return _classPrivateFieldGet(_options, this);
    },
    set: function set(newOptions) {
      this.configure(newOptions);
    }
  }, {
    key: "configure",
    value: function configure(newOptions) {
      if (this.isRecording && newOptions.enabled === false) {
        this.stop();
      }
      _classPrivateFieldSet(_options, this, newOptions);
    }

    /**
     * Converts recorded events into a formatted payload ready for transport.
     *
     * This method takes the recorder's stored events, creates a new span with the
     * provided tracing context, attaches all events with their timestamps as span
     * events, and then returns a payload ready for transport to the server.
     *
     * @param {Object} tracing - The tracing system instance to create spans
     * @param {string} replayId - Unique identifier to associate with this replay recording
     * @returns {Object|null} A formatted payload containing spans data in OTLP format, or null if no events exist
     */
  }, {
    key: "dump",
    value: function dump(tracing, replayId, occurrenceUuid) {
      var events = _classPrivateFieldGet(_events, this).previous.concat(_classPrivateFieldGet(_events, this).current);
      if (events.length < 2) {
        console.warn("Recorder.dump: Min 2 events req. Found ".concat(events.length));
        return null;
      }
      console.log("Recorder.dump: Dumping ".concat(events.length, " events"));
      var recordingSpan = tracing.startSpan('rrweb-replay-recording', {});
      recordingSpan.setAttribute('rollbar.replay.id', replayId);
      if (occurrenceUuid) {
        recordingSpan.setAttribute('rollbar.occurrence.uuid', occurrenceUuid);
      }
      var earliestEvent = events.reduce(function (earliestEvent, event) {
        return event.timestamp < earliestEvent.timestamp ? event : earliestEvent;
      });
      recordingSpan.span.startTime = hrtime/* default */.A.fromMillis(earliestEvent.timestamp);
      var _iterator = _createForOfIteratorHelper(events),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var event = _step.value;
          recordingSpan.addEvent('rrweb-replay-events', {
            eventType: event.type,
            json: JSON.stringify(event.data),
            'rollbar.replay.id': replayId
          }, hrtime/* default */.A.fromMillis(event.timestamp));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      recordingSpan.end();
      return tracing.exporter.toPayload();
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;
      if (this.isRecording || this.options.enabled === false) {
        if (this.isRecording) {
          console.log('Recorder: Already started');
        } else {
          console.log('Recorder: Disabled');
        }
        return;
      }
      console.log('Recorder: Starting...');
      this.clear();
      _classPrivateFieldSet(_stopFn, this, _classPrivateFieldGet(_recordFn, this).call(this, _objectSpread({
        emit: function emit(event, isCheckout) {
          var _this$options$debug;
          if ((_this$options$debug = _this.options.debug) !== null && _this$options$debug !== void 0 && _this$options$debug.logEmits) {
            _this._logEvent(event, isCheckout);
          }
          if (isCheckout && event.type === types_EventType.Meta) {
            _classPrivateFieldGet(_events, _this).previous = _classPrivateFieldGet(_events, _this).current;
            _classPrivateFieldGet(_events, _this).current = [];
          }
          _classPrivateFieldGet(_events, _this).current.push(event);
        },
        checkoutEveryNms: 5 * 60 * 1000
      }, this.options)));
      console.log('Recorder: Started');
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.isRecording) {
        console.log('Recorder: Already stopped');
        return;
      }
      console.log('Recorder: Stopping...');
      _classPrivateFieldGet(_stopFn, this).call(this);
      _classPrivateFieldSet(_stopFn, this, null);
      console.log('Recorder: Stopped');
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldSet(_events, this, {
        previous: [],
        current: []
      });
    }
  }, {
    key: "_logEvent",
    value: function _logEvent(event, isCheckout) {
      console.log("Recorder: ".concat(isCheckout ? 'checkout' : '', " event\n"), function (e) {
        var seen = new WeakSet();
        return JSON.stringify(e, function (_, v) {
          if (_typeof(v) === 'object' && v !== null) {
            if (seen.has(v)) return '[Circular]';
            seen.add(v);
          }
          return v;
        }, 2);
      }(event));
    }
  }]);
}();


/***/ }),

/***/ 922:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_657762__) {

var _ = __nested_webpack_require_657762__(585);
var traverse = __nested_webpack_require_657762__(98);
function scrub(data, scrubFields, scrubPaths) {
  scrubFields = scrubFields || [];
  if (scrubPaths) {
    for (var i = 0; i < scrubPaths.length; ++i) {
      scrubPath(data, scrubPaths[i]);
    }
  }
  var paramRes = _getScrubFieldRegexs(scrubFields);
  var queryRes = _getScrubQueryParamRegexs(scrubFields);
  function redactQueryParam(dummy0, paramPart) {
    return paramPart + _.redact();
  }
  function paramScrubber(v) {
    var i;
    if (_.isType(v, 'string')) {
      for (i = 0; i < queryRes.length; ++i) {
        v = v.replace(queryRes[i], redactQueryParam);
      }
    }
    return v;
  }
  function valScrubber(k, v) {
    var i;
    for (i = 0; i < paramRes.length; ++i) {
      if (paramRes[i].test(k)) {
        v = _.redact();
        break;
      }
    }
    return v;
  }
  function scrubber(k, v, seen) {
    var tmpV = valScrubber(k, v);
    if (tmpV === v) {
      if (_.isType(v, 'object') || _.isType(v, 'array')) {
        return traverse(v, scrubber, seen);
      }
      return paramScrubber(tmpV);
    } else {
      return tmpV;
    }
  }
  return traverse(data, scrubber);
}
function scrubPath(obj, path) {
  var keys = path.split('.');
  var last = keys.length - 1;
  try {
    for (var i = 0; i <= last; ++i) {
      if (i < last) {
        obj = obj[keys[i]];
      } else {
        obj[keys[i]] = _.redact();
      }
    }
  } catch (e) {
    // Missing key is OK;
  }
}
function _getScrubFieldRegexs(scrubFields) {
  var ret = [];
  var pat;
  for (var i = 0; i < scrubFields.length; ++i) {
    pat = '^\\[?(%5[bB])?' + scrubFields[i] + '\\[?(%5[bB])?\\]?(%5[dD])?$';
    ret.push(new RegExp(pat, 'i'));
  }
  return ret;
}
function _getScrubQueryParamRegexs(scrubFields) {
  var ret = [];
  var pat;
  for (var i = 0; i < scrubFields.length; ++i) {
    pat = '\\[?(%5[bB])?' + scrubFields[i] + '\\[?(%5[bB])?\\]?(%5[dD])?';
    ret.push(new RegExp('(' + pat + '=)([^&\\n]+)', 'igm'));
  }
  return ret;
}
module.exports = scrub;

/***/ }),

/***/ 939:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_659901__) {

var _ = __nested_webpack_require_659901__(585);

/*
 * Notifier - the internal object responsible for delegating between the client exposed API, the
 * chain of transforms necessary to turn an item into something that can be sent to Rollbar, and the
 * queue which handles the communcation with the Rollbar API servers.
 *
 * @param queue - an object that conforms to the interface: addItem(item, callback)
 * @param options - an object representing the options to be set for this notifier, this should have
 * any defaults already set by the caller
 */
function Notifier(queue, options) {
  this.queue = queue;
  this.options = options;
  this.transforms = [];
  this.diagnostic = {};
}

/*
 * configure - updates the options for this notifier with the passed in object
 *
 * @param options - an object which gets merged with the current options set on this notifier
 * @returns this
 */
Notifier.prototype.configure = function (options) {
  this.queue && this.queue.configure(options);
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  return this;
};

/*
 * addTransform - adds a transform onto the end of the queue of transforms for this notifier
 *
 * @param transform - a function which takes three arguments:
 *    * item: An Object representing the data to eventually be sent to Rollbar
 *    * options: The current value of the options for this notifier
 *    * callback: function(err: (Null|Error), item: (Null|Object)) the transform must call this
 *    callback with a null value for error if it wants the processing chain to continue, otherwise
 *    with an error to terminate the processing. The item should be the updated item after this
 *    transform is finished modifying it.
 */
Notifier.prototype.addTransform = function (transform) {
  if (_.isFunction(transform)) {
    this.transforms.push(transform);
  }
  return this;
};

/*
 * log - the internal log function which applies the configured transforms and then pushes onto the
 * queue to be sent to the backend.
 *
 * @param item - An object with the following structure:
 *    message [String] - An optional string to be sent to rollbar
 *    error [Error] - An optional error
 *
 * @param callback - A function of type function(err, resp) which will be called with exactly one
 * null argument and one non-null argument. The callback will be called once, either during the
 * transform stage if an error occurs inside a transform, or in response to the communication with
 * the backend. The second argument will be the response from the backend in case of success.
 */
Notifier.prototype.log = function (item, callback) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  if (!this.options.enabled) {
    return callback(new Error('Rollbar is not enabled'));
  }
  this.queue.addPendingItem(item);
  var originalError = item.err;
  this._applyTransforms(item, function (err, i) {
    if (err) {
      this.queue.removePendingItem(item);
      return callback(err, null);
    }
    this.queue.addItem(i, callback, originalError, item);
  }.bind(this));
};

/* Internal */

/*
 * _applyTransforms - Applies the transforms that have been added to this notifier sequentially. See
 * `addTransform` for more information.
 *
 * @param item - An item to be transformed
 * @param callback - A function of type function(err, item) which will be called with a non-null
 * error and a null item in the case of a transform failure, or a null error and non-null item after
 * all transforms have been applied.
 */
Notifier.prototype._applyTransforms = function (item, callback) {
  var transformIndex = -1;
  var transformsLength = this.transforms.length;
  var transforms = this.transforms;
  var options = this.options;
  var _cb = function cb(err, i) {
    if (err) {
      callback(err, null);
      return;
    }
    transformIndex++;
    if (transformIndex === transformsLength) {
      callback(null, i);
      return;
    }
    transforms[transformIndex](i, options, _cb);
  };
  _cb(null, item);
};
module.exports = Notifier;

/***/ }),

/***/ 949:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_664059__) {

var RateLimiter = __nested_webpack_require_664059__(511);
var Queue = __nested_webpack_require_664059__(14);
var Notifier = __nested_webpack_require_664059__(939);
var _ = __nested_webpack_require_664059__(585);

/*
 * Rollbar - the interface to Rollbar
 *
 * @param options
 * @param api
 * @param logger
 */
function Rollbar(options, api, logger, telemeter, tracing, replayMap, platform) {
  this.options = _.merge(options);
  this.logger = logger;
  Rollbar.rateLimiter.configureGlobal(this.options);
  Rollbar.rateLimiter.setPlatformOptions(platform, this.options);
  this.api = api;
  this.queue = new Queue(Rollbar.rateLimiter, api, logger, this.options, replayMap);
  this.tracing = tracing;

  // Legacy OpenTracing support
  // This must happen before the Notifier is created
  var tracer = this.options.tracer || null;
  if (validateTracer(tracer)) {
    this.tracer = tracer;
    // set to a string for api response serialization
    this.options.tracer = 'opentracing-tracer-enabled';
    this.options._configuredOptions.tracer = 'opentracing-tracer-enabled';
  } else {
    this.tracer = null;
  }
  this.notifier = new Notifier(this.queue, this.options);
  this.telemeter = telemeter;
  setStackTraceLimit(options);
  this.lastError = null;
  this.lastErrorHash = 'none';
}
var defaultOptions = {
  maxItems: 0,
  itemsPerMinute: 60
};
Rollbar.rateLimiter = new RateLimiter(defaultOptions);
Rollbar.prototype.global = function (options) {
  Rollbar.rateLimiter.configureGlobal(options);
  return this;
};
Rollbar.prototype.configure = function (options, payloadData) {
  var oldOptions = this.options;
  var payload = {};
  if (payloadData) {
    payload = {
      payload: payloadData
    };
  }
  this.options = _.merge(oldOptions, options, payload);

  // Legacy OpenTracing support
  // This must happen before the Notifier is configured
  var tracer = this.options.tracer || null;
  if (validateTracer(tracer)) {
    this.tracer = tracer;
    // set to a string for api response serialization
    this.options.tracer = 'opentracing-tracer-enabled';
    this.options._configuredOptions.tracer = 'opentracing-tracer-enabled';
  } else {
    this.tracer = null;
  }
  this.notifier && this.notifier.configure(this.options);
  this.telemeter && this.telemeter.configure(this.options);
  setStackTraceLimit(options);
  this.global(this.options);
  if (validateTracer(options.tracer)) {
    this.tracer = options.tracer;
  }
  return this;
};
Rollbar.prototype.log = function (item) {
  var level = this._defaultLogLevel();
  return this._log(level, item);
};
Rollbar.prototype.debug = function (item) {
  this._log('debug', item);
};
Rollbar.prototype.info = function (item) {
  this._log('info', item);
};
Rollbar.prototype.warn = function (item) {
  this._log('warning', item);
};
Rollbar.prototype.warning = function (item) {
  this._log('warning', item);
};
Rollbar.prototype.error = function (item) {
  this._log('error', item);
};
Rollbar.prototype.critical = function (item) {
  this._log('critical', item);
};
Rollbar.prototype.wait = function (callback) {
  this.queue.wait(callback);
};
Rollbar.prototype.captureEvent = function (type, metadata, level) {
  return this.telemeter && this.telemeter.captureEvent(type, metadata, level);
};
Rollbar.prototype.captureDomContentLoaded = function (ts) {
  return this.telemeter && this.telemeter.captureDomContentLoaded(ts);
};
Rollbar.prototype.captureLoad = function (ts) {
  return this.telemeter && this.telemeter.captureLoad(ts);
};
Rollbar.prototype.buildJsonPayload = function (item) {
  return this.api.buildJsonPayload(item);
};
Rollbar.prototype.sendJsonPayload = function (jsonPayload) {
  this.api.postJsonPayload(jsonPayload);
};

/* Internal */

Rollbar.prototype._log = function (defaultLevel, item) {
  var callback;
  if (item.callback) {
    callback = item.callback;
    delete item.callback;
  }
  if (this.options.ignoreDuplicateErrors && this._sameAsLastError(item)) {
    if (callback) {
      var error = new Error('ignored identical item');
      error.item = item;
      callback(error);
    }
    return;
  }
  try {
    this._addTracingAttributes(item);

    // Legacy OpenTracing support
    this._addTracingInfo(item);
    item.level = item.level || defaultLevel;
    var telemeter = this.telemeter;
    if (telemeter) {
      telemeter._captureRollbarItem(item);
      item.telemetryEvents = telemeter.copyEvents() || [];
      if (telemeter.telemetrySpan) {
        telemeter.telemetrySpan.end();
        telemeter.telemetrySpan = telemeter.tracing.startSpan('rollbar-telemetry', {});
      }
    }
    this.notifier.log(item, callback);
  } catch (e) {
    if (callback) {
      callback(e);
    }
    this.logger.error(e);
  }
};
Rollbar.prototype._addTracingAttributes = function (item) {
  var _this$tracing;
  var span = (_this$tracing = this.tracing) === null || _this$tracing === void 0 ? void 0 : _this$tracing.getSpan();
  if (!span) {
    return;
  }
  var attributes = [{
    key: 'session_id',
    value: this.tracing.sessionId
  }, {
    key: 'span_id',
    value: span.spanId
  }, {
    key: 'trace_id',
    value: span.traceId
  }];
  _.addItemAttributes(item, attributes);
  span.addEvent('rollbar.occurrence', [{
    key: 'rollbar.occurrence.uuid',
    value: item.uuid
  }]);
};
Rollbar.prototype._defaultLogLevel = function () {
  return this.options.logLevel || 'debug';
};
Rollbar.prototype._sameAsLastError = function (item) {
  if (!item._isUncaught) {
    return false;
  }
  var itemHash = generateItemHash(item);
  if (this.lastErrorHash === itemHash) {
    return true;
  }
  this.lastError = item.err;
  this.lastErrorHash = itemHash;
  return false;
};
Rollbar.prototype._addTracingInfo = function (item) {
  // Tracer validation occurs in the constructor
  // or in the Rollbar.prototype.configure methods
  if (this.tracer) {
    // add rollbar occurrence uuid to span
    var span = this.tracer.scope().active();
    if (validateSpan(span)) {
      span.setTag('rollbar.error_uuid', item.uuid);
      span.setTag('rollbar.has_error', true);
      span.setTag('error', true);
      span.setTag('rollbar.item_url', "https://rollbar.com/item/uuid/?uuid=".concat(item.uuid));
      span.setTag('rollbar.occurrence_url', "https://rollbar.com/occurrence/uuid/?uuid=".concat(item.uuid));

      // add span ID & trace ID to occurrence
      var opentracingSpanId = span.context().toSpanId();
      var opentracingTraceId = span.context().toTraceId();
      if (item.custom) {
        item.custom.opentracing_span_id = opentracingSpanId;
        item.custom.opentracing_trace_id = opentracingTraceId;
      } else {
        item.custom = {
          opentracing_span_id: opentracingSpanId,
          opentracing_trace_id: opentracingTraceId
        };
      }
    }
  }
};
function generateItemHash(item) {
  var message = item.message || '';
  var stack = (item.err || {}).stack || String(item.err);
  return message + '::' + stack;
}

// Node.js, Chrome, Safari, and some other browsers support this property
// which globally sets the number of stack frames returned in an Error object.
// If a browser can't use it, no harm done.
function setStackTraceLimit(options) {
  if (options.stackTraceLimit) {
    Error.stackTraceLimit = options.stackTraceLimit;
  }
}

/**
 * Validate the Tracer object provided to the Client
 * is valid for our Opentracing use case.
 * @param {opentracer.Tracer} tracer
 */
function validateTracer(tracer) {
  if (!tracer) {
    return false;
  }
  if (!tracer.scope || typeof tracer.scope !== 'function') {
    return false;
  }
  var scope = tracer.scope();
  if (!scope || !scope.active || typeof scope.active !== 'function') {
    return false;
  }
  return true;
}

/**
 * Validate the Span object provided
 * @param {opentracer.Span} span
 */
function validateSpan(span) {
  if (!span || !span.context || typeof span.context !== 'function') {
    return false;
  }
  var spanContext = span.context();
  if (!spanContext || !spanContext.toSpanId || !spanContext.toTraceId || typeof spanContext.toSpanId !== 'function' || typeof spanContext.toTraceId !== 'function') {
    return false;
  }
  return true;
}
module.exports = Rollbar;

/***/ }),

/***/ 960:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_672293__) {

var _ = __nested_webpack_require_672293__(585);
function itemToPayload(item, options, callback) {
  var data = item.data;
  if (item._isUncaught) {
    data._isUncaught = true;
  }
  if (item._originalArgs) {
    data._originalArgs = item._originalArgs;
  }
  callback(null, data);
}
function addPayloadOptions(item, options, callback) {
  var payloadOptions = options.payload || {};
  if (payloadOptions.body) {
    delete payloadOptions.body;
  }
  item.data = _.merge(item.data, payloadOptions);
  callback(null, item);
}
function addTelemetryData(item, options, callback) {
  if (item.telemetryEvents) {
    _.set(item, 'data.body.telemetry', item.telemetryEvents);
  }
  callback(null, item);
}
function addMessageWithError(item, options, callback) {
  if (!item.message) {
    callback(null, item);
    return;
  }
  var tracePath = 'data.body.trace_chain.0';
  var trace = _.get(item, tracePath);
  if (!trace) {
    tracePath = 'data.body.trace';
    trace = _.get(item, tracePath);
  }
  if (trace) {
    if (!(trace.exception && trace.exception.description)) {
      _.set(item, tracePath + '.exception.description', item.message);
      callback(null, item);
      return;
    }
    var extra = _.get(item, tracePath + '.extra') || {};
    var newExtra = _.merge(extra, {
      message: item.message
    });
    _.set(item, tracePath + '.extra', newExtra);
  }
  callback(null, item);
}
function userTransform(logger) {
  return function (item, options, callback) {
    var newItem = _.merge(item);
    var response = null;
    try {
      if (_.isFunction(options.transform)) {
        response = options.transform(newItem.data, item);
      }
    } catch (e) {
      options.transform = null;
      logger.error('Error while calling custom transform() function. Removing custom transform().', e);
      callback(null, item);
      return;
    }
    if (_.isPromise(response)) {
      response.then(function (promisedItem) {
        if (promisedItem) {
          newItem.data = promisedItem;
        }
        callback(null, newItem);
      }, function (error) {
        callback(error, item);
      });
    } else {
      callback(null, newItem);
    }
  };
}
function addConfigToPayload(item, options, callback) {
  if (!options.sendConfig) {
    return callback(null, item);
  }
  var configKey = '_rollbarConfig';
  var custom = _.get(item, 'data.custom') || {};
  custom[configKey] = options;
  item.data.custom = custom;
  callback(null, item);
}
function addFunctionOption(options, name) {
  if (_.isFunction(options[name])) {
    options[name] = options[name].toString();
  }
}
function addConfiguredOptions(item, options, callback) {
  var configuredOptions = options._configuredOptions;

  // These must be stringified or they'll get dropped during serialization.
  addFunctionOption(configuredOptions, 'transform');
  addFunctionOption(configuredOptions, 'checkIgnore');
  addFunctionOption(configuredOptions, 'onSendCallback');
  delete configuredOptions.accessToken;
  item.data.notifier.configured_options = configuredOptions;
  callback(null, item);
}
function addDiagnosticKeys(item, options, callback) {
  var diagnostic = _.merge(item.notifier.client.notifier.diagnostic, item.diagnostic);
  if (_.get(item, 'err._isAnonymous')) {
    diagnostic.is_anonymous = true;
  }
  if (item._isUncaught) {
    diagnostic.is_uncaught = item._isUncaught;
  }
  if (item.err) {
    try {
      diagnostic.raw_error = {
        message: item.err.message,
        name: item.err.name,
        constructor_name: item.err.constructor && item.err.constructor.name,
        filename: item.err.fileName,
        line: item.err.lineNumber,
        column: item.err.columnNumber,
        stack: item.err.stack
      };
    } catch (e) {
      diagnostic.raw_error = {
        failed: String(e)
      };
    }
  }
  item.data.notifier.diagnostic = _.merge(item.data.notifier.diagnostic, diagnostic);
  callback(null, item);
}
module.exports = {
  itemToPayload: itemToPayload,
  addPayloadOptions: addPayloadOptions,
  addTelemetryData: addTelemetryData,
  addMessageWithError: addMessageWithError,
  userTransform: userTransform,
  addConfigToPayload: addConfigToPayload,
  addConfiguredOptions: addConfiguredOptions,
  addDiagnosticKeys: addDiagnosticKeys
};

/***/ }),

/***/ 965:
/***/ (function(module) {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var isPlainObject = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== '[object Object]') {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, 'constructor');
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  // Not own constructor property must be Object
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {
    /**/
  }
  return typeof key === 'undefined' || hasOwn.call(obj, key);
};
function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = {},
    current = null,
    length = arguments.length;
  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {
      continue;
    }
    for (name in current) {
      src = result[name];
      copy = current[name];
      if (result !== copy) {
        if (copy && isPlainObject(copy)) {
          clone = src && isPlainObject(src) ? src : {};
          result[name] = merge(clone, copy);
        } else if (typeof copy !== 'undefined') {
          result[name] = copy;
        }
      }
    }
  }
  return result;
}
module.exports = merge;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_678286__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_678286__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_678286__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_678286__.o(definition, key) && !__nested_webpack_require_678286__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_678286__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_678286__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_678286__(428);
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=rollbar.umd.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***************************************!*\
  !*** ./test/examples/angular.test.js ***!
  \***************************************/
/* globals expect */
/* globals describe */
/* globals it */

// Import Rollbar directly from the source
var Rollbar = __webpack_require__(/*! ../../dist/rollbar.umd.js */ "./dist/rollbar.umd.js");

describe('Angular integration', function () {
  // Utility function to create a test-enabled Rollbar instance
  function createTestRollbar(capturePayload) {
    var rollbar = new Rollbar({
      accessToken: 'ROLLBAR_POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      // Override logging to test
      autoInstrument: false,
      // Override endpoint to prevent actual API calls
      endpoint: 'https://test.example.com/api',
      // Set log level to debug to catch all messages
      logLevel: 'debug'
    });

    // Override the actual API call with our test hook
    var originalQueue = rollbar.client.queue.addItem;
    rollbar.client.queue.addItem = function(item, callback) {
      // Capture the payload for verification
      capturePayload(item);
      // Call the original to maintain proper behavior
      return originalQueue.call(this, item, callback);
    };

    return rollbar;
  }

  it('should correctly configure Rollbar with Angular config options', function () {
    // Verify the integration by evaluating the Rollbar configuration pattern
    var config = {
      accessToken: 'ROLLBAR_POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      captureUnhandledRejections: true,
      environment: 'production'
    };

    // Initialize Rollbar like the Angular app would
    var rollbar = new Rollbar(config);

    // Check that Rollbar was initialized correctly
    expect(rollbar.options.accessToken).to.equal('ROLLBAR_POST_CLIENT_ITEM_TOKEN');
    expect(rollbar.options.captureUncaught).to.equal(true);
    expect(rollbar.options.captureUnhandledRejections).to.equal(true);
  });

  it('should process and send errors with correct data', function() {
    var processedItem = null;

    // Create a Rollbar instance with our test hook
    var rollbar = createTestRollbar(function(item) {
      processedItem = item;
    });

    // Create a test error
    var testError = new Error('Test Angular Error');
    var customData = { component: 'TestComponent' };

    // Call error method
    rollbar.error(testError, customData);

    // Verify the error was processed
    expect(processedItem).to.not.equal(null);

    // Verify the error level is set correctly
    expect(processedItem.level).to.equal('error');

    // Verify the error message is included
    expect(processedItem.body.trace.exception.message).to.equal('Test Angular Error');

    // Verify custom data is included
    expect(processedItem.custom.component).to.equal('TestComponent');
  });

  it('should process and send warnings with correct data', function() {
    var processedItem = null;

    // Create a Rollbar instance with our test hook
    var rollbar = createTestRollbar(function(item) {
      processedItem = item;
    });

    // Call warning method
    var warningMessage = 'Test Angular Warning';
    var customData = { severity: 'medium' };

    rollbar.warning(warningMessage, customData);

    // Verify the warning was processed
    expect(processedItem).to.not.equal(null);

    // Verify the warning level is set correctly
    expect(processedItem.level).to.equal('warning');

    // Verify the warning message is included
    expect(processedItem.body.message.body).to.equal('Test Angular Warning');

    // Verify custom data is included
    expect(processedItem.custom.severity).to.equal('medium');
  });

  it('should include Angular-specific properties in error data', function() {
    var processedItem = null;

    // Create a Rollbar instance with our test hook
    var rollbar = createTestRollbar(function(item) {
      processedItem = item;
    });

    // Create an Angular-specific error with ngDebugContext
    var angularError = new Error('Angular Component Error');

    // Create a custom object that includes Angular-specific context
    var customData = {
      ngDebugContext: {
        component: 'TestAngularComponent',
        context: { name: 'AngularContext' }
      }
    };

    // Call error method with the custom data that includes Angular debug context
    rollbar.error(angularError, customData);

    // Verify the error was processed
    expect(processedItem).to.not.equal(null);

    // Verify the error message is included
    expect(processedItem.body.trace.exception.message).to.equal('Angular Component Error');

    // Verify Angular-specific properties are included in custom data
    expect(typeof processedItem.custom.ngDebugContext).to.equal('object');
    expect(processedItem.custom.ngDebugContext.component).to.equal('TestAngularComponent');
    expect(processedItem.custom.ngDebugContext.context.name).to.equal('AngularContext');
  });
});

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhhbXBsZXMvYW5ndWxhci50ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7QUNWQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNO0FBQUEsRUFLd0I7QUFDOUIsQ0FBQztBQUNELDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLHlDQUF5QywwQkFBbUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsY0FBYyxjQUFjLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCwrQkFBbUI7O0FBRXJFLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQyxjQUFjLDRNQUE0TSxhQUFhLGFBQWEsZ0dBQWdHLGlCQUFpQiwrQ0FBK0Msa0hBQWtILDJCQUEyQixxQ0FBcUMsMERBQTBELFdBQVcsTUFBTSxTQUFTLFNBQVMsWUFBWSxvQ0FBb0Msc0JBQXNCLDRCQUE0Qix5SEFBeUgseUJBQXlCLGtDQUFrQyxRQUFRLDZCQUE2QixNQUFNLFNBQVMsdUNBQXVDLFlBQVksU0FBUyw2QkFBNkIsZUFBZSwwRkFBMEYsd0JBQXdCLGdDQUFnQyx5Q0FBeUMsWUFBWSwyQkFBMkIsY0FBYyxHQUFHLDBEQUEwRCx5Q0FBeUMsdUZBQXVGLG9DQUFvQyxtREFBbUQsNEJBQTRCLDRCQUE0QixJQUFJLEtBQUssK0JBQStCLDhCQUE4Qiw4QkFBOEIsMEJBQTBCLDRCQUE0QixzR0FBc0csMEJBQTBCLGlCQUFpQiwyQkFBMkIscUNBQXFDLG9CQUFvQixpQkFBaUIsa0NBQWtDLEtBQUssWUFBWSxPQUFPLHFCQUFxQiw4QkFBOEIsd0NBQXdDLCtCQUErQixxQkFBcUIsS0FBSyxpSEFBaUgsS0FBSyxxQ0FBcUMsV0FBVyx5QkFBeUIsMERBQTBELGVBQWUsNEJBQTRCLFNBQVMsd0JBQXdCLDhCQUE4QixJQUFJLG9CQUFvQixTQUFTLG1DQUFtQyxTQUFTLHVCQUF1QixjQUFjLGtEQUFrRCxpQ0FBaUMsaUNBQWlDLDhCQUE4Qix5REFBeUQsT0FBTywyQkFBMkIsMkJBQTJCLCtDQUErQyxTQUFTLGdDQUFnQyx5RUFBeUUscUNBQXFDLHFDQUFxQyw2UkFBNlIsd0NBQXdDLHdGQUF3RixlQUFlLGtRQUFrUSwyQkFBMkIsVUFBVSxnQkFBZ0IsOEdBQThHLDRCQUE0Qiw0QkFBNEIscURBQXFELHNCQUFzQixxQkFBcUIsZ0JBQWdCLG9EQUFvRCxxQkFBcUIscUJBQXFCLGNBQWMseUJBQXlCLDJDQUEyQyx3QkFBd0Isa0NBQWtDLE9BQU8sZUFBZSxvRUFBb0UsZ0RBQWdELHVCQUF1Qix3REFBd0QsdUZBQXVGLHFEQUFxRCxrREFBa0QsNENBQTRDLHNJQUFzSSxpREFBaUQsK0ZBQStGLDBCQUEwQix5TUFBeU0sMkJBQTJCLFNBQVMsZUFBZSxtR0FBbUcsY0FBYyx5RUFBeUUsK0JBQStCLGdEQUFnRCxtRUFBbUUscUNBQXFDLElBQUksa0ZBQWtGLGNBQWMsdUNBQXVDLDhCQUE4QiwyQkFBMkIsMkJBQTJCLDRCQUE0QixzQ0FBc0MsT0FBTyxTQUFTLElBQUksaUJBQWlCLDJEQUEyRCxpQ0FBaUMsMkNBQTJDLGlEQUFpRCx5UkFBeVIsMEJBQTBCLGdCQUFnQix1Q0FBdUMscUNBQXFDLG1CQUFtQixxREFBcUQsd0JBQXdCLGNBQWMsd0JBQXdCLDRGQUE0Rix5Q0FBeUMsUUFBUSxPQUFPLDhDQUE4QywrQ0FBK0MsNkJBQTZCLDREQUE0RCxjQUFjLDJEQUEyRCw2REFBNkQsY0FBYyw2REFBNkQsT0FBTywrREFBK0Qsa0VBQWtFLGtDQUFrQyx5Q0FBeUMsUUFBUSxPQUFPLDRCQUE0QixvRkFBb0YsV0FBVyxXQUFXLDhGQUE4RiwrQkFBK0IsMkdBQTJHLHNDQUFzQyxxQ0FBcUMsNE5BQTROLCtCQUErQix5Q0FBeUMsUUFBUSxPQUFPLDRCQUE0QixnR0FBZ0csZ0NBQWdDLHlDQUF5QyxRQUFRLE9BQU8sNEJBQTRCLHNCQUFzQixzQkFBc0IsMEJBQTBCLGVBQWUsb0JBQW9CLGNBQWMsdUNBQXVDLG1EQUFtRCx5QkFBeUIsZ0RBQWdELGtEQUFrRDtBQUNuMVIsbURBQW1ELE1BQU0sZ0NBQWdDLFlBQVksb0JBQW9CO0FBQ3pILGdDQUFnQyxxQkFBcUIsNkJBQTZCLHFDQUFxQyx1QkFBdUIsb0JBQW9CLHlEQUF5RCxxQkFBcUIsMERBQTBELGdCQUFnQjtBQUMxVCxRQUFRLCtCQUFtQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsV0FBVztBQUNuRTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxpQ0FBaUMsY0FBYyw0TUFBNE0sYUFBYSxhQUFhLGdHQUFnRyxpQkFBaUIsK0NBQStDLGtIQUFrSCwyQkFBMkIscUNBQXFDLDBEQUEwRCxXQUFXLE1BQU0sU0FBUyxTQUFTLFlBQVksb0NBQW9DLHNCQUFzQiw0QkFBNEIseUhBQXlILHlCQUF5QixrQ0FBa0MsUUFBUSw2QkFBNkIsTUFBTSxTQUFTLHVDQUF1QyxZQUFZLFNBQVMsNkJBQTZCLGVBQWUsMEZBQTBGLHdCQUF3QixnQ0FBZ0MseUNBQXlDLFlBQVksMkJBQTJCLGNBQWMsR0FBRywwREFBMEQseUNBQXlDLHVGQUF1RixvQ0FBb0MsbURBQW1ELDRCQUE0Qiw0QkFBNEIsSUFBSSxLQUFLLCtCQUErQiw4QkFBOEIsOEJBQThCLDBCQUEwQiw0QkFBNEIsc0dBQXNHLDBCQUEwQixpQkFBaUIsMkJBQTJCLHFDQUFxQyxvQkFBb0IsaUJBQWlCLGtDQUFrQyxLQUFLLFlBQVksT0FBTyxxQkFBcUIsOEJBQThCLHdDQUF3QywrQkFBK0IscUJBQXFCLEtBQUssaUhBQWlILEtBQUsscUNBQXFDLFdBQVcseUJBQXlCLDBEQUEwRCxlQUFlLDRCQUE0QixTQUFTLHdCQUF3Qiw4QkFBOEIsSUFBSSxvQkFBb0IsU0FBUyxtQ0FBbUMsU0FBUyx1QkFBdUIsY0FBYyxrREFBa0QsaUNBQWlDLGlDQUFpQyw4QkFBOEIseURBQXlELE9BQU8sMkJBQTJCLDJCQUEyQiwrQ0FBK0MsU0FBUyxnQ0FBZ0MseUVBQXlFLHFDQUFxQyxxQ0FBcUMsNlJBQTZSLHdDQUF3Qyx3RkFBd0YsZUFBZSxrUUFBa1EsMkJBQTJCLFVBQVUsZ0JBQWdCLDhHQUE4Ryw0QkFBNEIsNEJBQTRCLHFEQUFxRCxzQkFBc0IscUJBQXFCLGdCQUFnQixvREFBb0QscUJBQXFCLHFCQUFxQixjQUFjLHlCQUF5QiwyQ0FBMkMsd0JBQXdCLGtDQUFrQyxPQUFPLGVBQWUsb0VBQW9FLGdEQUFnRCx1QkFBdUIsd0RBQXdELHVGQUF1RixxREFBcUQsa0RBQWtELDRDQUE0QyxzSUFBc0ksaURBQWlELCtGQUErRiwwQkFBMEIseU1BQXlNLDJCQUEyQixTQUFTLGVBQWUsbUdBQW1HLGNBQWMseUVBQXlFLCtCQUErQixnREFBZ0QsbUVBQW1FLHFDQUFxQyxJQUFJLGtGQUFrRixjQUFjLHVDQUF1Qyw4QkFBOEIsMkJBQTJCLDJCQUEyQiw0QkFBNEIsc0NBQXNDLE9BQU8sU0FBUyxJQUFJLGlCQUFpQiwyREFBMkQsaUNBQWlDLDJDQUEyQyxpREFBaUQseVJBQXlSLDBCQUEwQixnQkFBZ0IsdUNBQXVDLHFDQUFxQyxtQkFBbUIscURBQXFELHdCQUF3QixjQUFjLHdCQUF3Qiw0RkFBNEYseUNBQXlDLFFBQVEsT0FBTyw4Q0FBOEMsK0NBQStDLDZCQUE2Qiw0REFBNEQsY0FBYywyREFBMkQsNkRBQTZELGNBQWMsNkRBQTZELE9BQU8sK0RBQStELGtFQUFrRSxrQ0FBa0MseUNBQXlDLFFBQVEsT0FBTyw0QkFBNEIsb0ZBQW9GLFdBQVcsV0FBVyw4RkFBOEYsK0JBQStCLDJHQUEyRyxzQ0FBc0MscUNBQXFDLDROQUE0TiwrQkFBK0IseUNBQXlDLFFBQVEsT0FBTyw0QkFBNEIsZ0dBQWdHLGdDQUFnQyx5Q0FBeUMsUUFBUSxPQUFPLDRCQUE0QixzQkFBc0Isc0JBQXNCLDBCQUEwQixlQUFlLG9CQUFvQixjQUFjLHVDQUF1QyxtREFBbUQseUJBQXlCLGdEQUFnRCxrREFBa0Q7QUFDbjFSLG1EQUFtRCxNQUFNLGdDQUFnQyxZQUFZLG9CQUFvQjtBQUN6SCxnQ0FBZ0MscUJBQXFCLDZCQUE2QixxQ0FBcUMsdUJBQXVCLG9CQUFvQix5REFBeUQscUJBQXFCLDBEQUEwRCxnQkFBZ0I7QUFDMVQsUUFBUSxnQ0FBbUI7QUFDM0IsY0FBYyxnQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckUsUUFBUSxnQ0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckUsUUFBUSxnQ0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxnR0FBZ0c7QUFDaEc7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQUEsRUFBRTtBQUNiLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFLHVCQUF1QixnQ0FBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFO0FBQ0EsZ0NBQW1CO0FBQ25CLGdCQUFnQixnQ0FBbUI7QUFDbkMsUUFBUSxnQ0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELGdHQUFnRztBQUNoRztBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFJO0FBQ1osMENBQTBDLGdDQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUs7QUFBQSxFQUFFO0FBQ2IsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EseUNBQXlDLDBCQUFtQixFQUFFLGdDQUFtQjs7QUFFakY7QUFDQTtBQUNBLGdDQUFtQixHQUFHLDBCQUFtQjs7QUFFekM7QUFDQSxnQ0FBbUIsR0FBRywwQkFBbUI7QUFDekMsMEJBQTBCO0FBQzFCLENBQUM7O0FBRUQsQ0FBQztBQUNELHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxvQ0FBb0MsMkJBQTJCLGtIQUFrSCxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMzVSwrQ0FBK0M7QUFDL0MsaURBQWlELGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUNwRywrQ0FBK0MsaUpBQWlKLGNBQWM7QUFDOU0sMkNBQTJDLGlEQUFpRDtBQUM1Riw0Q0FBNEMsMERBQTBELCtCQUErQixvQkFBb0IsbUNBQW1DLG9EQUFvRCx1RUFBdUU7O0FBRXZUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0NBQW1CO0FBQzVCLENBQUM7QUFDRCw2QkFBNkIsMkJBQTJCLDJHQUEyRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUM3VCx3Q0FBd0M7QUFDeEMsMENBQTBDLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUM3Rix3Q0FBd0MsbUlBQW1JLGNBQWM7QUFDekwsb0NBQW9DLDBDQUEwQztBQUM5RSxxQ0FBcUMsbURBQW1ELCtCQUErQixvQkFBb0IsbUNBQW1DLDZDQUE2Qyx1RUFBdUU7O0FBRWxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsYUFBYSxnQ0FBbUI7QUFDaEMsQ0FBQztBQUNELDhCQUE4QiwyQkFBMkIsNEdBQTRHLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9ULGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLDRDQUE0QywrRUFBK0UsVUFBVSx5R0FBeUcsY0FBYyxpQ0FBaUMsU0FBUyx3QkFBd0IsMEJBQTBCLFdBQVcsSUFBSSw2QkFBNkIscUJBQXFCLFVBQVUsWUFBWSxnS0FBZ0ssdUJBQXVCLFNBQVMsa0JBQWtCLGdCQUFnQixvQkFBb0Isa0JBQWtCLHVCQUF1QixxQkFBcUIsZ0JBQWdCLG9CQUFvQixNQUFNLDZDQUE2QyxVQUFVO0FBQ3AwQixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHlDQUF5QztBQUN6QywyQ0FBMkMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQzlGLHlDQUF5QyxxSUFBcUksY0FBYztBQUM1TCxxQ0FBcUMsMkNBQTJDO0FBQ2hGLHNDQUFzQyxvREFBb0QsK0JBQStCLG9CQUFvQixtQ0FBbUMsOENBQThDLHVFQUF1RTs7O0FBR3JTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLDJCQUEyQixpSEFBaUgsbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDelUsOENBQThDO0FBQzlDLGdEQUFnRCxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDbkcsOENBQThDLCtJQUErSSxjQUFjO0FBQzNNLDBDQUEwQyxnREFBZ0Q7QUFDMUYsMkNBQTJDLHlEQUF5RCwrQkFBK0Isb0JBQW9CLG1DQUFtQyxtREFBbUQsdUVBQXVFO0FBQ3BUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsQ0FBQztBQUNELDBCQUEwQiwyQkFBMkIsd0dBQXdHLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQ3ZULG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEMsaURBQWlELFNBQVMsOERBQThELFVBQVUsZ0NBQWdDO0FBQ2xLLHVDQUF1QywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQzdJLDJDQUEyQyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDamhCLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsdUNBQXVDLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUMxRixxQ0FBcUMsNkhBQTZILGNBQWM7QUFDaEwsaUNBQWlDLHVDQUF1QztBQUN4RSxrQ0FBa0MsZ0RBQWdELCtCQUErQixvQkFBb0IsbUNBQW1DLDBDQUEwQyx1RUFBdUU7O0FBRXpSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFFQUFxRSw2QkFBNkI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsQ0FBQztBQUNELDRCQUE0QiwyQkFBMkIsMEdBQTBHLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQzNULHVDQUF1QztBQUN2Qyx5Q0FBeUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQzVGLHVDQUF1QyxpSUFBaUksY0FBYztBQUN0TCxtQ0FBbUMseUNBQXlDO0FBQzVFLG9DQUFvQyxrREFBa0QsK0JBQStCLG9CQUFvQixtQ0FBbUMsNENBQTRDLHVFQUF1RTs7O0FBRy9SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELENBQUM7QUFDRCw2QkFBNkIsMkJBQTJCLDJHQUEyRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUM3VCx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLDJFQUEyRSwwREFBMEQ7QUFDekssd0NBQXdDO0FBQ3hDLDBDQUEwQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDN0Ysd0NBQXdDLG1JQUFtSSxjQUFjO0FBQ3pMLG9DQUFvQywwQ0FBMEM7QUFDOUUscUNBQXFDLG1EQUFtRCwrQkFBK0Isb0JBQW9CLG1DQUFtQyw2Q0FBNkMsdUVBQXVFOzs7Ozs7QUFNbFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNkJBQTZCLEtBQUs7QUFDcEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EseUNBQXlDLDBCQUFtQixFQUFFLGlDQUFtQjs7QUFFakY7QUFDQSxxQkFBcUIsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQzlELHVDQUF1QztBQUN2QyxzQkFBc0I7QUFDdEIsdUVBQXVFLGlDQUFtQjtBQUMxRixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUMsY0FBYyw0TUFBNE0sYUFBYSxhQUFhLGdHQUFnRyxpQkFBaUIsK0NBQStDLGtIQUFrSCwyQkFBMkIscUNBQXFDLDBEQUEwRCxXQUFXLE1BQU0sU0FBUyxTQUFTLFlBQVksb0NBQW9DLHNCQUFzQiw0QkFBNEIseUhBQXlILHlCQUF5QixrQ0FBa0MsUUFBUSw2QkFBNkIsTUFBTSxTQUFTLHVDQUF1QyxZQUFZLFNBQVMsNkJBQTZCLGVBQWUsMEZBQTBGLHdCQUF3QixnQ0FBZ0MseUNBQXlDLFlBQVksMkJBQTJCLGNBQWMsR0FBRywwREFBMEQseUNBQXlDLHVGQUF1RixvQ0FBb0MsbURBQW1ELDRCQUE0Qiw0QkFBNEIsSUFBSSxLQUFLLCtCQUErQiw4QkFBOEIsOEJBQThCLDBCQUEwQiw0QkFBNEIsc0dBQXNHLDBCQUEwQixpQkFBaUIsMkJBQTJCLHFDQUFxQyxvQkFBb0IsaUJBQWlCLGtDQUFrQyxLQUFLLFlBQVksT0FBTyxxQkFBcUIsOEJBQThCLHdDQUF3QywrQkFBK0IscUJBQXFCLEtBQUssaUhBQWlILEtBQUsscUNBQXFDLFdBQVcseUJBQXlCLDBEQUEwRCxlQUFlLDRCQUE0QixTQUFTLHdCQUF3Qiw4QkFBOEIsSUFBSSxvQkFBb0IsU0FBUyxtQ0FBbUMsU0FBUyx1QkFBdUIsY0FBYyxrREFBa0QsaUNBQWlDLGlDQUFpQyw4QkFBOEIseURBQXlELE9BQU8sMkJBQTJCLDJCQUEyQiwrQ0FBK0MsU0FBUyxnQ0FBZ0MseUVBQXlFLHFDQUFxQyxxQ0FBcUMsNlJBQTZSLHdDQUF3Qyx3RkFBd0YsZUFBZSxrUUFBa1EsMkJBQTJCLFVBQVUsZ0JBQWdCLDhHQUE4Ryw0QkFBNEIsNEJBQTRCLHFEQUFxRCxzQkFBc0IscUJBQXFCLGdCQUFnQixvREFBb0QscUJBQXFCLHFCQUFxQixjQUFjLHlCQUF5QiwyQ0FBMkMsd0JBQXdCLGtDQUFrQyxPQUFPLGVBQWUsb0VBQW9FLGdEQUFnRCx1QkFBdUIsd0RBQXdELHVGQUF1RixxREFBcUQsa0RBQWtELDRDQUE0QyxzSUFBc0ksaURBQWlELCtGQUErRiwwQkFBMEIseU1BQXlNLDJCQUEyQixTQUFTLGVBQWUsbUdBQW1HLGNBQWMseUVBQXlFLCtCQUErQixnREFBZ0QsbUVBQW1FLHFDQUFxQyxJQUFJLGtGQUFrRixjQUFjLHVDQUF1Qyw4QkFBOEIsMkJBQTJCLDJCQUEyQiw0QkFBNEIsc0NBQXNDLE9BQU8sU0FBUyxJQUFJLGlCQUFpQiwyREFBMkQsaUNBQWlDLDJDQUEyQyxpREFBaUQseVJBQXlSLDBCQUEwQixnQkFBZ0IsdUNBQXVDLHFDQUFxQyxtQkFBbUIscURBQXFELHdCQUF3QixjQUFjLHdCQUF3Qiw0RkFBNEYseUNBQXlDLFFBQVEsT0FBTyw4Q0FBOEMsK0NBQStDLDZCQUE2Qiw0REFBNEQsY0FBYywyREFBMkQsNkRBQTZELGNBQWMsNkRBQTZELE9BQU8sK0RBQStELGtFQUFrRSxrQ0FBa0MseUNBQXlDLFFBQVEsT0FBTyw0QkFBNEIsb0ZBQW9GLFdBQVcsV0FBVyw4RkFBOEYsK0JBQStCLDJHQUEyRyxzQ0FBc0MscUNBQXFDLDROQUE0TiwrQkFBK0IseUNBQXlDLFFBQVEsT0FBTyw0QkFBNEIsZ0dBQWdHLGdDQUFnQyx5Q0FBeUMsUUFBUSxPQUFPLDRCQUE0QixzQkFBc0Isc0JBQXNCLDBCQUEwQixlQUFlLG9CQUFvQixjQUFjLHVDQUF1QyxtREFBbUQseUJBQXlCLGdEQUFnRCxrREFBa0Q7QUFDbjFSLG1EQUFtRCxNQUFNLGdDQUFnQyxZQUFZLG9CQUFvQjtBQUN6SCxnQ0FBZ0MscUJBQXFCLDZCQUE2QixxQ0FBcUMsdUJBQXVCLG9CQUFvQix5REFBeUQscUJBQXFCLDBEQUEwRCxnQkFBZ0I7QUFDMVQsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLCtDQUErQztBQUMvQyw0Q0FBNEM7QUFDNUMsdUNBQXVDO0FBQ3ZDLDBDQUEwQztBQUMxQyxzQ0FBc0Msc0ZBQXNGOzs7QUFHNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxRQUFRLGlDQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxjQUFjLGlDQUFtQjtBQUNqQyxnQkFBZ0IsaUNBQW1CO0FBQ25DLG1CQUFtQixpQ0FBbUI7QUFDdEMsbUJBQW1CLGlDQUFtQjtBQUN0QyxrQkFBa0IsaUNBQW1CO0FBQ3JDLFlBQVksaUNBQW1CO0FBQy9CLGlCQUFpQixpQ0FBbUI7QUFDcEMsY0FBYyxpQ0FBbUI7QUFDakMsZUFBZSxpQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxjQUFjLGlDQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0EseUNBQXlDLDBCQUFtQixFQUFFLGlDQUFtQjs7QUFFakY7QUFDQSxpQ0FBbUIsR0FBRywwQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUFtQjtBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGlDQUFtQjs7QUFFckUsYUFBYSxpQ0FBbUI7QUFDaEMsUUFBUSxpQ0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxpQ0FBbUI7O0FBRXJFLFFBQVEsaUNBQW1CO0FBQzNCLGtCQUFrQixpQ0FBbUI7QUFDckMsYUFBYSxpQ0FBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGlDQUFtQjs7QUFFckUsUUFBUSxpQ0FBbUI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxpQkFBaUI7QUFDMUQsOEJBQThCLGtCQUFrQjs7QUFFaEQseUNBQXlDLGlCQUFpQjtBQUMxRCxzQ0FBc0MsNkJBQTZCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4QiwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjLHdEQUF3RDtBQUN0RSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MseUdBQXlHLEVBQUU7O0FBRTFKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUUsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxhQUFhLGlDQUFtQjtBQUNoQyxRQUFRLGlDQUFtQjtBQUMzQixVQUFVLGlDQUFtQjtBQUM3QixhQUFhLGlDQUFtQjtBQUNoQyxjQUFjLGlDQUFtQjtBQUNqQyxnQkFBZ0IsaUNBQW1CO0FBQ25DLGFBQWEsaUNBQW1CO0FBQ2hDLGlCQUFpQixpQ0FBbUI7QUFDcEMsdUJBQXVCLGlDQUFtQjtBQUMxQyxpQkFBaUIsaUNBQW1CO0FBQ3BDLHVCQUF1QixpQ0FBbUI7QUFDMUMsa0JBQWtCLGlDQUFtQjtBQUNyQyx1QkFBdUIsaUNBQW1CO0FBQzFDLHNCQUFzQixpQ0FBbUI7QUFDekMsaUJBQWlCLGlDQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBbUI7QUFDbEMsa0JBQWtCLGlDQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLFlBQVksaUNBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUyxVQUFVLFlBQVksR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxRQUFRLGlDQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUpBQXFKO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxRQUFRLGlDQUFtQjtBQUMzQixlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxpQ0FBbUI7O0FBRXJFLG1CQUFtQixpQ0FBbUI7QUFDdEM7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGlDQUFtQjs7QUFFckUsUUFBUSxpQ0FBbUI7QUFDM0IsY0FBYyxpQ0FBbUI7QUFDakMsY0FBYyxpQ0FBbUI7QUFDakMsWUFBWSxpQ0FBbUI7QUFDL0IsZ0JBQWdCLGlDQUFtQjtBQUNuQyxjQUFjLGlDQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGlDQUFtQjs7QUFFckUsUUFBUSxpQ0FBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsaUNBQW1COztBQUVyRSxRQUFRLGlDQUFtQjtBQUMzQix1QkFBdUIsaUNBQW1CO0FBQzFDLHFCQUFxQixpQ0FBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0EseUNBQXlDLDBCQUFtQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCLDBCQUFtQjtBQUNoRDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBLHlDQUF5QywwQkFBbUIsRUFBRSxpQ0FBbUI7O0FBRWpGO0FBQ0EsaUNBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGlDQUFtQjs7QUFFckU7O0FBRUEsUUFBUSxpQ0FBbUI7QUFDM0IsYUFBYSxpQ0FBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSx5Q0FBeUMsMEJBQW1CLEVBQUUsaUNBQW1COztBQUVqRjtBQUNBO0FBQ0EsaUNBQW1CLEdBQUcsMEJBQW1COztBQUV6QztBQUNBLGlDQUFtQixHQUFHLDBCQUFtQjtBQUN6QywwQkFBMEI7QUFDMUIsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxHQUFHLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxHQUFHLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQXdEO0FBQ3ZHO0FBQ0EsaUNBQWlDO0FBQ2pDLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBLElBQUk7QUFDSiw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLFNBQVMsRUFBRSxXQUFXO0FBQ3pEO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLFNBQVMsRUFBRSxXQUFXO0FBQ3pEO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLCtCQUErQixFQUFFLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QyxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQ0FBcUMsU0FBUyxXQUFXLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxZQUFZO0FBQ3BCLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixhQUFhLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixNQUFNLHVGQUF1RjtBQUM3RixNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLHFDQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFLDJDQUEyQztBQUMzQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUZBQXVGO0FBQzdGLE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0saURBQWlEO0FBQ3ZELE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMENBQTBDO0FBQzlGLHNEQUFzRCxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLDJFQUEyRTtBQUNqRixNQUFNLGlDQUFpQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekMsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3Qyx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUErQztBQUN2RDtBQUNBLHdCQUF3QjtBQUN4QixRQUFRO0FBQ1IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLEtBQUssRUFBRTtBQUFBLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxDQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFlBQVksS0FBSyxFQUFFO0FBQUEsRUFBRTtBQUNyQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxLQUFLLHVCQUF1QiwyQkFBMkIsd0JBQXdCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQUssRUFBRTtBQUFBLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsQ0FBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQUssRUFBRTtBQUFBLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLFlBQVksS0FBSyxFQUFFO0FBQUEsRUFBRTtBQUNyQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkRBQTZEO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixhQUFhLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixNQUFNLG1GQUFtRjtBQUN6RixNQUFNLDJCQUEyQjtBQUNqQyxNQUFNLDJCQUEyQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFLDJDQUEyQztBQUMzQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUZBQW1GO0FBQ3pGLE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sU0FBUztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMENBQTBDO0FBQzlGLHNEQUFzRCxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdDQUF3QztBQUM5QyxNQUFNLGtDQUFrQztBQUN4QyxNQUFNLGdCQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekMsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUErQztBQUN2RDtBQUNBLHdCQUF3QjtBQUN4QixRQUFRO0FBQ1IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLEtBQUssRUFBRTtBQUFBLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGNBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsQ0FBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZLEtBQUssRUFBRTtBQUFBLEVBQUU7QUFDckI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sS0FBSyx1QkFBdUIsMkJBQTJCLHdCQUF3QjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUU7QUFBQSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLENBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUU7QUFBQSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixZQUFZLEtBQUssRUFBRTtBQUFBLEVBQUU7QUFDckIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHLEdBQUcsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCLElBQUksS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQyxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUEyRCxJQUFJO0FBQ3BHO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQXNELElBQUksS0FBSztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsWUFBWSxFQUFFLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksS0FBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLCtEQUErRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0EsY0FBYyx1REFBdUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDViw2REFBNkQsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVCQUF1QixnQkFBZ0I7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBLEtBQUs7QUFDTCxZQUFZLE9BQU87QUFDbkIsc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUF1RDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOztBQUVkOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrQkFBK0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2Qjs7QUFFQTtBQUNBLGFBQWEsaUNBQW1CO0FBQ2hDLENBQUM7QUFDRCxzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNENBQTRDLCtFQUErRSxVQUFVLHlHQUF5RyxjQUFjLGlDQUFpQyxTQUFTLHdCQUF3QiwwQkFBMEIsV0FBVyxJQUFJLDZCQUE2QixxQkFBcUIsVUFBVSxZQUFZLGdLQUFnSyx1QkFBdUIsU0FBUyxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0IsdUJBQXVCLHFCQUFxQixnQkFBZ0Isb0JBQW9CLE1BQU0sNkNBQTZDLFVBQVU7QUFDcDBCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsK0NBQStDO0FBQy9DLDRDQUE0QztBQUM1Qyx1Q0FBdUM7QUFDdkMsMENBQTBDO0FBQzFDLHNDQUFzQyxzRkFBc0Y7Ozs7QUFJNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxpQ0FBbUI7O0FBRXJFLFFBQVEsaUNBQW1CO0FBQzNCLGVBQWUsaUNBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxpQ0FBbUI7O0FBRXJFLFFBQVEsaUNBQW1COztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGlDQUFtQjs7QUFFckUsa0JBQWtCLGlDQUFtQjtBQUNyQyxZQUFZLGlDQUFtQjtBQUMvQixlQUFlLGlDQUFtQjtBQUNsQyxRQUFRLGlDQUFtQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxpQ0FBbUI7O0FBRXJFLFFBQVEsaUNBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsaUNBQW1CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLGlDQUFtQix3QkFBd0IsaUNBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CLDJCQUEyQjtBQUN6RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QjtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUFtQixHQUFHLGlDQUFtQjtBQUN2RDtBQUNBLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7VUMxdm5CQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHdEQUEyQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL2Rpc3Qvcm9sbGJhci51bWQuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vdGVzdC9leGFtcGxlcy9hbmd1bGFyLnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJyb2xsYmFyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInJvbGxiYXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyAxOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGhydGltZVxuICpcbiAqIEBkZXNjcmlwdGlvbiBNZXRob2RzIGZvciBoYW5kbGluZyBPcGVuVGVsZW1ldHJ5IGhydGltZS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gYW4gT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyAtIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyXX0gQW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgc2Vjb25kc1xuICogICBhbmQgdGhlIHNlY29uZCBpcyBuYW5vc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gZnJvbU1pbGxpcyhtaWxsaXMpIHtcbiAgcmV0dXJuIFtNYXRoLnRydW5jKG1pbGxpcyAvIDEwMDApLCBNYXRoLnJvdW5kKG1pbGxpcyAlIDEwMDAgKiAxZTYpXTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIE9wZW5UZWxlbWV0cnkgaHJ0aW1lIHR1cGxlIGJhY2sgdG8gYSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBocnRpbWUgLSBUaGUgaHJ0aW1lIHR1cGxlIFtzZWNvbmRzLCBuYW5vc2Vjb25kc10uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiB0b01pbGxpcyhocnRpbWUpIHtcbiAgcmV0dXJuIGhydGltZVswXSAqIDFlMyArIE1hdGgucm91bmQoaHJ0aW1lWzFdIC8gMWU2KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIE9wZW5UZWxlbWV0cnkgaHJ0aW1lIHR1cGxlIGJhY2sgdG8gYSBkdXJhdGlvbiBpbiBuYW5vc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGhydGltZSAtIFRoZSBocnRpbWUgdHVwbGUgW3NlY29uZHMsIG5hbm9zZWNvbmRzXS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBkdXJhdGlvbiBpbiBuYW5vc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gdG9OYW5vcyhocnRpbWUpIHtcbiAgcmV0dXJuIGhydGltZVswXSAqIDFlOSArIGhydGltZVsxXTtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBPcGVuVGVsZW1ldHJ5IGhydGltZSB0dXBsZXMuXG4gKlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBhIC0gVGhlIGZpcnN0IGhydGltZSB0dXBsZSBbcywgbnNdLlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBiIC0gVGhlIHNlY29uZCBocnRpbWUgdHVwbGUgW3MsIG5zXS5cbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXJdfSBTdW1tZWQgaHJ0aW1lIHR1cGxlLCBub3JtYWxpemVkLlxuICpcbiAqL1xuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIFthWzBdICsgYlswXSArIE1hdGgudHJ1bmMoKGFbMV0gKyBiWzFdKSAvIDFlOSksIChhWzFdICsgYlsxXSkgJSAxZTldO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBoaWdoLXJlc29sdXRpb24gdGltZSBhcyBhbiBPcGVuVGVsZW1ldHJ5IGhydGltZSB0dXBsZS5cbiAqXG4gKiBVc2VzIHRoZSBQZXJmb3JtYW5jZSBBUEkgKHRpbWVPcmlnaW4gKyBub3coKSkuXG4gKlxuICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFRoZSBjdXJyZW50IGhydGltZSB0dXBsZSBbcywgbnNdLlxuICovXG5mdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBhZGQoZnJvbU1pbGxpcyhwZXJmb3JtYW5jZS50aW1lT3JpZ2luKSwgZnJvbU1pbGxpcyhwZXJmb3JtYW5jZS5ub3coKSkpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBPcGVuVGVsZW1ldHJ5IGhydGltZSB0dXBsZS5cbiAqXG4gKiBBbiBocnRpbWUgdHVwbGUgaXMgYW4gQXJyYXkgb2YgZXhhY3RseSB0d28gbnVtYmVyczpcbiAqICAgW3NlY29uZHMsIG5hbm9zZWNvbmRzXVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUg4oCTIGFueXRoaW5nIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBbbnVtYmVyLCBudW1iZXJdIGFycmF5IG9mIGxlbmd0aCAyXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzSHJUaW1lKFsgMSwgNTAwIF0pOyAgICAgICAgIC8vIHRydWVcbiAqIGlzSHJUaW1lKFsgMCwgMWU5IF0pOyAgICAgICAgIC8vIHRydWVcbiAqIGlzSHJUaW1lKFsgJzEnLCA1MDAgXSk7ICAgICAgIC8vIGZhbHNlXG4gKiBpc0hyVGltZSh7IDA6IDEsIDE6IDUwMCB9KTsgICAvLyBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0hyVGltZSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlWzFdID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBNZXRob2RzIGZvciBoYW5kbGluZyBocnRpbWUuIE9wZW5UZWxlbWV0cnkgdXNlcyB0aGUgW3NlY29uZHMsIG5hbm9zZWNvbmRzXVxuICogZm9ybWF0IGZvciBocnRpbWUgaW4gdGhlIGBSZWFkYWJsZVNwYW5gIGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IGhydGltZSBmcm9tICdAdHJhY2luZy9ocnRpbWUuanMnO1xuICpcbiAqIGhydGltZS5mcm9tTWlsbGlzKDEwMDApO1xuICogaHJ0aW1lLnRvTWlsbGlzKFswLCAxMDAwXSk7XG4gKiBocnRpbWUuYWRkKFswLCAwXSwgWzAsIDEwMDBdKTtcbiAqIGhydGltZS5ub3coKTtcbiAqIGhydGltZS5pc0hyVGltZShbMCwgMTAwMF0pO1xuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX18uQSA9ICh7XG4gIGZyb21NaWxsaXM6IGZyb21NaWxsaXMsXG4gIHRvTWlsbGlzOiB0b01pbGxpcyxcbiAgdG9OYW5vczogdG9OYW5vcyxcbiAgYWRkOiBhZGQsXG4gIG5vdzogbm93LFxuICBpc0hyVGltZTogaXNIclRpbWVcbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBlOyB9OyB2YXIgdCwgZSA9IHt9LCByID0gT2JqZWN0LnByb3RvdHlwZSwgbiA9IHIuaGFzT3duUHJvcGVydHksIG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKHQsIGUsIHIpIHsgdFtlXSA9IHIudmFsdWU7IH0sIGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBhID0gaS5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYyA9IGkuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB1ID0gaS50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7IHZhbHVlOiByLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCB0W2VdOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKHQpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHsgcmV0dXJuIHRbZV0gPSByOyB9OyB9IGZ1bmN0aW9uIHdyYXAodCwgZSwgciwgbikgeyB2YXIgaSA9IGUgJiYgZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBlIDogR2VuZXJhdG9yLCBhID0gT2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSksIGMgPSBuZXcgQ29udGV4dChuIHx8IFtdKTsgcmV0dXJuIG8oYSwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QodCwgciwgYykgfSksIGE7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2godCwgZSwgcikgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IHQuY2FsbChlLCByKSB9OyB9IGNhdGNoICh0KSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiB0IH07IH0gfSBlLndyYXAgPSB3cmFwOyB2YXIgaCA9IFwic3VzcGVuZGVkU3RhcnRcIiwgbCA9IFwic3VzcGVuZGVkWWllbGRcIiwgZiA9IFwiZXhlY3V0aW5nXCIsIHMgPSBcImNvbXBsZXRlZFwiLCB5ID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgcCA9IHt9OyBkZWZpbmUocCwgYSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBkID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCB2ID0gZCAmJiBkKGQodmFsdWVzKFtdKSkpOyB2ICYmIHYgIT09IHIgJiYgbi5jYWxsKHYsIGEpICYmIChwID0gdik7IHZhciBnID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocCk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyh0KSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IGRlZmluZSh0LCBlLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5faW52b2tlKGUsIHQpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcih0LCBlKSB7IGZ1bmN0aW9uIGludm9rZShyLCBvLCBpLCBhKSB7IHZhciBjID0gdHJ5Q2F0Y2godFtyXSwgdCwgbyk7IGlmIChcInRocm93XCIgIT09IGMudHlwZSkgeyB2YXIgdSA9IGMuYXJnLCBoID0gdS52YWx1ZTsgcmV0dXJuIGggJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKGgpICYmIG4uY2FsbChoLCBcIl9fYXdhaXRcIikgPyBlLnJlc29sdmUoaC5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh0KSB7IGludm9rZShcIm5leHRcIiwgdCwgaSwgYSk7IH0sIGZ1bmN0aW9uICh0KSB7IGludm9rZShcInRocm93XCIsIHQsIGksIGEpOyB9KSA6IGUucmVzb2x2ZShoKS50aGVuKGZ1bmN0aW9uICh0KSB7IHUudmFsdWUgPSB0LCBpKHUpOyB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgdCwgaSwgYSk7IH0pOyB9IGEoYy5hcmcpOyB9IHZhciByOyBvKHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0LCBuKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHsgaW52b2tlKHQsIG4sIGUsIHIpOyB9KTsgfSByZXR1cm4gciA9IHIgPyByLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChlLCByLCBuKSB7IHZhciBvID0gaDsgcmV0dXJuIGZ1bmN0aW9uIChpLCBhKSB7IGlmIChvID09PSBmKSB0aHJvdyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChvID09PSBzKSB7IGlmIChcInRocm93XCIgPT09IGkpIHRocm93IGE7IHJldHVybiB7IHZhbHVlOiB0LCBkb25lOiAhMCB9OyB9IGZvciAobi5tZXRob2QgPSBpLCBuLmFyZyA9IGE7OykgeyB2YXIgYyA9IG4uZGVsZWdhdGU7IGlmIChjKSB7IHZhciB1ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShjLCBuKTsgaWYgKHUpIHsgaWYgKHUgPT09IHkpIGNvbnRpbnVlOyByZXR1cm4gdTsgfSB9IGlmIChcIm5leHRcIiA9PT0gbi5tZXRob2QpIG4uc2VudCA9IG4uX3NlbnQgPSBuLmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IG4ubWV0aG9kKSB7IGlmIChvID09PSBoKSB0aHJvdyBvID0gcywgbi5hcmc7IG4uZGlzcGF0Y2hFeGNlcHRpb24obi5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gbi5tZXRob2QgJiYgbi5hYnJ1cHQoXCJyZXR1cm5cIiwgbi5hcmcpOyBvID0gZjsgdmFyIHAgPSB0cnlDYXRjaChlLCByLCBuKTsgaWYgKFwibm9ybWFsXCIgPT09IHAudHlwZSkgeyBpZiAobyA9IG4uZG9uZSA/IHMgOiBsLCBwLmFyZyA9PT0geSkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiBwLmFyZywgZG9uZTogbi5kb25lIH07IH0gXCJ0aHJvd1wiID09PSBwLnR5cGUgJiYgKG8gPSBzLCBuLm1ldGhvZCA9IFwidGhyb3dcIiwgbi5hcmcgPSBwLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpIHsgdmFyIG4gPSByLm1ldGhvZCwgbyA9IGUuaXRlcmF0b3Jbbl07IGlmIChvID09PSB0KSByZXR1cm4gci5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbiAmJiBlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChyLm1ldGhvZCA9IFwicmV0dXJuXCIsIHIuYXJnID0gdCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShlLCByKSwgXCJ0aHJvd1wiID09PSByLm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbiAmJiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbiArIFwiJyBtZXRob2RcIikpLCB5OyB2YXIgaSA9IHRyeUNhdGNoKG8sIGUuaXRlcmF0b3IsIHIuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gaS50eXBlKSByZXR1cm4gci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gaS5hcmcsIHIuZGVsZWdhdGUgPSBudWxsLCB5OyB2YXIgYSA9IGkuYXJnOyByZXR1cm4gYSA/IGEuZG9uZSA/IChyW2UucmVzdWx0TmFtZV0gPSBhLnZhbHVlLCByLm5leHQgPSBlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IHIubWV0aG9kICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCByLmRlbGVnYXRlID0gbnVsbCwgeSkgOiBhIDogKHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgci5kZWxlZ2F0ZSA9IG51bGwsIHkpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeSh0KSB7IHZhciBlID0geyB0cnlMb2M6IHRbMF0gfTsgMSBpbiB0ICYmIChlLmNhdGNoTG9jID0gdFsxXSksIDIgaW4gdCAmJiAoZS5maW5hbGx5TG9jID0gdFsyXSwgZS5hZnRlckxvYyA9IHRbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlKTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KHQpIHsgdmFyIGUgPSB0LmNvbXBsZXRpb24gfHwge307IGUudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSBlLmFyZywgdC5jb21wbGV0aW9uID0gZTsgfSBmdW5jdGlvbiBDb250ZXh0KHQpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhlKSB7IGlmIChlIHx8IFwiXCIgPT09IGUpIHsgdmFyIHIgPSBlW2FdOyBpZiAocikgcmV0dXJuIHIuY2FsbChlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTsgaWYgKCFpc05hTihlLmxlbmd0aCkpIHsgdmFyIG8gPSAtMSwgaSA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK28gPCBlLmxlbmd0aDspIGlmIChuLmNhbGwoZSwgbykpIHJldHVybiBuZXh0LnZhbHVlID0gZVtvXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBpLm5leHQgPSBpOyB9IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihfdHlwZW9mKGUpICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpOyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgbyhnLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBvKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgJiYgdC5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhZSAmJiAoZSA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpKTsgfSwgZS5tYXJrID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZih0LCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAodC5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKHQsIHUsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZyksIHQ7IH0sIGUuYXdyYXAgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4geyBfX2F3YWl0OiB0IH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGUuYXN5bmMgPSBmdW5jdGlvbiAodCwgciwgbiwgbywgaSkgeyB2b2lkIDAgPT09IGkgJiYgKGkgPSBQcm9taXNlKTsgdmFyIGEgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKHQsIHIsIG4sIG8pLCBpKTsgcmV0dXJuIGUuaXNHZW5lcmF0b3JGdW5jdGlvbihyKSA/IGEgOiBhLm5leHQoKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmRvbmUgPyB0LnZhbHVlIDogYS5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoZyksIGRlZmluZShnLCB1LCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKGcsIGEsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoZywgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZS5rZXlzID0gZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBPYmplY3QodCksIHIgPSBbXTsgZm9yICh2YXIgbiBpbiBlKSByLnB1c2gobik7IHJldHVybiByLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IHIubGVuZ3RoOykgeyB2YXIgdCA9IHIucG9wKCk7IGlmICh0IGluIGUpIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBlLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoZSkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB0LCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIWUpIGZvciAodmFyIHIgaW4gdGhpcykgXCJ0XCIgPT09IHIuY2hhckF0KDApICYmIG4uY2FsbCh0aGlzLCByKSAmJiAhaXNOYU4oK3Iuc2xpY2UoMSkpICYmICh0aGlzW3JdID0gdCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgdCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSB0LnR5cGUpIHRocm93IHQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZSkgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBlOyB2YXIgciA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShuLCBvKSB7IHJldHVybiBhLnR5cGUgPSBcInRocm93XCIsIGEuYXJnID0gZSwgci5uZXh0ID0gbiwgbyAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgISFvOyB9IGZvciAodmFyIG8gPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgbyA+PSAwOyAtLW8pIHsgdmFyIGkgPSB0aGlzLnRyeUVudHJpZXNbb10sIGEgPSBpLmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gaS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChpLnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGMgPSBuLmNhbGwoaSwgXCJjYXRjaExvY1wiKSwgdSA9IG4uY2FsbChpLCBcImZpbmFsbHlMb2NcIik7IGlmIChjICYmIHUpIHsgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoYykgeyBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghdSkgdGhyb3cgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShpLmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0LCBlKSB7IGZvciAodmFyIHIgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpIHsgdmFyIG8gPSB0aGlzLnRyeUVudHJpZXNbcl07IGlmIChvLnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgbi5jYWxsKG8sIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBvLmZpbmFsbHlMb2MpIHsgdmFyIGkgPSBvOyBicmVhazsgfSB9IGkgJiYgKFwiYnJlYWtcIiA9PT0gdCB8fCBcImNvbnRpbnVlXCIgPT09IHQpICYmIGkudHJ5TG9jIDw9IGUgJiYgZSA8PSBpLmZpbmFsbHlMb2MgJiYgKGkgPSBudWxsKTsgdmFyIGEgPSBpID8gaS5jb21wbGV0aW9uIDoge307IHJldHVybiBhLnR5cGUgPSB0LCBhLmFyZyA9IGUsIGkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gaS5maW5hbGx5TG9jLCB5KSA6IHRoaXMuY29tcGxldGUoYSk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh0LCBlKSB7IGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHQudHlwZSA/IHRoaXMubmV4dCA9IHQuYXJnIDogXCJyZXR1cm5cIiA9PT0gdC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gdC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSB0LnR5cGUgJiYgZSAmJiAodGhpcy5uZXh0ID0gZSksIHk7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHQpIHsgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkgeyB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTsgaWYgKHIuZmluYWxseUxvYyA9PT0gdCkgcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLCByLmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShyKSwgeTsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0KSB7IGZvciAodmFyIGUgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpIHsgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07IGlmIChyLnRyeUxvYyA9PT0gdCkgeyB2YXIgbiA9IHIuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gbi50eXBlKSB7IHZhciBvID0gbi5hcmc7IHJlc2V0VHJ5RW50cnkocik7IH0gcmV0dXJuIG87IH0gfSB0aHJvdyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChlLCByLCBuKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGUpLCByZXN1bHROYW1lOiByLCBuZXh0TG9jOiBuIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB0KSwgeTsgfSB9LCBlOyB9XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAobiwgdCwgZSwgciwgbywgYSwgYykgeyB0cnkgeyB2YXIgaSA9IG5bYV0oYyksIHUgPSBpLnZhbHVlOyB9IGNhdGNoIChuKSB7IHJldHVybiB2b2lkIGUobik7IH0gaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pOyB9XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcywgZSA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7IHZhciBhID0gbi5hcHBseSh0LCBlKTsgZnVuY3Rpb24gX25leHQobikgeyBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIG4pOyB9IGZ1bmN0aW9uIF90aHJvdyhuKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIG4pOyB9IF9uZXh0KHZvaWQgMCk7IH0pOyB9OyB9XG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcblxuLypcbiAqIFF1ZXVlIC0gYW4gb2JqZWN0IHdoaWNoIGhhbmRsZXMgd2hpY2ggaGFuZGxlcyBhIHF1ZXVlIG9mIGl0ZW1zIHRvIGJlIHNlbnQgdG8gUm9sbGJhci5cbiAqICAgVGhpcyBvYmplY3QgaGFuZGxlcyByYXRlIGxpbWl0aW5nIHZpYSBhIHBhc3NlZCBpbiByYXRlIGxpbWl0ZXIsIHJldHJpZXMgYmFzZWQgb24gY29ubmVjdGlvblxuICogICBlcnJvcnMsIGFuZCBmaWx0ZXJpbmcgb2YgaXRlbXMgYmFzZWQgb24gYSBzZXQgb2YgY29uZmlndXJhYmxlIHByZWRpY2F0ZXMuIFRoZSBjb21tdW5pY2F0aW9uIHRvXG4gKiAgIHRoZSBiYWNrZW5kIGlzIHBlcmZvcm1lZCB2aWEgYSBnaXZlbiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByYXRlTGltaXRlciAtIEFuIG9iamVjdCB3aGljaCBjb25mb3JtcyB0byB0aGUgaW50ZXJmYWNlXG4gKiAgICByYXRlTGltaXRlci5zaG91bGRTZW5kKGl0ZW0pIC0+IGJvb2xcbiAqIEBwYXJhbSBhcGkgLSBBbiBvYmplY3Qgd2hpY2ggY29uZm9ybXMgdG8gdGhlIGludGVyZmFjZVxuICogICAgYXBpLnBvc3RJdGVtKHBheWxvYWQsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpKVxuICogQHBhcmFtIGxvZ2dlciAtIEFuIG9iamVjdCB1c2VkIHRvIGxvZyB2ZXJib3NlIG1lc3NhZ2VzIGlmIGRlc2lyZWRcbiAqIEBwYXJhbSBvcHRpb25zIC0gc2VlIFF1ZXVlLnByb3RvdHlwZS5jb25maWd1cmVcbiAqIEBwYXJhbSByZXBsYXlNYXAgLSBPcHRpb25hbCBSZXBsYXlNYXAgZm9yIGNvb3JkaW5hdGluZyBzZXNzaW9uIHJlcGxheSB3aXRoIGVycm9yIG9jY3VycmVuY2VzXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKHJhdGVMaW1pdGVyLCBhcGksIGxvZ2dlciwgb3B0aW9ucywgcmVwbGF5TWFwKSB7XG4gIHRoaXMucmF0ZUxpbWl0ZXIgPSByYXRlTGltaXRlcjtcbiAgdGhpcy5hcGkgPSBhcGk7XG4gIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnJlcGxheU1hcCA9IHJlcGxheU1hcDtcbiAgdGhpcy5wcmVkaWNhdGVzID0gW107XG4gIHRoaXMucGVuZGluZ0l0ZW1zID0gW107XG4gIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gW107XG4gIHRoaXMucmV0cnlRdWV1ZSA9IFtdO1xuICB0aGlzLnJldHJ5SGFuZGxlID0gbnVsbDtcbiAgdGhpcy53YWl0Q2FsbGJhY2sgPSBudWxsO1xuICB0aGlzLndhaXRJbnRlcnZhbElEID0gbnVsbDtcbn1cblxuLypcbiAqIGNvbmZpZ3VyZSAtIHVwZGF0ZXMgdGhlIG9wdGlvbnMgdGhpcyBxdWV1ZSB1c2VzXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuUXVldWUucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHRoaXMuYXBpICYmIHRoaXMuYXBpLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob2xkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIGFkZFByZWRpY2F0ZSAtIGFkZHMgYSBwcmVkaWNhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBwcmVkaWNhdGVzIGZvciB0aGlzIHF1ZXVlXG4gKlxuICogQHBhcmFtIHByZWRpY2F0ZSAtIGZ1bmN0aW9uKGl0ZW0sIG9wdGlvbnMpIC0+IChib29sfHtlcnI6IEVycm9yfSlcbiAqICBSZXR1cm5pbmcgdHJ1ZSBtZWFucyB0aGF0IHRoaXMgcHJlZGljYXRlIHBhc3NlcyBhbmQgdGhlIGl0ZW0gaXMgb2theSB0byBnbyBvbiB0aGUgcXVldWVcbiAqICBSZXR1cm5pbmcgZmFsc2UgbWVhbnMgZG8gbm90IGFkZCB0aGUgaXRlbSB0byB0aGUgcXVldWUsIGJ1dCBpdCBpcyBub3QgYW4gZXJyb3JcbiAqICBSZXR1cm5pbmcge2VycjogRXJyb3J9IG1lYW5zIGRvIG5vdCBhZGQgdGhlIGl0ZW0gdG8gdGhlIHF1ZXVlLCBhbmQgdGhlIGdpdmVuIGVycm9yIGV4cGxhaW5zIHdoeVxuICogIFJldHVybmluZyB7ZXJyOiB1bmRlZmluZWR9IGlzIGVxdWl2YWxlbnQgdG8gcmV0dXJuaW5nIHRydWUgYnV0IGRvbid0IGRvIHRoYXRcbiAqL1xuUXVldWUucHJvdG90eXBlLmFkZFByZWRpY2F0ZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgaWYgKF8uaXNGdW5jdGlvbihwcmVkaWNhdGUpKSB7XG4gICAgdGhpcy5wcmVkaWNhdGVzLnB1c2gocHJlZGljYXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5RdWV1ZS5wcm90b3R5cGUuYWRkUGVuZGluZ0l0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLnBlbmRpbmdJdGVtcy5wdXNoKGl0ZW0pO1xufTtcblF1ZXVlLnByb3RvdHlwZS5yZW1vdmVQZW5kaW5nSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZHggPSB0aGlzLnBlbmRpbmdJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zLnNwbGljZShpZHgsIDEpO1xuICB9XG59O1xuXG4vKlxuICogYWRkSXRlbSAtIFNlbmQgYW4gaXRlbSB0byB0aGUgUm9sbGJhciBBUEkgaWYgYWxsIG9mIHRoZSBwcmVkaWNhdGVzIGFyZSBzYXRpc2ZpZWRcbiAqXG4gKiBAcGFyYW0gaXRlbSAtIFRoZSBwYXlsb2FkIHRvIHNlbmQgdG8gdGhlIGJhY2tlbmRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVycm9yLCByZXBzb25zZSkgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJXG4gKiAgaW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzLCBvdGhlcndpc2UgcmVzcG9uc2Ugd2lsbCBiZSBudWxsIGFuZCBlcnJvciB3aWxsIGhhdmUgYSB2YWx1ZS4gSWYgYm90aFxuICogIGVycm9yIGFuZCByZXNwb25zZSBhcmUgbnVsbCB0aGVuIHRoZSBpdGVtIHdhcyBzdG9wcGVkIGJ5IGEgcHJlZGljYXRlIHdoaWNoIGRpZCBub3QgY29uc2lkZXIgdGhpc1xuICogIHRvIGJlIGFuIGVycm9yIGNvbmRpdGlvbiwgYnV0IG5vbmV0aGVsZXNzIGRpZCBub3Qgc2VuZCB0aGUgaXRlbSB0byB0aGUgQVBJLlxuICogIEBwYXJhbSBvcmlnaW5hbEVycm9yIC0gVGhlIG9yaWdpbmFsIGVycm9yIGJlZm9yZSBhbnkgdHJhbnNmb3JtYXRpb25zIHRoYXQgaXMgdG8gYmUgbG9nZ2VkIGlmIGFueVxuICovXG5RdWV1ZS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaywgb3JpZ2luYWxFcnJvciwgb3JpZ2luYWxJdGVtKSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbiAgdmFyIHByZWRpY2F0ZVJlc3VsdCA9IHRoaXMuX2FwcGx5UHJlZGljYXRlcyhpdGVtKTtcbiAgaWYgKHByZWRpY2F0ZVJlc3VsdC5zdG9wKSB7XG4gICAgdGhpcy5yZW1vdmVQZW5kaW5nSXRlbShvcmlnaW5hbEl0ZW0pO1xuICAgIGNhbGxiYWNrKHByZWRpY2F0ZVJlc3VsdC5lcnIpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9tYXliZUxvZyhpdGVtLCBvcmlnaW5hbEVycm9yKTtcbiAgdGhpcy5yZW1vdmVQZW5kaW5nSXRlbShvcmlnaW5hbEl0ZW0pO1xuICBpZiAoIXRoaXMub3B0aW9ucy50cmFuc21pdCkge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVHJhbnNtaXQgZGlzYWJsZWQnKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLnJlcGxheU1hcCAmJiBpdGVtLmJvZHkpIHtcbiAgICB2YXIgcmVwbGF5SWQgPSB0aGlzLnJlcGxheU1hcC5hZGQoaXRlbS51dWlkKTtcbiAgICBpdGVtLnJlcGxheUlkID0gcmVwbGF5SWQ7XG4gIH1cbiAgdGhpcy5wZW5kaW5nUmVxdWVzdHMucHVzaChpdGVtKTtcbiAgdHJ5IHtcbiAgICB0aGlzLl9tYWtlQXBpUmVxdWVzdChpdGVtLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICB0aGlzLl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QoaXRlbSk7XG4gICAgICBpZiAoIWVyciAmJiByZXNwICYmIGl0ZW0ucmVwbGF5SWQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlUmVwbGF5UmVzcG9uc2UoaXRlbS5yZXBsYXlJZCwgcmVzcCk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIsIHJlc3ApO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QoaXRlbSk7XG4gICAgY2FsbGJhY2soZSk7XG4gIH1cbn07XG5cbi8qXG4gKiB3YWl0IC0gU3RvcCBhbnkgZnVydGhlciBlcnJvcnMgZnJvbSBiZWluZyBhZGRlZCB0byB0aGUgcXVldWUsIGFuZCBnZXQgY2FsbGVkIGJhY2sgd2hlbiBhbGwgaXRlbXNcbiAqICAgY3VycmVudGx5IHByb2Nlc3NpbmcgaGF2ZSBmaW5pc2hlZCBzZW5kaW5nIHRvIHRoZSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKCkgY2FsbGVkIHdoZW4gYWxsIHBlbmRpbmcgaXRlbXMgaGF2ZSBiZWVuIHNlbnRcbiAqL1xuUXVldWUucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKCFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMud2FpdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIGlmICh0aGlzLl9tYXliZUNhbGxXYWl0KCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRoaXMud2FpdEludGVydmFsSUQpIHtcbiAgICB0aGlzLndhaXRJbnRlcnZhbElEID0gY2xlYXJJbnRlcnZhbCh0aGlzLndhaXRJbnRlcnZhbElEKTtcbiAgfVxuICB0aGlzLndhaXRJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX21heWJlQ2FsbFdhaXQoKTtcbiAgfS5iaW5kKHRoaXMpLCA1MDApO1xufTtcblxuLyogX2FwcGx5UHJlZGljYXRlcyAtIFNlcXVlbnRpYWxseSBhcHBsaWVzIHRoZSBwcmVkaWNhdGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBxdWV1ZSB0byB0aGVcbiAqICAgZ2l2ZW4gaXRlbSB3aXRoIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gQW4gaXRlbSBpbiB0aGUgcXVldWVcbiAqIEByZXR1cm5zIHtzdG9wOiBib29sLCBlcnI6IChFcnJvcnxudWxsKX0gLSBzdG9wIGJlaW5nIHRydWUgbWVhbnMgZG8gbm90IGFkZCBpdGVtIHRvIHRoZSBxdWV1ZSxcbiAqICAgdGhlIGVycm9yIHZhbHVlIHNob3VsZCBiZSBwYXNzZWQgdXAgdG8gYSBjYWxsYmFrIGlmIHdlIGFyZSBzdG9wcGluZy5cbiAqL1xuUXVldWUucHJvdG90eXBlLl9hcHBseVByZWRpY2F0ZXMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgcCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnByZWRpY2F0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwID0gdGhpcy5wcmVkaWNhdGVzW2ldKGl0ZW0sIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKCFwIHx8IHAuZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IHRydWUsXG4gICAgICAgIGVycjogcC5lcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3RvcDogZmFsc2UsXG4gICAgZXJyOiBudWxsXG4gIH07XG59O1xuXG4vKlxuICogX21ha2VBcGlSZXF1ZXN0IC0gU2VuZCBhbiBpdGVtIHRvIFJvbGxiYXIsIGNhbGxiYWNrIHdoZW4gZG9uZSwgaWYgdGhlcmUgaXMgYW4gZXJyb3IgbWFrZSBhblxuICogICBlZmZvcnQgdG8gcmV0cnkgaWYgd2UgYXJlIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBhbiBpdGVtIHJlYWR5IHRvIHNlbmQgdG8gdGhlIGJhY2tlbmRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fbWFrZUFwaVJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgdmFyIHJhdGVMaW1pdFJlc3BvbnNlID0gdGhpcy5yYXRlTGltaXRlci5zaG91bGRTZW5kKGl0ZW0pO1xuICBpZiAocmF0ZUxpbWl0UmVzcG9uc2Uuc2hvdWxkU2VuZCkge1xuICAgIHRoaXMuYXBpLnBvc3RJdGVtKGl0ZW0sIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5fbWF5YmVSZXRyeShlcnIsIGl0ZW0sIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSBlbHNlIGlmIChyYXRlTGltaXRSZXNwb25zZS5lcnJvcikge1xuICAgIGNhbGxiYWNrKHJhdGVMaW1pdFJlc3BvbnNlLmVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwaS5wb3N0SXRlbShyYXRlTGltaXRSZXNwb25zZS5wYXlsb2FkLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8vIFRoZXNlIGFyZSBlcnJvcnMgYmFzaWNhbGx5IG1lYW4gdGhlcmUgaXMgbm8gaW50ZXJuZXQgY29ubmVjdGlvblxudmFyIFJFVFJJQUJMRV9FUlJPUlMgPSBbJ0VDT05OUkVTRVQnLCAnRU5PVEZPVU5EJywgJ0VTT0NLRVRUSU1FRE9VVCcsICdFVElNRURPVVQnLCAnRUNPTk5SRUZVU0VEJywgJ0VIT1NUVU5SRUFDSCcsICdFUElQRScsICdFQUlfQUdBSU4nXTtcblxuLypcbiAqIF9tYXliZVJldHJ5IC0gR2l2ZW4gdGhlIGVycm9yIHJldHVybmVkIGJ5IHRoZSBBUEksIGRlY2lkZSBpZiB3ZSBzaG91bGQgcmV0cnkgb3IganVzdCBjYWxsYmFja1xuICogICB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyIC0gYW4gZXJyb3IgcmV0dXJuZWQgYnkgdGhlIEFQSSB0cmFuc3BvcnRcbiAqIEBwYXJhbSBpdGVtIC0gdGhlIGl0ZW0gdGhhdCB3YXMgdHJ5aW5nIHRvIGJlIHNlbnQgd2hlbiB0aGlzIGVycm9yIG9jY3VyZWRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fbWF5YmVSZXRyeSA9IGZ1bmN0aW9uIChlcnIsIGl0ZW0sIGNhbGxiYWNrKSB7XG4gIHZhciBzaG91bGRSZXRyeSA9IGZhbHNlO1xuICBpZiAodGhpcy5vcHRpb25zLnJldHJ5SW50ZXJ2YWwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gUkVUUklBQkxFX0VSUk9SUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGVyci5jb2RlID09PSBSRVRSSUFCTEVfRVJST1JTW2ldKSB7XG4gICAgICAgIHNob3VsZFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRSZXRyeSAmJiBfLmlzRmluaXRlTnVtYmVyKHRoaXMub3B0aW9ucy5tYXhSZXRyaWVzKSkge1xuICAgICAgaXRlbS5yZXRyaWVzID0gaXRlbS5yZXRyaWVzID8gaXRlbS5yZXRyaWVzICsgMSA6IDE7XG4gICAgICBpZiAoaXRlbS5yZXRyaWVzID4gdGhpcy5vcHRpb25zLm1heFJldHJpZXMpIHtcbiAgICAgICAgc2hvdWxkUmV0cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgdGhpcy5fcmV0cnlBcGlSZXF1ZXN0KGl0ZW0sIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG59O1xuXG4vKlxuICogX3JldHJ5QXBpUmVxdWVzdCAtIEFkZCBhbiBpdGVtIGFuZCBhIGNhbGxiYWNrIHRvIGEgcXVldWUgYW5kIHBvc3NpYmx5IHN0YXJ0IGEgdGltZXIgdG8gcHJvY2Vzc1xuICogICB0aGF0IHF1ZXVlIGJhc2VkIG9uIHRoZSByZXRyeUludGVydmFsIGluIHRoZSBvcHRpb25zIGZvciB0aGlzIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gYW4gaXRlbSB0aGF0IGZhaWxlZCB0byBzZW5kIGR1ZSB0byBhbiBlcnJvciB3ZSBkZWVtIHJldHJpYWJsZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gZnVuY3Rpb24oZXJyLCByZXNwb25zZSlcbiAqL1xuUXVldWUucHJvdG90eXBlLl9yZXRyeUFwaVJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgdGhpcy5yZXRyeVF1ZXVlLnB1c2goe1xuICAgIGl0ZW06IGl0ZW0sXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xuICBpZiAoIXRoaXMucmV0cnlIYW5kbGUpIHtcbiAgICB0aGlzLnJldHJ5SGFuZGxlID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMucmV0cnlRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldHJ5T2JqZWN0ID0gdGhpcy5yZXRyeVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX21ha2VBcGlSZXF1ZXN0KHJldHJ5T2JqZWN0Lml0ZW0sIHJldHJ5T2JqZWN0LmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyksIHRoaXMub3B0aW9ucy5yZXRyeUludGVydmFsKTtcbiAgfVxufTtcblxuLypcbiAqIF9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QgLSBSZW1vdmVzIHRoZSBpdGVtIGZyb20gdGhlIHBlbmRpbmcgcmVxdWVzdCBxdWV1ZSwgdGhpcyBxdWV1ZSBpcyB1c2VkIHRvXG4gKiAgIGVuYWJsZSB0byBmdW5jdGlvbmFsaXR5IG9mIHByb3ZpZGluZyBhIGNhbGxiYWNrIHRoYXQgY2xpZW50cyBjYW4gcGFzcyB0byBgd2FpdGAgdG8gYmUgbm90aWZpZWRcbiAqICAgd2hlbiB0aGUgcGVuZGluZyByZXF1ZXN0IHF1ZXVlIGhhcyBiZWVuIGVtcHRpZWQuIFRoaXMgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgQVBJIGZpbmlzaGVzXG4gKiAgIHByb2Nlc3NpbmcgdGhpcyBpdGVtLiBJZiBhIGB3YWl0YCBjYWxsYmFjayBpcyBjb25maWd1cmVkLCBpdCBpcyBjYWxsZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIHByZXZpb3VzbHkgYWRkZWQgdG8gdGhlIHBlbmRpbmcgcmVxdWVzdCBxdWV1ZVxuICovXG5RdWV1ZS5wcm90b3R5cGUuX2RlcXVldWVQZW5kaW5nUmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZHggPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX21heWJlQ2FsbFdhaXQoKTtcbiAgfVxufTtcblF1ZXVlLnByb3RvdHlwZS5fbWF5YmVMb2cgPSBmdW5jdGlvbiAoZGF0YSwgb3JpZ2luYWxFcnJvcikge1xuICBpZiAodGhpcy5sb2dnZXIgJiYgdGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcbiAgICB2YXIgbWVzc2FnZSA9IG9yaWdpbmFsRXJyb3I7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgXy5nZXQoZGF0YSwgJ2JvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UnKTtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBfLmdldChkYXRhLCAnYm9keS50cmFjZV9jaGFpbi4wLmV4Y2VwdGlvbi5tZXNzYWdlJyk7XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXNzYWdlID0gXy5nZXQoZGF0YSwgJ2JvZHkubWVzc2FnZS5ib2R5Jyk7XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn07XG5RdWV1ZS5wcm90b3R5cGUuX21heWJlQ2FsbFdhaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24odGhpcy53YWl0Q2FsbGJhY2spICYmIHRoaXMucGVuZGluZ0l0ZW1zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy53YWl0SW50ZXJ2YWxJRCkge1xuICAgICAgdGhpcy53YWl0SW50ZXJ2YWxJRCA9IGNsZWFySW50ZXJ2YWwodGhpcy53YWl0SW50ZXJ2YWxJRCk7XG4gICAgfVxuICAgIHRoaXMud2FpdENhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBBUEkgcmVzcG9uc2UgZm9yIGFuIGl0ZW0gd2l0aCBhIHJlcGxheSBJRC5cbiAqIEJhc2VkIG9uIHRoZSBzdWNjZXNzIG9yIGZhaWx1cmUgc3RhdHVzIG9mIHRoZSByZXNwb25zZSxcbiAqIGl0IGVpdGhlciBzZW5kcyBvciBkaXNjYXJkcyB0aGUgYXNzb2NpYXRlZCBzZXNzaW9uIHJlcGxheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBUaGUgSUQgb2YgdGhlIHJlcGxheSB0byBoYW5kbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIFRoZSBBUEkgcmVzcG9uc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHJlcGxheSB3YXMgc2VudCBzdWNjZXNzZnVsbHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UgaWYgcmVwbGF5IHdhcyBkaXNjYXJkZWQgb3IgYW4gZXJyb3Igb2NjdXJyZWRcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5faGFuZGxlUmVwbGF5UmVzcG9uc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlcGxheUlkLCByZXNwb25zZSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKHRoaXMucmVwbGF5TWFwKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1F1ZXVlLl9oYW5kbGVSZXBsYXlSZXNwb25zZTogUmVwbGF5TWFwIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGlmIChyZXBsYXlJZCkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS53YXJuKCdRdWV1ZS5faGFuZGxlUmVwbGF5UmVzcG9uc2U6IE5vIHJlcGxheUlkIHByb3ZpZGVkJyk7XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNjtcbiAgICAgICAgICBpZiAoIShyZXNwb25zZSAmJiByZXNwb25zZS5lcnIgPT09IDApKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxheU1hcC5zZW5kKHJlcGxheUlkKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICB0aGlzLnJlcGxheU1hcC5kaXNjYXJkKHJlcGxheUlkKTtcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDE4O1xuICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg2KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyByZXBsYXkgcmVzcG9uc2U6JywgX2NvbnRleHQudDApO1xuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzYsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGU7IH07IHZhciB0LCBlID0ge30sIHIgPSBPYmplY3QucHJvdG90eXBlLCBuID0gci5oYXNPd25Qcm9wZXJ0eSwgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAodCwgZSwgcikgeyB0W2VdID0gci52YWx1ZTsgfSwgaSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGEgPSBpLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBjID0gaS5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHUgPSBpLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUodCwgZSwgcikgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHsgdmFsdWU6IHIsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIHRbZV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAodCkgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUodCwgZSwgcikgeyByZXR1cm4gdFtlXSA9IHI7IH07IH0gZnVuY3Rpb24gd3JhcCh0LCBlLCByLCBuKSB7IHZhciBpID0gZSAmJiBlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IGUgOiBHZW5lcmF0b3IsIGEgPSBPYmplY3QuY3JlYXRlKGkucHJvdG90eXBlKSwgYyA9IG5ldyBDb250ZXh0KG4gfHwgW10pOyByZXR1cm4gbyhhLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZCh0LCByLCBjKSB9KSwgYTsgfSBmdW5jdGlvbiB0cnlDYXRjaCh0LCBlLCByKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogdC5jYWxsKGUsIHIpIH07IH0gY2F0Y2ggKHQpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IHQgfTsgfSB9IGUud3JhcCA9IHdyYXA7IHZhciBoID0gXCJzdXNwZW5kZWRTdGFydFwiLCBsID0gXCJzdXNwZW5kZWRZaWVsZFwiLCBmID0gXCJleGVjdXRpbmdcIiwgcyA9IFwiY29tcGxldGVkXCIsIHkgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBwID0ge307IGRlZmluZShwLCBhLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIHYgPSBkICYmIGQoZCh2YWx1ZXMoW10pKSk7IHYgJiYgdiAhPT0gciAmJiBuLmNhbGwodiwgYSkgJiYgKHAgPSB2KTsgdmFyIGcgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHQpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgZGVmaW5lKHQsIGUsIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLl9pbnZva2UoZSwgdCk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKHQsIGUpIHsgZnVuY3Rpb24gaW52b2tlKHIsIG8sIGksIGEpIHsgdmFyIGMgPSB0cnlDYXRjaCh0W3JdLCB0LCBvKTsgaWYgKFwidGhyb3dcIiAhPT0gYy50eXBlKSB7IHZhciB1ID0gYy5hcmcsIGggPSB1LnZhbHVlOyByZXR1cm4gaCAmJiBcIm9iamVjdFwiID09IF90eXBlb2YoaCkgJiYgbi5jYWxsKGgsIFwiX19hd2FpdFwiKSA/IGUucmVzb2x2ZShoLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHQpIHsgaW52b2tlKFwibmV4dFwiLCB0LCBpLCBhKTsgfSwgZnVuY3Rpb24gKHQpIHsgaW52b2tlKFwidGhyb3dcIiwgdCwgaSwgYSk7IH0pIDogZS5yZXNvbHZlKGgpLnRoZW4oZnVuY3Rpb24gKHQpIHsgdS52YWx1ZSA9IHQsIGkodSk7IH0sIGZ1bmN0aW9uICh0KSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCB0LCBpLCBhKTsgfSk7IH0gYShjLmFyZyk7IH0gdmFyIHI7IG8odGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIG4pIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgZShmdW5jdGlvbiAoZSwgcikgeyBpbnZva2UodCwgbiwgZSwgcik7IH0pOyB9IHJldHVybiByID0gciA/IHIudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGUsIHIsIG4pIHsgdmFyIG8gPSBoOyByZXR1cm4gZnVuY3Rpb24gKGksIGEpIHsgaWYgKG8gPT09IGYpIHRocm93IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKG8gPT09IHMpIHsgaWYgKFwidGhyb3dcIiA9PT0gaSkgdGhyb3cgYTsgcmV0dXJuIHsgdmFsdWU6IHQsIGRvbmU6ICEwIH07IH0gZm9yIChuLm1ldGhvZCA9IGksIG4uYXJnID0gYTs7KSB7IHZhciBjID0gbi5kZWxlZ2F0ZTsgaWYgKGMpIHsgdmFyIHUgPSBtYXliZUludm9rZURlbGVnYXRlKGMsIG4pOyBpZiAodSkgeyBpZiAodSA9PT0geSkgY29udGludWU7IHJldHVybiB1OyB9IH0gaWYgKFwibmV4dFwiID09PSBuLm1ldGhvZCkgbi5zZW50ID0gbi5fc2VudCA9IG4uYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gbi5tZXRob2QpIHsgaWYgKG8gPT09IGgpIHRocm93IG8gPSBzLCBuLmFyZzsgbi5kaXNwYXRjaEV4Y2VwdGlvbihuLmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBuLm1ldGhvZCAmJiBuLmFicnVwdChcInJldHVyblwiLCBuLmFyZyk7IG8gPSBmOyB2YXIgcCA9IHRyeUNhdGNoKGUsIHIsIG4pOyBpZiAoXCJub3JtYWxcIiA9PT0gcC50eXBlKSB7IGlmIChvID0gbi5kb25lID8gcyA6IGwsIHAuYXJnID09PSB5KSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHAuYXJnLCBkb25lOiBuLmRvbmUgfTsgfSBcInRocm93XCIgPT09IHAudHlwZSAmJiAobyA9IHMsIG4ubWV0aG9kID0gXCJ0aHJvd1wiLCBuLmFyZyA9IHAuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZSwgcikgeyB2YXIgbiA9IHIubWV0aG9kLCBvID0gZS5pdGVyYXRvcltuXTsgaWYgKG8gPT09IHQpIHJldHVybiByLmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBuICYmIGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKHIubWV0aG9kID0gXCJyZXR1cm5cIiwgci5hcmcgPSB0LCBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpLCBcInRocm93XCIgPT09IHIubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBuICYmIChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBuICsgXCInIG1ldGhvZFwiKSksIHk7IHZhciBpID0gdHJ5Q2F0Y2gobywgZS5pdGVyYXRvciwgci5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSBpLnR5cGUpIHJldHVybiByLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBpLmFyZywgci5kZWxlZ2F0ZSA9IG51bGwsIHk7IHZhciBhID0gaS5hcmc7IHJldHVybiBhID8gYS5kb25lID8gKHJbZS5yZXN1bHROYW1lXSA9IGEudmFsdWUsIHIubmV4dCA9IGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gci5tZXRob2QgJiYgKHIubWV0aG9kID0gXCJuZXh0XCIsIHIuYXJnID0gdCksIHIuZGVsZWdhdGUgPSBudWxsLCB5KSA6IGEgOiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCByLmRlbGVnYXRlID0gbnVsbCwgeSk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KHQpIHsgdmFyIGUgPSB7IHRyeUxvYzogdFswXSB9OyAxIGluIHQgJiYgKGUuY2F0Y2hMb2MgPSB0WzFdKSwgMiBpbiB0ICYmIChlLmZpbmFsbHlMb2MgPSB0WzJdLCBlLmFmdGVyTG9jID0gdFszXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGUpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkodCkgeyB2YXIgZSA9IHQuY29tcGxldGlvbiB8fCB7fTsgZS50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIGUuYXJnLCB0LmNvbXBsZXRpb24gPSBlOyB9IGZ1bmN0aW9uIENvbnRleHQodCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGUpIHsgaWYgKGUgfHwgXCJcIiA9PT0gZSkgeyB2YXIgciA9IGVbYV07IGlmIChyKSByZXR1cm4gci5jYWxsKGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLm5leHQpIHJldHVybiBlOyBpZiAoIWlzTmFOKGUubGVuZ3RoKSkgeyB2YXIgbyA9IC0xLCBpID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsrbyA8IGUubGVuZ3RoOykgaWYgKG4uY2FsbChlLCBvKSkgcmV0dXJuIG5leHQudmFsdWUgPSBlW29dLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB0LCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIGkubmV4dCA9IGk7IH0gfSB0aHJvdyBuZXcgVHlwZUVycm9yKF90eXBlb2YoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBvKGcsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIG8oR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB1LCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBlLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCAmJiB0LmNvbnN0cnVjdG9yOyByZXR1cm4gISFlICYmIChlID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSkpOyB9LCBlLm1hcmsgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHQsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6ICh0Ll9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUodCwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShnKSwgdDsgfSwgZS5hd3JhcCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB7IF9fYXdhaXQ6IHQgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBjLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZS5hc3luYyA9IGZ1bmN0aW9uICh0LCByLCBuLCBvLCBpKSB7IHZvaWQgMCA9PT0gaSAmJiAoaSA9IFByb21pc2UpOyB2YXIgYSA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAodCwgciwgbiwgbyksIGkpOyByZXR1cm4gZS5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpID8gYSA6IGEubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZG9uZSA/IHQudmFsdWUgOiBhLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhnKSwgZGVmaW5lKGcsIHUsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoZywgYSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShnLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBlLmtleXMgPSBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IE9iamVjdCh0KSwgciA9IFtdOyBmb3IgKHZhciBuIGluIGUpIHIucHVzaChuKTsgcmV0dXJuIHIucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgci5sZW5ndGg7KSB7IHZhciB0ID0gci5wb3AoKTsgaWYgKHQgaW4gZSkgcmV0dXJuIG5leHQudmFsdWUgPSB0LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGUudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChlKSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhZSkgZm9yICh2YXIgciBpbiB0aGlzKSBcInRcIiA9PT0gci5jaGFyQXQoMCkgJiYgbi5jYWxsKHRoaXMsIHIpICYmICFpc05hTigrci5zbGljZSgxKSkgJiYgKHRoaXNbcl0gPSB0KTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciB0ID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihlKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGU7IHZhciByID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKG4sIG8pIHsgcmV0dXJuIGEudHlwZSA9IFwidGhyb3dcIiwgYS5hcmcgPSBlLCByLm5leHQgPSBuLCBvICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCAhIW87IH0gZm9yICh2YXIgbyA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBvID49IDA7IC0tbykgeyB2YXIgaSA9IHRoaXMudHJ5RW50cmllc1tvXSwgYSA9IGkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBpLnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgYyA9IG4uY2FsbChpLCBcImNhdGNoTG9jXCIpLCB1ID0gbi5jYWxsKGksIFwiZmluYWxseUxvY1wiKTsgaWYgKGMgJiYgdSkgeyBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBpLmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoaS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChjKSB7IGlmICh0aGlzLnByZXYgPCBpLmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCF1KSB0aHJvdyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHQsIGUpIHsgZm9yICh2YXIgciA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyByID49IDA7IC0tcikgeyB2YXIgbyA9IHRoaXMudHJ5RW50cmllc1tyXTsgaWYgKG8udHJ5TG9jIDw9IHRoaXMucHJldiAmJiBuLmNhbGwobywgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IG8uZmluYWxseUxvYykgeyB2YXIgaSA9IG87IGJyZWFrOyB9IH0gaSAmJiAoXCJicmVha1wiID09PSB0IHx8IFwiY29udGludWVcIiA9PT0gdCkgJiYgaS50cnlMb2MgPD0gZSAmJiBlIDw9IGkuZmluYWxseUxvYyAmJiAoaSA9IG51bGwpOyB2YXIgYSA9IGkgPyBpLmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIGEudHlwZSA9IHQsIGEuYXJnID0gZSwgaSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBpLmZpbmFsbHlMb2MsIHkpIDogdGhpcy5jb21wbGV0ZShhKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHQsIGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gdC50eXBlKSB0aHJvdyB0LmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gdC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gdC50eXBlID8gdGhpcy5uZXh0ID0gdC5hcmcgOiBcInJldHVyblwiID09PSB0LnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSB0LmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHQudHlwZSAmJiBlICYmICh0aGlzLm5leHQgPSBlKSwgeTsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2godCkgeyBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7IHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdOyBpZiAoci5maW5hbGx5TG9jID09PSB0KSByZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sIHIuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KHIpLCB5OyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHQpIHsgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkgeyB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTsgaWYgKHIudHJ5TG9jID09PSB0KSB7IHZhciBuID0gci5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSBuLnR5cGUpIHsgdmFyIG8gPSBuLmFyZzsgcmVzZXRUcnlFbnRyeShyKTsgfSByZXR1cm4gbzsgfSB9IHRocm93IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGUsIHIsIG4pIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoZSksIHJlc3VsdE5hbWU6IHIsIG5leHRMb2M6IG4gfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHQpLCB5OyB9IH0sIGU7IH1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChuLCB0LCBlLCByLCBvLCBhLCBjKSB7IHRyeSB7IHZhciBpID0gblthXShjKSwgdSA9IGkudmFsdWU7IH0gY2F0Y2ggKG4pIHsgcmV0dXJuIHZvaWQgZShuKTsgfSBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7IH1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLCBlID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIG8pIHsgdmFyIGEgPSBuLmFwcGx5KHQsIGUpOyBmdW5jdGlvbiBfbmV4dChuKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7IH0gZnVuY3Rpb24gX3Rocm93KG4pIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgbik7IH0gX25leHQodm9pZCAwKTsgfSk7IH07IH1cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xudmFyIGhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaG9zdG5hbWU6ICdhcGkucm9sbGJhci5jb20nLFxuICBwYXRoOiAnL2FwaS8xL2l0ZW0vJyxcbiAgc2VhcmNoOiBudWxsLFxuICB2ZXJzaW9uOiAnMScsXG4gIHByb3RvY29sOiAnaHR0cHM6JyxcbiAgcG9ydDogNDQzXG59O1xudmFyIE9UTFBEZWZhdWx0T3B0aW9ucyA9IHtcbiAgaG9zdG5hbWU6ICdhcGkucm9sbGJhci5jb20nLFxuICBwYXRoOiAnL2FwaS8xL3Nlc3Npb24vJyxcbiAgc2VhcmNoOiBudWxsLFxuICB2ZXJzaW9uOiAnMScsXG4gIHByb3RvY29sOiAnaHR0cHM6JyxcbiAgcG9ydDogNDQzXG59O1xuXG4vKipcbiAqIEFwaSBpcyBhbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgbWV0aG9kcyBvZiBjb21tdW5pY2F0aW5nIHdpdGhcbiAqIHRoZSBSb2xsYmFyIEFQSS4gIEl0IGlzIGEgc3RhbmRhcmQgaW50ZXJmYWNlIHdpdGggc29tZSBwYXJ0cyBpbXBsZW1lbnRlZFxuICogZGlmZmVyZW50bHkgZm9yIHNlcnZlciBvciBicm93c2VyIGNvbnRleHRzLiAgSXQgaXMgYW4gb2JqZWN0IHRoYXQgc2hvdWxkXG4gKiBiZSBpbnN0YW50aWF0ZWQgd2hlbiB1c2VkIHNvIGl0IGNhbiBjb250YWluIG5vbi1nbG9iYWwgb3B0aW9ucyB0aGF0IG1heVxuICogYmUgZGlmZmVyZW50IGZvciBhbm90aGVyIGluc3RhbmNlIG9mIFJvbGxiYXJBcGkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge1xuICogICAgYWNjZXNzVG9rZW46IHRoZSBhY2Nlc3NUb2tlbiB0byB1c2UgZm9yIHBvc3RpbmcgaXRlbXMgdG8gcm9sbGJhclxuICogICAgZW5kcG9pbnQ6IGFuIGFsdGVybmF0aXZlIGVuZHBvaW50IHRvIHNlbmQgZXJyb3JzIHRvXG4gKiAgICAgICAgbXVzdCBiZSBhIHZhbGlkLCBmdWxseSBxdWFsaWZpZWQgVVJMLlxuICogICAgICAgIFRoZSBkZWZhdWx0IGlzOiBodHRwczovL2FwaS5yb2xsYmFyLmNvbS9hcGkvMS9pdGVtXG4gKiAgICBwcm94eTogaWYgeW91IHdpc2ggdG8gcHJveHkgcmVxdWVzdHMgcHJvdmlkZSBhbiBvYmplY3RcbiAqICAgICAgICB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqICAgICAgICAgIGhvc3Qgb3IgaG9zdG5hbWUgKHJlcXVpcmVkKTogZm9vLmV4YW1wbGUuY29tXG4gKiAgICAgICAgICBwb3J0IChvcHRpb25hbCk6IDEyM1xuICogICAgICAgICAgcHJvdG9jb2wgKG9wdGlvbmFsKTogaHR0cHNcbiAqIH1cbiAqL1xuZnVuY3Rpb24gQXBpKG9wdGlvbnMsIHRyYW5zcG9ydCwgdXJsbGliLCB0cnVuY2F0aW9uKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLnVybCA9IHVybGxpYjtcbiAgdGhpcy50cnVuY2F0aW9uID0gdHJ1bmNhdGlvbjtcbiAgdGhpcy5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuYWNjZXNzVG9rZW47XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IF9nZXRUcmFuc3BvcnQob3B0aW9ucywgdXJsbGliKTtcbiAgdGhpcy5PVExQVHJhbnNwb3J0T3B0aW9ucyA9IF9nZXRPVExQVHJhbnNwb3J0KG9wdGlvbnMsIHVybGxpYik7XG59XG5cbi8qKlxuICogV3JhcHMgdHJhbnNwb3J0LnBvc3QgaW4gYSBQcm9taXNlIHRvIHN1cHBvcnQgYXN5bmMvYXdhaXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBBUEkgcmVxdWVzdFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW4gLSBUaGUgYWNjZXNzIHRva2VuIGZvciBhdXRoZW50aWNhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB0cmFuc3BvcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBheWxvYWQgLSBUaGUgZGF0YSBwYXlsb2FkIHRvIHNlbmRcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbkFwaS5wcm90b3R5cGUuX3Bvc3RQcm9taXNlID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFjY2Vzc1Rva2VuID0gX3JlZi5hY2Nlc3NUb2tlbixcbiAgICB0cmFuc3BvcnRPcHRpb25zID0gX3JlZi50cmFuc3BvcnRPcHRpb25zLFxuICAgIHBheWxvYWQgPSBfcmVmLnBheWxvYWQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZWxmLnRyYW5zcG9ydC5wb3N0KGFjY2Vzc1Rva2VuLCB0cmFuc3BvcnRPcHRpb25zLCBwYXlsb2FkLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3ApO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuQXBpLnByb3RvdHlwZS5wb3N0SXRlbSA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgdHJhbnNwb3J0T3B0aW9ucyA9IGhlbHBlcnMudHJhbnNwb3J0T3B0aW9ucyh0aGlzLnRyYW5zcG9ydE9wdGlvbnMsICdQT1NUJyk7XG4gIHZhciBwYXlsb2FkID0gaGVscGVycy5idWlsZFBheWxvYWQoZGF0YSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBlbnN1cmUgdGhlIG5ldHdvcmsgcmVxdWVzdCBpcyBzY2hlZHVsZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgdGljay5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi50cmFuc3BvcnQucG9zdChzZWxmLmFjY2Vzc1Rva2VuLCB0cmFuc3BvcnRPcHRpb25zLCBwYXlsb2FkLCBjYWxsYmFjayk7XG4gIH0sIDApO1xufTtcblxuLyoqXG4gKiBQb3N0cyBzcGFucyB0byB0aGUgUm9sbGJhciBBUEkgdXNpbmcgdGhlIHNlc3Npb24gZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXlsb2FkIC0gVGhlIHNwYW5zIHRvIHNlbmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEFQSSByZXNwb25zZVxuICovXG5BcGkucHJvdG90eXBlLnBvc3RTcGFucyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKHBheWxvYWQpIHtcbiAgICB2YXIgdHJhbnNwb3J0T3B0aW9ucztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zID0gaGVscGVycy50cmFuc3BvcnRPcHRpb25zKHRoaXMuT1RMUFRyYW5zcG9ydE9wdGlvbnMsICdQT1NUJyk7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RQcm9taXNlKHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgdHJhbnNwb3J0T3B0aW9uczogdHJhbnNwb3J0T3B0aW9ucyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfeCkge1xuICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkFwaS5wcm90b3R5cGUuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgcGF5bG9hZCA9IGhlbHBlcnMuYnVpbGRQYXlsb2FkKGRhdGEpO1xuICB2YXIgc3RyaW5naWZ5UmVzdWx0O1xuICBpZiAodGhpcy50cnVuY2F0aW9uKSB7XG4gICAgc3RyaW5naWZ5UmVzdWx0ID0gdGhpcy50cnVuY2F0aW9uLnRydW5jYXRlKHBheWxvYWQpO1xuICB9IGVsc2Uge1xuICAgIHN0cmluZ2lmeVJlc3VsdCA9IF8uc3RyaW5naWZ5KHBheWxvYWQpO1xuICB9XG4gIGlmIChzdHJpbmdpZnlSZXN1bHQuZXJyb3IpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHN0cmluZ2lmeVJlc3VsdC5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzdHJpbmdpZnlSZXN1bHQudmFsdWU7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ganNvblBheWxvYWRcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5BcGkucHJvdG90eXBlLnBvc3RKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChqc29uUGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgdmFyIHRyYW5zcG9ydE9wdGlvbnMgPSBoZWxwZXJzLnRyYW5zcG9ydE9wdGlvbnModGhpcy50cmFuc3BvcnRPcHRpb25zLCAnUE9TVCcpO1xuICB0aGlzLnRyYW5zcG9ydC5wb3N0SnNvblBheWxvYWQodGhpcy5hY2Nlc3NUb2tlbiwgdHJhbnNwb3J0T3B0aW9ucywganNvblBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG5BcGkucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBvbGRPcHRpb25zID0gdGhpcy5vbGRPcHRpb25zO1xuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9sZE9wdGlvbnMsIG9wdGlvbnMpO1xuICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMgPSBfZ2V0VHJhbnNwb3J0KHRoaXMub3B0aW9ucywgdGhpcy51cmwpO1xuICB0aGlzLk9UTFBUcmFuc3BvcnRPcHRpb25zID0gX2dldE9UTFBUcmFuc3BvcnQodGhpcy5vcHRpb25zLCB0aGlzLnVybCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gX2dldFRyYW5zcG9ydChvcHRpb25zLCB1cmwpIHtcbiAgcmV0dXJuIGhlbHBlcnMuZ2V0VHJhbnNwb3J0RnJvbU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdE9wdGlvbnMsIHVybCk7XG59XG5mdW5jdGlvbiBfZ2V0T1RMUFRyYW5zcG9ydChvcHRpb25zLCB1cmwpIHtcbiAgdmFyIF9vcHRpb25zJHRyYWNpbmc7XG4gIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIGVuZHBvaW50OiAoX29wdGlvbnMkdHJhY2luZyA9IG9wdGlvbnMudHJhY2luZykgPT09IG51bGwgfHwgX29wdGlvbnMkdHJhY2luZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkdHJhY2luZy5lbmRwb2ludFxuICB9KTtcbiAgcmV0dXJuIGhlbHBlcnMuZ2V0VHJhbnNwb3J0RnJvbU9wdGlvbnMob3B0aW9ucywgT1RMUERlZmF1bHRPcHRpb25zLCB1cmwpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBBcGk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Mzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcbmZ1bmN0aW9uIGJ1aWxkUGF5bG9hZChkYXRhKSB7XG4gIGlmICghXy5pc1R5cGUoZGF0YS5jb250ZXh0LCAnc3RyaW5nJykpIHtcbiAgICB2YXIgY29udGV4dFJlc3VsdCA9IF8uc3RyaW5naWZ5KGRhdGEuY29udGV4dCk7XG4gICAgaWYgKGNvbnRleHRSZXN1bHQuZXJyb3IpIHtcbiAgICAgIGRhdGEuY29udGV4dCA9IFwiRXJyb3I6IGNvdWxkIG5vdCBzZXJpYWxpemUgJ2NvbnRleHQnXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuY29udGV4dCA9IGNvbnRleHRSZXN1bHQudmFsdWUgfHwgJyc7XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQubGVuZ3RoID4gMjU1KSB7XG4gICAgICBkYXRhLmNvbnRleHQgPSBkYXRhLmNvbnRleHQuc3Vic3RyKDAsIDI1NSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNwb3J0RnJvbU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMsIHVybCkge1xuICB2YXIgaG9zdG5hbWUgPSBkZWZhdWx0cy5ob3N0bmFtZTtcbiAgdmFyIHByb3RvY29sID0gZGVmYXVsdHMucHJvdG9jb2w7XG4gIHZhciBwb3J0ID0gZGVmYXVsdHMucG9ydDtcbiAgdmFyIHBhdGggPSBkZWZhdWx0cy5wYXRoO1xuICB2YXIgc2VhcmNoID0gZGVmYXVsdHMuc2VhcmNoO1xuICB2YXIgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgdmFyIHRyYW5zcG9ydCA9IGRldGVjdFRyYW5zcG9ydChvcHRpb25zKTtcbiAgdmFyIHByb3h5ID0gb3B0aW9ucy5wcm94eTtcbiAgaWYgKG9wdGlvbnMuZW5kcG9pbnQpIHtcbiAgICB2YXIgb3B0cyA9IHVybC5wYXJzZShvcHRpb25zLmVuZHBvaW50KTtcbiAgICBob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gICAgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sO1xuICAgIHBvcnQgPSBvcHRzLnBvcnQ7XG4gICAgcGF0aCA9IG9wdHMucGF0aG5hbWU7XG4gICAgc2VhcmNoID0gb3B0cy5zZWFyY2g7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIGhvc3RuYW1lOiBob3N0bmFtZSxcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgcG9ydDogcG9ydCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIHByb3h5OiBwcm94eSxcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydFxuICB9O1xufVxuZnVuY3Rpb24gZGV0ZWN0VHJhbnNwb3J0KG9wdGlvbnMpIHtcbiAgdmFyIGdXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdyB8fCB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmO1xuICB2YXIgdHJhbnNwb3J0ID0gb3B0aW9ucy5kZWZhdWx0VHJhbnNwb3J0IHx8ICd4aHInO1xuICBpZiAodHlwZW9mIGdXaW5kb3cuZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB0cmFuc3BvcnQgPSAneGhyJztcbiAgaWYgKHR5cGVvZiBnV2luZG93LlhNTEh0dHBSZXF1ZXN0ID09PSAndW5kZWZpbmVkJykgdHJhbnNwb3J0ID0gJ2ZldGNoJztcbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn1cbmZ1bmN0aW9uIHRyYW5zcG9ydE9wdGlvbnModHJhbnNwb3J0LCBtZXRob2QpIHtcbiAgdmFyIHByb3RvY29sID0gdHJhbnNwb3J0LnByb3RvY29sIHx8ICdodHRwczonO1xuICB2YXIgcG9ydCA9IHRyYW5zcG9ydC5wb3J0IHx8IChwcm90b2NvbCA9PT0gJ2h0dHA6JyA/IDgwIDogcHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogdW5kZWZpbmVkKTtcbiAgdmFyIGhvc3RuYW1lID0gdHJhbnNwb3J0Lmhvc3RuYW1lO1xuICB2YXIgcGF0aCA9IHRyYW5zcG9ydC5wYXRoO1xuICB2YXIgdGltZW91dCA9IHRyYW5zcG9ydC50aW1lb3V0O1xuICB2YXIgdHJhbnNwb3J0QVBJID0gdHJhbnNwb3J0LnRyYW5zcG9ydDtcbiAgaWYgKHRyYW5zcG9ydC5zZWFyY2gpIHtcbiAgICBwYXRoID0gcGF0aCArIHRyYW5zcG9ydC5zZWFyY2g7XG4gIH1cbiAgaWYgKHRyYW5zcG9ydC5wcm94eSkge1xuICAgIHBhdGggPSBwcm90b2NvbCArICcvLycgKyBob3N0bmFtZSArIHBhdGg7XG4gICAgaG9zdG5hbWUgPSB0cmFuc3BvcnQucHJveHkuaG9zdCB8fCB0cmFuc3BvcnQucHJveHkuaG9zdG5hbWU7XG4gICAgcG9ydCA9IHRyYW5zcG9ydC5wcm94eS5wb3J0O1xuICAgIHByb3RvY29sID0gdHJhbnNwb3J0LnByb3h5LnByb3RvY29sIHx8IHByb3RvY29sO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcG9ydDogcG9ydCxcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydEFQSVxuICB9O1xufVxuZnVuY3Rpb24gYXBwZW5kUGF0aFRvUGF0aChiYXNlLCBwYXRoKSB7XG4gIHZhciBiYXNlVHJhaWxpbmdTbGFzaCA9IC9cXC8kLy50ZXN0KGJhc2UpO1xuICB2YXIgcGF0aEJlZ2lubmluZ1NsYXNoID0gL15cXC8vLnRlc3QocGF0aCk7XG4gIGlmIChiYXNlVHJhaWxpbmdTbGFzaCAmJiBwYXRoQmVnaW5uaW5nU2xhc2gpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XG4gIH0gZWxzZSBpZiAoIWJhc2VUcmFpbGluZ1NsYXNoICYmICFwYXRoQmVnaW5uaW5nU2xhc2gpIHtcbiAgICBwYXRoID0gJy8nICsgcGF0aDtcbiAgfVxuICByZXR1cm4gYmFzZSArIHBhdGg7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRQYXlsb2FkOiBidWlsZFBheWxvYWQsXG4gIGdldFRyYW5zcG9ydEZyb21PcHRpb25zOiBnZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyxcbiAgdHJhbnNwb3J0T3B0aW9uczogdHJhbnNwb3J0T3B0aW9ucyxcbiAgYXBwZW5kUGF0aFRvUGF0aDogYXBwZW5kUGF0aFRvUGF0aFxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDk4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xuZnVuY3Rpb24gdHJhdmVyc2Uob2JqLCBmdW5jLCBzZWVuKSB7XG4gIHZhciBrLCB2LCBpO1xuICB2YXIgaXNPYmogPSBfLmlzVHlwZShvYmosICdvYmplY3QnKTtcbiAgdmFyIGlzQXJyYXkgPSBfLmlzVHlwZShvYmosICdhcnJheScpO1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgc2VlbkluZGV4O1xuXG4gIC8vIEJlc3QgbWlnaHQgYmUgdG8gdXNlIE1hcCBoZXJlIHdpdGggYG9iamAgYXMgdGhlIGtleXMsIGJ1dCB3ZSB3YW50IHRvIHN1cHBvcnQgSUUgPCAxMS5cbiAgc2VlbiA9IHNlZW4gfHwge1xuICAgIG9iajogW10sXG4gICAgbWFwcGVkOiBbXVxuICB9O1xuICBpZiAoaXNPYmopIHtcbiAgICBzZWVuSW5kZXggPSBzZWVuLm9iai5pbmRleE9mKG9iaik7XG4gICAgaWYgKGlzT2JqICYmIHNlZW5JbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFByZWZlciB0aGUgbWFwcGVkIG9iamVjdCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICByZXR1cm4gc2Vlbi5tYXBwZWRbc2VlbkluZGV4XSB8fCBzZWVuLm9ialtzZWVuSW5kZXhdO1xuICAgIH1cbiAgICBzZWVuLm9iai5wdXNoKG9iaik7XG4gICAgc2VlbkluZGV4ID0gc2Vlbi5vYmoubGVuZ3RoIC0gMTtcbiAgfVxuICBpZiAoaXNPYmopIHtcbiAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAga2V5cy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICB2YXIgcmVzdWx0ID0gaXNPYmogPyB7fSA6IFtdO1xuICB2YXIgc2FtZSA9IHRydWU7XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgdiA9IG9ialtrXTtcbiAgICByZXN1bHRba10gPSBmdW5jKGssIHYsIHNlZW4pO1xuICAgIHNhbWUgPSBzYW1lICYmIHJlc3VsdFtrXSA9PT0gb2JqW2tdO1xuICB9XG4gIGlmIChpc09iaiAmJiAhc2FtZSkge1xuICAgIHNlZW4ubWFwcGVkW3NlZW5JbmRleF0gPSByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuICFzYW1lID8gcmVzdWx0IDogb2JqO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDEwODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxuXHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gICAgfSBlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0dGVyKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICAgIHZhciBudW1lcmljUHJvcHMgPSBbJ2NvbHVtbk51bWJlcicsICdsaW5lTnVtYmVyJ107XG4gICAgdmFyIHN0cmluZ1Byb3BzID0gWydmaWxlTmFtZScsICdmdW5jdGlvbk5hbWUnLCAnc291cmNlJ107XG4gICAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgICB2YXIgb2JqZWN0UHJvcHMgPSBbJ2V2YWxPcmlnaW4nXTtcblxuICAgIHZhciBwcm9wcyA9IGJvb2xlYW5Qcm9wcy5jb25jYXQobnVtZXJpY1Byb3BzLCBzdHJpbmdQcm9wcywgYXJyYXlQcm9wcywgb2JqZWN0UHJvcHMpO1xuXG4gICAgZnVuY3Rpb24gU3RhY2tGcmFtZShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9ialtwcm9wc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3NldCcgKyBfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldEFyZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXJnczogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmdzID0gdjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFdmFsT3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWxPcmlnaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldEV2YWxPcmlnaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSBuZXcgU3RhY2tGcmFtZSh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gdGhpcy5nZXRDb2x1bW5OdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SXNFdmFsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF0gKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyAnICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdGFja0ZyYW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBTdGFja0ZyYW1lJCRmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgYXJnc1N0YXJ0SW5kZXggPSBzdHIuaW5kZXhPZignKCcpO1xuICAgICAgICB2YXIgYXJnc0VuZEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcpJyk7XG5cbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgYXJnc1N0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgYXJncyA9IHN0ci5zdWJzdHJpbmcoYXJnc1N0YXJ0SW5kZXggKyAxLCBhcmdzRW5kSW5kZXgpLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBsb2NhdGlvblN0cmluZyA9IHN0ci5zdWJzdHJpbmcoYXJnc0VuZEluZGV4ICsgMSk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uU3RyaW5nLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gL0AoLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMobG9jYXRpb25TdHJpbmcsICcnKTtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBwYXJ0c1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhblByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSBfZ2V0dGVyKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gQm9vbGVhbih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1lcmljUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IF9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocCArICcgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gTnVtYmVyKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkobnVtZXJpY1Byb3BzW2pdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHN0cmluZ1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IF9nZXR0ZXIoc3RyaW5nUHJvcHNba10pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoc3RyaW5nUHJvcHNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGFja0ZyYW1lO1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIEVycm9yU3RhY2tQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Myk7XG52YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc/JztcbnZhciBFUlJfQ0xBU1NfUkVHRVhQID0gbmV3IFJlZ0V4cCgnXigoW2EtekEtWjAtOS1fJCBdKik6ICopPyhVbmNhdWdodCApPyhbYS16QS1aMC05LV8kIF0qKTogJyk7XG5mdW5jdGlvbiBndWVzc0Z1bmN0aW9uTmFtZSgpIHtcbiAgcmV0dXJuIFVOS05PV05fRlVOQ1RJT047XG59XG5mdW5jdGlvbiBnYXRoZXJDb250ZXh0KCkge1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEZyYW1lKHN0YWNrRnJhbWUpIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgZGF0YS5fc3RhY2tGcmFtZSA9IHN0YWNrRnJhbWU7XG4gIGRhdGEudXJsID0gc3RhY2tGcmFtZS5maWxlTmFtZTtcbiAgZGF0YS5saW5lID0gc3RhY2tGcmFtZS5saW5lTnVtYmVyO1xuICBkYXRhLmZ1bmMgPSBzdGFja0ZyYW1lLmZ1bmN0aW9uTmFtZTtcbiAgZGF0YS5jb2x1bW4gPSBzdGFja0ZyYW1lLmNvbHVtbk51bWJlcjtcbiAgZGF0YS5hcmdzID0gc3RhY2tGcmFtZS5hcmdzO1xuICBkYXRhLmNvbnRleHQgPSBnYXRoZXJDb250ZXh0KCk7XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gU3RhY2soZXhjZXB0aW9uLCBza2lwKSB7XG4gIGZ1bmN0aW9uIGdldFN0YWNrKCkge1xuICAgIHZhciBwYXJzZXJTdGFjayA9IFtdO1xuICAgIHNraXAgPSBza2lwIHx8IDA7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlclN0YWNrID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShleGNlcHRpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHBhcnNlclN0YWNrID0gW107XG4gICAgfVxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBza2lwOyBpIDwgcGFyc2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YWNrLnB1c2gobmV3IEZyYW1lKHBhcnNlclN0YWNrW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YWNrOiBnZXRTdGFjaygpLFxuICAgIG1lc3NhZ2U6IGV4Y2VwdGlvbi5tZXNzYWdlLFxuICAgIG5hbWU6IF9tb3N0U3BlY2lmaWNFcnJvck5hbWUoZXhjZXB0aW9uKSxcbiAgICByYXdTdGFjazogZXhjZXB0aW9uLnN0YWNrLFxuICAgIHJhd0V4Y2VwdGlvbjogZXhjZXB0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZShlLCBza2lwKSB7XG4gIHZhciBlcnIgPSBlO1xuICBpZiAoZXJyLm5lc3RlZCB8fCBlcnIuY2F1c2UpIHtcbiAgICB2YXIgdHJhY2VDaGFpbiA9IFtdO1xuICAgIHdoaWxlIChlcnIpIHtcbiAgICAgIHRyYWNlQ2hhaW4ucHVzaChuZXcgU3RhY2soZXJyLCBza2lwKSk7XG4gICAgICBlcnIgPSBlcnIubmVzdGVkIHx8IGVyci5jYXVzZTtcbiAgICAgIHNraXAgPSAwOyAvLyBPbmx5IGFwcGx5IHNraXAgdmFsdWUgdG8gcHJpbWFyeSBlcnJvclxuICAgIH1cblxuICAgIC8vIFJldHVybiBwcmltYXJ5IGVycm9yIHdpdGggZnVsbCB0cmFjZSBjaGFpbiBhdHRhY2hlZC5cbiAgICB0cmFjZUNoYWluWzBdLnRyYWNlQ2hhaW4gPSB0cmFjZUNoYWluO1xuICAgIHJldHVybiB0cmFjZUNoYWluWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgU3RhY2soZXJyLCBza2lwKTtcbiAgfVxufVxuZnVuY3Rpb24gZ3Vlc3NFcnJvckNsYXNzKGVyck1zZykge1xuICBpZiAoIWVyck1zZyB8fCAhZXJyTXNnLm1hdGNoKSB7XG4gICAgcmV0dXJuIFsnVW5rbm93biBlcnJvci4gVGhlcmUgd2FzIG5vIGVycm9yIG1lc3NhZ2UgdG8gZGlzcGxheS4nLCAnJ107XG4gIH1cbiAgdmFyIGVyckNsYXNzTWF0Y2ggPSBlcnJNc2cubWF0Y2goRVJSX0NMQVNTX1JFR0VYUCk7XG4gIHZhciBlcnJDbGFzcyA9ICcodW5rbm93biknO1xuICBpZiAoZXJyQ2xhc3NNYXRjaCkge1xuICAgIGVyckNsYXNzID0gZXJyQ2xhc3NNYXRjaFtlcnJDbGFzc01hdGNoLmxlbmd0aCAtIDFdO1xuICAgIGVyck1zZyA9IGVyck1zZy5yZXBsYWNlKChlcnJDbGFzc01hdGNoW2VyckNsYXNzTWF0Y2gubGVuZ3RoIC0gMl0gfHwgJycpICsgZXJyQ2xhc3MgKyAnOicsICcnKTtcbiAgICBlcnJNc2cgPSBlcnJNc2cucmVwbGFjZSgvKF5bXFxzXSt8W1xcc10rJCkvZywgJycpO1xuICB9XG4gIHJldHVybiBbZXJyQ2xhc3MsIGVyck1zZ107XG59XG5cbi8vICogUHJlZmVycyBhbnkgdmFsdWUgb3ZlciBhbiBlbXB0eSBzdHJpbmdcbi8vICogUHJlZmVycyBhbnkgdmFsdWUgb3ZlciAnRXJyb3InIHdoZXJlIHBvc3NpYmxlXG4vLyAqIFByZWZlcnMgbmFtZSBvdmVyIGNvbnN0cnVjdG9yLm5hbWUgd2hlbiBib3RoIGFyZSBtb3JlIHNwZWNpZmljIHRoYW4gJ0Vycm9yJ1xuZnVuY3Rpb24gX21vc3RTcGVjaWZpY0Vycm9yTmFtZShlcnJvcikge1xuICB2YXIgbmFtZSA9IGVycm9yLm5hbWUgJiYgZXJyb3IubmFtZS5sZW5ndGggJiYgZXJyb3IubmFtZTtcbiAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGVycm9yLmNvbnN0cnVjdG9yLm5hbWUgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZS5sZW5ndGggJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKCFuYW1lIHx8ICFjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSB8fCBjb25zdHJ1Y3Rvck5hbWU7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdFcnJvcicpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGd1ZXNzRnVuY3Rpb25OYW1lOiBndWVzc0Z1bmN0aW9uTmFtZSxcbiAgZ3Vlc3NFcnJvckNsYXNzOiBndWVzc0Vycm9yQ2xhc3MsXG4gIGdhdGhlckNvbnRleHQ6IGdhdGhlckNvbnRleHQsXG4gIHBhcnNlOiBwYXJzZSxcbiAgU3RhY2s6IFN0YWNrLFxuICBGcmFtZTogRnJhbWVcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3MzgpO1xudmFyIGRldGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjI5KTtcbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgYXJncy51bnNoaWZ0KCdSb2xsYmFyOicpO1xuICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcbiAgICBjb25zb2xlLmVycm9yKF8uZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBpbmZvKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcbiAgaWYgKGRldGVjdGlvbi5pZVZlcnNpb24oKSA8PSA4KSB7XG4gICAgY29uc29sZS5pbmZvKF8uZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICBhcmdzLnVuc2hpZnQoJ1JvbGxiYXI6Jyk7XG4gIGlmIChkZXRlY3Rpb24uaWVWZXJzaW9uKCkgPD0gOCkge1xuICAgIGNvbnNvbGUubG9nKF8uZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVycm9yOiBlcnJvcixcbiAgaW5mbzogaW5mbyxcbiAgbG9nOiBsb2dcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbmZ1bmN0aW9uIGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvbGRPbkVycm9yO1xuICBpZiAodHlwZW9mIGhhbmRsZXIuX3JvbGxiYXJPbGRPbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb2xkT25FcnJvciA9IGhhbmRsZXIuX3JvbGxiYXJPbGRPbkVycm9yO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKSB7XG4gICAgb2xkT25FcnJvciA9IHdpbmRvdy5vbmVycm9yO1xuICAgIHdoaWxlIChvbGRPbkVycm9yLl9yb2xsYmFyT2xkT25FcnJvcikge1xuICAgICAgb2xkT25FcnJvciA9IG9sZE9uRXJyb3IuX3JvbGxiYXJPbGRPbkVycm9yO1xuICAgIH1cbiAgICBoYW5kbGVyLl9yb2xsYmFyT2xkT25FcnJvciA9IG9sZE9uRXJyb3I7XG4gIH1cbiAgaGFuZGxlci5oYW5kbGVBbm9ueW1vdXNFcnJvcnMoKTtcbiAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIF9yb2xsYmFyV2luZG93T25FcnJvcih3aW5kb3csIGhhbmRsZXIsIG9sZE9uRXJyb3IsIGFyZ3MpO1xuICB9O1xuICBpZiAoc2hpbSkge1xuICAgIGZuLl9yb2xsYmFyT2xkT25FcnJvciA9IG9sZE9uRXJyb3I7XG4gIH1cbiAgd2luZG93Lm9uZXJyb3IgPSBmbjtcbn1cbmZ1bmN0aW9uIF9yb2xsYmFyV2luZG93T25FcnJvcih3aW5kb3csIHIsIG9sZCwgYXJncykge1xuICBpZiAod2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yKSB7XG4gICAgaWYgKCFhcmdzWzRdKSB7XG4gICAgICBhcmdzWzRdID0gd2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yO1xuICAgIH1cbiAgICBpZiAoIWFyZ3NbNV0pIHtcbiAgICAgIGFyZ3NbNV0gPSB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IuX3JvbGxiYXJDb250ZXh0O1xuICAgIH1cbiAgICB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IgPSBudWxsO1xuICB9XG4gIHZhciByZXQgPSByLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uLmFwcGx5KHIsIGFyZ3MpO1xuICBpZiAob2xkKSB7XG4gICAgb2xkLmFwcGx5KHdpbmRvdywgYXJncyk7XG4gIH1cblxuICAvLyBMZXQgb3RoZXIgY2hhaW5lZCBvbmVycm9yIGhhbmRsZXJzIGFib3ZlIHJ1biBiZWZvcmUgc2V0dGluZyB0aGlzLlxuICAvLyBJZiBhbiBlcnJvciBpcyB0aHJvd24gYW5kIGNhdWdodCB3aXRoaW4gYSBjaGFpbmVkIG9uZXJyb3IgaGFuZGxlcixcbiAgLy8gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UoKSB3aWxsIHNlZSB0aGF0IG9uZSBiZWZvcmUgdGhlIG9uZSB3ZSB3YW50LlxuICBpZiAocmV0ID09PSAnYW5vbnltb3VzJykge1xuICAgIHIuYW5vbnltb3VzRXJyb3JzUGVuZGluZyArPSAxOyAvLyBTZWUgUm9sbGJhci5wcm90b3R5cGUuaGFuZGxlQW5vbnltb3VzRXJyb3JzKClcbiAgfVxufVxuZnVuY3Rpb24gY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93Ll9yb2xsYmFyVVJIID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy5fcm9sbGJhclVSSC5iZWxvbmdzVG9TaGltKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHdpbmRvdy5fcm9sbGJhclVSSCk7XG4gIH1cbiAgdmFyIHJlamVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiByZWplY3Rpb25IYW5kbGVyKGV2dCkge1xuICAgIHZhciByZWFzb24sIHByb21pc2UsIGRldGFpbDtcbiAgICB0cnkge1xuICAgICAgcmVhc29uID0gZXZ0LnJlYXNvbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWFzb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZXZ0LnByb21pc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcHJvbWlzZSA9ICdbdW5oYW5kbGVkcmVqZWN0aW9uXSBlcnJvciBnZXR0aW5nIGBwcm9taXNlYCBmcm9tIGV2ZW50JztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRldGFpbCA9IGV2dC5kZXRhaWw7XG4gICAgICBpZiAoIXJlYXNvbiAmJiBkZXRhaWwpIHtcbiAgICAgICAgcmVhc29uID0gZGV0YWlsLnJlYXNvbjtcbiAgICAgICAgcHJvbWlzZSA9IGRldGFpbC5wcm9taXNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgIH1cbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgcmVhc29uID0gJ1t1bmhhbmRsZWRyZWplY3Rpb25dIGVycm9yIGdldHRpbmcgYHJlYXNvbmAgZnJvbSBldmVudCc7XG4gICAgfVxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXIuaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uKSB7XG4gICAgICBoYW5kbGVyLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbihyZWFzb24sIHByb21pc2UpO1xuICAgIH1cbiAgfTtcbiAgcmVqZWN0aW9uSGFuZGxlci5iZWxvbmdzVG9TaGltID0gc2hpbTtcbiAgd2luZG93Ll9yb2xsYmFyVVJIID0gcmVqZWN0aW9uSGFuZGxlcjtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHJlamVjdGlvbkhhbmRsZXIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnM6IGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMsXG4gIGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zOiBjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9uc1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI2Mzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxuXHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gICAgfSBlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xuICAgIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcbiAgICB2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVdKT8kLztcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIGV4dHJhY3QgdGhlIG1vc3QgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdGFja0ZyYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrICYmIGVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGdpdmVuIEVycm9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgICAgIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkZXh0cmFjdExvY2F0aW9uKHVybExpa2UpIHtcbiAgICAgICAgICAgIC8vIEZhaWwtZmFzdCBidXQgcmV0dXJuIGxvY2F0aW9ucyBsaWtlIFwiKG5hdGl2ZSlcIlxuICAgICAgICAgICAgaWYgKHVybExpa2UuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlVjhPcklFOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZVY4T3JJRShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csICdldmFsJykucmVwbGFjZSgvKFxcKGV2YWwgYXQgW14oKV0qKXwoXFwpLC4qJCkvZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIGFuZCBwcmVzZXZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIFwiKC9mb28vbXkgYmFyLmpzOjEyOjg3KVwiIGluXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gZnJvbSB0aGUgbGluZSwgaWYgaXQgd2FzIG1hdGNoZWRcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWRMaW5lID0gbG9jYXRpb24gPyBzYW5pdGl6ZWRMaW5lLnJlcGxhY2UobG9jYXRpb25bMF0sICcnKSA6IHNhbml0aXplZExpbmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gc2FuaXRpemVkTGluZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgbG9jYXRpb24gd2FzIG1hdGNoZWQsIHBhc3MgaXQgdG8gZXh0cmFjdExvY2F0aW9uKCkgb3RoZXJ3aXNlIHBvcCB0aGUgbGFzdCB0b2tlblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obG9jYXRpb24gPyBsb2NhdGlvblsxXSA6IHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IFsnZXZhbCcsICc8YW5vbnltb3VzPiddLmluZGV4T2YobG9jYXRpb25QYXJ0c1swXSkgPiAtMSA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uUGFydHNbMF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VGRk9yU2FmYXJpOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZUZGT3JTYWZhcmkoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignID4gZXZhbCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csICc6JDEnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdAJykgPT09IC0xICYmIGxpbmUuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZXZhbCBmcmFtZXMgb25seSBoYXZlIGZ1bmN0aW9uIG5hbWVzIGFuZCBub3RoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lUmVnZXggPSAvKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS87XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChmdW5jdGlvbk5hbWVSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxpbmUucmVwbGFjZShmdW5jdGlvbk5hbWVSZWdleCwgJycpKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYShlKSB7XG4gICAgICAgICAgICBpZiAoIWUuc3RhY2t0cmFjZSB8fCAoZS5tZXNzYWdlLmluZGV4T2YoJ1xcbicpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCA+IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJykubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE5OiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhOShlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTAoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBJbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBtYXRjaFszXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE9wZXJhIDEwLjY1KyBFcnJvci5zdGFjayB2ZXJ5IHNpbWlsYXIgdG8gRkYvU2FmYXJpXG4gICAgICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkgJiYgIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9ICh0b2tlbnMuc2hpZnQoKSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sICckMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXildKlxcKS9nLCAnJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzUmF3O1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGwubWF0Y2goL1xcKChbXildKilcXCkvKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXihdK1xcKChbXildKilcXCkkLywgJyQxJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gKGFyZ3NSYXcgPT09IHVuZGVmaW5lZCB8fCBhcmdzUmF3ID09PSAnW2FyZ3VtZW50cyBub3QgYXZhaWxhYmxlXScpID9cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjk6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBUcmFjaW5nOyB9XG59KTtcblxuOy8vIC4vc3JjL3RyYWNpbmcvY29udGV4dC5qc1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIENvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGV4dCk7XG4gICAgdGhpcy5fY3VycmVudENvbnRleHQgPSBwYXJlbnRDb250ZXh0ID8gbmV3IE1hcChwYXJlbnRDb250ZXh0KSA6IG5ldyBNYXAoKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbnRleHQsIFt7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0LmdldChrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRoaXMuX2N1cnJlbnRDb250ZXh0KTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRDb250ZXh0LnNldChrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVWYWx1ZShrZXkpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoc2VsZi5fY3VycmVudENvbnRleHQpO1xuICAgICAgY29udGV4dC5fY3VycmVudENvbnRleHRbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIFJPT1RfQ09OVEVYVCA9IG5ldyBDb250ZXh0KCk7XG47Ly8gLi9zcmMvdHJhY2luZy9jb250ZXh0TWFuYWdlci5qc1xuZnVuY3Rpb24gY29udGV4dE1hbmFnZXJfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY29udGV4dE1hbmFnZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGNvbnRleHRNYW5hZ2VyX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY29udGV4dE1hbmFnZXJfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIGNvbnRleHRNYW5hZ2VyX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgY29udGV4dE1hbmFnZXJfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIGNvbnRleHRNYW5hZ2VyX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgY29udGV4dE1hbmFnZXJfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgY29udGV4dE1hbmFnZXJfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBjb250ZXh0TWFuYWdlcl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBjb250ZXh0TWFuYWdlcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gY29udGV4dE1hbmFnZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjb250ZXh0TWFuYWdlcl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IGNvbnRleHRNYW5hZ2VyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBjb250ZXh0TWFuYWdlcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG52YXIgQ29udGV4dE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZXh0TWFuYWdlcigpIHtcbiAgICBjb250ZXh0TWFuYWdlcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZXh0TWFuYWdlcik7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IFJPT1RfQ09OVEVYVDtcbiAgfVxuICByZXR1cm4gY29udGV4dE1hbmFnZXJfY3JlYXRlQ2xhc3MoQ29udGV4dE1hbmFnZXIsIFt7XG4gICAga2V5OiBcImFjdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW50ZXJDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyQ29udGV4dChjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjb250ZXh0IHx8IFJPT1RfQ09OVEVYVDtcbiAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4aXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4aXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudENvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dpdGgoY29udGV4dCwgZm4sIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwcmV2aW91c0NvbnRleHQgPSB0aGlzLmVudGVyQ29udGV4dChjb250ZXh0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uY2FsbC5hcHBseShmbiwgW3RoaXNBcmddLmNvbmNhdChhcmdzKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmV4aXRDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0S2V5KGtleSkge1xuICAvLyBVc2UgU3ltYm9sIGZvciBPcGVuVGVsZW1ldHJ5IGNvbXBhdGliaWxpdHkuXG4gIHJldHVybiBTeW1ib2xbXCJmb3JcIl0oa2V5KTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdHJhY2luZy9pZC5qc1xudmFyIGlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xuOy8vIC4vc3JjL3RyYWNpbmcvc2Vzc2lvbi5qc1xuZnVuY3Rpb24gc2Vzc2lvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzZXNzaW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBzZXNzaW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gc2Vzc2lvbl9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gc2Vzc2lvbl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHNlc3Npb25fdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIHNlc3Npb25fY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBzZXNzaW9uX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHNlc3Npb25fZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBzZXNzaW9uX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHNlc3Npb25fdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHNlc3Npb25fdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBzZXNzaW9uX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gc2Vzc2lvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gc2Vzc2lvbl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG52YXIgU0VTU0lPTl9LRVkgPSAnUm9sbGJhclNlc3Npb24nO1xudmFyIFNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXNzaW9uKHRyYWNpbmcsIG9wdGlvbnMpIHtcbiAgICBzZXNzaW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlc3Npb24pO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFjaW5nID0gdHJhY2luZztcbiAgICB0aGlzLndpbmRvdyA9IHRyYWNpbmcud2luZG93O1xuICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHNlc3Npb25fY3JlYXRlQ2xhc3MoU2Vzc2lvbiwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFNlc3Npb24oKSB8fCB0aGlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXNzaW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRTZXNzaW9uID0gdGhpcy53aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTRVNTSU9OX0tFWSk7XG4gICAgICAgIGlmICghc2VyaWFsaXplZFNlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24gPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRTZXNzaW9uKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTZXNzaW9uKCkge1xuICAgICAgdGhpcy5zZXNzaW9uID0ge1xuICAgICAgICBpZDogaWQvKiBkZWZhdWx0ICovLkEuZ2VuKCksXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLnNldFNlc3Npb24odGhpcy5zZXNzaW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgIHZhciBzZXNzaW9uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbik7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNFU1NJT05fS0VZLCBzZXNzaW9uU3RyaW5nKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3RyYWNpbmcvaHJ0aW1lLmpzXG52YXIgaHJ0aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbjsvLyAuL3NyYy90cmFjaW5nL2V4cG9ydGVyLmpzXG5mdW5jdGlvbiBleHBvcnRlcl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBleHBvcnRlcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgZXhwb3J0ZXJfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpKSB8fCBlICYmIHIgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2Ygci5sZW5ndGgpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBleHBvcnRlcl9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gZXhwb3J0ZXJfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBleHBvcnRlcl90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gZXhwb3J0ZXJfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBleHBvcnRlcl9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBleHBvcnRlcl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIGV4cG9ydGVyX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGV4cG9ydGVyX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBleHBvcnRlcl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGV4cG9ydGVyX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gZXhwb3J0ZXJfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGV4cG9ydGVyX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5cblxuLyoqXG4gKiBTcGFuRXhwb3J0ZXIgaXMgcmVzcG9uc2libGUgZm9yIGV4cG9ydGluZyBSZWFkYWJsZVNwYW4gb2JqZWN0c1xuICogYW5kIHRyYW5zZm9ybWluZyB0aGVtIGludG8gdGhlIE9UTFAtY29tcGF0aWJsZSBmb3JtYXQuXG4gKi9cbnZhciBTcGFuRXhwb3J0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTcGFuRXhwb3J0ZXIoKSB7XG4gICAgZXhwb3J0ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhbkV4cG9ydGVyKTtcbiAgfVxuICByZXR1cm4gZXhwb3J0ZXJfY3JlYXRlQ2xhc3MoU3BhbkV4cG9ydGVyLCBbe1xuICAgIGtleTogXCJleHBvcnRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgc3BhbnMgdG8gdGhlIHNwYW4gZXhwb3J0IHF1ZXVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzcGFucyAtIEFycmF5IG9mIFJlYWRhYmxlU3BhbiBvYmplY3RzIHRvIGV4cG9ydFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IF9yZXN1bHRDYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIChub3QgdXNlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXhwb3J0KHNwYW5zLCBfcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgIGNvbnNvbGUubG9nKHNwYW5zKTsgLy8gY29uc29sZSBleHBvcnRlciwgVE9ETzogbWFrZSBvcHRpb25hbFxuICAgICAgc3BhbkV4cG9ydFF1ZXVlLnB1c2guYXBwbHkoc3BhbkV4cG9ydFF1ZXVlLCBfdG9Db25zdW1hYmxlQXJyYXkoc3BhbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIFJlYWRhYmxlU3BhbiBvYmplY3RzIGludG8gdGhlIE9UTFAgZm9ybWF0IHBheWxvYWRcbiAgICAgKiBjb21wYXRpYmxlIHdpdGggdGhlIFJvbGxiYXIgQVBJLiBUaGlzIGZvbGxvd3MgdGhlIE9wZW5UZWxlbWV0cnkgcHJvdG9jb2xcbiAgICAgKiBzcGVjaWZpY2F0aW9uIGZvciB0cmFjZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPVExQIGZvcm1hdCBwYXlsb2FkIGZvciBBUEkgdHJhbnNtaXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9QYXlsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGF5bG9hZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgc3BhbnMgPSBzcGFuRXhwb3J0UXVldWUuc2xpY2UoKTtcbiAgICAgIHNwYW5FeHBvcnRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgaWYgKCFzcGFucyB8fCAhc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb3VyY2VTcGFuczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXNvdXJjZSA9IHNwYW5zWzBdICYmIHNwYW5zWzBdLnJlc291cmNlIHx8IHt9O1xuICAgICAgdmFyIHNjb3BlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNwYW5zKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzcGFuID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHNjb3BlS2V5ID0gc3Bhbi5pbnN0cnVtZW50YXRpb25TY29wZSA/IFwiXCIuY29uY2F0KHNwYW4uaW5zdHJ1bWVudGF0aW9uU2NvcGUubmFtZSwgXCI6XCIpLmNvbmNhdChzcGFuLmluc3RydW1lbnRhdGlvblNjb3BlLnZlcnNpb24pIDogJ2RlZmF1bHQ6MS4wLjAnO1xuICAgICAgICAgIGlmICghc2NvcGVNYXAuaGFzKHNjb3BlS2V5KSkge1xuICAgICAgICAgICAgc2NvcGVNYXAuc2V0KHNjb3BlS2V5LCB7XG4gICAgICAgICAgICAgIHNjb3BlOiBzcGFuLmluc3RydW1lbnRhdGlvblNjb3BlIHx8IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzcGFuczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY29wZU1hcC5nZXQoc2NvcGVLZXkpLnNwYW5zLnB1c2godGhpcy5fdHJhbnNmb3JtU3BhbihzcGFuKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc291cmNlU3BhbnM6IFt7XG4gICAgICAgICAgcmVzb3VyY2U6IHRoaXMuX3RyYW5zZm9ybVJlc291cmNlKHJlc291cmNlKSxcbiAgICAgICAgICBzY29wZVNwYW5zOiBBcnJheS5mcm9tKHNjb3BlTWFwLnZhbHVlcygpKS5tYXAoZnVuY3Rpb24gKHNjb3BlRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2NvcGU6IF90aGlzLl90cmFuc2Zvcm1JbnN0cnVtZW50YXRpb25TY29wZShzY29wZURhdGEuc2NvcGUpLFxuICAgICAgICAgICAgICBzcGFuczogc2NvcGVEYXRhLnNwYW5zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBSZWFkYWJsZVNwYW4gaW50byB0aGUgT1RMUCBTcGFuIGZvcm1hdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BhbiAtIFJlYWRhYmxlU3BhbiBvYmplY3QgdG8gdHJhbnNmb3JtXG4gICAgICogQHJldHVybnMge09iamVjdH0gT1RMUCBTcGFuIGZvcm1hdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl90cmFuc2Zvcm1TcGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1TcGFuKHNwYW4pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHRyYW5zZm9ybUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMgfHwge30pLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAga2V5ID0gX3JlZjJbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9yZWYyWzFdO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpczIuX3RyYW5zZm9ybUFueVZhbHVlKHZhbHVlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHZhciB0cmFuc2Zvcm1FdmVudHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1FdmVudHMoZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiAoZXZlbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVVbml4TmFubzogaHJ0aW1lLyogZGVmYXVsdCAqLy5BLnRvTmFub3MoZXZlbnQudGltZSksXG4gICAgICAgICAgICBuYW1lOiBldmVudC5uYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJhbnNmb3JtQXR0cmlidXRlcyhldmVudC5hdHRyaWJ1dGVzKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNlSWQ6IHNwYW4uc3BhbkNvbnRleHQudHJhY2VJZCxcbiAgICAgICAgc3BhbklkOiBzcGFuLnNwYW5Db250ZXh0LnNwYW5JZCxcbiAgICAgICAgcGFyZW50U3BhbklkOiBzcGFuLnBhcmVudFNwYW5JZCB8fCAnJyxcbiAgICAgICAgbmFtZTogc3Bhbi5uYW1lLFxuICAgICAgICBraW5kOiBzcGFuLmtpbmQgfHwgMSxcbiAgICAgICAgLy8gSU5URVJOQUwgYnkgZGVmYXVsdFxuICAgICAgICBzdGFydFRpbWVVbml4TmFubzogaHJ0aW1lLyogZGVmYXVsdCAqLy5BLnRvTmFub3Moc3Bhbi5zdGFydFRpbWUpLFxuICAgICAgICBlbmRUaW1lVW5peE5hbm86IGhydGltZS8qIGRlZmF1bHQgKi8uQS50b05hbm9zKHNwYW4uZW5kVGltZSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRyYW5zZm9ybUF0dHJpYnV0ZXMoc3Bhbi5hdHRyaWJ1dGVzKSxcbiAgICAgICAgZXZlbnRzOiB0cmFuc2Zvcm1FdmVudHMoc3Bhbi5ldmVudHMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSByZXNvdXJjZSBvYmplY3QgaW50byBPVExQIFJlc291cmNlIGZvcm1hdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzb3VyY2UgLSBSZXNvdXJjZSBpbmZvcm1hdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9UTFAgUmVzb3VyY2UgZm9ybWF0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zZm9ybVJlc291cmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1SZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHJlc291cmNlLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICB2YXIga2V5VmFsdWVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykubWFwKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAga2V5ID0gX3JlZjRbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmNFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogX3RoaXMzLl90cmFuc2Zvcm1BbnlWYWx1ZSh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cmlidXRlczoga2V5VmFsdWVzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gaW5zdHJ1bWVudGF0aW9uIHNjb3BlIGludG8gT1RMUCBJbnN0cnVtZW50YXRpb25TY29wZSBmb3JtYXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIC0gSW5zdHJ1bWVudGF0aW9uIHNjb3BlIGluZm9ybWF0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH0gT1RMUCBJbnN0cnVtZW50YXRpb25TY29wZSBmb3JtYXRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdHJhbnNmb3JtSW5zdHJ1bWVudGF0aW9uU2NvcGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybUluc3RydW1lbnRhdGlvblNjb3BlKHNjb3BlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNjb3BlLm5hbWUgfHwgJycsXG4gICAgICAgIHZlcnNpb246IHNjb3BlLnZlcnNpb24gfHwgJycsXG4gICAgICAgIGF0dHJpYnV0ZXM6IChzY29wZS5hdHRyaWJ1dGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBhdHRyLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpczQuX3RyYW5zZm9ybUFueVZhbHVlKGF0dHIudmFsdWUpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBhbiBPVExQIEFueVZhbHVlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFZhbHVlIHRvIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9UTFAgQW55VmFsdWUgZm9ybWF0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zZm9ybUFueVZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1BbnlWYWx1ZSh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmluZ1ZhbHVlOiAnJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSBleHBvcnRlcl90eXBlb2YodmFsdWUpO1xuICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyaW5nVmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRWYWx1ZTogdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvdWJsZVZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9vbFZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFycmF5VmFsdWU6IHtcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczUuX3RyYW5zZm9ybUFueVZhbHVlKHYpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga3ZsaXN0VmFsdWU6IHtcbiAgICAgICAgICAgIHZhbHVlczogT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpLFxuICAgICAgICAgICAgICAgIGsgPSBfcmVmNlswXSxcbiAgICAgICAgICAgICAgICB2ID0gX3JlZjZbMV07XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpczUuX3RyYW5zZm9ybUFueVZhbHVlKHYpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmluZ1ZhbHVlOiBTdHJpbmcodmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIHNwYW5FeHBvcnRRdWV1ZSA9IFtdO1xuOy8vIC4vc3JjL3RyYWNpbmcvc3BhblByb2Nlc3Nvci5qc1xuZnVuY3Rpb24gc3BhblByb2Nlc3Nvcl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzcGFuUHJvY2Vzc29yX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBzcGFuUHJvY2Vzc29yX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gc3BhblByb2Nlc3Nvcl9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gc3BhblByb2Nlc3Nvcl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHNwYW5Qcm9jZXNzb3JfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIHNwYW5Qcm9jZXNzb3JfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBzcGFuUHJvY2Vzc29yX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHNwYW5Qcm9jZXNzb3JfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBzcGFuUHJvY2Vzc29yX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHNwYW5Qcm9jZXNzb3JfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHNwYW5Qcm9jZXNzb3JfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBzcGFuUHJvY2Vzc29yX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gc3BhblByb2Nlc3Nvcl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gc3BhblByb2Nlc3Nvcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIFNwYW5Qcm9jZXNzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTcGFuUHJvY2Vzc29yKGV4cG9ydGVyKSB7XG4gICAgc3BhblByb2Nlc3Nvcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFuUHJvY2Vzc29yKTtcbiAgICB0aGlzLmV4cG9ydGVyID0gZXhwb3J0ZXI7XG4gICAgdGhpcy5wZW5kaW5nU3BhbnMgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmV0dXJuIHNwYW5Qcm9jZXNzb3JfY3JlYXRlQ2xhc3MoU3BhblByb2Nlc3NvciwgW3tcbiAgICBrZXk6IFwib25TdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN0YXJ0KHNwYW4sIF9wYXJlbnRDb250ZXh0KSB7XG4gICAgICB0aGlzLnBlbmRpbmdTcGFucy5zZXQoc3Bhbi5zcGFuLnNwYW5Db250ZXh0LnNwYW5JZCwgc3Bhbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRW5kKHNwYW4pIHtcbiAgICAgIHRoaXMuZXhwb3J0ZXJbXCJleHBvcnRcIl0oW3NwYW5bXCJleHBvcnRcIl0oKV0pO1xuICAgICAgdGhpcy5wZW5kaW5nU3BhbnNbXCJkZWxldGVcIl0oc3Bhbi5zcGFuLnNwYW5Db250ZXh0LnNwYW5JZCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG47Ly8gLi9zcmMvdHJhY2luZy9zcGFuLmpzXG5mdW5jdGlvbiBzcGFuX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHNwYW5fdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHNwYW5fdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBzcGFuX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gc3Bhbl9hcnJheVdpdGhIb2xlcyhyKSB8fCBzcGFuX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IHNwYW5fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgc3Bhbl9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gc3Bhbl9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIHNwYW5fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIHNwYW5fYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gc3Bhbl9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIHNwYW5fYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBzcGFuX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBzcGFuX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBzcGFuX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBzcGFuX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgc3Bhbl90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gc3Bhbl9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIHNwYW5fZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgc3Bhbl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIHNwYW5fdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gc3Bhbl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gc3Bhbl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHNwYW5fdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBzcGFuX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBzcGFuX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5cbnZhciBTcGFuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BhbihvcHRpb25zKSB7XG4gICAgc3Bhbl9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFuKTtcbiAgICB0aGlzLmluaXRSZWFkYWJsZVNwYW4ob3B0aW9ucyk7XG4gICAgdGhpcy5zcGFuUHJvY2Vzc29yID0gb3B0aW9ucy5zcGFuUHJvY2Vzc29yO1xuICAgIHRoaXMuc3BhblByb2Nlc3Nvci5vblN0YXJ0KHRoaXMsIG9wdGlvbnMuY29udGV4dCk7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiBzcGFuX2NyZWF0ZUNsYXNzKFNwYW4sIFt7XG4gICAga2V5OiBcImluaXRSZWFkYWJsZVNwYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFJlYWRhYmxlU3BhbihvcHRpb25zKSB7XG4gICAgICB0aGlzLnNwYW4gPSB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAga2luZDogb3B0aW9ucy5raW5kLFxuICAgICAgICBzcGFuQ29udGV4dDogb3B0aW9ucy5zcGFuQ29udGV4dCxcbiAgICAgICAgcGFyZW50U3BhbklkOiBvcHRpb25zLnBhcmVudFNwYW5JZCxcbiAgICAgICAgc3RhcnRUaW1lOiBvcHRpb25zLnN0YXJ0VGltZSB8fCBocnRpbWUvKiBkZWZhdWx0ICovLkEubm93KCksXG4gICAgICAgIGVuZFRpbWU6IFswLCAwXSxcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICBtZXNzYWdlOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgJ3Nlc3Npb24uaWQnOiBvcHRpb25zLnNlc3Npb24uaWRcbiAgICAgICAgfSxcbiAgICAgICAgbGlua3M6IFtdLFxuICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZW5kZWQ6IGZhbHNlLFxuICAgICAgICByZXNvdXJjZTogb3B0aW9ucy5yZXNvdXJjZSxcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uU2NvcGU6IG9wdGlvbnMuc2NvcGUsXG4gICAgICAgIGRyb3BwZWRBdHRyaWJ1dGVzQ291bnQ6IDAsXG4gICAgICAgIGRyb3BwZWRFdmVudHNDb3VudDogMCxcbiAgICAgICAgZHJvcHBlZExpbmtzQ291bnQ6IDBcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwYW5Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwYW5Db250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhbi5zcGFuQ29udGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3BhbklkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuLnNwYW5Db250ZXh0LnNwYW5JZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2VJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhbi5zcGFuQ29udGV4dC50cmFjZUlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHRoaXMuZW5kZWQpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKGtleS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5zcGFuLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpOyBfaSA8IF9PYmplY3QkZW50cmllcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IHNwYW5fc2xpY2VkVG9BcnJheShfT2JqZWN0JGVudHJpZXNbX2ldLCAyKSxcbiAgICAgICAgICBrID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIHYgPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50KG5hbWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5zcGFuLmVuZGVkKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuc3Bhbi5ldmVudHMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIHRpbWU6IHRpbWUgfHwgaHJ0aW1lLyogZGVmYXVsdCAqLy5BLm5vdygpLFxuICAgICAgICBkcm9wcGVkQXR0cmlidXRlc0NvdW50OiAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1JlY29yZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1JlY29yZGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYW4uZW5kZWQgPT09IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKGF0dHJpYnV0ZXMsIHRpbWUpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLnNwYW4uZW5kVGltZSA9IHRpbWUgfHwgaHJ0aW1lLyogZGVmYXVsdCAqLy5BLm5vdygpO1xuICAgICAgdGhpcy5zcGFuLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3BhblByb2Nlc3Nvci5vbkVuZCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9leHBvcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuOy8vIC4vc3JjL3RyYWNpbmcvdHJhY2VyLmpzXG5mdW5jdGlvbiB0cmFjZXJfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdHJhY2VyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCB0cmFjZXJfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiB0cmFjZXJfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIHRyYWNlcl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHRyYWNlcl90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gdHJhY2VyX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgdHJhY2VyX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHRyYWNlcl9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIHRyYWNlcl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSB0cmFjZXJfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHRyYWNlcl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHRyYWNlcl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHRyYWNlcl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHJhY2VyX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5cblxudmFyIFRyYWNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYWNlcih0cmFjaW5nLCBzcGFuUHJvY2Vzc29yKSB7XG4gICAgdHJhY2VyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNlcik7XG4gICAgdGhpcy5zcGFuUHJvY2Vzc29yID0gc3BhblByb2Nlc3NvcjtcbiAgICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuICB9XG4gIHJldHVybiB0cmFjZXJfY3JlYXRlQ2xhc3MoVHJhY2VyLCBbe1xuICAgIGtleTogXCJzdGFydFNwYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTcGFuKG5hbWUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnRyYWNpbmcuY29udGV4dE1hbmFnZXIuYWN0aXZlKCk7XG4gICAgICB2YXIgcGFyZW50U3BhbiA9IHRoaXMudHJhY2luZy5nZXRTcGFuKGNvbnRleHQpO1xuICAgICAgdmFyIHBhcmVudFNwYW5Db250ZXh0ID0gcGFyZW50U3BhbiA9PT0gbnVsbCB8fCBwYXJlbnRTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG4gICAgICB2YXIgc3BhbklkID0gaWQvKiBkZWZhdWx0ICovLkEuZ2VuKDgpO1xuICAgICAgdmFyIHRyYWNlSWQ7XG4gICAgICB2YXIgdHJhY2VGbGFncyA9IDA7XG4gICAgICB2YXIgdHJhY2VTdGF0ZSA9IG51bGw7XG4gICAgICB2YXIgcGFyZW50U3BhbklkO1xuICAgICAgaWYgKHBhcmVudFNwYW5Db250ZXh0KSB7XG4gICAgICAgIHRyYWNlSWQgPSBwYXJlbnRTcGFuQ29udGV4dC50cmFjZUlkO1xuICAgICAgICB0cmFjZVN0YXRlID0gcGFyZW50U3BhbkNvbnRleHQudHJhY2VTdGF0ZTtcbiAgICAgICAgcGFyZW50U3BhbklkID0gcGFyZW50U3BhbkNvbnRleHQuc3BhbklkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2VJZCA9IGlkLyogZGVmYXVsdCAqLy5BLmdlbigxNik7XG4gICAgICB9XG4gICAgICB2YXIga2luZCA9IDA7XG4gICAgICB2YXIgc3BhbkNvbnRleHQgPSB7XG4gICAgICAgIHRyYWNlSWQ6IHRyYWNlSWQsXG4gICAgICAgIHNwYW5JZDogc3BhbklkLFxuICAgICAgICB0cmFjZUZsYWdzOiB0cmFjZUZsYWdzLFxuICAgICAgICB0cmFjZVN0YXRlOiB0cmFjZVN0YXRlXG4gICAgICB9O1xuICAgICAgdmFyIHNwYW4gPSBuZXcgU3Bhbih7XG4gICAgICAgIHJlc291cmNlOiB0aGlzLnRyYWNpbmcucmVzb3VyY2UsXG4gICAgICAgIHNjb3BlOiB0aGlzLnRyYWNpbmcuc2NvcGUsXG4gICAgICAgIHNlc3Npb246IHRoaXMudHJhY2luZy5zZXNzaW9uLnNlc3Npb24sXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHNwYW5Db250ZXh0OiBzcGFuQ29udGV4dCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgcGFyZW50U3BhbklkOiBwYXJlbnRTcGFuSWQsXG4gICAgICAgIHNwYW5Qcm9jZXNzb3I6IHRoaXMuc3BhblByb2Nlc3NvclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbjsvLyAuL3NyYy90cmFjaW5nL3RyYWNpbmcuanNcbmZ1bmN0aW9uIHRyYWNpbmdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdHJhY2luZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgdHJhY2luZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gdHJhY2luZ190b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gdHJhY2luZ19jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gdHJhY2luZ19kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHRyYWNpbmdfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIHRyYWNpbmdfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiB0cmFjaW5nX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIHRyYWNpbmdfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiB0cmFjaW5nX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHRyYWNpbmdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHRyYWNpbmdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiB0cmFjaW5nX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHJhY2luZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHJhY2luZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG5cblxuXG5cbnZhciBTUEFOX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoJ1JvbGxiYXIgQ29udGV4dCBLZXkgU1BBTicpO1xudmFyIFRyYWNpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFjaW5nKGdXaW5kb3csIG9wdGlvbnMpIHtcbiAgICB0cmFjaW5nX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNpbmcpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53aW5kb3cgPSBnV2luZG93O1xuICAgIHRoaXMuc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY3JlYXRlVHJhY2VyKCk7XG4gIH1cbiAgcmV0dXJuIHRyYWNpbmdfY3JlYXRlQ2xhc3MoVHJhY2luZywgW3tcbiAgICBrZXk6IFwiaW5pdFNlc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFNlc3Npb24oKSB7XG4gICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5pbml0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlc3Npb25JZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnNlc3Npb24uaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb3VyY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zJHBheWxvYWQsIF90aGlzJG9wdGlvbnMkcGF5bG9hZDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMub3B0aW9ucy5yZXNvdXJjZSB8fCB7fSksIHt9LCB7XG4gICAgICAgICAgJ3JvbGxiYXIuZW52aXJvbm1lbnQnOiAoX3RoaXMkb3B0aW9ucyRwYXlsb2FkID0gKF90aGlzJG9wdGlvbnMkcGF5bG9hZDIgPSB0aGlzLm9wdGlvbnMucGF5bG9hZCkgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9ucyRwYXlsb2FkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRwYXlsb2FkMi5lbnZpcm9ubWVudCkgIT09IG51bGwgJiYgX3RoaXMkb3B0aW9ucyRwYXlsb2FkICE9PSB2b2lkIDAgPyBfdGhpcyRvcHRpb25zJHBheWxvYWQgOiB0aGlzLm9wdGlvbnMuZW52aXJvbm1lbnRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjb3BlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAncm9sbGJhci1icm93c2VyLWpzJyxcbiAgICAgICAgdmVyc2lvbjogdGhpcy5vcHRpb25zLnZlcnNpb25cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRyYWNlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUcmFjZXIoKSB7XG4gICAgICB0aGlzLmNvbnRleHRNYW5hZ2VyID0gbmV3IENvbnRleHRNYW5hZ2VyKCk7XG4gICAgICB0aGlzLmV4cG9ydGVyID0gbmV3IFNwYW5FeHBvcnRlcigpO1xuICAgICAgdGhpcy5zcGFuUHJvY2Vzc29yID0gbmV3IFNwYW5Qcm9jZXNzb3IodGhpcy5leHBvcnRlcik7XG4gICAgICB0aGlzLnRyYWNlciA9IG5ldyBUcmFjZXIodGhpcywgdGhpcy5zcGFuUHJvY2Vzc29yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJhY2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYWNlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3BhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcGFuKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuY29udGV4dE1hbmFnZXIuYWN0aXZlKCk7XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRWYWx1ZShTUEFOX0tFWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNwYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3BhbigpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpO1xuICAgICAgdmFyIHNwYW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBjb250ZXh0LnNldFZhbHVlKFNQQU5fS0VZLCBzcGFuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRTcGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0U3BhbihuYW1lKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5jb250ZXh0TWFuYWdlci5hY3RpdmUoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNlci5zdGFydFNwYW4obmFtZSwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dpdGgoY29udGV4dCwgZm4sIHRoaXNBcmcpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0TWFuYWdlcjtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90aGlzJGNvbnRleHRNYW5hZ2VyID0gdGhpcy5jb250ZXh0TWFuYWdlcilbXCJ3aXRoXCJdLmFwcGx5KF90aGlzJGNvbnRleHRNYW5hZ2VyLCBbY29udGV4dCwgZm4sIHRoaXNBcmddLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhTcGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTcGFuKG5hbWUsIG9wdGlvbnMsIGZuLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgc3BhbiA9IHRoaXMuc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXNbXCJ3aXRoXCJdKHRoaXMuc2V0U3Bhbih0aGlzLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpLCBzcGFuKSwgZm4sIHRoaXNBcmcsIHNwYW4pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyODc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gUmVwbGF5TWFwOyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhY2luZ19pZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBlOyB9OyB2YXIgdCwgZSA9IHt9LCByID0gT2JqZWN0LnByb3RvdHlwZSwgbiA9IHIuaGFzT3duUHJvcGVydHksIG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKHQsIGUsIHIpIHsgdFtlXSA9IHIudmFsdWU7IH0sIGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBhID0gaS5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYyA9IGkuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB1ID0gaS50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7IHZhbHVlOiByLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCB0W2VdOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKHQpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHsgcmV0dXJuIHRbZV0gPSByOyB9OyB9IGZ1bmN0aW9uIHdyYXAodCwgZSwgciwgbikgeyB2YXIgaSA9IGUgJiYgZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBlIDogR2VuZXJhdG9yLCBhID0gT2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSksIGMgPSBuZXcgQ29udGV4dChuIHx8IFtdKTsgcmV0dXJuIG8oYSwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QodCwgciwgYykgfSksIGE7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2godCwgZSwgcikgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IHQuY2FsbChlLCByKSB9OyB9IGNhdGNoICh0KSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiB0IH07IH0gfSBlLndyYXAgPSB3cmFwOyB2YXIgaCA9IFwic3VzcGVuZGVkU3RhcnRcIiwgbCA9IFwic3VzcGVuZGVkWWllbGRcIiwgZiA9IFwiZXhlY3V0aW5nXCIsIHMgPSBcImNvbXBsZXRlZFwiLCB5ID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgcCA9IHt9OyBkZWZpbmUocCwgYSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBkID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCB2ID0gZCAmJiBkKGQodmFsdWVzKFtdKSkpOyB2ICYmIHYgIT09IHIgJiYgbi5jYWxsKHYsIGEpICYmIChwID0gdik7IHZhciBnID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocCk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyh0KSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IGRlZmluZSh0LCBlLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5faW52b2tlKGUsIHQpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcih0LCBlKSB7IGZ1bmN0aW9uIGludm9rZShyLCBvLCBpLCBhKSB7IHZhciBjID0gdHJ5Q2F0Y2godFtyXSwgdCwgbyk7IGlmIChcInRocm93XCIgIT09IGMudHlwZSkgeyB2YXIgdSA9IGMuYXJnLCBoID0gdS52YWx1ZTsgcmV0dXJuIGggJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKGgpICYmIG4uY2FsbChoLCBcIl9fYXdhaXRcIikgPyBlLnJlc29sdmUoaC5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh0KSB7IGludm9rZShcIm5leHRcIiwgdCwgaSwgYSk7IH0sIGZ1bmN0aW9uICh0KSB7IGludm9rZShcInRocm93XCIsIHQsIGksIGEpOyB9KSA6IGUucmVzb2x2ZShoKS50aGVuKGZ1bmN0aW9uICh0KSB7IHUudmFsdWUgPSB0LCBpKHUpOyB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgdCwgaSwgYSk7IH0pOyB9IGEoYy5hcmcpOyB9IHZhciByOyBvKHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0LCBuKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHsgaW52b2tlKHQsIG4sIGUsIHIpOyB9KTsgfSByZXR1cm4gciA9IHIgPyByLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChlLCByLCBuKSB7IHZhciBvID0gaDsgcmV0dXJuIGZ1bmN0aW9uIChpLCBhKSB7IGlmIChvID09PSBmKSB0aHJvdyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChvID09PSBzKSB7IGlmIChcInRocm93XCIgPT09IGkpIHRocm93IGE7IHJldHVybiB7IHZhbHVlOiB0LCBkb25lOiAhMCB9OyB9IGZvciAobi5tZXRob2QgPSBpLCBuLmFyZyA9IGE7OykgeyB2YXIgYyA9IG4uZGVsZWdhdGU7IGlmIChjKSB7IHZhciB1ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShjLCBuKTsgaWYgKHUpIHsgaWYgKHUgPT09IHkpIGNvbnRpbnVlOyByZXR1cm4gdTsgfSB9IGlmIChcIm5leHRcIiA9PT0gbi5tZXRob2QpIG4uc2VudCA9IG4uX3NlbnQgPSBuLmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IG4ubWV0aG9kKSB7IGlmIChvID09PSBoKSB0aHJvdyBvID0gcywgbi5hcmc7IG4uZGlzcGF0Y2hFeGNlcHRpb24obi5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gbi5tZXRob2QgJiYgbi5hYnJ1cHQoXCJyZXR1cm5cIiwgbi5hcmcpOyBvID0gZjsgdmFyIHAgPSB0cnlDYXRjaChlLCByLCBuKTsgaWYgKFwibm9ybWFsXCIgPT09IHAudHlwZSkgeyBpZiAobyA9IG4uZG9uZSA/IHMgOiBsLCBwLmFyZyA9PT0geSkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiBwLmFyZywgZG9uZTogbi5kb25lIH07IH0gXCJ0aHJvd1wiID09PSBwLnR5cGUgJiYgKG8gPSBzLCBuLm1ldGhvZCA9IFwidGhyb3dcIiwgbi5hcmcgPSBwLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpIHsgdmFyIG4gPSByLm1ldGhvZCwgbyA9IGUuaXRlcmF0b3Jbbl07IGlmIChvID09PSB0KSByZXR1cm4gci5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbiAmJiBlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChyLm1ldGhvZCA9IFwicmV0dXJuXCIsIHIuYXJnID0gdCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShlLCByKSwgXCJ0aHJvd1wiID09PSByLm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbiAmJiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbiArIFwiJyBtZXRob2RcIikpLCB5OyB2YXIgaSA9IHRyeUNhdGNoKG8sIGUuaXRlcmF0b3IsIHIuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gaS50eXBlKSByZXR1cm4gci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gaS5hcmcsIHIuZGVsZWdhdGUgPSBudWxsLCB5OyB2YXIgYSA9IGkuYXJnOyByZXR1cm4gYSA/IGEuZG9uZSA/IChyW2UucmVzdWx0TmFtZV0gPSBhLnZhbHVlLCByLm5leHQgPSBlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IHIubWV0aG9kICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCByLmRlbGVnYXRlID0gbnVsbCwgeSkgOiBhIDogKHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgci5kZWxlZ2F0ZSA9IG51bGwsIHkpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeSh0KSB7IHZhciBlID0geyB0cnlMb2M6IHRbMF0gfTsgMSBpbiB0ICYmIChlLmNhdGNoTG9jID0gdFsxXSksIDIgaW4gdCAmJiAoZS5maW5hbGx5TG9jID0gdFsyXSwgZS5hZnRlckxvYyA9IHRbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlKTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KHQpIHsgdmFyIGUgPSB0LmNvbXBsZXRpb24gfHwge307IGUudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSBlLmFyZywgdC5jb21wbGV0aW9uID0gZTsgfSBmdW5jdGlvbiBDb250ZXh0KHQpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhlKSB7IGlmIChlIHx8IFwiXCIgPT09IGUpIHsgdmFyIHIgPSBlW2FdOyBpZiAocikgcmV0dXJuIHIuY2FsbChlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTsgaWYgKCFpc05hTihlLmxlbmd0aCkpIHsgdmFyIG8gPSAtMSwgaSA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK28gPCBlLmxlbmd0aDspIGlmIChuLmNhbGwoZSwgbykpIHJldHVybiBuZXh0LnZhbHVlID0gZVtvXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBpLm5leHQgPSBpOyB9IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihfdHlwZW9mKGUpICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpOyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgbyhnLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBvKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgJiYgdC5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhZSAmJiAoZSA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpKTsgfSwgZS5tYXJrID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZih0LCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAodC5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKHQsIHUsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZyksIHQ7IH0sIGUuYXdyYXAgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4geyBfX2F3YWl0OiB0IH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGUuYXN5bmMgPSBmdW5jdGlvbiAodCwgciwgbiwgbywgaSkgeyB2b2lkIDAgPT09IGkgJiYgKGkgPSBQcm9taXNlKTsgdmFyIGEgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKHQsIHIsIG4sIG8pLCBpKTsgcmV0dXJuIGUuaXNHZW5lcmF0b3JGdW5jdGlvbihyKSA/IGEgOiBhLm5leHQoKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmRvbmUgPyB0LnZhbHVlIDogYS5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoZyksIGRlZmluZShnLCB1LCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKGcsIGEsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoZywgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZS5rZXlzID0gZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBPYmplY3QodCksIHIgPSBbXTsgZm9yICh2YXIgbiBpbiBlKSByLnB1c2gobik7IHJldHVybiByLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IHIubGVuZ3RoOykgeyB2YXIgdCA9IHIucG9wKCk7IGlmICh0IGluIGUpIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBlLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoZSkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB0LCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIWUpIGZvciAodmFyIHIgaW4gdGhpcykgXCJ0XCIgPT09IHIuY2hhckF0KDApICYmIG4uY2FsbCh0aGlzLCByKSAmJiAhaXNOYU4oK3Iuc2xpY2UoMSkpICYmICh0aGlzW3JdID0gdCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgdCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSB0LnR5cGUpIHRocm93IHQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZSkgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBlOyB2YXIgciA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShuLCBvKSB7IHJldHVybiBhLnR5cGUgPSBcInRocm93XCIsIGEuYXJnID0gZSwgci5uZXh0ID0gbiwgbyAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgISFvOyB9IGZvciAodmFyIG8gPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgbyA+PSAwOyAtLW8pIHsgdmFyIGkgPSB0aGlzLnRyeUVudHJpZXNbb10sIGEgPSBpLmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gaS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChpLnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGMgPSBuLmNhbGwoaSwgXCJjYXRjaExvY1wiKSwgdSA9IG4uY2FsbChpLCBcImZpbmFsbHlMb2NcIik7IGlmIChjICYmIHUpIHsgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoYykgeyBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghdSkgdGhyb3cgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShpLmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0LCBlKSB7IGZvciAodmFyIHIgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpIHsgdmFyIG8gPSB0aGlzLnRyeUVudHJpZXNbcl07IGlmIChvLnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgbi5jYWxsKG8sIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBvLmZpbmFsbHlMb2MpIHsgdmFyIGkgPSBvOyBicmVhazsgfSB9IGkgJiYgKFwiYnJlYWtcIiA9PT0gdCB8fCBcImNvbnRpbnVlXCIgPT09IHQpICYmIGkudHJ5TG9jIDw9IGUgJiYgZSA8PSBpLmZpbmFsbHlMb2MgJiYgKGkgPSBudWxsKTsgdmFyIGEgPSBpID8gaS5jb21wbGV0aW9uIDoge307IHJldHVybiBhLnR5cGUgPSB0LCBhLmFyZyA9IGUsIGkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gaS5maW5hbGx5TG9jLCB5KSA6IHRoaXMuY29tcGxldGUoYSk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh0LCBlKSB7IGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHQudHlwZSA/IHRoaXMubmV4dCA9IHQuYXJnIDogXCJyZXR1cm5cIiA9PT0gdC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gdC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSB0LnR5cGUgJiYgZSAmJiAodGhpcy5uZXh0ID0gZSksIHk7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHQpIHsgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkgeyB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTsgaWYgKHIuZmluYWxseUxvYyA9PT0gdCkgcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLCByLmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShyKSwgeTsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0KSB7IGZvciAodmFyIGUgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpIHsgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07IGlmIChyLnRyeUxvYyA9PT0gdCkgeyB2YXIgbiA9IHIuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gbi50eXBlKSB7IHZhciBvID0gbi5hcmc7IHJlc2V0VHJ5RW50cnkocik7IH0gcmV0dXJuIG87IH0gfSB0aHJvdyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChlLCByLCBuKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGUpLCByZXN1bHROYW1lOiByLCBuZXh0TG9jOiBuIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB0KSwgeTsgfSB9LCBlOyB9XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAobiwgdCwgZSwgciwgbywgYSwgYykgeyB0cnkgeyB2YXIgaSA9IG5bYV0oYyksIHUgPSBpLnZhbHVlOyB9IGNhdGNoIChuKSB7IHJldHVybiB2b2lkIGUobik7IH0gaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pOyB9XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcywgZSA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7IHZhciBhID0gbi5hcHBseSh0LCBlKTsgZnVuY3Rpb24gX25leHQobikgeyBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIG4pOyB9IGZ1bmN0aW9uIF90aHJvdyhuKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIG4pOyB9IF9uZXh0KHZvaWQgMCk7IH0pOyB9OyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhlLCB0LCBhKSB7IF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpLCB0LnNldChlLCBhKTsgfVxuZnVuY3Rpb24gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCkgeyBpZiAodC5oYXMoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBwcml2YXRlIGVsZW1lbnRzIHR3aWNlIG9uIGFuIG9iamVjdFwiKTsgfVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHMsIGEpIHsgcmV0dXJuIHMuZ2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpKTsgfVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHMsIGEsIHIpIHsgcmV0dXJuIHMuc2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpLCByKSwgcjsgfVxuZnVuY3Rpb24gX2Fzc2VydENsYXNzQnJhbmQoZSwgdCwgbikgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA9PT0gdCA6IGUuaGFzKHQpKSByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0IDogbjsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgZWxlbWVudCBpcyBub3QgcHJlc2VudCBvbiB0aGlzIG9iamVjdFwiKTsgfVxuXG5cbi8qKlxuICogUmVwbGF5TWFwIC0gTWFuYWdlcyB0aGUgbWFwcGluZyBiZXR3ZWVuIGVycm9yIG9jY3VycmVuY2VzIGFuZCB0aGVpciBhc3NvY2lhdGVkXG4gKiBzZXNzaW9uIHJlY29yZGluZ3MuIFRoaXMgY2xhc3MgaGFuZGxlcyB0aGUgY29vcmRpbmF0aW9uIGJldHdlZW4gd2hlbiByZWNvcmRpbmdzXG4gKiBhcmUgZHVtcGVkIGFuZCB3aGVuIHRoZXkgYXJlIGV2ZW50dWFsbHkgc2VudCB0byB0aGUgYmFja2VuZC5cbiAqL1xudmFyIF9tYXAgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfcmVjb3JkZXIgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfYXBpID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX3RyYWNpbmcgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBSZXBsYXlNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSZXBsYXlNYXAgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gQ29uZmlndXJhdGlvbiBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMucmVjb3JkZXIgLSBUaGUgcmVjb3JkZXIgaW5zdGFuY2UgdGhhdCBkdW1wcyByZXBsYXkgZGF0YSBpbnRvIHNwYW5zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5hcGkgLSBUaGUgQVBJIGluc3RhbmNlIHVzZWQgdG8gc2VuZCByZXBsYXkgcGF5bG9hZHMgdG8gdGhlIGJhY2tlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzLnRyYWNpbmcgLSBUaGUgdHJhY2luZyBpbnN0YW5jZSB1c2VkIHRvIGNyZWF0ZSBzcGFucyBhbmQgbWFuYWdlIGNvbnRleHRcbiAgICovXG4gIGZ1bmN0aW9uIFJlcGxheU1hcChfcmVmKSB7XG4gICAgdmFyIHJlY29yZGVyID0gX3JlZi5yZWNvcmRlcixcbiAgICAgIGFwaSA9IF9yZWYuYXBpLFxuICAgICAgdHJhY2luZyA9IF9yZWYudHJhY2luZztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwbGF5TWFwKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyh0aGlzLCBfbWFwLCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9yZWNvcmRlciwgdm9pZCAwKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyh0aGlzLCBfYXBpLCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF90cmFjaW5nLCB2b2lkIDApO1xuICAgIGlmICghcmVjb3JkZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAncmVjb3JkZXInIHRvIGJlIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBpZiAoIWFwaSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdhcGknIHRvIGJlIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBpZiAoIXRyYWNpbmcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAndHJhY2luZycgdG8gYmUgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfbWFwLCB0aGlzLCBuZXcgTWFwKCkpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfcmVjb3JkZXIsIHRoaXMsIHJlY29yZGVyKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX2FwaSwgdGhpcywgYXBpKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX3RyYWNpbmcsIHRoaXMsIHRyYWNpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHJlcGxheSBieSBjb252ZXJ0aW5nIHJlY29yZGVyIGV2ZW50cyBpbnRvIGEgdHJhbnNwb3J0LXJlYWR5IHBheWxvYWQuXG4gICAqXG4gICAqIENhbGxzIHJlY29yZGVyLmR1bXAoKSB0byBjYXB0dXJlIGV2ZW50cyBhcyBzcGFucywgZm9ybWF0cyB0aGVtIGludG8gYSBwcm9wZXIgcGF5bG9hZCxcbiAgICogYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBtYXAgdXNpbmcgcmVwbGF5SWQgYXMgdGhlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIHVuaXF1ZSBJRCBmb3IgdGhpcyByZXBsYXlcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJvY2Vzc2VkIHJlcGxheUlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlcGxheU1hcCwgW3tcbiAgICBrZXk6IFwiX3Byb2Nlc3NSZXBsYXlcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcHJvY2Vzc1JlcGxheTIgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXBsYXlJZCwgb2NjdXJyZW5jZVV1aWQpIHtcbiAgICAgICAgdmFyIHBheWxvYWQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IF9jbGFzc1ByaXZhdGVGaWVsZEdldChfcmVjb3JkZXIsIHRoaXMpLmR1bXAoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF90cmFjaW5nLCB0aGlzKSwgcmVwbGF5SWQsIG9jY3VycmVuY2VVdWlkKTtcbiAgICAgICAgICAgICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQoX21hcCwgdGhpcykuc2V0KHJlcGxheUlkLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAodHJhbnNmb3JtRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0cmFuc2Zvcm1pbmcgc3BhbnM6JywgdHJhbnNmb3JtRXJyb3IpO1xuICAgICAgICAgICAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldChfbWFwLCB0aGlzKS5zZXQocmVwbGF5SWQsIG51bGwpOyAvLyBUT0RPKG1hdHV4KTogRXJyb3Igc3Bhbj9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlcGxheUlkKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gX3Byb2Nlc3NSZXBsYXkoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX3Byb2Nlc3NSZXBsYXkyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Byb2Nlc3NSZXBsYXk7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlcGxheSB0byB0aGUgbWFwIGFuZCByZXR1cm5zIGEgdW5pcXVlbHkgZ2VuZXJhdGVkIHJlcGxheSBJRC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgdGhlIHJlcGxheUlkIGFuZCBhc3luY2hyb25vdXNseSBwcm9jZXNzZXNcbiAgICAgKiB0aGUgcmVwbGF5IGRhdGEgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBwcm9jZXNzaW5nIGludm9sdmVzIGNvbnZlcnRpbmdcbiAgICAgKiByZWNvcmRlciBldmVudHMgaW50byBhIHBheWxvYWQgZm9ybWF0IGFuZCBzdG9yaW5nIGl0IGluIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHJlcGxheVxuICAgICAqL1xuICAgIClcbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG9jY3VycmVuY2VVdWlkKSB7XG4gICAgICB2YXIgcmVwbGF5SWQgPSBfdHJhY2luZ19pZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogW1wiZGVmYXVsdFwiXSAqLyAuQS5nZW4oOCk7XG4gICAgICB0aGlzLl9wcm9jZXNzUmVwbGF5KHJlcGxheUlkLCBvY2N1cnJlbmNlVXVpZClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgcmVwbGF5OicsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcGxheUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSByZXBsYXkgcGF5bG9hZCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHJlcGxheUlkIHRvIHRoZSBiYWNrZW5kXG4gICAgICogYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIHRoZSBwYXlsb2FkIGZyb20gdGhlIG1hcCwgY2hlY2tzIGlmIGl0J3MgdmFsaWQsIHRoZW4gc2VuZHMgaXRcbiAgICAgKiB0byB0aGUgQVBJIGVuZHBvaW50IGZvciBwcm9jZXNzaW5nLiBUaGUgcGF5bG9hZCBjYW4gYmUgZWl0aGVyIGEgc3BhbnMgYXJyYXlcbiAgICAgKiBvciBhIGZvcm1hdHRlZCBPVExQIHBheWxvYWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIElEIG9mIHRoZSByZXBsYXkgdG8gc2VuZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSBwYXlsb2FkIHdhcyBmb3VuZCBhbmQgc2VudCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZW5kID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlcGxheUlkKSB7XG4gICAgICAgIHZhciBwYXlsb2FkLCBpc0VtcHR5O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKHJlcGxheUlkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVwbGF5TWFwLnNlbmQ6IE5vIHJlcGxheUlkIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKF9jbGFzc1ByaXZhdGVGaWVsZEdldChfbWFwLCB0aGlzKS5oYXMocmVwbGF5SWQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlJlcGxheU1hcC5zZW5kOiBObyByZXBsYXkgZm91bmQgZm9yIHJlcGxheUlkOiBcIi5jb25jYXQocmVwbGF5SWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBwYXlsb2FkID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9tYXAsIHRoaXMpLmdldChyZXBsYXlJZCk7XG4gICAgICAgICAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldChfbWFwLCB0aGlzKVtcImRlbGV0ZVwiXShyZXBsYXlJZCk7XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bG9hZCBpcyBlbXB0eSAoY291bGQgYmUgcmF3IHNwYW5zIGFycmF5IG9yIE9UTFAgcGF5bG9hZClcbiAgICAgICAgICAgICAgaXNFbXB0eSA9ICFwYXlsb2FkIHx8IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiYgcGF5bG9hZC5sZW5ndGggPT09IDAgfHwgcGF5bG9hZC5yZXNvdXJjZVNwYW5zICYmIHBheWxvYWQucmVzb3VyY2VTcGFucy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVwbGF5TWFwLnNlbmQ6IE5vIHBheWxvYWQgZm91bmQgZm9yIHJlcGxheUlkOiBcIi5jb25jYXQocmVwbGF5SWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldChfYXBpLCB0aGlzKS5wb3N0U3BhbnMocGF5bG9hZCk7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDEyKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyByZXBsYXk6JywgX2NvbnRleHQyLnQwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1sxMiwgMThdXSk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBzZW5kKF94Mykge1xuICAgICAgICByZXR1cm4gX3NlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIERpc2NhcmRzIHRoZSByZXBsYXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiByZXBsYXkgSUQgYnkgcmVtb3ZpbmdcbiAgICAgKiBpdCBmcm9tIHRoZSBtYXAgd2l0aG91dCBzZW5kaW5nIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIElEIG9mIHRoZSByZXBsYXkgdG8gZGlzY2FyZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGEgcmVwbGF5IHdhcyBmb3VuZCBhbmQgZGlzY2FyZGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICApXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjYXJkKHJlcGxheUlkKSB7XG4gICAgICBpZiAoIXJlcGxheUlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUmVwbGF5TWFwLmRpc2NhcmQ6IE5vIHJlcGxheUlkIHByb3ZpZGVkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9tYXAsIHRoaXMpLmhhcyhyZXBsYXlJZCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUmVwbGF5TWFwLmRpc2NhcmQ6IE5vIHJlcGxheSBmb3VuZCBmb3IgcmVwbGF5SWQ6IFwiLmNvbmNhdChyZXBsYXlJZCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQoX21hcCwgdGhpcylbXCJkZWxldGVcIl0ocmVwbGF5SWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzcGFucyBmb3IgdGhlIGdpdmVuIHJlcGxheSBJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIElEIHRvIHJldHJpZXZlIHNwYW5zIGZvclxuICAgICAqIEByZXR1cm5zIHtBcnJheXxudWxsfSBUaGUgc3BhbnMgYXJyYXkgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTcGFuc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcGFucyhyZXBsYXlJZCkge1xuICAgICAgdmFyIF9jbGFzc1ByaXZhdGVGaWVsZEdldDI7XG4gICAgICByZXR1cm4gKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIgPSBfY2xhc3NQcml2YXRlRmllbGRHZXQoX21hcCwgdGhpcykuZ2V0KHJlcGxheUlkKSkgIT09IG51bGwgJiYgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MiAhPT0gdm9pZCAwID8gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MiA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzcGFucyBmb3IgYSBnaXZlbiByZXBsYXkgSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYXlJZCAtIFRoZSBJRCB0byBzZXQgc3BhbnMgZm9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BhbnMgLSBUaGUgc3BhbnMgdG8gc2V0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3BhbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3BhbnMocmVwbGF5SWQsIHNwYW5zKSB7XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQoX21hcCwgdGhpcykuc2V0KHJlcGxheUlkLCBzcGFucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgbWFwIChudW1iZXIgb2Ygc3RvcmVkIHJlcGxheXMpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJlcGxheXMgY3VycmVudGx5IHN0b3JlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY2xhc3NQcml2YXRlRmllbGRHZXQoX21hcCwgdGhpcykuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHN0b3JlZCByZXBsYXlzIHdpdGhvdXQgc2VuZGluZyB0aGVtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQoX21hcCwgdGhpcykuY2xlYXIoKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvbjogJzMuMC4wLWFscGhhLjAnLFxuICBlbmRwb2ludDogJ2FwaS5yb2xsYmFyLmNvbS9hcGkvMS9pdGVtLycsXG4gIGxvZ0xldmVsOiAnZGVidWcnLFxuICByZXBvcnRMZXZlbDogJ2RlYnVnJyxcbiAgdW5jYXVnaHRFcnJvckxldmVsOiAnZXJyb3InLFxuICBtYXhJdGVtczogMCxcbiAgaXRlbXNQZXJNaW46IDYwXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzc5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xuZnVuY3Rpb24gY2hlY2tMZXZlbChpdGVtLCBzZXR0aW5ncykge1xuICB2YXIgbGV2ZWwgPSBpdGVtLmxldmVsO1xuICB2YXIgbGV2ZWxWYWwgPSBfLkxFVkVMU1tsZXZlbF0gfHwgMDtcbiAgdmFyIHJlcG9ydExldmVsID0gc2V0dGluZ3MucmVwb3J0TGV2ZWw7XG4gIHZhciByZXBvcnRMZXZlbFZhbCA9IF8uTEVWRUxTW3JlcG9ydExldmVsXSB8fCAwO1xuICBpZiAobGV2ZWxWYWwgPCByZXBvcnRMZXZlbFZhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVzZXJDaGVja0lnbm9yZShsb2dnZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBzZXR0aW5ncykge1xuICAgIHZhciBpc1VuY2F1Z2h0ID0gISFpdGVtLl9pc1VuY2F1Z2h0O1xuICAgIGRlbGV0ZSBpdGVtLl9pc1VuY2F1Z2h0O1xuICAgIHZhciBhcmdzID0gaXRlbS5fb3JpZ2luYWxBcmdzO1xuICAgIGRlbGV0ZSBpdGVtLl9vcmlnaW5hbEFyZ3M7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oc2V0dGluZ3Mub25TZW5kQ2FsbGJhY2spKSB7XG4gICAgICAgIHNldHRpbmdzLm9uU2VuZENhbGxiYWNrKGlzVW5jYXVnaHQsIGFyZ3MsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldHRpbmdzLm9uU2VuZENhbGxiYWNrID0gbnVsbDtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgY2FsbGluZyBvblNlbmRDYWxsYmFjaywgcmVtb3ZpbmcnLCBlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oc2V0dGluZ3MuY2hlY2tJZ25vcmUpICYmIHNldHRpbmdzLmNoZWNrSWdub3JlKGlzVW5jYXVnaHQsIGFyZ3MsIGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZXR0aW5ncy5jaGVja0lnbm9yZSA9IG51bGw7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIGNhbGxpbmcgY3VzdG9tIGNoZWNrSWdub3JlKCksIHJlbW92aW5nJywgZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gdXJsSXNOb3RCbG9ja0xpc3RlZChsb2dnZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBzZXR0aW5ncykge1xuICAgIHJldHVybiAhdXJsSXNPbkFMaXN0KGl0ZW0sIHNldHRpbmdzLCAnYmxvY2tsaXN0JywgbG9nZ2VyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVybElzU2FmZUxpc3RlZChsb2dnZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBzZXR0aW5ncykge1xuICAgIHJldHVybiB1cmxJc09uQUxpc3QoaXRlbSwgc2V0dGluZ3MsICdzYWZlbGlzdCcsIGxvZ2dlcik7XG4gIH07XG59XG5mdW5jdGlvbiBtYXRjaEZyYW1lcyh0cmFjZSwgbGlzdCwgYmxvY2spIHtcbiAgaWYgKCF0cmFjZSkge1xuICAgIHJldHVybiAhYmxvY2s7XG4gIH1cbiAgdmFyIGZyYW1lcyA9IHRyYWNlLmZyYW1lcztcbiAgaWYgKCFmcmFtZXMgfHwgZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAhYmxvY2s7XG4gIH1cbiAgdmFyIGZyYW1lLCBmaWxlbmFtZSwgdXJsLCB1cmxSZWdleDtcbiAgdmFyIGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGZyYW1lTGVuZ3RoID0gZnJhbWVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZUxlbmd0aDsgaSsrKSB7XG4gICAgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgZmlsZW5hbWUgPSBmcmFtZS5maWxlbmFtZTtcbiAgICBpZiAoIV8uaXNUeXBlKGZpbGVuYW1lLCAnc3RyaW5nJykpIHtcbiAgICAgIHJldHVybiAhYmxvY2s7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlzdExlbmd0aDsgaisrKSB7XG4gICAgICB1cmwgPSBsaXN0W2pdO1xuICAgICAgdXJsUmVnZXggPSBuZXcgUmVnRXhwKHVybCk7XG4gICAgICBpZiAodXJsUmVnZXgudGVzdChmaWxlbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVybElzT25BTGlzdChpdGVtLCBzZXR0aW5ncywgc2FmZU9yQmxvY2ssIGxvZ2dlcikge1xuICAvLyBzYWZlbGlzdCBpcyB0aGUgZGVmYXVsdFxuICB2YXIgYmxvY2sgPSBmYWxzZTtcbiAgaWYgKHNhZmVPckJsb2NrID09PSAnYmxvY2tsaXN0Jykge1xuICAgIGJsb2NrID0gdHJ1ZTtcbiAgfVxuICB2YXIgbGlzdCwgdHJhY2VzO1xuICB0cnkge1xuICAgIGxpc3QgPSBibG9jayA/IHNldHRpbmdzLmhvc3RCbG9ja0xpc3QgOiBzZXR0aW5ncy5ob3N0U2FmZUxpc3Q7XG4gICAgdHJhY2VzID0gXy5nZXQoaXRlbSwgJ2JvZHkudHJhY2VfY2hhaW4nKSB8fCBbXy5nZXQoaXRlbSwgJ2JvZHkudHJhY2UnKV07XG5cbiAgICAvLyBUaGVzZSB0d28gY2hlY2tzIGFyZSBpbXBvcnRhbnQgdG8gY29tZSBmaXJzdCBhcyB0aGV5IGFyZSBkZWZhdWx0c1xuICAgIC8vIGluIGNhc2UgdGhlIGxpc3QgaXMgbWlzc2luZyBvciB0aGUgdHJhY2UgaXMgbWlzc2luZyBvciBub3Qgd2VsbC1mb3JtZWRcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAhYmxvY2s7XG4gICAgfVxuICAgIGlmICh0cmFjZXMubGVuZ3RoID09PSAwIHx8ICF0cmFjZXNbMF0pIHtcbiAgICAgIHJldHVybiAhYmxvY2s7XG4gICAgfVxuICAgIHZhciB0cmFjZXNMZW5ndGggPSB0cmFjZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtYXRjaEZyYW1lcyh0cmFjZXNbaV0sIGxpc3QsIGJsb2NrKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8pIHtcbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIHNldHRpbmdzLmhvc3RCbG9ja0xpc3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0aW5ncy5ob3N0U2FmZUxpc3QgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbGlzdE5hbWUgPSBibG9jayA/ICdob3N0QmxvY2tMaXN0JyA6ICdob3N0U2FmZUxpc3QnO1xuICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHdoaWxlIHJlYWRpbmcgeW91ciBjb25maWd1cmF0aW9uJ3MgXCIgKyBsaXN0TmFtZSArICcgb3B0aW9uLiBSZW1vdmluZyBjdXN0b20gJyArIGxpc3ROYW1lICsgJy4nLCBlKTtcbiAgICByZXR1cm4gIWJsb2NrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VJc0lnbm9yZWQobG9nZ2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgaSwgaiwgaWdub3JlZE1lc3NhZ2VzLCBsZW4sIG1lc3NhZ2VJc0lnbm9yZWQsIHJJZ25vcmVkTWVzc2FnZSwgbWVzc2FnZXM7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2VJc0lnbm9yZWQgPSBmYWxzZTtcbiAgICAgIGlnbm9yZWRNZXNzYWdlcyA9IHNldHRpbmdzLmlnbm9yZWRNZXNzYWdlcztcbiAgICAgIGlmICghaWdub3JlZE1lc3NhZ2VzIHx8IGlnbm9yZWRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzRnJvbUl0ZW0oaXRlbSk7XG4gICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGVuID0gaWdub3JlZE1lc3NhZ2VzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBySWdub3JlZE1lc3NhZ2UgPSBuZXcgUmVnRXhwKGlnbm9yZWRNZXNzYWdlc1tpXSwgJ2dpJyk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBtZXNzYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG1lc3NhZ2VJc0lnbm9yZWQgPSBySWdub3JlZE1lc3NhZ2UudGVzdChtZXNzYWdlc1tqXSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2VJc0lnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8pIHtcbiAgICAgIHNldHRpbmdzLmlnbm9yZWRNZXNzYWdlcyA9IG51bGw7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciB3aGlsZSByZWFkaW5nIHlvdXIgY29uZmlndXJhdGlvbidzIGlnbm9yZWRNZXNzYWdlcyBvcHRpb24uIFJlbW92aW5nIGN1c3RvbSBpZ25vcmVkTWVzc2FnZXMuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VzRnJvbUl0ZW0oaXRlbSkge1xuICB2YXIgYm9keSA9IGl0ZW0uYm9keTtcbiAgdmFyIG1lc3NhZ2VzID0gW107XG5cbiAgLy8gVGhlIHBheWxvYWQgc2NoZW1hIG9ubHkgYWxsb3dzIG9uZSBvZiB0cmFjZV9jaGFpbiwgbWVzc2FnZSwgb3IgdHJhY2UuXG4gIC8vIEhvd2V2ZXIsIGV4aXN0aW5nIHRlc3QgY2FzZXMgYXJlIGJhc2VkIG9uIGhhdmluZyBib3RoIHRyYWNlIGFuZCBtZXNzYWdlIHByZXNlbnQuXG4gIC8vIFNvIGhlcmUgd2UgcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gY29sbGVjdCBzdHJpbmdzIGZyb20gYW55IGNvbWJpbmF0aW9uIG9mIHRoZXNlIGtleXMuXG4gIGlmIChib2R5LnRyYWNlX2NoYWluKSB7XG4gICAgdmFyIHRyYWNlQ2hhaW4gPSBib2R5LnRyYWNlX2NoYWluO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VDaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNlID0gdHJhY2VDaGFpbltpXTtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXy5nZXQodHJhY2UsICdleGNlcHRpb24ubWVzc2FnZScpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGJvZHkudHJhY2UpIHtcbiAgICBtZXNzYWdlcy5wdXNoKF8uZ2V0KGJvZHksICd0cmFjZS5leGNlcHRpb24ubWVzc2FnZScpKTtcbiAgfVxuICBpZiAoYm9keS5tZXNzYWdlKSB7XG4gICAgbWVzc2FnZXMucHVzaChfLmdldChib2R5LCAnbWVzc2FnZS5ib2R5JykpO1xuICB9XG4gIHJldHVybiBtZXNzYWdlcztcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja0xldmVsOiBjaGVja0xldmVsLFxuICB1c2VyQ2hlY2tJZ25vcmU6IHVzZXJDaGVja0lnbm9yZSxcbiAgdXJsSXNOb3RCbG9ja0xpc3RlZDogdXJsSXNOb3RCbG9ja0xpc3RlZCxcbiAgdXJsSXNTYWZlTGlzdGVkOiB1cmxJc1NhZmVMaXN0ZWQsXG4gIG1lc3NhZ2VJc0lnbm9yZWQ6IG1lc3NhZ2VJc0lnbm9yZWRcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzOTI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUeXBlKGUpIHtcbiAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXNEZXNjcmliZWRFbGVtZW50KGVsZW1lbnQsIHR5cGUsIHN1YnR5cGVzKSB7XG4gIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghc3VidHlwZXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbGVtZW50ID0gZ2V0RWxlbWVudFR5cGUoZWxlbWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3VidHlwZXNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50RnJvbUV2ZW50KGV2dCwgZG9jKSB7XG4gIGlmIChldnQudGFyZ2V0KSB7XG4gICAgcmV0dXJuIGV2dC50YXJnZXQ7XG4gIH1cbiAgaWYgKGRvYyAmJiBkb2MuZWxlbWVudEZyb21Qb2ludCkge1xuICAgIHJldHVybiBkb2MuZWxlbWVudEZyb21Qb2ludChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0cmVlVG9BcnJheShlbGVtKSB7XG4gIHZhciBNQVhfSEVJR0hUID0gNTtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgbmV4dERlc2NyaXB0aW9uO1xuICBmb3IgKHZhciBoZWlnaHQgPSAwOyBlbGVtICYmIGhlaWdodCA8IE1BWF9IRUlHSFQ7IGhlaWdodCsrKSB7XG4gICAgbmV4dERlc2NyaXB0aW9uID0gZGVzY3JpYmVFbGVtZW50KGVsZW0pO1xuICAgIGlmIChuZXh0RGVzY3JpcHRpb24udGFnTmFtZSA9PT0gJ2h0bWwnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3V0LnVuc2hpZnQobmV4dERlc2NyaXB0aW9uKTtcbiAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBlbGVtZW50QXJyYXlUb1N0cmluZyhhKSB7XG4gIHZhciBNQVhfTEVOR1RIID0gODA7XG4gIHZhciBzZXBhcmF0b3IgPSAnID4gJyxcbiAgICBzZXBhcmF0b3JMZW5ndGggPSBzZXBhcmF0b3IubGVuZ3RoO1xuICB2YXIgb3V0ID0gW10sXG4gICAgbGVuID0gMCxcbiAgICBuZXh0U3RyLFxuICAgIHRvdGFsTGVuZ3RoO1xuICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG5leHRTdHIgPSBkZXNjcmlwdGlvblRvU3RyaW5nKGFbaV0pO1xuICAgIHRvdGFsTGVuZ3RoID0gbGVuICsgb3V0Lmxlbmd0aCAqIHNlcGFyYXRvckxlbmd0aCArIG5leHRTdHIubGVuZ3RoO1xuICAgIGlmIChpIDwgYS5sZW5ndGggLSAxICYmIHRvdGFsTGVuZ3RoID49IE1BWF9MRU5HVEggKyAzKSB7XG4gICAgICBvdXQudW5zaGlmdCgnLi4uJyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3V0LnVuc2hpZnQobmV4dFN0cik7XG4gICAgbGVuICs9IG5leHRTdHIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBvdXQuam9pbihzZXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gZGVzY3JpcHRpb25Ub1N0cmluZyhkZXNjKSB7XG4gIGlmICghZGVzYyB8fCAhZGVzYy50YWdOYW1lKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBvdXQgPSBbZGVzYy50YWdOYW1lXTtcbiAgaWYgKGRlc2MuaWQpIHtcbiAgICBvdXQucHVzaCgnIycgKyBkZXNjLmlkKTtcbiAgfVxuICBpZiAoZGVzYy5jbGFzc2VzKSB7XG4gICAgb3V0LnB1c2goJy4nICsgZGVzYy5jbGFzc2VzLmpvaW4oJy4nKSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXQucHVzaCgnWycgKyBkZXNjLmF0dHJpYnV0ZXNbaV0ua2V5ICsgJz1cIicgKyBkZXNjLmF0dHJpYnV0ZXNbaV0udmFsdWUgKyAnXCJdJyk7XG4gIH1cbiAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBJbnB1dDogYSBkb20gZWxlbWVudFxuICogT3V0cHV0OiBudWxsIGlmIHRhZ05hbWUgaXMgZmFsc2V5IG9yIGlucHV0IGlzIGZhbHNleSwgZWxzZVxuICogIHtcbiAqICAgIHRhZ05hbWU6IFN0cmluZyxcbiAqICAgIGlkOiBTdHJpbmcgfCB1bmRlZmluZWQsXG4gKiAgICBjbGFzc2VzOiBbU3RyaW5nXSB8IHVuZGVmaW5lZCxcbiAqICAgIGF0dHJpYnV0ZXM6IFtcbiAqICAgICAge1xuICogICAgICAgIGtleTogT25lT2YodHlwZSwgbmFtZSwgdGl0bGUsIGFsdCksXG4gKiAgICAgICAgdmFsdWU6IFN0cmluZ1xuICogICAgICB9XG4gKiAgICBdXG4gKiAgfVxuICovXG5mdW5jdGlvbiBkZXNjcmliZUVsZW1lbnQoZWxlbSkge1xuICBpZiAoIWVsZW0gfHwgIWVsZW0udGFnTmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBvdXQgPSB7fSxcbiAgICBjbGFzc05hbWUsXG4gICAga2V5LFxuICAgIGF0dHIsXG4gICAgaTtcbiAgb3V0LnRhZ05hbWUgPSBlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGVsZW0uaWQpIHtcbiAgICBvdXQuaWQgPSBlbGVtLmlkO1xuICB9XG4gIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lO1xuICBpZiAoY2xhc3NOYW1lICYmIHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgb3V0LmNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgfVxuICB2YXIgYXR0cmlidXRlcyA9IFsndHlwZScsICduYW1lJywgJ3RpdGxlJywgJ2FsdCddO1xuICBvdXQuYXR0cmlidXRlcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIG91dC5hdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGF0dHJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc2NyaWJlRWxlbWVudDogZGVzY3JpYmVFbGVtZW50LFxuICBkZXNjcmlwdGlvblRvU3RyaW5nOiBkZXNjcmlwdGlvblRvU3RyaW5nLFxuICBlbGVtZW50QXJyYXlUb1N0cmluZzogZWxlbWVudEFycmF5VG9TdHJpbmcsXG4gIHRyZWVUb0FycmF5OiB0cmVlVG9BcnJheSxcbiAgZ2V0RWxlbWVudEZyb21FdmVudDogZ2V0RWxlbWVudEZyb21FdmVudCxcbiAgaXNEZXNjcmliZWRFbGVtZW50OiBpc0Rlc2NyaWJlZEVsZW1lbnQsXG4gIGdldEVsZW1lbnRUeXBlOiBnZXRFbGVtZW50VHlwZVxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDM5ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gcmVwbGFjZShvYmosIG5hbWUsIHJlcGxhY2VtZW50LCByZXBsYWNlbWVudHMsIHR5cGUpIHtcbiAgdmFyIG9yaWcgPSBvYmpbbmFtZV07XG4gIG9ialtuYW1lXSA9IHJlcGxhY2VtZW50KG9yaWcpO1xuICBpZiAocmVwbGFjZW1lbnRzKSB7XG4gICAgcmVwbGFjZW1lbnRzW3R5cGVdLnB1c2goW29iaiwgbmFtZSwgb3JpZ10pO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHJlcGxhY2U7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFJvbGxiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4Myk7XG52YXIgdGVsZW1ldGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTgpO1xudmFyIGluc3RydW1lbnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNzA1KTtcbnZhciBwb2x5ZmlsbEpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1Nyk7XG52YXIgd3JhcEdsb2JhbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNik7XG52YXIgc2NydWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMik7XG52YXIgdHJ1bmNhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjIyKTtcbnZhciBUcmFjaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjkpO1xudmFyIFJlY29yZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTgpO1xuUm9sbGJhci5zZXRDb21wb25lbnRzKHtcbiAgdGVsZW1ldGVyOiB0ZWxlbWV0ZXIsXG4gIGluc3RydW1lbnRlcjogaW5zdHJ1bWVudGVyLFxuICBwb2x5ZmlsbEpTT046IHBvbHlmaWxsSlNPTixcbiAgd3JhcEdsb2JhbHM6IHdyYXBHbG9iYWxzLFxuICBzY3J1Yjogc2NydWIsXG4gIHRydW5jYXRpb246IHRydW5jYXRpb24sXG4gIHRyYWNpbmc6IFRyYWNpbmdbXCJkZWZhdWx0XCJdLFxuICByZWNvcmRlcjogUmVjb3JkZXJbXCJkZWZhdWx0XCJdXG59KTtcbm1vZHVsZS5leHBvcnRzID0gUm9sbGJhcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDQyODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9sbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oNDAyKTtcbnZhciBvcHRpb25zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9yb2xsYmFyQ29uZmlnO1xudmFyIGFsaWFzID0gb3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbEFsaWFzIHx8ICdSb2xsYmFyJztcbnZhciBzaGltUnVubmluZyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1thbGlhc10gJiYgdHlwZW9mIHdpbmRvd1thbGlhc10uc2hpbUlkID09PSAnZnVuY3Rpb24nICYmIHdpbmRvd1thbGlhc10uc2hpbUlkKCkgIT09IHVuZGVmaW5lZDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Ll9yb2xsYmFyU3RhcnRUaW1lKSB7XG4gIHdpbmRvdy5fcm9sbGJhclN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuaWYgKCFzaGltUnVubmluZyAmJiBvcHRpb25zKSB7XG4gIHZhciBSb2xsYmFyID0gbmV3IHJvbGxiYXIob3B0aW9ucyk7XG4gIHdpbmRvd1thbGlhc10gPSBSb2xsYmFyO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cucm9sbGJhciA9IHJvbGxiYXI7XG4gIHdpbmRvdy5fcm9sbGJhckRpZExvYWQgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgc2VsZi5yb2xsYmFyID0gcm9sbGJhcjtcbiAgc2VsZi5fcm9sbGJhckRpZExvYWQgPSB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSByb2xsYmFyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDM2OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiBEZWZhdWx0IHRyYWNpbmcgb3B0aW9uc1xuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIGVuZHBvaW50OiAnYXBpLnJvbGxiYXIuY29tL2FwaS8xL3Nlc3Npb24vJ1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KTtcbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xuZnVuY3Rpb24gbWFrZUZldGNoUmVxdWVzdChhY2Nlc3NUb2tlbiwgdXJsLCBtZXRob2QsIGRhdGEsIGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gIHZhciBjb250cm9sbGVyO1xuICB2YXIgdGltZW91dElkO1xuICBpZiAoXy5pc0Zpbml0ZU51bWJlcih0aW1lb3V0KSkge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cbiAgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdYLVJvbGxiYXItQWNjZXNzLVRva2VuJzogYWNjZXNzVG9rZW4sXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWxcbiAgICB9LFxuICAgIGJvZHk6IGRhdGFcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAodGltZW91dElkKSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VGZXRjaFJlcXVlc3Q7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0ODU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4NSk7XG52YXIgZXJyb3JQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNik7XG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDQpO1xuZnVuY3Rpb24gaGFuZGxlRG9tRXhjZXB0aW9uKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChpdGVtLmVyciAmJiBlcnJvclBhcnNlci5TdGFjayhpdGVtLmVycikubmFtZSA9PT0gJ0RPTUV4Y2VwdGlvbicpIHtcbiAgICB2YXIgb3JpZ2luYWxFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgIG9yaWdpbmFsRXJyb3IubmFtZSA9IGl0ZW0uZXJyLm5hbWU7XG4gICAgb3JpZ2luYWxFcnJvci5tZXNzYWdlID0gaXRlbS5lcnIubWVzc2FnZTtcbiAgICBvcmlnaW5hbEVycm9yLnN0YWNrID0gaXRlbS5lcnIuc3RhY2s7XG4gICAgb3JpZ2luYWxFcnJvci5uZXN0ZWQgPSBpdGVtLmVycjtcbiAgICBpdGVtLmVyciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5mdW5jdGlvbiBoYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGl0ZW0uZGF0YSA9IGl0ZW0uZGF0YSB8fCB7fTtcbiAgaWYgKGl0ZW0uZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGl0ZW0uc3RhY2tJbmZvID0gaXRlbS5lcnIuX3NhdmVkU3RhY2tUcmFjZSB8fCBlcnJvclBhcnNlci5wYXJzZShpdGVtLmVyciwgaXRlbS5za2lwRnJhbWVzKTtcbiAgICAgIGlmIChvcHRpb25zLmFkZEVycm9yQ29udGV4dCkge1xuICAgICAgICBhZGRFcnJvckNvbnRleHQoaXRlbSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBwYXJzaW5nIHRoZSBlcnJvciBvYmplY3QuJywgZSk7XG4gICAgICB0cnkge1xuICAgICAgICBpdGVtLm1lc3NhZ2UgPSBpdGVtLmVyci5tZXNzYWdlIHx8IGl0ZW0uZXJyLmRlc2NyaXB0aW9uIHx8IGl0ZW0ubWVzc2FnZSB8fCBTdHJpbmcoaXRlbS5lcnIpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaXRlbS5tZXNzYWdlID0gU3RyaW5nKGl0ZW0uZXJyKSB8fCBTdHJpbmcoZTIpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGl0ZW0uZXJyO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGFkZEVycm9yQ29udGV4dChpdGVtKSB7XG4gIHZhciBjaGFpbiA9IFtdO1xuICB2YXIgZXJyID0gaXRlbS5lcnI7XG4gIGNoYWluLnB1c2goZXJyKTtcbiAgd2hpbGUgKGVyci5uZXN0ZWQgfHwgZXJyLmNhdXNlKSB7XG4gICAgZXJyID0gZXJyLm5lc3RlZCB8fCBlcnIuY2F1c2U7XG4gICAgY2hhaW4ucHVzaChlcnIpO1xuICB9XG4gIF8uYWRkRXJyb3JDb250ZXh0KGl0ZW0sIGNoYWluKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIWl0ZW0ubWVzc2FnZSAmJiAhaXRlbS5zdGFja0luZm8gJiYgIWl0ZW0uY3VzdG9tKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdObyBtZXNzYWdlLCBzdGFjayBpbmZvLCBvciBjdXN0b20gZGF0YScpLCBudWxsKTtcbiAgfVxuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGFkZEJhc2VJbmZvKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBlbnZpcm9ubWVudCA9IG9wdGlvbnMucGF5bG9hZCAmJiBvcHRpb25zLnBheWxvYWQuZW52aXJvbm1lbnQgfHwgb3B0aW9ucy5lbnZpcm9ubWVudDtcbiAgaXRlbS5kYXRhID0gXy5tZXJnZShpdGVtLmRhdGEsIHtcbiAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgbGV2ZWw6IGl0ZW0ubGV2ZWwsXG4gICAgZW5kcG9pbnQ6IG9wdGlvbnMuZW5kcG9pbnQsXG4gICAgcGxhdGZvcm06ICdicm93c2VyJyxcbiAgICBmcmFtZXdvcms6ICdicm93c2VyLWpzJyxcbiAgICBsYW5ndWFnZTogJ2phdmFzY3JpcHQnLFxuICAgIHNlcnZlcjoge30sXG4gICAgdXVpZDogaXRlbS51dWlkLFxuICAgIG5vdGlmaWVyOiB7XG4gICAgICBuYW1lOiAncm9sbGJhci1icm93c2VyLWpzJyxcbiAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvblxuICAgIH0sXG4gICAgY3VzdG9tOiBpdGVtLmN1c3RvbVxuICB9KTtcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5mdW5jdGlvbiBhZGRSZXF1ZXN0SW5mbyh3aW5kb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IHt9O1xuICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICByZXF1ZXN0SW5mby51cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIHJlcXVlc3RJbmZvLnF1ZXJ5X3N0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gICAgfVxuICAgIHZhciByZW1vdGVTdHJpbmcgPSAnJHJlbW90ZV9pcCc7XG4gICAgaWYgKCFvcHRpb25zLmNhcHR1cmVJcCkge1xuICAgICAgcmVtb3RlU3RyaW5nID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY2FwdHVyZUlwICE9PSB0cnVlKSB7XG4gICAgICByZW1vdGVTdHJpbmcgKz0gJ19hbm9ueW1pemUnO1xuICAgIH1cbiAgICBpZiAocmVtb3RlU3RyaW5nKSByZXF1ZXN0SW5mby51c2VyX2lwID0gcmVtb3RlU3RyaW5nO1xuICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0SW5mbykubGVuZ3RoID4gMCkge1xuICAgICAgXy5zZXQoaXRlbSwgJ2RhdGEucmVxdWVzdCcsIHJlcXVlc3RJbmZvKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gIH07XG59XG5mdW5jdGlvbiBhZGRDbGllbnRJbmZvKHdpbmRvdykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICB9XG4gICAgdmFyIG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3IgfHwge307XG4gICAgdmFyIHNjciA9IHdpbmRvdy5zY3JlZW4gfHwge307XG4gICAgXy5zZXQoaXRlbSwgJ2RhdGEuY2xpZW50Jywge1xuICAgICAgcnVudGltZV9tczogaXRlbS50aW1lc3RhbXAgLSB3aW5kb3cuX3JvbGxiYXJTdGFydFRpbWUsXG4gICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQoaXRlbS50aW1lc3RhbXAgLyAxMDAwKSxcbiAgICAgIGphdmFzY3JpcHQ6IHtcbiAgICAgICAgYnJvd3NlcjogbmF2LnVzZXJBZ2VudCxcbiAgICAgICAgbGFuZ3VhZ2U6IG5hdi5sYW5ndWFnZSxcbiAgICAgICAgY29va2llX2VuYWJsZWQ6IG5hdi5jb29raWVFbmFibGVkLFxuICAgICAgICBzY3JlZW46IHtcbiAgICAgICAgICB3aWR0aDogc2NyLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc2NyLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gIH07XG59XG5mdW5jdGlvbiBhZGRQbHVnaW5JbmZvKHdpbmRvdykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbnMgPSBbXTtcbiAgICB2YXIgbmF2UGx1Z2lucyA9IHdpbmRvdy5uYXZpZ2F0b3IucGx1Z2lucyB8fCBbXTtcbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmF2UGx1Z2lucy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGN1ciA9IG5hdlBsdWdpbnNbaV07XG4gICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICBuYW1lOiBjdXIubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGN1ci5kZXNjcmlwdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIF8uc2V0KGl0ZW0sICdkYXRhLmNsaWVudC5qYXZhc2NyaXB0LnBsdWdpbnMnLCBwbHVnaW5zKTtcbiAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZEJvZHkoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGl0ZW0uc3RhY2tJbmZvKSB7XG4gICAgaWYgKGl0ZW0uc3RhY2tJbmZvLnRyYWNlQ2hhaW4pIHtcbiAgICAgIGFkZEJvZHlUcmFjZUNoYWluKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQm9keVRyYWNlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWRkQm9keU1lc3NhZ2UoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG59XG5mdW5jdGlvbiBhZGRCb2R5TWVzc2FnZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9IGl0ZW0ubWVzc2FnZTtcbiAgdmFyIGN1c3RvbSA9IGl0ZW0uY3VzdG9tO1xuICBpZiAoIW1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gJ0l0ZW0gc2VudCB3aXRoIG51bGwgb3IgbWlzc2luZyBhcmd1bWVudHMuJztcbiAgfVxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGJvZHk6IG1lc3NhZ2VcbiAgfTtcbiAgaWYgKGN1c3RvbSkge1xuICAgIHJlc3VsdC5leHRyYSA9IF8ubWVyZ2UoY3VzdG9tKTtcbiAgfVxuICBfLnNldChpdGVtLCAnZGF0YS5ib2R5Jywge1xuICAgIG1lc3NhZ2U6IHJlc3VsdFxuICB9KTtcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5mdW5jdGlvbiBzdGFja0Zyb21JdGVtKGl0ZW0pIHtcbiAgLy8gVHJhbnNmb3JtIGEgVHJhY2VLaXQgc3RhY2tJbmZvIG9iamVjdCBpbnRvIGEgUm9sbGJhciB0cmFjZVxuICB2YXIgc3RhY2sgPSBpdGVtLnN0YWNrSW5mby5zdGFjaztcbiAgaWYgKHN0YWNrICYmIHN0YWNrLmxlbmd0aCA9PT0gMCAmJiBpdGVtLl91bmhhbmRsZWRTdGFja0luZm8gJiYgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvLnN0YWNrKSB7XG4gICAgc3RhY2sgPSBpdGVtLl91bmhhbmRsZWRTdGFja0luZm8uc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHN0YWNrO1xufVxuZnVuY3Rpb24gYWRkQm9keVRyYWNlQ2hhaW4oaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHRyYWNlQ2hhaW4gPSBpdGVtLnN0YWNrSW5mby50cmFjZUNoYWluO1xuICB2YXIgdHJhY2VzID0gW107XG4gIHZhciB0cmFjZUNoYWluTGVuZ3RoID0gdHJhY2VDaGFpbi5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VDaGFpbkxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRyYWNlID0gYnVpbGRUcmFjZShpdGVtLCB0cmFjZUNoYWluW2ldLCBvcHRpb25zKTtcbiAgICB0cmFjZXMucHVzaCh0cmFjZSk7XG4gIH1cbiAgXy5zZXQoaXRlbSwgJ2RhdGEuYm9keScsIHtcbiAgICB0cmFjZV9jaGFpbjogdHJhY2VzXG4gIH0pO1xuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGFkZEJvZHlUcmFjZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgc3RhY2sgPSBzdGFja0Zyb21JdGVtKGl0ZW0pO1xuICBpZiAoc3RhY2spIHtcbiAgICB2YXIgdHJhY2UgPSBidWlsZFRyYWNlKGl0ZW0sIGl0ZW0uc3RhY2tJbmZvLCBvcHRpb25zKTtcbiAgICBfLnNldChpdGVtLCAnZGF0YS5ib2R5Jywge1xuICAgICAgdHJhY2U6IHRyYWNlXG4gICAgfSk7XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YWNrSW5mbyA9IGl0ZW0uc3RhY2tJbmZvO1xuICAgIHZhciBndWVzcyA9IGVycm9yUGFyc2VyLmd1ZXNzRXJyb3JDbGFzcyhzdGFja0luZm8ubWVzc2FnZSk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGVycm9yQ2xhc3Moc3RhY2tJbmZvLCBndWVzc1swXSwgb3B0aW9ucyk7XG4gICAgdmFyIG1lc3NhZ2UgPSBndWVzc1sxXTtcbiAgICBpdGVtLm1lc3NhZ2UgPSBjbGFzc05hbWUgKyAnOiAnICsgbWVzc2FnZTtcbiAgICBhZGRCb2R5TWVzc2FnZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVHJhY2UoaXRlbSwgc3RhY2tJbmZvLCBvcHRpb25zKSB7XG4gIHZhciBkZXNjcmlwdGlvbiA9IGl0ZW0gJiYgaXRlbS5kYXRhLmRlc2NyaXB0aW9uO1xuICB2YXIgY3VzdG9tID0gaXRlbSAmJiBpdGVtLmN1c3RvbTtcbiAgdmFyIHN0YWNrID0gc3RhY2tGcm9tSXRlbShpdGVtKTtcbiAgdmFyIGd1ZXNzID0gZXJyb3JQYXJzZXIuZ3Vlc3NFcnJvckNsYXNzKHN0YWNrSW5mby5tZXNzYWdlKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGVycm9yQ2xhc3Moc3RhY2tJbmZvLCBndWVzc1swXSwgb3B0aW9ucyk7XG4gIHZhciBtZXNzYWdlID0gZ3Vlc3NbMV07XG4gIHZhciB0cmFjZSA9IHtcbiAgICBleGNlcHRpb246IHtcbiAgICAgIFwiY2xhc3NcIjogY2xhc3NOYW1lLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH1cbiAgfTtcbiAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgdHJhY2UuZXhjZXB0aW9uLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIH1cbiAgaWYgKHN0YWNrKSB7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdHJhY2UuZXhjZXB0aW9uLnN0YWNrID0gc3RhY2tJbmZvLnJhd1N0YWNrO1xuICAgICAgdHJhY2UuZXhjZXB0aW9uLnJhdyA9IFN0cmluZyhzdGFja0luZm8ucmF3RXhjZXB0aW9uKTtcbiAgICB9XG4gICAgdmFyIHN0YWNrRnJhbWU7XG4gICAgdmFyIGZyYW1lO1xuICAgIHZhciBjb2RlO1xuICAgIHZhciBwcmU7XG4gICAgdmFyIHBvc3Q7XG4gICAgdmFyIGNvbnRleHRMZW5ndGg7XG4gICAgdmFyIGksIG1pZDtcbiAgICB0cmFjZS5mcmFtZXMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgIHN0YWNrRnJhbWUgPSBzdGFja1tpXTtcbiAgICAgIGZyYW1lID0ge1xuICAgICAgICBmaWxlbmFtZTogc3RhY2tGcmFtZS51cmwgPyBfLnNhbml0aXplVXJsKHN0YWNrRnJhbWUudXJsKSA6ICcodW5rbm93biknLFxuICAgICAgICBsaW5lbm86IHN0YWNrRnJhbWUubGluZSB8fCBudWxsLFxuICAgICAgICBtZXRob2Q6ICFzdGFja0ZyYW1lLmZ1bmMgfHwgc3RhY2tGcmFtZS5mdW5jID09PSAnPycgPyAnW2Fub255bW91c10nIDogc3RhY2tGcmFtZS5mdW5jLFxuICAgICAgICBjb2xubzogc3RhY2tGcmFtZS5jb2x1bW5cbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5zZW5kRnJhbWVVcmwpIHtcbiAgICAgICAgZnJhbWUudXJsID0gc3RhY2tGcmFtZS51cmw7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWUubWV0aG9kICYmIGZyYW1lLm1ldGhvZC5lbmRzV2l0aCAmJiBmcmFtZS5tZXRob2QuZW5kc1dpdGgoJ19yb2xsYmFyX3dyYXBwZWQnKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvZGUgPSBwcmUgPSBwb3N0ID0gbnVsbDtcbiAgICAgIGNvbnRleHRMZW5ndGggPSBzdGFja0ZyYW1lLmNvbnRleHQgPyBzdGFja0ZyYW1lLmNvbnRleHQubGVuZ3RoIDogMDtcbiAgICAgIGlmIChjb250ZXh0TGVuZ3RoKSB7XG4gICAgICAgIG1pZCA9IE1hdGguZmxvb3IoY29udGV4dExlbmd0aCAvIDIpO1xuICAgICAgICBwcmUgPSBzdGFja0ZyYW1lLmNvbnRleHQuc2xpY2UoMCwgbWlkKTtcbiAgICAgICAgY29kZSA9IHN0YWNrRnJhbWUuY29udGV4dFttaWRdO1xuICAgICAgICBwb3N0ID0gc3RhY2tGcmFtZS5jb250ZXh0LnNsaWNlKG1pZCk7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICBmcmFtZS5jb2RlID0gY29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmUgfHwgcG9zdCkge1xuICAgICAgICBmcmFtZS5jb250ZXh0ID0ge307XG4gICAgICAgIGlmIChwcmUgJiYgcHJlLmxlbmd0aCkge1xuICAgICAgICAgIGZyYW1lLmNvbnRleHQucHJlID0gcHJlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3N0ICYmIHBvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgZnJhbWUuY29udGV4dC5wb3N0ID0gcG9zdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YWNrRnJhbWUuYXJncykge1xuICAgICAgICBmcmFtZS5hcmdzID0gc3RhY2tGcmFtZS5hcmdzO1xuICAgICAgfVxuICAgICAgdHJhY2UuZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgIH1cblxuICAgIC8vIE5PVEUoY29yeSk6IHJldmVyc2UgdGhlIGZyYW1lcyBzaW5jZSByb2xsYmFyLmNvbSBleHBlY3RzIHRoZSBtb3N0IHJlY2VudCBjYWxsIGxhc3RcbiAgICB0cmFjZS5mcmFtZXMucmV2ZXJzZSgpO1xuICAgIGlmIChjdXN0b20pIHtcbiAgICAgIHRyYWNlLmV4dHJhID0gXy5tZXJnZShjdXN0b20pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2U7XG59XG5mdW5jdGlvbiBlcnJvckNsYXNzKHN0YWNrSW5mbywgZ3Vlc3MsIG9wdGlvbnMpIHtcbiAgaWYgKHN0YWNrSW5mby5uYW1lKSB7XG4gICAgcmV0dXJuIHN0YWNrSW5mby5uYW1lO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3Vlc3NFcnJvckNsYXNzKSB7XG4gICAgcmV0dXJuIGd1ZXNzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnKHVua25vd24pJztcbiAgfVxufVxuZnVuY3Rpb24gYWRkU2NydWJiZXIoc2NydWJGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNjcnViRm4pIHtcbiAgICAgIHZhciBzY3J1YkZpZWxkcyA9IG9wdGlvbnMuc2NydWJGaWVsZHMgfHwgW107XG4gICAgICB2YXIgc2NydWJQYXRocyA9IG9wdGlvbnMuc2NydWJQYXRocyB8fCBbXTtcbiAgICAgIGl0ZW0uZGF0YSA9IHNjcnViRm4oaXRlbS5kYXRhLCBzY3J1YkZpZWxkcywgc2NydWJQYXRocyk7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhbmRsZURvbUV4Y2VwdGlvbjogaGFuZGxlRG9tRXhjZXB0aW9uLFxuICBoYW5kbGVJdGVtV2l0aEVycm9yOiBoYW5kbGVJdGVtV2l0aEVycm9yLFxuICBlbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXk6IGVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheSxcbiAgYWRkQmFzZUluZm86IGFkZEJhc2VJbmZvLFxuICBhZGRSZXF1ZXN0SW5mbzogYWRkUmVxdWVzdEluZm8sXG4gIGFkZENsaWVudEluZm86IGFkZENsaWVudEluZm8sXG4gIGFkZFBsdWdpbkluZm86IGFkZFBsdWdpbkluZm8sXG4gIGFkZEJvZHk6IGFkZEJvZHksXG4gIGFkZFNjcnViYmVyOiBhZGRTY3J1YmJlclxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDUxMTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcblxuLypcbiAqIFJhdGVMaW1pdGVyIC0gYW4gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBmb3IgY291bnRpbmcgaXRlbXMgc2VudCB0byBSb2xsYmFyXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgc2FtZSBvcHRpb25zIHRoYXQgYXJlIGFjY2VwdGVkIGJ5IGNvbmZpZ3VyZUdsb2JhbCBvZmZlcmVkIGFzIGEgY29udmVuaWVuY2VcbiAqL1xuZnVuY3Rpb24gUmF0ZUxpbWl0ZXIob3B0aW9ucykge1xuICB0aGlzLnN0YXJ0VGltZSA9IF8ubm93KCk7XG4gIHRoaXMuY291bnRlciA9IDA7XG4gIHRoaXMucGVyTWluQ291bnRlciA9IDA7XG4gIHRoaXMucGxhdGZvcm0gPSBudWxsO1xuICB0aGlzLnBsYXRmb3JtT3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZUdsb2JhbChvcHRpb25zKTtcbn1cblJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzID0ge1xuICBzdGFydFRpbWU6IF8ubm93KCksXG4gIG1heEl0ZW1zOiB1bmRlZmluZWQsXG4gIGl0ZW1zUGVyTWludXRlOiB1bmRlZmluZWRcbn07XG5cbi8qXG4gKiBjb25maWd1cmVHbG9iYWwgLSBzZXQgdGhlIGdsb2JhbCByYXRlIGxpbWl0ZXIgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT25seSB0aGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgcmVjb2duaXplZDpcbiAqICAgIHN0YXJ0VGltZTogYSB0aW1lc3RhbXAgb2YgdGhlIGZvcm0gcmV0dXJuZWQgYnkgKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuICogICAgbWF4SXRlbXM6IHRoZSBtYXhpbXVtIGl0ZW1zXG4gKiAgICBpdGVtc1Blck1pbnV0ZTogdGhlIG1heCBudW1iZXIgb2YgaXRlbXMgdG8gc2VuZCBpbiBhIGdpdmVuIG1pbnV0ZVxuICovXG5SYXRlTGltaXRlci5wcm90b3R5cGUuY29uZmlndXJlR2xvYmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5zdGFydFRpbWUgPSBvcHRpb25zLnN0YXJ0VGltZTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3MubWF4SXRlbXMgPSBvcHRpb25zLm1heEl0ZW1zO1xuICB9XG4gIGlmIChvcHRpb25zLml0ZW1zUGVyTWludXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5pdGVtc1Blck1pbnV0ZSA9IG9wdGlvbnMuaXRlbXNQZXJNaW51dGU7XG4gIH1cbn07XG5cbi8qXG4gKiBzaG91bGRTZW5kIC0gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBzZW5kIGEgZ2l2ZW4gaXRlbSBiYXNlZCBvbiByYXRlIGxpbWl0IHNldHRpbmdzXG4gKlxuICogQHBhcmFtIGl0ZW0gLSB0aGUgaXRlbSB3ZSBhcmUgYWJvdXQgdG8gc2VuZFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKiAgZXJyb3I6IChFcnJvcnxudWxsKVxuICogIHNob3VsZFNlbmQ6IGJvb2xcbiAqICBwYXlsb2FkOiAoT2JqZWN0fG51bGwpXG4gKiAgSWYgc2hvdWxkU2VuZCBpcyBmYWxzZSwgdGhlIGl0ZW0gcGFzc2VkIGFzIGEgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgc2VudCB0byBSb2xsYmFyLCBhbmRcbiAqICBleGFjdGx5IG9uZSBvZiBlcnJvciBvciBwYXlsb2FkIHdpbGwgYmUgbm9uLW51bGwuIElmIGVycm9yIGlzIG5vbi1udWxsLCB0aGUgcmV0dXJuZWQgRXJyb3Igd2lsbFxuICogIGRlc2NyaWJlIHRoZSBzaXR1YXRpb24sIGJ1dCBpdCBtZWFucyB0aGF0IHdlIHdlcmUgYWxyZWFkeSBvdmVyIGEgcmF0ZSBsaW1pdCAoZWl0aGVyIGdsb2JhbGx5IG9yXG4gKiAgcGVyIG1pbnV0ZSkgd2hlbiB0aGlzIGl0ZW0gd2FzIGNoZWNrZWQuIElmIGVycm9yIGlzIG51bGwsIGFuZCB0aGVyZWZvcmUgcGF5bG9hZCBpcyBub24tbnVsbCwgaXRcbiAqICBtZWFucyB0aGlzIGl0ZW0gcHV0IHVzIG92ZXIgdGhlIGdsb2JhbCByYXRlIGxpbWl0IGFuZCB0aGUgcGF5bG9hZCBzaG91bGQgYmUgc2VudCB0byBSb2xsYmFyIGluXG4gKiAgcGxhY2Ugb2YgdGhlIHBhc3NlZCBpbiBpdGVtLlxuICovXG5SYXRlTGltaXRlci5wcm90b3R5cGUuc2hvdWxkU2VuZCA9IGZ1bmN0aW9uIChpdGVtLCBub3cpIHtcbiAgbm93ID0gbm93IHx8IF8ubm93KCk7XG4gIHZhciBlbGFwc2VkVGltZSA9IG5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuICBpZiAoZWxhcHNlZFRpbWUgPCAwIHx8IGVsYXBzZWRUaW1lID49IDYwMDAwKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBub3c7XG4gICAgdGhpcy5wZXJNaW5Db3VudGVyID0gMDtcbiAgfVxuICB2YXIgZ2xvYmFsUmF0ZUxpbWl0ID0gUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3MubWF4SXRlbXM7XG4gIHZhciBnbG9iYWxSYXRlTGltaXRQZXJNaW4gPSBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5pdGVtc1Blck1pbnV0ZTtcbiAgaWYgKGNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXQsIHRoaXMuY291bnRlcikpIHtcbiAgICByZXR1cm4gc2hvdWxkU2VuZFZhbHVlKHRoaXMucGxhdGZvcm0sIHRoaXMucGxhdGZvcm1PcHRpb25zLCBnbG9iYWxSYXRlTGltaXQgKyAnIG1heCBpdGVtcyByZWFjaGVkJywgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXRQZXJNaW4sIHRoaXMucGVyTWluQ291bnRlcikpIHtcbiAgICByZXR1cm4gc2hvdWxkU2VuZFZhbHVlKHRoaXMucGxhdGZvcm0sIHRoaXMucGxhdGZvcm1PcHRpb25zLCBnbG9iYWxSYXRlTGltaXRQZXJNaW4gKyAnIGl0ZW1zIHBlciBtaW51dGUgcmVhY2hlZCcsIGZhbHNlKTtcbiAgfVxuICB0aGlzLmNvdW50ZXIrKztcbiAgdGhpcy5wZXJNaW5Db3VudGVyKys7XG4gIHZhciBzaG91bGRTZW5kID0gIWNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXQsIHRoaXMuY291bnRlcik7XG4gIHZhciBwZXJNaW51dGUgPSBzaG91bGRTZW5kO1xuICBzaG91bGRTZW5kID0gc2hvdWxkU2VuZCAmJiAhY2hlY2tSYXRlKGl0ZW0sIGdsb2JhbFJhdGVMaW1pdFBlck1pbiwgdGhpcy5wZXJNaW5Db3VudGVyKTtcbiAgcmV0dXJuIHNob3VsZFNlbmRWYWx1ZSh0aGlzLnBsYXRmb3JtLCB0aGlzLnBsYXRmb3JtT3B0aW9ucywgbnVsbCwgc2hvdWxkU2VuZCwgZ2xvYmFsUmF0ZUxpbWl0LCBnbG9iYWxSYXRlTGltaXRQZXJNaW4sIHBlck1pbnV0ZSk7XG59O1xuUmF0ZUxpbWl0ZXIucHJvdG90eXBlLnNldFBsYXRmb3JtT3B0aW9ucyA9IGZ1bmN0aW9uIChwbGF0Zm9ybSwgb3B0aW9ucykge1xuICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gIHRoaXMucGxhdGZvcm1PcHRpb25zID0gb3B0aW9ucztcbn07XG5cbi8qIEhlbHBlcnMgKi9cblxuZnVuY3Rpb24gY2hlY2tSYXRlKGl0ZW0sIGxpbWl0LCBjb3VudGVyKSB7XG4gIHJldHVybiAhaXRlbS5pZ25vcmVSYXRlTGltaXQgJiYgbGltaXQgPj0gMSAmJiBjb3VudGVyID4gbGltaXQ7XG59XG5mdW5jdGlvbiBzaG91bGRTZW5kVmFsdWUocGxhdGZvcm0sIG9wdGlvbnMsIGVycm9yLCBzaG91bGRTZW5kLCBnbG9iYWxSYXRlTGltaXQsIGxpbWl0UGVyTWluLCBwZXJNaW51dGUpIHtcbiAgdmFyIHBheWxvYWQgPSBudWxsO1xuICBpZiAoZXJyb3IpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgaWYgKCFlcnJvciAmJiAhc2hvdWxkU2VuZCkge1xuICAgIHBheWxvYWQgPSByYXRlTGltaXRQYXlsb2FkKHBsYXRmb3JtLCBvcHRpb25zLCBnbG9iYWxSYXRlTGltaXQsIGxpbWl0UGVyTWluLCBwZXJNaW51dGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3I6IGVycm9yLFxuICAgIHNob3VsZFNlbmQ6IHNob3VsZFNlbmQsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9O1xufVxuZnVuY3Rpb24gcmF0ZUxpbWl0UGF5bG9hZChwbGF0Zm9ybSwgb3B0aW9ucywgZ2xvYmFsUmF0ZUxpbWl0LCBsaW1pdFBlck1pbiwgcGVyTWludXRlKSB7XG4gIHZhciBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgb3B0aW9ucy5wYXlsb2FkICYmIG9wdGlvbnMucGF5bG9hZC5lbnZpcm9ubWVudDtcbiAgdmFyIG1zZztcbiAgaWYgKHBlck1pbnV0ZSkge1xuICAgIG1zZyA9ICdpdGVtIHBlciBtaW51dGUgbGltaXQgcmVhY2hlZCwgaWdub3JpbmcgZXJyb3JzIHVudGlsIHRpbWVvdXQnO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9ICdtYXhJdGVtcyBoYXMgYmVlbiBoaXQsIGlnbm9yaW5nIGVycm9ycyB1bnRpbCByZXNldC4nO1xuICB9XG4gIHZhciBpdGVtID0ge1xuICAgIGJvZHk6IHtcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgYm9keTogbXNnLFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgIG1heEl0ZW1zOiBnbG9iYWxSYXRlTGltaXQsXG4gICAgICAgICAgaXRlbXNQZXJNaW51dGU6IGxpbWl0UGVyTWluXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbmd1YWdlOiAnamF2YXNjcmlwdCcsXG4gICAgZW52aXJvbm1lbnQ6IGVudmlyb25tZW50LFxuICAgIG5vdGlmaWVyOiB7XG4gICAgICB2ZXJzaW9uOiBvcHRpb25zLm5vdGlmaWVyICYmIG9wdGlvbnMubm90aWZpZXIudmVyc2lvbiB8fCBvcHRpb25zLnZlcnNpb25cbiAgICB9XG4gIH07XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgaXRlbS5wbGF0Zm9ybSA9ICdicm93c2VyJztcbiAgICBpdGVtLmZyYW1ld29yayA9ICdicm93c2VyLWpzJztcbiAgICBpdGVtLm5vdGlmaWVyLm5hbWUgPSAncm9sbGJhci1icm93c2VyLWpzJztcbiAgfSBlbHNlIGlmIChwbGF0Zm9ybSA9PT0gJ3NlcnZlcicpIHtcbiAgICBpdGVtLmZyYW1ld29yayA9IG9wdGlvbnMuZnJhbWV3b3JrIHx8ICdub2RlLWpzJztcbiAgICBpdGVtLm5vdGlmaWVyLm5hbWUgPSBvcHRpb25zLm5vdGlmaWVyLm5hbWU7XG4gIH0gZWxzZSBpZiAocGxhdGZvcm0gPT09ICdyZWFjdC1uYXRpdmUnKSB7XG4gICAgaXRlbS5mcmFtZXdvcmsgPSBvcHRpb25zLmZyYW1ld29yayB8fCAncmVhY3QtbmF0aXZlJztcbiAgICBpdGVtLm5vdGlmaWVyLm5hbWUgPSBvcHRpb25zLm5vdGlmaWVyLm5hbWU7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJhdGVMaW1pdGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vLyAganNvbjMuanNcbi8vICAyMDE3LTAyLTIxXG4vLyAgUHVibGljIERvbWFpbi5cbi8vICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG4vLyAgU2VlIGh0dHA6Ly93d3cuSlNPTi5vcmcvanMuaHRtbFxuLy8gIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4vLyAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4vLyAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbi8vICBOT1QgQ09OVFJPTC5cblxuLy8gIFRoaXMgZmlsZSBjcmVhdGVzIGEgZ2xvYmFsIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIG1ldGhvZHM6IHN0cmluZ2lmeVxuLy8gIGFuZCBwYXJzZS4gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBFUzUgSlNPTiBjYXBhYmlsaXR5IHRvIEVTMyBzeXN0ZW1zLlxuLy8gIElmIGEgcHJvamVjdCBtaWdodCBydW4gb24gSUU4IG9yIGVhcmxpZXIsIHRoZW4gdGhpcyBmaWxlIHNob3VsZCBiZSBpbmNsdWRlZC5cbi8vICBUaGlzIGZpbGUgZG9lcyBub3RoaW5nIG9uIEVTNSBzeXN0ZW1zLlxuXG4vLyAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4vLyAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4vLyAgICAgICAgICByZXBsYWNlciAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZXRlcm1pbmVzIGhvdyBvYmplY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG4vLyAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuLy8gICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuLy8gICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbi8vICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuLy8gICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4vLyAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgXCJcXHRcIiBvciBcIiZuYnNwO1wiKSxcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG4vLyAgICAgICAgICBUaGlzIG1ldGhvZCBwcm9kdWNlcyBhIEpTT04gdGV4dCBmcm9tIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbi8vICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4vLyAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuLy8gICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuLy8gICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4vLyAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbi8vICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZS5cblxuLy8gICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4vLyAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuLy8gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG4gPCAxMClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiMFwiICsgblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgIDogbjtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgXCJUXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArIFwiOlwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgXCJaXCI7XG4vLyAgICAgICAgICAgICAgfTtcblxuLy8gICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4vLyAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbi8vICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4vLyAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbi8vICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbi8vICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4vLyAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4vLyAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuLy8gICAgICAgICAgc3RyaW5naWZpZWQuXG5cbi8vICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuLy8gICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbi8vICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuLy8gICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG5cbi8vICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbi8vICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4vLyAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4vLyAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuLy8gICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuLy8gICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbi8vICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbXCJlXCIsIHtwbHVyaWJ1czogXCJ1bnVtXCJ9XSk7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0sIG51bGwsIFwiXFx0XCIpO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1xcblxcdFwiZVwiLFxcblxcdHtcXG5cXHRcXHRcInBsdXJpYnVzXCI6IFwidW51bVwiXFxuXFx0fVxcbl0nXG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbbmV3IERhdGUoKV0sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGVcbi8vICAgICAgICAgICAgICAgICAgPyBcIkRhdGUoXCIgKyB0aGlzW2tleV0gKyBcIilcIlxuLy8gICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cbi8vICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuLy8gICAgICAgICAgVGhpcyBoYXMgYmVlbiBtb2RpZmllZCB0byB1c2UgSlNPTi1qcy9qc29uX3BhcnNlX3N0YXRlLmpzIGFzIHRoZVxuLy8gICAgICAgICAgcGFyc2VyIGluc3RlYWQgb2YgdGhlIG9uZSBidWlsdCBhcm91bmQgZXZhbCBmb3VuZCBpbiBKU09OLWpzL2pzb24yLmpzXG5cbi8vICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbi8vICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuLy8gICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbi8vICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbi8vICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuLy8gICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuLy8gICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBhO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgYSA9XG4vLyAgIC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuLy8gICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbi8vICAgICAgICAgICAgICB2YXIgZDtcbi8vICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gXCJEYXRlKFwiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgtMSkgPT09IFwiKVwiKSB7XG4vLyAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuLy8gICAgICAgICAgICAgICAgICBpZiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICBUaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLiBZb3UgYXJlIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBvclxuLy8gIHJlZGlzdHJpYnV0ZS5cblxuLypqc2xpbnRcbiAgZm9yLCB0aGlzXG4gICovXG5cbi8qcHJvcGVydHlcbiAgSlNPTiwgYXBwbHksIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuICAqL1xuXG52YXIgc2V0dXBDdXN0b21KU09OID0gZnVuY3Rpb24oSlNPTikge1xuXG4gIHZhciByeF9vbmUgPSAvXltcXF0sOnt9XFxzXSokLztcbiAgdmFyIHJ4X3R3byA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG4gIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgdmFyIHJ4X2ZvdXIgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG4gIHZhciByeF9lc2NhcGFibGUgPSAvW1xcXFxcIlxcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgZnVuY3Rpb24gZihuKSB7XG4gICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICByZXR1cm4gbiA8IDEwXG4gICAgICA/IFwiMFwiICsgblxuICAgICAgOiBuO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhpc192YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSlcbiAgICAgICAgPyB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXG4gICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4gICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArXG4gICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICsgXCI6XCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuXG4gICAgQm9vbGVhbi5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICB9XG5cbiAgdmFyIGdhcDtcbiAgdmFyIGluZGVudDtcbiAgdmFyIG1ldGE7XG4gIHZhciByZXA7XG5cblxuICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cblxuICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiByeF9lc2NhcGFibGUudGVzdChzdHJpbmcpXG4gICAgICA/IFwiXFxcIlwiICsgc3RyaW5nLnJlcGxhY2UocnhfZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgID8gY1xuICAgICAgICAgIDogXCJcXFxcdVwiICsgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgfSkgKyBcIlxcXCJcIlxuICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICB2YXIgaTsgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICB2YXIgazsgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgdmFyIGxlbmd0aDtcbiAgICB2YXIgbWluZCA9IGdhcDtcbiAgICB2YXIgcGFydGlhbDtcbiAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4gICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSlcbiAgICAgICAgICA/IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICA6IFwibnVsbFwiO1xuXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcIm51bGxcIjpcblxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgXCJudWxsXCIuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyBcIm9iamVjdFwiLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4gICAgICAgIC8vIG51bGwuXG5cbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcblxuICAgICAgICAvLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbiAgICAgICAgLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG5cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICBwYXJ0aWFsID0gW107XG5cbiAgICAgICAgLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cbiAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8IFwibnVsbFwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4gICAgICAgICAgLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gXCJbXVwiXG4gICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgPyBcIltcXG5cIiArIGdhcCArIHBhcnRpYWwuam9pbihcIixcXG5cIiArIGdhcCkgKyBcIlxcblwiICsgbWluZCArIFwiXVwiXG4gICAgICAgICAgICA6IFwiW1wiICsgcGFydGlhbC5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCI6XCJcbiAgICAgICAgICAgICAgICAgICAgICApICsgdik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgIGdhcFxuICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICA6IGdhcFxuICAgICAgICAgID8gXCJ7XFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIn1cIlxuICAgICAgICAgIDogXCJ7XCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHN0cmluZ2lmeSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gIGlmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICBcIlxcYlwiOiBcIlxcXFxiXCIsXG4gICAgICBcIlxcdFwiOiBcIlxcXFx0XCIsXG4gICAgICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gICAgICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gICAgICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gICAgICBcIlxcXCJcIjogXCJcXFxcXFxcIlwiLFxuICAgICAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxuICAgIH07XG4gICAgSlNPTi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuXG4gICAgICAvLyBUaGUgc3RyaW5naWZ5IG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCByZXBsYWNlciwgYW5kIGFuIG9wdGlvbmFsXG4gICAgICAvLyBzcGFjZSBwYXJhbWV0ZXIsIGFuZCByZXR1cm5zIGEgSlNPTiB0ZXh0LiBUaGUgcmVwbGFjZXIgY2FuIGJlIGEgZnVuY3Rpb25cbiAgICAgIC8vIHRoYXQgY2FuIHJlcGxhY2UgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGtleXMuXG4gICAgICAvLyBBIGRlZmF1bHQgcmVwbGFjZXIgbWV0aG9kIGNhbiBiZSBwcm92aWRlZC4gVXNlIG9mIHRoZSBzcGFjZSBwYXJhbWV0ZXIgY2FuXG4gICAgICAvLyBwcm9kdWNlIHRleHQgdGhhdCBpcyBtb3JlIGVhc2lseSByZWFkYWJsZS5cblxuICAgICAgdmFyIGk7XG4gICAgICBnYXAgPSBcIlwiO1xuICAgICAgaW5kZW50ID0gXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgICAgLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICBpbmRlbnQgKz0gXCIgXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbiAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgfTtcbiAgfVxuXG5cbiAgLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIEpTT04ucGFyc2UgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBKU09OIHBhcnNlIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIHN0YXRlIG1hY2hpbmUgcmF0aGVyXG4gICAgICAvLyB0aGFuIHRoZSBkYW5nZXJvdXMgZXZhbCBmdW5jdGlvbiB0byBwYXJzZSBhIEpTT04gdGV4dC5cblxuICAgICAgdmFyIHN0YXRlOyAgICAgIC8vIFRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLCBvbmUgb2ZcbiAgICAgIC8vICdnbycgICAgICAgICBUaGUgc3RhcnRpbmcgc3RhdGVcbiAgICAgIC8vICdvaycgICAgICAgICBUaGUgZmluYWwsIGFjY2VwdGluZyBzdGF0ZVxuICAgICAgLy8gJ2ZpcnN0b2tleScgIFJlYWR5IGZvciB0aGUgZmlyc3Qga2V5IG9mIHRoZSBvYmplY3Qgb3JcbiAgICAgIC8vICAgICAgICAgICAgICB0aGUgY2xvc2luZyBvZiBhbiBlbXB0eSBvYmplY3RcbiAgICAgIC8vICdva2V5JyAgICAgICBSZWFkeSBmb3IgdGhlIG5leHQga2V5IG9mIHRoZSBvYmplY3RcbiAgICAgIC8vICdjb2xvbicgICAgICBSZWFkeSBmb3IgdGhlIGNvbG9uXG4gICAgICAvLyAnb3ZhbHVlJyAgICAgUmVhZHkgZm9yIHRoZSB2YWx1ZSBoYWxmIG9mIGEga2V5L3ZhbHVlIHBhaXJcbiAgICAgIC8vICdvY29tbWEnICAgICBSZWFkeSBmb3IgYSBjb21tYSBvciBjbG9zaW5nIH1cbiAgICAgIC8vICdmaXJzdGF2YWx1ZScgUmVhZHkgZm9yIHRoZSBmaXJzdCB2YWx1ZSBvZiBhbiBhcnJheSBvclxuICAgICAgLy8gICAgICAgICAgICAgIGFuIGVtcHR5IGFycmF5XG4gICAgICAvLyAnYXZhbHVlJyAgICAgUmVhZHkgZm9yIHRoZSBuZXh0IHZhbHVlIG9mIGFuIGFycmF5XG4gICAgICAvLyAnYWNvbW1hJyAgICAgUmVhZHkgZm9yIGEgY29tbWEgb3IgY2xvc2luZyBdXG4gICAgICB2YXIgc3RhY2s7ICAgICAgLy8gVGhlIHN0YWNrLCBmb3IgY29udHJvbGxpbmcgbmVzdGluZy5cbiAgICAgIHZhciBjb250YWluZXI7ICAvLyBUaGUgY3VycmVudCBjb250YWluZXIgb2JqZWN0IG9yIGFycmF5XG4gICAgICB2YXIga2V5OyAgICAgICAgLy8gVGhlIGN1cnJlbnQga2V5XG4gICAgICB2YXIgdmFsdWU7ICAgICAgLy8gVGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgIHZhciBlc2NhcGVzID0geyAvLyBFc2NhcGVtZW50IHRyYW5zbGF0aW9uIHRhYmxlXG4gICAgICAgIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgICAgICAgXCJcXFwiXCI6IFwiXFxcIlwiLFxuICAgICAgICBcIi9cIjogXCIvXCIsXG4gICAgICAgIFwidFwiOiBcIlxcdFwiLFxuICAgICAgICBcIm5cIjogXCJcXG5cIixcbiAgICAgICAgXCJyXCI6IFwiXFxyXCIsXG4gICAgICAgIFwiZlwiOiBcIlxcZlwiLFxuICAgICAgICBcImJcIjogXCJcXGJcIlxuICAgICAgfTtcbiAgICAgIHZhciBzdHJpbmcgPSB7ICAgLy8gVGhlIGFjdGlvbnMgZm9yIHN0cmluZyB0b2tlbnNcbiAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3Rva2V5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAga2V5ID0gdmFsdWU7XG4gICAgICAgICAgc3RhdGUgPSBcImNvbG9uXCI7XG4gICAgICAgIH0sXG4gICAgICAgIG9rZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBrZXkgPSB2YWx1ZTtcbiAgICAgICAgICBzdGF0ZSA9IFwiY29sb25cIjtcbiAgICAgICAgfSxcbiAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuICAgICAgICB9LFxuICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgfSxcbiAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG51bWJlciA9IHsgICAvLyBUaGUgYWN0aW9ucyBmb3IgbnVtYmVyIHRva2Vuc1xuICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJva1wiO1xuICAgICAgICB9LFxuICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwib2NvbW1hXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICB9LFxuICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgYWN0aW9uID0ge1xuXG4gICAgICAgIC8vIFRoZSBhY3Rpb24gdGFibGUgZGVzY3JpYmVzIHRoZSBiZWhhdmlvciBvZiB0aGUgbWFjaGluZS4gSXQgY29udGFpbnMgYW5cbiAgICAgICAgLy8gb2JqZWN0IGZvciBlYWNoIHRva2VuLiBFYWNoIG9iamVjdCBjb250YWlucyBhIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuXG4gICAgICAgIC8vIGEgdG9rZW4gaXMgbWF0Y2hlZCBpbiBhIHN0YXRlLiBBbiBvYmplY3Qgd2lsbCBsYWNrIGEgbWV0aG9kIGZvciBpbGxlZ2FsXG4gICAgICAgIC8vIHN0YXRlcy5cblxuICAgICAgICBcIntcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtzdGF0ZTogXCJva1wifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSB7fTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdG9rZXlcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcIm9jb21tYVwiLCBrZXk6IGtleX0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0ge307XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSB7fTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdG9rZXlcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSB7fTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdG9rZXlcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwifVwiOiB7XG4gICAgICAgICAgZmlyc3Rva2V5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9wID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcC5jb250YWluZXI7XG4gICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvY29tbWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3AgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lcltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcC5jb250YWluZXI7XG4gICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIltcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtzdGF0ZTogXCJva1wifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtjb250YWluZXI6IGNvbnRhaW5lciwgc3RhdGU6IFwib2NvbW1hXCIsIGtleToga2V5fSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3RhdmFsdWVcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJdXCI6IHtcbiAgICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBwb3AuY29udGFpbmVyO1xuICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcbiAgICAgICAgICAgIHN0YXRlID0gcG9wLnN0YXRlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWNvbW1hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9wID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcC5jb250YWluZXI7XG4gICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIjpcIjoge1xuICAgICAgICAgIGNvbG9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVyLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkR1cGxpY2F0ZSBrZXkgJ1wiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBcIm92YWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIsXCI6IHtcbiAgICAgICAgICBvY29tbWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2tleVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWNvbW1hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiYXZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRydWVcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJmYWxzZVwiOiB7XG4gICAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJvY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJudWxsXCI6IHtcbiAgICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9rXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlID0gXCJvY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGRlYmFja3NsYXNoaWZ5KHRleHQpIHtcblxuICAgICAgICAvLyBSZW1vdmUgYW5kIHJlcGxhY2UgYW55IGJhY2tzbGFzaCBlc2NhcGVtZW50LlxuXG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcXFwoPzp1KC57NH0pfChbXnVdKSkvZywgZnVuY3Rpb24gKGlnbm9yZSwgYiwgYykge1xuICAgICAgICAgIHJldHVybiBiXG4gICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYiwgMTYpKVxuICAgICAgICAgICAgOiBlc2NhcGVzW2NdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcblxuICAgICAgICAvLyBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyB1c2VkIHRvIGV4dHJhY3QgdG9rZW5zIGZyb20gdGhlIEpTT04gdGV4dC5cbiAgICAgICAgLy8gVGhlIGV4dHJhY3Rpb24gcHJvY2VzcyBpcyBjYXV0aW91cy5cblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdHggPSAvXltcXHUwMDIwXFx0XFxuXFxyXSooPzooWyw6XFxbXFxde31dfHRydWV8ZmFsc2V8bnVsbCl8KC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/KXxcIigoPzpbXlxcclxcblxcdFxcXFxcXFwiXXxcXFxcKD86W1wiXFxcXFxcL3RybmZiXXx1WzAtOWEtZkEtRl17NH0pKSopXCIpLztcblxuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0aW5nIHN0YXRlLlxuXG4gICAgICAgIHN0YXRlID0gXCJnb1wiO1xuXG4gICAgICAgIC8vIFRoZSBzdGFjayByZWNvcmRzIHRoZSBjb250YWluZXIsIGtleSwgYW5kIHN0YXRlIGZvciBlYWNoIG9iamVjdCBvciBhcnJheVxuICAgICAgICAvLyB0aGF0IGNvbnRhaW5zIGFub3RoZXIgb2JqZWN0IG9yIGFycmF5IHdoaWxlIHByb2Nlc3NpbmcgbmVzdGVkIHN0cnVjdHVyZXMuXG5cbiAgICAgICAgc3RhY2sgPSBbXTtcblxuICAgICAgICAvLyBJZiBhbnkgZXJyb3Igb2NjdXJzLCB3ZSB3aWxsIGNhdGNoIGl0IGFuZCB1bHRpbWF0ZWx5IHRocm93IGEgc3ludGF4IGVycm9yLlxuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAvLyBGb3IgZWFjaCB0b2tlbi4uLlxuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHR4LmV4ZWMoc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXN1bHQgaXMgdGhlIHJlc3VsdCBhcnJheSBmcm9tIG1hdGNoaW5nIHRoZSB0b2tlbml6aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgIC8vICByZXN1bHRbMF0gY29udGFpbnMgZXZlcnl0aGluZyB0aGF0IG1hdGNoZWQsIGluY2x1ZGluZyBhbnkgaW5pdGlhbCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgLy8gIHJlc3VsdFsxXSBjb250YWlucyBhbnkgcHVuY3R1YXRpb24gdGhhdCB3YXMgbWF0Y2hlZCwgb3IgdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG4gICAgICAgICAgICAvLyAgcmVzdWx0WzJdIGNvbnRhaW5zIGEgbWF0Y2hlZCBudW1iZXIsIHN0aWxsIGluIHN0cmluZyBmb3JtLlxuICAgICAgICAgICAgLy8gIHJlc3VsdFszXSBjb250YWlucyBhIG1hdGNoZWQgc3RyaW5nLCB3aXRob3V0IHF1b3RlcyBidXQgd2l0aCBlc2NhcGVtZW50LlxuXG4gICAgICAgICAgICBpZiAocmVzdWx0WzFdKSB7XG5cbiAgICAgICAgICAgICAgLy8gVG9rZW46IEV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgdGhpcyBzdGF0ZSBhbmQgdG9rZW4uXG5cbiAgICAgICAgICAgICAgYWN0aW9uW3Jlc3VsdFsxXV1bc3RhdGVdKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzJdKSB7XG5cbiAgICAgICAgICAgICAgLy8gTnVtYmVyIHRva2VuOiBDb252ZXJ0IHRoZSBudW1iZXIgc3RyaW5nIGludG8gYSBudW1iZXIgdmFsdWUgYW5kIGV4ZWN1dGVcbiAgICAgICAgICAgICAgLy8gdGhlIGFjdGlvbiBmb3IgdGhpcyBzdGF0ZSBhbmQgbnVtYmVyLlxuXG4gICAgICAgICAgICAgIHZhbHVlID0gK3Jlc3VsdFsyXTtcbiAgICAgICAgICAgICAgbnVtYmVyW3N0YXRlXSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvLyBTdHJpbmcgdG9rZW46IFJlcGxhY2UgdGhlIGVzY2FwZW1lbnQgc2VxdWVuY2VzIGFuZCBleGVjdXRlIHRoZSBhY3Rpb24gZm9yXG4gICAgICAgICAgICAgIC8vIHRoaXMgc3RhdGUgYW5kIHN0cmluZy5cblxuICAgICAgICAgICAgICB2YWx1ZSA9IGRlYmFja3NsYXNoaWZ5KHJlc3VsdFszXSk7XG4gICAgICAgICAgICAgIHN0cmluZ1tzdGF0ZV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0b2tlbiBmcm9tIHRoZSBzdHJpbmcuIFRoZSBsb29wIHdpbGwgY29udGludWUgYXMgbG9uZyBhcyB0aGVyZVxuICAgICAgICAgICAgLy8gYXJlIHRva2Vucy4gVGhpcyBpcyBhIHNsb3cgcHJvY2VzcywgYnV0IGl0IGFsbG93cyB0aGUgdXNlIG9mIF4gbWF0Y2hpbmcsXG4gICAgICAgICAgICAvLyB3aGljaCBhc3N1cmVzIHRoYXQgbm8gaWxsZWdhbCB0b2tlbnMgc2xpcCB0aHJvdWdoLlxuXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc2xpY2UocmVzdWx0WzBdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UgZmluZCBhIHN0YXRlL3Rva2VuIGNvbWJpbmF0aW9uIHRoYXQgaXMgaWxsZWdhbCwgdGhlbiB0aGUgYWN0aW9uIHdpbGxcbiAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvci4gV2UgaGFuZGxlIHRoZSBlcnJvciBieSBzaW1wbHkgY2hhbmdpbmcgdGhlIHN0YXRlLlxuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcGFyc2luZyBpcyBmaW5pc2hlZC4gSWYgd2UgYXJlIG5vdCBpbiB0aGUgZmluYWwgXCJva1wiIHN0YXRlLCBvciBpZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHNvdXJjZSBjb250YWlucyBhbnl0aGluZyBleGNlcHQgd2hpdGVzcGFjZSwgdGhlbiB3ZSBkaWQgbm90IGhhdmVcbiAgICAgICAgLy9hIHdlbGwtZm9ybWVkIEpTT04gdGV4dC5cblxuICAgICAgICBpZiAoc3RhdGUgIT09IFwib2tcIiB8fCAoL1teXFx1MDAyMFxcdFxcblxccl0vLnRlc3Qoc291cmNlKSkpIHtcbiAgICAgICAgICB0aHJvdyAoc3RhdGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcilcbiAgICAgICAgICAgID8gc3RhdGVcbiAgICAgICAgICAgIDogbmV3IFN5bnRheEVycm9yKFwiSlNPTlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAgICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgY3VycmVudFxuICAgICAgICAvLyB2YWx1ZSBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm5cbiAgICAgICAgLy8gdGhhdCB2YWx1ZS5cblxuICAgICAgICByZXR1cm4gKHR5cGVvZiByZXZpdmVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICB2YXIgdjtcbiAgICAgICAgICAgIHZhciB2YWwgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwgaykpIHtcbiAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbCwgayk7XG4gICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsKTtcbiAgICAgICAgICB9KHtcIlwiOiB2YWx1ZX0sIFwiXCIpKVxuICAgICAgICA6IHZhbHVlO1xuICAgICAgfTtcbiAgICB9KCkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXBDdXN0b21KU09OO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1ODM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIENsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQ5KTtcbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xudmFyIEFQSSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KTtcbnZhciBnbG9iYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjIpO1xudmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUxKTtcbnZhciB1cmxsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4Nyk7XG52YXIgdHJhbnNmb3JtcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDg1KTtcbnZhciBzaGFyZWRUcmFuc2Zvcm1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjApO1xudmFyIHByZWRpY2F0ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0Nik7XG52YXIgc2hhcmVkUHJlZGljYXRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzc5KTtcbnZhciBlcnJvclBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTM2KTtcbnZhciByZWNvcmRlckRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTIpO1xudmFyIHRyYWNpbmdEZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2KTtcbnZhciBSZXBsYXlNYXAgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyODcpLyogW1wiZGVmYXVsdFwiXSAqLyAuQSk7XG5mdW5jdGlvbiBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkge1xuICB0aGlzLm9wdGlvbnMgPSBfLmhhbmRsZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIG51bGwsIGxvZ2dlcik7XG4gIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgVGVsZW1ldGVyID0gdGhpcy5jb21wb25lbnRzLnRlbGVtZXRlcjtcbiAgdmFyIEluc3RydW1lbnRlciA9IHRoaXMuY29tcG9uZW50cy5pbnN0cnVtZW50ZXI7XG4gIHZhciBwb2x5ZmlsbEpTT04gPSB0aGlzLmNvbXBvbmVudHMucG9seWZpbGxKU09OO1xuICB0aGlzLndyYXBHbG9iYWxzID0gdGhpcy5jb21wb25lbnRzLndyYXBHbG9iYWxzO1xuICB0aGlzLnNjcnViID0gdGhpcy5jb21wb25lbnRzLnNjcnViO1xuICB2YXIgdHJ1bmNhdGlvbiA9IHRoaXMuY29tcG9uZW50cy50cnVuY2F0aW9uO1xuICB2YXIgVHJhY2luZyA9IHRoaXMuY29tcG9uZW50cy50cmFjaW5nO1xuICB2YXIgUmVjb3JkZXIgPSB0aGlzLmNvbXBvbmVudHMucmVjb3JkZXI7XG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0KHRydW5jYXRpb24pO1xuICB2YXIgYXBpID0gbmV3IEFQSSh0aGlzLm9wdGlvbnMsIHRyYW5zcG9ydCwgdXJsbGliLCB0cnVuY2F0aW9uKTtcbiAgaWYgKFRyYWNpbmcpIHtcbiAgICB0aGlzLnRyYWNpbmcgPSBuZXcgVHJhY2luZyhfZ1dpbmRvdygpLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMudHJhY2luZy5pbml0U2Vzc2lvbigpO1xuICB9XG4gIGlmIChSZWNvcmRlciAmJiBfLmlzQnJvd3NlcigpKSB7XG4gICAgdmFyIHJlY29yZGVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZWNvcmRlcjtcbiAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKHJlY29yZGVyT3B0aW9ucyk7XG4gICAgdGhpcy5yZXBsYXlNYXAgPSBuZXcgUmVwbGF5TWFwKHtcbiAgICAgIHJlY29yZGVyOiB0aGlzLnJlY29yZGVyLFxuICAgICAgYXBpOiBhcGksXG4gICAgICB0cmFjaW5nOiB0aGlzLnRyYWNpbmdcbiAgICB9KTtcbiAgICBpZiAocmVjb3JkZXJPcHRpb25zLmVuYWJsZWQgJiYgcmVjb3JkZXJPcHRpb25zLmF1dG9TdGFydCkge1xuICAgICAgdGhpcy5yZWNvcmRlci5zdGFydCgpO1xuICAgIH1cbiAgfVxuICBpZiAoVGVsZW1ldGVyKSB7XG4gICAgdGhpcy50ZWxlbWV0ZXIgPSBuZXcgVGVsZW1ldGVyKHRoaXMub3B0aW9ucywgdGhpcy50cmFjaW5nKTtcbiAgfVxuICB0aGlzLmNsaWVudCA9IGNsaWVudCB8fCBuZXcgQ2xpZW50KHRoaXMub3B0aW9ucywgYXBpLCBsb2dnZXIsIHRoaXMudGVsZW1ldGVyLCB0aGlzLnRyYWNpbmcsIHRoaXMucmVwbGF5TWFwLCAnYnJvd3NlcicpO1xuICB2YXIgZ1dpbmRvdyA9IF9nV2luZG93KCk7XG4gIHZhciBnRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQ7XG4gIHRoaXMuaXNDaHJvbWUgPSBnV2luZG93LmNocm9tZSAmJiBnV2luZG93LmNocm9tZS5ydW50aW1lOyAvLyBjaGVjayAucnVudGltZSB0byBhdm9pZCBFZGdlIGJyb3dzZXJzXG4gIHRoaXMuYW5vbnltb3VzRXJyb3JzUGVuZGluZyA9IDA7XG4gIGFkZFRyYW5zZm9ybXNUb05vdGlmaWVyKHRoaXMuY2xpZW50Lm5vdGlmaWVyLCB0aGlzLCBnV2luZG93KTtcbiAgYWRkUHJlZGljYXRlc1RvUXVldWUodGhpcy5jbGllbnQucXVldWUpO1xuICB0aGlzLnNldHVwVW5oYW5kbGVkQ2FwdHVyZSgpO1xuICBpZiAoSW5zdHJ1bWVudGVyKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50ZXIgPSBuZXcgSW5zdHJ1bWVudGVyKHRoaXMub3B0aW9ucywgdGhpcy5jbGllbnQudGVsZW1ldGVyLCB0aGlzLCBnV2luZG93LCBnRG9jdW1lbnQpO1xuICAgIHRoaXMuaW5zdHJ1bWVudGVyLmluc3RydW1lbnQoKTtcbiAgfVxuICBfLnNldHVwSlNPTihwb2x5ZmlsbEpTT04pO1xuXG4gIC8vIFVzZWQgd2l0aCByb2xsYmFyLXJlYWN0IGZvciByb2xsYmFyLXJlYWN0LW5hdGl2ZSBjb21wYXRpYmlsaXR5LlxuICB0aGlzLnJvbGxiYXIgPSB0aGlzO1xufVxudmFyIF9pbnN0YW5jZSA9IG51bGw7XG5Sb2xsYmFyLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2xpZW50KSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmdsb2JhbChvcHRpb25zKS5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgX2luc3RhbmNlID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KTtcbiAgcmV0dXJuIF9pbnN0YW5jZTtcbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5jb21wb25lbnRzID0ge307XG5Sb2xsYmFyLnNldENvbXBvbmVudHMgPSBmdW5jdGlvbiAoY29tcG9uZW50cykge1xuICBSb2xsYmFyLnByb3RvdHlwZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbn07XG5mdW5jdGlvbiBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnUm9sbGJhciBpcyBub3QgaW5pdGlhbGl6ZWQnO1xuICBsb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gIGlmIChtYXliZUNhbGxiYWNrKSB7XG4gICAgbWF5YmVDYWxsYmFjayhuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG59XG5Sb2xsYmFyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLmNsaWVudC5nbG9iYWwob3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblJvbGxiYXIuZ2xvYmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuZ2xvYmFsKG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXlsb2FkRGF0YSkge1xuICB2YXIgX3RoaXMkcmVjb3JkZXI7XG4gIHZhciBvbGRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgcGF5bG9hZCA9IHt9O1xuICBpZiAocGF5bG9hZERhdGEpIHtcbiAgICBwYXlsb2FkID0ge1xuICAgICAgcGF5bG9hZDogcGF5bG9hZERhdGFcbiAgICB9O1xuICB9XG4gIHRoaXMub3B0aW9ucyA9IF8uaGFuZGxlT3B0aW9ucyhvbGRPcHRpb25zLCBvcHRpb25zLCBwYXlsb2FkLCBsb2dnZXIpO1xuICB0aGlzLm9wdGlvbnMuX2NvbmZpZ3VyZWRPcHRpb25zID0gXy5oYW5kbGVPcHRpb25zKG9sZE9wdGlvbnMuX2NvbmZpZ3VyZWRPcHRpb25zLCBvcHRpb25zLCBwYXlsb2FkKTtcbiAgKF90aGlzJHJlY29yZGVyID0gdGhpcy5yZWNvcmRlcikgPT09IG51bGwgfHwgX3RoaXMkcmVjb3JkZXIgPT09IHZvaWQgMCB8fCBfdGhpcyRyZWNvcmRlci5jb25maWd1cmUodGhpcy5vcHRpb25zKTtcbiAgdGhpcy5jbGllbnQuY29uZmlndXJlKHRoaXMub3B0aW9ucywgcGF5bG9hZERhdGEpO1xuICB0aGlzLmluc3RydW1lbnRlciAmJiB0aGlzLmluc3RydW1lbnRlci5jb25maWd1cmUodGhpcy5vcHRpb25zKTtcbiAgdGhpcy5zZXR1cFVuaGFuZGxlZENhcHR1cmUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuUm9sbGJhci5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGF5bG9hZERhdGEpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuY29uZmlndXJlKG9wdGlvbnMsIHBheWxvYWREYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKCk7XG4gIH1cbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5sYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5sYXN0RXJyb3I7XG59O1xuUm9sbGJhci5sYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmxhc3RFcnJvcigpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC5sb2coaXRlbSk7XG4gIHJldHVybiB7XG4gICAgdXVpZDogdXVpZFxuICB9O1xufTtcblJvbGxiYXIubG9nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5sb2cuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXliZUNhbGxiYWNrID0gX2dldEZpcnN0RnVuY3Rpb24oYXJndW1lbnRzKTtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spO1xuICB9XG59O1xuUm9sbGJhci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQuZGVidWcoaXRlbSk7XG4gIHJldHVybiB7XG4gICAgdXVpZDogdXVpZFxuICB9O1xufTtcblJvbGxiYXIuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmRlYnVnLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQuaW5mbyhpdGVtKTtcbiAgcmV0dXJuIHtcbiAgICB1dWlkOiB1dWlkXG4gIH07XG59O1xuUm9sbGJhci5pbmZvID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5pbmZvLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQud2FybihpdGVtKTtcbiAgcmV0dXJuIHtcbiAgICB1dWlkOiB1dWlkXG4gIH07XG59O1xuUm9sbGJhci53YXJuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS53YXJuLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQud2FybmluZyhpdGVtKTtcbiAgcmV0dXJuIHtcbiAgICB1dWlkOiB1dWlkXG4gIH07XG59O1xuUm9sbGJhci53YXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS53YXJuaW5nLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oYXJndW1lbnRzKTtcbiAgdmFyIHV1aWQgPSBpdGVtLnV1aWQ7XG4gIHRoaXMuY2xpZW50LmVycm9yKGl0ZW0pO1xuICByZXR1cm4ge1xuICAgIHV1aWQ6IHV1aWRcbiAgfTtcbn07XG5Sb2xsYmFyLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5lcnJvci5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heWJlQ2FsbGJhY2sgPSBfZ2V0Rmlyc3RGdW5jdGlvbihhcmd1bWVudHMpO1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQobWF5YmVDYWxsYmFjayk7XG4gIH1cbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5jcml0aWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC5jcml0aWNhbChpdGVtKTtcbiAgcmV0dXJuIHtcbiAgICB1dWlkOiB1dWlkXG4gIH07XG59O1xuUm9sbGJhci5jcml0aWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuY3JpdGljYWwuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXliZUNhbGxiYWNrID0gX2dldEZpcnN0RnVuY3Rpb24oYXJndW1lbnRzKTtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spO1xuICB9XG59O1xuUm9sbGJhci5wcm90b3R5cGUuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5idWlsZEpzb25QYXlsb2FkKGl0ZW0pO1xufTtcblJvbGxiYXIuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuYnVpbGRKc29uUGF5bG9hZC5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZCgpO1xuICB9XG59O1xuUm9sbGJhci5wcm90b3R5cGUuc2VuZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKGpzb25QYXlsb2FkKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5zZW5kSnNvblBheWxvYWQoanNvblBheWxvYWQpO1xufTtcblJvbGxiYXIuc2VuZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5zZW5kSnNvblBheWxvYWQuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLnNldHVwVW5oYW5kbGVkQ2FwdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdXaW5kb3cgPSBfZ1dpbmRvdygpO1xuICBpZiAoIXRoaXMudW5oYW5kbGVkRXhjZXB0aW9uc0luaXRpYWxpemVkKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXB0dXJlVW5jYXVnaHQgfHwgdGhpcy5vcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucykge1xuICAgICAgZ2xvYmFscy5jYXB0dXJlVW5jYXVnaHRFeGNlcHRpb25zKGdXaW5kb3csIHRoaXMpO1xuICAgICAgaWYgKHRoaXMud3JhcEdsb2JhbHMgJiYgdGhpcy5vcHRpb25zLndyYXBHbG9iYWxFdmVudEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMud3JhcEdsb2JhbHMoZ1dpbmRvdywgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVuaGFuZGxlZEV4Y2VwdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zSW5pdGlhbGl6ZWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zIHx8IHRoaXMub3B0aW9ucy5oYW5kbGVVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICBnbG9iYWxzLmNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zKGdXaW5kb3csIHRoaXMpO1xuICAgICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblJvbGxiYXIucHJvdG90eXBlLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHVybCwgbGluZW5vLCBjb2xubywgZXJyb3IsIGNvbnRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuY2FwdHVyZVVuY2F1Z2h0ICYmICF0aGlzLm9wdGlvbnMuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2hyb21lIHdpbGwgYWx3YXlzIHNlbmQgNSsgYXJndW1lbnRzIGFuZCBlcnJvciB3aWxsIGJlIHZhbGlkIG9yIG51bGwsIG5vdCB1bmRlZmluZWQuXG4gIC8vIElmIGVycm9yIGlzIHVuZGVmaW5lZCwgd2UgaGF2ZSBhIGRpZmZlcmVudCBjYWxsZXIuXG4gIC8vIENocm9tZSBhbHNvIHNlbmRzIGVycm9ycyBmcm9tIHdlYiB3b3JrZXJzIHdpdGggbnVsbCBlcnJvciwgYnV0IGRvZXMgbm90IGludm9rZVxuICAvLyBwcmVwYXJlU3RhY2tUcmFjZSgpIGZvciB0aGVzZS4gVGVzdCBmb3IgZW1wdHkgdXJsIHRvIHNraXAgdGhlbS5cbiAgaWYgKHRoaXMub3B0aW9ucy5pbnNwZWN0QW5vbnltb3VzRXJyb3JzICYmIHRoaXMuaXNDaHJvbWUgJiYgZXJyb3IgPT09IG51bGwgJiYgdXJsID09PSAnJykge1xuICAgIHJldHVybiAnYW5vbnltb3VzJztcbiAgfVxuICB2YXIgaXRlbTtcbiAgdmFyIHN0YWNrSW5mbyA9IF8ubWFrZVVuaGFuZGxlZFN0YWNrSW5mbyhtZXNzYWdlLCB1cmwsIGxpbmVubywgY29sbm8sIGVycm9yLCAnb25lcnJvcicsICd1bmNhdWdodCBleGNlcHRpb24nLCBlcnJvclBhcnNlcik7XG4gIGlmIChfLmlzRXJyb3IoZXJyb3IpKSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIGVycm9yLCBjb250ZXh0XSk7XG4gICAgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvID0gc3RhY2tJbmZvO1xuICB9IGVsc2UgaWYgKF8uaXNFcnJvcih1cmwpKSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIHVybCwgY29udGV4dF0pO1xuICAgIGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mbyA9IHN0YWNrSW5mbztcbiAgfSBlbHNlIHtcbiAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShbbWVzc2FnZSwgY29udGV4dF0pO1xuICAgIGl0ZW0uc3RhY2tJbmZvID0gc3RhY2tJbmZvO1xuICB9XG4gIGl0ZW0ubGV2ZWwgPSB0aGlzLm9wdGlvbnMudW5jYXVnaHRFcnJvckxldmVsO1xuICBpdGVtLl9pc1VuY2F1Z2h0ID0gdHJ1ZTtcbiAgdGhpcy5jbGllbnQubG9nKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBDaHJvbWUgb25seS4gT3RoZXIgYnJvd3NlcnMgd2lsbCBpZ25vcmUuXG4gKlxuICogVXNlIEVycm9yLnByZXBhcmVTdGFja1RyYWNlIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gYWJvdXQgZXJyb3JzIHRoYXRcbiAqIGRvIG5vdCBoYXZlIGEgdmFsaWQgZXJyb3Igb2JqZWN0IGluIG9uZXJyb3IoKS5cbiAqXG4gKiBJbiB0ZXN0ZWQgdmVyc2lvbiBvZiBDaHJvbWUsIG9uZXJyb3IgaXMgY2FsbGVkIGZpcnN0IGJ1dCBoYXMgbm8gd2F5XG4gKiB0byBjb21tdW5pY2F0ZSB3aXRoIHByZXBhcmVTdGFja1RyYWNlLiBVc2UgYSBjb3VudGVyIHRvIGxldCB0aGlzXG4gKiBoYW5kbGVyIGtub3cgd2hpY2ggZXJyb3JzIHRvIHNlbmQgdG8gUm9sbGJhci5cbiAqXG4gKiBJbiBjb25maWcgb3B0aW9ucywgc2V0IGluc3BlY3RBbm9ueW1vdXNFcnJvcnMgdG8gZW5hYmxlLlxuICovXG5Sb2xsYmFyLnByb3RvdHlwZS5oYW5kbGVBbm9ueW1vdXNFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmluc3BlY3RBbm9ueW1vdXNFcnJvcnMgfHwgIXRoaXMuaXNDaHJvbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHIgPSB0aGlzO1xuICBmdW5jdGlvbiBwcmVwYXJlU3RhY2tUcmFjZShlcnJvciwgX3N0YWNrKSB7XG4gICAgaWYgKHIub3B0aW9ucy5pbnNwZWN0QW5vbnltb3VzRXJyb3JzKSB7XG4gICAgICBpZiAoci5hbm9ueW1vdXNFcnJvcnNQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkga25vd24gd2F5IHRvIGRldGVjdCB0aGF0IG9uZXJyb3Igc2F3IGFuIGFub255bW91cyBlcnJvci5cbiAgICAgICAgLy8gSXQgZGVwZW5kcyBvbiBvbmVycm9yIHJlbGlhYmx5IGJlaW5nIGNhbGxlZCBiZWZvcmUgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UsXG4gICAgICAgIC8vIHdoaWNoIHNvIGZhciBob2xkcyB0cnVlIG9uIHRlc3RlZCB2ZXJzaW9ucyBvZiBDaHJvbWUuIElmIHZlcnNpb25zIG9mIENocm9tZVxuICAgICAgICAvLyBhcmUgdGVzdGVkIHRoYXQgYmVoYXZlIGRpZmZlcmVudGx5LCB0aGlzIGxvZ2ljIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICByLmFub255bW91c0Vycm9yc1BlbmRpbmcgLT0gMTtcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIC8vIE5vdCBsaWtlbHkgdG8gZ2V0IGhlcmUsIGJ1dCBjYWxsaW5nIGhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uIGZyb20gaGVyZVxuICAgICAgICAgIC8vIHdpdGhvdXQgYW4gZXJyb3Igb2JqZWN0IHdvdWxkIHRocm93IG9mZiB0aGUgYW5vbnltb3VzRXJyb3JzUGVuZGluZyBjb3VudGVyLFxuICAgICAgICAgIC8vIHNvIHJldHVybiBub3cuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgdGhpcyB0byBiZSB0cmFja2VkIGxhdGVyLlxuICAgICAgICBlcnJvci5faXNBbm9ueW1vdXMgPSB0cnVlO1xuXG4gICAgICAgIC8vIHVybCwgbGluZW5vLCBjb2xubyBzaG91bGRuJ3QgYmUgbmVlZGVkIGZvciB0aGVzZSBlcnJvcnMuXG4gICAgICAgIC8vIElmIHRoYXQgY2hhbmdlcywgdXBkYXRlIHRoaXMgYWNjb3JkaW5nbHksIHVzaW5nIHRoZSB1bnVzZWRcbiAgICAgICAgLy8gX3N0YWNrIHBhcmFtIGFzIG5lZWRlZCAocmF0aGVyIHRoYW4gcGFyc2UgZXJyb3IudG9TdHJpbmcoKSkuXG4gICAgICAgIHIuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24oZXJyb3IubWVzc2FnZSwgbnVsbCwgbnVsbCwgbnVsbCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmthcm91bmQgdG8gZW5zdXJlIHN0YWNrIGlzIHByZXNlcnZlZCBmb3Igbm9ybWFsIGVycm9ycy5cbiAgICByZXR1cm4gZXJyb3Iuc3RhY2s7XG4gIH1cblxuICAvLyBodHRwczovL3Y4LmRldi9kb2NzL3N0YWNrLXRyYWNlLWFwaVxuICB0cnkge1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9wdGlvbnMuaW5zcGVjdEFub255bW91c0Vycm9ycyA9IGZhbHNlO1xuICAgIHRoaXMuZXJyb3IoJ2Fub255bW91cyBlcnJvciBoYW5kbGVyIGZhaWxlZCcsIGUpO1xuICB9XG59O1xuUm9sbGJhci5wcm90b3R5cGUuaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKHJlYXNvbiwgcHJvbWlzZSkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5jYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucyAmJiAhdGhpcy5vcHRpb25zLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1lc3NhZ2UgPSAndW5oYW5kbGVkIHJlamVjdGlvbiB3YXMgbnVsbCBvciB1bmRlZmluZWQhJztcbiAgaWYgKHJlYXNvbikge1xuICAgIGlmIChyZWFzb24ubWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSA9IHJlYXNvbi5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVhc29uUmVzdWx0ID0gXy5zdHJpbmdpZnkocmVhc29uKTtcbiAgICAgIGlmIChyZWFzb25SZXN1bHQudmFsdWUpIHtcbiAgICAgICAgbWVzc2FnZSA9IHJlYXNvblJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGNvbnRleHQgPSByZWFzb24gJiYgcmVhc29uLl9yb2xsYmFyQ29udGV4dCB8fCBwcm9taXNlICYmIHByb21pc2UuX3JvbGxiYXJDb250ZXh0O1xuICB2YXIgaXRlbTtcbiAgaWYgKF8uaXNFcnJvcihyZWFzb24pKSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIHJlYXNvbiwgY29udGV4dF0pO1xuICB9IGVsc2Uge1xuICAgIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKFttZXNzYWdlLCByZWFzb24sIGNvbnRleHRdKTtcbiAgICBpdGVtLnN0YWNrSW5mbyA9IF8ubWFrZVVuaGFuZGxlZFN0YWNrSW5mbyhtZXNzYWdlLCAnJywgMCwgMCwgbnVsbCwgJ3VuaGFuZGxlZHJlamVjdGlvbicsICcnLCBlcnJvclBhcnNlcik7XG4gIH1cbiAgaXRlbS5sZXZlbCA9IHRoaXMub3B0aW9ucy51bmNhdWdodEVycm9yTGV2ZWw7XG4gIGl0ZW0uX2lzVW5jYXVnaHQgPSB0cnVlO1xuICBpdGVtLl9vcmlnaW5hbEFyZ3MgPSBpdGVtLl9vcmlnaW5hbEFyZ3MgfHwgW107XG4gIGl0ZW0uX29yaWdpbmFsQXJncy5wdXNoKHByb21pc2UpO1xuICB0aGlzLmNsaWVudC5sb2coaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChmLCBjb250ZXh0LCBfYmVmb3JlKSB7XG4gIHRyeSB7XG4gICAgdmFyIGN0eEZuO1xuICAgIGlmIChfLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcbiAgICAgIGN0eEZuID0gY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4Rm4gPSBmdW5jdGlvbiBjdHhGbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgfHwge307XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmKSkge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuICAgIGlmIChmLl9pc1dyYXApIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgICBpZiAoIWYuX3JvbGxiYXJfd3JhcHBlZCkge1xuICAgICAgZi5fcm9sbGJhcl93cmFwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX2JlZm9yZSAmJiBfLmlzRnVuY3Rpb24oX2JlZm9yZSkpIHtcbiAgICAgICAgICBfYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgICB2YXIgZSA9IGV4YztcbiAgICAgICAgICBpZiAoZSAmJiB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IgIT09IGUpIHtcbiAgICAgICAgICAgIGlmIChfLmlzVHlwZShlLCAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgZSA9IG5ldyBTdHJpbmcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLl9yb2xsYmFyQ29udGV4dCA9IGN0eEZuKCkgfHwge307XG4gICAgICAgICAgICBlLl9yb2xsYmFyQ29udGV4dC5fd3JhcHBlZFNvdXJjZSA9IGYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHdpbmRvdy5fcm9sbGJhcldyYXBwZWRFcnJvciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmLl9yb2xsYmFyX3dyYXBwZWQuX2lzV3JhcCA9IHRydWU7XG4gICAgICBpZiAoZi5oYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGYpIHtcbiAgICAgICAgICBpZiAoZi5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwcm9wICE9PSAnX3JvbGxiYXJfd3JhcHBlZCcpIHtcbiAgICAgICAgICAgIGYuX3JvbGxiYXJfd3JhcHBlZFtwcm9wXSA9IGZbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmLl9yb2xsYmFyX3dyYXBwZWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBSZXR1cm4gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGlmIHRoZSB3cmFwIGZhaWxzLlxuICAgIHJldHVybiBmO1xuICB9XG59O1xuUm9sbGJhci53cmFwID0gZnVuY3Rpb24gKGYsIGNvbnRleHQpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2Uud3JhcChmLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKCk7XG4gIH1cbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBldmVudCA9IF8uY3JlYXRlVGVsZW1ldHJ5RXZlbnQoYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXMuY2xpZW50LmNhcHR1cmVFdmVudChldmVudC50eXBlLCBldmVudC5tZXRhZGF0YSwgZXZlbnQubGV2ZWwpO1xufTtcblJvbGxiYXIuY2FwdHVyZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5jYXB0dXJlRXZlbnQuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyB0d28gbWV0aG9kcyBhcmUgdXNlZCBpbnRlcm5hbGx5IGFuZCBhcmUgbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlRG9tQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uIChlLCB0cykge1xuICBpZiAoIXRzKSB7XG4gICAgdHMgPSBuZXcgRGF0ZSgpO1xuICB9XG4gIHJldHVybiB0aGlzLmNsaWVudC5jYXB0dXJlRG9tQ29udGVudExvYWRlZCh0cyk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuY2FwdHVyZUxvYWQgPSBmdW5jdGlvbiAoZSwgdHMpIHtcbiAgaWYgKCF0cykge1xuICAgIHRzID0gbmV3IERhdGUoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbGllbnQuY2FwdHVyZUxvYWQodHMpO1xufTtcblxuLyogSW50ZXJuYWwgKi9cblxuZnVuY3Rpb24gYWRkVHJhbnNmb3Jtc1RvTm90aWZpZXIobm90aWZpZXIsIHJvbGxiYXIsIGdXaW5kb3cpIHtcbiAgbm90aWZpZXIuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuaGFuZGxlRG9tRXhjZXB0aW9uKS5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5oYW5kbGVJdGVtV2l0aEVycm9yKS5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5lbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXkpLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmFkZEJhc2VJbmZvKS5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRSZXF1ZXN0SW5mbyhnV2luZG93KSkuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkQ2xpZW50SW5mbyhnV2luZG93KSkuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkUGx1Z2luSW5mbyhnV2luZG93KSkuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkQm9keSkuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkTWVzc2FnZVdpdGhFcnJvcikuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkVGVsZW1ldHJ5RGF0YSkuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkQ29uZmlnVG9QYXlsb2FkKS5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRTY3J1YmJlcihyb2xsYmFyLnNjcnViKSkuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkUGF5bG9hZE9wdGlvbnMpLmFkZFRyYW5zZm9ybShzaGFyZWRUcmFuc2Zvcm1zLnVzZXJUcmFuc2Zvcm0obG9nZ2VyKSkuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkQ29uZmlndXJlZE9wdGlvbnMpLmFkZFRyYW5zZm9ybShzaGFyZWRUcmFuc2Zvcm1zLmFkZERpYWdub3N0aWNLZXlzKS5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5pdGVtVG9QYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGFkZFByZWRpY2F0ZXNUb1F1ZXVlKHF1ZXVlKSB7XG4gIHF1ZXVlLmFkZFByZWRpY2F0ZShzaGFyZWRQcmVkaWNhdGVzLmNoZWNrTGV2ZWwpLmFkZFByZWRpY2F0ZShwcmVkaWNhdGVzLmNoZWNrSWdub3JlKS5hZGRQcmVkaWNhdGUoc2hhcmVkUHJlZGljYXRlcy51c2VyQ2hlY2tJZ25vcmUobG9nZ2VyKSkuYWRkUHJlZGljYXRlKHNoYXJlZFByZWRpY2F0ZXMudXJsSXNOb3RCbG9ja0xpc3RlZChsb2dnZXIpKS5hZGRQcmVkaWNhdGUoc2hhcmVkUHJlZGljYXRlcy51cmxJc1NhZmVMaXN0ZWQobG9nZ2VyKSkuYWRkUHJlZGljYXRlKHNoYXJlZFByZWRpY2F0ZXMubWVzc2FnZUlzSWdub3JlZChsb2dnZXIpKTtcbn1cblJvbGxiYXIucHJvdG90eXBlLmxvYWRGdWxsID0gZnVuY3Rpb24gKCkge1xuICBsb2dnZXIuaW5mbygnVW5leHBlY3RlZCBSb2xsYmFyLmxvYWRGdWxsKCkgY2FsbGVkIG9uIGEgTm90aWZpZXIgaW5zdGFuY2UuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIFJvbGxiYXIgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLicpO1xufTtcblJvbGxiYXIucHJvdG90eXBlLl9jcmVhdGVJdGVtID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgcmV0dXJuIF8uY3JlYXRlSXRlbShhcmdzLCBsb2dnZXIsIHRoaXMpO1xufTtcbmZ1bmN0aW9uIF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3MpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbaV0pKSB7XG4gICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9nV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwgdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZjtcbn1cbnZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjk5KTtcbnZhciBzY3J1YkZpZWxkcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjk5KTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgdmVyc2lvbjogZGVmYXVsdHMudmVyc2lvbixcbiAgc2NydWJGaWVsZHM6IHNjcnViRmllbGRzLnNjcnViRmllbGRzLFxuICBsb2dMZXZlbDogZGVmYXVsdHMubG9nTGV2ZWwsXG4gIHJlcG9ydExldmVsOiBkZWZhdWx0cy5yZXBvcnRMZXZlbCxcbiAgdW5jYXVnaHRFcnJvckxldmVsOiBkZWZhdWx0cy51bmNhdWdodEVycm9yTGV2ZWwsXG4gIGVuZHBvaW50OiBkZWZhdWx0cy5lbmRwb2ludCxcbiAgdmVyYm9zZTogZmFsc2UsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHRyYW5zbWl0OiB0cnVlLFxuICBzZW5kQ29uZmlnOiBmYWxzZSxcbiAgaW5jbHVkZUl0ZW1zSW5UZWxlbWV0cnk6IHRydWUsXG4gIGNhcHR1cmVJcDogdHJ1ZSxcbiAgaW5zcGVjdEFub255bW91c0Vycm9yczogdHJ1ZSxcbiAgaWdub3JlRHVwbGljYXRlRXJyb3JzOiB0cnVlLFxuICB3cmFwR2xvYmFsRXZlbnRIYW5kbGVyczogZmFsc2UsXG4gIHJlY29yZGVyOiByZWNvcmRlckRlZmF1bHRzLFxuICB0cmFjaW5nOiB0cmFjaW5nRGVmYXVsdHNcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFJvbGxiYXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1ODU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBtZXJnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTY1KTtcbnZhciBSb2xsYmFySlNPTiA9IHt9O1xuZnVuY3Rpb24gc2V0dXBKU09OKHBvbHlmaWxsSlNPTikge1xuICBpZiAoaXNGdW5jdGlvbihSb2xsYmFySlNPTi5zdHJpbmdpZnkpICYmIGlzRnVuY3Rpb24oUm9sbGJhckpTT04ucGFyc2UpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0RlZmluZWQoSlNPTikpIHtcbiAgICAvLyBJZiBwb2x5ZmlsbCBpcyBwcm92aWRlZCwgcHJlZmVyIGl0IG92ZXIgZXhpc3Rpbmcgbm9uLW5hdGl2ZSBzaGltcy5cbiAgICBpZiAocG9seWZpbGxKU09OKSB7XG4gICAgICBpZiAoaXNOYXRpdmVGdW5jdGlvbihKU09OLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgUm9sbGJhckpTT04uc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYXRpdmVGdW5jdGlvbihKU09OLnBhcnNlKSkge1xuICAgICAgICBSb2xsYmFySlNPTi5wYXJzZSA9IEpTT04ucGFyc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsc2UgYWNjZXB0IGFueSBpbnRlcmZhY2UgdGhhdCBpcyBwcmVzZW50LlxuICAgICAgaWYgKGlzRnVuY3Rpb24oSlNPTi5zdHJpbmdpZnkpKSB7XG4gICAgICAgIFJvbGxiYXJKU09OLnN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgICAgfVxuICAgICAgaWYgKGlzRnVuY3Rpb24oSlNPTi5wYXJzZSkpIHtcbiAgICAgICAgUm9sbGJhckpTT04ucGFyc2UgPSBKU09OLnBhcnNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRnVuY3Rpb24oUm9sbGJhckpTT04uc3RyaW5naWZ5KSB8fCAhaXNGdW5jdGlvbihSb2xsYmFySlNPTi5wYXJzZSkpIHtcbiAgICBwb2x5ZmlsbEpTT04gJiYgcG9seWZpbGxKU09OKFJvbGxiYXJKU09OKTtcbiAgfVxufVxuXG4vKlxuICogaXNUeXBlIC0gR2l2ZW4gYSBKYXZhc2NyaXB0IHZhbHVlIGFuZCBhIHN0cmluZywgcmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZVxuICogZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB4IC0gYW55IHZhbHVlXG4gKiBAcGFyYW0gdCAtIGEgbG93ZXJjYXNlIHN0cmluZyBjb250YWluaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIHR5cGUgbmFtZXM6XG4gKiAgICAtIHVuZGVmaW5lZFxuICogICAgLSBudWxsXG4gKiAgICAtIGVycm9yXG4gKiAgICAtIG51bWJlclxuICogICAgLSBib29sZWFuXG4gKiAgICAtIHN0cmluZ1xuICogICAgLSBzeW1ib2xcbiAqICAgIC0gZnVuY3Rpb25cbiAqICAgIC0gb2JqZWN0XG4gKiAgICAtIGFycmF5XG4gKiBAcmV0dXJucyB0cnVlIGlmIHggaXMgb2YgdHlwZSB0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNUeXBlKHgsIHQpIHtcbiAgcmV0dXJuIHQgPT09IHR5cGVOYW1lKHgpO1xufVxuXG4vKlxuICogdHlwZU5hbWUgLSBHaXZlbiBhIEphdmFzY3JpcHQgdmFsdWUsIHJldHVybnMgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCBhcyBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiB0eXBlTmFtZSh4KSB7XG4gIHZhciBuYW1lID0gX3R5cGVvZih4KTtcbiAgaWYgKG5hbWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgaWYgKCF4KSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBpZiAoeCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuICdlcnJvcic7XG4gIH1cbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyogaXNGdW5jdGlvbiAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgYSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGYgaXMgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZikge1xuICByZXR1cm4gaXNUeXBlKGYsICdmdW5jdGlvbicpO1xufVxuXG4vKiBpc05hdGl2ZUZ1bmN0aW9uIC0gYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBpcyBhIG5hdGl2ZSBKUyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGYgaXMgYSBuYXRpdmUgSlMgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZUZ1bmN0aW9uKGYpIHtcbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcbiAgdmFyIGZ1bmNNYXRjaFN0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJykucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/Jyk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNNYXRjaFN0cmluZyArICckJyk7XG4gIHJldHVybiBpc09iamVjdChmKSAmJiByZUlzTmF0aXZlLnRlc3QoZik7XG59XG5cbi8qIGlzT2JqZWN0IC0gQ2hlY2tzIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaXMgdmFsdWUgaXMgYW4gb2JqZWN0IGZ1bmN0aW9uIGlzIGFuIG9iamVjdClcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyogaXNTdHJpbmcgLSBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIGlzRmluaXRlTnVtYmVyIC0gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSBuIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZmluaXRlIG51bWJlclxuICovXG5mdW5jdGlvbiBpc0Zpbml0ZU51bWJlcihuKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobik7XG59XG5cbi8qXG4gKiBpc0RlZmluZWQgLSBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0gdSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB1IGlzIGFueXRoaW5nIG90aGVyIHRoYW4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGlzRGVmaW5lZCh1KSB7XG4gIHJldHVybiAhaXNUeXBlKHUsICd1bmRlZmluZWQnKTtcbn1cblxuLypcbiAqIGlzSXRlcmFibGUgLSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBjYW4gYmUgaXRlcmF0ZWQsIGVzc2VudGlhbGx5XG4gKiB3aGV0aGVyIGl0IGlzIGFuIG9iamVjdCBvciBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gaSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBpIGlzIGFuIG9iamVjdCBvciBhbiBhcnJheSBhcyBkZXRlcm1pbmVkIGJ5IGB0eXBlTmFtZWBcbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZShpKSB7XG4gIHZhciB0eXBlID0gdHlwZU5hbWUoaSk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnYXJyYXknO1xufVxuXG4vKlxuICogaXNFcnJvciAtIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIG9mIGFuIGVycm9yIHR5cGVcbiAqXG4gKiBAcGFyYW0gZSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBlIGlzIGFuIGVycm9yXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAvLyBEZXRlY3QgYm90aCBFcnJvciBhbmQgRmlyZWZveCBFeGNlcHRpb24gdHlwZVxuICByZXR1cm4gaXNUeXBlKGUsICdlcnJvcicpIHx8IGlzVHlwZShlLCAnZXhjZXB0aW9uJyk7XG59XG5cbi8qIGlzUHJvbWlzZSAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgYSBwcm9taXNlXG4gKlxuICogQHBhcmFtIHAgLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgZiBpcyBhIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHApICYmIGlzVHlwZShwLnRoZW4sICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIGlzQnJvd3NlciAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIHRoZSBjb2RlIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY29kZSBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIHJlZGFjdCgpIHtcbiAgcmV0dXJuICcqKioqKioqKic7XG59XG5cbi8vIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODgwOTQ3Mi8xMTM4MTkxXG5mdW5jdGlvbiB1dWlkNCgpIHtcbiAgdmFyIGQgPSBub3coKTtcbiAgdmFyIHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT09ICd4JyA/IHIgOiByICYgMHg3IHwgMHg4KS50b1N0cmluZygxNik7XG4gIH0pO1xuICByZXR1cm4gdXVpZDtcbn1cbnZhciBMRVZFTFMgPSB7XG4gIGRlYnVnOiAwLFxuICBpbmZvOiAxLFxuICB3YXJuaW5nOiAyLFxuICBlcnJvcjogMyxcbiAgY3JpdGljYWw6IDRcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgdmFyIGJhc2VVcmxQYXJ0cyA9IHBhcnNlVXJpKHVybCk7XG4gIGlmICghYmFzZVVybFBhcnRzKSB7XG4gICAgcmV0dXJuICcodW5rbm93biknO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGEgdHJhaWxpbmcgIyBpZiB0aGVyZSBpcyBubyBhbmNob3JcbiAgaWYgKGJhc2VVcmxQYXJ0cy5hbmNob3IgPT09ICcnKSB7XG4gICAgYmFzZVVybFBhcnRzLnNvdXJjZSA9IGJhc2VVcmxQYXJ0cy5zb3VyY2UucmVwbGFjZSgnIycsICcnKTtcbiAgfVxuICB1cmwgPSBiYXNlVXJsUGFydHMuc291cmNlLnJlcGxhY2UoJz8nICsgYmFzZVVybFBhcnRzLnF1ZXJ5LCAnJyk7XG4gIHJldHVybiB1cmw7XG59XG52YXIgcGFyc2VVcmlPcHRpb25zID0ge1xuICBzdHJpY3RNb2RlOiBmYWxzZSxcbiAga2V5OiBbJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXSxcbiAgcToge1xuICAgIG5hbWU6ICdxdWVyeUtleScsXG4gICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcbiAgfSxcbiAgcGFyc2VyOiB7XG4gICAgc3RyaWN0OiAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCgoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxuICAgIGxvb3NlOiAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShbXjpcXC8/Iy5dKyk6KT8oPzpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS9cbiAgfVxufTtcbmZ1bmN0aW9uIHBhcnNlVXJpKHN0cikge1xuICBpZiAoIWlzVHlwZShzdHIsICdzdHJpbmcnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIG8gPSBwYXJzZVVyaU9wdGlvbnM7XG4gIHZhciBtID0gby5wYXJzZXJbby5zdHJpY3RNb2RlID8gJ3N0cmljdCcgOiAnbG9vc2UnXS5leGVjKHN0cik7XG4gIHZhciB1cmkgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvLmtleS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCAnJztcbiAgfVxuICB1cmlbby5xLm5hbWVdID0ge307XG4gIHVyaVtvLmtleVsxMl1dLnJlcGxhY2Uoby5xLnBhcnNlciwgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICBpZiAoJDEpIHtcbiAgICAgIHVyaVtvLnEubmFtZV1bJDFdID0gJDI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVyaTtcbn1cbmZ1bmN0aW9uIGFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoKGFjY2Vzc1Rva2VuLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMuYWNjZXNzX3Rva2VuID0gYWNjZXNzVG9rZW47XG4gIHZhciBwYXJhbXNBcnJheSA9IFtdO1xuICB2YXIgaztcbiAgZm9yIChrIGluIHBhcmFtcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBrKSkge1xuICAgICAgcGFyYW1zQXJyYXkucHVzaChbaywgcGFyYW1zW2tdXS5qb2luKCc9JykpO1xuICAgIH1cbiAgfVxuICB2YXIgcXVlcnkgPSAnPycgKyBwYXJhbXNBcnJheS5zb3J0KCkuam9pbignJicpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8ICcnO1xuICB2YXIgcXMgPSBvcHRpb25zLnBhdGguaW5kZXhPZignPycpO1xuICB2YXIgaCA9IG9wdGlvbnMucGF0aC5pbmRleE9mKCcjJyk7XG4gIHZhciBwO1xuICBpZiAocXMgIT09IC0xICYmIChoID09PSAtMSB8fCBoID4gcXMpKSB7XG4gICAgcCA9IG9wdGlvbnMucGF0aDtcbiAgICBvcHRpb25zLnBhdGggPSBwLnN1YnN0cmluZygwLCBxcykgKyBxdWVyeSArICcmJyArIHAuc3Vic3RyaW5nKHFzICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGggIT09IC0xKSB7XG4gICAgICBwID0gb3B0aW9ucy5wYXRoO1xuICAgICAgb3B0aW9ucy5wYXRoID0gcC5zdWJzdHJpbmcoMCwgaCkgKyBxdWVyeSArIHAuc3Vic3RyaW5nKGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnBhdGggKyBxdWVyeTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFVybCh1LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sIHx8IHUucHJvdG9jb2w7XG4gIGlmICghcHJvdG9jb2wgJiYgdS5wb3J0KSB7XG4gICAgaWYgKHUucG9ydCA9PT0gODApIHtcbiAgICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgICB9IGVsc2UgaWYgKHUucG9ydCA9PT0gNDQzKSB7XG4gICAgICBwcm90b2NvbCA9ICdodHRwczonO1xuICAgIH1cbiAgfVxuICBwcm90b2NvbCA9IHByb3RvY29sIHx8ICdodHRwczonO1xuICBpZiAoIXUuaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAnLy8nICsgdS5ob3N0bmFtZTtcbiAgaWYgKHUucG9ydCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCArICc6JyArIHUucG9ydDtcbiAgfVxuICBpZiAodS5wYXRoKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgdS5wYXRoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBiYWNrdXApIHtcbiAgdmFyIHZhbHVlLCBlcnJvcjtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IFJvbGxiYXJKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGNhdGNoIChqc29uRXJyb3IpIHtcbiAgICBpZiAoYmFja3VwICYmIGlzRnVuY3Rpb24oYmFja3VwKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBiYWNrdXAob2JqKTtcbiAgICAgIH0gY2F0Y2ggKGJhY2t1cEVycm9yKSB7XG4gICAgICAgIGVycm9yID0gYmFja3VwRXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yID0ganNvbkVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGVycm9yOiBlcnJvcixcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIG1heEJ5dGVTaXplKHN0cmluZykge1xuICAvLyBUaGUgdHJhbnNwb3J0IHdpbGwgdXNlIHV0Zi04LCBzbyBhc3N1bWUgdXRmLTggZW5jb2RpbmcuXG4gIC8vXG4gIC8vIFRoaXMgbWluaW1hbCBpbXBsZW1lbnRhdGlvbiB3aWxsIGFjY3VyYXRlbHkgY291bnQgYnl0ZXMgZm9yIGFsbCBVQ1MtMiBhbmRcbiAgLy8gc2luZ2xlIGNvZGUgcG9pbnQgVVRGLTE2LiBJZiBwcmVzZW50ZWQgd2l0aCBtdWx0aSBjb2RlIHBvaW50IFVURi0xNixcbiAgLy8gd2hpY2ggc2hvdWxkIGJlIHJhcmUsIGl0IHdpbGwgc2FmZWx5IG92ZXJjb3VudCwgbm90IHVuZGVyY291bnQuXG4gIC8vXG4gIC8vIFdoaWxlIHJvYnVzdCB1dGYtOCBlbmNvZGVycyBleGlzdCwgdGhpcyBpcyBmYXIgc21hbGxlciBhbmQgZmFyIG1vcmUgcGVyZm9ybWFudC5cbiAgLy8gRm9yIHF1aWNrbHkgY291bnRpbmcgcGF5bG9hZCBzaXplIGZvciB0cnVuY2F0aW9uLCBzbWFsbGVyIGlzIGJldHRlci5cblxuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIC8vIHVwIHRvIDcgYml0c1xuICAgICAgY291bnQgPSBjb3VudCArIDE7XG4gICAgfSBlbHNlIGlmIChjb2RlIDwgMjA0OCkge1xuICAgICAgLy8gdXAgdG8gMTEgYml0c1xuICAgICAgY291bnQgPSBjb3VudCArIDI7XG4gICAgfSBlbHNlIGlmIChjb2RlIDwgNjU1MzYpIHtcbiAgICAgIC8vIHVwIHRvIDE2IGJpdHNcbiAgICAgIGNvdW50ID0gY291bnQgKyAzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBqc29uUGFyc2Uocykge1xuICB2YXIgdmFsdWUsIGVycm9yO1xuICB0cnkge1xuICAgIHZhbHVlID0gUm9sbGJhckpTT04ucGFyc2Uocyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlcnJvcjogZXJyb3IsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlVW5oYW5kbGVkU3RhY2tJbmZvKG1lc3NhZ2UsIHVybCwgbGluZW5vLCBjb2xubywgZXJyb3IsIG1vZGUsIGJhY2t1cE1lc3NhZ2UsIGVycm9yUGFyc2VyKSB7XG4gIHZhciBsb2NhdGlvbiA9IHtcbiAgICB1cmw6IHVybCB8fCAnJyxcbiAgICBsaW5lOiBsaW5lbm8sXG4gICAgY29sdW1uOiBjb2xub1xuICB9O1xuICBsb2NhdGlvbi5mdW5jID0gZXJyb3JQYXJzZXIuZ3Vlc3NGdW5jdGlvbk5hbWUobG9jYXRpb24udXJsLCBsb2NhdGlvbi5saW5lKTtcbiAgbG9jYXRpb24uY29udGV4dCA9IGVycm9yUGFyc2VyLmdhdGhlckNvbnRleHQobG9jYXRpb24udXJsLCBsb2NhdGlvbi5saW5lKTtcbiAgdmFyIGhyZWYgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmxvY2F0aW9uICYmIGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gIHZhciB1c2VyYWdlbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHtcbiAgICBtb2RlOiBtb2RlLFxuICAgIG1lc3NhZ2U6IGVycm9yID8gU3RyaW5nKGVycm9yKSA6IG1lc3NhZ2UgfHwgYmFja3VwTWVzc2FnZSxcbiAgICB1cmw6IGhyZWYsXG4gICAgc3RhY2s6IFtsb2NhdGlvbl0sXG4gICAgdXNlcmFnZW50OiB1c2VyYWdlbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBDYWxsYmFjayhsb2dnZXIsIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICB0cnkge1xuICAgICAgZihlcnIsIHJlc3ApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBub25DaXJjdWxhckNsb25lKG9iaikge1xuICB2YXIgc2VlbiA9IFtvYmpdO1xuICBmdW5jdGlvbiBjbG9uZShvYmosIHNlZW4pIHtcbiAgICB2YXIgdmFsdWUsXG4gICAgICBuYW1lLFxuICAgICAgbmV3U2VlbixcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgJiYgKGlzVHlwZSh2YWx1ZSwgJ29iamVjdCcpIHx8IGlzVHlwZSh2YWx1ZSwgJ2FycmF5JykpKSB7XG4gICAgICAgICAgaWYgKHNlZW4uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSAnUmVtb3ZlZCBjaXJjdWxhciByZWZlcmVuY2U6ICcgKyB0eXBlTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NlZW4gPSBzZWVuLnNsaWNlKCk7XG4gICAgICAgICAgICBuZXdTZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gY2xvbmUodmFsdWUsIG5ld1NlZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSAnRmFpbGVkIGNsb25pbmcgY3VzdG9tIGRhdGE6ICcgKyBlLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGNsb25lKG9iaiwgc2Vlbik7XG59XG5mdW5jdGlvbiBjcmVhdGVJdGVtKGFyZ3MsIGxvZ2dlciwgbm90aWZpZXIsIHJlcXVlc3RLZXlzLCBsYW1iZGFDb250ZXh0KSB7XG4gIHZhciBtZXNzYWdlLCBlcnIsIGN1c3RvbSwgY2FsbGJhY2ssIHJlcXVlc3Q7XG4gIHZhciBhcmc7XG4gIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgdmFyIGRpYWdub3N0aWMgPSB7fTtcbiAgdmFyIGFyZ1R5cGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBhcmcgPSBhcmdzW2ldO1xuICAgIHZhciB0eXAgPSB0eXBlTmFtZShhcmcpO1xuICAgIGFyZ1R5cGVzLnB1c2godHlwKTtcbiAgICBzd2l0Y2ggKHR5cCkge1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBtZXNzYWdlID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IG1lc3NhZ2UgPSBhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBjYWxsYmFjayA9IHdyYXBDYWxsYmFjayhsb2dnZXIsIGFyZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgIGV4dHJhQXJncy5wdXNoKGFyZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgY2FzZSAnZG9tZXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ2V4Y2VwdGlvbic6XG4gICAgICAgIC8vIEZpcmVmb3ggRXhjZXB0aW9uIHR5cGVcbiAgICAgICAgZXJyID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IGVyciA9IGFyZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgICAgZXJyID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IGVyciA9IGFyZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdEtleXMgJiYgdHlwID09PSAnb2JqZWN0JyAmJiAhcmVxdWVzdCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSByZXF1ZXN0S2V5cy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgaWYgKGFyZ1tyZXF1ZXN0S2V5c1tqXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gYXJnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXN0b20gPyBleHRyYUFyZ3MucHVzaChhcmcpIDogY3VzdG9tID0gYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBhcmcgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcbiAgICAgICAgICBlcnIgPyBleHRyYUFyZ3MucHVzaChhcmcpIDogZXJyID0gYXJnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhQXJncy5wdXNoKGFyZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgY3VzdG9tIGlzIGFuIGFycmF5IHRoaXMgdHVybnMgaXQgaW50byBhbiBvYmplY3Qgd2l0aCBpbnRlZ2VyIGtleXNcbiAgaWYgKGN1c3RvbSkgY3VzdG9tID0gbm9uQ2lyY3VsYXJDbG9uZShjdXN0b20pO1xuICBpZiAoZXh0cmFBcmdzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIWN1c3RvbSkgY3VzdG9tID0gbm9uQ2lyY3VsYXJDbG9uZSh7fSk7XG4gICAgY3VzdG9tLmV4dHJhQXJncyA9IG5vbkNpcmN1bGFyQ2xvbmUoZXh0cmFBcmdzKTtcbiAgfVxuICB2YXIgaXRlbSA9IHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGVycjogZXJyLFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIHRpbWVzdGFtcDogbm93KCksXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIG5vdGlmaWVyOiBub3RpZmllcixcbiAgICBkaWFnbm9zdGljOiBkaWFnbm9zdGljLFxuICAgIHV1aWQ6IHV1aWQ0KClcbiAgfTtcbiAgaXRlbS5kYXRhID0gaXRlbS5kYXRhIHx8IHt9O1xuICBzZXRDdXN0b21JdGVtS2V5cyhpdGVtLCBjdXN0b20pO1xuICBpZiAocmVxdWVzdEtleXMgJiYgcmVxdWVzdCkge1xuICAgIGl0ZW0ucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIH1cbiAgaWYgKGxhbWJkYUNvbnRleHQpIHtcbiAgICBpdGVtLmxhbWJkYUNvbnRleHQgPSBsYW1iZGFDb250ZXh0O1xuICB9XG4gIGl0ZW0uX29yaWdpbmFsQXJncyA9IGFyZ3M7XG4gIGl0ZW0uZGlhZ25vc3RpYy5vcmlnaW5hbF9hcmdfdHlwZXMgPSBhcmdUeXBlcztcbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBzZXRDdXN0b21JdGVtS2V5cyhpdGVtLCBjdXN0b20pIHtcbiAgaWYgKGN1c3RvbSAmJiBjdXN0b20ubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGl0ZW0ubGV2ZWwgPSBjdXN0b20ubGV2ZWw7XG4gICAgZGVsZXRlIGN1c3RvbS5sZXZlbDtcbiAgfVxuICBpZiAoY3VzdG9tICYmIGN1c3RvbS5za2lwRnJhbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpdGVtLnNraXBGcmFtZXMgPSBjdXN0b20uc2tpcEZyYW1lcztcbiAgICBkZWxldGUgY3VzdG9tLnNraXBGcmFtZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEVycm9yQ29udGV4dChpdGVtLCBlcnJvcnMpIHtcbiAgdmFyIGN1c3RvbSA9IGl0ZW0uZGF0YS5jdXN0b20gfHwge307XG4gIHZhciBjb250ZXh0QWRkZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGVycm9yc1tpXS5oYXNPd25Qcm9wZXJ0eSgncm9sbGJhckNvbnRleHQnKSkge1xuICAgICAgICBjdXN0b20gPSBtZXJnZShjdXN0b20sIG5vbkNpcmN1bGFyQ2xvbmUoZXJyb3JzW2ldLnJvbGxiYXJDb250ZXh0KSk7XG4gICAgICAgIGNvbnRleHRBZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYWRkaW5nIGFuIGVtcHR5IG9iamVjdCB0byB0aGUgZGF0YS5cbiAgICBpZiAoY29udGV4dEFkZGVkKSB7XG4gICAgICBpdGVtLmRhdGEuY3VzdG9tID0gY3VzdG9tO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGl0ZW0uZGlhZ25vc3RpYy5lcnJvcl9jb250ZXh0ID0gJ0ZhaWxlZDogJyArIGUubWVzc2FnZTtcbiAgfVxufVxudmFyIFRFTEVNRVRSWV9UWVBFUyA9IFsnbG9nJywgJ25ldHdvcmsnLCAnZG9tJywgJ25hdmlnYXRpb24nLCAnZXJyb3InLCAnbWFudWFsJ107XG52YXIgVEVMRU1FVFJZX0xFVkVMUyA9IFsnY3JpdGljYWwnLCAnZXJyb3InLCAnd2FybmluZycsICdpbmZvJywgJ2RlYnVnJ107XG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgYXJyLmxlbmd0aDsgKytrKSB7XG4gICAgaWYgKGFycltrXSA9PT0gdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlVGVsZW1ldHJ5RXZlbnQoYXJncykge1xuICB2YXIgdHlwZSwgbWV0YWRhdGEsIGxldmVsO1xuICB2YXIgYXJnO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgYXJnID0gYXJnc1tpXTtcbiAgICB2YXIgdHlwID0gdHlwZU5hbWUoYXJnKTtcbiAgICBzd2l0Y2ggKHR5cCkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaWYgKCF0eXBlICYmIGFycmF5SW5jbHVkZXMoVEVMRU1FVFJZX1RZUEVTLCBhcmcpKSB7XG4gICAgICAgICAgdHlwZSA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmICghbGV2ZWwgJiYgYXJyYXlJbmNsdWRlcyhURUxFTUVUUllfTEVWRUxTLCBhcmcpKSB7XG4gICAgICAgICAgbGV2ZWwgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBtZXRhZGF0YSA9IGFyZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGV2ZW50ID0ge1xuICAgIHR5cGU6IHR5cGUgfHwgJ21hbnVhbCcsXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICAgIGxldmVsOiBsZXZlbFxuICB9O1xuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBhZGRJdGVtQXR0cmlidXRlcyhpdGVtLCBhdHRyaWJ1dGVzKSB7XG4gIGl0ZW0uZGF0YS5hdHRyaWJ1dGVzID0gaXRlbS5kYXRhLmF0dHJpYnV0ZXMgfHwgW107XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIF9pdGVtJGRhdGEkYXR0cmlidXRlcztcbiAgICAoX2l0ZW0kZGF0YSRhdHRyaWJ1dGVzID0gaXRlbS5kYXRhLmF0dHJpYnV0ZXMpLnB1c2guYXBwbHkoX2l0ZW0kZGF0YSRhdHRyaWJ1dGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoYXR0cmlidXRlcykpO1xuICB9XG59XG5cbi8qXG4gKiBnZXQgLSBnaXZlbiBhbiBvYmovYXJyYXkgYW5kIGEga2V5cGF0aCwgcmV0dXJuIHRoZSB2YWx1ZSBhdCB0aGF0IGtleXBhdGggb3JcbiAqICAgICAgIHVuZGVmaW5lZCBpZiBub3QgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvciBhcnJheVxuICogQHBhcmFtIHBhdGggLSBhIHN0cmluZyBvZiBrZXlzIHNlcGFyYXRlZCBieSAnLicgc3VjaCBhcyAncGx1Z2luLmpxdWVyeS4wLm1lc3NhZ2UnXG4gKiAgICB3aGljaCB3b3VsZCBjb3JyZXNwb25kIHRvIDQyIGluIGB7cGx1Z2luOiB7anF1ZXJ5OiBbe21lc3NhZ2U6IDQyfV19fWBcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciByZXN1bHQgPSBvYmo7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdFtrZXlzW2ldXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldChvYmosIHBhdGgsIHZhbHVlKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW4gPCAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChsZW4gPT09IDEpIHtcbiAgICBvYmpba2V5c1swXV0gPSB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgdGVtcCA9IG9ialtrZXlzWzBdXSB8fCB7fTtcbiAgICB2YXIgcmVwbGFjZW1lbnQgPSB0ZW1wO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICB0ZW1wW2tleXNbaV1dID0gdGVtcFtrZXlzW2ldXSB8fCB7fTtcbiAgICAgIHRlbXAgPSB0ZW1wW2tleXNbaV1dO1xuICAgIH1cbiAgICB0ZW1wW2tleXNbbGVuIC0gMV1dID0gdmFsdWU7XG4gICAgb2JqW2tleXNbMF1dID0gcmVwbGFjZW1lbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEFyZ3NBc1N0cmluZyhhcmdzKSB7XG4gIHZhciBpLCBsZW4sIGFyZztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJnID0gYXJnc1tpXTtcbiAgICBzd2l0Y2ggKHR5cGVOYW1lKGFyZykpIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGFyZyA9IHN0cmluZ2lmeShhcmcpO1xuICAgICAgICBhcmcgPSBhcmcuZXJyb3IgfHwgYXJnLnZhbHVlO1xuICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDUwMCkge1xuICAgICAgICAgIGFyZyA9IGFyZy5zdWJzdHIoMCwgNDk3KSArICcuLi4nO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIGFyZyA9ICdudWxsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBhcmcgPSAndW5kZWZpbmVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICBhcmcgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGFyZyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBub3coKSB7XG4gIGlmIChEYXRlLm5vdykge1xuICAgIHJldHVybiArRGF0ZS5ub3coKTtcbiAgfVxuICByZXR1cm4gK25ldyBEYXRlKCk7XG59XG5mdW5jdGlvbiBmaWx0ZXJJcChyZXF1ZXN0RGF0YSwgY2FwdHVyZUlwKSB7XG4gIGlmICghcmVxdWVzdERhdGEgfHwgIXJlcXVlc3REYXRhWyd1c2VyX2lwJ10gfHwgY2FwdHVyZUlwID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdJcCA9IHJlcXVlc3REYXRhWyd1c2VyX2lwJ107XG4gIGlmICghY2FwdHVyZUlwKSB7XG4gICAgbmV3SXAgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcGFydHM7XG4gICAgICBpZiAobmV3SXAuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICBwYXJ0cyA9IG5ld0lwLnNwbGl0KCcuJyk7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBwYXJ0cy5wdXNoKCcwJyk7XG4gICAgICAgIG5ld0lwID0gcGFydHMuam9pbignLicpO1xuICAgICAgfSBlbHNlIGlmIChuZXdJcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIHBhcnRzID0gbmV3SXAuc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgYmVnaW5uaW5nID0gcGFydHMuc2xpY2UoMCwgMyk7XG4gICAgICAgICAgdmFyIHNsYXNoSWR4ID0gYmVnaW5uaW5nWzJdLmluZGV4T2YoJy8nKTtcbiAgICAgICAgICBpZiAoc2xhc2hJZHggIT09IC0xKSB7XG4gICAgICAgICAgICBiZWdpbm5pbmdbMl0gPSBiZWdpbm5pbmdbMl0uc3Vic3RyaW5nKDAsIHNsYXNoSWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRlcm1pbmFsID0gJzAwMDA6MDAwMDowMDAwOjAwMDA6MDAwMCc7XG4gICAgICAgICAgbmV3SXAgPSBiZWdpbm5pbmcuY29uY2F0KHRlcm1pbmFsKS5qb2luKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0lwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdJcCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlcXVlc3REYXRhWyd1c2VyX2lwJ10gPSBuZXdJcDtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wdGlvbnMoY3VycmVudCwgaW5wdXQsIHBheWxvYWQsIGxvZ2dlcikge1xuICB2YXIgcmVzdWx0ID0gbWVyZ2UoY3VycmVudCwgaW5wdXQsIHBheWxvYWQpO1xuICByZXN1bHQgPSB1cGRhdGVEZXByZWNhdGVkT3B0aW9ucyhyZXN1bHQsIGxvZ2dlcik7XG4gIGlmICghaW5wdXQgfHwgaW5wdXQub3ZlcndyaXRlU2NydWJGaWVsZHMpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpbnB1dC5zY3J1YkZpZWxkcykge1xuICAgIHJlc3VsdC5zY3J1YkZpZWxkcyA9IChjdXJyZW50LnNjcnViRmllbGRzIHx8IFtdKS5jb25jYXQoaW5wdXQuc2NydWJGaWVsZHMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVEZXByZWNhdGVkT3B0aW9ucyhvcHRpb25zLCBsb2dnZXIpIHtcbiAgaWYgKG9wdGlvbnMuaG9zdFdoaXRlTGlzdCAmJiAhb3B0aW9ucy5ob3N0U2FmZUxpc3QpIHtcbiAgICBvcHRpb25zLmhvc3RTYWZlTGlzdCA9IG9wdGlvbnMuaG9zdFdoaXRlTGlzdDtcbiAgICBvcHRpb25zLmhvc3RXaGl0ZUxpc3QgPSB1bmRlZmluZWQ7XG4gICAgbG9nZ2VyICYmIGxvZ2dlci5sb2coJ2hvc3RXaGl0ZUxpc3QgaXMgZGVwcmVjYXRlZC4gVXNlIGhvc3RTYWZlTGlzdC4nKTtcbiAgfVxuICBpZiAob3B0aW9ucy5ob3N0QmxhY2tMaXN0ICYmICFvcHRpb25zLmhvc3RCbG9ja0xpc3QpIHtcbiAgICBvcHRpb25zLmhvc3RCbG9ja0xpc3QgPSBvcHRpb25zLmhvc3RCbGFja0xpc3Q7XG4gICAgb3B0aW9ucy5ob3N0QmxhY2tMaXN0ID0gdW5kZWZpbmVkO1xuICAgIGxvZ2dlciAmJiBsb2dnZXIubG9nKCdob3N0QmxhY2tMaXN0IGlzIGRlcHJlY2F0ZWQuIFVzZSBob3N0QmxvY2tMaXN0LicpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoOiBhZGRQYXJhbXNBbmRBY2Nlc3NUb2tlblRvUGF0aCxcbiAgY3JlYXRlSXRlbTogY3JlYXRlSXRlbSxcbiAgYWRkRXJyb3JDb250ZXh0OiBhZGRFcnJvckNvbnRleHQsXG4gIGNyZWF0ZVRlbGVtZXRyeUV2ZW50OiBjcmVhdGVUZWxlbWV0cnlFdmVudCxcbiAgYWRkSXRlbUF0dHJpYnV0ZXM6IGFkZEl0ZW1BdHRyaWJ1dGVzLFxuICBmaWx0ZXJJcDogZmlsdGVySXAsXG4gIGZvcm1hdEFyZ3NBc1N0cmluZzogZm9ybWF0QXJnc0FzU3RyaW5nLFxuICBmb3JtYXRVcmw6IGZvcm1hdFVybCxcbiAgZ2V0OiBnZXQsXG4gIGhhbmRsZU9wdGlvbnM6IGhhbmRsZU9wdGlvbnMsXG4gIGlzRXJyb3I6IGlzRXJyb3IsXG4gIGlzRmluaXRlTnVtYmVyOiBpc0Zpbml0ZU51bWJlcixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNJdGVyYWJsZTogaXNJdGVyYWJsZSxcbiAgaXNOYXRpdmVGdW5jdGlvbjogaXNOYXRpdmVGdW5jdGlvbixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzVHlwZTogaXNUeXBlLFxuICBpc1Byb21pc2U6IGlzUHJvbWlzZSxcbiAgaXNCcm93c2VyOiBpc0Jyb3dzZXIsXG4gIGpzb25QYXJzZToganNvblBhcnNlLFxuICBMRVZFTFM6IExFVkVMUyxcbiAgbWFrZVVuaGFuZGxlZFN0YWNrSW5mbzogbWFrZVVuaGFuZGxlZFN0YWNrSW5mbyxcbiAgbWVyZ2U6IG1lcmdlLFxuICBub3c6IG5vdyxcbiAgcmVkYWN0OiByZWRhY3QsXG4gIFJvbGxiYXJKU09OOiBSb2xsYmFySlNPTixcbiAgc2FuaXRpemVVcmw6IHNhbml0aXplVXJsLFxuICBzZXQ6IHNldCxcbiAgc2V0dXBKU09OOiBzZXR1cEpTT04sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuICBtYXhCeXRlU2l6ZTogbWF4Qnl0ZVNpemUsXG4gIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgdXVpZDQ6IHV1aWQ0XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTg3OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vLyBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS91cmwuaHRtbFxuZnVuY3Rpb24gcGFyc2UodXJsKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgcHJvdG9jb2w6IG51bGwsXG4gICAgYXV0aDogbnVsbCxcbiAgICBob3N0OiBudWxsLFxuICAgIHBhdGg6IG51bGwsXG4gICAgaGFzaDogbnVsbCxcbiAgICBocmVmOiB1cmwsXG4gICAgaG9zdG5hbWU6IG51bGwsXG4gICAgcG9ydDogbnVsbCxcbiAgICBwYXRobmFtZTogbnVsbCxcbiAgICBzZWFyY2g6IG51bGwsXG4gICAgcXVlcnk6IG51bGxcbiAgfTtcbiAgdmFyIGksIGxhc3Q7XG4gIGkgPSB1cmwuaW5kZXhPZignLy8nKTtcbiAgaWYgKGkgIT09IC0xKSB7XG4gICAgcmVzdWx0LnByb3RvY29sID0gdXJsLnN1YnN0cmluZygwLCBpKTtcbiAgICBsYXN0ID0gaSArIDI7XG4gIH0gZWxzZSB7XG4gICAgbGFzdCA9IDA7XG4gIH1cbiAgaSA9IHVybC5pbmRleE9mKCdAJywgbGFzdCk7XG4gIGlmIChpICE9PSAtMSkge1xuICAgIHJlc3VsdC5hdXRoID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICBsYXN0ID0gaSArIDE7XG4gIH1cbiAgaSA9IHVybC5pbmRleE9mKCcvJywgbGFzdCk7XG4gIGlmIChpID09PSAtMSkge1xuICAgIGkgPSB1cmwuaW5kZXhPZignPycsIGxhc3QpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgaSA9IHVybC5pbmRleE9mKCcjJywgbGFzdCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuICAgICAgICByZXN1bHQuaGFzaCA9IHVybC5zdWJzdHJpbmcoaSk7XG4gICAgICB9XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgICAgcmVzdWx0LnBvcnQgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgICAgaWYgKHJlc3VsdC5wb3J0KSB7XG4gICAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VJbnQocmVzdWx0LnBvcnQsIDEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5ob3N0ID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgICByZXN1bHQucG9ydCA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMV07XG4gICAgICBpZiAocmVzdWx0LnBvcnQpIHtcbiAgICAgICAgcmVzdWx0LnBvcnQgPSBwYXJzZUludChyZXN1bHQucG9ydCwgMTApO1xuICAgICAgfVxuICAgICAgbGFzdCA9IGk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5ob3N0ID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgIHJlc3VsdC5wb3J0ID0gcmVzdWx0Lmhvc3Quc3BsaXQoJzonKVsxXTtcbiAgICBpZiAocmVzdWx0LnBvcnQpIHtcbiAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VJbnQocmVzdWx0LnBvcnQsIDEwKTtcbiAgICB9XG4gICAgbGFzdCA9IGk7XG4gIH1cbiAgaSA9IHVybC5pbmRleE9mKCcjJywgbGFzdCk7XG4gIGlmIChpID09PSAtMSkge1xuICAgIHJlc3VsdC5wYXRoID0gdXJsLnN1YnN0cmluZyhsYXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aCA9IHVybC5zdWJzdHJpbmcobGFzdCwgaSk7XG4gICAgcmVzdWx0Lmhhc2ggPSB1cmwuc3Vic3RyaW5nKGkpO1xuICB9XG4gIGlmIChyZXN1bHQucGF0aCkge1xuICAgIHZhciBwYXRoUGFydHMgPSByZXN1bHQucGF0aC5zcGxpdCgnPycpO1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHBhdGhQYXJ0c1swXTtcbiAgICByZXN1bHQucXVlcnkgPSBwYXRoUGFydHNbMV07XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlc3VsdC5xdWVyeSA/ICc/JyArIHJlc3VsdC5xdWVyeSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogcGFyc2Vcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTg6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4NSk7XG52YXIgTUFYX0VWRU5UUyA9IDEwMDtcblxuLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgd2hpbGUgc29sdmluZyBjb21tb25qcyAtPiBlc20gaXNzdWVzIGluIE5vZGUgMTggLSAyMC5cbmZ1bmN0aW9uIGZyb21NaWxsaXMobWlsbGlzKSB7XG4gIHJldHVybiBbTWF0aC50cnVuYyhtaWxsaXMgLyAxMDAwKSwgTWF0aC5yb3VuZChtaWxsaXMgJSAxMDAwICogMWU2KV07XG59XG5mdW5jdGlvbiBUZWxlbWV0ZXIob3B0aW9ucywgdHJhY2luZykge1xuICB2YXIgX3RoaXMkdHJhY2luZztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9wdGlvbnMpO1xuICB2YXIgbWF4VGVsZW1ldHJ5RXZlbnRzID0gdGhpcy5vcHRpb25zLm1heFRlbGVtZXRyeUV2ZW50cyB8fCBNQVhfRVZFTlRTO1xuICB0aGlzLm1heFF1ZXVlU2l6ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heFRlbGVtZXRyeUV2ZW50cywgTUFYX0VWRU5UUykpO1xuICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuICB0aGlzLnRlbGVtZXRyeVNwYW4gPSAoX3RoaXMkdHJhY2luZyA9IHRoaXMudHJhY2luZykgPT09IG51bGwgfHwgX3RoaXMkdHJhY2luZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkdHJhY2luZy5zdGFydFNwYW4oJ3JvbGxiYXItdGVsZW1ldHJ5Jywge30pO1xufVxuVGVsZW1ldGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvbGRPcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIG1heFRlbGVtZXRyeUV2ZW50cyA9IHRoaXMub3B0aW9ucy5tYXhUZWxlbWV0cnlFdmVudHMgfHwgTUFYX0VWRU5UUztcbiAgdmFyIG5ld01heEV2ZW50cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heFRlbGVtZXRyeUV2ZW50cywgTUFYX0VWRU5UUykpO1xuICB2YXIgZGVsZXRlQ291bnQgPSAwO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiBuZXdNYXhFdmVudHMpIHtcbiAgICBkZWxldGVDb3VudCA9IHRoaXMucXVldWUubGVuZ3RoIC0gbmV3TWF4RXZlbnRzO1xuICB9XG4gIHRoaXMubWF4UXVldWVTaXplID0gbmV3TWF4RXZlbnRzO1xuICB0aGlzLnF1ZXVlLnNwbGljZSgwLCBkZWxldGVDb3VudCk7XG59O1xuVGVsZW1ldGVyLnByb3RvdHlwZS5jb3B5RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXZlbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5xdWV1ZSwgMCk7XG4gIGlmIChfLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeSkpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGkgPSBldmVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeShldmVudHNbaV0pKSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJUZWxlbWV0cnkgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufTtcblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uICh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwsIHJvbGxiYXJVVUlELCB0aW1lc3RhbXApIHtcbiAgdmFyIGUgPSB7XG4gICAgbGV2ZWw6IGdldExldmVsKHR5cGUsIGxldmVsKSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVzdGFtcF9tczogdGltZXN0YW1wIHx8IF8ubm93KCksXG4gICAgYm9keTogbWV0YWRhdGEsXG4gICAgc291cmNlOiAnY2xpZW50J1xuICB9O1xuICBpZiAocm9sbGJhclVVSUQpIHtcbiAgICBlLnV1aWQgPSByb2xsYmFyVVVJRDtcbiAgfVxuICB0cnkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeSkgJiYgdGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeShlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXhjKSB7XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeSA9IG51bGw7XG4gIH1cbiAgdGhpcy5wdXNoKGUpO1xuICByZXR1cm4gZTtcbn07XG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwsIHJvbGxiYXJVVUlEKSB7XG4gIHJldHVybiB0aGlzLmNhcHR1cmUodHlwZSwgbWV0YWRhdGEsIGxldmVsLCByb2xsYmFyVVVJRCk7XG59O1xuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlRXJyb3IgPSBmdW5jdGlvbiAoZXJyLCBsZXZlbCwgcm9sbGJhclVVSUQsIHRpbWVzdGFtcCkge1xuICB2YXIgX3RoaXMkdGVsZW1ldHJ5U3BhbjtcbiAgdmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCBTdHJpbmcoZXJyKTtcbiAgdmFyIG1ldGFkYXRhID0ge1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgfTtcbiAgaWYgKGVyci5zdGFjaykge1xuICAgIG1ldGFkYXRhLnN0YWNrID0gZXJyLnN0YWNrO1xuICB9XG4gIChfdGhpcyR0ZWxlbWV0cnlTcGFuID0gdGhpcy50ZWxlbWV0cnlTcGFuKSA9PT0gbnVsbCB8fCBfdGhpcyR0ZWxlbWV0cnlTcGFuID09PSB2b2lkIDAgfHwgX3RoaXMkdGVsZW1ldHJ5U3Bhbi5hZGRFdmVudCgncm9sbGJhci1vY2N1cnJlbmNlLWV2ZW50Jywge1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgbGV2ZWw6IGxldmVsLFxuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgdXVpZDogcm9sbGJhclVVSUQsXG4gICAgJ29jY3VycmVuY2UudHlwZSc6ICdlcnJvcicsXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgICdvY2N1cnJlbmNlLnV1aWQnOiByb2xsYmFyVVVJRCAvLyBkZXByZWNhdGVkXG4gIH0sIGZyb21NaWxsaXModGltZXN0YW1wKSk7XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ2Vycm9yJywgbWV0YWRhdGEsIGxldmVsLCByb2xsYmFyVVVJRCwgdGltZXN0YW1wKTtcbn07XG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVMb2cgPSBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwsIHJvbGxiYXJVVUlELCB0aW1lc3RhbXApIHtcbiAgLy8gSWYgdGhlIHV1aWQgaXMgcHJlc2VudCwgdGhpcyBpcyBhIG1lc3NhZ2Ugb2NjdXJyZW5jZS5cbiAgaWYgKHJvbGxiYXJVVUlEKSB7XG4gICAgdmFyIF90aGlzJHRlbGVtZXRyeVNwYW4yO1xuICAgIChfdGhpcyR0ZWxlbWV0cnlTcGFuMiA9IHRoaXMudGVsZW1ldHJ5U3BhbikgPT09IG51bGwgfHwgX3RoaXMkdGVsZW1ldHJ5U3BhbjIgPT09IHZvaWQgMCB8fCBfdGhpcyR0ZWxlbWV0cnlTcGFuMi5hZGRFdmVudCgncm9sbGJhci1vY2N1cnJlbmNlLWV2ZW50Jywge1xuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgIHR5cGU6ICdtZXNzYWdlJyxcbiAgICAgIHV1aWQ6IHJvbGxiYXJVVUlELFxuICAgICAgJ29jY3VycmVuY2UudHlwZSc6ICdtZXNzYWdlJyxcbiAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICdvY2N1cnJlbmNlLnV1aWQnOiByb2xsYmFyVVVJRCAvLyBkZXByZWNhdGVkXG4gICAgfSwgZnJvbU1pbGxpcyh0aW1lc3RhbXApKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3RoaXMkdGVsZW1ldHJ5U3BhbjM7XG4gICAgKF90aGlzJHRlbGVtZXRyeVNwYW4zID0gdGhpcy50ZWxlbWV0cnlTcGFuKSA9PT0gbnVsbCB8fCBfdGhpcyR0ZWxlbWV0cnlTcGFuMyA9PT0gdm9pZCAwIHx8IF90aGlzJHRlbGVtZXRyeVNwYW4zLmFkZEV2ZW50KCdsb2ctZXZlbnQnLCB7XG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgbGV2ZWw6IGxldmVsXG4gICAgfSwgZnJvbU1pbGxpcyh0aW1lc3RhbXApKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jYXB0dXJlKCdsb2cnLCB7XG4gICAgbWVzc2FnZTogbWVzc2FnZVxuICB9LCBsZXZlbCwgcm9sbGJhclVVSUQsIHRpbWVzdGFtcCk7XG59O1xuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlTmV0d29yayA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgc3VidHlwZSwgcm9sbGJhclVVSUQsIHJlcXVlc3REYXRhKSB7XG4gIHN1YnR5cGUgPSBzdWJ0eXBlIHx8ICd4aHInO1xuICBtZXRhZGF0YS5zdWJ0eXBlID0gbWV0YWRhdGEuc3VidHlwZSB8fCBzdWJ0eXBlO1xuICBpZiAocmVxdWVzdERhdGEpIHtcbiAgICBtZXRhZGF0YS5yZXF1ZXN0ID0gcmVxdWVzdERhdGE7XG4gIH1cbiAgdmFyIGxldmVsID0gdGhpcy5sZXZlbEZyb21TdGF0dXMobWV0YWRhdGEuc3RhdHVzX2NvZGUpO1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKCduZXR3b3JrJywgbWV0YWRhdGEsIGxldmVsLCByb2xsYmFyVVVJRCk7XG59O1xuVGVsZW1ldGVyLnByb3RvdHlwZS5sZXZlbEZyb21TdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSkge1xuICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDQwMCkge1xuICAgIHJldHVybiAnaW5mbyc7XG4gIH1cbiAgaWYgKHN0YXR1c0NvZGUgPT09IDAgfHwgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuICByZXR1cm4gJ2luZm8nO1xufTtcblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZURvbSA9IGZ1bmN0aW9uIChzdWJ0eXBlLCBlbGVtZW50LCB2YWx1ZSwgY2hlY2tlZCwgcm9sbGJhclVVSUQpIHtcbiAgdmFyIG1ldGFkYXRhID0ge1xuICAgIHN1YnR5cGU6IHN1YnR5cGUsXG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9O1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1ldGFkYXRhLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKGNoZWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIG1ldGFkYXRhLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ2RvbScsIG1ldGFkYXRhLCAnaW5mbycsIHJvbGxiYXJVVUlEKTtcbn07XG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKGZyb20sIHRvLCByb2xsYmFyVVVJRCwgdGltZXN0YW1wKSB7XG4gIHZhciBfdGhpcyR0ZWxlbWV0cnlTcGFuNDtcbiAgKF90aGlzJHRlbGVtZXRyeVNwYW40ID0gdGhpcy50ZWxlbWV0cnlTcGFuKSA9PT0gbnVsbCB8fCBfdGhpcyR0ZWxlbWV0cnlTcGFuNCA9PT0gdm9pZCAwIHx8IF90aGlzJHRlbGVtZXRyeVNwYW40LmFkZEV2ZW50KCdzZXNzaW9uLW5hdmlnYXRpb24tZXZlbnQnLCB7XG4gICAgJ3ByZXZpb3VzLnVybC5mdWxsJzogZnJvbSxcbiAgICAndXJsLmZ1bGwnOiB0b1xuICB9LCBmcm9tTWlsbGlzKHRpbWVzdGFtcCkpO1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKCduYXZpZ2F0aW9uJywge1xuICAgIGZyb206IGZyb20sXG4gICAgdG86IHRvXG4gIH0sICdpbmZvJywgcm9sbGJhclVVSUQsIHRpbWVzdGFtcCk7XG59O1xuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlRG9tQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uICh0cykge1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKCduYXZpZ2F0aW9uJywge1xuICAgIHN1YnR5cGU6ICdET01Db250ZW50TG9hZGVkJ1xuICB9LCAnaW5mbycsIHVuZGVmaW5lZCwgdHMgJiYgdHMuZ2V0VGltZSgpKTtcbiAgLyoqXG4gICAqIElmIHdlIGRlY2lkZSB0byBtYWtlIHRoaXMgYSBkb20gZXZlbnQgaW5zdGVhZCwgdGhlbiB1c2UgdGhlIGxpbmUgYmVsb3c6XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ2RvbScsIHtzdWJ0eXBlOiAnRE9NQ29udGVudExvYWRlZCd9LCAnaW5mbycsIHVuZGVmaW5lZCwgdHMgJiYgdHMuZ2V0VGltZSgpKTtcbiAgKi9cbn07XG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVMb2FkID0gZnVuY3Rpb24gKHRzKSB7XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ25hdmlnYXRpb24nLCB7XG4gICAgc3VidHlwZTogJ2xvYWQnXG4gIH0sICdpbmZvJywgdW5kZWZpbmVkLCB0cyAmJiB0cy5nZXRUaW1lKCkpO1xuICAvKipcbiAgICogSWYgd2UgZGVjaWRlIHRvIG1ha2UgdGhpcyBhIGRvbSBldmVudCBpbnN0ZWFkLCB0aGVuIHVzZSB0aGUgbGluZSBiZWxvdzpcbiAgcmV0dXJuIHRoaXMuY2FwdHVyZSgnZG9tJywge3N1YnR5cGU6ICdsb2FkJ30sICdpbmZvJywgdW5kZWZpbmVkLCB0cyAmJiB0cy5nZXRUaW1lKCkpO1xuICAqL1xufTtcblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSA9IGZ1bmN0aW9uICh0eXBlLCByb2xsYmFyVVVJRCkge1xuICByZXR1cm4gdGhpcy5jYXB0dXJlTmV0d29yayh7XG4gICAgY2hhbmdlOiB0eXBlXG4gIH0sICdjb25uZWN0aXZpdHknLCByb2xsYmFyVVVJRCk7XG59O1xuXG4vLyBPbmx5IGludGVuZGVkIHRvIGJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgbm90aWZpZXJcblRlbGVtZXRlci5wcm90b3R5cGUuX2NhcHR1cmVSb2xsYmFySXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmluY2x1ZGVJdGVtc0luVGVsZW1ldHJ5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpdGVtLmVycikge1xuICAgIHJldHVybiB0aGlzLmNhcHR1cmVFcnJvcihpdGVtLmVyciwgaXRlbS5sZXZlbCwgaXRlbS51dWlkLCBpdGVtLnRpbWVzdGFtcCk7XG4gIH1cbiAgaWYgKGl0ZW0ubWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLmNhcHR1cmVMb2coaXRlbS5tZXNzYWdlLCBpdGVtLmxldmVsLCBpdGVtLnV1aWQsIGl0ZW0udGltZXN0YW1wKTtcbiAgfVxuICBpZiAoaXRlbS5jdXN0b20pIHtcbiAgICByZXR1cm4gdGhpcy5jYXB0dXJlKCdsb2cnLCBpdGVtLmN1c3RvbSwgaXRlbS5sZXZlbCwgaXRlbS51dWlkLCBpdGVtLnRpbWVzdGFtcCk7XG4gIH1cbn07XG5UZWxlbWV0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZSkge1xuICB0aGlzLnF1ZXVlLnB1c2goZSk7XG4gIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IHRoaXMubWF4UXVldWVTaXplKSB7XG4gICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0TGV2ZWwodHlwZSwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsKSB7XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG4gIHZhciBkZWZhdWx0TGV2ZWwgPSB7XG4gICAgZXJyb3I6ICdlcnJvcicsXG4gICAgbWFudWFsOiAnaW5mbydcbiAgfTtcbiAgcmV0dXJuIGRlZmF1bHRMZXZlbFt0eXBlXSB8fCAnaW5mbyc7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVtZXRlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDYyMjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcbnZhciB0cmF2ZXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xuZnVuY3Rpb24gcmF3KHBheWxvYWQsIGpzb25CYWNrdXApIHtcbiAgcmV0dXJuIFtwYXlsb2FkLCBfLnN0cmluZ2lmeShwYXlsb2FkLCBqc29uQmFja3VwKV07XG59XG5mdW5jdGlvbiBzZWxlY3RGcmFtZXMoZnJhbWVzLCByYW5nZSkge1xuICB2YXIgbGVuID0gZnJhbWVzLmxlbmd0aDtcbiAgaWYgKGxlbiA+IHJhbmdlICogMikge1xuICAgIHJldHVybiBmcmFtZXMuc2xpY2UoMCwgcmFuZ2UpLmNvbmNhdChmcmFtZXMuc2xpY2UobGVuIC0gcmFuZ2UpKTtcbiAgfVxuICByZXR1cm4gZnJhbWVzO1xufVxuZnVuY3Rpb24gdHJ1bmNhdGVGcmFtZXMocGF5bG9hZCwganNvbkJhY2t1cCwgcmFuZ2UpIHtcbiAgcmFuZ2UgPSB0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnID8gMzAgOiByYW5nZTtcbiAgdmFyIGJvZHkgPSBwYXlsb2FkLmRhdGEuYm9keTtcbiAgdmFyIGZyYW1lcztcbiAgaWYgKGJvZHkudHJhY2VfY2hhaW4pIHtcbiAgICB2YXIgY2hhaW4gPSBib2R5LnRyYWNlX2NoYWluO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lcyA9IGNoYWluW2ldLmZyYW1lcztcbiAgICAgIGZyYW1lcyA9IHNlbGVjdEZyYW1lcyhmcmFtZXMsIHJhbmdlKTtcbiAgICAgIGNoYWluW2ldLmZyYW1lcyA9IGZyYW1lcztcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm9keS50cmFjZSkge1xuICAgIGZyYW1lcyA9IGJvZHkudHJhY2UuZnJhbWVzO1xuICAgIGZyYW1lcyA9IHNlbGVjdEZyYW1lcyhmcmFtZXMsIHJhbmdlKTtcbiAgICBib2R5LnRyYWNlLmZyYW1lcyA9IGZyYW1lcztcbiAgfVxuICByZXR1cm4gW3BheWxvYWQsIF8uc3RyaW5naWZ5KHBheWxvYWQsIGpzb25CYWNrdXApXTtcbn1cbmZ1bmN0aW9uIG1heWJlVHJ1bmNhdGVWYWx1ZShsZW4sIHZhbCkge1xuICBpZiAoIXZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHZhbC5sZW5ndGggPiBsZW4pIHtcbiAgICByZXR1cm4gdmFsLnNsaWNlKDAsIGxlbiAtIDMpLmNvbmNhdCgnLi4uJyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlU3RyaW5ncyhsZW4sIHBheWxvYWQsIGpzb25CYWNrdXApIHtcbiAgZnVuY3Rpb24gdHJ1bmNhdG9yKGssIHYsIHNlZW4pIHtcbiAgICBzd2l0Y2ggKF8udHlwZU5hbWUodikpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBtYXliZVRydW5jYXRlVmFsdWUobGVuLCB2KTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIHJldHVybiB0cmF2ZXJzZSh2LCB0cnVuY2F0b3IsIHNlZW4pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICB9XG4gIHBheWxvYWQgPSB0cmF2ZXJzZShwYXlsb2FkLCB0cnVuY2F0b3IpO1xuICByZXR1cm4gW3BheWxvYWQsIF8uc3RyaW5naWZ5KHBheWxvYWQsIGpzb25CYWNrdXApXTtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlVHJhY2VEYXRhKHRyYWNlRGF0YSkge1xuICBpZiAodHJhY2VEYXRhLmV4Y2VwdGlvbikge1xuICAgIGRlbGV0ZSB0cmFjZURhdGEuZXhjZXB0aW9uLmRlc2NyaXB0aW9uO1xuICAgIHRyYWNlRGF0YS5leGNlcHRpb24ubWVzc2FnZSA9IG1heWJlVHJ1bmNhdGVWYWx1ZSgyNTUsIHRyYWNlRGF0YS5leGNlcHRpb24ubWVzc2FnZSk7XG4gIH1cbiAgdHJhY2VEYXRhLmZyYW1lcyA9IHNlbGVjdEZyYW1lcyh0cmFjZURhdGEuZnJhbWVzLCAxKTtcbiAgcmV0dXJuIHRyYWNlRGF0YTtcbn1cbmZ1bmN0aW9uIG1pbkJvZHkocGF5bG9hZCwganNvbkJhY2t1cCkge1xuICB2YXIgYm9keSA9IHBheWxvYWQuZGF0YS5ib2R5O1xuICBpZiAoYm9keS50cmFjZV9jaGFpbikge1xuICAgIHZhciBjaGFpbiA9IGJvZHkudHJhY2VfY2hhaW47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhaW5baV0gPSB0cnVuY2F0ZVRyYWNlRGF0YShjaGFpbltpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJvZHkudHJhY2UpIHtcbiAgICBib2R5LnRyYWNlID0gdHJ1bmNhdGVUcmFjZURhdGEoYm9keS50cmFjZSk7XG4gIH1cbiAgcmV0dXJuIFtwYXlsb2FkLCBfLnN0cmluZ2lmeShwYXlsb2FkLCBqc29uQmFja3VwKV07XG59XG5mdW5jdGlvbiBuZWVkc1RydW5jYXRpb24ocGF5bG9hZCwgbWF4U2l6ZSkge1xuICByZXR1cm4gXy5tYXhCeXRlU2l6ZShwYXlsb2FkKSA+IG1heFNpemU7XG59XG5mdW5jdGlvbiB0cnVuY2F0ZShwYXlsb2FkLCBqc29uQmFja3VwLCBtYXhTaXplKSB7XG4gIG1heFNpemUgPSB0eXBlb2YgbWF4U2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyA1MTIgKiAxMDI0IDogbWF4U2l6ZTtcbiAgdmFyIHN0cmF0ZWdpZXMgPSBbcmF3LCB0cnVuY2F0ZUZyYW1lcywgdHJ1bmNhdGVTdHJpbmdzLmJpbmQobnVsbCwgMTAyNCksIHRydW5jYXRlU3RyaW5ncy5iaW5kKG51bGwsIDUxMiksIHRydW5jYXRlU3RyaW5ncy5iaW5kKG51bGwsIDI1NiksIG1pbkJvZHldO1xuICB2YXIgc3RyYXRlZ3ksIHJlc3VsdHMsIHJlc3VsdDtcbiAgd2hpbGUgKHN0cmF0ZWd5ID0gc3RyYXRlZ2llcy5zaGlmdCgpKSB7XG4gICAgcmVzdWx0cyA9IHN0cmF0ZWd5KHBheWxvYWQsIGpzb25CYWNrdXApO1xuICAgIHBheWxvYWQgPSByZXN1bHRzWzBdO1xuICAgIHJlc3VsdCA9IHJlc3VsdHNbMV07XG4gICAgaWYgKHJlc3VsdC5lcnJvciB8fCAhbmVlZHNUcnVuY2F0aW9uKHJlc3VsdC52YWx1ZSwgbWF4U2l6ZSkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICAvKiBmb3IgdGVzdGluZyAqL1xuICByYXc6IHJhdyxcbiAgdHJ1bmNhdGVGcmFtZXM6IHRydW5jYXRlRnJhbWVzLFxuICB0cnVuY2F0ZVN0cmluZ3M6IHRydW5jYXRlU3RyaW5ncyxcbiAgbWF5YmVUcnVuY2F0ZVZhbHVlOiBtYXliZVRydW5jYXRlVmFsdWVcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Mjk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIFRoaXMgZGV0ZWN0aW9uLmpzIG1vZHVsZSBpcyB1c2VkIHRvIGVuY2Fwc3VsYXRlIGFueSB1Z2x5IGJyb3dzZXIvZmVhdHVyZVxuLy8gZGV0ZWN0aW9uIHdlIG1heSBuZWVkIHRvIGRvLlxuXG4vLyBGaWd1cmUgb3V0IHdoaWNoIHZlcnNpb24gb2YgSUUgd2UncmUgdXNpbmcsIGlmIGFueS5cbi8vIFRoaXMgaXMgZ2xlYW5lZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTU3NDg0Mi9iZXN0LXdheS10by1jaGVjay1mb3ItaWUtbGVzcy10aGFuLTktaW4tamF2YXNjcmlwdC13aXRob3V0LWxpYnJhcnlcbi8vIFdpbGwgcmV0dXJuIGFuIGludGVnZXIgb24gSUUgKGkuZS4gOClcbi8vIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBvdGhlcndpc2VcbmZ1bmN0aW9uIGdldElFVmVyc2lvbigpIHtcbiAgdmFyIHVuZGVmO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZjtcbiAgfVxuICB2YXIgdiA9IDMsXG4gICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgYWxsID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpJyk7XG4gIHdoaWxlIChkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArICsrdiArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nLCBhbGxbMF0pO1xuICByZXR1cm4gdiA+IDQgPyB2IDogdW5kZWY7XG59XG52YXIgRGV0ZWN0aW9uID0ge1xuICBpZVZlcnNpb246IGdldElFVmVyc2lvblxufTtcbm1vZHVsZS5leHBvcnRzID0gRGV0ZWN0aW9uO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU3OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwb2x5ZmlsbEpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzOCk7XG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsSlNPTjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDY5OTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNjcnViRmllbGRzOiBbJ3B3JywgJ3Bhc3MnLCAncGFzc3dkJywgJ3Bhc3N3b3JkJywgJ3NlY3JldCcsICdjb25maXJtX3Bhc3N3b3JkJywgJ2NvbmZpcm1QYXNzd29yZCcsICdwYXNzd29yZF9jb25maXJtYXRpb24nLCAncGFzc3dvcmRDb25maXJtYXRpb24nLCAnYWNjZXNzX3Rva2VuJywgJ2FjY2Vzc1Rva2VuJywgJ1gtUm9sbGJhci1BY2Nlc3MtVG9rZW4nLCAnc2VjcmV0X2tleScsICdzZWNyZXRLZXknLCAnc2VjcmV0VG9rZW4nLCAnY2MtbnVtYmVyJywgJ2NhcmQgbnVtYmVyJywgJ2NhcmRudW1iZXInLCAnY2FyZG51bScsICdjY251bScsICdjY251bWJlcicsICdjYyBudW0nLCAnY3JlZGl0Y2FyZG51bWJlcicsICdjcmVkaXQgY2FyZCBudW1iZXInLCAnbmV3Y3JlZGl0Y2FyZG51bWJlcicsICduZXcgY3JlZGl0IGNhcmQnLCAnY3JlZGl0Y2FyZG5vJywgJ2NyZWRpdCBjYXJkIG5vJywgJ2NhcmQjJywgJ2NhcmQgIycsICdjYy1jc2MnLCAnY3ZjJywgJ2N2YzInLCAnY3Z2MicsICdjY3YyJywgJ3NlY3VyaXR5IGNvZGUnLCAnY2FyZCB2ZXJpZmljYXRpb24nLCAnbmFtZSBvbiBjcmVkaXQgY2FyZCcsICduYW1lIG9uIGNhcmQnLCAnbmFtZW9uY2FyZCcsICdjYXJkaG9sZGVyJywgJ2NhcmQgaG9sZGVyJywgJ25hbWUgZGVzIGthcnRlbmluaGFiZXJzJywgJ2NjbmFtZScsICdjYXJkIHR5cGUnLCAnY2FyZHR5cGUnLCAnY2MgdHlwZScsICdjY3R5cGUnLCAncGF5bWVudCB0eXBlJywgJ2V4cGlyYXRpb24gZGF0ZScsICdleHBpcmF0aW9uZGF0ZScsICdleHBkYXRlJywgJ2NjLWV4cCcsICdjY21vbnRoJywgJ2NjeWVhciddXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xudmFyIGhlYWRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczNik7XG52YXIgcmVwbGFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzk4KTtcbnZhciBzY3J1YiA9IF9fd2VicGFja19yZXF1aXJlX18oOTIyKTtcbnZhciB1cmxwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4Nyk7XG52YXIgZG9tVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkyKTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgbmV0d29yazogdHJ1ZSxcbiAgbmV0d29ya1Jlc3BvbnNlSGVhZGVyczogZmFsc2UsXG4gIG5ldHdvcmtSZXNwb25zZUJvZHk6IGZhbHNlLFxuICBuZXR3b3JrUmVxdWVzdEhlYWRlcnM6IGZhbHNlLFxuICBuZXR3b3JrUmVxdWVzdEJvZHk6IGZhbHNlLFxuICBuZXR3b3JrRXJyb3JPbkh0dHA1eHg6IGZhbHNlLFxuICBuZXR3b3JrRXJyb3JPbkh0dHA0eHg6IGZhbHNlLFxuICBuZXR3b3JrRXJyb3JPbkh0dHAwOiBmYWxzZSxcbiAgbG9nOiB0cnVlLFxuICBkb206IHRydWUsXG4gIG5hdmlnYXRpb246IHRydWUsXG4gIGNvbm5lY3Rpdml0eTogdHJ1ZSxcbiAgY29udGVudFNlY3VyaXR5UG9saWN5OiB0cnVlLFxuICBlcnJvck9uQ29udGVudFNlY3VyaXR5UG9saWN5OiBmYWxzZVxufTtcbmZ1bmN0aW9uIHJlc3RvcmUocmVwbGFjZW1lbnRzLCB0eXBlKSB7XG4gIHZhciBiO1xuICB3aGlsZSAocmVwbGFjZW1lbnRzW3R5cGVdLmxlbmd0aCkge1xuICAgIGIgPSByZXBsYWNlbWVudHNbdHlwZV0uc2hpZnQoKTtcbiAgICBiWzBdW2JbMV1dID0gYlsyXTtcbiAgfVxufVxuZnVuY3Rpb24gbmFtZUZyb21EZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGF0dHJzID0gZGVzY3JpcHRpb24uYXR0cmlidXRlcztcbiAgZm9yICh2YXIgYSA9IDA7IGEgPCBhdHRycy5sZW5ndGg7ICsrYSkge1xuICAgIGlmIChhdHRyc1thXS5rZXkgPT09ICduYW1lJykge1xuICAgICAgcmV0dXJuIGF0dHJzW2FdLnZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZVNjcnViYmVyKHNjcnViRmllbGRzKSB7XG4gIHZhciBwYXR0ZXJucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgcGF0dGVybnMucHVzaChuZXcgUmVnRXhwKHNjcnViRmllbGRzW2ldLCAnaScpKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lRnJvbURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHBhdHRlcm5zW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEluc3RydW1lbnRlcihvcHRpb25zLCB0ZWxlbWV0ZXIsIHJvbGxiYXIsIF93aW5kb3csIF9kb2N1bWVudCkge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgYXV0b0luc3RydW1lbnQgPSBvcHRpb25zLmF1dG9JbnN0cnVtZW50O1xuICBpZiAob3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSB8fCBhdXRvSW5zdHJ1bWVudCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50ID0ge307XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFfLmlzVHlwZShhdXRvSW5zdHJ1bWVudCwgJ29iamVjdCcpKSB7XG4gICAgICBhdXRvSW5zdHJ1bWVudCA9IGRlZmF1bHRzO1xuICAgIH1cbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50ID0gXy5tZXJnZShkZWZhdWx0cywgYXV0b0luc3RydW1lbnQpO1xuICB9XG4gIHRoaXMuc2NydWJUZWxlbWV0cnlJbnB1dHMgPSAhIW9wdGlvbnMuc2NydWJUZWxlbWV0cnlJbnB1dHM7XG4gIHRoaXMudGVsZW1ldHJ5U2NydWJiZXIgPSBvcHRpb25zLnRlbGVtZXRyeVNjcnViYmVyO1xuICB0aGlzLmRlZmF1bHRWYWx1ZVNjcnViYmVyID0gZGVmYXVsdFZhbHVlU2NydWJiZXIob3B0aW9ucy5zY3J1YkZpZWxkcyk7XG4gIHRoaXMudGVsZW1ldGVyID0gdGVsZW1ldGVyO1xuICB0aGlzLnJvbGxiYXIgPSByb2xsYmFyO1xuICB0aGlzLmRpYWdub3N0aWMgPSByb2xsYmFyLmNsaWVudC5ub3RpZmllci5kaWFnbm9zdGljO1xuICB0aGlzLl93aW5kb3cgPSBfd2luZG93IHx8IHt9O1xuICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudCB8fCB7fTtcbiAgdGhpcy5yZXBsYWNlbWVudHMgPSB7XG4gICAgbmV0d29yazogW10sXG4gICAgbG9nOiBbXSxcbiAgICBuYXZpZ2F0aW9uOiBbXSxcbiAgICBjb25uZWN0aXZpdHk6IFtdXG4gIH07XG4gIHRoaXMuZXZlbnRSZW1vdmVycyA9IHtcbiAgICBkb206IFtdLFxuICAgIGNvbm5lY3Rpdml0eTogW10sXG4gICAgY29udGVudHNlY3VyaXR5cG9saWN5OiBbXVxuICB9O1xuICB0aGlzLl9sb2NhdGlvbiA9IHRoaXMuX3dpbmRvdy5sb2NhdGlvbjtcbiAgdGhpcy5fbGFzdEhyZWYgPSB0aGlzLl9sb2NhdGlvbiAmJiB0aGlzLl9sb2NhdGlvbi5ocmVmO1xufVxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHZhciBhdXRvSW5zdHJ1bWVudCA9IG9wdGlvbnMuYXV0b0luc3RydW1lbnQ7XG4gIHZhciBvbGRTZXR0aW5ncyA9IF8ubWVyZ2UodGhpcy5hdXRvSW5zdHJ1bWVudCk7XG4gIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlIHx8IGF1dG9JbnN0cnVtZW50ID09PSBmYWxzZSkge1xuICAgIHRoaXMuYXV0b0luc3RydW1lbnQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIV8uaXNUeXBlKGF1dG9JbnN0cnVtZW50LCAnb2JqZWN0JykpIHtcbiAgICAgIGF1dG9JbnN0cnVtZW50ID0gZGVmYXVsdHM7XG4gICAgfVxuICAgIHRoaXMuYXV0b0luc3RydW1lbnQgPSBfLm1lcmdlKGRlZmF1bHRzLCBhdXRvSW5zdHJ1bWVudCk7XG4gIH1cbiAgdGhpcy5pbnN0cnVtZW50KG9sZFNldHRpbmdzKTtcbiAgaWYgKG9wdGlvbnMuc2NydWJUZWxlbWV0cnlJbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2NydWJUZWxlbWV0cnlJbnB1dHMgPSAhIW9wdGlvbnMuc2NydWJUZWxlbWV0cnlJbnB1dHM7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVsZW1ldHJ5U2NydWJiZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudGVsZW1ldHJ5U2NydWJiZXIgPSBvcHRpb25zLnRlbGVtZXRyeVNjcnViYmVyO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pbnN0cnVtZW50ID0gZnVuY3Rpb24gKG9sZFNldHRpbmdzKSB7XG4gIGlmICh0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmsgJiYgIShvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5uZXR3b3JrKSkge1xuICAgIHRoaXMuaW5zdHJ1bWVudE5ldHdvcmsoKTtcbiAgfSBlbHNlIGlmICghdGhpcy5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrICYmIG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLm5ldHdvcmspIHtcbiAgICB0aGlzLmRlaW5zdHJ1bWVudE5ldHdvcmsoKTtcbiAgfVxuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5sb2cgJiYgIShvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5sb2cpKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50Q29uc29sZSgpO1xuICB9IGVsc2UgaWYgKCF0aGlzLmF1dG9JbnN0cnVtZW50LmxvZyAmJiBvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5sb2cpIHtcbiAgICB0aGlzLmRlaW5zdHJ1bWVudENvbnNvbGUoKTtcbiAgfVxuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5kb20gJiYgIShvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5kb20pKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50RG9tKCk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuYXV0b0luc3RydW1lbnQuZG9tICYmIG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmRvbSkge1xuICAgIHRoaXMuZGVpbnN0cnVtZW50RG9tKCk7XG4gIH1cbiAgaWYgKHRoaXMuYXV0b0luc3RydW1lbnQubmF2aWdhdGlvbiAmJiAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLm5hdmlnYXRpb24pKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50TmF2aWdhdGlvbigpO1xuICB9IGVsc2UgaWYgKCF0aGlzLmF1dG9JbnN0cnVtZW50Lm5hdmlnYXRpb24gJiYgb2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MubmF2aWdhdGlvbikge1xuICAgIHRoaXMuZGVpbnN0cnVtZW50TmF2aWdhdGlvbigpO1xuICB9XG4gIGlmICh0aGlzLmF1dG9JbnN0cnVtZW50LmNvbm5lY3Rpdml0eSAmJiAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmNvbm5lY3Rpdml0eSkpIHtcbiAgICB0aGlzLmluc3RydW1lbnRDb25uZWN0aXZpdHkoKTtcbiAgfSBlbHNlIGlmICghdGhpcy5hdXRvSW5zdHJ1bWVudC5jb25uZWN0aXZpdHkgJiYgb2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MuY29ubmVjdGl2aXR5KSB7XG4gICAgdGhpcy5kZWluc3RydW1lbnRDb25uZWN0aXZpdHkoKTtcbiAgfVxuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5jb250ZW50U2VjdXJpdHlQb2xpY3kgJiYgIShvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5jb250ZW50U2VjdXJpdHlQb2xpY3kpKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50Q29udGVudFNlY3VyaXR5UG9saWN5KCk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuYXV0b0luc3RydW1lbnQuY29udGVudFNlY3VyaXR5UG9saWN5ICYmIG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmNvbnRlbnRTZWN1cml0eVBvbGljeSkge1xuICAgIHRoaXMuZGVpbnN0cnVtZW50Q29udGVudFNlY3VyaXR5UG9saWN5KCk7XG4gIH1cbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHJlc3RvcmUodGhpcy5yZXBsYWNlbWVudHMsICduZXR3b3JrJyk7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pbnN0cnVtZW50TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiB3cmFwUHJvcChwcm9wLCB4aHIpIHtcbiAgICBpZiAocHJvcCBpbiB4aHIgJiYgXy5pc0Z1bmN0aW9uKHhocltwcm9wXSkpIHtcbiAgICAgIHJlcGxhY2UoeGhyLCBwcm9wLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgICByZXR1cm4gc2VsZi5yb2xsYmFyLndyYXAob3JpZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKCdYTUxIdHRwUmVxdWVzdCcgaW4gdGhpcy5fd2luZG93KSB7XG4gICAgdmFyIHhocnAgPSB0aGlzLl93aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlO1xuICAgIHJlcGxhY2UoeGhycCwgJ29wZW4nLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICAgICAgICB2YXIgaXNVcmxPYmplY3QgPSBfaXNVcmxPYmplY3QodXJsKTtcbiAgICAgICAgaWYgKF8uaXNUeXBlKHVybCwgJ3N0cmluZycpIHx8IGlzVXJsT2JqZWN0KSB7XG4gICAgICAgICAgdXJsID0gaXNVcmxPYmplY3QgPyB1cmwudG9TdHJpbmcoKSA6IHVybDtcbiAgICAgICAgICBpZiAodGhpcy5fX3JvbGxiYXJfeGhyKSB7XG4gICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5zdGF0dXNfY29kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIuc3RhcnRfdGltZV9tcyA9IF8ubm93KCk7XG4gICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIuZW5kX3RpbWVfbXMgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIgPSB7XG4gICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgc3RhdHVzX2NvZGU6IG51bGwsXG4gICAgICAgICAgICAgIHN0YXJ0X3RpbWVfbXM6IF8ubm93KCksXG4gICAgICAgICAgICAgIGVuZF90aW1lX21zOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9LCB0aGlzLnJlcGxhY2VtZW50cywgJ25ldHdvcmsnKTtcbiAgICByZXBsYWNlKHhocnAsICdzZXRSZXF1ZXN0SGVhZGVyJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgICAvLyBJZiB4aHIub3BlbiBpcyBhc3luYywgX19yb2xsYmFyX3hociBtYXkgbm90IGJlIGluaXRpYWxpemVkIHlldC5cbiAgICAgICAgaWYgKCF0aGlzLl9fcm9sbGJhcl94aHIpIHtcbiAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc1R5cGUoaGVhZGVyLCAnc3RyaW5nJykgJiYgXy5pc1R5cGUodmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9fcm9sbGJhcl94aHIucmVxdWVzdF9oZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5yZXF1ZXN0X2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5yZXF1ZXN0X2hlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSB3YW50IHRoZSBjb250ZW50IHR5cGUgZXZlbiBpZiByZXF1ZXN0IGhlYWRlciB0ZWxlbWV0cnkgaXMgb2ZmLlxuICAgICAgICAgIGlmIChoZWFkZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5yZXF1ZXN0X2NvbnRlbnRfdHlwZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9LCB0aGlzLnJlcGxhY2VtZW50cywgJ25ldHdvcmsnKTtcbiAgICByZXBsYWNlKHhocnAsICdzZW5kJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICB2YXIgeGhyID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoeGhyLl9fcm9sbGJhcl94aHIpIHtcbiAgICAgICAgICAgIGlmICh4aHIuX19yb2xsYmFyX3hoci5zdGF0dXNfY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5zdGF0dXNfY29kZSA9IDA7XG4gICAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0Qm9keSkge1xuICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnJlcXVlc3QgPSBkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfZXZlbnQgPSBzZWxmLmNhcHR1cmVOZXR3b3JrKHhoci5fX3JvbGxiYXJfeGhyLCAneGhyJywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIuc3RhcnRfdGltZV9tcyA9IF8ubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPiAzKSB7XG4gICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLmVuZF90aW1lX21zID0gXy5ub3coKTtcbiAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5yZXNwb25zZV9jb250ZW50X3R5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgICBpZiAoc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnNDb25maWcgPSBzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXNwb25zZUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBpO1xuICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNDb25maWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IGFsbEhlYWRlcnMudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMsIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzID0gYXJyW2ldLnNwbGl0KCc6ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFydHMuam9pbignOiAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlcnNDb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBoZWFkZXJzQ29uZmlnW2ldO1xuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVyXSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgLyogd2UgaWdub3JlIHRoZSBlcnJvcnMgaGVyZSB0aGF0IGNvdWxkIGNvbWUgZnJvbSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAqIGJyb3dzZXIgaXNzdWVzIHdpdGggdGhlIHhociBtZXRob2RzICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgZXJyb3JzIGZyb20gcmVhZGluZyByZXNwb25zZVRleHQgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGJvZHkgfHwgaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzSnNvbkNvbnRlbnRUeXBlKHhoci5fX3JvbGxiYXJfeGhyLnJlc3BvbnNlX2NvbnRlbnRfdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHNlbGYuc2NydWJKc29uKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSA9PT0gMTIyMyA/IDIwNCA6IGNvZGU7XG4gICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIuc3RhdHVzX2NvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfZXZlbnQubGV2ZWwgPSBzZWxmLnRlbGVtZXRlci5sZXZlbEZyb21TdGF0dXMoY29kZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvck9uSHR0cFN0YXR1cyh4aHIuX19yb2xsYmFyX3hocik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpZ25vcmUgcG9zc2libGUgZXhjZXB0aW9uIGZyb20geGhyLnN0YXR1cyAqL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdyYXBQcm9wKCdvbmxvYWQnLCB4aHIpO1xuICAgICAgICB3cmFwUHJvcCgnb25lcnJvcicsIHhocik7XG4gICAgICAgIHdyYXBQcm9wKCdvbnByb2dyZXNzJywgeGhyKTtcbiAgICAgICAgaWYgKCdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIHhociAmJiBfLmlzRnVuY3Rpb24oeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSkpIHtcbiAgICAgICAgICByZXBsYWNlKHhociwgJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yb2xsYmFyLndyYXAob3JpZywgdW5kZWZpbmVkLCBvbnJlYWR5c3RhdGVjaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeGhyLl9fcm9sbGJhcl94aHIgJiYgc2VsZi50cmFja0h0dHBFcnJvcnMoKSkge1xuICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSwgdGhpcy5yZXBsYWNlbWVudHMsICduZXR3b3JrJyk7XG4gIH1cbiAgaWYgKCdmZXRjaCcgaW4gdGhpcy5fd2luZG93KSB7XG4gICAgcmVwbGFjZSh0aGlzLl93aW5kb3csICdmZXRjaCcsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdCkge1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0ID0gYXJnc1swXTtcbiAgICAgICAgdmFyIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICB2YXIgdXJsO1xuICAgICAgICB2YXIgaXNVcmxPYmplY3QgPSBfaXNVcmxPYmplY3QoaW5wdXQpO1xuICAgICAgICBpZiAoXy5pc1R5cGUoaW5wdXQsICdzdHJpbmcnKSB8fCBpc1VybE9iamVjdCkge1xuICAgICAgICAgIHVybCA9IGlzVXJsT2JqZWN0ID8gaW5wdXQudG9TdHJpbmcoKSA6IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0KSB7XG4gICAgICAgICAgdXJsID0gaW5wdXQudXJsO1xuICAgICAgICAgIGlmIChpbnB1dC5tZXRob2QpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3NbMV0gJiYgYXJnc1sxXS5tZXRob2QpIHtcbiAgICAgICAgICBtZXRob2QgPSBhcmdzWzFdLm1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgc3RhdHVzX2NvZGU6IG51bGwsXG4gICAgICAgICAgc3RhcnRfdGltZV9tczogXy5ub3coKSxcbiAgICAgICAgICBlbmRfdGltZV9tczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJnc1sxXSAmJiBhcmdzWzFdLmhlYWRlcnMpIHtcbiAgICAgICAgICAvLyBBcmd1bWVudCBtYXkgYmUgYSBIZWFkZXJzIG9iamVjdCwgb3IgcGxhaW4gb2JqZWN0LiBFbnN1cmUgaGVyZSB0aGF0XG4gICAgICAgICAgLy8gd2UgYXJlIHdvcmtpbmcgd2l0aCBhIEhlYWRlcnMgb2JqZWN0IHdpdGggY2FzZS1pbnNlbnNpdGl2ZSBrZXlzLlxuICAgICAgICAgIHZhciByZXFIZWFkZXJzID0gaGVhZGVycyhhcmdzWzFdLmhlYWRlcnMpO1xuICAgICAgICAgIG1ldGFkYXRhLnJlcXVlc3RfY29udGVudF90eXBlID0gcmVxSGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgbWV0YWRhdGEucmVxdWVzdF9oZWFkZXJzID0gc2VsZi5mZXRjaEhlYWRlcnMocmVxSGVhZGVycywgc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVxdWVzdEJvZHkpIHtcbiAgICAgICAgICBpZiAoYXJnc1sxXSAmJiBhcmdzWzFdLmJvZHkpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlcXVlc3QgPSBhcmdzWzFdLmJvZHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmdzWzBdICYmICFfLmlzVHlwZShhcmdzWzBdLCAnc3RyaW5nJykgJiYgYXJnc1swXS5ib2R5KSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5yZXF1ZXN0ID0gYXJnc1swXS5ib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmNhcHR1cmVOZXR3b3JrKG1ldGFkYXRhLCAnZmV0Y2gnLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoc2VsZi50cmFja0h0dHBFcnJvcnMoKSkge1xuICAgICAgICAgIG1ldGFkYXRhLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCBvdXIgaGFuZGxlciBiZWZvcmUgcmV0dXJuaW5nIHRoZSBwcm9taXNlLiBUaGlzIGFsbG93cyByZXNwLmNsb25lKClcbiAgICAgICAgLy8gdG8gZXhlY3V0ZSBiZWZvcmUgb3RoZXIgaGFuZGxlcnMgdG91Y2ggdGhlIHJlc3BvbnNlLlxuICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmdzKS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgbWV0YWRhdGEuZW5kX3RpbWVfbXMgPSBfLm5vdygpO1xuICAgICAgICAgIG1ldGFkYXRhLnN0YXR1c19jb2RlID0gcmVzcC5zdGF0dXM7XG4gICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2VfY29udGVudF90eXBlID0gcmVzcC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBzZWxmLmZldGNoSGVhZGVycyhyZXNwLmhlYWRlcnMsIHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlSGVhZGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICAgICAgICBpZiAoc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3AudGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBSZXNwb25zZS50ZXh0KCkgaXMgbm90IGltcGxlbWVudGVkIG9uIHNvbWUgcGxhdGZvcm1zXG4gICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBtdXN0IGJlIGNsb25lZCB0byBwcmV2ZW50IHJlYWRpbmcgKGFuZCBsb2NraW5nKSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICAgICAgICAgICAgICAvLyBUaGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgb3RoZXIgaGFuZGxlcnMgdG91Y2ggdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBib2R5ID0gcmVzcC5jbG9uZSgpLnRleHQoKTsgLy9yZXR1cm5zIGEgUHJvbWlzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVhZGVycyB8fCBib2R5KSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5yZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgLy8gVGVzdCB0byBlbnN1cmUgYm9keSBpcyBhIFByb21pc2UsIHdoaWNoIGl0IHNob3VsZCBhbHdheXMgYmUuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYm9keS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGV4dCAmJiBzZWxmLmlzSnNvbkNvbnRlbnRUeXBlKG1ldGFkYXRhLnJlc3BvbnNlX2NvbnRlbnRfdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2UuYm9keSA9IHNlbGYuc2NydWJKc29uKHRleHQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2UuYm9keSA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2UuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVycm9yT25IdHRwU3RhdHVzKG1ldGFkYXRhKTtcbiAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sIHRoaXMucmVwbGFjZW1lbnRzLCAnbmV0d29yaycpO1xuICB9XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5jYXB0dXJlTmV0d29yayA9IGZ1bmN0aW9uIChtZXRhZGF0YSwgc3VidHlwZSwgcm9sbGJhclVVSUQpIHtcbiAgaWYgKG1ldGFkYXRhLnJlcXVlc3QgJiYgdGhpcy5pc0pzb25Db250ZW50VHlwZShtZXRhZGF0YS5yZXF1ZXN0X2NvbnRlbnRfdHlwZSkpIHtcbiAgICBtZXRhZGF0YS5yZXF1ZXN0ID0gdGhpcy5zY3J1Ykpzb24obWV0YWRhdGEucmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVOZXR3b3JrKG1ldGFkYXRhLCBzdWJ0eXBlLCByb2xsYmFyVVVJRCk7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pc0pzb25Db250ZW50VHlwZSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xuICByZXR1cm4gY29udGVudFR5cGUgJiYgXy5pc1R5cGUoY29udGVudFR5cGUsICdzdHJpbmcnKSAmJiBjb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdqc29uJykgPyB0cnVlIDogZmFsc2U7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5zY3J1Ykpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2NydWIoSlNPTi5wYXJzZShqc29uKSwgdGhpcy5vcHRpb25zLnNjcnViRmllbGRzKSk7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5mZXRjaEhlYWRlcnMgPSBmdW5jdGlvbiAoaW5IZWFkZXJzLCBoZWFkZXJzQ29uZmlnKSB7XG4gIHZhciBvdXRIZWFkZXJzID0ge307XG4gIHRyeSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGhlYWRlcnNDb25maWcgPT09IHRydWUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5IZWFkZXJzLmVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSGVhZGVycy5lbnRyaWVzKCkgaXMgbm90IGltcGxlbWVudGVkIGluIElFXG4gICAgICAgIHZhciBhbGxIZWFkZXJzID0gaW5IZWFkZXJzLmVudHJpZXMoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRIZWFkZXIgPSBhbGxIZWFkZXJzLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFjdXJyZW50SGVhZGVyLmRvbmUpIHtcbiAgICAgICAgICBvdXRIZWFkZXJzW2N1cnJlbnRIZWFkZXIudmFsdWVbMF1dID0gY3VycmVudEhlYWRlci52YWx1ZVsxXTtcbiAgICAgICAgICBjdXJyZW50SGVhZGVyID0gYWxsSGVhZGVycy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlcnNDb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNDb25maWdbaV07XG4gICAgICAgIG91dEhlYWRlcnNbaGVhZGVyXSA9IGluSGVhZGVycy5nZXQoaGVhZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBpZ25vcmUgcHJvYmFibGUgSUUgZXJyb3JzICovXG4gIH1cbiAgcmV0dXJuIG91dEhlYWRlcnM7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS50cmFja0h0dHBFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDV4eCB8fCB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDR4eCB8fCB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDA7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5lcnJvck9uSHR0cFN0YXR1cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICB2YXIgc3RhdHVzID0gbWV0YWRhdGEuc3RhdHVzX2NvZGU7XG4gIGlmIChzdGF0dXMgPj0gNTAwICYmIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwNXh4IHx8IHN0YXR1cyA+PSA0MDAgJiYgdGhpcy5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrRXJyb3JPbkh0dHA0eHggfHwgc3RhdHVzID09PSAwICYmIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwMCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignSFRUUCByZXF1ZXN0IGZhaWxlZCB3aXRoIFN0YXR1cyAnICsgc3RhdHVzKTtcbiAgICBlcnJvci5zdGFjayA9IG1ldGFkYXRhLnN0YWNrO1xuICAgIHRoaXMucm9sbGJhci5lcnJvcihlcnJvciwge1xuICAgICAgc2tpcEZyYW1lczogMVxuICAgIH0pO1xuICB9XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5kZWluc3RydW1lbnRDb25zb2xlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoISgnY29uc29sZScgaW4gdGhpcy5fd2luZG93ICYmIHRoaXMuX3dpbmRvdy5jb25zb2xlLmxvZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGI7XG4gIHdoaWxlICh0aGlzLnJlcGxhY2VtZW50c1snbG9nJ10ubGVuZ3RoKSB7XG4gICAgYiA9IHRoaXMucmVwbGFjZW1lbnRzWydsb2cnXS5zaGlmdCgpO1xuICAgIHRoaXMuX3dpbmRvdy5jb25zb2xlW2JbMF1dID0gYlsxXTtcbiAgfVxufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudENvbnNvbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdjb25zb2xlJyBpbiB0aGlzLl93aW5kb3cgJiYgdGhpcy5fd2luZG93LmNvbnNvbGUubG9nKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjID0gdGhpcy5fd2luZG93LmNvbnNvbGU7XG4gIGZ1bmN0aW9uIHdyYXBDb25zb2xlKG1ldGhvZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcm9sbGJhci9yb2xsYmFyLmpzL3B1bGwvNzc4XG4gICAgdmFyIG9yaWcgPSBjW21ldGhvZF07XG4gICAgdmFyIG9yaWdDb25zb2xlID0gYztcbiAgICB2YXIgbGV2ZWwgPSBtZXRob2QgPT09ICd3YXJuJyA/ICd3YXJuaW5nJyA6IG1ldGhvZDtcbiAgICBjW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgbWVzc2FnZSA9IF8uZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpO1xuICAgICAgc2VsZi50ZWxlbWV0ZXIuY2FwdHVyZUxvZyhtZXNzYWdlLCBsZXZlbCwgbnVsbCwgXy5ub3coKSk7XG4gICAgICBpZiAob3JpZykge1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChvcmlnLCBvcmlnQ29uc29sZSwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnJlcGxhY2VtZW50c1snbG9nJ10ucHVzaChbbWV0aG9kLCBvcmlnXSk7XG4gIH1cbiAgdmFyIG1ldGhvZHMgPSBbJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvcicsICdsb2cnXTtcbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgd3JhcENvbnNvbGUobWV0aG9kc1tpXSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5kaWFnbm9zdGljLmluc3RydW1lbnRDb25zb2xlID0ge1xuICAgICAgZXJyb3I6IGUubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYXR0YWNoRXZlbnQnIGluIHRoaXMuX3dpbmRvdykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoJ2RvbScpO1xufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYXR0YWNoRXZlbnQnIGluIHRoaXMuX3dpbmRvdykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNsaWNrSGFuZGxlciA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgdmFyIGJsdXJIYW5kbGVyID0gdGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcyk7XG4gIHRoaXMuYWRkTGlzdGVuZXIoJ2RvbScsIHRoaXMuX3dpbmRvdywgJ2NsaWNrJywgJ29uY2xpY2snLCBjbGlja0hhbmRsZXIsIHRydWUpO1xuICB0aGlzLmFkZExpc3RlbmVyKCdkb20nLCB0aGlzLl93aW5kb3csICdibHVyJywgJ29uZm9jdXNvdXQnLCBibHVySGFuZGxlciwgdHJ1ZSk7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldnQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZSA9IGRvbVV0aWwuZ2V0RWxlbWVudEZyb21FdmVudChldnQsIHRoaXMuX2RvY3VtZW50KTtcbiAgICB2YXIgaGFzVGFnID0gZSAmJiBlLnRhZ05hbWU7XG4gICAgdmFyIGFuY2hvck9yQnV0dG9uID0gZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2EnKSB8fCBkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnYnV0dG9uJyk7XG4gICAgaWYgKGhhc1RhZyAmJiAoYW5jaG9yT3JCdXR0b24gfHwgZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2lucHV0JywgWydidXR0b24nLCAnc3VibWl0J10pKSkge1xuICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgfSBlbHNlIGlmIChkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnaW5wdXQnLCBbJ2NoZWNrYm94JywgJ3JhZGlvJ10pKSB7XG4gICAgICB0aGlzLmNhcHR1cmVEb21FdmVudCgnaW5wdXQnLCBlLCBlLnZhbHVlLCBlLmNoZWNrZWQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXhjKSB7XG4gICAgLy8gVE9ETzogTm90IHN1cmUgd2hhdCB0byBkbyBoZXJlXG4gIH1cbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSBkb21VdGlsLmdldEVsZW1lbnRGcm9tRXZlbnQoZXZ0LCB0aGlzLl9kb2N1bWVudCk7XG4gICAgaWYgKGUgJiYgZS50YWdOYW1lKSB7XG4gICAgICBpZiAoZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ3RleHRhcmVhJykpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2lucHV0JywgZSwgZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGRvbVV0aWwuaXNEZXNjcmliZWRFbGVtZW50KGUsICdzZWxlY3QnKSAmJiBlLm9wdGlvbnMgJiYgZS5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdElucHV0Q2hhbmdlZChlKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2lucHV0JykgJiYgIWRvbVV0aWwuaXNEZXNjcmliZWRFbGVtZW50KGUsICdpbnB1dCcsIFsnYnV0dG9uJywgJ3N1Ym1pdCcsICdoaWRkZW4nLCAnY2hlY2tib3gnLCAncmFkaW8nXSkpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2lucHV0JywgZSwgZS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChleGMpIHtcbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSB3aGF0IHRvIGRvIGhlcmVcbiAgfVxufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlU2VsZWN0SW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgaWYgKGVsZW0ubXVsdGlwbGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0ub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVsZW0ub3B0aW9uc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmNhcHR1cmVEb21FdmVudCgnaW5wdXQnLCBlbGVtLCBlbGVtLm9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbGVtLnNlbGVjdGVkSW5kZXggPj0gMCAmJiBlbGVtLm9wdGlvbnNbZWxlbS5zZWxlY3RlZEluZGV4XSkge1xuICAgIHRoaXMuY2FwdHVyZURvbUV2ZW50KCdpbnB1dCcsIGVsZW0sIGVsZW0ub3B0aW9uc1tlbGVtLnNlbGVjdGVkSW5kZXhdLnZhbHVlKTtcbiAgfVxufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuY2FwdHVyZURvbUV2ZW50ID0gZnVuY3Rpb24gKHN1YnR5cGUsIGVsZW1lbnQsIHZhbHVlLCBpc0NoZWNrZWQpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5zY3J1YlRlbGVtZXRyeUlucHV0cyB8fCBkb21VdGlsLmdldEVsZW1lbnRUeXBlKGVsZW1lbnQpID09PSAncGFzc3dvcmQnKSB7XG4gICAgICB2YWx1ZSA9ICdbc2NydWJiZWRdJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZG9tVXRpbC5kZXNjcmliZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy50ZWxlbWV0cnlTY3J1YmJlcikge1xuICAgICAgICBpZiAodGhpcy50ZWxlbWV0cnlTY3J1YmJlcihkZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICB2YWx1ZSA9ICdbc2NydWJiZWRdJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRWYWx1ZVNjcnViYmVyKGRlc2NyaXB0aW9uKSkge1xuICAgICAgICB2YWx1ZSA9ICdbc2NydWJiZWRdJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGVsZW1lbnRTdHJpbmcgPSBkb21VdGlsLmVsZW1lbnRBcnJheVRvU3RyaW5nKGRvbVV0aWwudHJlZVRvQXJyYXkoZWxlbWVudCkpO1xuICB0aGlzLnRlbGVtZXRlci5jYXB0dXJlRG9tKHN1YnR5cGUsIGVsZW1lbnRTdHJpbmcsIHZhbHVlLCBpc0NoZWNrZWQpO1xufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuZGVpbnN0cnVtZW50TmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNocm9tZSA9IHRoaXMuX3dpbmRvdy5jaHJvbWU7XG4gIHZhciBjaHJvbWVQYWNrYWdlZEFwcCA9IGNocm9tZSAmJiBjaHJvbWUuYXBwICYmIGNocm9tZS5hcHAucnVudGltZTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8xMzk0NS9maWxlc1xuICB2YXIgaGFzUHVzaFN0YXRlID0gIWNocm9tZVBhY2thZ2VkQXBwICYmIHRoaXMuX3dpbmRvdy5oaXN0b3J5ICYmIHRoaXMuX3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgaWYgKCFoYXNQdXNoU3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdG9yZSh0aGlzLnJlcGxhY2VtZW50cywgJ25hdmlnYXRpb24nKTtcbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmluc3RydW1lbnROYXZpZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hyb21lID0gdGhpcy5fd2luZG93LmNocm9tZTtcbiAgdmFyIGNocm9tZVBhY2thZ2VkQXBwID0gY2hyb21lICYmIGNocm9tZS5hcHAgJiYgY2hyb21lLmFwcC5ydW50aW1lO1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9wdWxsLzEzOTQ1L2ZpbGVzXG4gIHZhciBoYXNQdXNoU3RhdGUgPSAhY2hyb21lUGFja2FnZWRBcHAgJiYgdGhpcy5fd2luZG93Lmhpc3RvcnkgJiYgdGhpcy5fd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuICBpZiAoIWhhc1B1c2hTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcGxhY2UodGhpcy5fd2luZG93LCAnb25wb3BzdGF0ZScsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gc2VsZi5fbG9jYXRpb24uaHJlZjtcbiAgICAgIHNlbGYuaGFuZGxlVXJsQ2hhbmdlKHNlbGYuX2xhc3RIcmVmLCBjdXJyZW50KTtcbiAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCB0aGlzLnJlcGxhY2VtZW50cywgJ25hdmlnYXRpb24nKTtcbiAgcmVwbGFjZSh0aGlzLl93aW5kb3cuaGlzdG9yeSwgJ3B1c2hTdGF0ZScsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB1cmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVVcmxDaGFuZ2Uoc2VsZi5fbGFzdEhyZWYsIHVybCArICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgdGhpcy5yZXBsYWNlbWVudHMsICduYXZpZ2F0aW9uJyk7XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5oYW5kbGVVcmxDaGFuZ2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdmFyIHBhcnNlZEhyZWYgPSB1cmxwYXJzZXIucGFyc2UodGhpcy5fbG9jYXRpb24uaHJlZik7XG4gIHZhciBwYXJzZWRUbyA9IHVybHBhcnNlci5wYXJzZSh0byk7XG4gIHZhciBwYXJzZWRGcm9tID0gdXJscGFyc2VyLnBhcnNlKGZyb20pO1xuICB0aGlzLl9sYXN0SHJlZiA9IHRvO1xuICBpZiAocGFyc2VkSHJlZi5wcm90b2NvbCA9PT0gcGFyc2VkVG8ucHJvdG9jb2wgJiYgcGFyc2VkSHJlZi5ob3N0ID09PSBwYXJzZWRUby5ob3N0KSB7XG4gICAgdG8gPSBwYXJzZWRUby5wYXRoICsgKHBhcnNlZFRvLmhhc2ggfHwgJycpO1xuICB9XG4gIGlmIChwYXJzZWRIcmVmLnByb3RvY29sID09PSBwYXJzZWRGcm9tLnByb3RvY29sICYmIHBhcnNlZEhyZWYuaG9zdCA9PT0gcGFyc2VkRnJvbS5ob3N0KSB7XG4gICAgZnJvbSA9IHBhcnNlZEZyb20ucGF0aCArIChwYXJzZWRGcm9tLmhhc2ggfHwgJycpO1xuICB9XG4gIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVOYXZpZ2F0aW9uKGZyb20sIHRvLCBfLm5vdygpKTtcbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudENvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYm9keScgaW4gdGhpcy5fZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLl93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCdjb25uZWN0aXZpdHknKTtcbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlKHRoaXMucmVwbGFjZW1lbnRzLCAnY29ubmVjdGl2aXR5Jyk7XG4gIH1cbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmluc3RydW1lbnRDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdhZGRFdmVudExpc3RlbmVyJyBpbiB0aGlzLl93aW5kb3cgfHwgJ2JvZHknIGluIHRoaXMuX2RvY3VtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGhpcy5fd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0aGlzLmFkZExpc3RlbmVyKCdjb25uZWN0aXZpdHknLCB0aGlzLl93aW5kb3csICdvbmxpbmUnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVDb25uZWN0aXZpdHlDaGFuZ2UoJ29ubGluZScpO1xuICAgIH0uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcignY29ubmVjdGl2aXR5JywgdGhpcy5fd2luZG93LCAnb2ZmbGluZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSgnb2ZmbGluZScpO1xuICAgIH0uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlcGxhY2UodGhpcy5fZG9jdW1lbnQuYm9keSwgJ29ub25saW5lJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudGVsZW1ldGVyLmNhcHR1cmVDb25uZWN0aXZpdHlDaGFuZ2UoJ29ubGluZScpO1xuICAgICAgICBpZiAob3JpZykge1xuICAgICAgICAgIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCB0aGlzLnJlcGxhY2VtZW50cywgJ2Nvbm5lY3Rpdml0eScpO1xuICAgIHJlcGxhY2UodGhpcy5fZG9jdW1lbnQuYm9keSwgJ29ub2ZmbGluZScsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnRlbGVtZXRlci5jYXB0dXJlQ29ubmVjdGl2aXR5Q2hhbmdlKCdvZmZsaW5lJyk7XG4gICAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIHRoaXMucmVwbGFjZW1lbnRzLCAnY29ubmVjdGl2aXR5Jyk7XG4gIH1cbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmhhbmRsZUNzcEV2ZW50ID0gZnVuY3Rpb24gKGNzcEV2ZW50KSB7XG4gIHZhciBtZXNzYWdlID0gJ1NlY3VyaXR5IFBvbGljeSBWaW9sYXRpb246ICcgKyAnYmxvY2tlZFVSSTogJyArIGNzcEV2ZW50LmJsb2NrZWRVUkkgKyAnLCAnICsgJ3Zpb2xhdGVkRGlyZWN0aXZlOiAnICsgY3NwRXZlbnQudmlvbGF0ZWREaXJlY3RpdmUgKyAnLCAnICsgJ2VmZmVjdGl2ZURpcmVjdGl2ZTogJyArIGNzcEV2ZW50LmVmZmVjdGl2ZURpcmVjdGl2ZSArICcsICc7XG4gIGlmIChjc3BFdmVudC5zb3VyY2VGaWxlKSB7XG4gICAgbWVzc2FnZSArPSAnbG9jYXRpb246ICcgKyBjc3BFdmVudC5zb3VyY2VGaWxlICsgJywgJyArICdsaW5lOiAnICsgY3NwRXZlbnQubGluZU51bWJlciArICcsICcgKyAnY29sOiAnICsgY3NwRXZlbnQuY29sdW1uTnVtYmVyICsgJywgJztcbiAgfVxuICBtZXNzYWdlICs9ICdvcmlnaW5hbFBvbGljeTogJyArIGNzcEV2ZW50Lm9yaWdpbmFsUG9saWN5O1xuICB0aGlzLnRlbGVtZXRlci5jYXB0dXJlTG9nKG1lc3NhZ2UsICdlcnJvcicsIG51bGwsIF8ubm93KCkpO1xuICB0aGlzLmhhbmRsZUNzcEVycm9yKG1lc3NhZ2UpO1xufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlQ3NwRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5lcnJvck9uQ29udGVudFNlY3VyaXR5UG9saWN5KSB7XG4gICAgdGhpcy5yb2xsYmFyLmVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5kZWluc3RydW1lbnRDb250ZW50U2VjdXJpdHlQb2xpY3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdhZGRFdmVudExpc3RlbmVyJyBpbiB0aGlzLl9kb2N1bWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoJ2NvbnRlbnRzZWN1cml0eXBvbGljeScpO1xufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudENvbnRlbnRTZWN1cml0eVBvbGljeSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX2RvY3VtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY3NwSGFuZGxlciA9IHRoaXMuaGFuZGxlQ3NwRXZlbnQuYmluZCh0aGlzKTtcbiAgdGhpcy5hZGRMaXN0ZW5lcignY29udGVudHNlY3VyaXR5cG9saWN5JywgdGhpcy5fZG9jdW1lbnQsICdzZWN1cml0eXBvbGljeXZpb2xhdGlvbicsIG51bGwsIGNzcEhhbmRsZXIsIGZhbHNlKTtcbn07XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKHNlY3Rpb24sIG9iaiwgdHlwZSwgYWx0VHlwZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICBpZiAob2JqLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICB0aGlzLmV2ZW50UmVtb3ZlcnNbc2VjdGlvbl0ucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChhbHRUeXBlKSB7XG4gICAgb2JqLmF0dGFjaEV2ZW50KGFsdFR5cGUsIGhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRSZW1vdmVyc1tzZWN0aW9uXS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5kZXRhY2hFdmVudChhbHRUeXBlLCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufTtcbkluc3RydW1lbnRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgdmFyIHI7XG4gIHdoaWxlICh0aGlzLmV2ZW50UmVtb3ZlcnNbc2VjdGlvbl0ubGVuZ3RoKSB7XG4gICAgciA9IHRoaXMuZXZlbnRSZW1vdmVyc1tzZWN0aW9uXS5zaGlmdCgpO1xuICAgIHIoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIF9pc1VybE9iamVjdChpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIFVSTCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBVUkw7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEluc3RydW1lbnRlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gd3JhcEdsb2JhbHMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYnVnc25hZy9idWdzbmFnLWpzXG4gIHZhciBnbG9iYWxzID0gJ0V2ZW50VGFyZ2V0LFdpbmRvdyxOb2RlLEFwcGxpY2F0aW9uQ2FjaGUsQXVkaW9UcmFja0xpc3QsQ2hhbm5lbE1lcmdlck5vZGUsQ3J5cHRvT3BlcmF0aW9uLEV2ZW50U291cmNlLEZpbGVSZWFkZXIsSFRNTFVua25vd25FbGVtZW50LElEQkRhdGFiYXNlLElEQlJlcXVlc3QsSURCVHJhbnNhY3Rpb24sS2V5T3BlcmF0aW9uLE1lZGlhQ29udHJvbGxlcixNZXNzYWdlUG9ydCxNb2RhbFdpbmRvdyxOb3RpZmljYXRpb24sU1ZHRWxlbWVudEluc3RhbmNlLFNjcmVlbixUZXh0VHJhY2ssVGV4dFRyYWNrQ3VlLFRleHRUcmFja0xpc3QsV2ViU29ja2V0LFdlYlNvY2tldFdvcmtlcixXb3JrZXIsWE1MSHR0cFJlcXVlc3QsWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCxYTUxIdHRwUmVxdWVzdFVwbG9hZCcuc3BsaXQoJywnKTtcbiAgdmFyIGksIGdsb2JhbDtcbiAgZm9yIChpID0gMDsgaSA8IGdsb2JhbHMubGVuZ3RoOyArK2kpIHtcbiAgICBnbG9iYWwgPSBnbG9iYWxzW2ldO1xuICAgIGlmICh3aW5kb3dbZ2xvYmFsXSAmJiB3aW5kb3dbZ2xvYmFsXS5wcm90b3R5cGUpIHtcbiAgICAgIF9leHRlbmRMaXN0ZW5lclByb3RvdHlwZShoYW5kbGVyLCB3aW5kb3dbZ2xvYmFsXS5wcm90b3R5cGUsIHNoaW0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2V4dGVuZExpc3RlbmVyUHJvdG90eXBlKGhhbmRsZXIsIHByb3RvdHlwZSwgc2hpbSkge1xuICBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5ICYmIHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnYWRkRXZlbnRMaXN0ZW5lcicpKSB7XG4gICAgdmFyIG9sZEFkZEV2ZW50TGlzdGVuZXIgPSBwcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB3aGlsZSAob2xkQWRkRXZlbnRMaXN0ZW5lci5fcm9sbGJhck9sZEFkZCAmJiBvbGRBZGRFdmVudExpc3RlbmVyLmJlbG9uZ3NUb1NoaW0pIHtcbiAgICAgIG9sZEFkZEV2ZW50TGlzdGVuZXIgPSBvbGRBZGRFdmVudExpc3RlbmVyLl9yb2xsYmFyT2xkQWRkO1xuICAgIH1cbiAgICB2YXIgYWRkRm4gPSBmdW5jdGlvbiBhZGRGbihldmVudCwgY2FsbGJhY2ssIGJ1YmJsZSkge1xuICAgICAgb2xkQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCBoYW5kbGVyLndyYXAoY2FsbGJhY2spLCBidWJibGUpO1xuICAgIH07XG4gICAgYWRkRm4uX3JvbGxiYXJPbGRBZGQgPSBvbGRBZGRFdmVudExpc3RlbmVyO1xuICAgIGFkZEZuLmJlbG9uZ3NUb1NoaW0gPSBzaGltO1xuICAgIHByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRm47XG4gICAgdmFyIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICB3aGlsZSAob2xkUmVtb3ZlRXZlbnRMaXN0ZW5lci5fcm9sbGJhck9sZFJlbW92ZSAmJiBvbGRSZW1vdmVFdmVudExpc3RlbmVyLmJlbG9uZ3NUb1NoaW0pIHtcbiAgICAgIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIgPSBvbGRSZW1vdmVFdmVudExpc3RlbmVyLl9yb2xsYmFyT2xkUmVtb3ZlO1xuICAgIH1cbiAgICB2YXIgcmVtb3ZlRm4gPSBmdW5jdGlvbiByZW1vdmVGbihldmVudCwgY2FsbGJhY2ssIGJ1YmJsZSkge1xuICAgICAgb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCBjYWxsYmFjayAmJiBjYWxsYmFjay5fcm9sbGJhcl93cmFwcGVkIHx8IGNhbGxiYWNrLCBidWJibGUpO1xuICAgIH07XG4gICAgcmVtb3ZlRm4uX3JvbGxiYXJPbGRSZW1vdmUgPSBvbGRSZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHJlbW92ZUZuLmJlbG9uZ3NUb1NoaW0gPSBzaGltO1xuICAgIHByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRm47XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gd3JhcEdsb2JhbHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MzY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qXG4gKiBoZWFkZXJzIC0gRGV0ZWN0IHdoZW4gZmV0Y2ggSGVhZGVycyBhcmUgdW5kZWZpbmVkIGFuZCB1c2UgYSBwYXJ0aWFsIHBvbHlmaWxsLlxuICpcbiAqIEEgZnVsbCBwb2x5ZmlsbCBpcyBub3QgdXNlZCBpbiBvcmRlciB0byBrZWVwIHBhY2thZ2Ugc2l6ZSBhcyBzbWFsbCBhcyBwb3NzaWJsZS5cbiAqIFNpbmNlIHRoaXMgaXMgb25seSB1c2VkIGludGVybmFsbHkgYW5kIGlzIG5vdCBhZGRlZCB0byB0aGUgd2luZG93IG9iamVjdCxcbiAqIHRoZSBmdWxsIGludGVyZmFjZSBkb2Vzbid0IG5lZWQgdG8gYmUgc3VwcG9ydGVkLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgbW9kaWZpZWQgZnJvbSB3aGF0d2ctZmV0Y2g6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoXG4gKi9cbmZ1bmN0aW9uIGhlYWRlcnMoaGVhZGVycykge1xuICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaEhlYWRlcnMoaGVhZGVycyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5mdW5jdGlvbiBGZXRjaEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9O1xuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEZldGNoSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn1cbkZldGNoSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07XG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xufTtcbkZldGNoSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbDtcbn07XG5GZXRjaEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKTtcbn07XG5GZXRjaEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG59O1xuRmV0Y2hIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gaGVhZGVycztcblxuLyoqKi8gfSksXG5cbi8qKiovIDczODpcbi8qKiovIChmdW5jdGlvbigpIHtcblxuLy8gQ29uc29sZS1wb2x5ZmlsbC4gTUlUIGxpY2Vuc2UuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2NvbnNvbGUtcG9seWZpbGxcbi8vIE1ha2UgaXQgc2FmZSB0byBkbyBjb25zb2xlLmxvZygpIGFsd2F5cy5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAoIWdsb2JhbC5jb25zb2xlKSB7XG4gICAgZ2xvYmFsLmNvbnNvbGUgPSB7fTtcbiAgfVxuICB2YXIgY29uID0gZ2xvYmFsLmNvbnNvbGU7XG4gIHZhciBwcm9wLCBtZXRob2Q7XG4gIHZhciBkdW1teSA9IGZ1bmN0aW9uKCkge307XG4gIHZhciBwcm9wZXJ0aWVzID0gWydtZW1vcnknXTtcbiAgdmFyIG1ldGhvZHMgPSAoJ2Fzc2VydCxjbGVhcixjb3VudCxkZWJ1ZyxkaXIsZGlyeG1sLGVycm9yLGV4Y2VwdGlvbixncm91cCwnICtcbiAgICAgJ2dyb3VwQ29sbGFwc2VkLGdyb3VwRW5kLGluZm8sbG9nLG1hcmtUaW1lbGluZSxwcm9maWxlLHByb2ZpbGVzLHByb2ZpbGVFbmQsJyArXG4gICAgICdzaG93LHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSx0aW1lbGluZUVuZCx0aW1lU3RhbXAsdHJhY2Usd2FybicpLnNwbGl0KCcsJyk7XG4gIHdoaWxlIChwcm9wID0gcHJvcGVydGllcy5wb3AoKSkgaWYgKCFjb25bcHJvcF0pIGNvbltwcm9wXSA9IHt9O1xuICB3aGlsZSAobWV0aG9kID0gbWV0aG9kcy5wb3AoKSkgaWYgKCFjb25bbWV0aG9kXSkgY29uW21ldGhvZF0gPSBkdW1teTtcbiAgLy8gVXNpbmcgYHRoaXNgIGZvciB3ZWIgd29ya2VycyAmIHN1cHBvcnRzIEJyb3dzZXJpZnkgLyBXZWJwYWNrLlxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzIDogd2luZG93KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQ2OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xuZnVuY3Rpb24gY2hlY2tJZ25vcmUoaXRlbSwgc2V0dGluZ3MpIHtcbiAgaWYgKF8uZ2V0KHNldHRpbmdzLCAncGx1Z2lucy5qcXVlcnkuaWdub3JlQWpheEVycm9ycycpKSB7XG4gICAgcmV0dXJuICFfLmdldChpdGVtLCAnYm9keS5tZXNzYWdlLmV4dHJhLmlzQWpheCcpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrSWdub3JlOiBjaGVja0lnbm9yZVxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDc1MTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcbnZhciBtYWtlRmV0Y2hSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzIpO1xudmFyIG1ha2VYaHJSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjIpO1xuXG4vKlxuICogYWNjZXNzVG9rZW4gbWF5IGJlIGVtYmVkZGVkIGluIHBheWxvYWQgYnV0IHRoYXQgc2hvdWxkIG5vdFxuICogICBiZSBhc3N1bWVkXG4gKlxuICogb3B0aW9uczoge1xuICogICBob3N0bmFtZVxuICogICBwcm90b2NvbFxuICogICBwYXRoXG4gKiAgIHBvcnRcbiAqICAgbWV0aG9kXG4gKiAgIHRyYW5zcG9ydCAoJ3hocicgfCAnZmV0Y2gnKVxuICogfVxuICpcbiAqICBwYXJhbXMgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5L3ZhbHVlIHBhaXJzLiBUaGVzZVxuICogICAgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcGF0aCBhcyAna2V5PXZhbHVlJmtleT12YWx1ZSdcbiAqXG4gKiBwYXlsb2FkIGlzIGFuIHVuc2VyaWFsaXplZCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gVHJhbnNwb3J0KHRydW5jYXRpb24pIHtcbiAgdGhpcy50cnVuY2F0aW9uID0gdHJ1bmNhdGlvbjtcbn1cblRyYW5zcG9ydC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBvcHRpb25zLCBwYXJhbXMsIGNhbGxiYWNrLCByZXF1ZXN0RmFjdG9yeSkge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHt9O1xuICB9XG4gIF8uYWRkUGFyYW1zQW5kQWNjZXNzVG9rZW5Ub1BhdGgoYWNjZXNzVG9rZW4sIG9wdGlvbnMsIHBhcmFtcyk7XG4gIHZhciBtZXRob2QgPSAnR0VUJztcbiAgdmFyIHVybCA9IF8uZm9ybWF0VXJsKG9wdGlvbnMpO1xuICB0aGlzLl9tYWtlWm9uZVJlcXVlc3QoYWNjZXNzVG9rZW4sIHVybCwgbWV0aG9kLCBudWxsLCBjYWxsYmFjaywgcmVxdWVzdEZhY3RvcnksIG9wdGlvbnMudGltZW91dCwgb3B0aW9ucy50cmFuc3BvcnQpO1xufTtcblRyYW5zcG9ydC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgb3B0aW9ucywgcGF5bG9hZCwgY2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5KSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge307XG4gIH1cbiAgaWYgKCFwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQ2Fubm90IHNlbmQgZW1wdHkgcmVxdWVzdCcpKTtcbiAgfVxuICB2YXIgc3RyaW5naWZ5UmVzdWx0O1xuICBpZiAodGhpcy50cnVuY2F0aW9uKSB7XG4gICAgc3RyaW5naWZ5UmVzdWx0ID0gdGhpcy50cnVuY2F0aW9uLnRydW5jYXRlKHBheWxvYWQpO1xuICB9IGVsc2Uge1xuICAgIHN0cmluZ2lmeVJlc3VsdCA9IF8uc3RyaW5naWZ5KHBheWxvYWQpO1xuICB9XG4gIGlmIChzdHJpbmdpZnlSZXN1bHQuZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soc3RyaW5naWZ5UmVzdWx0LmVycm9yKTtcbiAgfVxuICB2YXIgd3JpdGVEYXRhID0gc3RyaW5naWZ5UmVzdWx0LnZhbHVlO1xuICB2YXIgbWV0aG9kID0gJ1BPU1QnO1xuICB2YXIgdXJsID0gXy5mb3JtYXRVcmwob3B0aW9ucyk7XG4gIHRoaXMuX21ha2Vab25lUmVxdWVzdChhY2Nlc3NUb2tlbiwgdXJsLCBtZXRob2QsIHdyaXRlRGF0YSwgY2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5LCBvcHRpb25zLnRpbWVvdXQsIG9wdGlvbnMudHJhbnNwb3J0KTtcbn07XG5UcmFuc3BvcnQucHJvdG90eXBlLnBvc3RKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgb3B0aW9ucywganNvblBheWxvYWQsIGNhbGxiYWNrLCByZXF1ZXN0RmFjdG9yeSkge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHt9O1xuICB9XG4gIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gIHZhciB1cmwgPSBfLmZvcm1hdFVybChvcHRpb25zKTtcbiAgdGhpcy5fbWFrZVpvbmVSZXF1ZXN0KGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwganNvblBheWxvYWQsIGNhbGxiYWNrLCByZXF1ZXN0RmFjdG9yeSwgb3B0aW9ucy50aW1lb3V0LCBvcHRpb25zLnRyYW5zcG9ydCk7XG59O1xuXG4vLyBXcmFwcyBgX21ha2VSZXF1ZXN0YCBpZiB6b25lLmpzIGlzIGJlaW5nIHVzZWQsIGVuc3VyaW5nIHRoYXQgUm9sbGJhclxuLy8gQVBJIGNhbGxzIGFyZSBub3QgaW50ZXJjZXB0ZWQgYnkgYW55IGNoaWxkIGZvcmtlZCB6b25lcy5cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgTmdab25lLnJ1bk91dHNpZGVBbmd1bGFyYCBpbiBBbmd1bGFyLlxuVHJhbnNwb3J0LnByb3RvdHlwZS5fbWFrZVpvbmVSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ1dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93IHx8IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGY7XG4gIC8vIFdoZW5ldmVyIHpvbmUuanMgaXMgbG9hZGVkIGFuZCBgWm9uZWAgaXMgZXhwb3NlZCBnbG9iYWxseSwgYWNjZXNzXG4gIC8vIHRoZSByb290IHpvbmUgdG8gZW5zdXJlIHRoYXQgcmVxdWVzdHMgYXJlIGFsd2F5cyBtYWRlIHdpdGhpbiBpdC5cbiAgLy8gVGhpcyBhcHByb2FjaCBpcyBmcmFtZXdvcmstYWdub3N0aWMsIHJlZ2FyZGxlc3Mgb2Ygd2hpY2hcbiAgLy8gZnJhbWV3b3JrIHpvbmUuanMgaXMgdXNlZCB3aXRoLlxuICB2YXIgcm9vdFpvbmUgPSBnV2luZG93ICYmIGdXaW5kb3cuWm9uZSAmJiBnV2luZG93LlpvbmUucm9vdDtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICBpZiAocm9vdFpvbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcm9vdFpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX21ha2VSZXF1ZXN0LmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWFrZVJlcXVlc3QuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfVxufTtcblRyYW5zcG9ydC5wcm90b3R5cGUuX21ha2VSZXF1ZXN0ID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5LCB0aW1lb3V0LCB0cmFuc3BvcnQpIHtcbiAgaWYgKHR5cGVvZiBSb2xsYmFyUHJveHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIF9wcm94eVJlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xuICB9XG4gIGlmICh0cmFuc3BvcnQgPT09ICdmZXRjaCcpIHtcbiAgICBtYWtlRmV0Y2hSZXF1ZXN0KGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIHRpbWVvdXQpO1xuICB9IGVsc2Uge1xuICAgIG1ha2VYaHJSZXF1ZXN0KGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5LCB0aW1lb3V0KTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIFJvbGxiYXJQcm94eSAqL1xuZnVuY3Rpb24gX3Byb3h5UmVxdWVzdChqc29uLCBjYWxsYmFjaykge1xuICB2YXIgcm9sbGJhclByb3h5ID0gbmV3IFJvbGxiYXJQcm94eSgpO1xuICByb2xsYmFyUHJveHkuc2VuZEpzb25QYXlsb2FkKGpzb24sIGZ1bmN0aW9uIChfbXNnKSB7XG4gICAgLyogZG8gbm90aGluZyAqL1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoZXJyKSk7XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGhleGFkZWNpbWFsIElEIG9mIHNwZWNpZmllZCBieXRlIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyAtIE51bWJlciBvZiBieXRlcyBmb3IgdGhlIElEIChkZWZhdWx0OiAxNilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gSGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdlbigpIHtcbiAgdmFyIGJ5dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxNjtcbiAgdmFyIHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ5dGVzKTtcbiAgdmFyIHJhbmRIZXggPSBBcnJheS5mcm9tKHJhbmRvbUJ5dGVzLCBmdW5jdGlvbiAoX2J5dGUpIHtcbiAgICByZXR1cm4gX2J5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gIH0pLmpvaW4oJycpO1xuICByZXR1cm4gcmFuZEhleDtcbn1cblxuLyoqXG4gKiBUcmFjaW5nIGlkIGdlbmVyYXRpb24gdXRpbHNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IGlkIGZyb20gJy4vaWQuanMnO1xuICpcbiAqIGNvbnN0IHNwYW5JZCA9IGlkLmdlbig4KTsgLy8gPT4gXCJhMWIyYzNkNGU1ZjYuLi5cIlxuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX18uQSA9ICh7XG4gIGdlbjogZ2VuXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDc5Mjpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgcnJ3ZWIgcmVjb3JkZXJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcnJ3ZWItaW8vcnJ3ZWIvYmxvYi9tYXN0ZXIvZ3VpZGUubWQjb3B0aW9ucyBmb3IgZGV0YWlsc1xuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIC8vIFdoZXRoZXIgcmVjb3JkaW5nIGlzIGVuYWJsZWRcbiAgYXV0b1N0YXJ0OiB0cnVlLFxuICAvLyBTdGFydCByZWNvcmRpbmcgYXV0b21hdGljYWxseSB3aGVuIFJvbGxiYXIgaW5pdGlhbGl6ZXNcbiAgZGVidWc6IHtcbiAgICBsb2dFbWl0czogZmFsc2UgLy8gV2hldGhlciB0byBsb2cgZW1pdHRlZCBldmVudHNcbiAgfSxcbiAgLy8gUmVjb3JkaW5nIG9wdGlvbnNcbiAgaW5saW5lU3R5bGVzaGVldDogdHJ1ZSxcbiAgLy8gV2hldGhlciB0byBpbmxpbmUgc3R5bGVzaGVldHMgdG8gaW1wcm92ZSByZXBsYXkgYWNjdXJhY3lcbiAgaW5saW5lSW1hZ2VzOiBmYWxzZSxcbiAgLy8gV2hldGhlciB0byByZWNvcmQgdGhlIGltYWdlIGNvbnRlbnRcbiAgY29sbGVjdEZvbnRzOiB0cnVlLFxuICAvLyBXaGV0aGVyIHRvIGNvbGxlY3QgZm9udHMgaW4gdGhlIHdlYnNpdGVcblxuICAvLyBQcml2YWN5IG9wdGlvbnNcbiAgLy8gRmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB3aGljaCBpbnB1dCB0eXBlcyB0byBtYXNrXG4gIC8vIEJ5IGRlZmF1bHQgb25seSBwYXNzd29yZCBpbnB1dHMgYXJlIG1hc2tlZCBpZiBtYXNrSW5wdXRzIGlzIHRydWVcbiAgbWFza0lucHV0T3B0aW9uczoge1xuICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgIGVtYWlsOiBmYWxzZSxcbiAgICB0ZWw6IGZhbHNlLFxuICAgIHRleHQ6IGZhbHNlLFxuICAgIGNvbG9yOiBmYWxzZSxcbiAgICBkYXRlOiBmYWxzZSxcbiAgICAnZGF0ZXRpbWUtbG9jYWwnOiBmYWxzZSxcbiAgICBtb250aDogZmFsc2UsXG4gICAgbnVtYmVyOiBmYWxzZSxcbiAgICByYW5nZTogZmFsc2UsXG4gICAgc2VhcmNoOiBmYWxzZSxcbiAgICB0aW1lOiBmYWxzZSxcbiAgICB1cmw6IGZhbHNlLFxuICAgIHdlZWs6IGZhbHNlXG4gIH0sXG4gIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBwYXJ0cyBvZiB0aGUgRE9NXG4gIC8vIEJ5IGRlZmF1bHQgYWxsIHJlbW92YWJsZSBlbGVtZW50cyBhcmUgcmVtb3ZlZFxuICBzbGltRE9NT3B0aW9uczoge1xuICAgIHNjcmlwdDogdHJ1ZSxcbiAgICAvLyBSZW1vdmUgc2NyaXB0IGVsZW1lbnRzXG4gICAgY29tbWVudDogdHJ1ZSxcbiAgICAvLyBSZW1vdmUgY29tbWVudHNcbiAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcbiAgICAvLyBSZW1vdmUgZmF2aWNvbnMgaW4gdGhlIGhlYWRcbiAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZSBpbiBoZWFkXG4gICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IHRydWUsXG4gICAgLy8gUmVtb3ZlIG1ldGEgZGVzY3JpcHRpb24gYW5kIGtleXdvcmRzXG4gICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgLy8gUmVtb3ZlIHNvY2lhbCBtZWRpYSBtZXRhIHRhZ3NcbiAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcbiAgICAvLyBSZW1vdmUgcm9ib3RzIG1ldGEgZGlyZWN0aXZlc1xuICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgIC8vIFJlbW92ZSBodHRwLWVxdWl2IG1ldGEgZGlyZWN0aXZlc1xuICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcbiAgICAvLyBSZW1vdmUgYXV0aG9yc2hpcCBtZXRhIGRpcmVjdGl2ZXNcbiAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZSAvLyBSZW1vdmUgdmVyaWZpY2F0aW9uIG1ldGEgZGlyZWN0aXZlc1xuICB9XG5cbiAgLy8gQ3VzdG9tIGNhbGxiYWNrcyBmb3IgYWR2YW5jZWQgdXNlIGNhc2VzXG4gIC8vIFRoZXNlIGFyZSB1bmRlZmluZWQgYnkgZGVmYXVsdCBhbmQgY2FuIGJlIHNldCBwcm9ncmFtbWF0aWNhbGx5XG4gIC8vIG1hc2tJbnB1dEZuOiB1bmRlZmluZWQsICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIG1hc2sgaW5wdXQgdmFsdWVzXG4gIC8vIG1hc2tUZXh0Rm46IHVuZGVmaW5lZCwgICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIG1hc2sgdGV4dCBjb250ZW50XG4gIC8vIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLCAgICAgLy8gQ3VzdG9tIGVycm9yIGhhbmRsZXIgZm9yIHJlY29yZGluZyBlcnJvcnNcblxuICAvLyBQbHVnaW4gc3lzdGVtXG4gIC8vIHBsdWdpbnM6IFtdICAgICAgICAgICAgICAgICAgLy8gTGlzdCBvZiBwbHVnaW5zIHRvIHVzZSAobXVzdCBiZSBzZXQgcHJvZ3JhbW1hdGljYWxseSlcbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODYyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0Ki9cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4NSk7XG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDQpO1xuZnVuY3Rpb24gbWFrZVhoclJlcXVlc3QoYWNjZXNzVG9rZW4sIHVybCwgbWV0aG9kLCBkYXRhLCBjYWxsYmFjaywgcmVxdWVzdEZhY3RvcnksIHRpbWVvdXQpIHtcbiAgdmFyIHJlcXVlc3Q7XG4gIGlmIChyZXF1ZXN0RmFjdG9yeSkge1xuICAgIHJlcXVlc3QgPSByZXF1ZXN0RmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QgPSBfY3JlYXRlWE1MSFRUUE9iamVjdCgpO1xuICB9XG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEdpdmUgdXAsIG5vIHdheSB0byBzZW5kIHJlcXVlc3RzXG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm8gd2F5IHRvIHNlbmQgYSByZXF1ZXN0JykpO1xuICB9XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfb25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gb25yZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfb25yZWFkeXN0YXRlY2hhbmdlICYmIHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgX29ucmVhZHlzdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBwYXJzZVJlc3BvbnNlID0gXy5qc29uUGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgaWYgKF9pc1N1Y2Nlc3MocmVxdWVzdCkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socGFyc2VSZXNwb25zZS5lcnJvciwgcGFyc2VSZXNwb25zZS52YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2lzTm9ybWFsRmFpbHVyZShyZXF1ZXN0KSkge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICAgIC8vIGxpa2VseSBjYXVzZWQgYnkgdXNpbmcgYSBzZXJ2ZXIgYWNjZXNzIHRva2VuXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBwYXJzZVJlc3BvbnNlLnZhbHVlICYmIHBhcnNlUmVzcG9uc2UudmFsdWUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbGlkIGh0dHAgc3RhdHVzIGNvZGVzXG4gICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihTdHJpbmcocmVxdWVzdC5zdGF0dXMpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJRSB3aWxsIHJldHVybiBhIHN0YXR1cyAxMjAwMCsgb24gc29tZSBzb3J0IG9mIGNvbm5lY3Rpb24gZmFpbHVyZSxcbiAgICAgICAgICAgICAgLy8gc28gd2UgcmV0dXJuIGEgYmxhbmsgZXJyb3JcbiAgICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2FhMzgzNzcwJTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgICB2YXIgbXNnID0gJ1hIUiByZXNwb25zZSBoYWQgbm8gc3RhdHVzIGNvZGUgKGxpa2VseSBjb25uZWN0aW9uIGZhaWx1cmUpJztcbiAgICAgICAgICAgICAgY2FsbGJhY2soX25ld1JldHJpYWJsZUVycm9yKG1zZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAvL2pxdWVyeSBzb3VyY2UgbWVudGlvbnMgZmlyZWZveCBtYXkgZXJyb3Igb3V0IHdoaWxlIGFjY2Vzc2luZyB0aGVcbiAgICAgICAgICAvL3JlcXVlc3QgbWVtYmVycyBpZiB0aGVyZSBpcyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvYTkzOGQ3YjEyODJmYzBlNWM1MjUwMmMyMjVhZThmMGNlZjIxOWYwYS9zcmMvYWpheC94aHIuanMjTDExMVxuICAgICAgICAgIHZhciBleGM7XG4gICAgICAgICAgaWYgKGV4ICYmIGV4LnN0YWNrKSB7XG4gICAgICAgICAgICBleGMgPSBleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhjID0gbmV3IEVycm9yKGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2soZXhjKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICBpZiAocmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJvbGxiYXItQWNjZXNzLVRva2VuJywgYWNjZXNzVG9rZW4pO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNGaW5pdGVOdW1iZXIodGltZW91dCkpIHtcbiAgICAgICAgcmVxdWVzdC50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gX29ucmVhZHlzdGF0ZWNoYW5nZTtcbiAgICAgIHJlcXVlc3Quc2VuZChkYXRhKTtcbiAgICB9IGNhdGNoIChlMSkge1xuICAgICAgLy8gU2VuZGluZyB1c2luZyB0aGUgbm9ybWFsIHhtbGh0dHByZXF1ZXN0IG9iamVjdCBkaWRuJ3Qgd29yaywgdHJ5IFhEb21haW5SZXF1ZXN0XG4gICAgICBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBBc3N1bWUgd2UgYXJlIGluIGEgcmVhbGx5IG9sZCBicm93c2VyIHdoaWNoIGhhcyBhIGJ1bmNoIG9mIGxpbWl0YXRpb25zOlxuICAgICAgICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cbiAgICAgICAgLy8gRXh0cmVtZSBwYXJhbm9pYTogaWYgd2UgaGF2ZSBYRG9tYWluUmVxdWVzdCB0aGVuIHdlIGhhdmUgYSB3aW5kb3csIGJ1dCBqdXN0IGluIGNhc2VcbiAgICAgICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIHdpbmRvdyBhdmFpbGFibGUgZHVyaW5nIHJlcXVlc3QsIHVua25vd24gZW52aXJvbm1lbnQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBwYWdlIGlzIGh0dHAsIHRyeSBhbmQgc2VuZCBvdmVyIGh0dHBcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnN1YnN0cmluZygwLCA1KSA9PT0gJ2h0dHA6JyAmJiB1cmwuc3Vic3RyaW5nKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgICAgICAgdXJsID0gJ2h0dHAnICsgdXJsLnN1YnN0cmluZyg1KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeGRvbWFpbnJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB4ZG9tYWlucmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdSZXF1ZXN0IHRpbWVkIG91dCc7XG4gICAgICAgICAgdmFyIGNvZGUgPSAnRVRJTUVET1VUJztcbiAgICAgICAgICBjYWxsYmFjayhfbmV3UmV0cmlhYmxlRXJyb3IobXNnLCBjb2RlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHhkb21haW5yZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdFcnJvciBkdXJpbmcgcmVxdWVzdCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwYXJzZVJlc3BvbnNlID0gXy5qc29uUGFyc2UoeGRvbWFpbnJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhwYXJzZVJlc3BvbnNlLmVycm9yLCBwYXJzZVJlc3BvbnNlLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhkb21haW5yZXF1ZXN0LnNlbmQoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgbWV0aG9kIHRvIHRyYW5zcG9ydCBhIHJlcXVlc3QnKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlMikge1xuICAgIGNhbGxiYWNrKGUyKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVhNTEhUVFBPYmplY3QoKSB7XG4gIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0OmZhbHNlICovXG5cbiAgdmFyIGZhY3RvcmllcyA9IFtmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDMuWE1MSFRUUCcpO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICB9XTtcbiAgdmFyIHhtbGh0dHA7XG4gIHZhciBpO1xuICB2YXIgbnVtRmFjdG9yaWVzID0gZmFjdG9yaWVzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IG51bUZhY3RvcmllczsgaSsrKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgICB0cnkge1xuICAgICAgeG1saHR0cCA9IGZhY3Rvcmllc1tpXSgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcGFzc1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG4gIH1cbiAgcmV0dXJuIHhtbGh0dHA7XG59XG5mdW5jdGlvbiBfaXNTdWNjZXNzKHIpIHtcbiAgcmV0dXJuIHIgJiYgci5zdGF0dXMgJiYgci5zdGF0dXMgPT09IDIwMDtcbn1cbmZ1bmN0aW9uIF9pc05vcm1hbEZhaWx1cmUocikge1xuICByZXR1cm4gciAmJiBfLmlzVHlwZShyLnN0YXR1cywgJ251bWJlcicpICYmIHIuc3RhdHVzID49IDQwMCAmJiByLnN0YXR1cyA8IDYwMDtcbn1cbmZ1bmN0aW9uIF9uZXdSZXRyaWFibGVFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29kZSB8fCAnRU5PVEZPVU5EJztcbiAgcmV0dXJuIGVycjtcbn1cbm1vZHVsZS5leHBvcnRzID0gbWFrZVhoclJlcXVlc3Q7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MTg6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBSZWNvcmRlcjsgfVxufSk7XG5cbjsvLyAuL25vZGVfbW9kdWxlcy9AcnJ3ZWIvcmVjb3JkL2Rpc3QvcmVjb3JkLmpzXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIF9hO1xudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG52YXIgTm9kZVR5cGUkMyA9IC8qIEBfX1BVUkVfXyAqLyAoKE5vZGVUeXBlMikgPT4ge1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gIHJldHVybiBOb2RlVHlwZTI7XG59KShOb2RlVHlwZSQzIHx8IHt9KTtcbmNvbnN0IHRlc3RhYmxlQWNjZXNzb3JzJDEgPSB7XG4gIE5vZGU6IFtcImNoaWxkTm9kZXNcIiwgXCJwYXJlbnROb2RlXCIsIFwicGFyZW50RWxlbWVudFwiLCBcInRleHRDb250ZW50XCJdLFxuICBTaGFkb3dSb290OiBbXCJob3N0XCIsIFwic3R5bGVTaGVldHNcIl0sXG4gIEVsZW1lbnQ6IFtcInNoYWRvd1Jvb3RcIiwgXCJxdWVyeVNlbGVjdG9yXCIsIFwicXVlcnlTZWxlY3RvckFsbFwiXSxcbiAgTXV0YXRpb25PYnNlcnZlcjogW11cbn07XG5jb25zdCB0ZXN0YWJsZU1ldGhvZHMkMSA9IHtcbiAgTm9kZTogW1wiY29udGFpbnNcIiwgXCJnZXRSb290Tm9kZVwiXSxcbiAgU2hhZG93Um9vdDogW1wiZ2V0U2VsZWN0aW9uXCJdLFxuICBFbGVtZW50OiBbXSxcbiAgTXV0YXRpb25PYnNlcnZlcjogW1wiY29uc3RydWN0b3JcIl1cbn07XG5jb25zdCB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDEgPSB7fTtcbmNvbnN0IGlzQW5ndWxhclpvbmVQcmVzZW50JDEgPSAoKSA9PiB7XG4gIHJldHVybiAhIWdsb2JhbFRoaXMuWm9uZTtcbn07XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpIHtcbiAgaWYgKHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldKVxuICAgIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XTtcbiAgY29uc3QgZGVmYXVsdE9iaiA9IGdsb2JhbFRoaXNba2V5XTtcbiAgY29uc3QgZGVmYXVsdFByb3RvdHlwZSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICBjb25zdCBhY2Nlc3Nvck5hbWVzID0ga2V5IGluIHRlc3RhYmxlQWNjZXNzb3JzJDEgPyB0ZXN0YWJsZUFjY2Vzc29ycyQxW2tleV0gOiB2b2lkIDA7XG4gIGNvbnN0IGlzVW50YWludGVkQWNjZXNzb3JzID0gQm9vbGVhbihcbiAgICBhY2Nlc3Nvck5hbWVzICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgIGFjY2Vzc29yTmFtZXMuZXZlcnkoXG4gICAgICAoYWNjZXNzb3IpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgICAgIChfYiA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRQcm90b3R5cGUsIGFjY2Vzc29yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpLmluY2x1ZGVzKFwiW25hdGl2ZSBjb2RlXVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIClcbiAgKTtcbiAgY29uc3QgbWV0aG9kTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVNZXRob2RzJDEgPyB0ZXN0YWJsZU1ldGhvZHMkMVtrZXldIDogdm9pZCAwO1xuICBjb25zdCBpc1VudGFpbnRlZE1ldGhvZHMgPSBCb29sZWFuKFxuICAgIG1ldGhvZE5hbWVzICYmIG1ldGhvZE5hbWVzLmV2ZXJ5KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgICAgfVxuICAgIClcbiAgKTtcbiAgaWYgKGlzVW50YWludGVkQWNjZXNzb3JzICYmIGlzVW50YWludGVkTWV0aG9kcyAmJiAhaXNBbmd1bGFyWm9uZVByZXNlbnQkMSgpKSB7XG4gICAgdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0gPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBpZnJhbWVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWVFbCk7XG4gICAgY29uc3Qgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICBpZiAoIXdpbikgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIGNvbnN0IHVudGFpbnRlZE9iamVjdCA9IHdpbltrZXldLnByb3RvdHlwZTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZUVsKTtcbiAgICBpZiAoIXVudGFpbnRlZE9iamVjdCkgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldID0gdW50YWludGVkT2JqZWN0O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgfVxufVxuY29uc3QgdW50YWludGVkQWNjZXNzb3JDYWNoZSQxID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKGtleSwgaW5zdGFuY2UsIGFjY2Vzc29yKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7a2V5fS4ke1N0cmluZyhhY2Nlc3Nvcil9YDtcbiAgaWYgKHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0uY2FsbChcbiAgICAgIGluc3RhbmNlXG4gICAgKTtcbiAgY29uc3QgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoa2V5KTtcbiAgY29uc3QgdW50YWludGVkQWNjZXNzb3IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICB1bnRhaW50ZWRQcm90b3R5cGUsXG4gICAgYWNjZXNzb3JcbiAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQ7XG4gIGlmICghdW50YWludGVkQWNjZXNzb3IpIHJldHVybiBpbnN0YW5jZVthY2Nlc3Nvcl07XG4gIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0gPSB1bnRhaW50ZWRBY2Nlc3NvcjtcbiAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yLmNhbGwoaW5zdGFuY2UpO1xufVxuY29uc3QgdW50YWludGVkTWV0aG9kQ2FjaGUkMSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkTWV0aG9kJDEoa2V5LCBpbnN0YW5jZSwgbWV0aG9kKSB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7a2V5fS4ke1N0cmluZyhtZXRob2QpfWA7XG4gIGlmICh1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kQ2FjaGUkMVtjYWNoZUtleV0uYmluZChcbiAgICAgIGluc3RhbmNlXG4gICAgKTtcbiAgY29uc3QgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoa2V5KTtcbiAgY29uc3QgdW50YWludGVkTWV0aG9kID0gdW50YWludGVkUHJvdG90eXBlW21ldGhvZF07XG4gIGlmICh0eXBlb2YgdW50YWludGVkTWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBpbnN0YW5jZVttZXRob2RdO1xuICB1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZC5iaW5kKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNoaWxkTm9kZXMkMShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwiY2hpbGROb2Rlc1wiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUkMShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwicGFyZW50Tm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudEVsZW1lbnQkMShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwicGFyZW50RWxlbWVudFwiKTtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50JDEobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcInRleHRDb250ZW50XCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnMkMShuMiwgb3RoZXIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZCQxKFwiTm9kZVwiLCBuMiwgXCJjb250YWluc1wiKShvdGhlcik7XG59XG5mdW5jdGlvbiBnZXRSb290Tm9kZSQxKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QkMShcIk5vZGVcIiwgbjIsIFwiZ2V0Um9vdE5vZGVcIikoKTtcbn1cbmZ1bmN0aW9uIGhvc3QkMShuMikge1xuICBpZiAoIW4yIHx8ICEoXCJob3N0XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJTaGFkb3dSb290XCIsIG4yLCBcImhvc3RcIik7XG59XG5mdW5jdGlvbiBzdHlsZVNoZWV0cyQxKG4yKSB7XG4gIHJldHVybiBuMi5zdHlsZVNoZWV0cztcbn1cbmZ1bmN0aW9uIHNoYWRvd1Jvb3QkMShuMikge1xuICBpZiAoIW4yIHx8ICEoXCJzaGFkb3dSb290XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInNoYWRvd1Jvb3RcIik7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yJDEobjIsIHNlbGVjdG9ycykge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvclwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbCQxKG4yLCBzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JBbGxcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uT2JzZXJ2ZXJDdG9yJDEoKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShcIk11dGF0aW9uT2JzZXJ2ZXJcIikuY29uc3RydWN0b3I7XG59XG5jb25zdCBpbmRleCQxID0ge1xuICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzJDEsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUkMSxcbiAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudCQxLFxuICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQkMSxcbiAgY29udGFpbnM6IGNvbnRhaW5zJDEsXG4gIGdldFJvb3ROb2RlOiBnZXRSb290Tm9kZSQxLFxuICBob3N0OiBob3N0JDEsXG4gIHN0eWxlU2hlZXRzOiBzdHlsZVNoZWV0cyQxLFxuICBzaGFkb3dSb290OiBzaGFkb3dSb290JDEsXG4gIHF1ZXJ5U2VsZWN0b3I6IHF1ZXJ5U2VsZWN0b3IkMSxcbiAgcXVlcnlTZWxlY3RvckFsbDogcXVlcnlTZWxlY3RvckFsbCQxLFxuICBtdXRhdGlvbk9ic2VydmVyOiBtdXRhdGlvbk9ic2VydmVyQ3RvciQxXG59O1xuZnVuY3Rpb24gaXNFbGVtZW50KG4yKSB7XG4gIHJldHVybiBuMi5ub2RlVHlwZSA9PT0gbjIuRUxFTUVOVF9OT0RFO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG4yKSB7XG4gIGNvbnN0IGhvc3RFbCA9IChcbiAgICAvLyBhbmNob3IgYW5kIHRleHRhcmVhIGVsZW1lbnRzIGFsc28gaGF2ZSBhIGBob3N0YCBwcm9wZXJ0eVxuICAgIC8vIGJ1dCBvbmx5IHNoYWRvdyByb290cyBoYXZlIGEgYG1vZGVgIHByb3BlcnR5XG4gICAgbjIgJiYgXCJob3N0XCIgaW4gbjIgJiYgXCJtb2RlXCIgaW4gbjIgJiYgaW5kZXgkMS5ob3N0KG4yKSB8fCBudWxsXG4gICk7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIGhvc3RFbCAmJiBcInNoYWRvd1Jvb3RcIiBpbiBob3N0RWwgJiYgaW5kZXgkMS5zaGFkb3dSb290KGhvc3RFbCkgPT09IG4yXG4gICk7XG59XG5mdW5jdGlvbiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290Mikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNoYWRvd1Jvb3QyKSA9PT0gXCJbb2JqZWN0IFNoYWRvd1Jvb3RdXCI7XG59XG5mdW5jdGlvbiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKGNzc1RleHQpIHtcbiAgaWYgKGNzc1RleHQuaW5jbHVkZXMoXCIgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSAmJiAhY3NzVGV4dC5pbmNsdWRlcyhcIiAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDtcIikpIHtcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKFxuICAgICAgL1xcc2JhY2tncm91bmQtY2xpcDpcXHMqdGV4dDsvZyxcbiAgICAgIFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuZnVuY3Rpb24gZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUyKSB7XG4gIGNvbnN0IHsgY3NzVGV4dCB9ID0gcnVsZTI7XG4gIGlmIChjc3NUZXh0LnNwbGl0KCdcIicpLmxlbmd0aCA8IDMpIHJldHVybiBjc3NUZXh0O1xuICBjb25zdCBzdGF0ZW1lbnQgPSBbXCJAaW1wb3J0XCIsIGB1cmwoJHtKU09OLnN0cmluZ2lmeShydWxlMi5ocmVmKX0pYF07XG4gIGlmIChydWxlMi5sYXllck5hbWUgPT09IFwiXCIpIHtcbiAgICBzdGF0ZW1lbnQucHVzaChgbGF5ZXJgKTtcbiAgfSBlbHNlIGlmIChydWxlMi5sYXllck5hbWUpIHtcbiAgICBzdGF0ZW1lbnQucHVzaChgbGF5ZXIoJHtydWxlMi5sYXllck5hbWV9KWApO1xuICB9XG4gIGlmIChydWxlMi5zdXBwb3J0c1RleHQpIHtcbiAgICBzdGF0ZW1lbnQucHVzaChgc3VwcG9ydHMoJHtydWxlMi5zdXBwb3J0c1RleHR9KWApO1xuICB9XG4gIGlmIChydWxlMi5tZWRpYS5sZW5ndGgpIHtcbiAgICBzdGF0ZW1lbnQucHVzaChydWxlMi5tZWRpYS5tZWRpYVRleHQpO1xuICB9XG4gIHJldHVybiBzdGF0ZW1lbnQuam9pbihcIiBcIikgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlc2hlZXQoczIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBydWxlczIgPSBzMi5ydWxlcyB8fCBzMi5jc3NSdWxlcztcbiAgICBpZiAoIXJ1bGVzMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBzaGVldEhyZWYgPSBzMi5ocmVmO1xuICAgIGlmICghc2hlZXRIcmVmICYmIHMyLm93bmVyTm9kZSAmJiBzMi5vd25lck5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgc2hlZXRIcmVmID0gczIub3duZXJOb2RlLm93bmVyRG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5naWZpZWRSdWxlcyA9IEFycmF5LmZyb20oXG4gICAgICBydWxlczIsXG4gICAgICAocnVsZTIpID0+IHN0cmluZ2lmeVJ1bGUocnVsZTIsIHNoZWV0SHJlZilcbiAgICApLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1Moc3RyaW5naWZpZWRSdWxlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGUocnVsZTIsIHNoZWV0SHJlZikge1xuICBpZiAoaXNDU1NJbXBvcnRSdWxlKHJ1bGUyKSkge1xuICAgIGxldCBpbXBvcnRTdHJpbmdpZmllZDtcbiAgICB0cnkge1xuICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPSAvLyBmb3Igc2FtZS1vcmlnaW4gc3R5bGVzaGVldHMsXG4gICAgICAvLyB3ZSBjYW4gYWNjZXNzIHRoZSBpbXBvcnRlZCBzdHlsZXNoZWV0IHJ1bGVzIGRpcmVjdGx5XG4gICAgICBzdHJpbmdpZnlTdHlsZXNoZWV0KHJ1bGUyLnN0eWxlU2hlZXQpIHx8IC8vIHdvcmsgYXJvdW5kIGJyb3dzZXIgaXNzdWVzIHdpdGggdGhlIHJhdyBzdHJpbmcgYEBpbXBvcnQgdXJsKC4uLilgIHN0YXRlbWVudFxuICAgICAgZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPSBydWxlMi5jc3NUZXh0O1xuICAgIH1cbiAgICBpZiAocnVsZTIuc3R5bGVTaGVldC5ocmVmKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHMoaW1wb3J0U3RyaW5naWZpZWQsIHJ1bGUyLnN0eWxlU2hlZXQuaHJlZik7XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRTdHJpbmdpZmllZDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcnVsZVN0cmluZ2lmaWVkID0gcnVsZTIuY3NzVGV4dDtcbiAgICBpZiAoaXNDU1NTdHlsZVJ1bGUocnVsZTIpICYmIHJ1bGUyLnNlbGVjdG9yVGV4dC5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgIHJ1bGVTdHJpbmdpZmllZCA9IGZpeFNhZmFyaUNvbG9ucyhydWxlU3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBpZiAoc2hlZXRIcmVmKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHMocnVsZVN0cmluZ2lmaWVkLCBzaGVldEhyZWYpO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZVN0cmluZ2lmaWVkO1xuICB9XG59XG5mdW5jdGlvbiBmaXhTYWZhcmlDb2xvbnMoY3NzU3RyaW5naWZpZWQpIHtcbiAgY29uc3QgcmVnZXggPSAvKFxcWyg/OltcXHctXSspW15cXFxcXSkoOig/OltcXHctXSspXFxdKS9nbTtcbiAgcmV0dXJuIGNzc1N0cmluZ2lmaWVkLnJlcGxhY2UocmVnZXgsIFwiJDFcXFxcJDJcIik7XG59XG5mdW5jdGlvbiBpc0NTU0ltcG9ydFJ1bGUocnVsZTIpIHtcbiAgcmV0dXJuIFwic3R5bGVTaGVldFwiIGluIHJ1bGUyO1xufVxuZnVuY3Rpb24gaXNDU1NTdHlsZVJ1bGUocnVsZTIpIHtcbiAgcmV0dXJuIFwic2VsZWN0b3JUZXh0XCIgaW4gcnVsZTI7XG59XG5jbGFzcyBNaXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpZE5vZGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibm9kZU1ldGFNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICB9XG4gIGdldElkKG4yKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoIW4yKSByZXR1cm4gLTE7XG4gICAgY29uc3QgaWQgPSAoX2EyID0gdGhpcy5nZXRNZXRhKG4yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pZDtcbiAgICByZXR1cm4gaWQgPz8gLTE7XG4gIH1cbiAgZ2V0Tm9kZShpZCkge1xuICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0SWRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaWROb2RlTWFwLmtleXMoKSk7XG4gIH1cbiAgZ2V0TWV0YShuMikge1xuICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmdldChuMikgfHwgbnVsbDtcbiAgfVxuICAvLyByZW1vdmVzIHRoZSBub2RlIGZyb20gaWROb2RlTWFwXG4gIC8vIGRvZXNuJ3QgcmVtb3ZlIHRoZSBub2RlIGZyb20gbm9kZU1ldGFNYXBcbiAgcmVtb3ZlTm9kZUZyb21NYXAobjIpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0SWQobjIpO1xuICAgIHRoaXMuaWROb2RlTWFwLmRlbGV0ZShpZCk7XG4gICAgaWYgKG4yLmNoaWxkTm9kZXMpIHtcbiAgICAgIG4yLmNoaWxkTm9kZXMuZm9yRWFjaChcbiAgICAgICAgKGNoaWxkTm9kZSkgPT4gdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZE5vZGUpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBoYXMoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuaGFzKGlkKTtcbiAgfVxuICBoYXNOb2RlKG5vZGUyKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuaGFzKG5vZGUyKTtcbiAgfVxuICBhZGQobjIsIG1ldGEpIHtcbiAgICBjb25zdCBpZCA9IG1ldGEuaWQ7XG4gICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobjIsIG1ldGEpO1xuICB9XG4gIHJlcGxhY2UoaWQsIG4yKSB7XG4gICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgaWYgKG9sZE5vZGUpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLm5vZGVNZXRhTWFwLmdldChvbGROb2RlKTtcbiAgICAgIGlmIChtZXRhKSB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbjIpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaWROb2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm5vZGVNZXRhTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pcnJvciQyKCkge1xuICByZXR1cm4gbmV3IE1pcnJvcigpO1xufVxuZnVuY3Rpb24gbWFza0lucHV0VmFsdWUoe1xuICBlbGVtZW50LFxuICBtYXNrSW5wdXRPcHRpb25zLFxuICB0YWdOYW1lLFxuICB0eXBlLFxuICB2YWx1ZSxcbiAgbWFza0lucHV0Rm5cbn0pIHtcbiAgbGV0IHRleHQgPSB2YWx1ZSB8fCBcIlwiO1xuICBjb25zdCBhY3R1YWxUeXBlID0gdHlwZSAmJiB0b0xvd2VyQ2FzZSh0eXBlKTtcbiAgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBhY3R1YWxUeXBlICYmIG1hc2tJbnB1dE9wdGlvbnNbYWN0dWFsVHlwZV0pIHtcbiAgICBpZiAobWFza0lucHV0Rm4pIHtcbiAgICAgIHRleHQgPSBtYXNrSW5wdXRGbih0ZXh0LCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dCA9IFwiKlwiLnJlcGVhdCh0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gdG9Mb3dlckNhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbn1cbmNvbnN0IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FID0gXCJfX3Jyd2ViX29yaWdpbmFsX19cIjtcbmZ1bmN0aW9uIGlzMkRDYW52YXNCbGFuayhjYW52YXMpIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHJldHVybiB0cnVlO1xuICBjb25zdCBjaHVua1NpemUgPSA1MDtcbiAgZm9yIChsZXQgeDIgPSAwOyB4MiA8IGNhbnZhcy53aWR0aDsgeDIgKz0gY2h1bmtTaXplKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IGNodW5rU2l6ZSkge1xuICAgICAgY29uc3QgZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhID8gZ2V0SW1hZ2VEYXRhW09SSUdJTkFMX0FUVFJJQlVURV9OQU1FXSA6IGdldEltYWdlRGF0YTtcbiAgICAgIGNvbnN0IHBpeGVsQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIG9yaWdpbmFsR2V0SW1hZ2VEYXRhLmNhbGwoXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHgyLFxuICAgICAgICAgIHksXG4gICAgICAgICAgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMud2lkdGggLSB4MiksXG4gICAgICAgICAgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSlcbiAgICAgICAgKS5kYXRhLmJ1ZmZlclxuICAgICAgKTtcbiAgICAgIGlmIChwaXhlbEJ1ZmZlci5zb21lKChwaXhlbCkgPT4gcGl4ZWwgIT09IDApKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKGVsZW1lbnQpIHtcbiAgY29uc3QgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiKSA/IFwicGFzc3dvcmRcIiA6IHR5cGUgPyAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgIHRvTG93ZXJDYXNlKHR5cGUpXG4gICkgOiBudWxsO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVFeHRlbnNpb24ocGF0aCwgYmFzZVVSTCkge1xuICBsZXQgdXJsO1xuICB0cnkge1xuICAgIHVybCA9IG5ldyBVUkwocGF0aCwgYmFzZVVSTCA/PyB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlZ2V4ID0gL1xcLihbMC05YS16XSspKD86JCkvaTtcbiAgY29uc3QgbWF0Y2ggPSB1cmwucGF0aG5hbWUubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gKG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFsxXSkgPz8gbnVsbDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPcmlnaW4odXJsKSB7XG4gIGxldCBvcmlnaW4gPSBcIlwiO1xuICBpZiAodXJsLmluZGV4T2YoXCIvL1wiKSA+IC0xKSB7XG4gICAgb3JpZ2luID0gdXJsLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAzKS5qb2luKFwiL1wiKTtcbiAgfSBlbHNlIHtcbiAgICBvcmlnaW4gPSB1cmwuc3BsaXQoXCIvXCIpWzBdO1xuICB9XG4gIG9yaWdpbiA9IG9yaWdpbi5zcGxpdChcIj9cIilbMF07XG4gIHJldHVybiBvcmlnaW47XG59XG5jb25zdCBVUkxfSU5fQ1NTX1JFRiA9IC91cmxcXCgoPzooJykoW14nXSopJ3woXCIpKC4qPylcInwoW14pXSopKVxcKS9nbTtcbmNvbnN0IFVSTF9QUk9UT0NPTF9NQVRDSCA9IC9eKD86W2EteitdKzopP1xcL1xcLy9pO1xuY29uc3QgVVJMX1dXV19NQVRDSCA9IC9ed3d3XFwuLiovaTtcbmNvbnN0IERBVEFfVVJJID0gL14oZGF0YTopKFteLF0qKSwoLiopL2k7XG5mdW5jdGlvbiBhYnNvbHV0aWZ5VVJMcyhjc3NUZXh0LCBocmVmKSB7XG4gIHJldHVybiAoY3NzVGV4dCB8fCBcIlwiKS5yZXBsYWNlKFxuICAgIFVSTF9JTl9DU1NfUkVGLFxuICAgIChvcmlnaW4sIHF1b3RlMSwgcGF0aDEsIHF1b3RlMiwgcGF0aDIsIHBhdGgzKSA9PiB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgxIHx8IHBhdGgyIHx8IHBhdGgzO1xuICAgICAgY29uc3QgbWF5YmVRdW90ZSA9IHF1b3RlMSB8fCBxdW90ZTIgfHwgXCJcIjtcbiAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChVUkxfUFJPVE9DT0xfTUFUQ0gudGVzdChmaWxlUGF0aCkgfHwgVVJMX1dXV19NQVRDSC50ZXN0KGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XG4gICAgICB9XG4gICAgICBpZiAoREFUQV9VUkkudGVzdChmaWxlUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtleHRyYWN0T3JpZ2luKGhyZWYpICsgZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhY2sgPSBocmVmLnNwbGl0KFwiL1wiKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gZmlsZVBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IFwiLlwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7c3RhY2suam9pbihcIi9cIil9JHttYXliZVF1b3RlfSlgO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoLyhcXC9cXCpbXipdKlxcKlxcLyl8W1xccztdL2csIFwiXCIpO1xufVxuZnVuY3Rpb24gc3BsaXRDc3NUZXh0KGNzc1RleHQsIHN0eWxlKSB7XG4gIGNvbnN0IGNoaWxkTm9kZXMyID0gQXJyYXkuZnJvbShzdHlsZS5jaGlsZE5vZGVzKTtcbiAgY29uc3Qgc3BsaXRzID0gW107XG4gIGlmIChjaGlsZE5vZGVzMi5sZW5ndGggPiAxICYmIGNzc1RleHQgJiYgdHlwZW9mIGNzc1RleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBjc3NUZXh0Tm9ybSA9IG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0KTtcbiAgICBmb3IgKGxldCBpMiA9IDE7IGkyIDwgY2hpbGROb2RlczIubGVuZ3RoOyBpMisrKSB7XG4gICAgICBpZiAoY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50ICYmIHR5cGVvZiBjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgdGV4dENvbnRlbnROb3JtID0gbm9ybWFsaXplQ3NzU3RyaW5nKGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCk7XG4gICAgICAgIGZvciAobGV0IGogPSAzOyBqIDwgdGV4dENvbnRlbnROb3JtLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYml0ID0gdGV4dENvbnRlbnROb3JtLnN1YnN0cmluZygwLCBqKTtcbiAgICAgICAgICBpZiAoY3NzVGV4dE5vcm0uc3BsaXQoYml0KS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0Tm9ybSA9IGNzc1RleHROb3JtLmluZGV4T2YoYml0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBzcGxpdE5vcm07IGsgPCBjc3NUZXh0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChub3JtYWxpemVDc3NTdHJpbmcoY3NzVGV4dC5zdWJzdHJpbmcoMCwgaykpLmxlbmd0aCA9PT0gc3BsaXROb3JtKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRzLnB1c2goY3NzVGV4dC5zdWJzdHJpbmcoMCwgaykpO1xuICAgICAgICAgICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnN1YnN0cmluZyhrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNwbGl0cy5wdXNoKGNzc1RleHQpO1xuICByZXR1cm4gc3BsaXRzO1xufVxuZnVuY3Rpb24gbWFya0Nzc1NwbGl0cyhjc3NUZXh0LCBzdHlsZSkge1xuICByZXR1cm4gc3BsaXRDc3NUZXh0KGNzc1RleHQsIHN0eWxlKS5qb2luKFwiLyogcnJfc3BsaXQgKi9cIik7XG59XG5sZXQgX2lkID0gMTtcbmNvbnN0IHRhZ05hbWVSZWdleCA9IG5ldyBSZWdFeHAoXCJbXmEtejAtOS1fOl1cIik7XG5jb25zdCBJR05PUkVEX05PREUgPSAtMjtcbmZ1bmN0aW9uIGdlbklkKCkge1xuICByZXR1cm4gX2lkKys7XG59XG5mdW5jdGlvbiBnZXRWYWxpZFRhZ05hbWUkMShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSB7XG4gICAgcmV0dXJuIFwiZm9ybVwiO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NlZFRhZ05hbWUgPSB0b0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICBpZiAodGFnTmFtZVJlZ2V4LnRlc3QocHJvY2Vzc2VkVGFnTmFtZSkpIHtcbiAgICByZXR1cm4gXCJkaXZcIjtcbiAgfVxuICByZXR1cm4gcHJvY2Vzc2VkVGFnTmFtZTtcbn1cbmxldCBjYW52YXNTZXJ2aWNlO1xubGV0IGNhbnZhc0N0eDtcbmNvbnN0IFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xuY29uc3QgU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMgPSAvXlssIFxcdFxcblxcclxcdTAwMGNdKy87XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gIGlmIChhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gIH1cbiAgbGV0IHBvcyA9IDA7XG4gIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XG4gICAgbGV0IGNoYXJzMjtcbiAgICBjb25zdCBtYXRjaCA9IHJlZ0V4LmV4ZWMoYXR0cmlidXRlVmFsdWUuc3Vic3RyaW5nKHBvcykpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY2hhcnMyID0gbWF0Y2hbMF07XG4gICAgICBwb3MgKz0gY2hhcnMyLmxlbmd0aDtcbiAgICAgIHJldHVybiBjaGFyczI7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTKTtcbiAgICBpZiAocG9zID49IGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCB1cmwgPSBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfTk9UX1NQQUNFUyk7XG4gICAgaWYgKHVybC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSkpO1xuICAgICAgb3V0cHV0LnB1c2godXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlc2NyaXB0b3JzU3RyID0gXCJcIjtcbiAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwpO1xuICAgICAgbGV0IGluUGFyZW5zID0gZmFsc2U7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBjMiA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xuICAgICAgICBpZiAoYzIgPT09IFwiXCIpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoIWluUGFyZW5zKSB7XG4gICAgICAgICAgaWYgKGMyID09PSBcIixcIikge1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMyID09PSBcIihcIikge1xuICAgICAgICAgICAgaW5QYXJlbnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYzIgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICBpblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yc1N0ciArPSBjMjtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbihcIiwgXCIpO1xufVxuY29uc3QgY2FjaGVkRG9jdW1lbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gZ2V0SHJlZihkb2MsIGF0dHJpYnV0ZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbCkge1xuICByZXR1cm4gQm9vbGVhbihlbC50YWdOYW1lID09PSBcInN2Z1wiIHx8IGVsLm93bmVyU1ZHRWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXRIcmVmKGRvYywgY3VzdG9tSHJlZikge1xuICBsZXQgYTIgPSBjYWNoZWREb2N1bWVudC5nZXQoZG9jKTtcbiAgaWYgKCFhMikge1xuICAgIGEyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGNhY2hlZERvY3VtZW50LnNldChkb2MsIGEyKTtcbiAgfVxuICBpZiAoIWN1c3RvbUhyZWYpIHtcbiAgICBjdXN0b21IcmVmID0gXCJcIjtcbiAgfSBlbHNlIGlmIChjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSB8fCBjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiBjdXN0b21IcmVmO1xuICB9XG4gIGEyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgY3VzdG9tSHJlZik7XG4gIHJldHVybiBhMi5ocmVmO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAobmFtZSA9PT0gXCJzcmNcIiB8fCBuYW1lID09PSBcImhyZWZcIiAmJiAhKHRhZ05hbWUgPT09IFwidXNlXCIgJiYgdmFsdWVbMF0gPT09IFwiI1wiKSkge1xuICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwieGxpbms6aHJlZlwiICYmIHZhbHVlWzBdICE9PSBcIiNcIikge1xuICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiYmFja2dyb3VuZFwiICYmICh0YWdOYW1lID09PSBcInRhYmxlXCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZFwiIHx8IHRhZ05hbWUgPT09IFwidGhcIikpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcInNyY3NldFwiKSB7XG4gICAgcmV0dXJuIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyh2YWx1ZSwgZ2V0SHJlZihkb2MpKTtcbiAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBcIm9iamVjdFwiICYmIG5hbWUgPT09IFwiZGF0YVwiKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIG5hbWUsIF92YWx1ZSkge1xuICByZXR1cm4gKHRhZ05hbWUgPT09IFwidmlkZW9cIiB8fCB0YWdOYW1lID09PSBcImF1ZGlvXCIpICYmIG5hbWUgPT09IFwiYXV0b3BsYXlcIjtcbn1cbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZUluZGV4ID0gZWxlbWVudC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTsgKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgICAgIGlmIChibG9ja0NsYXNzLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpO1xuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbGFzc01hdGNoZXNSZWdleChub2RlMiwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKSB7XG4gIGlmICghbm9kZTIpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUyLm5vZGVUeXBlICE9PSBub2RlMi5FTEVNRU5UX05PREUpIHtcbiAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KGluZGV4JDEucGFyZW50Tm9kZShub2RlMiksIHJlZ2V4LCBjaGVja0FuY2VzdG9ycyk7XG4gIH1cbiAgZm9yIChsZXQgZUluZGV4ID0gbm9kZTIuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07ICkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IG5vZGUyLmNsYXNzTGlzdFtlSW5kZXhdO1xuICAgIGlmIChyZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIWNoZWNrQW5jZXN0b3JzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBjbGFzc01hdGNoZXNSZWdleChpbmRleCQxLnBhcmVudE5vZGUobm9kZTIpLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpO1xufVxuZnVuY3Rpb24gbmVlZE1hc2tpbmdUZXh0KG5vZGUyLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xuICBsZXQgZWw7XG4gIGlmIChpc0VsZW1lbnQobm9kZTIpKSB7XG4gICAgZWwgPSBub2RlMjtcbiAgICBpZiAoIWluZGV4JDEuY2hpbGROb2RlcyhlbCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGluZGV4JDEucGFyZW50RWxlbWVudChub2RlMikgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZWwgPSBpbmRleCQxLnBhcmVudEVsZW1lbnQobm9kZTIpO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBtYXNrVGV4dENsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcbiAgICAgICAgaWYgKGVsLmNsb3Nlc3QoYC4ke21hc2tUZXh0Q2xhc3N9YCkpIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhtYXNrVGV4dENsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgbWFza1RleHRDbGFzcywgY2hlY2tBbmNlc3RvcnMpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hc2tUZXh0U2VsZWN0b3IpIHtcbiAgICAgIGlmIChjaGVja0FuY2VzdG9ycykge1xuICAgICAgICBpZiAoZWwuY2xvc2VzdChtYXNrVGV4dFNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwubWF0Y2hlcyhtYXNrVGV4dFNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlMikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uY2VJZnJhbWVMb2FkZWQoaWZyYW1lRWwsIGxpc3RlbmVyLCBpZnJhbWVMb2FkVGltZW91dCkge1xuICBjb25zdCB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICBpZiAoIXdpbikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZmlyZWQgPSBmYWxzZTtcbiAgbGV0IHJlYWR5U3RhdGU7XG4gIHRyeSB7XG4gICAgcmVhZHlTdGF0ZSA9IHdpbi5kb2N1bWVudC5yZWFkeVN0YXRlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVhZHlTdGF0ZSAhPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghZmlyZWQpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYmxhbmtVcmwgPSBcImFib3V0OmJsYW5rXCI7XG4gIGlmICh3aW4ubG9jYXRpb24uaHJlZiAhPT0gYmxhbmtVcmwgfHwgaWZyYW1lRWwuc3JjID09PSBibGFua1VybCB8fCBpZnJhbWVFbC5zcmMgPT09IFwiXCIpIHtcbiAgICBzZXRUaW1lb3V0KGxpc3RlbmVyLCAwKTtcbiAgICByZXR1cm4gaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGlzdGVuZXIpO1xuICB9XG4gIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIG9uY2VTdHlsZXNoZWV0TG9hZGVkKGxpbmssIGxpc3RlbmVyLCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpIHtcbiAgbGV0IGZpcmVkID0gZmFsc2U7XG4gIGxldCBzdHlsZVNoZWV0TG9hZGVkO1xuICB0cnkge1xuICAgIHN0eWxlU2hlZXRMb2FkZWQgPSBsaW5rLnNoZWV0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3R5bGVTaGVldExvYWRlZCkgcmV0dXJuO1xuICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgfVxuICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xuICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIGZpcmVkID0gdHJ1ZTtcbiAgICBsaXN0ZW5lcigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIG5lZWRzTWFzayxcbiAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSxcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIGRhdGFVUkxPcHRpb25zID0ge30sXG4gICAgaW5saW5lSW1hZ2VzLFxuICAgIHJlY29yZENhbnZhcyxcbiAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSxcbiAgICBjc3NDYXB0dXJlZCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IyKTtcbiAgc3dpdGNoIChuMi5ub2RlVHlwZSkge1xuICAgIGNhc2UgbjIuRE9DVU1FTlRfTk9ERTpcbiAgICAgIGlmIChuMi5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgY29tcGF0TW9kZTogbjIuY29tcGF0TW9kZVxuICAgICAgICAgIC8vIHByb2JhYmx5IFwiQmFja0NvbXBhdFwiXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGROb2RlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIG4yLkRPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRG9jdW1lbnRUeXBlLFxuICAgICAgICBuYW1lOiBuMi5uYW1lLFxuICAgICAgICBwdWJsaWNJZDogbjIucHVibGljSWQsXG4gICAgICAgIHN5c3RlbUlkOiBuMi5zeXN0ZW1JZCxcbiAgICAgICAgcm9vdElkXG4gICAgICB9O1xuICAgIGNhc2UgbjIuRUxFTUVOVF9OT0RFOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICBuZXdseUFkZGVkRWxlbWVudCxcbiAgICAgICAgcm9vdElkXG4gICAgICB9KTtcbiAgICBjYXNlIG4yLlRFWFRfTk9ERTpcbiAgICAgIHJldHVybiBzZXJpYWxpemVUZXh0Tm9kZShuMiwge1xuICAgICAgICBkb2MsXG4gICAgICAgIG5lZWRzTWFzayxcbiAgICAgICAgbWFza1RleHRGbixcbiAgICAgICAgcm9vdElkLFxuICAgICAgICBjc3NDYXB0dXJlZFxuICAgICAgfSk7XG4gICAgY2FzZSBuMi5DREFUQV9TRUNUSU9OX05PREU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkNEQVRBLFxuICAgICAgICB0ZXh0Q29udGVudDogXCJcIixcbiAgICAgICAgcm9vdElkXG4gICAgICB9O1xuICAgIGNhc2UgbjIuQ09NTUVOVF9OT0RFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Db21tZW50LFxuICAgICAgICB0ZXh0Q29udGVudDogaW5kZXgkMS50ZXh0Q29udGVudChuMikgfHwgXCJcIixcbiAgICAgICAgcm9vdElkXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJvb3RJZChkb2MsIG1pcnJvcjIpIHtcbiAgaWYgKCFtaXJyb3IyLmhhc05vZGUoZG9jKSkgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgZG9jSWQgPSBtaXJyb3IyLmdldElkKGRvYyk7XG4gIHJldHVybiBkb2NJZCA9PT0gMSA/IHZvaWQgMCA6IGRvY0lkO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVGV4dE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBuZWVkc01hc2ssIG1hc2tUZXh0Rm4sIHJvb3RJZCwgY3NzQ2FwdHVyZWQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBhcmVudCA9IGluZGV4JDEucGFyZW50Tm9kZShuMik7XG4gIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWU7XG4gIGxldCB0ZXh0Q29udGVudDIgPSBcIlwiO1xuICBjb25zdCBpc1N0eWxlID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTVFlMRVwiID8gdHJ1ZSA6IHZvaWQgMDtcbiAgY29uc3QgaXNTY3JpcHQgPSBwYXJlbnRUYWdOYW1lID09PSBcIlNDUklQVFwiID8gdHJ1ZSA6IHZvaWQgMDtcbiAgaWYgKGlzU2NyaXB0KSB7XG4gICAgdGV4dENvbnRlbnQyID0gXCJTQ1JJUFRfUExBQ0VIT0xERVJcIjtcbiAgfSBlbHNlIGlmICghY3NzQ2FwdHVyZWQpIHtcbiAgICB0ZXh0Q29udGVudDIgPSBpbmRleCQxLnRleHRDb250ZW50KG4yKTtcbiAgICBpZiAoaXNTdHlsZSAmJiB0ZXh0Q29udGVudDIpIHtcbiAgICAgIHRleHRDb250ZW50MiA9IGFic29sdXRpZnlVUkxzKHRleHRDb250ZW50MiwgZ2V0SHJlZihvcHRpb25zLmRvYykpO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmIHRleHRDb250ZW50MiAmJiBuZWVkc01hc2spIHtcbiAgICB0ZXh0Q29udGVudDIgPSBtYXNrVGV4dEZuID8gbWFza1RleHRGbih0ZXh0Q29udGVudDIsIGluZGV4JDEucGFyZW50RWxlbWVudChuMikpIDogdGV4dENvbnRlbnQyLnJlcGxhY2UoL1tcXFNdL2csIFwiKlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IE5vZGVUeXBlJDMuVGV4dCxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQyIHx8IFwiXCIsXG4gICAgcm9vdElkXG4gIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFbGVtZW50Tm9kZShuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZG9jLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSxcbiAgICBtYXNrSW5wdXRGbixcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsXG4gICAgcm9vdElkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XG4gIGNvbnN0IHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUkMShuMik7XG4gIGxldCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IGxlbiA9IG4yLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbGVuOyBpMisrKSB7XG4gICAgY29uc3QgYXR0ciA9IG4yLmF0dHJpYnV0ZXNbaTJdO1xuICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0ci5uYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShcbiAgICAgICAgZG9jLFxuICAgICAgICB0YWdOYW1lLFxuICAgICAgICB0b0xvd2VyQ2FzZShhdHRyLm5hbWUpLFxuICAgICAgICBhdHRyLnZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgaW5saW5lU3R5bGVzaGVldCkge1xuICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmluZCgoczIpID0+IHtcbiAgICAgIHJldHVybiBzMi5ocmVmID09PSBuMi5ocmVmO1xuICAgIH0pO1xuICAgIGxldCBjc3NUZXh0ID0gbnVsbDtcbiAgICBpZiAoc3R5bGVzaGVldCkge1xuICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XG4gICAgfVxuICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5yZWw7XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5ocmVmO1xuICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcInN0eWxlXCIgJiYgbjIuc2hlZXQpIHtcbiAgICBsZXQgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoXG4gICAgICBuMi5zaGVldFxuICAgICk7XG4gICAgaWYgKGNzc1RleHQpIHtcbiAgICAgIGlmIChuMi5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY3NzVGV4dCA9IG1hcmtDc3NTcGxpdHMoY3NzVGV4dCwgbjIpO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImlucHV0XCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IHRhZ05hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG4yLnZhbHVlO1xuICAgIGNvbnN0IGNoZWNrZWQgPSBuMi5jaGVja2VkO1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgIT09IFwicmFkaW9cIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwiY2hlY2tib3hcIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwic3VibWl0XCIgJiYgYXR0cmlidXRlcy50eXBlICE9PSBcImJ1dHRvblwiICYmIHZhbHVlKSB7XG4gICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICBlbGVtZW50OiBuMixcbiAgICAgICAgdHlwZTogZ2V0SW5wdXRUeXBlKG4yKSxcbiAgICAgICAgdGFnTmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIG1hc2tJbnB1dEZuXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNoZWNrZWQpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcIm9wdGlvblwiKSB7XG4gICAgaWYgKG4yLnNlbGVjdGVkICYmICFtYXNrSW5wdXRPcHRpb25zW1wic2VsZWN0XCJdKSB7XG4gICAgICBhdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImRpYWxvZ1wiICYmIG4yLm9wZW4pIHtcbiAgICBhdHRyaWJ1dGVzLnJyX29wZW5fbW9kZSA9IG4yLm1hdGNoZXMoXCJkaWFsb2c6bW9kYWxcIikgPyBcIm1vZGFsXCIgOiBcIm5vbi1tb2RhbFwiO1xuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImNhbnZhc1wiICYmIHJlY29yZENhbnZhcykge1xuICAgIGlmIChuMi5fX2NvbnRleHQgPT09IFwiMmRcIikge1xuICAgICAgaWYgKCFpczJEQ2FudmFzQmxhbmsobjIpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IG4yLnRvRGF0YVVSTChcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy50eXBlLFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXCJfX2NvbnRleHRcIiBpbiBuMikpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0RhdGFVUkwgPSBuMi50b0RhdGFVUkwoXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICk7XG4gICAgICBjb25zdCBibGFua0NhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuMi53aWR0aDtcbiAgICAgIGJsYW5rQ2FudmFzLmhlaWdodCA9IG4yLmhlaWdodDtcbiAgICAgIGNvbnN0IGJsYW5rQ2FudmFzRGF0YVVSTCA9IGJsYW5rQ2FudmFzLnRvRGF0YVVSTChcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMucXVhbGl0eVxuICAgICAgKTtcbiAgICAgIGlmIChjYW52YXNEYXRhVVJMICE9PSBibGFua0NhbnZhc0RhdGFVUkwpIHtcbiAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzRGF0YVVSTDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiaW1nXCIgJiYgaW5saW5lSW1hZ2VzKSB7XG4gICAgaWYgKCFjYW52YXNTZXJ2aWNlKSB7XG4gICAgICBjYW52YXNTZXJ2aWNlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjYW52YXNDdHggPSBjYW52YXNTZXJ2aWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2UgPSBuMjtcbiAgICBjb25zdCBpbWFnZVNyYyA9IGltYWdlLmN1cnJlbnRTcmMgfHwgaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpIHx8IFwiPHVua25vd24tc3JjPlwiO1xuICAgIGNvbnN0IHByaW9yQ3Jvc3NPcmlnaW4gPSBpbWFnZS5jcm9zc09yaWdpbjtcbiAgICBjb25zdCByZWNvcmRJbmxpbmVJbWFnZSA9ICgpID0+IHtcbiAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbnZhc1NlcnZpY2Uud2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIGNhbnZhc1NlcnZpY2UuaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgY2FudmFzQ3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc1NlcnZpY2UudG9EYXRhVVJMKFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMucXVhbGl0eVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChpbWFnZS5jcm9zc09yaWdpbiAhPT0gXCJhbm9ueW1vdXNcIikge1xuICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKVxuICAgICAgICAgICAgcmVjb3JkSW5saW5lSW1hZ2UoKTtcbiAgICAgICAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYENhbm5vdCBpbmxpbmUgaW1nIHNyYz0ke2ltYWdlU3JjfSEgRXJyb3I6ICR7ZXJyfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UuY3Jvc3NPcmlnaW4gPT09IFwiYW5vbnltb3VzXCIpIHtcbiAgICAgICAgcHJpb3JDcm9zc09yaWdpbiA/IGF0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4gPSBwcmlvckNyb3NzT3JpZ2luIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKSByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImF1ZGlvXCIgfHwgdGFnTmFtZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgY29uc3QgbWVkaWFBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFTdGF0ZSA9IG4yLnBhdXNlZCA/IFwicGF1c2VkXCIgOiBcInBsYXllZFwiO1xuICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUN1cnJlbnRUaW1lID0gbjIuY3VycmVudFRpbWU7XG4gICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhUGxheWJhY2tSYXRlID0gbjIucGxheWJhY2tSYXRlO1xuICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYU11dGVkID0gbjIubXV0ZWQ7XG4gICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTG9vcCA9IG4yLmxvb3A7XG4gICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhVm9sdW1lID0gbjIudm9sdW1lO1xuICB9XG4gIGlmICghbmV3bHlBZGRlZEVsZW1lbnQpIHtcbiAgICBpZiAobjIuc2Nyb2xsTGVmdCkge1xuICAgICAgYXR0cmlidXRlcy5ycl9zY3JvbGxMZWZ0ID0gbjIuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgaWYgKG4yLnNjcm9sbFRvcCkge1xuICAgICAgYXR0cmlidXRlcy5ycl9zY3JvbGxUb3AgPSBuMi5zY3JvbGxUb3A7XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQmxvY2spIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG4yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGF0dHJpYnV0ZXMgPSB7XG4gICAgICBjbGFzczogYXR0cmlidXRlcy5jbGFzcyxcbiAgICAgIHJyX3dpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgICBycl9oZWlnaHQ6IGAke2hlaWdodH1weGBcbiAgICB9O1xuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImlmcmFtZVwiICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlcy5zcmMpKSB7XG4gICAgaWYgKCFuMi5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgIGF0dHJpYnV0ZXMucnJfc3JjID0gYXR0cmlidXRlcy5zcmM7XG4gICAgfVxuICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNyYztcbiAgfVxuICBsZXQgaXNDdXN0b21FbGVtZW50O1xuICB0cnkge1xuICAgIGlmIChjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIGlzQ3VzdG9tRWxlbWVudCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBOb2RlVHlwZSQzLkVsZW1lbnQsXG4gICAgdGFnTmFtZSxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgIGlzU1ZHOiBpc1NWR0VsZW1lbnQobjIpIHx8IHZvaWQgMCxcbiAgICBuZWVkQmxvY2ssXG4gICAgcm9vdElkLFxuICAgIGlzQ3VzdG9tOiBpc0N1c3RvbUVsZW1lbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvd2VySWZFeGlzdHMobWF5YmVBdHRyKSB7XG4gIGlmIChtYXliZUF0dHIgPT09IHZvaWQgMCB8fCBtYXliZUF0dHIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF5YmVBdHRyLnRvTG93ZXJDYXNlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNsaW1ET01FeGNsdWRlZChzbiwgc2xpbURPTU9wdGlvbnMpIHtcbiAgaWYgKHNsaW1ET01PcHRpb25zLmNvbW1lbnQgJiYgc24udHlwZSA9PT0gTm9kZVR5cGUkMy5Db21tZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoc24udHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSB7XG4gICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJiAvLyBzY3JpcHQgdGFnXG4gICAgKHNuLnRhZ05hbWUgPT09IFwic2NyaXB0XCIgfHwgLy8gKG1vZHVsZSlwcmVsb2FkIGxpbmtcbiAgICBzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiAoc24uYXR0cmlidXRlcy5yZWwgPT09IFwicHJlbG9hZFwiIHx8IHNuLmF0dHJpYnV0ZXMucmVsID09PSBcIm1vZHVsZXByZWxvYWRcIikgJiYgc24uYXR0cmlidXRlcy5hcyA9PT0gXCJzY3JpcHRcIiB8fCAvLyBwcmVmZXRjaCBsaW5rXG4gICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwicHJlZmV0Y2hcIiAmJiB0eXBlb2Ygc24uYXR0cmlidXRlcy5ocmVmID09PSBcInN0cmluZ1wiICYmIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNuLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwianNcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZEZhdmljb24gJiYgKHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInNob3J0Y3V0IGljb25cIiB8fCBzbi50YWdOYW1lID09PSBcIm1ldGFcIiAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKFxuICAgICAgL15tc2FwcGxpY2F0aW9uLXRpbGUoaW1hZ2V8Y29sb3IpJC9cbiAgICApIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJhcHBsaWNhdGlvbi1uYW1lXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcImFwcGxlLXRvdWNoLWljb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJzaG9ydGN1dCBpY29uXCIpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzbi50YWdOYW1lID09PSBcIm1ldGFcIikge1xuICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhRGVzY0tleXdvcmRzICYmIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVNvY2lhbCAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXihvZ3x0d2l0dGVyfGZiKTovKSB8fCAvLyBvZyA9IG9wZW5ncmFwaCAoZmFjZWJvb2spXG4gICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL14ob2d8dHdpdHRlcik6LykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInBpbnRlcmVzdFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFSb2JvdHMgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJyb2JvdHNcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ29vZ2xlYm90XCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImJpbmdib3RcIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhSHR0cEVxdWl2ICYmIHNuLmF0dHJpYnV0ZXNbXCJodHRwLWVxdWl2XCJdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhQXV0aG9yc2hpcCAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImF1dGhvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnZW5lcmF0b3JcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZnJhbWV3b3JrXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInB1Ymxpc2hlclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwcm9naWRcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eYXJ0aWNsZTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9ecHJvZHVjdDovKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhVmVyaWZpY2F0aW9uICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInlhbmRleC12ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiY3NyZi10b2tlblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwOmRvbWFpbl92ZXJpZnlcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwidmVyaWZ5LXYxXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJzaG9waWZ5LWNoZWNrb3V0LWFwaS10b2tlblwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZG9jLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgbWFza1RleHRDbGFzcyxcbiAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgIHNraXBDaGlsZCA9IGZhbHNlLFxuICAgIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLFxuICAgIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSxcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHNsaW1ET01PcHRpb25zLFxuICAgIGRhdGFVUkxPcHRpb25zID0ge30sXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcmVjb3JkQ2FudmFzID0gZmFsc2UsXG4gICAgb25TZXJpYWxpemUsXG4gICAgb25JZnJhbWVMb2FkLFxuICAgIGlmcmFtZUxvYWRUaW1lb3V0ID0gNWUzLFxuICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gNWUzLFxuICAgIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsXG4gICAgY3NzQ2FwdHVyZWQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHsgbmVlZHNNYXNrIH0gPSBvcHRpb25zO1xuICBsZXQgeyBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBpZiAoIW5lZWRzTWFzaykge1xuICAgIGNvbnN0IGNoZWNrQW5jZXN0b3JzID0gbmVlZHNNYXNrID09PSB2b2lkIDA7XG4gICAgbmVlZHNNYXNrID0gbmVlZE1hc2tpbmdUZXh0KFxuICAgICAgbjIsXG4gICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgIGNoZWNrQW5jZXN0b3JzXG4gICAgKTtcbiAgfVxuICBjb25zdCBfc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVOb2RlKG4yLCB7XG4gICAgZG9jLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgbmVlZHNNYXNrLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIGRhdGFVUkxPcHRpb25zLFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50LFxuICAgIGNzc0NhcHR1cmVkXG4gIH0pO1xuICBpZiAoIV9zZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnNvbGUud2FybihuMiwgXCJub3Qgc2VyaWFsaXplZFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgaWQ7XG4gIGlmIChtaXJyb3IyLmhhc05vZGUobjIpKSB7XG4gICAgaWQgPSBtaXJyb3IyLmdldElkKG4yKTtcbiAgfSBlbHNlIGlmIChzbGltRE9NRXhjbHVkZWQoX3NlcmlhbGl6ZWROb2RlLCBzbGltRE9NT3B0aW9ucykgfHwgIXByZXNlcnZlV2hpdGVTcGFjZSAmJiBfc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5UZXh0ICYmICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sIFwiXCIpLmxlbmd0aCkge1xuICAgIGlkID0gSUdOT1JFRF9OT0RFO1xuICB9IGVsc2Uge1xuICAgIGlkID0gZ2VuSWQoKTtcbiAgfVxuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IE9iamVjdC5hc3NpZ24oX3NlcmlhbGl6ZWROb2RlLCB7IGlkIH0pO1xuICBtaXJyb3IyLmFkZChuMiwgc2VyaWFsaXplZE5vZGUpO1xuICBpZiAoaWQgPT09IElHTk9SRURfTk9ERSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvblNlcmlhbGl6ZSkge1xuICAgIG9uU2VyaWFsaXplKG4yKTtcbiAgfVxuICBsZXQgcmVjb3JkQ2hpbGQgPSAhc2tpcENoaWxkO1xuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSB7XG4gICAgcmVjb3JkQ2hpbGQgPSByZWNvcmRDaGlsZCAmJiAhc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XG4gICAgY29uc3Qgc2hhZG93Um9vdEVsID0gaW5kZXgkMS5zaGFkb3dSb290KG4yKTtcbiAgICBpZiAoc2hhZG93Um9vdEVsICYmIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3RFbCkpXG4gICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvd0hvc3QgPSB0cnVlO1xuICB9XG4gIGlmICgoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5Eb2N1bWVudCB8fCBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpICYmIHJlY29yZENoaWxkKSB7XG4gICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRXaGl0ZXNwYWNlICYmIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImhlYWRcIikge1xuICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJ5cGFzc09wdGlvbnMgPSB7XG4gICAgICBkb2MsXG4gICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIG5lZWRzTWFzayxcbiAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgc2tpcENoaWxkLFxuICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICBtYXNrVGV4dEZuLFxuICAgICAgbWFza0lucHV0Rm4sXG4gICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgb25TZXJpYWxpemUsXG4gICAgICBvbklmcmFtZUxvYWQsXG4gICAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICBjc3NDYXB0dXJlZDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMudmFsdWUgIT09IHZvaWQgMCkgO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLl9jc3NUZXh0ICE9PSB2b2lkIDAgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuX2Nzc1RleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnlwYXNzT3B0aW9ucy5jc3NDYXB0dXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkTiBvZiBBcnJheS5mcm9tKGluZGV4JDEuY2hpbGROb2RlcyhuMikpKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XG4gICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzaGFkb3dSb290RWwgPSBudWxsO1xuICAgIGlmIChpc0VsZW1lbnQobjIpICYmIChzaGFkb3dSb290RWwgPSBpbmRleCQxLnNoYWRvd1Jvb3QobjIpKSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShpbmRleCQxLmNoaWxkTm9kZXMoc2hhZG93Um9vdEVsKSkpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcbiAgICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290RWwpICYmIChzZXJpYWxpemVkQ2hpbGROb2RlLmlzU2hhZG93ID0gdHJ1ZSk7XG4gICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudCA9IGluZGV4JDEucGFyZW50Tm9kZShuMik7XG4gIGlmIChwYXJlbnQgJiYgaXNTaGFkb3dSb290KHBhcmVudCkgJiYgaXNOYXRpdmVTaGFkb3dEb20ocGFyZW50KSkge1xuICAgIHNlcmlhbGl6ZWROb2RlLmlzU2hhZG93ID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwiaWZyYW1lXCIpIHtcbiAgICBvbmNlSWZyYW1lTG9hZGVkKFxuICAgICAgbjIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlmcmFtZURvYyA9IG4yLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XG4gICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbmVlZHNNYXNrLFxuICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgb25TZXJpYWxpemUsXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRJZnJhbWVOb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlmcmFtZUxvYWRUaW1lb3V0XG4gICAgKTtcbiAgfVxuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzdHJpbmdcIiAmJiAoc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWxvYWRcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5ocmVmID09PSBcInN0cmluZ1wiICYmIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwiY3NzXCIpKSB7XG4gICAgb25jZVN0eWxlc2hlZXRMb2FkZWQoXG4gICAgICBuMixcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKG9uU3R5bGVzaGVldExvYWQpIHtcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTGlua05vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG5lZWRzTWFzayxcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgbWFza1RleHRGbixcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgIGlubGluZUltYWdlcyxcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgICAgIG9uU2VyaWFsaXplLFxuICAgICAgICAgICAgb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHNlcmlhbGl6ZWRMaW5rTm9kZSkge1xuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRMaW5rTm9kZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXRcbiAgICApO1xuICB9XG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90KG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtaXJyb3I6IG1pcnJvcjIgPSBuZXcgTWlycm9yKCksXG4gICAgYmxvY2tDbGFzcyA9IFwicnItYmxvY2tcIixcbiAgICBibG9ja1NlbGVjdG9yID0gbnVsbCxcbiAgICBtYXNrVGV4dENsYXNzID0gXCJyci1tYXNrXCIsXG4gICAgbWFza1RleHRTZWxlY3RvciA9IG51bGwsXG4gICAgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcmVjb3JkQ2FudmFzID0gZmFsc2UsXG4gICAgbWFza0FsbElucHV0cyA9IGZhbHNlLFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgc2xpbURPTSA9IGZhbHNlLFxuICAgIGRhdGFVUkxPcHRpb25zLFxuICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICBvblNlcmlhbGl6ZSxcbiAgICBvbklmcmFtZUxvYWQsXG4gICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2VcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgIGNvbG9yOiB0cnVlLFxuICAgIGRhdGU6IHRydWUsXG4gICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgIGVtYWlsOiB0cnVlLFxuICAgIG1vbnRoOiB0cnVlLFxuICAgIG51bWJlcjogdHJ1ZSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgICBzZWFyY2g6IHRydWUsXG4gICAgdGVsOiB0cnVlLFxuICAgIHRleHQ6IHRydWUsXG4gICAgdGltZTogdHJ1ZSxcbiAgICB1cmw6IHRydWUsXG4gICAgd2VlazogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBzZWxlY3Q6IHRydWUsXG4gICAgcGFzc3dvcmQ6IHRydWVcbiAgfSA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlID8ge1xuICAgIHBhc3N3b3JkOiB0cnVlXG4gIH0gOiBtYXNrQWxsSW5wdXRzO1xuICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IHNsaW1ET00gPT09IHRydWUgfHwgc2xpbURPTSA9PT0gXCJhbGxcIiA/IChcbiAgICAvLyBpZiB0cnVlOiBzZXQgb2Ygc2Vuc2libGUgb3B0aW9ucyB0aGF0IHNob3VsZCBub3QgdGhyb3cgYXdheSBhbnkgaW5mb3JtYXRpb25cbiAgICB7XG4gICAgICBzY3JpcHQ6IHRydWUsXG4gICAgICBjb21tZW50OiB0cnVlLFxuICAgICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSBcImFsbFwiLFxuICAgICAgLy8gZGVzdHJ1Y3RpdmVcbiAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxuICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlXG4gICAgfVxuICApIDogc2xpbURPTSA9PT0gZmFsc2UgPyB7fSA6IHNsaW1ET007XG4gIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgZG9jOiBuMixcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgbWFza1RleHRTZWxlY3RvcixcbiAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHNsaW1ET01PcHRpb25zLFxuICAgIGRhdGFVUkxPcHRpb25zLFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgIG9uU2VyaWFsaXplLFxuICAgIG9uSWZyYW1lTG9hZCxcbiAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgbmV3bHlBZGRlZEVsZW1lbnQ6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMSh4Mikge1xuICByZXR1cm4geDIgJiYgeDIuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiZGVmYXVsdFwiKSA/IHgyW1wiZGVmYXVsdFwiXSA6IHgyO1xufVxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlJDEobjIpIHtcbiAgaWYgKG4yLl9fZXNNb2R1bGUpIHJldHVybiBuMjtcbiAgdmFyIGYyID0gbjIuZGVmYXVsdDtcbiAgaWYgKHR5cGVvZiBmMiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYTIgPSBmdW5jdGlvbiBhMjIoKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGEyMikge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoZjIsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGEyLnByb3RvdHlwZSA9IGYyLnByb3RvdHlwZTtcbiAgfSBlbHNlIGEyID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhMiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5rZXlzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobjIsIGspO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhMiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuMltrXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhMjtcbn1cbnZhciBwaWNvY29sb3JzX2Jyb3dzZXIkMSA9IHsgZXhwb3J0czoge30gfTtcbnZhciB4JDEgPSBTdHJpbmc7XG52YXIgY3JlYXRlJDEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgaXNDb2xvclN1cHBvcnRlZDogZmFsc2UsIHJlc2V0OiB4JDEsIGJvbGQ6IHgkMSwgZGltOiB4JDEsIGl0YWxpYzogeCQxLCB1bmRlcmxpbmU6IHgkMSwgaW52ZXJzZTogeCQxLCBoaWRkZW46IHgkMSwgc3RyaWtldGhyb3VnaDogeCQxLCBibGFjazogeCQxLCByZWQ6IHgkMSwgZ3JlZW46IHgkMSwgeWVsbG93OiB4JDEsIGJsdWU6IHgkMSwgbWFnZW50YTogeCQxLCBjeWFuOiB4JDEsIHdoaXRlOiB4JDEsIGdyYXk6IHgkMSwgYmdCbGFjazogeCQxLCBiZ1JlZDogeCQxLCBiZ0dyZWVuOiB4JDEsIGJnWWVsbG93OiB4JDEsIGJnQmx1ZTogeCQxLCBiZ01hZ2VudGE6IHgkMSwgYmdDeWFuOiB4JDEsIGJnV2hpdGU6IHgkMSB9O1xufTtcbnBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHMgPSBjcmVhdGUkMSgpO1xucGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGUkMTtcbnZhciBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzJDEgPSBwaWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzO1xuY29uc3QgX192aXRlQnJvd3NlckV4dGVybmFsJDIgPSB7fTtcbmNvbnN0IF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0OiBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMlxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmNvbnN0IHJlcXVpcmUkJDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UkMShfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSQxKTtcbmxldCBwaWNvJDEgPSBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzJDE7XG5sZXQgdGVybWluYWxIaWdobGlnaHQkMSQxID0gcmVxdWlyZSQkMiQxO1xubGV0IENzc1N5bnRheEVycm9yJDMkMSA9IGNsYXNzIENzc1N5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIHNvdXJjZSwgZmlsZSwgcGx1Z2luMjIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNzc1N5bnRheEVycm9yXCI7XG4gICAgdGhpcy5yZWFzb24gPSBtZXNzYWdlO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIH1cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbjIyKSB7XG4gICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbHVtbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZS5saW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGxpbmUuY29sdW1uO1xuICAgICAgICB0aGlzLmVuZExpbmUgPSBjb2x1bW4ubGluZTtcbiAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBjb2x1bW4uY29sdW1uO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldE1lc3NhZ2UoKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENzc1N5bnRheEVycm9yKTtcbiAgICB9XG4gIH1cbiAgc2V0TWVzc2FnZSgpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBsdWdpbiA/IHRoaXMucGx1Z2luICsgXCI6IFwiIDogXCJcIjtcbiAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogXCI8Y3NzIGlucHV0PlwiO1xuICAgIGlmICh0eXBlb2YgdGhpcy5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6XCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sdW1uO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6IFwiICsgdGhpcy5yZWFzb247XG4gIH1cbiAgc2hvd1NvdXJjZUNvZGUoY29sb3IpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm4gXCJcIjtcbiAgICBsZXQgY3NzID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gcGljbyQxLmlzQ29sb3JTdXBwb3J0ZWQ7XG4gICAgaWYgKHRlcm1pbmFsSGlnaGxpZ2h0JDEkMSkge1xuICAgICAgaWYgKGNvbG9yKSBjc3MgPSB0ZXJtaW5hbEhpZ2hsaWdodCQxJDEoY3NzKTtcbiAgICB9XG4gICAgbGV0IGxpbmVzID0gY3NzLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgodGhpcy5saW5lIC0gMywgMCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMubGluZSArIDIsIGxpbmVzLmxlbmd0aCk7XG4gICAgbGV0IG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoO1xuICAgIGxldCBtYXJrLCBhc2lkZTtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGxldCB7IGJvbGQsIGdyYXksIHJlZCB9ID0gcGljbyQxLmNyZWF0ZUNvbG9ycyh0cnVlKTtcbiAgICAgIG1hcmsgPSAodGV4dCkgPT4gYm9sZChyZWQodGV4dCkpO1xuICAgICAgYXNpZGUgPSAodGV4dCkgPT4gZ3JheSh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFyayA9IGFzaWRlID0gKHN0cikgPT4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKChsaW5lLCBpbmRleDIpID0+IHtcbiAgICAgIGxldCBudW1iZXIgPSBzdGFydCArIDEgKyBpbmRleDI7XG4gICAgICBsZXQgZ3V0dGVyID0gXCIgXCIgKyAoXCIgXCIgKyBudW1iZXIpLnNsaWNlKC1tYXhXaWR0aCkgKyBcIiB8IFwiO1xuICAgICAgaWYgKG51bWJlciA9PT0gdGhpcy5saW5lKSB7XG4gICAgICAgIGxldCBzcGFjaW5nID0gYXNpZGUoZ3V0dGVyLnJlcGxhY2UoL1xcZC9nLCBcIiBcIikpICsgbGluZS5zbGljZSgwLCB0aGlzLmNvbHVtbiAtIDEpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgIHJldHVybiBtYXJrKFwiPlwiKSArIGFzaWRlKGd1dHRlcikgKyBsaW5lICsgXCJcXG4gXCIgKyBzcGFjaW5nICsgbWFyayhcIl5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCIgXCIgKyBhc2lkZShndXR0ZXIpICsgbGluZTtcbiAgICB9KS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBjb2RlID0gdGhpcy5zaG93U291cmNlQ29kZSgpO1xuICAgIGlmIChjb2RlKSB7XG4gICAgICBjb2RlID0gXCJcXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgY29kZTtcbiAgfVxufTtcbnZhciBjc3NTeW50YXhFcnJvciQxID0gQ3NzU3ludGF4RXJyb3IkMyQxO1xuQ3NzU3ludGF4RXJyb3IkMyQxLmRlZmF1bHQgPSBDc3NTeW50YXhFcnJvciQzJDE7XG52YXIgc3ltYm9scyQxID0ge307XG5zeW1ib2xzJDEuaXNDbGVhbiA9IFN5bWJvbChcImlzQ2xlYW5cIik7XG5zeW1ib2xzJDEubXkgPSBTeW1ib2woXCJteVwiKTtcbmNvbnN0IERFRkFVTFRfUkFXJDEgPSB7XG4gIGFmdGVyOiBcIlxcblwiLFxuICBiZWZvcmVDbG9zZTogXCJcXG5cIixcbiAgYmVmb3JlQ29tbWVudDogXCJcXG5cIixcbiAgYmVmb3JlRGVjbDogXCJcXG5cIixcbiAgYmVmb3JlT3BlbjogXCIgXCIsXG4gIGJlZm9yZVJ1bGU6IFwiXFxuXCIsXG4gIGNvbG9uOiBcIjogXCIsXG4gIGNvbW1lbnRMZWZ0OiBcIiBcIixcbiAgY29tbWVudFJpZ2h0OiBcIiBcIixcbiAgZW1wdHlCb2R5OiBcIlwiLFxuICBpbmRlbnQ6IFwiICAgIFwiLFxuICBzZW1pY29sb246IGZhbHNlXG59O1xuZnVuY3Rpb24gY2FwaXRhbGl6ZSQxKHN0cikge1xuICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5sZXQgU3RyaW5naWZpZXIkMiQxID0gY2xhc3MgU3RyaW5naWZpZXIge1xuICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgfVxuICBhdHJ1bGUobm9kZTIsIHNlbWljb2xvbikge1xuICAgIGxldCBuYW1lID0gXCJAXCIgKyBub2RlMi5uYW1lO1xuICAgIGxldCBwYXJhbXMgPSBub2RlMi5wYXJhbXMgPyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInBhcmFtc1wiKSA6IFwiXCI7XG4gICAgaWYgKHR5cGVvZiBub2RlMi5yYXdzLmFmdGVyTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbmFtZSArPSBub2RlMi5yYXdzLmFmdGVyTmFtZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgbmFtZSArPSBcIiBcIjtcbiAgICB9XG4gICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICB0aGlzLmJsb2NrKG5vZGUyLCBuYW1lICsgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVuZCA9IChub2RlMi5yYXdzLmJldHdlZW4gfHwgXCJcIikgKyAoc2VtaWNvbG9uID8gXCI7XCIgOiBcIlwiKTtcbiAgICAgIHRoaXMuYnVpbGRlcihuYW1lICsgcGFyYW1zICsgZW5kLCBub2RlMik7XG4gICAgfVxuICB9XG4gIGJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDb21tZW50XCIpO1xuICAgIH0gZWxzZSBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ2xvc2VcIik7XG4gICAgfVxuICAgIGxldCBidWYgPSBub2RlMi5wYXJlbnQ7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICB3aGlsZSAoYnVmICYmIGJ1Zi50eXBlICE9PSBcInJvb3RcIikge1xuICAgICAgZGVwdGggKz0gMTtcbiAgICAgIGJ1ZiA9IGJ1Zi5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgbGV0IGluZGVudCA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImluZGVudFwiKTtcbiAgICAgIGlmIChpbmRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKykgdmFsdWUgKz0gaW5kZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgYmxvY2sobm9kZTIsIHN0YXJ0KSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICB0aGlzLmJ1aWxkZXIoc3RhcnQgKyBiZXR3ZWVuICsgXCJ7XCIsIG5vZGUyLCBcInN0YXJ0XCIpO1xuICAgIGxldCBhZnRlcjtcbiAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiLCBcImVtcHR5Qm9keVwiKTtcbiAgICB9XG4gICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpO1xuICAgIHRoaXMuYnVpbGRlcihcIn1cIiwgbm9kZTIsIFwiZW5kXCIpO1xuICB9XG4gIGJvZHkobm9kZTIpIHtcbiAgICBsZXQgbGFzdCA9IG5vZGUyLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxhc3QgPiAwKSB7XG4gICAgICBpZiAobm9kZTIubm9kZXNbbGFzdF0udHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgbGFzdCAtPSAxO1xuICAgIH1cbiAgICBsZXQgc2VtaWNvbG9uID0gdGhpcy5yYXcobm9kZTIsIFwic2VtaWNvbG9uXCIpO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBub2RlMi5ub2Rlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGxldCBjaGlsZCA9IG5vZGUyLm5vZGVzW2kyXTtcbiAgICAgIGxldCBiZWZvcmUgPSB0aGlzLnJhdyhjaGlsZCwgXCJiZWZvcmVcIik7XG4gICAgICBpZiAoYmVmb3JlKSB0aGlzLmJ1aWxkZXIoYmVmb3JlKTtcbiAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpMiB8fCBzZW1pY29sb24pO1xuICAgIH1cbiAgfVxuICBjb21tZW50KG5vZGUyKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJhdyhub2RlMiwgXCJsZWZ0XCIsIFwiY29tbWVudExlZnRcIik7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yYXcobm9kZTIsIFwicmlnaHRcIiwgXCJjb21tZW50UmlnaHRcIik7XG4gICAgdGhpcy5idWlsZGVyKFwiLypcIiArIGxlZnQgKyBub2RlMi50ZXh0ICsgcmlnaHQgKyBcIiovXCIsIG5vZGUyKTtcbiAgfVxuICBkZWNsKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICBsZXQgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJjb2xvblwiKTtcbiAgICBsZXQgc3RyaW5nID0gbm9kZTIucHJvcCArIGJldHdlZW4gKyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInZhbHVlXCIpO1xuICAgIGlmIChub2RlMi5pbXBvcnRhbnQpIHtcbiAgICAgIHN0cmluZyArPSBub2RlMi5yYXdzLmltcG9ydGFudCB8fCBcIiAhaW1wb3J0YW50XCI7XG4gICAgfVxuICAgIGlmIChzZW1pY29sb24pIHN0cmluZyArPSBcIjtcIjtcbiAgICB0aGlzLmJ1aWxkZXIoc3RyaW5nLCBub2RlMik7XG4gIH1cbiAgZG9jdW1lbnQobm9kZTIpIHtcbiAgICB0aGlzLmJvZHkobm9kZTIpO1xuICB9XG4gIHJhdyhub2RlMiwgb3duLCBkZXRlY3QpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93bjtcbiAgICBpZiAob3duKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUyLnJhd3Nbb3duXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IG5vZGUyLnBhcmVudDtcbiAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgcGFyZW50LmZpcnN0ID09PSBub2RlMikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybiBERUZBVUxUX1JBVyQxW2RldGVjdF07XG4gICAgbGV0IHJvb3QyID0gbm9kZTIucm9vdCgpO1xuICAgIGlmICghcm9vdDIucmF3Q2FjaGUpIHJvb3QyLnJhd0NhY2hlID0ge307XG4gICAgaWYgKHR5cGVvZiByb290Mi5yYXdDYWNoZVtkZXRlY3RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XTtcbiAgICB9XG4gICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIiB8fCBkZXRlY3QgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlQWZ0ZXIobm9kZTIsIGRldGVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXRob2QgPSBcInJhd1wiICsgY2FwaXRhbGl6ZSQxKGRldGVjdCk7XG4gICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QyLCBub2RlMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3c1tvd25dO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVckMVtkZXRlY3RdO1xuICAgIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlQ2xvc2Uocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5hZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlQ29tbWVudChyb290Miwgbm9kZTIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2Fsa0NvbW1lbnRzKChpMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZURlY2wocm9vdDIsIG5vZGUyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtEZWNscygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVPcGVuKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIudHlwZSAhPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW47XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlUnVsZShyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIChpMi5wYXJlbnQgIT09IHJvb3QyIHx8IHJvb3QyLmZpcnN0ICE9PSBpMikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0NvbG9uKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtEZWNscygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZXR3ZWVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgXCJcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3RW1wdHlCb2R5KHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdJbmRlbnQocm9vdDIpIHtcbiAgICBpZiAocm9vdDIucmF3cy5pbmRlbnQpIHJldHVybiByb290Mi5yYXdzLmluZGVudDtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGxldCBwID0gaTIucGFyZW50O1xuICAgICAgaWYgKHAgJiYgcCAhPT0gcm9vdDIgJiYgcC5wYXJlbnQgJiYgcC5wYXJlbnQgPT09IHJvb3QyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSBpMi5yYXdzLmJlZm9yZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdTZW1pY29sb24ocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggJiYgaTIubGFzdC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3Muc2VtaWNvbG9uO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd1ZhbHVlKG5vZGUyLCBwcm9wKSB7XG4gICAgbGV0IHZhbHVlID0gbm9kZTJbcHJvcF07XG4gICAgbGV0IHJhdyA9IG5vZGUyLnJhd3NbcHJvcF07XG4gICAgaWYgKHJhdyAmJiByYXcudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmF3LnJhdztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJvb3Qobm9kZTIpIHtcbiAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgIGlmIChub2RlMi5yYXdzLmFmdGVyKSB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5hZnRlcik7XG4gIH1cbiAgcnVsZShub2RlMikge1xuICAgIHRoaXMuYmxvY2sobm9kZTIsIHRoaXMucmF3VmFsdWUobm9kZTIsIFwic2VsZWN0b3JcIikpO1xuICAgIGlmIChub2RlMi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uLCBub2RlMiwgXCJlbmRcIik7XG4gICAgfVxuICB9XG4gIHN0cmluZ2lmeShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgaWYgKCF0aGlzW25vZGUyLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biBBU1Qgbm9kZSB0eXBlIFwiICsgbm9kZTIudHlwZSArIFwiLiBNYXliZSB5b3UgbmVlZCB0byBjaGFuZ2UgUG9zdENTUyBzdHJpbmdpZmllci5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpc1tub2RlMi50eXBlXShub2RlMiwgc2VtaWNvbG9uKTtcbiAgfVxufTtcbnZhciBzdHJpbmdpZmllciQxID0gU3RyaW5naWZpZXIkMiQxO1xuU3RyaW5naWZpZXIkMiQxLmRlZmF1bHQgPSBTdHJpbmdpZmllciQyJDE7XG5sZXQgU3RyaW5naWZpZXIkMSQxID0gc3RyaW5naWZpZXIkMTtcbmZ1bmN0aW9uIHN0cmluZ2lmeSQ0JDEobm9kZTIsIGJ1aWxkZXIpIHtcbiAgbGV0IHN0ciA9IG5ldyBTdHJpbmdpZmllciQxJDEoYnVpbGRlcik7XG4gIHN0ci5zdHJpbmdpZnkobm9kZTIpO1xufVxudmFyIHN0cmluZ2lmeV8xJDEgPSBzdHJpbmdpZnkkNCQxO1xuc3RyaW5naWZ5JDQkMS5kZWZhdWx0ID0gc3RyaW5naWZ5JDQkMTtcbmxldCB7IGlzQ2xlYW46IGlzQ2xlYW4kMiQxLCBteTogbXkkMiQxIH0gPSBzeW1ib2xzJDE7XG5sZXQgQ3NzU3ludGF4RXJyb3IkMiQxID0gY3NzU3ludGF4RXJyb3IkMTtcbmxldCBTdHJpbmdpZmllcjIkMSA9IHN0cmluZ2lmaWVyJDE7XG5sZXQgc3RyaW5naWZ5JDMkMSA9IHN0cmluZ2lmeV8xJDE7XG5mdW5jdGlvbiBjbG9uZU5vZGUkMShvYmosIHBhcmVudCkge1xuICBsZXQgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuICBmb3IgKGxldCBpMiBpbiBvYmopIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpMiA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgIGxldCB2YWx1ZSA9IG9ialtpMl07XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKGkyID09PSBcInBhcmVudFwiICYmIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChwYXJlbnQpIGNsb25lZFtpMl0gPSBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZS5tYXAoKGopID0+IGNsb25lTm9kZSQxKGosIGNsb25lZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkgdmFsdWUgPSBjbG9uZU5vZGUkMSh2YWx1ZSk7XG4gICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5sZXQgTm9kZSQ0JDEgPSBjbGFzcyBOb2RlMiB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzID0ge30pIHtcbiAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICB0aGlzW2lzQ2xlYW4kMiQxXSA9IGZhbHNlO1xuICAgIHRoaXNbbXkkMiQxXSA9IHRydWU7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKG5hbWUgPT09IFwibm9kZXNcIikge1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IG5vZGUyIG9mIGRlZmF1bHRzW25hbWVdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMi5jbG9uZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgZXJyb3IucG9zdGNzc05vZGUgPSB0aGlzO1xuICAgIGlmIChlcnJvci5zdGFjayAmJiB0aGlzLnNvdXJjZSAmJiAvXFxuXFxzezR9YXQgLy50ZXN0KGVycm9yLnN0YWNrKSkge1xuICAgICAgbGV0IHMyID0gdGhpcy5zb3VyY2U7XG4gICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoXG4gICAgICAgIC9cXG5cXHN7NH1hdCAvLFxuICAgICAgICBgJCYke3MyLmlucHV0LmZyb219OiR7czIuc3RhcnQubGluZX06JHtzMi5zdGFydC5jb2x1bW59JCZgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgYWZ0ZXIoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3NpZ24ob3ZlcnJpZGVzID0ge30pIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIG92ZXJyaWRlcykge1xuICAgICAgdGhpc1tuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVmb3JlKGFkZCkge1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhZGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlO1xuICAgIGRlbGV0ZSB0aGlzLnJhd3MuYWZ0ZXI7XG4gICAgaWYgKCFrZWVwQmV0d2VlbikgZGVsZXRlIHRoaXMucmF3cy5iZXR3ZWVuO1xuICB9XG4gIGNsb25lKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IGNsb25lTm9kZSQxKHRoaXMpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgY2xvbmVBZnRlcihvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lQmVmb3JlKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGVycm9yKG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbGV0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5yYW5nZUJ5KG9wdHMpO1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB7IGNvbHVtbjogc3RhcnQuY29sdW1uLCBsaW5lOiBzdGFydC5saW5lIH0sXG4gICAgICAgIHsgY29sdW1uOiBlbmQuY29sdW1uLCBsaW5lOiBlbmQubGluZSB9LFxuICAgICAgICBvcHRzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENzc1N5bnRheEVycm9yJDIkMShtZXNzYWdlKTtcbiAgfVxuICBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGlmIChwcm9wID09PSBcInByb3BcIiB8fCBwcm9wID09PSBcInZhbHVlXCIgfHwgcHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcImltcG9ydGFudFwiIHx8IC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHByb3AgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBtYXJrRGlydHkoKSB7XG4gICAgaWYgKHRoaXNbaXNDbGVhbiQyJDFdKSB7XG4gICAgICB0aGlzW2lzQ2xlYW4kMiQxXSA9IGZhbHNlO1xuICAgICAgbGV0IG5leHQgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5leHQgPSBuZXh0LnBhcmVudCkge1xuICAgICAgICBuZXh0W2lzQ2xlYW4kMiQxXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgKyAxXTtcbiAgfVxuICBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0O1xuICAgIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMud29yZCkge1xuICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgcG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgIGxldCBzdHJpbmcgPSBzdHJpbmdSZXByZXNlbnRhdGlvbiB8fCB0aGlzLnRvU3RyaW5nKCk7XG4gICAgbGV0IGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbjtcbiAgICBsZXQgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGluZGV4MjsgaTIrKykge1xuICAgICAgaWYgKHN0cmluZ1tpMl0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgbGluZSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSB9O1xuICB9XG4gIHByZXYoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICBsZXQgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiAtIDFdO1xuICB9XG4gIHJhbmdlQnkob3B0cykge1xuICAgIGxldCBzdGFydCA9IHtcbiAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uLFxuICAgICAgbGluZTogdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuICAgIH07XG4gICAgbGV0IGVuZCA9IHRoaXMuc291cmNlLmVuZCA/IHtcbiAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiArIDEsXG4gICAgICBsaW5lOiB0aGlzLnNvdXJjZS5lbmQubGluZVxuICAgIH0gOiB7XG4gICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsXG4gICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgfTtcbiAgICBpZiAob3B0cy53b3JkKSB7XG4gICAgICBsZXQgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4MiArIG9wdHMud29yZC5sZW5ndGgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdHMuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICBsaW5lOiBvcHRzLnN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5lbmQpIHtcbiAgICAgICAgZW5kID0ge1xuICAgICAgICAgIGNvbHVtbjogb3B0cy5lbmQuY29sdW1uLFxuICAgICAgICAgIGxpbmU6IG9wdHMuZW5kLmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZW5kSW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmVuZEluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZC5saW5lIDwgc3RhcnQubGluZSB8fCBlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbikge1xuICAgICAgZW5kID0geyBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsIGxpbmU6IHN0YXJ0LmxpbmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5kLCBzdGFydCB9O1xuICB9XG4gIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIyJDEoKTtcbiAgICByZXR1cm4gc3RyLnJhdyh0aGlzLCBwcm9wLCBkZWZhdWx0VHlwZSk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlcGxhY2VXaXRoKC4uLm5vZGVzKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBsZXQgYm9va21hcmsgPSB0aGlzO1xuICAgICAgbGV0IGZvdW5kU2VsZiA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUyID09PSB0aGlzKSB7XG4gICAgICAgICAgZm91bmRTZWxmID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZTIpO1xuICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRTZWxmKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvb3QoKSB7XG4gICAgbGV0IHJlc3VsdDIgPSB0aGlzO1xuICAgIHdoaWxlIChyZXN1bHQyLnBhcmVudCAmJiByZXN1bHQyLnBhcmVudC50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdG9KU09OKF8sIGlucHV0cykge1xuICAgIGxldCBmaXhlZCA9IHt9O1xuICAgIGxldCBlbWl0SW5wdXRzID0gaW5wdXRzID09IG51bGw7XG4gICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGlucHV0c05leHRJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcInBhcmVudFwiIHx8IG5hbWUgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS5tYXAoKGkyKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBpMi50b0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiBpMi50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS50b0pTT04pIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICBsZXQgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICBpZiAoaW5wdXRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpO1xuICAgICAgICAgIGlucHV0c05leHRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgIGVuZDogdmFsdWUuZW5kLFxuICAgICAgICAgIGlucHV0SWQsXG4gICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgZml4ZWQuaW5wdXRzID0gWy4uLmlucHV0cy5rZXlzKCldLm1hcCgoaW5wdXQyKSA9PiBpbnB1dDIudG9KU09OKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZml4ZWQ7XG4gIH1cbiAgdG9Qcm94eSgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3h5Q2FjaGU7XG4gIH1cbiAgdG9TdHJpbmcoc3RyaW5naWZpZXIyID0gc3RyaW5naWZ5JDMkMSkge1xuICAgIGlmIChzdHJpbmdpZmllcjIuc3RyaW5naWZ5KSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZmllcjIuc3RyaW5naWZ5O1xuICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICBzdHJpbmdpZmllcjIodGhpcywgKGkyKSA9PiB7XG4gICAgICByZXN1bHQyICs9IGkyO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIHdhcm4ocmVzdWx0MiwgdGV4dCwgb3B0cykge1xuICAgIGxldCBkYXRhID0geyBub2RlOiB0aGlzIH07XG4gICAgZm9yIChsZXQgaTIgaW4gb3B0cykgZGF0YVtpMl0gPSBvcHRzW2kyXTtcbiAgICByZXR1cm4gcmVzdWx0Mi53YXJuKHRleHQsIGRhdGEpO1xuICB9XG4gIGdldCBwcm94eU9mKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vZGUkMSA9IE5vZGUkNCQxO1xuTm9kZSQ0JDEuZGVmYXVsdCA9IE5vZGUkNCQxO1xubGV0IE5vZGUkMyQxID0gbm9kZSQxO1xubGV0IERlY2xhcmF0aW9uJDQkMSA9IGNsYXNzIERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZSQzJDEge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIGlmIChkZWZhdWx0cyAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZWZhdWx0cyA9IHsgLi4uZGVmYXVsdHMsIHZhbHVlOiBTdHJpbmcoZGVmYXVsdHMudmFsdWUpIH07XG4gICAgfVxuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImRlY2xcIjtcbiAgfVxuICBnZXQgdmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5zdGFydHNXaXRoKFwiLS1cIikgfHwgdGhpcy5wcm9wWzBdID09PSBcIiRcIjtcbiAgfVxufTtcbnZhciBkZWNsYXJhdGlvbiQxID0gRGVjbGFyYXRpb24kNCQxO1xuRGVjbGFyYXRpb24kNCQxLmRlZmF1bHQgPSBEZWNsYXJhdGlvbiQ0JDE7XG5sZXQgdXJsQWxwaGFiZXQkMSA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xubGV0IGN1c3RvbUFscGhhYmV0JDEgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGxldCBpMiA9IHNpemU7XG4gICAgd2hpbGUgKGkyLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGggfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xuICB9O1xufTtcbmxldCBuYW5vaWQkMSQxID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaTIgPSBzaXplO1xuICB3aGlsZSAoaTItLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0JDFbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcbnZhciBub25TZWN1cmUkMSA9IHsgbmFub2lkOiBuYW5vaWQkMSQxLCBjdXN0b21BbHBoYWJldDogY3VzdG9tQWxwaGFiZXQkMSB9O1xubGV0IHsgU291cmNlTWFwQ29uc3VtZXI6IFNvdXJjZU1hcENvbnN1bWVyJDIkMSwgU291cmNlTWFwR2VuZXJhdG9yOiBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBleGlzdHNTeW5jOiBleGlzdHNTeW5jJDEsIHJlYWRGaWxlU3luYzogcmVhZEZpbGVTeW5jJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IGRpcm5hbWU6IGRpcm5hbWUkMSQxLCBqb2luOiBqb2luJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmZ1bmN0aW9uIGZyb21CYXNlNjQkMShzdHIpIHtcbiAgaWYgKEJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cik7XG4gIH1cbn1cbmxldCBQcmV2aW91c01hcCQyJDEgPSBjbGFzcyBQcmV2aW91c01hcCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cykge1xuICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICB0aGlzLmxvYWRBbm5vdGF0aW9uKGNzcyk7XG4gICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgbGV0IHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB2b2lkIDA7XG4gICAgbGV0IHRleHQgPSB0aGlzLmxvYWRNYXAob3B0cy5mcm9tLCBwcmV2KTtcbiAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwRmlsZSkgdGhpcy5yb290ID0gZGlybmFtZSQxJDEodGhpcy5tYXBGaWxlKTtcbiAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBjb25zdW1lcigpIHtcbiAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDIkMSh0aGlzLnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlO1xuICB9XG4gIGRlY29kZUlubGluZSh0ZXh0KSB7XG4gICAgbGV0IGJhc2VDaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/ODtiYXNlNjQsLztcbiAgICBsZXQgYmFzZVVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247YmFzZTY0LC87XG4gICAgbGV0IGNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84LC87XG4gICAgbGV0IHVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb24sLztcbiAgICBpZiAoY2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IHVyaS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7XG4gICAgfVxuICAgIGlmIChiYXNlQ2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IGJhc2VVcmkudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIGZyb21CYXNlNjQkMSh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgIH1cbiAgICBsZXQgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvblVSTChzb3VyY2VNYXBTdHJpbmcpIHtcbiAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nLnJlcGxhY2UoL15cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS8sIFwiXCIpLnRyaW0oKTtcbiAgfVxuICBpc01hcChtYXApIHtcbiAgICBpZiAodHlwZW9mIG1hcCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0eXBlb2YgbWFwLm1hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYXAuX21hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkobWFwLnNlY3Rpb25zKTtcbiAgfVxuICBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICBsZXQgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2dtKTtcbiAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgbGV0IHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKTtcbiAgICBsZXQgZW5kID0gY3NzLmluZGV4T2YoXCIqL1wiLCBzdGFydCk7XG4gICAgaWYgKHN0YXJ0ID4gLTEgJiYgZW5kID4gLTEpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICB9XG4gIH1cbiAgbG9hZEZpbGUocGF0aCkge1xuICAgIHRoaXMucm9vdCA9IGRpcm5hbWUkMSQxKHBhdGgpO1xuICAgIGlmIChleGlzdHNTeW5jJDEocGF0aCkpIHtcbiAgICAgIHRoaXMubWFwRmlsZSA9IHBhdGg7XG4gICAgICByZXR1cm4gcmVhZEZpbGVTeW5jJDEocGF0aCwgXCJ1dGYtOFwiKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsZXQgcHJldlBhdGggPSBwcmV2KGZpbGUpO1xuICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICBsZXQgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aCk7XG4gICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiBcIiArIHByZXZQYXRoLnRvU3RyaW5nKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcENvbnN1bWVyJDIkMSkge1xuICAgICAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yJDIkMS5mcm9tU291cmNlTWFwKHByZXYpLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHByZXYgaW5zdGFuY2VvZiBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxKSB7XG4gICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgcHJldmlvdXMgc291cmNlIG1hcCBmb3JtYXQ6IFwiICsgcHJldi50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFubm90YXRpb247XG4gICAgICBpZiAoZmlsZSkgbWFwID0gam9pbiQxKGRpcm5hbWUkMSQxKGZpbGUpLCBtYXApO1xuICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUobWFwKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRXaXRoKHN0cmluZywgc3RhcnQpIHtcbiAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIHN0YXJ0Lmxlbmd0aCkgPT09IHN0YXJ0O1xuICB9XG4gIHdpdGhDb250ZW50KCkge1xuICAgIHJldHVybiAhISh0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQgJiYgdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+IDApO1xuICB9XG59O1xudmFyIHByZXZpb3VzTWFwJDEgPSBQcmV2aW91c01hcCQyJDE7XG5QcmV2aW91c01hcCQyJDEuZGVmYXVsdCA9IFByZXZpb3VzTWFwJDIkMTtcbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lciQxJDEsIFNvdXJjZU1hcEdlbmVyYXRvcjogU291cmNlTWFwR2VuZXJhdG9yJDEkMSB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgZmlsZVVSTFRvUGF0aDogZmlsZVVSTFRvUGF0aCQxLCBwYXRoVG9GaWxlVVJMOiBwYXRoVG9GaWxlVVJMJDEkMSB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgaXNBYnNvbHV0ZTogaXNBYnNvbHV0ZSQxLCByZXNvbHZlOiByZXNvbHZlJDEkMSB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgbmFub2lkOiBuYW5vaWQkMiB9ID0gbm9uU2VjdXJlJDE7XG5sZXQgdGVybWluYWxIaWdobGlnaHQkMiA9IHJlcXVpcmUkJDIkMTtcbmxldCBDc3NTeW50YXhFcnJvciQxJDEgPSBjc3NTeW50YXhFcnJvciQxO1xubGV0IFByZXZpb3VzTWFwJDEkMSA9IHByZXZpb3VzTWFwJDE7XG5sZXQgZnJvbU9mZnNldENhY2hlJDEgPSBTeW1ib2woXCJmcm9tT2Zmc2V0Q2FjaGVcIik7XG5sZXQgc291cmNlTWFwQXZhaWxhYmxlJDEkMSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIkMSQxICYmIFNvdXJjZU1hcEdlbmVyYXRvciQxJDEpO1xubGV0IHBhdGhBdmFpbGFibGUkMSQxID0gQm9vbGVhbihyZXNvbHZlJDEkMSAmJiBpc0Fic29sdXRlJDEpO1xubGV0IElucHV0JDQkMSA9IGNsYXNzIElucHV0IHtcbiAgY29uc3RydWN0b3IoY3NzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoY3NzID09PSBudWxsIHx8IHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGNzcyA9PT0gXCJvYmplY3RcIiAmJiAhY3NzLnRvU3RyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3RDU1MgcmVjZWl2ZWQgJHtjc3N9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLmNzc1swXSA9PT0gXCJcXHVGRUZGXCIgfHwgdGhpcy5jc3NbMF0gPT09IFwi77++XCIpIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3Muc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRzLmZyb20pIHtcbiAgICAgIGlmICghcGF0aEF2YWlsYWJsZSQxJDEgfHwgL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IGlzQWJzb2x1dGUkMShvcHRzLmZyb20pKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IHJlc29sdmUkMSQxKG9wdHMuZnJvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoQXZhaWxhYmxlJDEkMSAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMSQxKSB7XG4gICAgICBsZXQgbWFwID0gbmV3IFByZXZpb3VzTWFwJDEkMSh0aGlzLmNzcywgb3B0cyk7XG4gICAgICBpZiAobWFwLnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGxldCBmaWxlID0gbWFwLmNvbnN1bWVyKCkuZmlsZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZmlsZSkge1xuICAgICAgdGhpcy5pZCA9IFwiPGlucHV0IGNzcyBcIiArIG5hbm9pZCQyKDYpICsgXCI+XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbTtcbiAgfVxuICBlcnJvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIG9wdHMgPSB7fSkge1xuICAgIGxldCByZXN1bHQyLCBlbmRMaW5lLCBlbmRDb2x1bW47XG4gICAgaWYgKGxpbmUgJiYgdHlwZW9mIGxpbmUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGxldCBzdGFydCA9IGxpbmU7XG4gICAgICBsZXQgZW5kID0gY29sdW1uO1xuICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZnJvbU9mZnNldChzdGFydC5vZmZzZXQpO1xuICAgICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lID0gc3RhcnQubGluZTtcbiAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldCk7XG4gICAgICAgIGVuZExpbmUgPSBwb3MubGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gcG9zLmNvbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZExpbmUgPSBlbmQubGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gZW5kLmNvbHVtbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFjb2x1bW4pIHtcbiAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQobGluZSk7XG4gICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICBjb2x1bW4gPSBwb3MuY29sO1xuICAgIH1cbiAgICBsZXQgb3JpZ2luID0gdGhpcy5vcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pO1xuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMSQxKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmxpbmUgOiB7IGNvbHVtbjogb3JpZ2luLmNvbHVtbiwgbGluZTogb3JpZ2luLmxpbmUgfSxcbiAgICAgICAgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5jb2x1bW4gOiB7IGNvbHVtbjogb3JpZ2luLmVuZENvbHVtbiwgbGluZTogb3JpZ2luLmVuZExpbmUgfSxcbiAgICAgICAgb3JpZ2luLnNvdXJjZSxcbiAgICAgICAgb3JpZ2luLmZpbGUsXG4gICAgICAgIG9wdHMucGx1Z2luXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEkMShcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHsgY29sdW1uLCBsaW5lIH0sXG4gICAgICAgIGVuZExpbmUgPT09IHZvaWQgMCA/IGNvbHVtbiA6IHsgY29sdW1uOiBlbmRDb2x1bW4sIGxpbmU6IGVuZExpbmUgfSxcbiAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgIHRoaXMuZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VsdDIuaW5wdXQgPSB7IGNvbHVtbiwgZW5kQ29sdW1uLCBlbmRMaW5lLCBsaW5lLCBzb3VyY2U6IHRoaXMuY3NzIH07XG4gICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwkMSQxKSB7XG4gICAgICAgIHJlc3VsdDIuaW5wdXQudXJsID0gcGF0aFRvRmlsZVVSTCQxJDEodGhpcy5maWxlKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmVzdWx0Mi5pbnB1dC5maWxlID0gdGhpcy5maWxlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICBmcm9tT2Zmc2V0KG9mZnNldCkge1xuICAgIGxldCBsYXN0TGluZSwgbGluZVRvSW5kZXg7XG4gICAgaWYgKCF0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXSkge1xuICAgICAgbGV0IGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoXCJcXG5cIik7XG4gICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgbGV0IHByZXZJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGwyID0gbGluZXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICAgIGxpbmVUb0luZGV4W2kyXSA9IHByZXZJbmRleDtcbiAgICAgICAgcHJldkluZGV4ICs9IGxpbmVzW2kyXS5sZW5ndGggKyAxO1xuICAgICAgfVxuICAgICAgdGhpc1tmcm9tT2Zmc2V0Q2FjaGUkMV0gPSBsaW5lVG9JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXTtcbiAgICB9XG4gICAgbGFzdExpbmUgPSBsaW5lVG9JbmRleFtsaW5lVG9JbmRleC5sZW5ndGggLSAxXTtcbiAgICBsZXQgbWluID0gMDtcbiAgICBpZiAob2Zmc2V0ID49IGxhc3RMaW5lKSB7XG4gICAgICBtaW4gPSBsaW5lVG9JbmRleC5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF4ID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMjtcbiAgICAgIGxldCBtaWQ7XG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIChtYXggLSBtaW4gPj4gMSk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsaW5lVG9JbmRleFttaWRdKSB7XG4gICAgICAgICAgbWF4ID0gbWlkIC0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPj0gbGluZVRvSW5kZXhbbWlkICsgMV0pIHtcbiAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29sOiBvZmZzZXQgLSBsaW5lVG9JbmRleFttaW5dICsgMSxcbiAgICAgIGxpbmU6IG1pbiArIDFcbiAgICB9O1xuICB9XG4gIG1hcFJlc29sdmUoZmlsZSkge1xuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSB7XG4gICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmUkMSQxKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8IFwiLlwiLCBmaWxlKTtcbiAgfVxuICBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbnN1bWVyID0gdGhpcy5tYXAuY29uc3VtZXIoKTtcbiAgICBsZXQgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBjb2x1bW4sIGxpbmUgfSk7XG4gICAgaWYgKCFmcm9tLnNvdXJjZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0bztcbiAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbjogZW5kQ29sdW1uLCBsaW5lOiBlbmRMaW5lIH0pO1xuICAgIH1cbiAgICBsZXQgZnJvbVVybDtcbiAgICBpZiAoaXNBYnNvbHV0ZSQxKGZyb20uc291cmNlKSkge1xuICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwkMSQxKGZyb20uc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbVVybCA9IG5ldyBVUkwoXG4gICAgICAgIGZyb20uc291cmNlLFxuICAgICAgICB0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgcGF0aFRvRmlsZVVSTCQxJDEodGhpcy5tYXAubWFwRmlsZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCByZXN1bHQyID0ge1xuICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgfTtcbiAgICBpZiAoZnJvbVVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiKSB7XG4gICAgICBpZiAoZmlsZVVSTFRvUGF0aCQxKSB7XG4gICAgICAgIHJlc3VsdDIuZmlsZSA9IGZpbGVVUkxUb1BhdGgkMShmcm9tVXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmlsZTogcHJvdG9jb2wgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IGNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoZnJvbS5zb3VyY2UpO1xuICAgIGlmIChzb3VyY2UpIHJlc3VsdDIuc291cmNlID0gc291cmNlO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICBsZXQganNvbiA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgb2YgW1wiaGFzQk9NXCIsIFwiY3NzXCIsIFwiZmlsZVwiLCBcImlkXCJdKSB7XG4gICAgICBpZiAodGhpc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIGpzb25bbmFtZV0gPSB0aGlzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgIGpzb24ubWFwID0geyAuLi50aGlzLm1hcCB9O1xuICAgICAgaWYgKGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAganNvbi5tYXAuY29uc3VtZXJDYWNoZSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgZ2V0IGZyb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZSB8fCB0aGlzLmlkO1xuICB9XG59O1xudmFyIGlucHV0JDEgPSBJbnB1dCQ0JDE7XG5JbnB1dCQ0JDEuZGVmYXVsdCA9IElucHV0JDQkMTtcbmlmICh0ZXJtaW5hbEhpZ2hsaWdodCQyICYmIHRlcm1pbmFsSGlnaGxpZ2h0JDIucmVnaXN0ZXJJbnB1dCkge1xuICB0ZXJtaW5hbEhpZ2hsaWdodCQyLnJlZ2lzdGVySW5wdXQoSW5wdXQkNCQxKTtcbn1cbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lciQzLCBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvciQzIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBkaXJuYW1lOiBkaXJuYW1lJDIsIHJlbGF0aXZlOiByZWxhdGl2ZSQxLCByZXNvbHZlOiByZXNvbHZlJDIsIHNlcDogc2VwJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IHBhdGhUb0ZpbGVVUkw6IHBhdGhUb0ZpbGVVUkwkMiB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IElucHV0JDMkMSA9IGlucHV0JDE7XG5sZXQgc291cmNlTWFwQXZhaWxhYmxlJDIgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyJDMgJiYgU291cmNlTWFwR2VuZXJhdG9yJDMpO1xubGV0IHBhdGhBdmFpbGFibGUkMiA9IEJvb2xlYW4oZGlybmFtZSQyICYmIHJlc29sdmUkMiAmJiByZWxhdGl2ZSQxICYmIHNlcCQxKTtcbmxldCBNYXBHZW5lcmF0b3IkMiQxID0gY2xhc3MgTWFwR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5naWZ5Miwgcm9vdDIsIG9wdHMsIGNzc1N0cmluZykge1xuICAgIHRoaXMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5MjtcbiAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fTtcbiAgICB0aGlzLnJvb3QgPSByb290MjtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuY3NzID0gY3NzU3RyaW5nO1xuICAgIHRoaXMub3JpZ2luYWxDU1MgPSBjc3NTdHJpbmc7XG4gICAgdGhpcy51c2VzRmlsZVVybHMgPSAhdGhpcy5tYXBPcHRzLmZyb20gJiYgdGhpcy5tYXBPcHRzLmFic29sdXRlO1xuICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tZW1vaXplZFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1lbW9pemVkVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkQW5ub3RhdGlvbigpIHtcbiAgICBsZXQgY29udGVudDtcbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICBjb250ZW50ID0gXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgdGhpcy50b0Jhc2U2NCh0aGlzLm1hcC50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbih0aGlzLm9wdHMudG8sIHRoaXMucm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm91dHB1dEZpbGUoKSArIFwiLm1hcFwiO1xuICAgIH1cbiAgICBsZXQgZW9sID0gXCJcXG5cIjtcbiAgICBpZiAodGhpcy5jc3MuaW5jbHVkZXMoXCJcXHJcXG5cIikpIGVvbCA9IFwiXFxyXFxuXCI7XG4gICAgdGhpcy5jc3MgKz0gZW9sICsgXCIvKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIGNvbnRlbnQgKyBcIiAqL1wiO1xuICB9XG4gIGFwcGx5UHJldk1hcHMoKSB7XG4gICAgZm9yIChsZXQgcHJldiBvZiB0aGlzLnByZXZpb3VzKCkpIHtcbiAgICAgIGxldCBmcm9tID0gdGhpcy50b1VybCh0aGlzLnBhdGgocHJldi5maWxlKSk7XG4gICAgICBsZXQgcm9vdDIgPSBwcmV2LnJvb3QgfHwgZGlybmFtZSQyKHByZXYuZmlsZSk7XG4gICAgICBsZXQgbWFwO1xuICAgICAgaWYgKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDMocHJldi50ZXh0KTtcbiAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcCA9IHByZXYuY29uc3VtZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZnJvbSwgdGhpcy50b1VybCh0aGlzLnBhdGgocm9vdDIpKSk7XG4gICAgfVxuICB9XG4gIGNsZWFyQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgbGV0IG5vZGUyO1xuICAgICAgZm9yIChsZXQgaTIgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICBub2RlMiA9IHRoaXMucm9vdC5ub2Rlc1tpMl07XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgY29udGludWU7XG4gICAgICAgIGlmIChub2RlMi50ZXh0LmluZGV4T2YoXCIjIHNvdXJjZU1hcHBpbmdVUkw9XCIpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvXFxuKj9cXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sIFwiXCIpO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgIGlmIChwYXRoQXZhaWxhYmxlJDIgJiYgc291cmNlTWFwQXZhaWxhYmxlJDIgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIChpMikgPT4ge1xuICAgICAgICByZXN1bHQyICs9IGkyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdDJdO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZU1hcCgpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpO1xuICAgICAgcHJldi5maWxlID0gdGhpcy5vdXRwdXRGaWxlKCk7XG4gICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvciQzLmZyb21Tb3VyY2VNYXAocHJldiwge1xuICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvciQzKHtcbiAgICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHsgY29sdW1uOiAwLCBsaW5lOiAxIH0sXG4gICAgICAgIG9yaWdpbmFsOiB7IGNvbHVtbjogMCwgbGluZTogMSB9LFxuICAgICAgICBzb3VyY2U6IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU291cmNlc0NvbnRlbnQoKSkgdGhpcy5zZXRTb3VyY2VzQ29udGVudCgpO1xuICAgIGlmICh0aGlzLnJvb3QgJiYgdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDApIHRoaXMuYXBwbHlQcmV2TWFwcygpO1xuICAgIGlmICh0aGlzLmlzQW5ub3RhdGlvbigpKSB0aGlzLmFkZEFubm90YXRpb24oKTtcbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt0aGlzLmNzcywgdGhpcy5tYXBdO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZVN0cmluZygpIHtcbiAgICB0aGlzLmNzcyA9IFwiXCI7XG4gICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yJDMoe1xuICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIGxldCBsaW5lID0gMTtcbiAgICBsZXQgY29sdW1uID0gMTtcbiAgICBsZXQgbm9Tb3VyY2UgPSBcIjxubyBzb3VyY2U+XCI7XG4gICAgbGV0IG1hcHBpbmcgPSB7XG4gICAgICBnZW5lcmF0ZWQ6IHsgY29sdW1uOiAwLCBsaW5lOiAwIH0sXG4gICAgICBvcmlnaW5hbDogeyBjb2x1bW46IDAsIGxpbmU6IDAgfSxcbiAgICAgIHNvdXJjZTogXCJcIlxuICAgIH07XG4gICAgbGV0IGxpbmVzLCBsYXN0O1xuICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKHN0ciwgbm9kZTIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMuY3NzICs9IHN0cjtcbiAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcImVuZFwiKSB7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5zdGFydCkge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxO1xuICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwic3RhcnRcIikge1xuICAgICAgICBsZXQgcCA9IG5vZGUyLnBhcmVudCB8fCB7IHJhd3M6IHt9IH07XG4gICAgICAgIGxldCBjaGlsZGxlc3MgPSBub2RlMi50eXBlID09PSBcImRlY2xcIiB8fCBub2RlMi50eXBlID09PSBcImF0cnVsZVwiICYmICFub2RlMi5ub2RlcztcbiAgICAgICAgaWYgKCFjaGlsZGxlc3MgfHwgbm9kZTIgIT09IHAubGFzdCB8fCBwLnJhd3Muc2VtaWNvbG9uKSB7XG4gICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5lbmQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMjtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0Fubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZSgoaTIpID0+IGkyLmFubm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5pbmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lO1xuICAgIH1cbiAgICBsZXQgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoKGkyKSA9PiBpMi5pbmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc01hcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMub3B0cy5tYXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBpc1NvdXJjZXNDb250ZW50KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKChpMikgPT4gaTIud2l0aENvbnRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG91dHB1dEZpbGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMudG8pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJ0by5jc3NcIjtcbiAgICB9XG4gIH1cbiAgcGF0aChmaWxlKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGU7XG4gICAgaWYgKGZpbGUuY2hhckNvZGVBdCgwKSA9PT0gNjApIHJldHVybiBmaWxlO1xuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZTtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZFBhdGhzLmdldChmaWxlKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSQyKHRoaXMub3B0cy50bykgOiBcIi5cIjtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmcm9tID0gZGlybmFtZSQyKHJlc29sdmUkMihmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IHJlbGF0aXZlJDEoZnJvbSwgZmlsZSk7XG4gICAgdGhpcy5tZW1vaXplZFBhdGhzLnNldChmaWxlLCBwYXRoKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBwcmV2aW91cygpIHtcbiAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzTWFwcyA9IFtdO1xuICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3Qud2Fsaygobm9kZTIpID0+IHtcbiAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5pbnB1dC5tYXApIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSBub2RlMi5zb3VyY2UuaW5wdXQubWFwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcy5pbmNsdWRlcyhtYXApKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldmlvdXNNYXBzLnB1c2gobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGlucHV0MiA9IG5ldyBJbnB1dCQzJDEodGhpcy5vcmlnaW5hbENTUywgdGhpcy5vcHRzKTtcbiAgICAgICAgaWYgKGlucHV0Mi5tYXApIHRoaXMucHJldmlvdXNNYXBzLnB1c2goaW5wdXQyLm1hcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzTWFwcztcbiAgfVxuICBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICBsZXQgYWxyZWFkeSA9IHt9O1xuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMucm9vdC53YWxrKChub2RlMikgPT4ge1xuICAgICAgICBpZiAobm9kZTIuc291cmNlKSB7XG4gICAgICAgICAgbGV0IGZyb20gPSBub2RlMi5zb3VyY2UuaW5wdXQuZnJvbTtcbiAgICAgICAgICBpZiAoZnJvbSAmJiAhYWxyZWFkeVtmcm9tXSkge1xuICAgICAgICAgICAgYWxyZWFkeVtmcm9tXSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZnJvbVVybCA9IHRoaXMudXNlc0ZpbGVVcmxzID8gdGhpcy50b0ZpbGVVcmwoZnJvbSkgOiB0aGlzLnRvVXJsKHRoaXMucGF0aChmcm9tKSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb21VcmwsIG5vZGUyLnNvdXJjZS5pbnB1dC5jc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCI7XG4gICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb20sIHRoaXMuY3NzKTtcbiAgICB9XG4gIH1cbiAgc291cmNlUGF0aChub2RlMikge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5tYXBPcHRzLmZyb20pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51c2VzRmlsZVVybHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRmlsZVVybChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMucGF0aChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSkpO1xuICAgIH1cbiAgfVxuICB0b0Jhc2U2NChzdHIpIHtcbiAgICBpZiAoQnVmZmVyKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgfVxuICB9XG4gIHRvRmlsZVVybChwYXRoKSB7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5nZXQocGF0aCk7XG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICBpZiAocGF0aFRvRmlsZVVSTCQyKSB7XG4gICAgICBsZXQgZmlsZVVSTCA9IHBhdGhUb0ZpbGVVUkwkMihwYXRoKS50b1N0cmluZygpO1xuICAgICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzLnNldChwYXRoLCBmaWxlVVJMKTtcbiAgICAgIHJldHVybiBmaWxlVVJMO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiYG1hcC5hYnNvbHV0ZWAgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRvVXJsKHBhdGgpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZFVSTHMuZ2V0KHBhdGgpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgaWYgKHNlcCQxID09PSBcIlxcXFxcIikge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gICAgfVxuICAgIGxldCB1cmwgPSBlbmNvZGVVUkkocGF0aCkucmVwbGFjZSgvWyM/XS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgIHRoaXMubWVtb2l6ZWRVUkxzLnNldChwYXRoLCB1cmwpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbn07XG52YXIgbWFwR2VuZXJhdG9yJDEgPSBNYXBHZW5lcmF0b3IkMiQxO1xubGV0IE5vZGUkMiQxID0gbm9kZSQxO1xubGV0IENvbW1lbnQkNCQxID0gY2xhc3MgQ29tbWVudCBleHRlbmRzIE5vZGUkMiQxIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJjb21tZW50XCI7XG4gIH1cbn07XG52YXIgY29tbWVudCQxID0gQ29tbWVudCQ0JDE7XG5Db21tZW50JDQkMS5kZWZhdWx0ID0gQ29tbWVudCQ0JDE7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDEkMSwgbXk6IG15JDEkMSB9ID0gc3ltYm9scyQxO1xubGV0IERlY2xhcmF0aW9uJDMkMSA9IGRlY2xhcmF0aW9uJDE7XG5sZXQgQ29tbWVudCQzJDEgPSBjb21tZW50JDE7XG5sZXQgTm9kZSQxJDEgPSBub2RlJDE7XG5sZXQgcGFyc2UkNCQxLCBSdWxlJDQkMSwgQXRSdWxlJDQkMSwgUm9vdCQ2JDE7XG5mdW5jdGlvbiBjbGVhblNvdXJjZSQxKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5tYXAoKGkyKSA9PiB7XG4gICAgaWYgKGkyLm5vZGVzKSBpMi5ub2RlcyA9IGNsZWFuU291cmNlJDEoaTIubm9kZXMpO1xuICAgIGRlbGV0ZSBpMi5zb3VyY2U7XG4gICAgcmV0dXJuIGkyO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcmtEaXJ0eVVwJDEobm9kZTIpIHtcbiAgbm9kZTJbaXNDbGVhbiQxJDFdID0gZmFsc2U7XG4gIGlmIChub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgZm9yIChsZXQgaTIgb2Ygbm9kZTIucHJveHlPZi5ub2Rlcykge1xuICAgICAgbWFya0RpcnR5VXAkMShpMik7XG4gICAgfVxuICB9XG59XG5sZXQgQ29udGFpbmVyJDckMSA9IGNsYXNzIENvbnRhaW5lciBleHRlbmRzIE5vZGUkMSQxIHtcbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKG5vZGUyKTtcbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICBzdXBlci5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBub2RlMiBvZiB0aGlzLm5vZGVzKSBub2RlMi5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgIH1cbiAgfVxuICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpO1xuICAgIGxldCBpbmRleDIsIHJlc3VsdDI7XG4gICAgd2hpbGUgKHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPCB0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKHRoaXMucHJveHlPZi5ub2Rlc1tpbmRleDJdLCBpbmRleDIpO1xuICAgICAgaWYgKHJlc3VsdDIgPT09IGZhbHNlKSBicmVhaztcbiAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKTtcbiAgfVxuICBnZXRJdGVyYXRvcigpIHtcbiAgICBpZiAoIXRoaXMubGFzdEVhY2gpIHRoaXMubGFzdEVhY2ggPSAwO1xuICAgIGlmICghdGhpcy5pbmRleGVzKSB0aGlzLmluZGV4ZXMgPSB7fTtcbiAgICB0aGlzLmxhc3RFYWNoICs9IDE7XG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5sYXN0RWFjaDtcbiAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdID0gMDtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG4gIH1cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5vZGUyW3Byb3BdKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZWFjaFwiIHx8IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiICYmIHByb3Auc3RhcnRzV2l0aChcIndhbGtcIikpIHtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXShcbiAgICAgICAgICAgICAgLi4uYXJncy5tYXAoKGkyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKGNoaWxkLCBpbmRleDIpID0+IGkyKGNoaWxkLnRvUHJveHkoKSwgaW5kZXgyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImV2ZXJ5XCIgfHwgcHJvcCA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oXG4gICAgICAgICAgICAgIChjaGlsZCwgLi4ub3RoZXIpID0+IGNiKGNoaWxkLnRvUHJveHkoKSwgLi4ub3RoZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTIubm9kZXMubWFwKChpMikgPT4gaTIudG9Qcm94eSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImZpcnN0XCIgfHwgcHJvcCA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0udG9Qcm94eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGlmIChwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwic2VsZWN0b3JcIikge1xuICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaW5kZXgoY2hpbGQpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiKSByZXR1cm4gY2hpbGQ7XG4gICAgaWYgKGNoaWxkLnByb3h5T2YpIGNoaWxkID0gY2hpbGQucHJveHlPZjtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICB9XG4gIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICBsZXQgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdKS5yZXZlcnNlKCk7XG4gICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXggKyAxLCAwLCBub2RlMik7XG4gICAgbGV0IGluZGV4MjtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICBpZiAoZXhpc3RJbmRleCA8IGluZGV4Mikge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluc2VydEJlZm9yZShleGlzdCwgYWRkKSB7XG4gICAgbGV0IGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBsZXQgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyBcInByZXBlbmRcIiA6IGZhbHNlO1xuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdLCB0eXBlKS5yZXZlcnNlKCk7XG4gICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXgsIDAsIG5vZGUyKTtcbiAgICBsZXQgaW5kZXgyO1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIGlmIChleGlzdEluZGV4IDw9IGluZGV4Mikge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5vcm1hbGl6ZShub2Rlcywgc2FtcGxlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbm9kZXMgPSBjbGVhblNvdXJjZSQxKHBhcnNlJDQkMShub2Rlcykubm9kZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBub2RlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vZGVzLnZhbHVlID0gU3RyaW5nKG5vZGVzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gW25ldyBEZWNsYXJhdGlvbiQzJDEobm9kZXMpXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzLnNlbGVjdG9yKSB7XG4gICAgICBub2RlcyA9IFtuZXcgUnVsZSQ0JDEobm9kZXMpXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzLm5hbWUpIHtcbiAgICAgIG5vZGVzID0gW25ldyBBdFJ1bGUkNCQxKG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy50ZXh0KSB7XG4gICAgICBub2RlcyA9IFtuZXcgQ29tbWVudCQzJDEobm9kZXMpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZCA9IG5vZGVzLm1hcCgoaTIpID0+IHtcbiAgICAgIGlmICghaTJbbXkkMSQxXSkgQ29udGFpbmVyLnJlYnVpbGQoaTIpO1xuICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgIGlmIChpMltpc0NsZWFuJDEkMV0pIG1hcmtEaXJ0eVVwJDEoaTIpO1xuICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoc2FtcGxlICYmIHR5cGVvZiBzYW1wbGUucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkyLnBhcmVudCA9IHRoaXMucHJveHlPZjtcbiAgICAgIHJldHVybiBpMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICB9XG4gIHByZXBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsIFwicHJlcGVuZFwiKS5yZXZlcnNlKCk7XG4gICAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnVuc2hpZnQobm9kZTIpO1xuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSB0aGlzLmluZGV4ZXNbaWRdICsgbm9kZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHB1c2goY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVBbGwoKSB7XG4gICAgZm9yIChsZXQgbm9kZTIgb2YgdGhpcy5wcm94eU9mLm5vZGVzKSBub2RlMi5wYXJlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eU9mLm5vZGVzID0gW107XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgdGhpcy5wcm94eU9mLm5vZGVzW2NoaWxkXS5wYXJlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShjaGlsZCwgMSk7XG4gICAgbGV0IGluZGV4MjtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICBpZiAoaW5kZXgyID49IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlcGxhY2VWYWx1ZXMocGF0dGVybiwgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIHRoaXMud2Fsa0RlY2xzKChkZWNsKSA9PiB7XG4gICAgICBpZiAob3B0cy5wcm9wcyAmJiAhb3B0cy5wcm9wcy5pbmNsdWRlcyhkZWNsLnByb3ApKSByZXR1cm47XG4gICAgICBpZiAob3B0cy5mYXN0ICYmICFkZWNsLnZhbHVlLmluY2x1ZGVzKG9wdHMuZmFzdCkpIHJldHVybjtcbiAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UocGF0dGVybiwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc29tZShjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbik7XG4gIH1cbiAgd2FsayhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVhY2goKGNoaWxkLCBpMikgPT4ge1xuICAgICAgbGV0IHJlc3VsdDI7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQyID0gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRocm93IGNoaWxkLmFkZFRvRXJyb3IoZTIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdDIgIT09IGZhbHNlICYmIGNoaWxkLndhbGspIHtcbiAgICAgICAgcmVzdWx0MiA9IGNoaWxkLndhbGsoY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfSk7XG4gIH1cbiAgd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgbmFtZS50ZXN0KGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIGNoaWxkLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2Fsa0NvbW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2Fsa0RlY2xzKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBwcm9wO1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb3AgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgcHJvcC50ZXN0KGNoaWxkLnByb3ApKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBjaGlsZC5wcm9wID09PSBwcm9wKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhbGtSdWxlcyhzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIHNlbGVjdG9yLnRlc3QoY2hpbGQuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpcnN0KCkge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbMF07XG4gIH1cbiAgZ2V0IGxhc3QoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1t0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoIC0gMV07XG4gIH1cbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUGFyc2UgPSAoZGVwZW5kYW50KSA9PiB7XG4gIHBhcnNlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUnVsZSA9IChkZXBlbmRhbnQpID0+IHtcbiAgUnVsZSQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDckMS5yZWdpc3RlckF0UnVsZSA9IChkZXBlbmRhbnQpID0+IHtcbiAgQXRSdWxlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUm9vdCA9IChkZXBlbmRhbnQpID0+IHtcbiAgUm9vdCQ2JDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGNvbnRhaW5lciQxID0gQ29udGFpbmVyJDckMTtcbkNvbnRhaW5lciQ3JDEuZGVmYXVsdCA9IENvbnRhaW5lciQ3JDE7XG5Db250YWluZXIkNyQxLnJlYnVpbGQgPSAobm9kZTIpID0+IHtcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0JDEucHJvdG90eXBlKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJ1bGVcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUnVsZSQ0JDEucHJvdG90eXBlKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgRGVjbGFyYXRpb24kMyQxLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMyQxLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJvb3QkNiQxLnByb3RvdHlwZSk7XG4gIH1cbiAgbm9kZTJbbXkkMSQxXSA9IHRydWU7XG4gIGlmIChub2RlMi5ub2Rlcykge1xuICAgIG5vZGUyLm5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBDb250YWluZXIkNyQxLnJlYnVpbGQoY2hpbGQpO1xuICAgIH0pO1xuICB9XG59O1xubGV0IENvbnRhaW5lciQ2JDEgPSBjb250YWluZXIkMTtcbmxldCBMYXp5UmVzdWx0JDQkMSwgUHJvY2Vzc29yJDMkMTtcbmxldCBEb2N1bWVudCQzJDEgPSBjbGFzcyBEb2N1bWVudDIgZXh0ZW5kcyBDb250YWluZXIkNiQxIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcih7IHR5cGU6IFwiZG9jdW1lbnRcIiwgLi4uZGVmYXVsdHMgfSk7XG4gICAgaWYgKCF0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuICB9XG4gIHRvUmVzdWx0KG9wdHMgPSB7fSkge1xuICAgIGxldCBsYXp5ID0gbmV3IExhenlSZXN1bHQkNCQxKG5ldyBQcm9jZXNzb3IkMyQxKCksIHRoaXMsIG9wdHMpO1xuICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICB9XG59O1xuRG9jdW1lbnQkMyQxLnJlZ2lzdGVyTGF6eVJlc3VsdCA9IChkZXBlbmRhbnQpID0+IHtcbiAgTGF6eVJlc3VsdCQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuRG9jdW1lbnQkMyQxLnJlZ2lzdGVyUHJvY2Vzc29yID0gKGRlcGVuZGFudCkgPT4ge1xuICBQcm9jZXNzb3IkMyQxID0gZGVwZW5kYW50O1xufTtcbnZhciBkb2N1bWVudCQxJDEgPSBEb2N1bWVudCQzJDE7XG5Eb2N1bWVudCQzJDEuZGVmYXVsdCA9IERvY3VtZW50JDMkMTtcbmxldCBwcmludGVkJDEgPSB7fTtcbnZhciB3YXJuT25jZSQyJDEgPSBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gIGlmIChwcmludGVkJDFbbWVzc2FnZV0pIHJldHVybjtcbiAgcHJpbnRlZCQxW21lc3NhZ2VdID0gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfVxufTtcbmxldCBXYXJuaW5nJDIkMSA9IGNsYXNzIFdhcm5pbmcge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSBcIndhcm5pbmdcIjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGlmIChvcHRzLm5vZGUgJiYgb3B0cy5ub2RlLnNvdXJjZSkge1xuICAgICAgbGV0IHJhbmdlID0gb3B0cy5ub2RlLnJhbmdlQnkob3B0cyk7XG4gICAgICB0aGlzLmxpbmUgPSByYW5nZS5zdGFydC5saW5lO1xuICAgICAgdGhpcy5jb2x1bW4gPSByYW5nZS5zdGFydC5jb2x1bW47XG4gICAgICB0aGlzLmVuZExpbmUgPSByYW5nZS5lbmQubGluZTtcbiAgICAgIHRoaXMuZW5kQ29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICB9XG4gICAgZm9yIChsZXQgb3B0IGluIG9wdHMpIHRoaXNbb3B0XSA9IG9wdHNbb3B0XTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmVycm9yKHRoaXMudGV4dCwge1xuICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgd29yZDogdGhpcy53b3JkXG4gICAgICB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArIFwiOiBcIiArIHRoaXMudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxufTtcbnZhciB3YXJuaW5nJDEgPSBXYXJuaW5nJDIkMTtcbldhcm5pbmckMiQxLmRlZmF1bHQgPSBXYXJuaW5nJDIkMTtcbmxldCBXYXJuaW5nJDEkMSA9IHdhcm5pbmckMTtcbmxldCBSZXN1bHQkMyQxID0gY2xhc3MgUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpIHtcbiAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzO1xuICB9XG4gIHdhcm4odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBvcHRzLnBsdWdpbiA9IHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2FybmluZzIgPSBuZXcgV2FybmluZyQxJDEodGV4dCwgb3B0cyk7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKHdhcm5pbmcyKTtcbiAgICByZXR1cm4gd2FybmluZzI7XG4gIH1cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKChpMikgPT4gaTIudHlwZSA9PT0gXCJ3YXJuaW5nXCIpO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNzcztcbiAgfVxufTtcbnZhciByZXN1bHQkMSA9IFJlc3VsdCQzJDE7XG5SZXN1bHQkMyQxLmRlZmF1bHQgPSBSZXN1bHQkMyQxO1xuY29uc3QgU0lOR0xFX1FVT1RFJDEgPSBcIidcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgRE9VQkxFX1FVT1RFJDEgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBCQUNLU0xBU0gkMSA9IFwiXFxcXFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTTEFTSCQxID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE5FV0xJTkUkMSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNQQUNFJDEgPSBcIiBcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgRkVFRCQxID0gXCJcXGZcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgVEFCJDEgPSBcIlx0XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENSJDEgPSBcIlxcclwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUEVOX1NRVUFSRSQxID0gXCJbXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX1NRVUFSRSQxID0gXCJdXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fUEFSRU5USEVTRVMkMSA9IFwiKFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDTE9TRV9QQVJFTlRIRVNFUyQxID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fQ1VSTFkkMSA9IFwie1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDTE9TRV9DVVJMWSQxID0gXCJ9XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNFTUlDT0xPTiQxID0gXCI7XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEFTVEVSSVNLJDEgPSBcIipcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ09MT04kMSA9IFwiOlwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBBVCQxID0gXCJAXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFJFX0FUX0VORCQxID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nO1xuY29uc3QgUkVfV09SRF9FTkQkMSA9IC9bXFx0XFxuXFxmXFxyICFcIiMnKCk6O0BbXFxcXFxcXXt9XXxcXC8oPz1cXCopL2c7XG5jb25zdCBSRV9CQURfQlJBQ0tFVCQxID0gLy5bXFxyXFxuXCInKC9cXFxcXS87XG5jb25zdCBSRV9IRVhfRVNDQVBFJDEgPSAvW1xcZGEtZl0vaTtcbnZhciB0b2tlbml6ZSQxID0gZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0Miwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjc3MgPSBpbnB1dDIuY3NzLnZhbHVlT2YoKTtcbiAgbGV0IGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzO1xuICBsZXQgY29kZSwgbmV4dCwgcXVvdGUsIGNvbnRlbnQsIGVzY2FwZTtcbiAgbGV0IGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbjIsIGN1cnJlbnRUb2tlbjtcbiAgbGV0IGxlbmd0aCA9IGNzcy5sZW5ndGg7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgYnVmZmVyID0gW107XG4gIGxldCByZXR1cm5lZCA9IFtdO1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICB0aHJvdyBpbnB1dDIuZXJyb3IoXCJVbmNsb3NlZCBcIiArIHdoYXQsIHBvcyk7XG4gIH1cbiAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBuZXh0VG9rZW4ob3B0cykge1xuICAgIGlmIChyZXR1cm5lZC5sZW5ndGgpIHJldHVybiByZXR1cm5lZC5wb3AoKTtcbiAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuO1xuICAgIGxldCBpZ25vcmVVbmNsb3NlZCA9IG9wdHMgPyBvcHRzLmlnbm9yZVVuY2xvc2VkIDogZmFsc2U7XG4gICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIE5FV0xJTkUkMTpcbiAgICAgIGNhc2UgU1BBQ0UkMTpcbiAgICAgIGNhc2UgVEFCJDE6XG4gICAgICBjYXNlIENSJDE6XG4gICAgICBjYXNlIEZFRUQkMToge1xuICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgICAgfSB3aGlsZSAoY29kZSA9PT0gU1BBQ0UkMSB8fCBjb2RlID09PSBORVdMSU5FJDEgfHwgY29kZSA9PT0gVEFCJDEgfHwgY29kZSA9PT0gQ1IkMSB8fCBjb2RlID09PSBGRUVEJDEpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJzcGFjZVwiLCBjc3Muc2xpY2UocG9zLCBuZXh0KV07XG4gICAgICAgIHBvcyA9IG5leHQgLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgT1BFTl9TUVVBUkUkMTpcbiAgICAgIGNhc2UgQ0xPU0VfU1FVQVJFJDE6XG4gICAgICBjYXNlIE9QRU5fQ1VSTFkkMTpcbiAgICAgIGNhc2UgQ0xPU0VfQ1VSTFkkMTpcbiAgICAgIGNhc2UgQ09MT04kMTpcbiAgICAgIGNhc2UgU0VNSUNPTE9OJDE6XG4gICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTJDE6IHtcbiAgICAgICAgbGV0IGNvbnRyb2xDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW2NvbnRyb2xDaGFyLCBjb250cm9sQ2hhciwgcG9zXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIE9QRU5fUEFSRU5USEVTRVMkMToge1xuICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6IFwiXCI7XG4gICAgICAgIG4yID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgIGlmIChwcmV2ID09PSBcInVybFwiICYmIG4yICE9PSBTSU5HTEVfUVVPVEUkMSAmJiBuMiAhPT0gRE9VQkxFX1FVT1RFJDEgJiYgbjIgIT09IFNQQUNFJDEgJiYgbjIgIT09IE5FV0xJTkUkMSAmJiBuMiAhPT0gVEFCJDEgJiYgbjIgIT09IEZFRUQkMSAmJiBuMiAhPT0gQ1IkMSkge1xuICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJicmFja2V0XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gkMSkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcImJyYWNrZXRzXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgcG9zICsgMSk7XG4gICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShwb3MsIG5leHQgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gLTEgfHwgUkVfQkFEX0JSQUNLRVQkMS50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCIoXCIsIFwiKFwiLCBwb3NdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJicmFja2V0c1wiLCBjb250ZW50LCBwb3MsIG5leHRdO1xuICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFNJTkdMRV9RVU9URSQxOlxuICAgICAgY2FzZSBET1VCTEVfUVVPVEUkMToge1xuICAgICAgICBxdW90ZSA9IGNvZGUgPT09IFNJTkdMRV9RVU9URSQxID8gXCInXCIgOiAnXCInO1xuICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCQxKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJzdHJpbmdcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgQVQkMToge1xuICAgICAgICBSRV9BVF9FTkQkMS5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICBSRV9BVF9FTkQkMS50ZXN0KGNzcyk7XG4gICAgICAgIGlmIChSRV9BVF9FTkQkMS5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IFJFX0FUX0VORCQxLmxhc3RJbmRleCAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRva2VuID0gW1wiYXQtd29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBCQUNLU0xBU0gkMToge1xuICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBCQUNLU0xBU0gkMSkge1xuICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICB9XG4gICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICAgIGlmIChlc2NhcGUgJiYgY29kZSAhPT0gU0xBU0gkMSAmJiBjb2RlICE9PSBTUEFDRSQxICYmIGNvZGUgIT09IE5FV0xJTkUkMSAmJiBjb2RlICE9PSBUQUIkMSAmJiBjb2RlICE9PSBDUiQxICYmIGNvZGUgIT09IEZFRUQkMSkge1xuICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICBpZiAoUkVfSEVYX0VTQ0FQRSQxLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgIHdoaWxlIChSRV9IRVhfRVNDQVBFJDEudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gU1BBQ0UkMSkge1xuICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcIndvcmRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IFNMQVNIJDEgJiYgY3NzLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IEFTVEVSSVNLJDEpIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIqL1wiLCBwb3MgKyAyKSArIDE7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcImNvbW1lbnRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgIFJFX1dPUkRfRU5EJDEudGVzdChjc3MpO1xuICAgICAgICAgIGlmIChSRV9XT1JEX0VORCQxLmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJ3b3JkXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgICBidWZmZXIucHVzaChjdXJyZW50VG9rZW4pO1xuICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHBvcysrO1xuICAgIHJldHVybiBjdXJyZW50VG9rZW47XG4gIH1cbiAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgIHJldHVybmVkLnB1c2godG9rZW4pO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFjayxcbiAgICBlbmRPZkZpbGUsXG4gICAgbmV4dFRva2VuLFxuICAgIHBvc2l0aW9uXG4gIH07XG59O1xubGV0IENvbnRhaW5lciQ1JDEgPSBjb250YWluZXIkMTtcbmxldCBBdFJ1bGUkMyQxID0gY2xhc3MgQXRSdWxlIGV4dGVuZHMgQ29udGFpbmVyJDUkMSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwiYXRydWxlXCI7XG4gIH1cbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICByZXR1cm4gc3VwZXIuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgfVxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICByZXR1cm4gc3VwZXIucHJlcGVuZCguLi5jaGlsZHJlbik7XG4gIH1cbn07XG52YXIgYXRSdWxlJDEgPSBBdFJ1bGUkMyQxO1xuQXRSdWxlJDMkMS5kZWZhdWx0ID0gQXRSdWxlJDMkMTtcbkNvbnRhaW5lciQ1JDEucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlJDMkMSk7XG5sZXQgQ29udGFpbmVyJDQkMSA9IGNvbnRhaW5lciQxO1xubGV0IExhenlSZXN1bHQkMyQxLCBQcm9jZXNzb3IkMiQxO1xubGV0IFJvb3QkNSQxID0gY2xhc3MgUm9vdCBleHRlbmRzIENvbnRhaW5lciQ0JDEge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcInJvb3RcIjtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgfVxuICBub3JtYWxpemUoY2hpbGQsIHNhbXBsZSwgdHlwZSkge1xuICAgIGxldCBub2RlcyA9IHN1cGVyLm5vcm1hbGl6ZShjaGlsZCk7XG4gICAgaWYgKHNhbXBsZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFwicHJlcGVuZFwiKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5maXJzdCAhPT0gc2FtcGxlKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB7XG4gICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIHJlbW92ZUNoaWxkKGNoaWxkLCBpZ25vcmUpIHtcbiAgICBsZXQgaW5kZXgyID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgaWYgKCFpZ25vcmUgJiYgaW5kZXgyID09PSAwICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbaW5kZXgyXS5yYXdzLmJlZm9yZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICB0b1Jlc3VsdChvcHRzID0ge30pIHtcbiAgICBsZXQgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDMkMShuZXcgUHJvY2Vzc29yJDIkMSgpLCB0aGlzLCBvcHRzKTtcbiAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgfVxufTtcblJvb3QkNSQxLnJlZ2lzdGVyTGF6eVJlc3VsdCA9IChkZXBlbmRhbnQpID0+IHtcbiAgTGF6eVJlc3VsdCQzJDEgPSBkZXBlbmRhbnQ7XG59O1xuUm9vdCQ1JDEucmVnaXN0ZXJQcm9jZXNzb3IgPSAoZGVwZW5kYW50KSA9PiB7XG4gIFByb2Nlc3NvciQyJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIHJvb3QkMSA9IFJvb3QkNSQxO1xuUm9vdCQ1JDEuZGVmYXVsdCA9IFJvb3QkNSQxO1xuQ29udGFpbmVyJDQkMS5yZWdpc3RlclJvb3QoUm9vdCQ1JDEpO1xubGV0IGxpc3QkMiQxID0ge1xuICBjb21tYShzdHJpbmcpIHtcbiAgICByZXR1cm4gbGlzdCQyJDEuc3BsaXQoc3RyaW5nLCBbXCIsXCJdLCB0cnVlKTtcbiAgfSxcbiAgc3BhY2Uoc3RyaW5nKSB7XG4gICAgbGV0IHNwYWNlcyA9IFtcIiBcIiwgXCJcXG5cIiwgXCJcdFwiXTtcbiAgICByZXR1cm4gbGlzdCQyJDEuc3BsaXQoc3RyaW5nLCBzcGFjZXMpO1xuICB9LFxuICBzcGxpdChzdHJpbmcsIHNlcGFyYXRvcnMsIGxhc3QpIHtcbiAgICBsZXQgYXJyYXkgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9IFwiXCI7XG4gICAgbGV0IHNwbGl0ID0gZmFsc2U7XG4gICAgbGV0IGZ1bmMgPSAwO1xuICAgIGxldCBpblF1b3RlID0gZmFsc2U7XG4gICAgbGV0IHByZXZRdW90ZSA9IFwiXCI7XG4gICAgbGV0IGVzY2FwZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGxldHRlciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgZXNjYXBlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZSkge1xuICAgICAgICBpZiAobGV0dGVyID09PSBwcmV2UXVvdGUpIHtcbiAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnXCInIHx8IGxldHRlciA9PT0gXCInXCIpIHtcbiAgICAgICAgaW5RdW90ZSA9IHRydWU7XG4gICAgICAgIHByZXZRdW90ZSA9IGxldHRlcjtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIihcIikge1xuICAgICAgICBmdW5jICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIpXCIpIHtcbiAgICAgICAgaWYgKGZ1bmMgPiAwKSBmdW5jIC09IDE7XG4gICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09IDApIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvcnMuaW5jbHVkZXMobGV0dGVyKSkgc3BsaXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgY3VycmVudCA9IFwiXCI7XG4gICAgICAgIHNwbGl0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGxldHRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3QgfHwgY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59O1xudmFyIGxpc3RfMSQxID0gbGlzdCQyJDE7XG5saXN0JDIkMS5kZWZhdWx0ID0gbGlzdCQyJDE7XG5sZXQgQ29udGFpbmVyJDMkMSA9IGNvbnRhaW5lciQxO1xubGV0IGxpc3QkMSQxID0gbGlzdF8xJDE7XG5sZXQgUnVsZSQzJDEgPSBjbGFzcyBSdWxlIGV4dGVuZHMgQ29udGFpbmVyJDMkMSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwicnVsZVwiO1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICB9XG4gIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgcmV0dXJuIGxpc3QkMSQxLmNvbW1hKHRoaXMuc2VsZWN0b3IpO1xuICB9XG4gIHNldCBzZWxlY3RvcnModmFsdWVzKSB7XG4gICAgbGV0IG1hdGNoID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IubWF0Y2goLyxcXHMqLykgOiBudWxsO1xuICAgIGxldCBzZXAyID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiLFwiICsgdGhpcy5yYXcoXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICB0aGlzLnNlbGVjdG9yID0gdmFsdWVzLmpvaW4oc2VwMik7XG4gIH1cbn07XG52YXIgcnVsZSQxID0gUnVsZSQzJDE7XG5SdWxlJDMkMS5kZWZhdWx0ID0gUnVsZSQzJDE7XG5Db250YWluZXIkMyQxLnJlZ2lzdGVyUnVsZShSdWxlJDMkMSk7XG5sZXQgRGVjbGFyYXRpb24kMiQxID0gZGVjbGFyYXRpb24kMTtcbmxldCB0b2tlbml6ZXIyJDEgPSB0b2tlbml6ZSQxO1xubGV0IENvbW1lbnQkMiQxID0gY29tbWVudCQxO1xubGV0IEF0UnVsZSQyJDEgPSBhdFJ1bGUkMTtcbmxldCBSb290JDQkMSA9IHJvb3QkMTtcbmxldCBSdWxlJDIkMSA9IHJ1bGUkMTtcbmNvbnN0IFNBRkVfQ09NTUVOVF9ORUlHSEJPUiQxID0ge1xuICBlbXB0eTogdHJ1ZSxcbiAgc3BhY2U6IHRydWVcbn07XG5mdW5jdGlvbiBmaW5kTGFzdFdpdGhQb3NpdGlvbiQxKHRva2Vucykge1xuICBmb3IgKGxldCBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgbGV0IHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICBsZXQgcG9zID0gdG9rZW5bM10gfHwgdG9rZW5bMl07XG4gICAgaWYgKHBvcykgcmV0dXJuIHBvcztcbiAgfVxufVxubGV0IFBhcnNlciQxJDEgPSBjbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dDIpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgIHRoaXMucm9vdCA9IG5ldyBSb290JDQkMSgpO1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucm9vdDtcbiAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB0aGlzLmNyZWF0ZVRva2VuaXplcigpO1xuICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7IGlucHV0OiBpbnB1dDIsIHN0YXJ0OiB7IGNvbHVtbjogMSwgbGluZTogMSwgb2Zmc2V0OiAwIH0gfTtcbiAgfVxuICBhdHJ1bGUodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgQXRSdWxlJDIkMSgpO1xuICAgIG5vZGUyLm5hbWUgPSB0b2tlblsxXS5zbGljZSgxKTtcbiAgICBpZiAobm9kZTIubmFtZSA9PT0gXCJcIikge1xuICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbik7XG4gICAgfVxuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCBzaGlmdDtcbiAgICBsZXQgbGFzdCA9IGZhbHNlO1xuICAgIGxldCBvcGVuID0gZmFsc2U7XG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBwcmV2ID0gcGFyYW1zW3NoaWZ0XTtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIHByZXZbMF0gPT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICBwcmV2ID0gcGFyYW1zWy0tc2hpZnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKTtcbiAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHBhcmFtcyk7XG4gICAgICB0aGlzLnJhdyhub2RlMiwgXCJwYXJhbXNcIiwgcGFyYW1zKTtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSBcIlwiO1xuICAgICAgbm9kZTIucGFyYW1zID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9XG4gIH1cbiAgY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpO1xuICAgIGlmIChjb2xvbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBsZXQgZm91bmRlZCA9IDA7XG4gICAgbGV0IHRva2VuO1xuICAgIGZvciAobGV0IGogPSBjb2xvbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgIGZvdW5kZWQgKz0gMTtcbiAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJNaXNzZWQgc2VtaWNvbG9uXCIsXG4gICAgICB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXVxuICAgICk7XG4gIH1cbiAgY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGJyYWNrZXRzID0gMDtcbiAgICBsZXQgdG9rZW4sIHR5cGUsIHByZXY7XG4gICAgZm9yIChsZXQgW2kyLCBlbGVtZW50XSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICB0b2tlbiA9IGVsZW1lbnQ7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIpIHtcbiAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIilcIikge1xuICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09IFwid29yZFwiICYmIHByZXZbMV0gPT09IFwicHJvZ2lkXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXYgPSB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbW1lbnQodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgQ29tbWVudCQyJDEoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICBsZXQgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKTtcbiAgICBpZiAoL15cXHMqJC8udGVzdCh0ZXh0KSkge1xuICAgICAgbm9kZTIudGV4dCA9IFwiXCI7XG4gICAgICBub2RlMi5yYXdzLmxlZnQgPSB0ZXh0O1xuICAgICAgbm9kZTIucmF3cy5yaWdodCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXRjaCA9IHRleHQubWF0Y2goL14oXFxzKikoW15dKlxcUykoXFxzKikkLyk7XG4gICAgICBub2RlMi50ZXh0ID0gbWF0Y2hbMl07XG4gICAgICBub2RlMi5yYXdzLmxlZnQgPSBtYXRjaFsxXTtcbiAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBtYXRjaFszXTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlVG9rZW5pemVyKCkge1xuICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyMiQxKHRoaXMuaW5wdXQpO1xuICB9XG4gIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCBub2RlMiA9IG5ldyBEZWNsYXJhdGlvbiQyJDEoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgbGV0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0WzBdID09PSBcIjtcIikge1xuICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgdG9rZW5zLnBvcCgpO1xuICAgIH1cbiAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihcbiAgICAgIGxhc3RbM10gfHwgbGFzdFsyXSB8fCBmaW5kTGFzdFdpdGhQb3NpdGlvbiQxKHRva2VucylcbiAgICApO1xuICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgd2hpbGUgKHRva2Vuc1swXVswXSAhPT0gXCJ3b3JkXCIpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICB9XG4gICAgbm9kZTIuc291cmNlLnN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlbnNbMF1bMl0pO1xuICAgIG5vZGUyLnByb3AgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsZXQgdHlwZSA9IHRva2Vuc1swXVswXTtcbiAgICAgIGlmICh0eXBlID09PSBcIjpcIiB8fCB0eXBlID09PSBcInNwYWNlXCIgfHwgdHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlMi5wcm9wICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgIGxldCB0b2tlbjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgIGlmICh0b2tlblswXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gXCJ3b3JkXCIgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICB0aGlzLnVua25vd25Xb3JkKFt0b2tlbl0pO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUyLnByb3BbMF0gPT09IFwiX1wiIHx8IG5vZGUyLnByb3BbMF0gPT09IFwiKlwiKSB7XG4gICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSBub2RlMi5wcm9wWzBdO1xuICAgICAgbm9kZTIucHJvcCA9IG5vZGUyLnByb3Auc2xpY2UoMSk7XG4gICAgfVxuICAgIGxldCBmaXJzdFNwYWNlcyA9IFtdO1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICBmaXJzdFNwYWNlcy5wdXNoKHRva2Vucy5zaGlmdCgpKTtcbiAgICB9XG4gICAgdGhpcy5wcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO1xuICAgIGZvciAobGV0IGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSBcIiFpbXBvcnRhbnRcIikge1xuICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy5zdHJpbmdGcm9tKHRva2VucywgaTIpO1xuICAgICAgICBzdHJpbmcgPSB0aGlzLnNwYWNlc0Zyb21FbmQodG9rZW5zKSArIHN0cmluZztcbiAgICAgICAgaWYgKHN0cmluZyAhPT0gXCIgIWltcG9ydGFudFwiKSBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cmluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiaW1wb3J0YW50XCIpIHtcbiAgICAgICAgbGV0IGNhY2hlID0gdG9rZW5zLnNsaWNlKDApO1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkyOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgbGV0IHR5cGUgPSBjYWNoZVtqXVswXTtcbiAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCAmJiB0eXBlICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgPSBjYWNoZS5wb3AoKVsxXSArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCkge1xuICAgICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgICAgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHI7XG4gICAgICAgICAgdG9rZW5zID0gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiICYmIHRva2VuWzBdICE9PSBcImNvbW1lbnRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhc1dvcmQgPSB0b2tlbnMuc29tZSgoaTIpID0+IGkyWzBdICE9PSBcInNwYWNlXCIgJiYgaTJbMF0gIT09IFwiY29tbWVudFwiKTtcbiAgICBpZiAoaGFzV29yZCkge1xuICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IGZpcnN0U3BhY2VzLm1hcCgoaTIpID0+IGkyWzFdKS5qb2luKFwiXCIpO1xuICAgICAgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5yYXcobm9kZTIsIFwidmFsdWVcIiwgZmlyc3RTcGFjZXMuY29uY2F0KHRva2VucyksIGN1c3RvbVByb3BlcnR5KTtcbiAgICBpZiAobm9kZTIudmFsdWUuaW5jbHVkZXMoXCI6XCIpICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgdGhpcy5jaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO1xuICAgIH1cbiAgfVxuICBkb3VibGVDb2xvbih0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIkRvdWJsZSBjb2xvblwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGggfVxuICAgICk7XG4gIH1cbiAgZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgbGV0IG5vZGUyID0gbmV3IFJ1bGUkMiQxKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc2VsZWN0b3IgPSBcIlwiO1xuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gIH1cbiAgZW5kKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO1xuICAgIH1cbiAgfVxuICBlbmRGaWxlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB0aGlzLnVuY2xvc2VkQmxvY2soKTtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgIHRoaXMucm9vdC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnRva2VuaXplci5wb3NpdGlvbigpKTtcbiAgfVxuICBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcInJ1bGVcIiAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gSGVscGVyc1xuICBnZXRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfVxuICBpbml0KG5vZGUyLCBvZmZzZXQpIHtcbiAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgbm9kZTIuc291cmNlID0ge1xuICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICBzdGFydDogdGhpcy5nZXRQb3NpdGlvbihvZmZzZXQpXG4gICAgfTtcbiAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gIH1cbiAgb3RoZXIoc3RhcnQpIHtcbiAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBjb2xvbiA9IGZhbHNlO1xuICAgIGxldCBicmFja2V0ID0gbnVsbDtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY3VzdG9tUHJvcGVydHkgPSBzdGFydFsxXS5zdGFydHNXaXRoKFwiLS1cIik7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IHN0YXJ0O1xuICAgIHdoaWxlICh0b2tlbikge1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIjpcIikge1xuICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIGVuZCA9IHRydWU7XG4gICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgIH1cbiAgfVxuICBwYXJzZSgpIHtcbiAgICBsZXQgdG9rZW47XG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSBcInNwYWNlXCI6XG4gICAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgdGhpcy5jb21tZW50KHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF0LXdvcmRcIjpcbiAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMub3RoZXIodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZEZpbGUoKTtcbiAgfVxuICBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpIHtcbiAgfVxuICByYXcobm9kZTIsIHByb3AsIHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICBsZXQgdG9rZW4sIHR5cGU7XG4gICAgbGV0IGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBsZXQgY2xlYW4gPSB0cnVlO1xuICAgIGxldCBuZXh0LCBwcmV2O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcInNwYWNlXCIgJiYgaTIgPT09IGxlbmd0aCAtIDEgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICBuZXh0ID0gdG9rZW5zW2kyICsgMV0gPyB0b2tlbnNbaTIgKyAxXVswXSA6IFwiZW1wdHlcIjtcbiAgICAgICAgaWYgKCFTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMVtwcmV2XSAmJiAhU0FGRV9DT01NRU5UX05FSUdIQk9SJDFbbmV4dF0pIHtcbiAgICAgICAgICBpZiAodmFsdWUuc2xpY2UoLTEpID09PSBcIixcIikge1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlICs9IHRva2VuWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsZWFuKSB7XG4gICAgICBsZXQgcmF3ID0gdG9rZW5zLnJlZHVjZSgoYWxsLCBpMikgPT4gYWxsICsgaTJbMV0sIFwiXCIpO1xuICAgICAgbm9kZTIucmF3c1twcm9wXSA9IHsgcmF3LCB2YWx1ZSB9O1xuICAgIH1cbiAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICB9XG4gIHJ1bGUodG9rZW5zKSB7XG4gICAgdG9rZW5zLnBvcCgpO1xuICAgIGxldCBub2RlMiA9IG5ldyBSdWxlJDIkMSgpO1xuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgIHRoaXMucmF3KG5vZGUyLCBcInNlbGVjdG9yXCIsIHRva2Vucyk7XG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gIH1cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlO1xuICAgIGxldCBzcGFjZXMgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIC8vIEVycm9yc1xuICBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgc3BhY2VzID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGU7XG4gICAgbGV0IHNwYWNlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgc3RyaW5nRnJvbSh0b2tlbnMsIGZyb20pIHtcbiAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgZm9yIChsZXQgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIHJlc3VsdDIgKz0gdG9rZW5zW2kyXVsxXTtcbiAgICB9XG4gICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdW5jbG9zZWRCbG9jaygpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydDtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYmxvY2tcIiwgcG9zLmxpbmUsIHBvcy5jb2x1bW4pO1xuICB9XG4gIHVuY2xvc2VkQnJhY2tldChicmFja2V0KSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiVW5jbG9zZWQgYnJhY2tldFwiLFxuICAgICAgeyBvZmZzZXQ6IGJyYWNrZXRbMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiBicmFja2V0WzJdICsgMSB9XG4gICAgKTtcbiAgfVxuICB1bmV4cGVjdGVkQ2xvc2UodG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIH1cIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgMSB9XG4gICAgKTtcbiAgfVxuICB1bmtub3duV29yZCh0b2tlbnMpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmtub3duIHdvcmRcIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gKyB0b2tlbnNbMF1bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG4gIHVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiQXQtcnVsZSB3aXRob3V0IG5hbWVcIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG59O1xudmFyIHBhcnNlciQxID0gUGFyc2VyJDEkMTtcbmxldCBDb250YWluZXIkMiQxID0gY29udGFpbmVyJDE7XG5sZXQgUGFyc2VyMiQxID0gcGFyc2VyJDE7XG5sZXQgSW5wdXQkMiQxID0gaW5wdXQkMTtcbmZ1bmN0aW9uIHBhcnNlJDMkMShjc3MsIG9wdHMpIHtcbiAgbGV0IGlucHV0MiA9IG5ldyBJbnB1dCQyJDEoY3NzLCBvcHRzKTtcbiAgbGV0IHBhcnNlcjIgPSBuZXcgUGFyc2VyMiQxKGlucHV0Mik7XG4gIHRyeSB7XG4gICAgcGFyc2VyMi5wYXJzZSgpO1xuICB9IGNhdGNoIChlMikge1xuICAgIGlmIChmYWxzZSkge31cbiAgICB0aHJvdyBlMjtcbiAgfVxuICByZXR1cm4gcGFyc2VyMi5yb290O1xufVxudmFyIHBhcnNlXzEkMSA9IHBhcnNlJDMkMTtcbnBhcnNlJDMkMS5kZWZhdWx0ID0gcGFyc2UkMyQxO1xuQ29udGFpbmVyJDIkMS5yZWdpc3RlclBhcnNlKHBhcnNlJDMkMSk7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDMsIG15OiBteSQzIH0gPSBzeW1ib2xzJDE7XG5sZXQgTWFwR2VuZXJhdG9yJDEkMSA9IG1hcEdlbmVyYXRvciQxO1xubGV0IHN0cmluZ2lmeSQyJDEgPSBzdHJpbmdpZnlfMSQxO1xubGV0IENvbnRhaW5lciQxJDEgPSBjb250YWluZXIkMTtcbmxldCBEb2N1bWVudCQyJDEgPSBkb2N1bWVudCQxJDE7XG5sZXQgd2Fybk9uY2UkMSQxID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAod2Fybk9uY2UkMiQxKSk7XG5sZXQgUmVzdWx0JDIkMSA9IHJlc3VsdCQxO1xubGV0IHBhcnNlJDIkMSA9IHBhcnNlXzEkMTtcbmxldCBSb290JDMkMSA9IHJvb3QkMTtcbmNvbnN0IFRZUEVfVE9fQ0xBU1NfTkFNRSQxID0ge1xuICBhdHJ1bGU6IFwiQXRSdWxlXCIsXG4gIGNvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICBkZWNsOiBcIkRlY2xhcmF0aW9uXCIsXG4gIGRvY3VtZW50OiBcIkRvY3VtZW50XCIsXG4gIHJvb3Q6IFwiUm9vdFwiLFxuICBydWxlOiBcIlJ1bGVcIlxufTtcbmNvbnN0IFBMVUdJTl9QUk9QUyQxID0ge1xuICBBdFJ1bGU6IHRydWUsXG4gIEF0UnVsZUV4aXQ6IHRydWUsXG4gIENvbW1lbnQ6IHRydWUsXG4gIENvbW1lbnRFeGl0OiB0cnVlLFxuICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgRGVjbGFyYXRpb25FeGl0OiB0cnVlLFxuICBEb2N1bWVudDogdHJ1ZSxcbiAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICBPbmNlOiB0cnVlLFxuICBPbmNlRXhpdDogdHJ1ZSxcbiAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgcHJlcGFyZTogdHJ1ZSxcbiAgUm9vdDogdHJ1ZSxcbiAgUm9vdEV4aXQ6IHRydWUsXG4gIFJ1bGU6IHRydWUsXG4gIFJ1bGVFeGl0OiB0cnVlXG59O1xuY29uc3QgTk9UX1ZJU0lUT1JTJDEgPSB7XG4gIE9uY2U6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWVcbn07XG5jb25zdCBDSElMRFJFTiQxID0gMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSQxKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyQxKG5vZGUyKSB7XG4gIGxldCBrZXkgPSBmYWxzZTtcbiAgbGV0IHR5cGUgPSBUWVBFX1RPX0NMQVNTX05BTUUkMVtub2RlMi50eXBlXTtcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAga2V5ID0gbm9kZTIucHJvcC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICBrZXkgPSBub2RlMi5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgaWYgKGtleSAmJiBub2RlMi5hcHBlbmQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgIENISUxEUkVOJDEsXG4gICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgXTtcbiAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICByZXR1cm4gW3R5cGUsIHR5cGUgKyBcIi1cIiArIGtleSwgdHlwZSArIFwiRXhpdFwiLCB0eXBlICsgXCJFeGl0LVwiICsga2V5XTtcbiAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICByZXR1cm4gW3R5cGUsIENISUxEUkVOJDEsIHR5cGUgKyBcIkV4aXRcIl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt0eXBlLCB0eXBlICsgXCJFeGl0XCJdO1xuICB9XG59XG5mdW5jdGlvbiB0b1N0YWNrJDEobm9kZTIpIHtcbiAgbGV0IGV2ZW50cztcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgIGV2ZW50cyA9IFtcIkRvY3VtZW50XCIsIENISUxEUkVOJDEsIFwiRG9jdW1lbnRFeGl0XCJdO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgZXZlbnRzID0gW1wiUm9vdFwiLCBDSElMRFJFTiQxLCBcIlJvb3RFeGl0XCJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGdldEV2ZW50cyQxKG5vZGUyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV2ZW50SW5kZXg6IDAsXG4gICAgZXZlbnRzLFxuICAgIGl0ZXJhdG9yOiAwLFxuICAgIG5vZGU6IG5vZGUyLFxuICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICB2aXNpdG9yczogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuTWFya3MkMShub2RlMikge1xuICBub2RlMltpc0NsZWFuJDNdID0gZmFsc2U7XG4gIGlmIChub2RlMi5ub2Rlcykgbm9kZTIubm9kZXMuZm9yRWFjaCgoaTIpID0+IGNsZWFuTWFya3MkMShpMikpO1xuICByZXR1cm4gbm9kZTI7XG59XG5sZXQgcG9zdGNzcyQyJDEgPSB7fTtcbmxldCBMYXp5UmVzdWx0JDIkMSA9IGNsYXNzIExhenlSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICBsZXQgcm9vdDI7XG4gICAgaWYgKHR5cGVvZiBjc3MgPT09IFwib2JqZWN0XCIgJiYgY3NzICE9PSBudWxsICYmIChjc3MudHlwZSA9PT0gXCJyb290XCIgfHwgY3NzLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHtcbiAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcyk7XG4gICAgfSBlbHNlIGlmIChjc3MgaW5zdGFuY2VvZiBMYXp5UmVzdWx0IHx8IGNzcyBpbnN0YW5jZW9mIFJlc3VsdCQyJDEpIHtcbiAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcy5yb290KTtcbiAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXAgPT09IFwidW5kZWZpbmVkXCIpIG9wdHMubWFwID0ge307XG4gICAgICAgIGlmICghb3B0cy5tYXAuaW5saW5lKSBvcHRzLm1hcC5pbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXJzZXIyID0gcGFyc2UkMiQxO1xuICAgICAgaWYgKG9wdHMuc3ludGF4KSBwYXJzZXIyID0gb3B0cy5zeW50YXgucGFyc2U7XG4gICAgICBpZiAob3B0cy5wYXJzZXIpIHBhcnNlcjIgPSBvcHRzLnBhcnNlcjtcbiAgICAgIGlmIChwYXJzZXIyLnBhcnNlKSBwYXJzZXIyID0gcGFyc2VyMi5wYXJzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJvb3QyID0gcGFyc2VyMihjc3MsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAocm9vdDIgJiYgIXJvb3QyW215JDNdKSB7XG4gICAgICAgIENvbnRhaW5lciQxJDEucmVidWlsZChyb290Mik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQyJDEocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgIHRoaXMuaGVscGVycyA9IHsgLi4ucG9zdGNzcyQyJDEsIHBvc3Rjc3M6IHBvc3Rjc3MkMiQxLCByZXN1bHQ6IHRoaXMucmVzdWx0IH07XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wcm9jZXNzb3IucGx1Z2lucy5tYXAoKHBsdWdpbjIyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLnByZXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucGx1Z2luMjIsIC4uLnBsdWdpbjIyLnByZXBhcmUodGhpcy5yZXN1bHQpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGx1Z2luMjI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgIGlmICghdGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnJ1bkFzeW5jKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gIH1cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gIH1cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICB9XG4gIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2luc1wiKTtcbiAgfVxuICBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICBsZXQgcGx1Z2luMjIgPSB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luO1xuICAgIHRyeSB7XG4gICAgICBpZiAobm9kZTIpIG5vZGUyLmFkZFRvRXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiAhZXJyb3IucGx1Z2luKSB7XG4gICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcHJlcGFyZVZpc2l0b3JzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgbGV0IGFkZCA9IChwbHVnaW4yMiwgdHlwZSwgY2IpID0+IHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtwbHVnaW4yMiwgY2JdKTtcbiAgICB9O1xuICAgIGZvciAobGV0IHBsdWdpbjIyIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiBwbHVnaW4yMikge1xuICAgICAgICAgIGlmICghUExVR0lOX1BST1BTJDFbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGV2ZW50ICR7ZXZlbnR9IGluICR7cGx1Z2luMjIucG9zdGNzc1BsdWdpbn0uIFRyeSB0byB1cGRhdGUgUG9zdENTUyAoJHt0aGlzLnByb2Nlc3Nvci52ZXJzaW9ufSBub3cpLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghTk9UX1ZJU0lUT1JTJDFbZXZlbnRdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gcGx1Z2luMjJbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkKFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgKyBcIi1cIiArIGZpbHRlci50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMltldmVudF1bZmlsdGVyXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGFzTGlzdGVuZXIgPSBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID4gMDtcbiAgfVxuICBhc3luYyBydW5Bc3luYygpIHtcbiAgICB0aGlzLnBsdWdpbiA9IDA7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGxldCBwbHVnaW4yMiA9IHRoaXMucGx1Z2luc1tpMl07XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgIHdoaWxlICghcm9vdDJbaXNDbGVhbiQzXSkge1xuICAgICAgICByb290Mltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0YWNrID0gW3RvU3RhY2skMShyb290MildO1xuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwcm9taXNlID0gdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgIGxldCBub2RlMiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICBmb3IgKGxldCBbcGx1Z2luMjIsIHZpc2l0b3JdIG9mIHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgIGxldCByb290cyA9IHJvb3QyLm5vZGVzLm1hcChcbiAgICAgICAgICAgICAgICAoc3ViUm9vdCkgPT4gdmlzaXRvcihzdWJSb290LCB0aGlzLmhlbHBlcnMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF3YWl0IHZpc2l0b3Iocm9vdDIsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCk7XG4gIH1cbiAgcnVuT25Sb290KHBsdWdpbjIyKSB7XG4gICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLk9uY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgbGV0IHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAoXG4gICAgICAgICAgICAocm9vdDIpID0+IHBsdWdpbjIyLk9uY2Uocm9vdDIsIHRoaXMuaGVscGVycylcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc1Byb21pc2UkMShyb290c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyb290cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZSh0aGlzLnJlc3VsdC5yb290LCB0aGlzLmhlbHBlcnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RyaW5naWZ5KCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IHRydWU7XG4gICAgdGhpcy5zeW5jKCk7XG4gICAgbGV0IG9wdHMgPSB0aGlzLnJlc3VsdC5vcHRzO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkkMiQxO1xuICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5O1xuICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyO1xuICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yJDEkMShzdHIsIHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0Lm9wdHMpO1xuICAgIGxldCBkYXRhID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXTtcbiAgICB0aGlzLnJlc3VsdC5tYXAgPSBkYXRhWzFdO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcGx1Z2luMjIgb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgIHdoaWxlICghcm9vdDJbaXNDbGVhbiQzXSkge1xuICAgICAgICByb290Mltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YWxrU3luYyhyb290Mik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgIGZvciAobGV0IHN1YlJvb3Qgb2Ygcm9vdDIubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChmYWxzZSkge31cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzcztcbiAgfVxuICB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgZm9yIChsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSBvZiB2aXNpdG9ycykge1xuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgbGV0IHByb21pc2U7XG4gICAgICB0cnkge1xuICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyLnByb3h5T2YpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvbWlzZSQxKHByb21pc2UpKSB7XG4gICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2aXNpdFRpY2soc3RhY2spIHtcbiAgICBsZXQgdmlzaXQyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgbGV0IHsgbm9kZTogbm9kZTIsIHZpc2l0b3JzIH0gPSB2aXNpdDI7XG4gICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZpc2l0b3JzLmxlbmd0aCA+IDAgJiYgdmlzaXQyLnZpc2l0b3JJbmRleCA8IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgbGV0IFtwbHVnaW4yMiwgdmlzaXRvcl0gPSB2aXNpdG9yc1t2aXNpdDIudmlzaXRvckluZGV4XTtcbiAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggKz0gMTtcbiAgICAgIGlmICh2aXNpdDIudmlzaXRvckluZGV4ID09PSB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gW107XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3Iobm9kZTIudG9Qcm94eSgpLCB0aGlzLmhlbHBlcnMpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlzaXQyLml0ZXJhdG9yICE9PSAwKSB7XG4gICAgICBsZXQgaXRlcmF0b3IgPSB2aXNpdDIuaXRlcmF0b3I7XG4gICAgICBsZXQgY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgPSBub2RlMi5ub2Rlc1tub2RlMi5pbmRleGVzW2l0ZXJhdG9yXV0pIHtcbiAgICAgICAgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuJDNdKSB7XG4gICAgICAgICAgY2hpbGRbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrJDEoY2hpbGQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IDA7XG4gICAgICBkZWxldGUgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgfVxuICAgIGxldCBldmVudHMgPSB2aXNpdDIuZXZlbnRzO1xuICAgIHdoaWxlICh2aXNpdDIuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGxldCBldmVudCA9IGV2ZW50c1t2aXNpdDIuZXZlbnRJbmRleF07XG4gICAgICB2aXNpdDIuZXZlbnRJbmRleCArPSAxO1xuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTiQxKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlMltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSBub2RlMi5nZXRJdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuICB3YWxrU3luYyhub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgIGxldCBldmVudHMgPSBnZXRFdmVudHMkMShub2RlMik7XG4gICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOJDEpIHtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgbm9kZTIuZWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbiQzXSkgdGhpcy53YWxrU3luYyhjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYgKHZpc2l0b3JzKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMi50b1Byb3h5KCkpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLndhcm5pbmdzKCk7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudDtcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNzcztcbiAgfVxuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLm1hcDtcbiAgfVxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLm1lc3NhZ2VzO1xuICB9XG4gIGdldCBvcHRzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICB9XG4gIGdldCBwcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgfVxuICBnZXQgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdDtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiTGF6eVJlc3VsdFwiO1xuICB9XG59O1xuTGF6eVJlc3VsdCQyJDEucmVnaXN0ZXJQb3N0Y3NzID0gKGRlcGVuZGFudCkgPT4ge1xuICBwb3N0Y3NzJDIkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgbGF6eVJlc3VsdCQxID0gTGF6eVJlc3VsdCQyJDE7XG5MYXp5UmVzdWx0JDIkMS5kZWZhdWx0ID0gTGF6eVJlc3VsdCQyJDE7XG5Sb290JDMkMS5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyJDEpO1xuRG9jdW1lbnQkMiQxLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIkMSk7XG5sZXQgTWFwR2VuZXJhdG9yMiQxID0gbWFwR2VuZXJhdG9yJDE7XG5sZXQgc3RyaW5naWZ5JDEkMSA9IHN0cmluZ2lmeV8xJDE7XG5sZXQgd2Fybk9uY2UyJDEgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmICh3YXJuT25jZSQyJDEpKTtcbmxldCBwYXJzZSQxJDEgPSBwYXJzZV8xJDE7XG5jb25zdCBSZXN1bHQkMSQxID0gcmVzdWx0JDE7XG5sZXQgTm9Xb3JrUmVzdWx0JDEkMSA9IGNsYXNzIE5vV29ya1Jlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgIGNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgIHRoaXMuX2NzcyA9IGNzcztcbiAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgbGV0IHJvb3QyO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkkMSQxO1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQxJDEodGhpcy5fcHJvY2Vzc29yLCByb290MiwgdGhpcy5fb3B0cyk7XG4gICAgdGhpcy5yZXN1bHQuY3NzID0gY3NzO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yZXN1bHQsIFwicm9vdFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJvb3Q7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IG1hcCA9IG5ldyBNYXBHZW5lcmF0b3IyJDEoc3RyLCByb290MiwgdGhpcy5fb3B0cywgY3NzKTtcbiAgICBpZiAobWFwLmlzTWFwKCkpIHtcbiAgICAgIGxldCBbZ2VuZXJhdGVkQ1NTLCBnZW5lcmF0ZWRNYXBdID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgICBpZiAoZ2VuZXJhdGVkQ1NTKSB7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTUztcbiAgICAgIH1cbiAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXAuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzO1xuICAgIH1cbiAgfVxuICBhc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICB9XG4gIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgfVxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKGZhbHNlKSB7fVxuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NzcztcbiAgfVxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IG9wdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gIH1cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICB9XG4gIGdldCByb290KCkge1xuICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9XG4gICAgbGV0IHJvb3QyO1xuICAgIGxldCBwYXJzZXIyID0gcGFyc2UkMSQxO1xuICAgIHRyeSB7XG4gICAgICByb290MiA9IHBhcnNlcjIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcm9vdCA9IHJvb3QyO1xuICAgICAgcmV0dXJuIHJvb3QyO1xuICAgIH1cbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiTm9Xb3JrUmVzdWx0XCI7XG4gIH1cbn07XG52YXIgbm9Xb3JrUmVzdWx0JDEgPSBOb1dvcmtSZXN1bHQkMSQxO1xuTm9Xb3JrUmVzdWx0JDEkMS5kZWZhdWx0ID0gTm9Xb3JrUmVzdWx0JDEkMTtcbmxldCBOb1dvcmtSZXN1bHQyJDEgPSBub1dvcmtSZXN1bHQkMTtcbmxldCBMYXp5UmVzdWx0JDEkMSA9IGxhenlSZXN1bHQkMTtcbmxldCBEb2N1bWVudCQxJDEgPSBkb2N1bWVudCQxJDE7XG5sZXQgUm9vdCQyJDEgPSByb290JDE7XG5sZXQgUHJvY2Vzc29yJDEkMSA9IGNsYXNzIFByb2Nlc3NvciB7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbnMgPSBbXSkge1xuICAgIHRoaXMudmVyc2lvbiA9IFwiOC40LjM4XCI7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucyk7XG4gIH1cbiAgbm9ybWFsaXplKHBsdWdpbnMpIHtcbiAgICBsZXQgbm9ybWFsaXplZCA9IFtdO1xuICAgIGZvciAobGV0IGkyIG9mIHBsdWdpbnMpIHtcbiAgICAgIGlmIChpMi5wb3N0Y3NzID09PSB0cnVlKSB7XG4gICAgICAgIGkyID0gaTIoKTtcbiAgICAgIH0gZWxzZSBpZiAoaTIucG9zdGNzcykge1xuICAgICAgICBpMiA9IGkyLnBvc3Rjc3M7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoaTIucGx1Z2lucykpIHtcbiAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQuY29uY2F0KGkyLnBsdWdpbnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwib2JqZWN0XCIgJiYgaTIucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwib2JqZWN0XCIgJiYgKGkyLnBhcnNlIHx8IGkyLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkyICsgXCIgaXMgbm90IGEgUG9zdENTUyBwbHVnaW5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG4gIHByb2Nlc3MoY3NzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMucGx1Z2lucy5sZW5ndGggJiYgIW9wdHMucGFyc2VyICYmICFvcHRzLnN0cmluZ2lmaWVyICYmICFvcHRzLnN5bnRheCkge1xuICAgICAgcmV0dXJuIG5ldyBOb1dvcmtSZXN1bHQyJDEodGhpcywgY3NzLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgIH1cbiAgfVxuICB1c2UocGx1Z2luMjIpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuY29uY2F0KHRoaXMubm9ybWFsaXplKFtwbHVnaW4yMl0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBwcm9jZXNzb3IkMSA9IFByb2Nlc3NvciQxJDE7XG5Qcm9jZXNzb3IkMSQxLmRlZmF1bHQgPSBQcm9jZXNzb3IkMSQxO1xuUm9vdCQyJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG5Eb2N1bWVudCQxJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG5sZXQgRGVjbGFyYXRpb24kMSQxID0gZGVjbGFyYXRpb24kMTtcbmxldCBQcmV2aW91c01hcDIkMSA9IHByZXZpb3VzTWFwJDE7XG5sZXQgQ29tbWVudCQxJDEgPSBjb21tZW50JDE7XG5sZXQgQXRSdWxlJDEkMSA9IGF0UnVsZSQxO1xubGV0IElucHV0JDEkMSA9IGlucHV0JDE7XG5sZXQgUm9vdCQxJDEgPSByb290JDE7XG5sZXQgUnVsZSQxJDEgPSBydWxlJDE7XG5mdW5jdGlvbiBmcm9tSlNPTiQxJDEoanNvbiwgaW5wdXRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSByZXR1cm4ganNvbi5tYXAoKG4yKSA9PiBmcm9tSlNPTiQxJDEobjIpKTtcbiAgbGV0IHsgaW5wdXRzOiBvd25JbnB1dHMsIC4uLmRlZmF1bHRzIH0gPSBqc29uO1xuICBpZiAob3duSW5wdXRzKSB7XG4gICAgaW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQyIG9mIG93bklucHV0cykge1xuICAgICAgbGV0IGlucHV0SHlkcmF0ZWQgPSB7IC4uLmlucHV0MiwgX19wcm90b19fOiBJbnB1dCQxJDEucHJvdG90eXBlIH07XG4gICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgaW5wdXRIeWRyYXRlZC5tYXAgPSB7XG4gICAgICAgICAgLi4uaW5wdXRIeWRyYXRlZC5tYXAsXG4gICAgICAgICAgX19wcm90b19fOiBQcmV2aW91c01hcDIkMS5wcm90b3R5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKGlucHV0SHlkcmF0ZWQpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICBkZWZhdWx0cy5ub2RlcyA9IGpzb24ubm9kZXMubWFwKChuMikgPT4gZnJvbUpTT04kMSQxKG4yLCBpbnB1dHMpKTtcbiAgfVxuICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgbGV0IHsgaW5wdXRJZCwgLi4uc291cmNlIH0gPSBkZWZhdWx0cy5zb3VyY2U7XG4gICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgcmV0dXJuIG5ldyBSb290JDEkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uJDEkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUkMSQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIHJldHVybiBuZXcgQ29tbWVudCQxJDEoZGVmYXVsdHMpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICByZXR1cm4gbmV3IEF0UnVsZSQxJDEoZGVmYXVsdHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gIH1cbn1cbnZhciBmcm9tSlNPTl8xJDEgPSBmcm9tSlNPTiQxJDE7XG5mcm9tSlNPTiQxJDEuZGVmYXVsdCA9IGZyb21KU09OJDEkMTtcbmxldCBDc3NTeW50YXhFcnJvcjIkMSA9IGNzc1N5bnRheEVycm9yJDE7XG5sZXQgRGVjbGFyYXRpb24yJDEgPSBkZWNsYXJhdGlvbiQxO1xubGV0IExhenlSZXN1bHQyJDEgPSBsYXp5UmVzdWx0JDE7XG5sZXQgQ29udGFpbmVyMiQxID0gY29udGFpbmVyJDE7XG5sZXQgUHJvY2Vzc29yMiQxID0gcHJvY2Vzc29yJDE7XG5sZXQgc3RyaW5naWZ5JDUgPSBzdHJpbmdpZnlfMSQxO1xubGV0IGZyb21KU09OJDIgPSBmcm9tSlNPTl8xJDE7XG5sZXQgRG9jdW1lbnQyMiA9IGRvY3VtZW50JDEkMTtcbmxldCBXYXJuaW5nMiQxID0gd2FybmluZyQxO1xubGV0IENvbW1lbnQyJDEgPSBjb21tZW50JDE7XG5sZXQgQXRSdWxlMiQxID0gYXRSdWxlJDE7XG5sZXQgUmVzdWx0MiQxID0gcmVzdWx0JDE7XG5sZXQgSW5wdXQyJDEgPSBpbnB1dCQxO1xubGV0IHBhcnNlJDUgPSBwYXJzZV8xJDE7XG5sZXQgbGlzdCQzID0gbGlzdF8xJDE7XG5sZXQgUnVsZTIkMSA9IHJ1bGUkMTtcbmxldCBSb290MiQxID0gcm9vdCQxO1xubGV0IE5vZGUyJDEgPSBub2RlJDE7XG5mdW5jdGlvbiBwb3N0Y3NzJDMoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICB9XG4gIHJldHVybiBuZXcgUHJvY2Vzc29yMiQxKHBsdWdpbnMpO1xufVxucG9zdGNzcyQzLnBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihuYW1lLCBpbml0aWFsaXplcikge1xuICBsZXQgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmICF3YXJuaW5nUHJpbnRlZCkge1xuICAgICAgd2FybmluZ1ByaW50ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIlxuICAgICAgKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5MQU5HICYmIHByb2Nlc3MuZW52LkxBTkcuc3RhcnRzV2l0aChcImNuXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncyk7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1ZlcnNpb24gPSBuZXcgUHJvY2Vzc29yMiQxKCkudmVyc2lvbjtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gIH1cbiAgbGV0IGNhY2hlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgXCJwb3N0Y3NzXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoIWNhY2hlKSBjYWNoZSA9IGNyZWF0b3IoKTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0pO1xuICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbihjc3MsIHByb2Nlc3NPcHRzLCBwbHVnaW5PcHRzKSB7XG4gICAgcmV0dXJuIHBvc3Rjc3MkMyhbY3JlYXRvcihwbHVnaW5PcHRzKV0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gIH07XG4gIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3MkMy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkkNTtcbnBvc3Rjc3MkMy5wYXJzZSA9IHBhcnNlJDU7XG5wb3N0Y3NzJDMuZnJvbUpTT04gPSBmcm9tSlNPTiQyO1xucG9zdGNzcyQzLmxpc3QgPSBsaXN0JDM7XG5wb3N0Y3NzJDMuY29tbWVudCA9IChkZWZhdWx0cykgPT4gbmV3IENvbW1lbnQyJDEoZGVmYXVsdHMpO1xucG9zdGNzcyQzLmF0UnVsZSA9IChkZWZhdWx0cykgPT4gbmV3IEF0UnVsZTIkMShkZWZhdWx0cyk7XG5wb3N0Y3NzJDMuZGVjbCA9IChkZWZhdWx0cykgPT4gbmV3IERlY2xhcmF0aW9uMiQxKGRlZmF1bHRzKTtcbnBvc3Rjc3MkMy5ydWxlID0gKGRlZmF1bHRzKSA9PiBuZXcgUnVsZTIkMShkZWZhdWx0cyk7XG5wb3N0Y3NzJDMucm9vdCA9IChkZWZhdWx0cykgPT4gbmV3IFJvb3QyJDEoZGVmYXVsdHMpO1xucG9zdGNzcyQzLmRvY3VtZW50ID0gKGRlZmF1bHRzKSA9PiBuZXcgRG9jdW1lbnQyMihkZWZhdWx0cyk7XG5wb3N0Y3NzJDMuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIkMTtcbnBvc3Rjc3MkMy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMiQxO1xucG9zdGNzcyQzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIkMTtcbnBvc3Rjc3MkMy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyJDE7XG5wb3N0Y3NzJDMuRG9jdW1lbnQgPSBEb2N1bWVudDIyO1xucG9zdGNzcyQzLkNvbW1lbnQgPSBDb21tZW50MiQxO1xucG9zdGNzcyQzLldhcm5pbmcgPSBXYXJuaW5nMiQxO1xucG9zdGNzcyQzLkF0UnVsZSA9IEF0UnVsZTIkMTtcbnBvc3Rjc3MkMy5SZXN1bHQgPSBSZXN1bHQyJDE7XG5wb3N0Y3NzJDMuSW5wdXQgPSBJbnB1dDIkMTtcbnBvc3Rjc3MkMy5SdWxlID0gUnVsZTIkMTtcbnBvc3Rjc3MkMy5Sb290ID0gUm9vdDIkMTtcbnBvc3Rjc3MkMy5Ob2RlID0gTm9kZTIkMTtcbkxhenlSZXN1bHQyJDEucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MkMyk7XG52YXIgcG9zdGNzc18xJDEgPSBwb3N0Y3NzJDM7XG5wb3N0Y3NzJDMuZGVmYXVsdCA9IHBvc3Rjc3MkMztcbmNvbnN0IHBvc3Rjc3MkMSQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEocG9zdGNzc18xJDEpO1xucG9zdGNzcyQxJDEuc3RyaW5naWZ5O1xucG9zdGNzcyQxJDEuZnJvbUpTT047XG5wb3N0Y3NzJDEkMS5wbHVnaW47XG5wb3N0Y3NzJDEkMS5wYXJzZTtcbnBvc3Rjc3MkMSQxLmxpc3Q7XG5wb3N0Y3NzJDEkMS5kb2N1bWVudDtcbnBvc3Rjc3MkMSQxLmNvbW1lbnQ7XG5wb3N0Y3NzJDEkMS5hdFJ1bGU7XG5wb3N0Y3NzJDEkMS5ydWxlO1xucG9zdGNzcyQxJDEuZGVjbDtcbnBvc3Rjc3MkMSQxLnJvb3Q7XG5wb3N0Y3NzJDEkMS5Dc3NTeW50YXhFcnJvcjtcbnBvc3Rjc3MkMSQxLkRlY2xhcmF0aW9uO1xucG9zdGNzcyQxJDEuQ29udGFpbmVyO1xucG9zdGNzcyQxJDEuUHJvY2Vzc29yO1xucG9zdGNzcyQxJDEuRG9jdW1lbnQ7XG5wb3N0Y3NzJDEkMS5Db21tZW50O1xucG9zdGNzcyQxJDEuV2FybmluZztcbnBvc3Rjc3MkMSQxLkF0UnVsZTtcbnBvc3Rjc3MkMSQxLlJlc3VsdDtcbnBvc3Rjc3MkMSQxLklucHV0O1xucG9zdGNzcyQxJDEuUnVsZTtcbnBvc3Rjc3MkMSQxLlJvb3Q7XG5wb3N0Y3NzJDEkMS5Ob2RlO1xudmFyIF9fZGVmUHJvcDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcDIob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeDIpIHtcbiAgcmV0dXJuIHgyICYmIHgyLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcImRlZmF1bHRcIikgPyB4MltcImRlZmF1bHRcIl0gOiB4Mjtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuMikge1xuICBpZiAobjIuX19lc01vZHVsZSkgcmV0dXJuIG4yO1xuICB2YXIgZjIgPSBuMi5kZWZhdWx0O1xuICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBhMiA9IGZ1bmN0aW9uIGEyMigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYTIyKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgYTIucHJvdG90eXBlID0gZjIucHJvdG90eXBlO1xuICB9IGVsc2UgYTIgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmtleXMobjIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuMiwgayk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGEyO1xufVxudmFyIHBpY29jb2xvcnNfYnJvd3NlciA9IHsgZXhwb3J0czoge30gfTtcbnZhciB4ID0gU3RyaW5nO1xudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyBpc0NvbG9yU3VwcG9ydGVkOiBmYWxzZSwgcmVzZXQ6IHgsIGJvbGQ6IHgsIGRpbTogeCwgaXRhbGljOiB4LCB1bmRlcmxpbmU6IHgsIGludmVyc2U6IHgsIGhpZGRlbjogeCwgc3RyaWtldGhyb3VnaDogeCwgYmxhY2s6IHgsIHJlZDogeCwgZ3JlZW46IHgsIHllbGxvdzogeCwgYmx1ZTogeCwgbWFnZW50YTogeCwgY3lhbjogeCwgd2hpdGU6IHgsIGdyYXk6IHgsIGJnQmxhY2s6IHgsIGJnUmVkOiB4LCBiZ0dyZWVuOiB4LCBiZ1llbGxvdzogeCwgYmdCbHVlOiB4LCBiZ01hZ2VudGE6IHgsIGJnQ3lhbjogeCwgYmdXaGl0ZTogeCB9O1xufTtcbnBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzID0gY3JlYXRlKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGU7XG52YXIgcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyA9IHBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzO1xuY29uc3QgX192aXRlQnJvd3NlckV4dGVybmFsID0ge307XG5jb25zdCBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmNvbnN0IHJlcXVpcmUkJDIgPSAvKiBAX19QVVJFX18gKi8gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxKTtcbmxldCBwaWNvID0gcGljb2NvbG9yc19icm93c2VyRXhwb3J0cztcbmxldCB0ZXJtaW5hbEhpZ2hsaWdodCQxID0gcmVxdWlyZSQkMjtcbmxldCBDc3NTeW50YXhFcnJvciQzID0gY2xhc3MgQ3NzU3ludGF4RXJyb3IyIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIHNvdXJjZSwgZmlsZSwgcGx1Z2luMjIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNzc1N5bnRheEVycm9yXCI7XG4gICAgdGhpcy5yZWFzb24gPSBtZXNzYWdlO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIH1cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbjIyKSB7XG4gICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbHVtbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZS5saW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGxpbmUuY29sdW1uO1xuICAgICAgICB0aGlzLmVuZExpbmUgPSBjb2x1bW4ubGluZTtcbiAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBjb2x1bW4uY29sdW1uO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldE1lc3NhZ2UoKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENzc1N5bnRheEVycm9yMik7XG4gICAgfVxuICB9XG4gIHNldE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wbHVnaW4gPyB0aGlzLnBsdWdpbiArIFwiOiBcIiA6IFwiXCI7XG4gICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6IFwiPGNzcyBpbnB1dD5cIjtcbiAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOlwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbjtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlICs9IFwiOiBcIiArIHRoaXMucmVhc29uO1xuICB9XG4gIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuIFwiXCI7XG4gICAgbGV0IGNzcyA9IHRoaXMuc291cmNlO1xuICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHBpY28uaXNDb2xvclN1cHBvcnRlZDtcbiAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSkge1xuICAgICAgaWYgKGNvbG9yKSBjc3MgPSB0ZXJtaW5hbEhpZ2hsaWdodCQxKGNzcyk7XG4gICAgfVxuICAgIGxldCBsaW5lcyA9IGNzcy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApO1xuICAgIGxldCBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgIGxldCBtYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgICBsZXQgbWFyaywgYXNpZGU7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBsZXQgeyBib2xkLCBncmF5LCByZWQgfSA9IHBpY28uY3JlYXRlQ29sb3JzKHRydWUpO1xuICAgICAgbWFyayA9ICh0ZXh0KSA9PiBib2xkKHJlZCh0ZXh0KSk7XG4gICAgICBhc2lkZSA9ICh0ZXh0KSA9PiBncmF5KHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrID0gYXNpZGUgPSAoc3RyKSA9PiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoKGxpbmUsIGluZGV4MikgPT4ge1xuICAgICAgbGV0IG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4MjtcbiAgICAgIGxldCBndXR0ZXIgPSBcIiBcIiArIChcIiBcIiArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArIFwiIHwgXCI7XG4gICAgICBpZiAobnVtYmVyID09PSB0aGlzLmxpbmUpIHtcbiAgICAgICAgbGV0IHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSkgKyBsaW5lLnNsaWNlKDAsIHRoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIG1hcmsoXCI+XCIpICsgYXNpZGUoZ3V0dGVyKSArIGxpbmUgKyBcIlxcbiBcIiArIHNwYWNpbmcgKyBtYXJrKFwiXlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIiBcIiArIGFzaWRlKGd1dHRlcikgKyBsaW5lO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNvZGUgPSBcIlxcblxcblwiICsgY29kZSArIFwiXFxuXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICB9XG59O1xudmFyIGNzc1N5bnRheEVycm9yID0gQ3NzU3ludGF4RXJyb3IkMztcbkNzc1N5bnRheEVycm9yJDMuZGVmYXVsdCA9IENzc1N5bnRheEVycm9yJDM7XG52YXIgc3ltYm9scyA9IHt9O1xuc3ltYm9scy5pc0NsZWFuID0gU3ltYm9sKFwiaXNDbGVhblwiKTtcbnN5bWJvbHMubXkgPSBTeW1ib2woXCJteVwiKTtcbmNvbnN0IERFRkFVTFRfUkFXID0ge1xuICBhZnRlcjogXCJcXG5cIixcbiAgYmVmb3JlQ2xvc2U6IFwiXFxuXCIsXG4gIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gIGJlZm9yZURlY2w6IFwiXFxuXCIsXG4gIGJlZm9yZU9wZW46IFwiIFwiLFxuICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICBjb2xvbjogXCI6IFwiLFxuICBjb21tZW50TGVmdDogXCIgXCIsXG4gIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gIGVtcHR5Qm9keTogXCJcIixcbiAgaW5kZW50OiBcIiAgICBcIixcbiAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmxldCBTdHJpbmdpZmllciQyID0gY2xhc3MgU3RyaW5naWZpZXIyIHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gIH1cbiAgYXRydWxlKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICBsZXQgbmFtZSA9IFwiQFwiICsgbm9kZTIubmFtZTtcbiAgICBsZXQgcGFyYW1zID0gbm9kZTIucGFyYW1zID8gdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJwYXJhbXNcIikgOiBcIlwiO1xuICAgIGlmICh0eXBlb2Ygbm9kZTIucmF3cy5hZnRlck5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG5hbWUgKz0gbm9kZTIucmF3cy5hZnRlck5hbWU7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgIG5hbWUgKz0gXCIgXCI7XG4gICAgfVxuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgdGhpcy5ibG9jayhub2RlMiwgbmFtZSArIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSAobm9kZTIucmF3cy5iZXR3ZWVuIHx8IFwiXCIpICsgKHNlbWljb2xvbiA/IFwiO1wiIDogXCJcIik7XG4gICAgICB0aGlzLmJ1aWxkZXIobmFtZSArIHBhcmFtcyArIGVuZCwgbm9kZTIpO1xuICAgIH1cbiAgfVxuICBiZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ29tbWVudFwiKTtcbiAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNsb3NlXCIpO1xuICAgIH1cbiAgICBsZXQgYnVmID0gbm9kZTIucGFyZW50O1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgd2hpbGUgKGJ1ZiAmJiBidWYudHlwZSAhPT0gXCJyb290XCIpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgICBidWYgPSBidWYucGFyZW50O1xuICAgIH1cbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIGxldCBpbmRlbnQgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJpbmRlbnRcIik7XG4gICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IGRlcHRoOyBzdGVwKyspIHZhbHVlICs9IGluZGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGJsb2NrKG5vZGUyLCBzdGFydCkge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArIFwie1wiLCBub2RlMiwgXCJzdGFydFwiKTtcbiAgICBsZXQgYWZ0ZXI7XG4gICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIiwgXCJlbXB0eUJvZHlcIik7XG4gICAgfVxuICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKTtcbiAgICB0aGlzLmJ1aWxkZXIoXCJ9XCIsIG5vZGUyLCBcImVuZFwiKTtcbiAgfVxuICBib2R5KG5vZGUyKSB7XG4gICAgbGV0IGxhc3QgPSBub2RlMi5ub2Rlcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsYXN0ID4gMCkge1xuICAgICAgaWYgKG5vZGUyLm5vZGVzW2xhc3RdLnR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIGxhc3QgLT0gMTtcbiAgICB9XG4gICAgbGV0IHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUyLCBcInNlbWljb2xvblwiKTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZTIubm9kZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlMi5ub2Rlc1tpMl07XG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsIFwiYmVmb3JlXCIpO1xuICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSk7XG4gICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaTIgfHwgc2VtaWNvbG9uKTtcbiAgICB9XG4gIH1cbiAgY29tbWVudChub2RlMikge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yYXcobm9kZTIsIFwibGVmdFwiLCBcImNvbW1lbnRMZWZ0XCIpO1xuICAgIGxldCByaWdodCA9IHRoaXMucmF3KG5vZGUyLCBcInJpZ2h0XCIsIFwiY29tbWVudFJpZ2h0XCIpO1xuICAgIHRoaXMuYnVpbGRlcihcIi8qXCIgKyBsZWZ0ICsgbm9kZTIudGV4dCArIHJpZ2h0ICsgXCIqL1wiLCBub2RlMik7XG4gIH1cbiAgZGVjbChub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiY29sb25cIik7XG4gICAgbGV0IHN0cmluZyA9IG5vZGUyLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAobm9kZTIuaW1wb3J0YW50KSB7XG4gICAgICBzdHJpbmcgKz0gbm9kZTIucmF3cy5pbXBvcnRhbnQgfHwgXCIgIWltcG9ydGFudFwiO1xuICAgIH1cbiAgICBpZiAoc2VtaWNvbG9uKSBzdHJpbmcgKz0gXCI7XCI7XG4gICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZTIpO1xuICB9XG4gIGRvY3VtZW50KG5vZGUyKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgfVxuICByYXcobm9kZTIsIG93biwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICghZGV0ZWN0KSBkZXRlY3QgPSBvd247XG4gICAgaWYgKG93bikge1xuICAgICAgdmFsdWUgPSBub2RlMi5yYXdzW293bl07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBub2RlMi5wYXJlbnQ7XG4gICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICBsZXQgcm9vdDIgPSBub2RlMi5yb290KCk7XG4gICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICBpZiAodHlwZW9mIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiByb290Mi5yYXdDYWNoZVtkZXRlY3RdO1xuICAgIH1cbiAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1ldGhvZCA9IFwicmF3XCIgKyBjYXBpdGFsaXplKGRldGVjdCk7XG4gICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QyLCBub2RlMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3c1tvd25dO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICByb290Mi5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZUNsb3NlKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZUNvbW1lbnQocm9vdDIsIG5vZGUyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtDb21tZW50cygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVEZWNsKHJvb3QyLCBub2RlMikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrRGVjbHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlT3Blbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLnR5cGUgIT09IFwiZGVjbFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZVJ1bGUocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiAoaTIucGFyZW50ICE9PSByb290MiB8fCByb290Mi5maXJzdCAhPT0gaTIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdDb2xvbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrRGVjbHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmV0d2VlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0VtcHR5Qm9keShyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3SW5kZW50KHJvb3QyKSB7XG4gICAgaWYgKHJvb3QyLnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdDIucmF3cy5pbmRlbnQ7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBsZXQgcCA9IGkyLnBhcmVudDtcbiAgICAgIGlmIChwICYmIHAgIT09IHJvb3QyICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290Mikge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gaTIucmF3cy5iZWZvcmUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgdmFsdWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3U2VtaWNvbG9uKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoICYmIGkyLmxhc3QudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLnNlbWljb2xvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdWYWx1ZShub2RlMiwgcHJvcCkge1xuICAgIGxldCB2YWx1ZSA9IG5vZGUyW3Byb3BdO1xuICAgIGxldCByYXcgPSBub2RlMi5yYXdzW3Byb3BdO1xuICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJhdy5yYXc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByb290KG5vZGUyKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICBpZiAobm9kZTIucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3MuYWZ0ZXIpO1xuICB9XG4gIHJ1bGUobm9kZTIpIHtcbiAgICB0aGlzLmJsb2NrKG5vZGUyLCB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInNlbGVjdG9yXCIpKTtcbiAgICBpZiAobm9kZTIucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLm93blNlbWljb2xvbiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdpZnkobm9kZTIsIHNlbWljb2xvbikge1xuICAgIGlmICghdGhpc1tub2RlMi50eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlVua25vd24gQVNUIG5vZGUgdHlwZSBcIiArIG5vZGUyLnR5cGUgKyBcIi4gTWF5YmUgeW91IG5lZWQgdG8gY2hhbmdlIFBvc3RDU1Mgc3RyaW5naWZpZXIuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXNbbm9kZTIudHlwZV0obm9kZTIsIHNlbWljb2xvbik7XG4gIH1cbn07XG52YXIgc3RyaW5naWZpZXIgPSBTdHJpbmdpZmllciQyO1xuU3RyaW5naWZpZXIkMi5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMjtcbmxldCBTdHJpbmdpZmllciQxID0gc3RyaW5naWZpZXI7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNChub2RlMiwgYnVpbGRlcikge1xuICBsZXQgc3RyID0gbmV3IFN0cmluZ2lmaWVyJDEoYnVpbGRlcik7XG4gIHN0ci5zdHJpbmdpZnkobm9kZTIpO1xufVxudmFyIHN0cmluZ2lmeV8xID0gc3RyaW5naWZ5JDQ7XG5zdHJpbmdpZnkkNC5kZWZhdWx0ID0gc3RyaW5naWZ5JDQ7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDIsIG15OiBteSQyIH0gPSBzeW1ib2xzO1xubGV0IENzc1N5bnRheEVycm9yJDIgPSBjc3NTeW50YXhFcnJvcjtcbmxldCBTdHJpbmdpZmllcjIyID0gc3RyaW5naWZpZXI7XG5sZXQgc3RyaW5naWZ5JDMgPSBzdHJpbmdpZnlfMTtcbmZ1bmN0aW9uIGNsb25lTm9kZShvYmosIHBhcmVudCkge1xuICBsZXQgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuICBmb3IgKGxldCBpMiBpbiBvYmopIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpMiA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgIGxldCB2YWx1ZSA9IG9ialtpMl07XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKGkyID09PSBcInBhcmVudFwiICYmIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChwYXJlbnQpIGNsb25lZFtpMl0gPSBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZS5tYXAoKGopID0+IGNsb25lTm9kZShqLCBjbG9uZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlKHZhbHVlKTtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmxldCBOb2RlJDQgPSBjbGFzcyBOb2RlMyB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzID0ge30pIHtcbiAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICB0aGlzW2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICB0aGlzW215JDJdID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbm9kZTIgb2YgZGVmYXVsdHNbbmFtZV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUyLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyLmNsb25lKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFkZFRvRXJyb3IoZXJyb3IpIHtcbiAgICBlcnJvci5wb3N0Y3NzTm9kZSA9IHRoaXM7XG4gICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICBsZXQgczIgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZShcbiAgICAgICAgL1xcblxcc3s0fWF0IC8sXG4gICAgICAgIGAkJiR7czIuaW5wdXQuZnJvbX06JHtzMi5zdGFydC5saW5lfToke3MyLnN0YXJ0LmNvbHVtbn0kJmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBhZnRlcihhZGQpIHtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBhZGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzc2lnbihvdmVycmlkZXMgPSB7fSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWZvcmUoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5iZWZvcmU7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlcjtcbiAgICBpZiAoIWtlZXBCZXR3ZWVuKSBkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47XG4gIH1cbiAgY2xvbmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gY2xvbmVOb2RlKHRoaXMpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgY2xvbmVBZnRlcihvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lQmVmb3JlKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGVycm9yKG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbGV0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5yYW5nZUJ5KG9wdHMpO1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB7IGNvbHVtbjogc3RhcnQuY29sdW1uLCBsaW5lOiBzdGFydC5saW5lIH0sXG4gICAgICAgIHsgY29sdW1uOiBlbmQuY29sdW1uLCBsaW5lOiBlbmQubGluZSB9LFxuICAgICAgICBvcHRzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENzc1N5bnRheEVycm9yJDIobWVzc2FnZSk7XG4gIH1cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgbWFya0RpcnR5KCkge1xuICAgIGlmICh0aGlzW2lzQ2xlYW4kMl0pIHtcbiAgICAgIHRoaXNbaXNDbGVhbiQyXSA9IGZhbHNlO1xuICAgICAgbGV0IG5leHQgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5leHQgPSBuZXh0LnBhcmVudCkge1xuICAgICAgICBuZXh0W2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gIH1cbiAgcG9zaXRpb25CeShvcHRzLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgIGxldCBwb3MgPSB0aGlzLnNvdXJjZS5zdGFydDtcbiAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHRzLndvcmQpIHtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgbGV0IGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKSBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIHBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgIGxldCBjb2x1bW4gPSB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW47XG4gICAgbGV0IGxpbmUgPSB0aGlzLnNvdXJjZS5zdGFydC5saW5lO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBpbmRleDI7IGkyKyspIHtcbiAgICAgIGlmIChzdHJpbmdbaTJdID09PSBcIlxcblwiKSB7XG4gICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgIGxpbmUgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUgfTtcbiAgfVxuICBwcmV2KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgLSAxXTtcbiAgfVxuICByYW5nZUJ5KG9wdHMpIHtcbiAgICBsZXQgc3RhcnQgPSB7XG4gICAgICBjb2x1bW46IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbixcbiAgICAgIGxpbmU6IHRoaXMuc291cmNlLnN0YXJ0LmxpbmVcbiAgICB9O1xuICAgIGxldCBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICB9IDoge1xuICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgbGluZTogc3RhcnQubGluZVxuICAgIH07XG4gICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgbGV0IGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIgKyBvcHRzLndvcmQubGVuZ3RoLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRzLnN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIGNvbHVtbjogb3B0cy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuZW5kKSB7XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICBjb2x1bW46IG9wdHMuZW5kLmNvbHVtbixcbiAgICAgICAgICBsaW5lOiBvcHRzLmVuZC5saW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmVuZEluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQubGluZSA8IHN0YXJ0LmxpbmUgfHwgZW5kLmxpbmUgPT09IHN0YXJ0LmxpbmUgJiYgZW5kLmNvbHVtbiA8PSBzdGFydC5jb2x1bW4pIHtcbiAgICAgIGVuZCA9IHsgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLCBsaW5lOiBzdGFydC5saW5lIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuZCwgc3RhcnQgfTtcbiAgfVxuICByYXcocHJvcCwgZGVmYXVsdFR5cGUpIHtcbiAgICBsZXQgc3RyID0gbmV3IFN0cmluZ2lmaWVyMjIoKTtcbiAgICByZXR1cm4gc3RyLnJhdyh0aGlzLCBwcm9wLCBkZWZhdWx0VHlwZSk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlcGxhY2VXaXRoKC4uLm5vZGVzKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBsZXQgYm9va21hcmsgPSB0aGlzO1xuICAgICAgbGV0IGZvdW5kU2VsZiA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUyID09PSB0aGlzKSB7XG4gICAgICAgICAgZm91bmRTZWxmID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZTIpO1xuICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRTZWxmKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvb3QoKSB7XG4gICAgbGV0IHJlc3VsdDIgPSB0aGlzO1xuICAgIHdoaWxlIChyZXN1bHQyLnBhcmVudCAmJiByZXN1bHQyLnBhcmVudC50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdG9KU09OKF8sIGlucHV0cykge1xuICAgIGxldCBmaXhlZCA9IHt9O1xuICAgIGxldCBlbWl0SW5wdXRzID0gaW5wdXRzID09IG51bGw7XG4gICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGlucHV0c05leHRJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcInBhcmVudFwiIHx8IG5hbWUgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS5tYXAoKGkyKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBpMi50b0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiBpMi50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS50b0pTT04pIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICBsZXQgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICBpZiAoaW5wdXRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpO1xuICAgICAgICAgIGlucHV0c05leHRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgIGVuZDogdmFsdWUuZW5kLFxuICAgICAgICAgIGlucHV0SWQsXG4gICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgZml4ZWQuaW5wdXRzID0gWy4uLmlucHV0cy5rZXlzKCldLm1hcCgoaW5wdXQyKSA9PiBpbnB1dDIudG9KU09OKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZml4ZWQ7XG4gIH1cbiAgdG9Qcm94eSgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3h5Q2FjaGU7XG4gIH1cbiAgdG9TdHJpbmcoc3RyaW5naWZpZXIyID0gc3RyaW5naWZ5JDMpIHtcbiAgICBpZiAoc3RyaW5naWZpZXIyLnN0cmluZ2lmeSkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZpZXIyLnN0cmluZ2lmeTtcbiAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgc3RyaW5naWZpZXIyKHRoaXMsIChpMikgPT4ge1xuICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm9kZTogdGhpcyB9O1xuICAgIGZvciAobGV0IGkyIGluIG9wdHMpIGRhdGFbaTJdID0gb3B0c1tpMl07XG4gICAgcmV0dXJuIHJlc3VsdDIud2Fybih0ZXh0LCBkYXRhKTtcbiAgfVxuICBnZXQgcHJveHlPZigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub2RlID0gTm9kZSQ0O1xuTm9kZSQ0LmRlZmF1bHQgPSBOb2RlJDQ7XG5sZXQgTm9kZSQzID0gbm9kZTtcbmxldCBEZWNsYXJhdGlvbiQ0ID0gY2xhc3MgRGVjbGFyYXRpb24yIGV4dGVuZHMgTm9kZSQzIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBpZiAoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKSB9O1xuICAgIH1cbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJkZWNsXCI7XG4gIH1cbiAgZ2V0IHZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aChcIi0tXCIpIHx8IHRoaXMucHJvcFswXSA9PT0gXCIkXCI7XG4gIH1cbn07XG52YXIgZGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbiQ0O1xuRGVjbGFyYXRpb24kNC5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNDtcbmxldCB1cmxBbHBoYWJldCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICBsZXQgaTIgPSBzaXplO1xuICAgIHdoaWxlIChpMi0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoIHwgMF07XG4gICAgfVxuICAgIHJldHVybiBpZDtcbiAgfTtcbn07XG5sZXQgbmFub2lkJDEgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9IFwiXCI7XG4gIGxldCBpMiA9IHNpemU7XG4gIHdoaWxlIChpMi0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcbnZhciBub25TZWN1cmUgPSB7IG5hbm9pZDogbmFub2lkJDEsIGN1c3RvbUFscGhhYmV0IH07XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lcjogU291cmNlTWFwQ29uc3VtZXIkMiwgU291cmNlTWFwR2VuZXJhdG9yOiBTb3VyY2VNYXBHZW5lcmF0b3IkMiB9ID0gcmVxdWlyZSQkMjtcbmxldCB7IGV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyB9ID0gcmVxdWlyZSQkMjtcbmxldCB7IGRpcm5hbWU6IGRpcm5hbWUkMSwgam9pbiB9ID0gcmVxdWlyZSQkMjtcbmZ1bmN0aW9uIGZyb21CYXNlNjQoc3RyKSB7XG4gIGlmIChCdWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpO1xuICB9XG59XG5sZXQgUHJldmlvdXNNYXAkMiA9IGNsYXNzIFByZXZpb3VzTWFwMiB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cykge1xuICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICB0aGlzLmxvYWRBbm5vdGF0aW9uKGNzcyk7XG4gICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgbGV0IHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB2b2lkIDA7XG4gICAgbGV0IHRleHQgPSB0aGlzLmxvYWRNYXAob3B0cy5mcm9tLCBwcmV2KTtcbiAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwRmlsZSkgdGhpcy5yb290ID0gZGlybmFtZSQxKHRoaXMubWFwRmlsZSk7XG4gICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgY29uc3VtZXIoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQyKHRoaXMudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnN1bWVyQ2FjaGU7XG4gIH1cbiAgZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICBsZXQgYmFzZUNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvO1xuICAgIGxldCBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICBsZXQgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsLztcbiAgICBsZXQgdXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbiwvO1xuICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICB9XG4gICAgaWYgKGJhc2VDaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgYmFzZVVyaS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm4gZnJvbUJhc2U2NCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgIH1cbiAgICBsZXQgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvblVSTChzb3VyY2VNYXBTdHJpbmcpIHtcbiAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nLnJlcGxhY2UoL15cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS8sIFwiXCIpLnRyaW0oKTtcbiAgfVxuICBpc01hcChtYXApIHtcbiAgICBpZiAodHlwZW9mIG1hcCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0eXBlb2YgbWFwLm1hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYXAuX21hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkobWFwLnNlY3Rpb25zKTtcbiAgfVxuICBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICBsZXQgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2dtKTtcbiAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgbGV0IHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKTtcbiAgICBsZXQgZW5kID0gY3NzLmluZGV4T2YoXCIqL1wiLCBzdGFydCk7XG4gICAgaWYgKHN0YXJ0ID4gLTEgJiYgZW5kID4gLTEpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICB9XG4gIH1cbiAgbG9hZEZpbGUocGF0aCkge1xuICAgIHRoaXMucm9vdCA9IGRpcm5hbWUkMShwYXRoKTtcbiAgICBpZiAoZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgIHJldHVybiByZWFkRmlsZVN5bmMocGF0aCwgXCJ1dGYtOFwiKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsZXQgcHJldlBhdGggPSBwcmV2KGZpbGUpO1xuICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICBsZXQgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aCk7XG4gICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiBcIiArIHByZXZQYXRoLnRvU3RyaW5nKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcENvbnN1bWVyJDIpIHtcbiAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcEdlbmVyYXRvciQyKSB7XG4gICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgcHJldmlvdXMgc291cmNlIG1hcCBmb3JtYXQ6IFwiICsgcHJldi50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFubm90YXRpb247XG4gICAgICBpZiAoZmlsZSkgbWFwID0gam9pbihkaXJuYW1lJDEoZmlsZSksIG1hcCk7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXApO1xuICAgIH1cbiAgfVxuICBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgc3RhcnQubGVuZ3RoKSA9PT0gc3RhcnQ7XG4gIH1cbiAgd2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudCAmJiB0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQubGVuZ3RoID4gMCk7XG4gIH1cbn07XG52YXIgcHJldmlvdXNNYXAgPSBQcmV2aW91c01hcCQyO1xuUHJldmlvdXNNYXAkMi5kZWZhdWx0ID0gUHJldmlvdXNNYXAkMjtcbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lciQxLCBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvciQxIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTDogcGF0aFRvRmlsZVVSTCQxIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgaXNBYnNvbHV0ZSwgcmVzb2x2ZTogcmVzb2x2ZSQxIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgbmFub2lkIH0gPSBub25TZWN1cmU7XG5sZXQgdGVybWluYWxIaWdobGlnaHQgPSByZXF1aXJlJCQyO1xubGV0IENzc1N5bnRheEVycm9yJDEgPSBjc3NTeW50YXhFcnJvcjtcbmxldCBQcmV2aW91c01hcCQxID0gcHJldmlvdXNNYXA7XG5sZXQgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxICYmIFNvdXJjZU1hcEdlbmVyYXRvciQxKTtcbmxldCBwYXRoQXZhaWxhYmxlJDEgPSBCb29sZWFuKHJlc29sdmUkMSAmJiBpc0Fic29sdXRlKTtcbmxldCBJbnB1dCQ0ID0gY2xhc3MgSW5wdXQyIHtcbiAgY29uc3RydWN0b3IoY3NzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoY3NzID09PSBudWxsIHx8IHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGNzcyA9PT0gXCJvYmplY3RcIiAmJiAhY3NzLnRvU3RyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3RDU1MgcmVjZWl2ZWQgJHtjc3N9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLmNzc1swXSA9PT0gXCJcXHVGRUZGXCIgfHwgdGhpcy5jc3NbMF0gPT09IFwi77++XCIpIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3Muc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRzLmZyb20pIHtcbiAgICAgIGlmICghcGF0aEF2YWlsYWJsZSQxIHx8IC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fCBpc0Fic29sdXRlKG9wdHMuZnJvbSkpIHtcbiAgICAgICAgdGhpcy5maWxlID0gb3B0cy5mcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxKG9wdHMuZnJvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoQXZhaWxhYmxlJDEgJiYgc291cmNlTWFwQXZhaWxhYmxlJDEpIHtcbiAgICAgIGxldCBtYXAgPSBuZXcgUHJldmlvdXNNYXAkMSh0aGlzLmNzcywgb3B0cyk7XG4gICAgICBpZiAobWFwLnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGxldCBmaWxlID0gbWFwLmNvbnN1bWVyKCkuZmlsZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZmlsZSkge1xuICAgICAgdGhpcy5pZCA9IFwiPGlucHV0IGNzcyBcIiArIG5hbm9pZCg2KSArIFwiPlwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gIH1cbiAgZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzID0ge30pIHtcbiAgICBsZXQgcmVzdWx0MiwgZW5kTGluZSwgZW5kQ29sdW1uO1xuICAgIGlmIChsaW5lICYmIHR5cGVvZiBsaW5lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBsZXQgc3RhcnQgPSBsaW5lO1xuICAgICAgbGV0IGVuZCA9IGNvbHVtbjtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICBjb2x1bW4gPSBwb3MuY29sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmU7XG4gICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICBlbmRMaW5lID0gcG9zLmxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IHBvcy5jb2w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghY29sdW1uKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICB9XG4gICAgbGV0IG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKTtcbiAgICBpZiAob3JpZ2luKSB7XG4gICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4ubGluZSA6IHsgY29sdW1uOiBvcmlnaW4uY29sdW1uLCBsaW5lOiBvcmlnaW4ubGluZSB9LFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmNvbHVtbiA6IHsgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLCBsaW5lOiBvcmlnaW4uZW5kTGluZSB9LFxuICAgICAgICBvcmlnaW4uc291cmNlLFxuICAgICAgICBvcmlnaW4uZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMShcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHsgY29sdW1uLCBsaW5lIH0sXG4gICAgICAgIGVuZExpbmUgPT09IHZvaWQgMCA/IGNvbHVtbiA6IHsgY29sdW1uOiBlbmRDb2x1bW4sIGxpbmU6IGVuZExpbmUgfSxcbiAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgIHRoaXMuZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VsdDIuaW5wdXQgPSB7IGNvbHVtbiwgZW5kQ29sdW1uLCBlbmRMaW5lLCBsaW5lLCBzb3VyY2U6IHRoaXMuY3NzIH07XG4gICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwkMSkge1xuICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLmZpbGUpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQyLmlucHV0LmZpbGUgPSB0aGlzLmZpbGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGZyb21PZmZzZXQob2Zmc2V0KSB7XG4gICAgbGV0IGxhc3RMaW5lLCBsaW5lVG9JbmRleDtcbiAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlXSkge1xuICAgICAgbGV0IGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoXCJcXG5cIik7XG4gICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgbGV0IHByZXZJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGwyID0gbGluZXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICAgIGxpbmVUb0luZGV4W2kyXSA9IHByZXZJbmRleDtcbiAgICAgICAgcHJldkluZGV4ICs9IGxpbmVzW2kyXS5sZW5ndGggKyAxO1xuICAgICAgfVxuICAgICAgdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdID0gbGluZVRvSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVUb0luZGV4ID0gdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdO1xuICAgIH1cbiAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdO1xuICAgIGxldCBtaW4gPSAwO1xuICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyO1xuICAgICAgbGV0IG1pZDtcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVUb0luZGV4W21pZF0pIHtcbiAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgbGluZTogbWluICsgMVxuICAgIH07XG4gIH1cbiAgbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZSQxKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8IFwiLlwiLCBmaWxlKTtcbiAgfVxuICBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbnN1bWVyID0gdGhpcy5tYXAuY29uc3VtZXIoKTtcbiAgICBsZXQgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBjb2x1bW4sIGxpbmUgfSk7XG4gICAgaWYgKCFmcm9tLnNvdXJjZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0bztcbiAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbjogZW5kQ29sdW1uLCBsaW5lOiBlbmRMaW5lIH0pO1xuICAgIH1cbiAgICBsZXQgZnJvbVVybDtcbiAgICBpZiAoaXNBYnNvbHV0ZShmcm9tLnNvdXJjZSkpIHtcbiAgICAgIGZyb21VcmwgPSBwYXRoVG9GaWxlVVJMJDEoZnJvbS5zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVXJsID0gbmV3IFVSTChcbiAgICAgICAgZnJvbS5zb3VyY2UsXG4gICAgICAgIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMJDEodGhpcy5tYXAubWFwRmlsZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCByZXN1bHQyID0ge1xuICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgfTtcbiAgICBpZiAoZnJvbVVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiKSB7XG4gICAgICBpZiAoZmlsZVVSTFRvUGF0aCkge1xuICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoKGZyb21VcmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWxlOiBwcm90b2NvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSkgcmVzdWx0Mi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBvZiBbXCJoYXNCT01cIiwgXCJjc3NcIiwgXCJmaWxlXCIsIFwiaWRcIl0pIHtcbiAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAganNvbltuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAganNvbi5tYXAgPSB7IC4uLnRoaXMubWFwIH07XG4gICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlIHx8IHRoaXMuaWQ7XG4gIH1cbn07XG52YXIgaW5wdXQgPSBJbnB1dCQ0O1xuSW5wdXQkNC5kZWZhdWx0ID0gSW5wdXQkNDtcbmlmICh0ZXJtaW5hbEhpZ2hsaWdodCAmJiB0ZXJtaW5hbEhpZ2hsaWdodC5yZWdpc3RlcklucHV0KSB7XG4gIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQoSW5wdXQkNCk7XG59XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgZGlybmFtZSwgcmVsYXRpdmUsIHJlc29sdmUsIHNlcCB9ID0gcmVxdWlyZSQkMjtcbmxldCB7IHBhdGhUb0ZpbGVVUkwgfSA9IHJlcXVpcmUkJDI7XG5sZXQgSW5wdXQkMyA9IGlucHV0O1xubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIgJiYgU291cmNlTWFwR2VuZXJhdG9yKTtcbmxldCBwYXRoQXZhaWxhYmxlID0gQm9vbGVhbihkaXJuYW1lICYmIHJlc29sdmUgJiYgcmVsYXRpdmUgJiYgc2VwKTtcbmxldCBNYXBHZW5lcmF0b3IkMiA9IGNsYXNzIE1hcEdlbmVyYXRvcjIge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdpZnkyLCByb290Miwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgIHRoaXMubWFwT3B0cyA9IG9wdHMubWFwIHx8IHt9O1xuICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jc3MgPSBjc3NTdHJpbmc7XG4gICAgdGhpcy5vcmlnaW5hbENTUyA9IGNzc1N0cmluZztcbiAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRBbm5vdGF0aW9uKCkge1xuICAgIGxldCBjb250ZW50O1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKHRoaXMub3B0cy50bywgdGhpcy5yb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgfVxuICAgIGxldCBlb2wgPSBcIlxcblwiO1xuICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICB0aGlzLmNzcyArPSBlb2wgKyBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY29udGVudCArIFwiICovXCI7XG4gIH1cbiAgYXBwbHlQcmV2TWFwcygpIHtcbiAgICBmb3IgKGxldCBwcmV2IG9mIHRoaXMucHJldmlvdXMoKSkge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgIGxldCByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lKHByZXYuZmlsZSk7XG4gICAgICBsZXQgbWFwO1xuICAgICAgaWYgKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKHByZXYudGV4dCk7XG4gICAgICAgIGlmIChtYXAuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgIH1cbiAgfVxuICBjbGVhckFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIGxldCBub2RlMjtcbiAgICAgIGZvciAobGV0IGkyID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZTIudGV4dC5pbmRleE9mKFwiIyBzb3VyY2VNYXBwaW5nVVJMPVwiKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbio/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGUoKSB7XG4gICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICBpZiAocGF0aEF2YWlsYWJsZSAmJiBzb3VyY2VNYXBBdmFpbGFibGUgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIChpMikgPT4ge1xuICAgICAgICByZXN1bHQyICs9IGkyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdDJdO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZU1hcCgpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpO1xuICAgICAgcHJldi5maWxlID0gdGhpcy5vdXRwdXRGaWxlKCk7XG4gICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYsIHtcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDogeyBjb2x1bW46IDAsIGxpbmU6IDEgfSxcbiAgICAgICAgb3JpZ2luYWw6IHsgY29sdW1uOiAwLCBsaW5lOiAxIH0sXG4gICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTb3VyY2VzQ29udGVudCgpKSB0aGlzLnNldFNvdXJjZXNDb250ZW50KCk7XG4gICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpO1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3NdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzLCB0aGlzLm1hcF07XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgIHRoaXMuY3NzID0gXCJcIjtcbiAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIGxldCBsaW5lID0gMTtcbiAgICBsZXQgY29sdW1uID0gMTtcbiAgICBsZXQgbm9Tb3VyY2UgPSBcIjxubyBzb3VyY2U+XCI7XG4gICAgbGV0IG1hcHBpbmcgPSB7XG4gICAgICBnZW5lcmF0ZWQ6IHsgY29sdW1uOiAwLCBsaW5lOiAwIH0sXG4gICAgICBvcmlnaW5hbDogeyBjb2x1bW46IDAsIGxpbmU6IDAgfSxcbiAgICAgIHNvdXJjZTogXCJcIlxuICAgIH07XG4gICAgbGV0IGxpbmVzLCBsYXN0O1xuICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKHN0ciwgbm9kZTIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMuY3NzICs9IHN0cjtcbiAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcImVuZFwiKSB7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5zdGFydCkge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxO1xuICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwic3RhcnRcIikge1xuICAgICAgICBsZXQgcCA9IG5vZGUyLnBhcmVudCB8fCB7IHJhd3M6IHt9IH07XG4gICAgICAgIGxldCBjaGlsZGxlc3MgPSBub2RlMi50eXBlID09PSBcImRlY2xcIiB8fCBub2RlMi50eXBlID09PSBcImF0cnVsZVwiICYmICFub2RlMi5ub2RlcztcbiAgICAgICAgaWYgKCFjaGlsZGxlc3MgfHwgbm9kZTIgIT09IHAubGFzdCB8fCBwLnJhd3Muc2VtaWNvbG9uKSB7XG4gICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5lbmQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMjtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0Fubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZSgoaTIpID0+IGkyLmFubm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5pbmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lO1xuICAgIH1cbiAgICBsZXQgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoKGkyKSA9PiBpMi5pbmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc01hcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMub3B0cy5tYXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBpc1NvdXJjZXNDb250ZW50KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKChpMikgPT4gaTIud2l0aENvbnRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG91dHB1dEZpbGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMudG8pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJ0by5jc3NcIjtcbiAgICB9XG4gIH1cbiAgcGF0aChmaWxlKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGU7XG4gICAgaWYgKGZpbGUuY2hhckNvZGVBdCgwKSA9PT0gNjApIHJldHVybiBmaWxlO1xuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZTtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZFBhdGhzLmdldChmaWxlKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSh0aGlzLm9wdHMudG8pIDogXCIuXCI7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZnJvbSA9IGRpcm5hbWUocmVzb2x2ZShmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IHJlbGF0aXZlKGZyb20sIGZpbGUpO1xuICAgIHRoaXMubWVtb2l6ZWRQYXRocy5zZXQoZmlsZSwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcHJldmlvdXMoKSB7XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290LndhbGsoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gbm9kZTIuc291cmNlLmlucHV0Lm1hcDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpbnB1dDIgPSBuZXcgSW5wdXQkMyh0aGlzLm9yaWdpbmFsQ1NTLCB0aGlzLm9wdHMpO1xuICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzO1xuICB9XG4gIHNldFNvdXJjZXNDb250ZW50KCkge1xuICAgIGxldCBhbHJlYWR5ID0ge307XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5yb290LndhbGsoKG5vZGUyKSA9PiB7XG4gICAgICAgIGlmIChub2RlMi5zb3VyY2UpIHtcbiAgICAgICAgICBsZXQgZnJvbSA9IG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tO1xuICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmcm9tVXJsID0gdGhpcy51c2VzRmlsZVVybHMgPyB0aGlzLnRvRmlsZVVybChmcm9tKSA6IHRoaXMudG9VcmwodGhpcy5wYXRoKGZyb20pKTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbVVybCwgbm9kZTIuc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICBsZXQgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgIH1cbiAgfVxuICBzb3VyY2VQYXRoKG5vZGUyKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVzZXNGaWxlVXJscykge1xuICAgICAgcmV0dXJuIHRoaXMudG9GaWxlVXJsKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKSk7XG4gICAgfVxuICB9XG4gIHRvQmFzZTY0KHN0cikge1xuICAgIGlmIChCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9XG4gIH1cbiAgdG9GaWxlVXJsKHBhdGgpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGlmIChwYXRoVG9GaWxlVVJMKSB7XG4gICAgICBsZXQgZmlsZVVSTCA9IHBhdGhUb0ZpbGVVUkwocGF0aCkudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5zZXQocGF0aCwgZmlsZVVSTCk7XG4gICAgICByZXR1cm4gZmlsZVVSTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImBtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0b1VybChwYXRoKSB7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGlmIChzZXAgPT09IFwiXFxcXFwiKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcbnZhciBtYXBHZW5lcmF0b3IgPSBNYXBHZW5lcmF0b3IkMjtcbmxldCBOb2RlJDIgPSBub2RlO1xubGV0IENvbW1lbnQkNCA9IGNsYXNzIENvbW1lbnQyIGV4dGVuZHMgTm9kZSQyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJjb21tZW50XCI7XG4gIH1cbn07XG52YXIgY29tbWVudCA9IENvbW1lbnQkNDtcbkNvbW1lbnQkNC5kZWZhdWx0ID0gQ29tbWVudCQ0O1xubGV0IHsgaXNDbGVhbjogaXNDbGVhbiQxLCBteTogbXkkMSB9ID0gc3ltYm9scztcbmxldCBEZWNsYXJhdGlvbiQzID0gZGVjbGFyYXRpb247XG5sZXQgQ29tbWVudCQzID0gY29tbWVudDtcbmxldCBOb2RlJDEgPSBub2RlO1xubGV0IHBhcnNlJDQsIFJ1bGUkNCwgQXRSdWxlJDQsIFJvb3QkNjtcbmZ1bmN0aW9uIGNsZWFuU291cmNlKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5tYXAoKGkyKSA9PiB7XG4gICAgaWYgKGkyLm5vZGVzKSBpMi5ub2RlcyA9IGNsZWFuU291cmNlKGkyLm5vZGVzKTtcbiAgICBkZWxldGUgaTIuc291cmNlO1xuICAgIHJldHVybiBpMjtcbiAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcChub2RlMikge1xuICBub2RlMltpc0NsZWFuJDFdID0gZmFsc2U7XG4gIGlmIChub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgZm9yIChsZXQgaTIgb2Ygbm9kZTIucHJveHlPZi5ub2Rlcykge1xuICAgICAgbWFya0RpcnR5VXAoaTIpO1xuICAgIH1cbiAgfVxufVxubGV0IENvbnRhaW5lciQ3ID0gY2xhc3MgQ29udGFpbmVyMiBleHRlbmRzIE5vZGUkMSB7XG4gIGFwcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlMik7XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgc3VwZXIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2YgdGhpcy5ub2Rlcykgbm9kZTIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICB9XG4gIH1cbiAgZWFjaChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpdGVyYXRvciA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICBsZXQgaW5kZXgyLCByZXN1bHQyO1xuICAgIHdoaWxlICh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXgyXSwgaW5kZXgyKTtcbiAgICAgIGlmIChyZXN1bHQyID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGV2ZXJ5KGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbik7XG4gIH1cbiAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge307XG4gICAgdGhpcy5sYXN0RWFjaCArPSAxO1xuICAgIGxldCBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2g7XG4gICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA9IDA7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9XG4gIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICB9IGVsc2UgaWYgKCFub2RlMltwcm9wXSkge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImVhY2hcIiB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiAmJiBwcm9wLnN0YXJ0c1dpdGgoXCJ3YWxrXCIpKSB7XG4gICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oXG4gICAgICAgICAgICAgIC4uLmFyZ3MubWFwKChpMikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChjaGlsZCwgaW5kZXgyKSA9PiBpMihjaGlsZC50b1Byb3h5KCksIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJldmVyeVwiIHx8IHByb3AgPT09IFwic29tZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKFxuICAgICAgICAgICAgICAoY2hpbGQsIC4uLm90aGVyKSA9PiBjYihjaGlsZC50b1Byb3h5KCksIC4uLm90aGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyLm5vZGVzLm1hcCgoaTIpID0+IGkyLnRvUHJveHkoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJmaXJzdFwiIHx8IHByb3AgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcInNlbGVjdG9yXCIpIHtcbiAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGluZGV4KGNoaWxkKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNoaWxkO1xuICAgIGlmIChjaGlsZC5wcm94eU9mKSBjaGlsZCA9IGNoaWxkLnByb3h5T2Y7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgfVxuICBpbnNlcnRBZnRlcihleGlzdCwgYWRkKSB7XG4gICAgbGV0IGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpO1xuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZTIpO1xuICAgIGxldCBpbmRleDI7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleDIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgbGV0IHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gXCJwcmVwZW5kXCIgOiBmYWxzZTtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSwgdHlwZSkucmV2ZXJzZSgpO1xuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlMik7XG4gICAgbGV0IGluZGV4MjtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICBpZiAoZXhpc3RJbmRleCA8PSBpbmRleDIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5vZGVzID0gY2xlYW5Tb3VyY2UocGFyc2UkNChub2Rlcykubm9kZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBub2RlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vZGVzLnZhbHVlID0gU3RyaW5nKG5vZGVzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gW25ldyBEZWNsYXJhdGlvbiQzKG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3Rvcikge1xuICAgICAgbm9kZXMgPSBbbmV3IFJ1bGUkNChub2RlcyldO1xuICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgbm9kZXMgPSBbbmV3IEF0UnVsZSQ0KG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy50ZXh0KSB7XG4gICAgICBub2RlcyA9IFtuZXcgQ29tbWVudCQzKG5vZGVzKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgfVxuICAgIGxldCBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoKGkyKSA9PiB7XG4gICAgICBpZiAoIWkyW215JDFdKSBDb250YWluZXIyLnJlYnVpbGQoaTIpO1xuICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgIGlmIChpMltpc0NsZWFuJDFdKSBtYXJrRGlydHlVcChpMik7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzYW1wbGUgJiYgdHlwZW9mIHNhbXBsZS5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaTIucGFyZW50ID0gdGhpcy5wcm94eU9mO1xuICAgICAgcmV0dXJuIGkyO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gIH1cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5maXJzdCwgXCJwcmVwZW5kXCIpLnJldmVyc2UoKTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlMik7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IHRoaXMuaW5kZXhlc1tpZF0gKyBub2Rlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaChjaGlsZCkge1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUFsbCgpIHtcbiAgICBmb3IgKGxldCBub2RlMiBvZiB0aGlzLnByb3h5T2Yubm9kZXMpIG5vZGUyLnBhcmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMgPSBbXTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXNbY2hpbGRdLnBhcmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICBsZXQgaW5kZXgyO1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIGlmIChpbmRleDIgPj0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy53YWxrRGVjbHMoKGRlY2wpID0+IHtcbiAgICAgIGlmIChvcHRzLnByb3BzICYmICFvcHRzLnByb3BzLmluY2x1ZGVzKGRlY2wucHJvcCkpIHJldHVybjtcbiAgICAgIGlmIChvcHRzLmZhc3QgJiYgIWRlY2wudmFsdWUuaW5jbHVkZXMob3B0cy5mYXN0KSkgcmV0dXJuO1xuICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZShwYXR0ZXJuLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzb21lKGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgfVxuICB3YWxrKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaCgoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0MjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlMik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0MiAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICByZXN1bHQyID0gY2hpbGQud2FsayhjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9KTtcbiAgfVxuICB3YWxrQXRSdWxlcyhuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrQ29tbWVudHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrRGVjbHMocHJvcCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IHByb3A7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIGNoaWxkLnByb3AgPT09IHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2Fsa1J1bGVzKHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIGNoaWxkLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZmlyc3QoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1swXTtcbiAgfVxuICBnZXQgbGFzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzW3RoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUGFyc2UgPSAoZGVwZW5kYW50KSA9PiB7XG4gIHBhcnNlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJSdWxlID0gKGRlcGVuZGFudCkgPT4ge1xuICBSdWxlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJBdFJ1bGUgPSAoZGVwZW5kYW50KSA9PiB7XG4gIEF0UnVsZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUm9vdCA9IChkZXBlbmRhbnQpID0+IHtcbiAgUm9vdCQ2ID0gZGVwZW5kYW50O1xufTtcbnZhciBjb250YWluZXIgPSBDb250YWluZXIkNztcbkNvbnRhaW5lciQ3LmRlZmF1bHQgPSBDb250YWluZXIkNztcbkNvbnRhaW5lciQ3LnJlYnVpbGQgPSAobm9kZTIpID0+IHtcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0LnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJ1bGUkNC5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMy5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSb290JDYucHJvdG90eXBlKTtcbiAgfVxuICBub2RlMltteSQxXSA9IHRydWU7XG4gIGlmIChub2RlMi5ub2Rlcykge1xuICAgIG5vZGUyLm5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBDb250YWluZXIkNy5yZWJ1aWxkKGNoaWxkKTtcbiAgICB9KTtcbiAgfVxufTtcbmxldCBDb250YWluZXIkNiA9IGNvbnRhaW5lcjtcbmxldCBMYXp5UmVzdWx0JDQsIFByb2Nlc3NvciQzO1xubGV0IERvY3VtZW50JDMgPSBjbGFzcyBEb2N1bWVudDIzIGV4dGVuZHMgQ29udGFpbmVyJDYge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKHsgdHlwZTogXCJkb2N1bWVudFwiLCAuLi5kZWZhdWx0cyB9KTtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG4gIH1cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdCQ0KG5ldyBQcm9jZXNzb3IkMygpLCB0aGlzLCBvcHRzKTtcbiAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgfVxufTtcbkRvY3VtZW50JDMucmVnaXN0ZXJMYXp5UmVzdWx0ID0gKGRlcGVuZGFudCkgPT4ge1xuICBMYXp5UmVzdWx0JDQgPSBkZXBlbmRhbnQ7XG59O1xuRG9jdW1lbnQkMy5yZWdpc3RlclByb2Nlc3NvciA9IChkZXBlbmRhbnQpID0+IHtcbiAgUHJvY2Vzc29yJDMgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGRvY3VtZW50JDEgPSBEb2N1bWVudCQzO1xuRG9jdW1lbnQkMy5kZWZhdWx0ID0gRG9jdW1lbnQkMztcbmxldCBwcmludGVkID0ge307XG52YXIgd2Fybk9uY2UkMiA9IGZ1bmN0aW9uIHdhcm5PbmNlMihtZXNzYWdlKSB7XG4gIGlmIChwcmludGVkW21lc3NhZ2VdKSByZXR1cm47XG4gIHByaW50ZWRbbWVzc2FnZV0gPSB0cnVlO1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59O1xubGV0IFdhcm5pbmckMiA9IGNsYXNzIFdhcm5pbmcyIHtcbiAgY29uc3RydWN0b3IodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gXCJ3YXJuaW5nXCI7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpO1xuICAgICAgdGhpcy5saW5lID0gcmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmU7XG4gICAgICB0aGlzLmVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgfVxuICAgIGZvciAobGV0IG9wdCBpbiBvcHRzKSB0aGlzW29wdF0gPSBvcHRzW29wdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgIHBsdWdpbjogdGhpcy5wbHVnaW4sXG4gICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGx1Z2luKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW4gKyBcIjogXCIgKyB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cbn07XG52YXIgd2FybmluZyA9IFdhcm5pbmckMjtcbldhcm5pbmckMi5kZWZhdWx0ID0gV2FybmluZyQyO1xubGV0IFdhcm5pbmckMSA9IHdhcm5pbmc7XG5sZXQgUmVzdWx0JDMgPSBjbGFzcyBSZXN1bHQyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpIHtcbiAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzO1xuICB9XG4gIHdhcm4odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBvcHRzLnBsdWdpbiA9IHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2FybmluZzIgPSBuZXcgV2FybmluZyQxKHRleHQsIG9wdHMpO1xuICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nMik7XG4gICAgcmV0dXJuIHdhcm5pbmcyO1xuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbHRlcigoaTIpID0+IGkyLnR5cGUgPT09IFwid2FybmluZ1wiKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbn07XG52YXIgcmVzdWx0ID0gUmVzdWx0JDM7XG5SZXN1bHQkMy5kZWZhdWx0ID0gUmVzdWx0JDM7XG5jb25zdCBTSU5HTEVfUVVPVEUgPSBcIidcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgRE9VQkxFX1FVT1RFID0gJ1wiJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgQkFDS1NMQVNIID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNMQVNIID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTUEFDRSA9IFwiIFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBGRUVEID0gXCJcXGZcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgVEFCID0gXCJcdFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDUiA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fU1FVQVJFID0gXCJbXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX1NRVUFSRSA9IFwiXVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUEVOX1BBUkVOVEhFU0VTID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX1BBUkVOVEhFU0VTID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fQ1VSTFkgPSBcIntcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfQ1VSTFkgPSBcIn1cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgU0VNSUNPTE9OID0gXCI7XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEFTVEVSSVNLID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENPTE9OID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEFUID0gXCJAXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFJFX0FUX0VORCA9IC9bXFx0XFxuXFxmXFxyIFwiIycoKS87W1xcXFxcXF17fV0vZztcbmNvbnN0IFJFX1dPUkRfRU5EID0gL1tcXHRcXG5cXGZcXHIgIVwiIycoKTo7QFtcXFxcXFxde31dfFxcLyg/PVxcKikvZztcbmNvbnN0IFJFX0JBRF9CUkFDS0VUID0gLy5bXFxyXFxuXCInKC9cXFxcXS87XG5jb25zdCBSRV9IRVhfRVNDQVBFID0gL1tcXGRhLWZdL2k7XG52YXIgdG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZXIyKGlucHV0Miwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjc3MgPSBpbnB1dDIuY3NzLnZhbHVlT2YoKTtcbiAgbGV0IGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzO1xuICBsZXQgY29kZSwgbmV4dCwgcXVvdGUsIGNvbnRlbnQsIGVzY2FwZTtcbiAgbGV0IGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbjIsIGN1cnJlbnRUb2tlbjtcbiAgbGV0IGxlbmd0aCA9IGNzcy5sZW5ndGg7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgYnVmZmVyID0gW107XG4gIGxldCByZXR1cm5lZCA9IFtdO1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICB0aHJvdyBpbnB1dDIuZXJyb3IoXCJVbmNsb3NlZCBcIiArIHdoYXQsIHBvcyk7XG4gIH1cbiAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBuZXh0VG9rZW4ob3B0cykge1xuICAgIGlmIChyZXR1cm5lZC5sZW5ndGgpIHJldHVybiByZXR1cm5lZC5wb3AoKTtcbiAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuO1xuICAgIGxldCBpZ25vcmVVbmNsb3NlZCA9IG9wdHMgPyBvcHRzLmlnbm9yZVVuY2xvc2VkIDogZmFsc2U7XG4gICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIE5FV0xJTkU6XG4gICAgICBjYXNlIFNQQUNFOlxuICAgICAgY2FzZSBUQUI6XG4gICAgICBjYXNlIENSOlxuICAgICAgY2FzZSBGRUVEOiB7XG4gICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICB9IHdoaWxlIChjb2RlID09PSBTUEFDRSB8fCBjb2RlID09PSBORVdMSU5FIHx8IGNvZGUgPT09IFRBQiB8fCBjb2RlID09PSBDUiB8fCBjb2RlID09PSBGRUVEKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW1wic3BhY2VcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCldO1xuICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIE9QRU5fU1FVQVJFOlxuICAgICAgY2FzZSBDTE9TRV9TUVVBUkU6XG4gICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICBjYXNlIENMT1NFX0NVUkxZOlxuICAgICAgY2FzZSBDT0xPTjpcbiAgICAgIGNhc2UgU0VNSUNPTE9OOlxuICAgICAgY2FzZSBDTE9TRV9QQVJFTlRIRVNFUzoge1xuICAgICAgICBsZXQgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbY29udHJvbENoYXIsIGNvbnRyb2xDaGFyLCBwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUzoge1xuICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6IFwiXCI7XG4gICAgICAgIG4yID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgIGlmIChwcmV2ID09PSBcInVybFwiICYmIG4yICE9PSBTSU5HTEVfUVVPVEUgJiYgbjIgIT09IERPVUJMRV9RVU9URSAmJiBuMiAhPT0gU1BBQ0UgJiYgbjIgIT09IE5FV0xJTkUgJiYgbjIgIT09IFRBQiAmJiBuMiAhPT0gRkVFRCAmJiBuMiAhPT0gQ1IpIHtcbiAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgY3VycmVudFRva2VuID0gW1wiYnJhY2tldHNcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBwb3MgKyAxKTtcbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCIoXCIsIFwiKFwiLCBwb3NdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJicmFja2V0c1wiLCBjb250ZW50LCBwb3MsIG5leHRdO1xuICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFNJTkdMRV9RVU9URTpcbiAgICAgIGNhc2UgRE9VQkxFX1FVT1RFOiB7XG4gICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFID8gXCInXCIgOiAnXCInO1xuICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW1wic3RyaW5nXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEFUOiB7XG4gICAgICAgIFJFX0FUX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICBSRV9BVF9FTkQudGVzdChjc3MpO1xuICAgICAgICBpZiAoUkVfQVRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gUkVfQVRfRU5ELmxhc3RJbmRleCAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRva2VuID0gW1wiYXQtd29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBCQUNLU0xBU0g6IHtcbiAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgICAgaWYgKGVzY2FwZSAmJiBjb2RlICE9PSBTTEFTSCAmJiBjb2RlICE9PSBTUEFDRSAmJiBjb2RlICE9PSBORVdMSU5FICYmIGNvZGUgIT09IFRBQiAmJiBjb2RlICE9PSBDUiAmJiBjb2RlICE9PSBGRUVEKSB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGlmIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgIHdoaWxlIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRva2VuID0gW1wid29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0ggJiYgY3NzLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgcG9zICsgMikgKyAxO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJjb21tZW50XCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgUkVfV09SRF9FTkQudGVzdChjc3MpO1xuICAgICAgICAgIGlmIChSRV9XT1JEX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCA9IFJFX1dPUkRfRU5ELmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcIndvcmRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgfVxuICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgcmV0dXJuZWQucHVzaCh0b2tlbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYWNrLFxuICAgIGVuZE9mRmlsZSxcbiAgICBuZXh0VG9rZW4sXG4gICAgcG9zaXRpb25cbiAgfTtcbn07XG5sZXQgQ29udGFpbmVyJDUgPSBjb250YWluZXI7XG5sZXQgQXRSdWxlJDMgPSBjbGFzcyBBdFJ1bGUyIGV4dGVuZHMgQ29udGFpbmVyJDUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICB9XG4gIGFwcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gIH1cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmQoLi4uY2hpbGRyZW4pO1xuICB9XG59O1xudmFyIGF0UnVsZSA9IEF0UnVsZSQzO1xuQXRSdWxlJDMuZGVmYXVsdCA9IEF0UnVsZSQzO1xuQ29udGFpbmVyJDUucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlJDMpO1xubGV0IENvbnRhaW5lciQ0ID0gY29udGFpbmVyO1xubGV0IExhenlSZXN1bHQkMywgUHJvY2Vzc29yJDI7XG5sZXQgUm9vdCQ1ID0gY2xhc3MgUm9vdDIgZXh0ZW5kcyBDb250YWluZXIkNCB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICB9XG4gIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgbGV0IG5vZGVzID0gc3VwZXIubm9ybWFsaXplKGNoaWxkKTtcbiAgICBpZiAoc2FtcGxlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHNhbXBsZS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQsIGlnbm9yZSkge1xuICAgIGxldCBpbmRleDIgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICBpZiAoIWlnbm9yZSAmJiBpbmRleDIgPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleDJdLnJhd3MuYmVmb3JlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRvUmVzdWx0KG9wdHMgPSB7fSkge1xuICAgIGxldCBsYXp5ID0gbmV3IExhenlSZXN1bHQkMyhuZXcgUHJvY2Vzc29yJDIoKSwgdGhpcywgb3B0cyk7XG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gIH1cbn07XG5Sb290JDUucmVnaXN0ZXJMYXp5UmVzdWx0ID0gKGRlcGVuZGFudCkgPT4ge1xuICBMYXp5UmVzdWx0JDMgPSBkZXBlbmRhbnQ7XG59O1xuUm9vdCQ1LnJlZ2lzdGVyUHJvY2Vzc29yID0gKGRlcGVuZGFudCkgPT4ge1xuICBQcm9jZXNzb3IkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgcm9vdCA9IFJvb3QkNTtcblJvb3QkNS5kZWZhdWx0ID0gUm9vdCQ1O1xuQ29udGFpbmVyJDQucmVnaXN0ZXJSb290KFJvb3QkNSk7XG5sZXQgbGlzdCQyID0ge1xuICBjb21tYShzdHJpbmcpIHtcbiAgICByZXR1cm4gbGlzdCQyLnNwbGl0KHN0cmluZywgW1wiLFwiXSwgdHJ1ZSk7XG4gIH0sXG4gIHNwYWNlKHN0cmluZykge1xuICAgIGxldCBzcGFjZXMgPSBbXCIgXCIsIFwiXFxuXCIsIFwiXHRcIl07XG4gICAgcmV0dXJuIGxpc3QkMi5zcGxpdChzdHJpbmcsIHNwYWNlcyk7XG4gIH0sXG4gIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgIGxldCBhcnJheSA9IFtdO1xuICAgIGxldCBjdXJyZW50ID0gXCJcIjtcbiAgICBsZXQgc3BsaXQgPSBmYWxzZTtcbiAgICBsZXQgZnVuYyA9IDA7XG4gICAgbGV0IGluUXVvdGUgPSBmYWxzZTtcbiAgICBsZXQgcHJldlF1b3RlID0gXCJcIjtcbiAgICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgbGV0dGVyIG9mIHN0cmluZykge1xuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3RlKSB7XG4gICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgcHJldlF1b3RlID0gbGV0dGVyO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKFwiKSB7XG4gICAgICAgIGZ1bmMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIilcIikge1xuICAgICAgICBpZiAoZnVuYyA+IDApIGZ1bmMgLT0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmNsdWRlcyhsZXR0ZXIpKSBzcGxpdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgc3BsaXQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCB8fCBjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG52YXIgbGlzdF8xID0gbGlzdCQyO1xubGlzdCQyLmRlZmF1bHQgPSBsaXN0JDI7XG5sZXQgQ29udGFpbmVyJDMgPSBjb250YWluZXI7XG5sZXQgbGlzdCQxID0gbGlzdF8xO1xubGV0IFJ1bGUkMyA9IGNsYXNzIFJ1bGUyIGV4dGVuZHMgQ29udGFpbmVyJDMge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgfVxuICBnZXQgc2VsZWN0b3JzKCkge1xuICAgIHJldHVybiBsaXN0JDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gIH1cbiAgc2V0IHNlbGVjdG9ycyh2YWx1ZXMpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKSA6IG51bGw7XG4gICAgbGV0IHNlcDIgPSBtYXRjaCA/IG1hdGNoWzBdIDogXCIsXCIgKyB0aGlzLnJhdyhcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgIHRoaXMuc2VsZWN0b3IgPSB2YWx1ZXMuam9pbihzZXAyKTtcbiAgfVxufTtcbnZhciBydWxlID0gUnVsZSQzO1xuUnVsZSQzLmRlZmF1bHQgPSBSdWxlJDM7XG5Db250YWluZXIkMy5yZWdpc3RlclJ1bGUoUnVsZSQzKTtcbmxldCBEZWNsYXJhdGlvbiQyID0gZGVjbGFyYXRpb247XG5sZXQgdG9rZW5pemVyMjIgPSB0b2tlbml6ZTtcbmxldCBDb21tZW50JDIgPSBjb21tZW50O1xubGV0IEF0UnVsZSQyID0gYXRSdWxlO1xubGV0IFJvb3QkNCA9IHJvb3Q7XG5sZXQgUnVsZSQyID0gcnVsZTtcbmNvbnN0IFNBRkVfQ09NTUVOVF9ORUlHSEJPUiA9IHtcbiAgZW1wdHk6IHRydWUsXG4gIHNwYWNlOiB0cnVlXG59O1xuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSB7XG4gIGZvciAobGV0IGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgIGxldCBwb3MgPSB0b2tlblszXSB8fCB0b2tlblsyXTtcbiAgICBpZiAocG9zKSByZXR1cm4gcG9zO1xuICB9XG59XG5sZXQgUGFyc2VyJDEgPSBjbGFzcyBQYXJzZXIyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQyKSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0MjtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0KCk7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgdGhpcy5yb290LnNvdXJjZSA9IHsgaW5wdXQ6IGlucHV0Miwgc3RhcnQ6IHsgY29sdW1uOiAxLCBsaW5lOiAxLCBvZmZzZXQ6IDAgfSB9O1xuICB9XG4gIGF0cnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBBdFJ1bGUkMigpO1xuICAgIG5vZGUyLm5hbWUgPSB0b2tlblsxXS5zbGljZSgxKTtcbiAgICBpZiAobm9kZTIubmFtZSA9PT0gXCJcIikge1xuICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbik7XG4gICAgfVxuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCBzaGlmdDtcbiAgICBsZXQgbGFzdCA9IGZhbHNlO1xuICAgIGxldCBvcGVuID0gZmFsc2U7XG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBwcmV2ID0gcGFyYW1zW3NoaWZ0XTtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIHByZXZbMF0gPT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICBwcmV2ID0gcGFyYW1zWy0tc2hpZnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKTtcbiAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHBhcmFtcyk7XG4gICAgICB0aGlzLnJhdyhub2RlMiwgXCJwYXJhbXNcIiwgcGFyYW1zKTtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSBcIlwiO1xuICAgICAgbm9kZTIucGFyYW1zID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9XG4gIH1cbiAgY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpO1xuICAgIGlmIChjb2xvbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBsZXQgZm91bmRlZCA9IDA7XG4gICAgbGV0IHRva2VuO1xuICAgIGZvciAobGV0IGogPSBjb2xvbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgIGZvdW5kZWQgKz0gMTtcbiAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJNaXNzZWQgc2VtaWNvbG9uXCIsXG4gICAgICB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXVxuICAgICk7XG4gIH1cbiAgY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGJyYWNrZXRzID0gMDtcbiAgICBsZXQgdG9rZW4sIHR5cGUsIHByZXY7XG4gICAgZm9yIChsZXQgW2kyLCBlbGVtZW50XSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICB0b2tlbiA9IGVsZW1lbnQ7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIpIHtcbiAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIilcIikge1xuICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09IFwid29yZFwiICYmIHByZXZbMV0gPT09IFwicHJvZ2lkXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXYgPSB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbW1lbnQodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgQ29tbWVudCQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgbGV0IHRleHQgPSB0b2tlblsxXS5zbGljZSgyLCAtMik7XG4gICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgIG5vZGUyLnRleHQgPSBcIlwiO1xuICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gdGV4dDtcbiAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pO1xuICAgICAgbm9kZTIudGV4dCA9IG1hdGNoWzJdO1xuICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gbWF0Y2hbMV07XG4gICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gbWF0Y2hbM107XG4gICAgfVxuICB9XG4gIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjIyKHRoaXMuaW5wdXQpO1xuICB9XG4gIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCBub2RlMiA9IG5ldyBEZWNsYXJhdGlvbiQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgIGxldCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFswXSA9PT0gXCI7XCIpIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgIHRva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24oXG4gICAgICBsYXN0WzNdIHx8IGxhc3RbMl0gfHwgZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKVxuICAgICk7XG4gICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICB3aGlsZSAodG9rZW5zWzBdWzBdICE9PSBcIndvcmRcIikge1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgbm9kZTIucHJvcCA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxldCB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUyLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgbGV0IHRva2VuO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgaWYgKHRva2VuWzBdID09PSBcIjpcIikge1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSBcIndvcmRcIiAmJiAvXFx3Ly50ZXN0KHRva2VuWzFdKSkge1xuICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW3Rva2VuXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZTIucHJvcFswXSA9PT0gXCJfXCIgfHwgbm9kZTIucHJvcFswXSA9PT0gXCIqXCIpIHtcbiAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IG5vZGUyLnByb3BbMF07XG4gICAgICBub2RlMi5wcm9wID0gbm9kZTIucHJvcC5zbGljZSgxKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0U3BhY2VzID0gW107XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIGZpcnN0U3BhY2VzLnB1c2godG9rZW5zLnNoaWZ0KCkpO1xuICAgIH1cbiAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgZm9yIChsZXQgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiIWltcG9ydGFudFwiKSB7XG4gICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nO1xuICAgICAgICBpZiAoc3RyaW5nICE9PSBcIiAhaW1wb3J0YW50XCIpIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICBsZXQgY2FjaGUgPSB0b2tlbnMuc2xpY2UoMCk7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBqID0gaTI7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwICYmIHR5cGUgIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGNhY2hlLnBvcCgpWzFdICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwKSB7XG4gICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cjtcbiAgICAgICAgICB0b2tlbnMgPSBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIgJiYgdG9rZW5bMF0gIT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGFzV29yZCA9IHRva2Vucy5zb21lKChpMikgPT4gaTJbMF0gIT09IFwic3BhY2VcIiAmJiBpMlswXSAhPT0gXCJjb21tZW50XCIpO1xuICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKChpMikgPT4gaTJbMV0pLmpvaW4oXCJcIik7XG4gICAgICBmaXJzdFNwYWNlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnJhdyhub2RlMiwgXCJ2YWx1ZVwiLCBmaXJzdFNwYWNlcy5jb25jYXQodG9rZW5zKSwgY3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChub2RlMi52YWx1ZS5pbmNsdWRlcyhcIjpcIikgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgfVxuICB9XG4gIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiRG91YmxlIGNvbG9uXCIsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aCB9XG4gICAgKTtcbiAgfVxuICBlbXB0eVJ1bGUodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgUnVsZSQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc2VsZWN0b3IgPSBcIlwiO1xuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gIH1cbiAgZW5kKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO1xuICAgIH1cbiAgfVxuICBlbmRGaWxlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB0aGlzLnVuY2xvc2VkQmxvY2soKTtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgIHRoaXMucm9vdC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnRva2VuaXplci5wb3NpdGlvbigpKTtcbiAgfVxuICBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcInJ1bGVcIiAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gSGVscGVyc1xuICBnZXRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfVxuICBpbml0KG5vZGUyLCBvZmZzZXQpIHtcbiAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgbm9kZTIuc291cmNlID0ge1xuICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICBzdGFydDogdGhpcy5nZXRQb3NpdGlvbihvZmZzZXQpXG4gICAgfTtcbiAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gIH1cbiAgb3RoZXIoc3RhcnQpIHtcbiAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBjb2xvbiA9IGZhbHNlO1xuICAgIGxldCBicmFja2V0ID0gbnVsbDtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY3VzdG9tUHJvcGVydHkgPSBzdGFydFsxXS5zdGFydHNXaXRoKFwiLS1cIik7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IHN0YXJ0O1xuICAgIHdoaWxlICh0b2tlbikge1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIjpcIikge1xuICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIGVuZCA9IHRydWU7XG4gICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgIH1cbiAgfVxuICBwYXJzZSgpIHtcbiAgICBsZXQgdG9rZW47XG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSBcInNwYWNlXCI6XG4gICAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgdGhpcy5jb21tZW50KHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF0LXdvcmRcIjpcbiAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMub3RoZXIodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZEZpbGUoKTtcbiAgfVxuICBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpIHtcbiAgfVxuICByYXcobm9kZTIsIHByb3AsIHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICBsZXQgdG9rZW4sIHR5cGU7XG4gICAgbGV0IGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBsZXQgY2xlYW4gPSB0cnVlO1xuICAgIGxldCBuZXh0LCBwcmV2O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcInNwYWNlXCIgJiYgaTIgPT09IGxlbmd0aCAtIDEgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICBuZXh0ID0gdG9rZW5zW2kyICsgMV0gPyB0b2tlbnNbaTIgKyAxXVswXSA6IFwiZW1wdHlcIjtcbiAgICAgICAgaWYgKCFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbcHJldl0gJiYgIVNBRkVfQ09NTUVOVF9ORUlHSEJPUltuZXh0XSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2xlYW4pIHtcbiAgICAgIGxldCByYXcgPSB0b2tlbnMucmVkdWNlKChhbGwsIGkyKSA9PiBhbGwgKyBpMlsxXSwgXCJcIik7XG4gICAgICBub2RlMi5yYXdzW3Byb3BdID0geyByYXcsIHZhbHVlIH07XG4gICAgfVxuICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gIH1cbiAgcnVsZSh0b2tlbnMpIHtcbiAgICB0b2tlbnMucG9wKCk7XG4gICAgbGV0IG5vZGUyID0gbmV3IFJ1bGUkMigpO1xuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgIHRoaXMucmF3KG5vZGUyLCBcInNlbGVjdG9yXCIsIHRva2Vucyk7XG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gIH1cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlO1xuICAgIGxldCBzcGFjZXMgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIC8vIEVycm9yc1xuICBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgc3BhY2VzID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGU7XG4gICAgbGV0IHNwYWNlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgc3RyaW5nRnJvbSh0b2tlbnMsIGZyb20pIHtcbiAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgZm9yIChsZXQgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIHJlc3VsdDIgKz0gdG9rZW5zW2kyXVsxXTtcbiAgICB9XG4gICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdW5jbG9zZWRCbG9jaygpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydDtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYmxvY2tcIiwgcG9zLmxpbmUsIHBvcy5jb2x1bW4pO1xuICB9XG4gIHVuY2xvc2VkQnJhY2tldChicmFja2V0KSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiVW5jbG9zZWQgYnJhY2tldFwiLFxuICAgICAgeyBvZmZzZXQ6IGJyYWNrZXRbMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiBicmFja2V0WzJdICsgMSB9XG4gICAgKTtcbiAgfVxuICB1bmV4cGVjdGVkQ2xvc2UodG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIH1cIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgMSB9XG4gICAgKTtcbiAgfVxuICB1bmtub3duV29yZCh0b2tlbnMpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmtub3duIHdvcmRcIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gKyB0b2tlbnNbMF1bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG4gIHVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiQXQtcnVsZSB3aXRob3V0IG5hbWVcIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG59O1xudmFyIHBhcnNlciA9IFBhcnNlciQxO1xubGV0IENvbnRhaW5lciQyID0gY29udGFpbmVyO1xubGV0IFBhcnNlcjIyID0gcGFyc2VyO1xubGV0IElucHV0JDIgPSBpbnB1dDtcbmZ1bmN0aW9uIHBhcnNlJDMoY3NzLCBvcHRzKSB7XG4gIGxldCBpbnB1dDIgPSBuZXcgSW5wdXQkMihjc3MsIG9wdHMpO1xuICBsZXQgcGFyc2VyMiA9IG5ldyBQYXJzZXIyMihpbnB1dDIpO1xuICB0cnkge1xuICAgIHBhcnNlcjIucGFyc2UoKTtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICBpZiAoZmFsc2UpIHt9XG4gICAgdGhyb3cgZTI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlcjIucm9vdDtcbn1cbnZhciBwYXJzZV8xID0gcGFyc2UkMztcbnBhcnNlJDMuZGVmYXVsdCA9IHBhcnNlJDM7XG5Db250YWluZXIkMi5yZWdpc3RlclBhcnNlKHBhcnNlJDMpO1xubGV0IHsgaXNDbGVhbiwgbXkgfSA9IHN5bWJvbHM7XG5sZXQgTWFwR2VuZXJhdG9yJDEgPSBtYXBHZW5lcmF0b3I7XG5sZXQgc3RyaW5naWZ5JDIgPSBzdHJpbmdpZnlfMTtcbmxldCBDb250YWluZXIkMSA9IGNvbnRhaW5lcjtcbmxldCBEb2N1bWVudCQyID0gZG9jdW1lbnQkMTtcbmxldCB3YXJuT25jZSQxID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAod2Fybk9uY2UkMikpO1xubGV0IFJlc3VsdCQyID0gcmVzdWx0O1xubGV0IHBhcnNlJDIgPSBwYXJzZV8xO1xubGV0IFJvb3QkMyA9IHJvb3Q7XG5jb25zdCBUWVBFX1RPX0NMQVNTX05BTUUgPSB7XG4gIGF0cnVsZTogXCJBdFJ1bGVcIixcbiAgY29tbWVudDogXCJDb21tZW50XCIsXG4gIGRlY2w6IFwiRGVjbGFyYXRpb25cIixcbiAgZG9jdW1lbnQ6IFwiRG9jdW1lbnRcIixcbiAgcm9vdDogXCJSb290XCIsXG4gIHJ1bGU6IFwiUnVsZVwiXG59O1xuY29uc3QgUExVR0lOX1BST1BTID0ge1xuICBBdFJ1bGU6IHRydWUsXG4gIEF0UnVsZUV4aXQ6IHRydWUsXG4gIENvbW1lbnQ6IHRydWUsXG4gIENvbW1lbnRFeGl0OiB0cnVlLFxuICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgRGVjbGFyYXRpb25FeGl0OiB0cnVlLFxuICBEb2N1bWVudDogdHJ1ZSxcbiAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICBPbmNlOiB0cnVlLFxuICBPbmNlRXhpdDogdHJ1ZSxcbiAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgcHJlcGFyZTogdHJ1ZSxcbiAgUm9vdDogdHJ1ZSxcbiAgUm9vdEV4aXQ6IHRydWUsXG4gIFJ1bGU6IHRydWUsXG4gIFJ1bGVFeGl0OiB0cnVlXG59O1xuY29uc3QgTk9UX1ZJU0lUT1JTID0ge1xuICBPbmNlOiB0cnVlLFxuICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICBwcmVwYXJlOiB0cnVlXG59O1xuY29uc3QgQ0hJTERSRU4gPSAwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyhub2RlMikge1xuICBsZXQga2V5ID0gZmFsc2U7XG4gIGxldCB0eXBlID0gVFlQRV9UT19DTEFTU19OQU1FW25vZGUyLnR5cGVdO1xuICBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICBrZXkgPSBub2RlMi5wcm9wLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgIGtleSA9IG5vZGUyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpZiAoa2V5ICYmIG5vZGUyLmFwcGVuZCkge1xuICAgIHJldHVybiBbXG4gICAgICB0eXBlLFxuICAgICAgdHlwZSArIFwiLVwiICsga2V5LFxuICAgICAgQ0hJTERSRU4sXG4gICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgXTtcbiAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICByZXR1cm4gW3R5cGUsIHR5cGUgKyBcIi1cIiArIGtleSwgdHlwZSArIFwiRXhpdFwiLCB0eXBlICsgXCJFeGl0LVwiICsga2V5XTtcbiAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICByZXR1cm4gW3R5cGUsIENISUxEUkVOLCB0eXBlICsgXCJFeGl0XCJdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArIFwiRXhpdFwiXTtcbiAgfVxufVxuZnVuY3Rpb24gdG9TdGFjayhub2RlMikge1xuICBsZXQgZXZlbnRzO1xuICBpZiAobm9kZTIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgZXZlbnRzID0gW1wiRG9jdW1lbnRcIiwgQ0hJTERSRU4sIFwiRG9jdW1lbnRFeGl0XCJdO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgZXZlbnRzID0gW1wiUm9vdFwiLCBDSElMRFJFTiwgXCJSb290RXhpdFwiXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBnZXRFdmVudHMobm9kZTIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXZlbnRJbmRleDogMCxcbiAgICBldmVudHMsXG4gICAgaXRlcmF0b3I6IDAsXG4gICAgbm9kZTogbm9kZTIsXG4gICAgdmlzaXRvckluZGV4OiAwLFxuICAgIHZpc2l0b3JzOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gY2xlYW5NYXJrcyhub2RlMikge1xuICBub2RlMltpc0NsZWFuXSA9IGZhbHNlO1xuICBpZiAobm9kZTIubm9kZXMpIG5vZGUyLm5vZGVzLmZvckVhY2goKGkyKSA9PiBjbGVhbk1hcmtzKGkyKSk7XG4gIHJldHVybiBub2RlMjtcbn1cbmxldCBwb3N0Y3NzJDIgPSB7fTtcbmxldCBMYXp5UmVzdWx0JDIgPSBjbGFzcyBMYXp5UmVzdWx0MiB7XG4gIGNvbnN0cnVjdG9yKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlO1xuICAgIGxldCByb290MjtcbiAgICBpZiAodHlwZW9mIGNzcyA9PT0gXCJvYmplY3RcIiAmJiBjc3MgIT09IG51bGwgJiYgKGNzcy50eXBlID09PSBcInJvb3RcIiB8fCBjc3MudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkge1xuICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzKGNzcyk7XG4gICAgfSBlbHNlIGlmIChjc3MgaW5zdGFuY2VvZiBMYXp5UmVzdWx0MiB8fCBjc3MgaW5zdGFuY2VvZiBSZXN1bHQkMikge1xuICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzKGNzcy5yb290KTtcbiAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXAgPT09IFwidW5kZWZpbmVkXCIpIG9wdHMubWFwID0ge307XG4gICAgICAgIGlmICghb3B0cy5tYXAuaW5saW5lKSBvcHRzLm1hcC5pbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXJzZXIyID0gcGFyc2UkMjtcbiAgICAgIGlmIChvcHRzLnN5bnRheCkgcGFyc2VyMiA9IG9wdHMuc3ludGF4LnBhcnNlO1xuICAgICAgaWYgKG9wdHMucGFyc2VyKSBwYXJzZXIyID0gb3B0cy5wYXJzZXI7XG4gICAgICBpZiAocGFyc2VyMi5wYXJzZSkgcGFyc2VyMiA9IHBhcnNlcjIucGFyc2U7XG4gICAgICB0cnkge1xuICAgICAgICByb290MiA9IHBhcnNlcjIoY3NzLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QyICYmICFyb290MltteV0pIHtcbiAgICAgICAgQ29udGFpbmVyJDEucmVidWlsZChyb290Mik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQyKHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKTtcbiAgICB0aGlzLmhlbHBlcnMgPSB7IC4uLnBvc3Rjc3MkMiwgcG9zdGNzczogcG9zdGNzcyQyLCByZXN1bHQ6IHRoaXMucmVzdWx0IH07XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wcm9jZXNzb3IucGx1Z2lucy5tYXAoKHBsdWdpbjIyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLnByZXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucGx1Z2luMjIsIC4uLnBsdWdpbjIyLnByZXBhcmUodGhpcy5yZXN1bHQpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGx1Z2luMjI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgIGlmICghdGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnJ1bkFzeW5jKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gIH1cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gIH1cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICB9XG4gIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2luc1wiKTtcbiAgfVxuICBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICBsZXQgcGx1Z2luMjIgPSB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luO1xuICAgIHRyeSB7XG4gICAgICBpZiAobm9kZTIpIG5vZGUyLmFkZFRvRXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiAhZXJyb3IucGx1Z2luKSB7XG4gICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcHJlcGFyZVZpc2l0b3JzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgbGV0IGFkZCA9IChwbHVnaW4yMiwgdHlwZSwgY2IpID0+IHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtwbHVnaW4yMiwgY2JdKTtcbiAgICB9O1xuICAgIGZvciAobGV0IHBsdWdpbjIyIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiBwbHVnaW4yMikge1xuICAgICAgICAgIGlmICghUExVR0lOX1BST1BTW2V2ZW50XSAmJiAvXltBLVpdLy50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBldmVudCAke2V2ZW50fSBpbiAke3BsdWdpbjIyLnBvc3Rjc3NQbHVnaW59LiBUcnkgdG8gdXBkYXRlIFBvc3RDU1MgKCR7dGhpcy5wcm9jZXNzb3IudmVyc2lvbn0gbm93KS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIU5PVF9WSVNJVE9SU1tldmVudF0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luMjJbZXZlbnRdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGZpbHRlciBpbiBwbHVnaW4yMltldmVudF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhZGQoXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbjIyLFxuICAgICAgICAgICAgICAgICAgICBldmVudCArIFwiLVwiICsgZmlsdGVyLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luMjJbZXZlbnRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oYXNMaXN0ZW5lciA9IE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPiAwO1xuICB9XG4gIGFzeW5jIHJ1bkFzeW5jKCkge1xuICAgIHRoaXMucGx1Z2luID0gMDtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaTIrKykge1xuICAgICAgbGV0IHBsdWdpbjIyID0gdGhpcy5wbHVnaW5zW2kyXTtcbiAgICAgIGxldCBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgIHdoaWxlICghcm9vdDJbaXNDbGVhbl0pIHtcbiAgICAgICAgcm9vdDJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3RhY2sgPSBbdG9TdGFjayhyb290MildO1xuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwcm9taXNlID0gdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICBsZXQgbm9kZTIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgZm9yIChsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSBvZiB0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICBsZXQgcm9vdHMgPSByb290Mi5ub2Rlcy5tYXAoXG4gICAgICAgICAgICAgICAgKHN1YlJvb3QpID0+IHZpc2l0b3Ioc3ViUm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyb290cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhd2FpdCB2aXNpdG9yKHJvb3QyLCB0aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpO1xuICB9XG4gIHJ1bk9uUm9vdChwbHVnaW4yMikge1xuICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5PbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdC5yb290LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgIGxldCByb290cyA9IHRoaXMucmVzdWx0LnJvb3Qubm9kZXMubWFwKFxuICAgICAgICAgICAgKHJvb3QyKSA9PiBwbHVnaW4yMi5PbmNlKHJvb3QyLCB0aGlzLmhlbHBlcnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlKHJvb3RzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvb3RzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbHVnaW4yMi5PbmNlKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMuaGVscGVycyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4yMih0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdpZnkoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgaWYgKHRoaXMuc3RyaW5naWZpZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZTtcbiAgICB0aGlzLnN5bmMoKTtcbiAgICBsZXQgb3B0cyA9IHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeSQyO1xuICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5O1xuICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyO1xuICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yJDEoc3RyLCB0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdC5vcHRzKTtcbiAgICBsZXQgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgIHRoaXMucmVzdWx0LmNzcyA9IGRhdGFbMF07XG4gICAgdGhpcy5yZXN1bHQubWFwID0gZGF0YVsxXTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbjIyIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXBhcmVWaXNpdG9ycygpO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICBsZXQgcm9vdDIgPSB0aGlzLnJlc3VsdC5yb290O1xuICAgICAgd2hpbGUgKCFyb290Mltpc0NsZWFuXSkge1xuICAgICAgICByb290Mltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgIHRoaXMud2Fsa1N5bmMocm9vdDIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgIGlmIChyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICBmb3IgKGxldCBzdWJSb290IG9mIHJvb3QyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgc3ViUm9vdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCByb290Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9XG4gIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICBpZiAoZmFsc2UpIHt9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbiAgdmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMikge1xuICAgIGZvciAobGV0IFtwbHVnaW4yMiwgdmlzaXRvcl0gb2YgdmlzaXRvcnMpIHtcbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgIGxldCBwcm9taXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZTIsIHRoaXMuaGVscGVycyk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMi5wcm94eU9mKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZpc2l0VGljayhzdGFjaykge1xuICAgIGxldCB2aXNpdDIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgeyBub2RlOiBub2RlMiwgdmlzaXRvcnMgfSA9IHZpc2l0MjtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmlzaXRvcnMubGVuZ3RoID4gMCAmJiB2aXNpdDIudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSA9IHZpc2l0b3JzW3Zpc2l0Mi52aXNpdG9ySW5kZXhdO1xuICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCArPSAxO1xuICAgICAgaWYgKHZpc2l0Mi52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSBbXTtcbiAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmlzaXRvcihub2RlMi50b1Byb3h5KCksIHRoaXMuaGVscGVycyk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aXNpdDIuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgIGxldCBpdGVyYXRvciA9IHZpc2l0Mi5pdGVyYXRvcjtcbiAgICAgIGxldCBjaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCA9IG5vZGUyLm5vZGVzW25vZGUyLmluZGV4ZXNbaXRlcmF0b3JdXSkge1xuICAgICAgICBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB7XG4gICAgICAgICAgY2hpbGRbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayhjaGlsZCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmlzaXQyLml0ZXJhdG9yID0gMDtcbiAgICAgIGRlbGV0ZSBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICB9XG4gICAgbGV0IGV2ZW50cyA9IHZpc2l0Mi5ldmVudHM7XG4gICAgd2hpbGUgKHZpc2l0Mi5ldmVudEluZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzW3Zpc2l0Mi5ldmVudEluZGV4XTtcbiAgICAgIHZpc2l0Mi5ldmVudEluZGV4ICs9IDE7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgdmlzaXQyLml0ZXJhdG9yID0gbm9kZTIuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cbiAgd2Fsa1N5bmMobm9kZTIpIHtcbiAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgbGV0IGV2ZW50cyA9IGdldEV2ZW50cyhub2RlMik7XG4gICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgIG5vZGUyLmVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB0aGlzLndhbGtTeW5jKGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBpZiAodmlzaXRvcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyLnRvUHJveHkoKSkpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50O1xuICB9XG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY3NzO1xuICB9XG4gIGdldCBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXM7XG4gIH1cbiAgZ2V0IG9wdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gIH1cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICB9XG4gIGdldCByb290KCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290O1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJMYXp5UmVzdWx0XCI7XG4gIH1cbn07XG5MYXp5UmVzdWx0JDIucmVnaXN0ZXJQb3N0Y3NzID0gKGRlcGVuZGFudCkgPT4ge1xuICBwb3N0Y3NzJDIgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGxhenlSZXN1bHQgPSBMYXp5UmVzdWx0JDI7XG5MYXp5UmVzdWx0JDIuZGVmYXVsdCA9IExhenlSZXN1bHQkMjtcblJvb3QkMy5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyKTtcbkRvY3VtZW50JDIucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMik7XG5sZXQgTWFwR2VuZXJhdG9yMjIgPSBtYXBHZW5lcmF0b3I7XG5sZXQgc3RyaW5naWZ5JDEgPSBzdHJpbmdpZnlfMTtcbmxldCB3YXJuT25jZTIyID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAod2Fybk9uY2UkMikpO1xubGV0IHBhcnNlJDEgPSBwYXJzZV8xO1xuY29uc3QgUmVzdWx0JDEgPSByZXN1bHQ7XG5sZXQgTm9Xb3JrUmVzdWx0JDEgPSBjbGFzcyBOb1dvcmtSZXN1bHQyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgdGhpcy5fY3NzID0gY3NzO1xuICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgICBsZXQgcm9vdDI7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeSQxO1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQxKHRoaXMuX3Byb2Nlc3Nvciwgcm9vdDIsIHRoaXMuX29wdHMpO1xuICAgIHRoaXMucmVzdWx0LmNzcyA9IGNzcztcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucmVzdWx0LCBcInJvb3RcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yb290O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yMjIoc3RyLCByb290MiwgdGhpcy5fb3B0cywgY3NzKTtcbiAgICBpZiAobWFwLmlzTWFwKCkpIHtcbiAgICAgIGxldCBbZ2VuZXJhdGVkQ1NTLCBnZW5lcmF0ZWRNYXBdID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgICBpZiAoZ2VuZXJhdGVkQ1NTKSB7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTUztcbiAgICAgIH1cbiAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXAuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzO1xuICAgIH1cbiAgfVxuICBhc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICB9XG4gIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgfVxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKGZhbHNlKSB7fVxuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NzcztcbiAgfVxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IG9wdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gIH1cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICB9XG4gIGdldCByb290KCkge1xuICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9XG4gICAgbGV0IHJvb3QyO1xuICAgIGxldCBwYXJzZXIyID0gcGFyc2UkMTtcbiAgICB0cnkge1xuICAgICAgcm9vdDIgPSBwYXJzZXIyKHRoaXMuX2NzcywgdGhpcy5fb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSByb290MjtcbiAgICAgIHJldHVybiByb290MjtcbiAgICB9XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIk5vV29ya1Jlc3VsdFwiO1xuICB9XG59O1xudmFyIG5vV29ya1Jlc3VsdCA9IE5vV29ya1Jlc3VsdCQxO1xuTm9Xb3JrUmVzdWx0JDEuZGVmYXVsdCA9IE5vV29ya1Jlc3VsdCQxO1xubGV0IE5vV29ya1Jlc3VsdDIyID0gbm9Xb3JrUmVzdWx0O1xubGV0IExhenlSZXN1bHQkMSA9IGxhenlSZXN1bHQ7XG5sZXQgRG9jdW1lbnQkMSA9IGRvY3VtZW50JDE7XG5sZXQgUm9vdCQyID0gcm9vdDtcbmxldCBQcm9jZXNzb3IkMSA9IGNsYXNzIFByb2Nlc3NvcjIge1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zID0gW10pIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcIjguNC4zOFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpO1xuICB9XG4gIG5vcm1hbGl6ZShwbHVnaW5zKSB7XG4gICAgbGV0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpMiBvZiBwbHVnaW5zKSB7XG4gICAgICBpZiAoaTIucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICBpMiA9IGkyKCk7XG4gICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgaTIgPSBpMi5wb3N0Y3NzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KGkyLnBsdWdpbnMpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpMi5wbHVnaW5zKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIGkyLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIChpMi5wYXJzZSB8fCBpMi5zdHJpbmdpZnkpKSB7XG4gICAgICAgIGlmIChmYWxzZSkge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihpMiArIFwiIGlzIG5vdCBhIFBvc3RDU1MgcGx1Z2luXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuICBwcm9jZXNzKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbnMubGVuZ3RoICYmICFvcHRzLnBhcnNlciAmJiAhb3B0cy5zdHJpbmdpZmllciAmJiAhb3B0cy5zeW50YXgpIHtcbiAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0MjIodGhpcywgY3NzLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEodGhpcywgY3NzLCBvcHRzKTtcbiAgICB9XG4gIH1cbiAgdXNlKHBsdWdpbjIyKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbcGx1Z2luMjJdKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgcHJvY2Vzc29yID0gUHJvY2Vzc29yJDE7XG5Qcm9jZXNzb3IkMS5kZWZhdWx0ID0gUHJvY2Vzc29yJDE7XG5Sb290JDIucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEpO1xuRG9jdW1lbnQkMS5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IkMSk7XG5sZXQgRGVjbGFyYXRpb24kMSA9IGRlY2xhcmF0aW9uO1xubGV0IFByZXZpb3VzTWFwMjIgPSBwcmV2aW91c01hcDtcbmxldCBDb21tZW50JDEgPSBjb21tZW50O1xubGV0IEF0UnVsZSQxID0gYXRSdWxlO1xubGV0IElucHV0JDEgPSBpbnB1dDtcbmxldCBSb290JDEgPSByb290O1xubGV0IFJ1bGUkMSA9IHJ1bGU7XG5mdW5jdGlvbiBmcm9tSlNPTiQxKGpzb24sIGlucHV0cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkgcmV0dXJuIGpzb24ubWFwKChuMikgPT4gZnJvbUpTT04kMShuMikpO1xuICBsZXQgeyBpbnB1dHM6IG93bklucHV0cywgLi4uZGVmYXVsdHMgfSA9IGpzb247XG4gIGlmIChvd25JbnB1dHMpIHtcbiAgICBpbnB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dDIgb2Ygb3duSW5wdXRzKSB7XG4gICAgICBsZXQgaW5wdXRIeWRyYXRlZCA9IHsgLi4uaW5wdXQyLCBfX3Byb3RvX186IElucHV0JDEucHJvdG90eXBlIH07XG4gICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgaW5wdXRIeWRyYXRlZC5tYXAgPSB7XG4gICAgICAgICAgLi4uaW5wdXRIeWRyYXRlZC5tYXAsXG4gICAgICAgICAgX19wcm90b19fOiBQcmV2aW91c01hcDIyLnByb3RvdHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZCk7XG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy5ub2Rlcykge1xuICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAoKG4yKSA9PiBmcm9tSlNPTiQxKG4yLCBpbnB1dHMpKTtcbiAgfVxuICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgbGV0IHsgaW5wdXRJZCwgLi4uc291cmNlIH0gPSBkZWZhdWx0cy5zb3VyY2U7XG4gICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgcmV0dXJuIG5ldyBSb290JDEoZGVmYXVsdHMpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbiQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgIHJldHVybiBuZXcgUnVsZSQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIHJldHVybiBuZXcgQ29tbWVudCQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsganNvbi50eXBlKTtcbiAgfVxufVxudmFyIGZyb21KU09OXzEgPSBmcm9tSlNPTiQxO1xuZnJvbUpTT04kMS5kZWZhdWx0ID0gZnJvbUpTT04kMTtcbmxldCBDc3NTeW50YXhFcnJvcjIyID0gY3NzU3ludGF4RXJyb3I7XG5sZXQgRGVjbGFyYXRpb24yMiA9IGRlY2xhcmF0aW9uO1xubGV0IExhenlSZXN1bHQyMiA9IGxhenlSZXN1bHQ7XG5sZXQgQ29udGFpbmVyMjIgPSBjb250YWluZXI7XG5sZXQgUHJvY2Vzc29yMjIgPSBwcm9jZXNzb3I7XG5sZXQgc3RyaW5naWZ5ID0gc3RyaW5naWZ5XzE7XG5sZXQgZnJvbUpTT04gPSBmcm9tSlNPTl8xO1xubGV0IERvY3VtZW50MjIyID0gZG9jdW1lbnQkMTtcbmxldCBXYXJuaW5nMjIgPSB3YXJuaW5nO1xubGV0IENvbW1lbnQyMiA9IGNvbW1lbnQ7XG5sZXQgQXRSdWxlMjIgPSBhdFJ1bGU7XG5sZXQgUmVzdWx0MjIgPSByZXN1bHQ7XG5sZXQgSW5wdXQyMiA9IGlucHV0O1xubGV0IHBhcnNlID0gcGFyc2VfMTtcbmxldCBsaXN0ID0gbGlzdF8xO1xubGV0IFJ1bGUyMiA9IHJ1bGU7XG5sZXQgUm9vdDIyID0gcm9vdDtcbmxldCBOb2RlMjIgPSBub2RlO1xuZnVuY3Rpb24gcG9zdGNzcyguLi5wbHVnaW5zKSB7XG4gIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IyMihwbHVnaW5zKTtcbn1cbnBvc3Rjc3MucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luMihuYW1lLCBpbml0aWFsaXplcikge1xuICBsZXQgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmICF3YXJuaW5nUHJpbnRlZCkge1xuICAgICAgd2FybmluZ1ByaW50ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIlxuICAgICAgKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5MQU5HICYmIHByb2Nlc3MuZW52LkxBTkcuc3RhcnRzV2l0aChcImNuXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncyk7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1ZlcnNpb24gPSBuZXcgUHJvY2Vzc29yMjIoKS52ZXJzaW9uO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgfVxuICBsZXQgY2FjaGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSk7XG4gIGNyZWF0b3IucHJvY2VzcyA9IGZ1bmN0aW9uKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICByZXR1cm4gcG9zdGNzcyhbY3JlYXRvcihwbHVnaW5PcHRzKV0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gIH07XG4gIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3Muc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xucG9zdGNzcy5wYXJzZSA9IHBhcnNlO1xucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OO1xucG9zdGNzcy5saXN0ID0gbGlzdDtcbnBvc3Rjc3MuY29tbWVudCA9IChkZWZhdWx0cykgPT4gbmV3IENvbW1lbnQyMihkZWZhdWx0cyk7XG5wb3N0Y3NzLmF0UnVsZSA9IChkZWZhdWx0cykgPT4gbmV3IEF0UnVsZTIyKGRlZmF1bHRzKTtcbnBvc3Rjc3MuZGVjbCA9IChkZWZhdWx0cykgPT4gbmV3IERlY2xhcmF0aW9uMjIoZGVmYXVsdHMpO1xucG9zdGNzcy5ydWxlID0gKGRlZmF1bHRzKSA9PiBuZXcgUnVsZTIyKGRlZmF1bHRzKTtcbnBvc3Rjc3Mucm9vdCA9IChkZWZhdWx0cykgPT4gbmV3IFJvb3QyMihkZWZhdWx0cyk7XG5wb3N0Y3NzLmRvY3VtZW50ID0gKGRlZmF1bHRzKSA9PiBuZXcgRG9jdW1lbnQyMjIoZGVmYXVsdHMpO1xucG9zdGNzcy5Dc3NTeW50YXhFcnJvciA9IENzc1N5bnRheEVycm9yMjI7XG5wb3N0Y3NzLkRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24yMjtcbnBvc3Rjc3MuQ29udGFpbmVyID0gQ29udGFpbmVyMjI7XG5wb3N0Y3NzLlByb2Nlc3NvciA9IFByb2Nlc3NvcjIyO1xucG9zdGNzcy5Eb2N1bWVudCA9IERvY3VtZW50MjIyO1xucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudDIyO1xucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZzIyO1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGUyMjtcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0MjI7XG5wb3N0Y3NzLklucHV0ID0gSW5wdXQyMjtcbnBvc3Rjc3MuUnVsZSA9IFJ1bGUyMjtcbnBvc3Rjc3MuUm9vdCA9IFJvb3QyMjtcbnBvc3Rjc3MuTm9kZSA9IE5vZGUyMjtcbkxhenlSZXN1bHQyMi5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcyk7XG52YXIgcG9zdGNzc18xID0gcG9zdGNzcztcbnBvc3Rjc3MuZGVmYXVsdCA9IHBvc3Rjc3M7XG5jb25zdCBwb3N0Y3NzJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocG9zdGNzc18xKTtcbnBvc3Rjc3MkMS5zdHJpbmdpZnk7XG5wb3N0Y3NzJDEuZnJvbUpTT047XG5wb3N0Y3NzJDEucGx1Z2luO1xucG9zdGNzcyQxLnBhcnNlO1xucG9zdGNzcyQxLmxpc3Q7XG5wb3N0Y3NzJDEuZG9jdW1lbnQ7XG5wb3N0Y3NzJDEuY29tbWVudDtcbnBvc3Rjc3MkMS5hdFJ1bGU7XG5wb3N0Y3NzJDEucnVsZTtcbnBvc3Rjc3MkMS5kZWNsO1xucG9zdGNzcyQxLnJvb3Q7XG5wb3N0Y3NzJDEuQ3NzU3ludGF4RXJyb3I7XG5wb3N0Y3NzJDEuRGVjbGFyYXRpb247XG5wb3N0Y3NzJDEuQ29udGFpbmVyO1xucG9zdGNzcyQxLlByb2Nlc3NvcjtcbnBvc3Rjc3MkMS5Eb2N1bWVudDtcbnBvc3Rjc3MkMS5Db21tZW50O1xucG9zdGNzcyQxLldhcm5pbmc7XG5wb3N0Y3NzJDEuQXRSdWxlO1xucG9zdGNzcyQxLlJlc3VsdDtcbnBvc3Rjc3MkMS5JbnB1dDtcbnBvc3Rjc3MkMS5SdWxlO1xucG9zdGNzcyQxLlJvb3Q7XG5wb3N0Y3NzJDEuTm9kZTtcbmNsYXNzIEJhc2VSUk5vZGUge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0cnVjdG9yKC4uLl9hcmdzKSB7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJwYXJlbnRFbGVtZW50XCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50Tm9kZVwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm93bmVyRG9jdW1lbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJmaXJzdENoaWxkXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibGFzdENoaWxkXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicHJldmlvdXNTaWJsaW5nXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibmV4dFNpYmxpbmdcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJFTEVNRU5UX05PREVcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJURVhUX05PREVcIiwgMyk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJub2RlVHlwZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5vZGVOYW1lXCIpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiUlJOb2RlVHlwZVwiKTtcbiAgfVxuICBnZXQgY2hpbGROb2RlcygpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzMiA9IFtdO1xuICAgIGxldCBjaGlsZEl0ZXJhdG9yID0gdGhpcy5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZEl0ZXJhdG9yKSB7XG4gICAgICBjaGlsZE5vZGVzMi5wdXNoKGNoaWxkSXRlcmF0b3IpO1xuICAgICAgY2hpbGRJdGVyYXRvciA9IGNoaWxkSXRlcmF0b3IubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzMjtcbiAgfVxuICBjb250YWlucyhub2RlMikge1xuICAgIGlmICghKG5vZGUyIGluc3RhbmNlb2YgQmFzZVJSTm9kZSkpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIGlmIChub2RlMi5vd25lckRvY3VtZW50ICE9PSB0aGlzLm93bmVyRG9jdW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIGlmIChub2RlMiA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgd2hpbGUgKG5vZGUyLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChub2RlMi5wYXJlbnROb2RlID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgYXBwZW5kQ2hpbGQoX25ld0NoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQ2hpbGQnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuYFxuICAgICk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBpbnNlcnRCZWZvcmUoX25ld0NoaWxkLCBfcmVmQ2hpbGQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdpbnNlcnRCZWZvcmUnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuYFxuICAgICk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW1vdmVDaGlsZChfbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSUkRvbUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ3JlbW92ZUNoaWxkJyBvbiAnUlJOb2RlJzogVGhpcyBSUk5vZGUgdHlwZSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgbWV0aG9kLmBcbiAgICApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJSTm9kZVwiO1xuICB9XG59XG5jb25zdCB0ZXN0YWJsZUFjY2Vzc29ycyA9IHtcbiAgTm9kZTogW1wiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIiwgXCJwYXJlbnRFbGVtZW50XCIsIFwidGV4dENvbnRlbnRcIl0sXG4gIFNoYWRvd1Jvb3Q6IFtcImhvc3RcIiwgXCJzdHlsZVNoZWV0c1wiXSxcbiAgRWxlbWVudDogW1wic2hhZG93Um9vdFwiLCBcInF1ZXJ5U2VsZWN0b3JcIiwgXCJxdWVyeVNlbGVjdG9yQWxsXCJdLFxuICBNdXRhdGlvbk9ic2VydmVyOiBbXVxufTtcbmNvbnN0IHRlc3RhYmxlTWV0aG9kcyA9IHtcbiAgTm9kZTogW1wiY29udGFpbnNcIiwgXCJnZXRSb290Tm9kZVwiXSxcbiAgU2hhZG93Um9vdDogW1wiZ2V0U2VsZWN0aW9uXCJdLFxuICBFbGVtZW50OiBbXSxcbiAgTXV0YXRpb25PYnNlcnZlcjogW1wiY29uc3RydWN0b3JcIl1cbn07XG5jb25zdCB1bnRhaW50ZWRCYXNlUHJvdG90eXBlID0ge307XG5jb25zdCBpc0FuZ3VsYXJab25lUHJlc2VudCA9ICgpID0+IHtcbiAgcmV0dXJuICEhZ2xvYmFsVGhpcy5ab25lO1xufTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpIHtcbiAgaWYgKHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldO1xuICBjb25zdCBkZWZhdWx0T2JqID0gZ2xvYmFsVGhpc1trZXldO1xuICBjb25zdCBkZWZhdWx0UHJvdG90eXBlID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVBY2Nlc3NvcnMgPyB0ZXN0YWJsZUFjY2Vzc29yc1trZXldIDogdm9pZCAwO1xuICBjb25zdCBpc1VudGFpbnRlZEFjY2Vzc29ycyA9IEJvb2xlYW4oXG4gICAgYWNjZXNzb3JOYW1lcyAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBhY2Nlc3Nvck5hbWVzLmV2ZXJ5KFxuICAgICAgKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgICAoX2IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0UHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IG1ldGhvZE5hbWVzID0ga2V5IGluIHRlc3RhYmxlTWV0aG9kcyA/IHRlc3RhYmxlTWV0aG9kc1trZXldIDogdm9pZCAwO1xuICBjb25zdCBpc1VudGFpbnRlZE1ldGhvZHMgPSBCb29sZWFuKFxuICAgIG1ldGhvZE5hbWVzICYmIG1ldGhvZE5hbWVzLmV2ZXJ5KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgICAgfVxuICAgIClcbiAgKTtcbiAgaWYgKGlzVW50YWludGVkQWNjZXNzb3JzICYmIGlzVW50YWludGVkTWV0aG9kcyAmJiAhaXNBbmd1bGFyWm9uZVByZXNlbnQoKSkge1xuICAgIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGlmcmFtZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICBjb25zdCB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgY29uc3QgdW50YWludGVkT2JqZWN0ID0gd2luW2tleV0ucHJvdG90eXBlO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgIGlmICghdW50YWludGVkT2JqZWN0KSByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldID0gdW50YWludGVkT2JqZWN0O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgfVxufVxuY29uc3QgdW50YWludGVkQWNjZXNzb3JDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkQWNjZXNzb3Ioa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtrZXl9LiR7U3RyaW5nKGFjY2Vzc29yKX1gO1xuICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGVbY2FjaGVLZXldLmNhbGwoXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gIGNvbnN0IHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpO1xuICBjb25zdCB1bnRhaW50ZWRBY2Nlc3NvciA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIHVudGFpbnRlZFByb3RvdHlwZSxcbiAgICBhY2Nlc3NvclxuICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldDtcbiAgaWYgKCF1bnRhaW50ZWRBY2Nlc3NvcikgcmV0dXJuIGluc3RhbmNlW2FjY2Vzc29yXTtcbiAgdW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRBY2Nlc3NvcjtcbiAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yLmNhbGwoaW5zdGFuY2UpO1xufVxuY29uc3QgdW50YWludGVkTWV0aG9kQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZE1ldGhvZChrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtrZXl9LiR7U3RyaW5nKG1ldGhvZCl9YDtcbiAgaWYgKHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kQ2FjaGVbY2FjaGVLZXldLmJpbmQoXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gIGNvbnN0IHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpO1xuICBjb25zdCB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgaWYgKHR5cGVvZiB1bnRhaW50ZWRNZXRob2QgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGluc3RhbmNlW21ldGhvZF07XG4gIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZC5iaW5kKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNoaWxkTm9kZXMobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJjaGlsZE5vZGVzXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInBhcmVudE5vZGVcIik7XG59XG5mdW5jdGlvbiBwYXJlbnRFbGVtZW50KG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwicGFyZW50RWxlbWVudFwiKTtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50KG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwidGV4dENvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBjb250YWlucyhuMiwgb3RoZXIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiY29udGFpbnNcIikob3RoZXIpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiZ2V0Um9vdE5vZGVcIikoKTtcbn1cbmZ1bmN0aW9uIGhvc3QobjIpIHtcbiAgaWYgKCFuMiB8fCAhKFwiaG9zdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIlNoYWRvd1Jvb3RcIiwgbjIsIFwiaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIHN0eWxlU2hlZXRzKG4yKSB7XG4gIHJldHVybiBuMi5zdHlsZVNoZWV0cztcbn1cbmZ1bmN0aW9uIHNoYWRvd1Jvb3QobjIpIHtcbiAgaWYgKCFuMiB8fCAhKFwic2hhZG93Um9vdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwic2hhZG93Um9vdFwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IobjIsIHNlbGVjdG9ycykge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwobjIsIHNlbGVjdG9ycykge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JBbGxcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uT2JzZXJ2ZXJDdG9yKCkge1xuICByZXR1cm4gZ2V0VW50YWludGVkUHJvdG90eXBlKFwiTXV0YXRpb25PYnNlcnZlclwiKS5jb25zdHJ1Y3Rvcjtcbn1cbmNvbnN0IGluZGV4ID0ge1xuICBjaGlsZE5vZGVzLFxuICBwYXJlbnROb2RlLFxuICBwYXJlbnRFbGVtZW50LFxuICB0ZXh0Q29udGVudCxcbiAgY29udGFpbnMsXG4gIGdldFJvb3ROb2RlLFxuICBob3N0LFxuICBzdHlsZVNoZWV0cyxcbiAgc2hhZG93Um9vdCxcbiAgcXVlcnlTZWxlY3RvcixcbiAgcXVlcnlTZWxlY3RvckFsbCxcbiAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3Jcbn07XG5mdW5jdGlvbiBvbih0eXBlLCBmbiwgdGFyZ2V0ID0gZG9jdW1lbnQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG59XG5jb25zdCBERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcgPSBcIlBsZWFzZSBzdG9wIGltcG9ydCBtaXJyb3IgZGlyZWN0bHkuIEluc3RlYWQgb2YgdGhhdCxcXHJcXG5ub3cgeW91IGNhbiB1c2UgcmVwbGF5ZXIuZ2V0TWlycm9yKCkgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2Ugb2YgYSByZXBsYXllcixcXHJcXG5vciB5b3UgY2FuIHVzZSByZWNvcmQubWlycm9yIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIGR1cmluZyByZWNvcmRpbmcuXCI7XG5sZXQgX21pcnJvciA9IHtcbiAgbWFwOiB7fSxcbiAgZ2V0SWQoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIHJldHVybiAtMTtcbiAgfSxcbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlbW92ZU5vZGVGcm9tTWFwKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgfSxcbiAgaGFzKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlc2V0KCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgfVxufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5Qcm94eSAmJiB3aW5kb3cuUmVmbGVjdCkge1xuICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHByb3AgPT09IFwibWFwXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICBsZXQgcHJldmlvdXMgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9LCByZW1haW5pbmcpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIGQsIGlzUmV2b2tlZCwgd2luID0gd2luZG93KSB7XG4gIGNvbnN0IG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB3aW4uT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgaXNSZXZva2VkID8gZCA6IHtcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcbiAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBvcmlnaW5hbCB8fCB7fSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBwYXRjaChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV07XG4gICAgY29uc3Qgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsKTtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSB3cmFwcGVkLnByb3RvdHlwZSB8fCB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcbiAgICAgICAgX19ycndlYl9vcmlnaW5hbF9fOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb3VyY2VbbmFtZV0gPSBvcmlnaW5hbDtcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cbmxldCBub3dUaW1lc3RhbXAgPSBEYXRlLm5vdztcbmlmICghLyogQF9fUFVSRV9fICovIC9bMS05XVswLTldezEyfS8udGVzdChEYXRlLm5vdygpLnRvU3RyaW5nKCkpKSB7XG4gIG5vd1RpbWVzdGFtcCA9ICgpID0+ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKHdpbikge1xuICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IDogd2luLnBhZ2VYT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVhPZmZzZXQgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2EyID0gaW5kZXgucGFyZW50RWxlbWVudChkb2MuYm9keSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsTGVmdCkgfHwgKChfYiA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY3JvbGxMZWZ0KSB8fCAwLFxuICAgIHRvcDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgOiB3aW4ucGFnZVlPZmZzZXQgIT09IHZvaWQgMCA/IHdpbi5wYWdlWU9mZnNldCA6IChkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fCAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgJiYgKChfYyA9IGluZGV4LnBhcmVudEVsZW1lbnQoZG9jLmJvZHkpKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2Nyb2xsVG9wKSB8fCAoKF9kID0gZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNjcm9sbFRvcCkgfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZTIpIHtcbiAgaWYgKCFub2RlMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVsID0gbm9kZTIubm9kZVR5cGUgPT09IG5vZGUyLkVMRU1FTlRfTk9ERSA/IG5vZGUyIDogaW5kZXgucGFyZW50RWxlbWVudChub2RlMik7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tlZChub2RlMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgaWYgKCFub2RlMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUyKTtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChcIi5cIiArIGJsb2NrQ2xhc3MpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBibG9ja0NsYXNzLCBjaGVja0FuY2VzdG9ycykpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChibG9ja1NlbGVjdG9yKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkKG4yLCBtaXJyb3IyKSB7XG4gIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBpc0lnbm9yZWQobjIsIG1pcnJvcjIsIHNsaW1ET01PcHRpb25zKSB7XG4gIGlmIChuMi50YWdOYW1lID09PSBcIlRJVExFXCIgJiYgc2xpbURPTU9wdGlvbnMuaGVhZFRpdGxlTXV0YXRpb25zKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG1pcnJvcjIuZ2V0SWQobjIpID09PSBJR05PUkVEX05PREU7XG59XG5mdW5jdGlvbiBpc0FuY2VzdG9yUmVtb3ZlZCh0YXJnZXQsIG1pcnJvcjIpIHtcbiAgaWYgKGlzU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICBpZiAoIW1pcnJvcjIuaGFzKGlkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodGFyZ2V0KTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghcGFyZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHBhcmVudCwgbWlycm9yMik7XG59XG5mdW5jdGlvbiBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBCb29sZWFuKGV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbn1cbmZ1bmN0aW9uIHBvbHlmaWxsJDEod2luID0gd2luZG93KSB7XG4gIGlmIChcIk5vZGVMaXN0XCIgaW4gd2luICYmICF3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICB3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgfVxuICBpZiAoXCJET01Ub2tlbkxpc3RcIiBpbiB3aW4gJiYgIXdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICB3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yMikge1xuICByZXR1cm4gQm9vbGVhbihuMi5ub2RlTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiBtaXJyb3IyLmdldE1ldGEobjIpKTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcjIpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbjIubm9kZU5hbWUgPT09IFwiTElOS1wiICYmIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREUgJiYgbjIuZ2V0QXR0cmlidXRlICYmIG4yLmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKVxuICApO1xufVxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuMikge1xuICBpZiAoIW4yKSByZXR1cm4gZmFsc2U7XG4gIGlmIChuMiBpbnN0YW5jZW9mIEJhc2VSUk5vZGUgJiYgXCJzaGFkb3dSb290XCIgaW4gbjIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihuMi5zaGFkb3dSb290KTtcbiAgfVxuICByZXR1cm4gQm9vbGVhbihpbmRleC5zaGFkb3dSb290KG4yKSk7XG59XG5jbGFzcyBTdHlsZVNoZWV0TWlycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIsIDEpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZUlETWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRTdHlsZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBnZXRJZChzdHlsZXNoZWV0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5nZXQoc3R5bGVzaGVldCkgPz8gLTE7XG4gIH1cbiAgaGFzKHN0eWxlc2hlZXQpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgSWYgdGhlIHN0eWxlc2hlZXQgaXMgaW4gdGhlIG1pcnJvciwgcmV0dXJucyB0aGUgaWQgb2YgdGhlIHN0eWxlc2hlZXQuIElmIG5vdCwgcmV0dXJuIHRoZSBuZXcgYXNzaWduZWQgaWQuXG4gICAqL1xuICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcbiAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xuICAgIGxldCBuZXdJZDtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XG4gICAgfSBlbHNlIG5ld0lkID0gaWQ7XG4gICAgdGhpcy5zdHlsZUlETWFwLnNldChzdHlsZXNoZWV0LCBuZXdJZCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XG4gICAgcmV0dXJuIG5ld0lkO1xuICB9XG4gIGdldFN0eWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmlkID0gMTtcbiAgfVxuICBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmlkKys7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRvd0hvc3QobjIpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IHNoYWRvd0hvc3QgPSBudWxsO1xuICBpZiAoXCJnZXRSb290Tm9kZVwiIGluIG4yICYmICgoX2EyID0gaW5kZXguZ2V0Um9vdE5vZGUobjIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5vZGVUeXBlKSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGluZGV4Lmhvc3QoaW5kZXguZ2V0Um9vdE5vZGUobjIpKSlcbiAgICBzaGFkb3dIb3N0ID0gaW5kZXguaG9zdChpbmRleC5nZXRSb290Tm9kZShuMikpO1xuICByZXR1cm4gc2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIGdldFJvb3RTaGFkb3dIb3N0KG4yKSB7XG4gIGxldCByb290U2hhZG93SG9zdCA9IG4yO1xuICBsZXQgc2hhZG93SG9zdDtcbiAgd2hpbGUgKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSlcbiAgICByb290U2hhZG93SG9zdCA9IHNoYWRvd0hvc3Q7XG4gIHJldHVybiByb290U2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuMikge1xuICBjb25zdCBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3QobjIpO1xuICByZXR1cm4gaW5kZXguY29udGFpbnMoZG9jLCBzaGFkb3dIb3N0KTtcbn1cbmZ1bmN0aW9uIGluRG9tKG4yKSB7XG4gIGNvbnN0IGRvYyA9IG4yLm93bmVyRG9jdW1lbnQ7XG4gIGlmICghZG9jKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpbmRleC5jb250YWlucyhkb2MsIG4yKSB8fCBzaGFkb3dIb3N0SW5Eb20objIpO1xufVxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIENhbnZhc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gKChDYW52YXNDb250ZXh0MikgPT4ge1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIjJEXCJdID0gMF0gPSBcIjJEXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0xcIl0gPSAxXSA9IFwiV2ViR0xcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gIHJldHVybiBDYW52YXNDb250ZXh0Mjtcbn0pKENhbnZhc0NvbnRleHQgfHwge30pO1xudmFyIE1lZGlhSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoTWVkaWFJbnRlcmFjdGlvbnMyKSA9PiB7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQbGF5XCJdID0gMF0gPSBcIlBsYXlcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJTZWVrZWRcIl0gPSAyXSA9IFwiU2Vla2VkXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJWb2x1bWVDaGFuZ2VcIl0gPSAzXSA9IFwiVm9sdW1lQ2hhbmdlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJSYXRlQ2hhbmdlXCJdID0gNF0gPSBcIlJhdGVDaGFuZ2VcIjtcbiAgcmV0dXJuIE1lZGlhSW50ZXJhY3Rpb25zMjtcbn0pKE1lZGlhSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBOb2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5vZGVUeXBlMikgPT4ge1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gIHJldHVybiBOb2RlVHlwZTI7XG59KShOb2RlVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3QobjIpIHtcbiAgcmV0dXJuIFwiX19sblwiIGluIG4yO1xufVxuY2xhc3MgRG91YmxlTGlua2VkTGlzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhlYWRcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhaWxcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0KHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBvdXRzaWRlIG9mIGxpc3QgcmFuZ2VcIik7XG4gICAgfVxuICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgIGZvciAobGV0IGluZGV4MiA9IDA7IGluZGV4MiA8IHBvc2l0aW9uOyBpbmRleDIrKykge1xuICAgICAgY3VycmVudCA9IChjdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Lm5leHQpIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG4gIGFkZE5vZGUobjIpIHtcbiAgICBjb25zdCBub2RlMiA9IHtcbiAgICAgIHZhbHVlOiBuMixcbiAgICAgIHByZXZpb3VzOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgbjIuX19sbiA9IG5vZGUyO1xuICAgIGlmIChuMi5wcmV2aW91c1NpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBuMi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0O1xuICAgICAgbm9kZTIubmV4dCA9IGN1cnJlbnQ7XG4gICAgICBub2RlMi5wcmV2aW91cyA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuO1xuICAgICAgbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGUyO1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobjIubmV4dFNpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLm5leHRTaWJsaW5nKSAmJiBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cztcbiAgICAgIG5vZGUyLnByZXZpb3VzID0gY3VycmVudDtcbiAgICAgIG5vZGUyLm5leHQgPSBuMi5uZXh0U2libGluZy5fX2xuO1xuICAgICAgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudC5uZXh0ID0gbm9kZTI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbm9kZTI7XG4gICAgICB9XG4gICAgICBub2RlMi5uZXh0ID0gdGhpcy5oZWFkO1xuICAgICAgdGhpcy5oZWFkID0gbm9kZTI7XG4gICAgfVxuICAgIGlmIChub2RlMi5uZXh0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBub2RlMjtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxuICByZW1vdmVOb2RlKG4yKSB7XG4gICAgY29uc3QgY3VycmVudCA9IG4yLl9fbG47XG4gICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50LnByZXZpb3VzKSB7XG4gICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICBpZiAoY3VycmVudC5uZXh0KSB7XG4gICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobjIuX19sbikge1xuICAgICAgZGVsZXRlIG4yLl9fbG47XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoLS07XG4gIH1cbn1cbmNvbnN0IG1vdmVLZXkgPSAoaWQsIHBhcmVudElkKSA9PiBgJHtpZH1AJHtwYXJlbnRJZH1gO1xuY2xhc3MgTXV0YXRpb25CdWZmZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJvemVuXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9ja2VkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGV4dHNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdHRyaWJ1dGVzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXR0cmlidXRlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3Zlc1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hcFJlbW92ZXNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3ZlZE1hcFwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZGVkU2V0XCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3ZlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZHJvcHBlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3Zlc1N1YlRyZWVDYWNoZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmxvY2tDbGFzc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmxvY2tTZWxlY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRDbGFzc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRTZWxlY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5saW5lU3R5bGVzaGVldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza0lucHV0T3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRGblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza0lucHV0Rm5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtlZXBJZnJhbWVTcmNGblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb3JkQ2FudmFzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmxpbmVJbWFnZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNsaW1ET01PcHRpb25zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhVVJMT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9jXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZU1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlc2hlZXRNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dEb21NYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjYW52YXNNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm9jZXNzZWROb2RlTWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5hdHRhY2hlZERvY1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uc1wiLCAobXV0YXRpb25zKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZm9yRWFjaCh0aGlzLnByb2Nlc3NNdXRhdGlvbik7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW1pdFwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWRkcyA9IFtdO1xuICAgICAgY29uc3QgYWRkZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgYWRkTGlzdCA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KCk7XG4gICAgICBjb25zdCBnZXROZXh0SWQgPSAobjIpID0+IHtcbiAgICAgICAgbGV0IG5zID0gbjI7XG4gICAgICAgIGxldCBuZXh0SWQgPSBJR05PUkVEX05PREU7XG4gICAgICAgIHdoaWxlIChuZXh0SWQgPT09IElHTk9SRURfTk9ERSkge1xuICAgICAgICAgIG5zID0gbnMgJiYgbnMubmV4dFNpYmxpbmc7XG4gICAgICAgICAgbmV4dElkID0gbnMgJiYgdGhpcy5taXJyb3IuZ2V0SWQobnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0SWQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgcHVzaEFkZCA9IChuMikgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWluRG9tKG4yKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3NzQ2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG4yLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudFRhZyA9IHBhcmVudC50YWdOYW1lO1xuICAgICAgICAgIGlmIChwYXJlbnRUYWcgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50VGFnID09PSBcIlNUWUxFXCIgJiYgdGhpcy5hZGRlZFNldC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgY3NzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChwYXJlbnQpID8gdGhpcy5taXJyb3IuZ2V0SWQoZ2V0U2hhZG93SG9zdChuMikpIDogdGhpcy5taXJyb3IuZ2V0SWQocGFyZW50KTtcbiAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKG4yKTtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSAtMSB8fCBuZXh0SWQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc24gPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgZG9jOiB0aGlzLmRvYyxcbiAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICAgIGJsb2NrQ2xhc3M6IHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yOiB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgbWFza1RleHRDbGFzczogdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IHRoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBtYXNrVGV4dEZuOiB0aGlzLm1hc2tUZXh0Rm4sXG4gICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm4sXG4gICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHRoaXMuc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IHRoaXMuZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgcmVjb3JkQ2FudmFzOiB0aGlzLnJlY29yZENhbnZhcyxcbiAgICAgICAgICBpbmxpbmVJbWFnZXM6IHRoaXMuaW5saW5lSW1hZ2VzLFxuICAgICAgICAgIG9uU2VyaWFsaXplOiAoY3VycmVudE4pID0+IHtcbiAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKGN1cnJlbnROKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KGN1cnJlbnROLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnROXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3QoaW5kZXguc2hhZG93Um9vdChuMiksIHRoaXMuZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rLCBjaGlsZFNuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3NzQ2FwdHVyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzbikge1xuICAgICAgICAgIGFkZHMucHVzaCh7XG4gICAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICAgIG5leHRJZCxcbiAgICAgICAgICAgIG5vZGU6IHNuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkZWRJZHMuYWRkKHNuLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdoaWxlICh0aGlzLm1hcFJlbW92ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnJlbW92ZU5vZGVGcm9tTWFwKHRoaXMubWFwUmVtb3Zlcy5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbjIgb2YgdGhpcy5tb3ZlZFNldCkge1xuICAgICAgICBpZiAoaXNQYXJlbnRSZW1vdmVkKHRoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSwgbjIsIHRoaXMubWlycm9yKSAmJiAhdGhpcy5tb3ZlZFNldC5oYXMoaW5kZXgucGFyZW50Tm9kZShuMikpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG4yIG9mIHRoaXMuYWRkZWRTZXQpIHtcbiAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQodGhpcy5kcm9wcGVkU2V0LCBuMikgJiYgIWlzUGFyZW50UmVtb3ZlZCh0aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUsIG4yLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICBwdXNoQWRkKG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FuY2VzdG9ySW5TZXQodGhpcy5tb3ZlZFNldCwgbjIpKSB7XG4gICAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYW5kaWRhdGUgPSBudWxsO1xuICAgICAgd2hpbGUgKGFkZExpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxldCBub2RlMiA9IG51bGw7XG4gICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKGluZGV4LnBhcmVudE5vZGUoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKHBhcmVudElkICE9PSAtMSAmJiBuZXh0SWQgIT09IC0xKSB7XG4gICAgICAgICAgICBub2RlMiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlMikge1xuICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcbiAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IF9ub2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKF9ub2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXgucGFyZW50Tm9kZShfbm9kZS52YWx1ZSkpO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQoX25vZGUudmFsdWUpO1xuICAgICAgICAgICAgICBpZiAobmV4dElkID09PSAtMSkgY29udGludWU7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG5vZGUyID0gX25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5oYW5kbGVkTm9kZSA9IF9ub2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodW5oYW5kbGVkTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhZG93SG9zdCA9IGluZGV4Lmhvc3QocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkMiA9IHRoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElkMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgICB3aGlsZSAoYWRkTGlzdC5oZWFkKSB7XG4gICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUoYWRkTGlzdC5oZWFkLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlID0gbm9kZTIucHJldmlvdXM7XG4gICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShub2RlMi52YWx1ZSk7XG4gICAgICAgIHB1c2hBZGQobm9kZTIudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdGV4dHM6IHRoaXMudGV4dHMubWFwKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgbjIgPSB0ZXh0Lm5vZGU7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKG4yKSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKCh0ZXh0KSA9PiAhYWRkZWRJZHMuaGFzKHRleHQuaWQpKS5maWx0ZXIoKHRleHQpID0+IHRoaXMubWlycm9yLmhhcyh0ZXh0LmlkKSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gYXR0cmlidXRlO1xuICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZGlmZkFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLnN0eWxlRGlmZik7XG4gICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5fdW5jaGFuZ2VkU3R5bGVzKTtcbiAgICAgICAgICAgIGlmIChkaWZmQXNTdHIubGVuZ3RoIDwgYXR0cmlidXRlcy5zdHlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKChkaWZmQXNTdHIgKyB1bmNoYW5nZWRBc1N0cikuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCA9PT0gYXR0cmlidXRlcy5zdHlsZS5zcGxpdChcInZhcihcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm1pcnJvci5nZXRJZChhdHRyaWJ1dGUubm9kZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKChhdHRyaWJ1dGUpID0+ICFhZGRlZElkcy5oYXMoYXR0cmlidXRlLmlkKSkuZmlsdGVyKChhdHRyaWJ1dGUpID0+IHRoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpKSxcbiAgICAgICAgcmVtb3ZlczogdGhpcy5yZW1vdmVzLFxuICAgICAgICBhZGRzXG4gICAgICB9O1xuICAgICAgaWYgKCFwYXlsb2FkLnRleHRzLmxlbmd0aCAmJiAhcGF5bG9hZC5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhcGF5bG9hZC5yZW1vdmVzLmxlbmd0aCAmJiAhcGF5bG9hZC5hZGRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRleHRzID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICB0aGlzLnJlbW92ZXMgPSBbXTtcbiAgICAgIHRoaXMuYWRkZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5tb3ZlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmRyb3BwZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5yZW1vdmVzU3ViVHJlZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcbiAgICAgIHRoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uXCIsICh0ZXh0YXJlYSkgPT4ge1xuICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQodGV4dGFyZWEpO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgbm9kZTogdGV4dGFyZWEsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KHRleHRhcmVhLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uYXR0cmlidXRlcy52YWx1ZSA9IEFycmF5LmZyb20oXG4gICAgICAgIGluZGV4LmNoaWxkTm9kZXModGV4dGFyZWEpLFxuICAgICAgICAoY24pID0+IGluZGV4LnRleHRDb250ZW50KGNuKSB8fCBcIlwiXG4gICAgICApLmpvaW4oXCJcIik7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NNdXRhdGlvblwiLCAobSkgPT4ge1xuICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgdGhpcy5taXJyb3IsIHRoaXMuc2xpbURPTU9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGFyYWN0ZXJEYXRhXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGV4LnRleHRDb250ZW50KG0udGFyZ2V0KTtcbiAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSAmJiB2YWx1ZSAhPT0gbS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChcbiAgICAgICAgICAgICAgICBtLnRhcmdldCxcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAvLyBjaGVja0FuY2VzdG9yc1xuICAgICAgICAgICAgICApICYmIHZhbHVlID8gdGhpcy5tYXNrVGV4dEZuID8gdGhpcy5tYXNrVGV4dEZuKHZhbHVlLCBjbG9zZXN0RWxlbWVudE9mTm9kZShtLnRhcmdldCkpIDogdmFsdWUucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpIDogdmFsdWUsXG4gICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImF0dHJpYnV0ZXNcIjoge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG0udGFyZ2V0O1xuICAgICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lID0gbS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IG0udGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgIHRhZ05hbWU6IHRhcmdldC50YWdOYW1lLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8IHZhbHVlID09PSBtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KG0udGFyZ2V0KTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09IFwiSUZSQU1FXCIgJiYgYXR0cmlidXRlTmFtZSA9PT0gXCJzcmNcIiAmJiAhdGhpcy5rZWVwSWZyYW1lU3JjRm4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwicnJfc3JjXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgICBzdHlsZURpZmY6IHt9LFxuICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KG0udGFyZ2V0LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidHlwZVwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgKG0ub2xkVmFsdWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKFxuICAgICAgICAgICAgICB0aGlzLmRvYyxcbiAgICAgICAgICAgICAgdG9Mb3dlckNhc2UodGFyZ2V0LnRhZ05hbWUpLFxuICAgICAgICAgICAgICB0b0xvd2VyQ2FzZShhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy51bmF0dGFjaGVkRG9jKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5hdHRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgb2xkID0gdGhpcy51bmF0dGFjaGVkRG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICBpZiAobS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBtLm9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20odGFyZ2V0LnN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpIHx8IG5ld1ByaW9yaXR5ICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLl91bmNoYW5nZWRTdHlsZXNbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcG5hbWUgb2YgQXJyYXkuZnJvbShvbGQuc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwib3BlblwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIkRJQUxPR1wiKSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQubWF0Y2hlcyhcImRpYWxvZzptb2RhbFwiKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1tcInJyX29wZW5fbW9kZVwiXSA9IFwibW9kYWxcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbXCJycl9vcGVuX21vZGVcIl0gPSBcIm5vbi1tb2RhbFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjaGlsZExpc3RcIjoge1xuICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCB0cnVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAobS50YXJnZXQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG0uYWRkZWROb2Rlcy5mb3JFYWNoKChuMikgPT4gdGhpcy5nZW5BZGRzKG4yLCBtLnRhcmdldCkpO1xuICAgICAgICAgIG0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlSWQgPSB0aGlzLm1pcnJvci5nZXRJZChuMik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChtLnRhcmdldCkgPyB0aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KG0udGFyZ2V0KSkgOiB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8IGlzSWdub3JlZChuMiwgdGhpcy5taXJyb3IsIHRoaXMuc2xpbURPTU9wdGlvbnMpIHx8ICFpc1NlcmlhbGl6ZWQobjIsIHRoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRlZFNldC5oYXMobjIpKSB7XG4gICAgICAgICAgICAgIGRlZXBEZWxldGUodGhpcy5hZGRlZFNldCwgbjIpO1xuICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hZGRlZFNldC5oYXMobS50YXJnZXQpICYmIG5vZGVJZCA9PT0gLTEpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JSZW1vdmVkKG0udGFyZ2V0LCB0aGlzLm1pcnJvcikpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubW92ZWRTZXQuaGFzKG4yKSAmJiB0aGlzLm1vdmVkTWFwW21vdmVLZXkobm9kZUlkLCBwYXJlbnRJZCldKSB7XG4gICAgICAgICAgICAgIGRlZXBEZWxldGUodGhpcy5tb3ZlZFNldCwgbjIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpID8gdHJ1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcHJvY2Vzc1JlbW92ZXMobjIsIHRoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcFJlbW92ZXMucHVzaChuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VuQWRkc1wiLCAobjIsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuaW5PdGhlckJ1ZmZlcihuMiwgdGhpcykpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuMikgfHwgdGhpcy5tb3ZlZFNldC5oYXMobjIpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5taXJyb3IuaGFzTm9kZShuMikpIHtcbiAgICAgICAgaWYgKGlzSWdub3JlZChuMiwgdGhpcy5taXJyb3IsIHRoaXMuc2xpbURPTU9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgbGV0IHRhcmdldElkID0gbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMubWlycm9yLmdldElkKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldElkICYmIHRhcmdldElkICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMubW92ZWRNYXBbbW92ZUtleSh0aGlzLm1pcnJvci5nZXRJZChuMiksIHRhcmdldElkKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZGVkU2V0LmFkZChuMik7XG4gICAgICAgIHRoaXMuZHJvcHBlZFNldC5kZWxldGUobjIpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Jsb2NrZWQobjIsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkpIHtcbiAgICAgICAgaW5kZXguY2hpbGROb2RlcyhuMikuZm9yRWFjaCgoY2hpbGROKSA9PiB0aGlzLmdlbkFkZHMoY2hpbGROKSk7XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIGluZGV4LmNoaWxkTm9kZXMoaW5kZXguc2hhZG93Um9vdChuMikpLmZvckVhY2goKGNoaWxkTikgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5hZGQoY2hpbGROLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuQWRkcyhjaGlsZE4sIG4yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIFtcbiAgICAgIFwibXV0YXRpb25DYlwiLFxuICAgICAgXCJibG9ja0NsYXNzXCIsXG4gICAgICBcImJsb2NrU2VsZWN0b3JcIixcbiAgICAgIFwibWFza1RleHRDbGFzc1wiLFxuICAgICAgXCJtYXNrVGV4dFNlbGVjdG9yXCIsXG4gICAgICBcImlubGluZVN0eWxlc2hlZXRcIixcbiAgICAgIFwibWFza0lucHV0T3B0aW9uc1wiLFxuICAgICAgXCJtYXNrVGV4dEZuXCIsXG4gICAgICBcIm1hc2tJbnB1dEZuXCIsXG4gICAgICBcImtlZXBJZnJhbWVTcmNGblwiLFxuICAgICAgXCJyZWNvcmRDYW52YXNcIixcbiAgICAgIFwiaW5saW5lSW1hZ2VzXCIsXG4gICAgICBcInNsaW1ET01PcHRpb25zXCIsXG4gICAgICBcImRhdGFVUkxPcHRpb25zXCIsXG4gICAgICBcImRvY1wiLFxuICAgICAgXCJtaXJyb3JcIixcbiAgICAgIFwiaWZyYW1lTWFuYWdlclwiLFxuICAgICAgXCJzdHlsZXNoZWV0TWFuYWdlclwiLFxuICAgICAgXCJzaGFkb3dEb21NYW5hZ2VyXCIsXG4gICAgICBcImNhbnZhc01hbmFnZXJcIixcbiAgICAgIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIlxuICAgIF0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfSk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XG4gIH1cbiAgdW5mcmVlemUoKSB7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5mcmVlemUoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBpc0Zyb3plbigpIHtcbiAgICByZXR1cm4gdGhpcy5mcm96ZW47XG4gIH1cbiAgbG9jaygpIHtcbiAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcbiAgfVxuICB1bmxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5sb2NrKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnJlc2V0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbjIpIHtcbiAgYWRkc1NldC5kZWxldGUobjIpO1xuICBpbmRleC5jaGlsZE5vZGVzKG4yKS5mb3JFYWNoKChjaGlsZE4pID0+IGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKSk7XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVtb3ZlcyhuMiwgY2FjaGUpIHtcbiAgY29uc3QgcXVldWUgPSBbbjJdO1xuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dCA9IHF1ZXVlLnBvcCgpO1xuICAgIGlmIChjYWNoZS5oYXMobmV4dCkpIGNvbnRpbnVlO1xuICAgIGNhY2hlLmFkZChuZXh0KTtcbiAgICBpbmRleC5jaGlsZE5vZGVzKG5leHQpLmZvckVhY2goKG4yMikgPT4gcXVldWUucHVzaChuMjIpKTtcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgaWYgKHJlbW92ZXMuc2l6ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMik7XG59XG5mdW5jdGlvbiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBfbWlycm9yMikge1xuICBjb25zdCBub2RlMiA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICBpZiAoIW5vZGUyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiByZW1vdmVzLmhhcyhub2RlMik7XG59XG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuMikge1xuICBpZiAoc2V0LnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuMik7XG59XG5mdW5jdGlvbiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgY29uc3QgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gIGlmICghcGFyZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzZXQuaGFzKHBhcmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIHBhcmVudCk7XG59XG5sZXQgZXJyb3JIYW5kbGVyO1xuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICBlcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckVycm9ySGFuZGxlcigpIHtcbiAgZXJyb3JIYW5kbGVyID0gdm9pZCAwO1xufVxuY29uc3QgY2FsbGJhY2tXcmFwcGVyID0gKGNiKSA9PiB7XG4gIGlmICghZXJyb3JIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGNiO1xuICB9XG4gIGNvbnN0IHJyd2ViV3JhcHBlZCA9ICguLi5yZXN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYiguLi5yZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9ySGFuZGxlciAmJiBlcnJvckhhbmRsZXIoZXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJyd2ViV3JhcHBlZDtcbn07XG5jb25zdCBtdXRhdGlvbkJ1ZmZlcnMgPSBbXTtcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKFwiY29tcG9zZWRQYXRoXCIgaW4gZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFwicGF0aFwiIGluIGV2ZW50ICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBldmVudCAmJiBldmVudC50YXJnZXQ7XG59XG5mdW5jdGlvbiBpbml0TXV0YXRpb25PYnNlcnZlcihvcHRpb25zLCByb290RWwpIHtcbiAgY29uc3QgbXV0YXRpb25CdWZmZXIgPSBuZXcgTXV0YXRpb25CdWZmZXIoKTtcbiAgbXV0YXRpb25CdWZmZXJzLnB1c2gobXV0YXRpb25CdWZmZXIpO1xuICBtdXRhdGlvbkJ1ZmZlci5pbml0KG9wdGlvbnMpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyAobXV0YXRpb25PYnNlcnZlckN0b3IoKSkoXG4gICAgY2FsbGJhY2tXcmFwcGVyKG11dGF0aW9uQnVmZmVyLnByb2Nlc3NNdXRhdGlvbnMuYmluZChtdXRhdGlvbkJ1ZmZlcikpXG4gICk7XG4gIG9ic2VydmVyLm9ic2VydmUocm9vdEVsLCB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gaW5pdE1vdmVPYnNlcnZlcih7XG4gIG1vdXNlbW92ZUNiLFxuICBzYW1wbGluZyxcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjJcbn0pIHtcbiAgaWYgKHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZSA6IDUwO1xuICBjb25zdCBjYWxsYmFja1RocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrIDogNTAwO1xuICBsZXQgcG9zaXRpb25zID0gW107XG4gIGxldCB0aW1lQmFzZWxpbmU7XG4gIGNvbnN0IHdyYXBwZWRDYiA9IHRocm90dGxlKFxuICAgIGNhbGxiYWNrV3JhcHBlcihcbiAgICAgIChzb3VyY2UpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBEYXRlLm5vdygpIC0gdGltZUJhc2VsaW5lO1xuICAgICAgICBtb3VzZW1vdmVDYihcbiAgICAgICAgICBwb3NpdGlvbnMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzb3VyY2VcbiAgICAgICAgKTtcbiAgICAgICAgcG9zaXRpb25zID0gW107XG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XG4gICAgICB9XG4gICAgKSxcbiAgICBjYWxsYmFja1RocmVzaG9sZFxuICApO1xuICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICB0aHJvdHRsZShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gbGVnYWN5X2lzVG91Y2hFdmVudChldnQpID8gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZ0O1xuICAgICAgICBpZiAoIXRpbWVCYXNlbGluZSkge1xuICAgICAgICAgIHRpbWVCYXNlbGluZSA9IG5vd1RpbWVzdGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICAgIHk6IGNsaWVudFksXG4gICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICB0aW1lT2Zmc2V0OiBub3dUaW1lc3RhbXAoKSAtIHRpbWVCYXNlbGluZVxuICAgICAgICB9KTtcbiAgICAgICAgd3JhcHBlZENiKFxuICAgICAgICAgIHR5cGVvZiBEcmFnRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZXZ0IGluc3RhbmNlb2YgRHJhZ0V2ZW50ID8gSW5jcmVtZW50YWxTb3VyY2UuRHJhZyA6IGV2dCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUgOiBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAge1xuICAgICAgICB0cmFpbGluZzogZmFsc2VcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgIG9uKFwibW91c2Vtb3ZlXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxuICAgIG9uKFwidG91Y2htb3ZlXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxuICAgIG9uKFwiZHJhZ1wiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKVxuICBdO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIoe1xuICBtb3VzZUludGVyYWN0aW9uQ2IsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBibG9ja0NsYXNzLFxuICBibG9ja1NlbGVjdG9yLFxuICBzYW1wbGluZ1xufSkge1xuICBpZiAoc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgZGlzYWJsZU1hcCA9IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHRydWUgfHwgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdm9pZCAwID8ge30gOiBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uO1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBsZXQgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgY29uc3QgZ2V0SGFuZGxlciA9IChldmVudEtleSkgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmIChpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xuICAgICAgaWYgKFwicG9pbnRlclR5cGVcIiBpbiBldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Nb3VzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xuICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gXCJUb3VjaFN0YXJ0XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcbiAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hFbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcbiAgICAgIH0gZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgIGlmICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIlRvdWNoXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2ggfHwgdGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJNb3VzZVwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSB7XG4gICAgICAgICAgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XG4gICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBlMiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgIGlmICghZTIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGUyO1xuICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoe1xuICAgICAgICB0eXBlOiBNb3VzZUludGVyYWN0aW9uc1t0aGlzRXZlbnRLZXldLFxuICAgICAgICBpZCxcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgLi4ucG9pbnRlclR5cGUgIT09IG51bGwgJiYgeyBwb2ludGVyVHlwZSB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucykuZmlsdGVyKFxuICAgIChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiYgIWtleS5lbmRzV2l0aChcIl9EZXBhcnRlZFwiKSAmJiBkaXNhYmxlTWFwW2tleV0gIT09IGZhbHNlXG4gICkuZm9yRWFjaCgoZXZlbnRLZXkpID0+IHtcbiAgICBsZXQgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XG4gICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcDpcbiAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZShcbiAgICAgICAgICAgIFwibW91c2VcIixcbiAgICAgICAgICAgIFwicG9pbnRlclwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxuICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcnMucHVzaChvbihldmVudE5hbWUsIGhhbmRsZXIsIGRvYykpO1xuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoe1xuICBzY3JvbGxDYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIHNhbXBsaW5nXG59KSB7XG4gIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gY2FsbGJhY2tXcmFwcGVyKFxuICAgIHRocm90dGxlKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKChldnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgc2Nyb2xsQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB4OiBzY3JvbGxMZWZ0VG9wLmxlZnQsXG4gICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMFxuICAgIClcbiAgKTtcbiAgcmV0dXJuIG9uKFwic2Nyb2xsXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpO1xufVxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIoeyB2aWV3cG9ydFJlc2l6ZUNiIH0sIHsgd2luIH0pIHtcbiAgbGV0IGxhc3RIID0gLTE7XG4gIGxldCBsYXN0VyA9IC0xO1xuICBjb25zdCB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUoXG4gICAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBnZXRXaW5kb3dIZWlnaHQoKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICBpZiAobGFzdEggIT09IGhlaWdodCB8fCBsYXN0VyAhPT0gd2lkdGgpIHtcbiAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiKHtcbiAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIod2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoaGVpZ2h0KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RIID0gaGVpZ2h0O1xuICAgICAgICAgIGxhc3RXID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgMjAwXG4gICAgKVxuICApO1xuICByZXR1cm4gb24oXCJyZXNpemVcIiwgdXBkYXRlRGltZW5zaW9uLCB3aW4pO1xufVxuY29uc3QgSU5QVVRfVEFHUyA9IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl07XG5jb25zdCBsYXN0SW5wdXRWYWx1ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaW5pdElucHV0T2JzZXJ2ZXIoe1xuICBpbnB1dENiLFxuICBkb2MsXG4gIG1pcnJvcjogbWlycm9yMixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgaWdub3JlQ2xhc3MsXG4gIGlnbm9yZVNlbGVjdG9yLFxuICBtYXNrSW5wdXRPcHRpb25zLFxuICBtYXNrSW5wdXRGbixcbiAgc2FtcGxpbmcsXG4gIHVzZXJUcmlnZ2VyZWRPbklucHV0XG59KSB7XG4gIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgY29uc3QgdXNlclRyaWdnZXJlZCA9IGV2ZW50LmlzVHJ1c3RlZDtcbiAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xuICAgIGlmICh0YXJnZXQgJiYgdGFnTmFtZSA9PT0gXCJPUFRJT05cIikge1xuICAgICAgdGFyZ2V0ID0gaW5kZXgucGFyZW50RWxlbWVudCh0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldCB8fCAhdGFnTmFtZSB8fCBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKSB8fCBpZ25vcmVTZWxlY3RvciAmJiB0YXJnZXQubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRleHQgPSB0YXJnZXQudmFsdWU7XG4gICAgbGV0IGlzQ2hlY2tlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KSB8fCBcIlwiO1xuICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICBpc0NoZWNrZWQgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICB9IGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XG4gICAgICB0ZXh0ID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICBlbGVtZW50OiB0YXJnZXQsXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIHRhZ05hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBtYXNrSW5wdXRGblxuICAgICAgfSk7XG4gICAgfVxuICAgIGNiV2l0aERlZHVwKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7IHRleHQsIGlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZCB9IDogeyB0ZXh0LCBpc0NoZWNrZWQgfVxuICAgICk7XG4gICAgY29uc3QgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcbiAgICAgIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIiR7bmFtZX1cIl1gKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwgIT09IHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHRleHQyID0gZWwudmFsdWU7XG4gICAgICAgICAgY2JXaXRoRGVkdXAoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID8geyB0ZXh0OiB0ZXh0MiwgaXNDaGVja2VkOiAhaXNDaGVja2VkLCB1c2VyVHJpZ2dlcmVkOiBmYWxzZSB9IDogeyB0ZXh0OiB0ZXh0MiwgaXNDaGVja2VkOiAhaXNDaGVja2VkIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2Mikge1xuICAgIGNvbnN0IGxhc3RJbnB1dFZhbHVlID0gbGFzdElucHV0VmFsdWVNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFsYXN0SW5wdXRWYWx1ZSB8fCBsYXN0SW5wdXRWYWx1ZS50ZXh0ICE9PSB2Mi50ZXh0IHx8IGxhc3RJbnB1dFZhbHVlLmlzQ2hlY2tlZCAhPT0gdjIuaXNDaGVja2VkKSB7XG4gICAgICBsYXN0SW5wdXRWYWx1ZU1hcC5zZXQodGFyZ2V0LCB2Mik7XG4gICAgICBjb25zdCBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICAgIGNhbGxiYWNrV3JhcHBlcihpbnB1dENiKSh7XG4gICAgICAgIC4uLnYyLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50cyA9IHNhbXBsaW5nLmlucHV0ID09PSBcImxhc3RcIiA/IFtcImNoYW5nZVwiXSA6IFtcImlucHV0XCIsIFwiY2hhbmdlXCJdO1xuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50cy5tYXAoXG4gICAgKGV2ZW50TmFtZSkgPT4gb24oZXZlbnROYW1lLCBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSwgZG9jKVxuICApO1xuICBjb25zdCBjdXJyZW50V2luZG93ID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLFxuICAgIFwidmFsdWVcIlxuICApO1xuICBjb25zdCBob29rUHJvcGVydGllcyA9IFtcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgXCJjaGVja2VkXCJdLFxuICAgIFtjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiXSxcbiAgICAvLyBTb21lIFVJIGxpYnJhcnkgdXNlIHNlbGVjdGVkSW5kZXggdG8gc2V0IHNlbGVjdCB2YWx1ZVxuICAgIFtjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCJdLFxuICAgIFtjdXJyZW50V2luZG93LkhUTUxPcHRpb25FbGVtZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiXVxuICBdO1xuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yICYmIHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcbiAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgLi4uaG9va1Byb3BlcnRpZXMubWFwKFxuICAgICAgICAocCkgPT4gaG9va1NldHRlcihcbiAgICAgICAgICBwWzBdLFxuICAgICAgICAgIHBbMV0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGlzVHJ1c3RlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAvLyB1c2VyVHJpZ2dlcmVkIHRvIGZhbHNlIGFzIHRoaXMgY291bGQgd2VsbCBiZSBwcm9ncmFtbWF0aWNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50V2luZG93XG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyhydWxlMikge1xuICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgZnVuY3Rpb24gcmVjdXJzZShjaGlsZFJ1bGUsIHBvcykge1xuICAgIGlmIChoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpICYmIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTR3JvdXBpbmdSdWxlIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikgJiYgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NNZWRpYVJ1bGUgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0NvbmRpdGlvblJ1bGUpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oXG4gICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlLmNzc1J1bGVzXG4gICAgICApO1xuICAgICAgY29uc3QgaW5kZXgyID0gcnVsZXMyLmluZGV4T2YoY2hpbGRSdWxlKTtcbiAgICAgIHBvcy51bnNoaWZ0KGluZGV4Mik7XG4gICAgfSBlbHNlIGlmIChjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldCkge1xuICAgICAgY29uc3QgcnVsZXMyID0gQXJyYXkuZnJvbShjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldC5jc3NSdWxlcyk7XG4gICAgICBjb25zdCBpbmRleDIgPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgcG9zLnVuc2hpZnQoaW5kZXgyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICByZXR1cm4gcmVjdXJzZShydWxlMiwgcG9zaXRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldElkQW5kU3R5bGVJZChzaGVldCwgbWlycm9yMiwgc3R5bGVNaXJyb3IpIHtcbiAgbGV0IGlkLCBzdHlsZUlkO1xuICBpZiAoIXNoZWV0KSByZXR1cm4ge307XG4gIGlmIChzaGVldC5vd25lck5vZGUpIGlkID0gbWlycm9yMi5nZXRJZChzaGVldC5vd25lck5vZGUpO1xuICBlbHNlIHN0eWxlSWQgPSBzdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XG4gIHJldHVybiB7XG4gICAgc3R5bGVJZCxcbiAgICBpZFxuICB9O1xufVxuZnVuY3Rpb24gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcih7IHN0eWxlU2hlZXRSdWxlQ2IsIG1pcnJvcjogbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIgfSwgeyB3aW4gfSkge1xuICBpZiAoIXdpbi5DU1NTdHlsZVNoZWV0IHx8ICF3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5zZXJ0UnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlO1xuICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eShpbnNlcnRSdWxlLCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgY29uc3QgW3J1bGUyLCBpbmRleDJdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICApO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgIGFkZHM6IFt7IHJ1bGU6IHJ1bGUyLCBpbmRleDogaW5kZXgyIH1dXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xuICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuYWRkUnVsZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBzdHlsZUJsb2NrLCBpbmRleDIgPSB0aGlzLmNzc1J1bGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IHJ1bGUyID0gYCR7c2VsZWN0b3J9IHsgJHtzdHlsZUJsb2NrfSB9YDtcbiAgICByZXR1cm4gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUuYXBwbHkodGhpcywgW3J1bGUyLCBpbmRleDJdKTtcbiAgfTtcbiAgY29uc3QgZGVsZXRlUnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlO1xuICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShkZWxldGVSdWxlLCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgY29uc3QgW2luZGV4Ml0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXg6IGluZGV4MiB9XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZVJ1bGUgPSBmdW5jdGlvbihpbmRleDIpIHtcbiAgICByZXR1cm4gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUuYXBwbHkodGhpcywgW2luZGV4Ml0pO1xuICB9O1xuICBsZXQgcmVwbGFjZTtcbiAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlKSB7XG4gICAgcmVwbGFjZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcbiAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICByZXBsYWNlOiB0ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG4gIGxldCByZXBsYWNlU3luYztcbiAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYykge1xuICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IG5ldyBQcm94eShyZXBsYWNlU3luYywge1xuICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgIHJlcGxhY2VTeW5jOiB0ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcyA9IHt9O1xuICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpKSB7XG4gICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0dyb3VwaW5nUnVsZSA9IHdpbi5DU1NHcm91cGluZ1J1bGU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU01lZGlhUnVsZVwiKSkge1xuICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU01lZGlhUnVsZSA9IHdpbi5DU1NNZWRpYVJ1bGU7XG4gICAgfVxuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NDb25kaXRpb25SdWxlXCIpKSB7XG4gICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xuICAgIH1cbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTU3VwcG9ydHNSdWxlXCIpKSB7XG4gICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdW5tb2RpZmllZEZ1bmN0aW9ucyA9IHt9O1xuICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xuICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBpbnNlcnRSdWxlOiB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgZGVsZXRlUnVsZTogdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZVxuICAgIH07XG4gICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eShcbiAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSxcbiAgICAgIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbcnVsZTIsIGluZGV4Ml0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgICB0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsXG4gICAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlMixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4MiB8fCAwXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gMFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KFxuICAgICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlLFxuICAgICAge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtpbmRleDJdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgICAgdGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LFxuICAgICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IFsuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBpbmRleDJdIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBpbnNlcnRSdWxlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZGVsZXRlUnVsZTtcbiAgICByZXBsYWNlICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IHJlcGxhY2UpO1xuICAgIHJlcGxhY2VTeW5jICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSByZXBsYWNlU3luYyk7XG4gICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKChbdHlwZUtleSwgdHlwZV0pID0+IHtcbiAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGU7XG4gICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKHtcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBzdHlsZXNoZWV0TWFuYWdlclxufSwgaG9zdDIpIHtcbiAgdmFyIF9hMiwgX2IsIF9jO1xuICBsZXQgaG9zdElkID0gbnVsbDtcbiAgaWYgKGhvc3QyLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiKSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGhvc3QyKTtcbiAgZWxzZSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGluZGV4Lmhvc3QoaG9zdDIpKTtcbiAgY29uc3QgcGF0Y2hUYXJnZXQgPSBob3N0Mi5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIiA/IChfYTIgPSBob3N0Mi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5Eb2N1bWVudCA6IChfYyA9IChfYiA9IGhvc3QyLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLlNoYWRvd1Jvb3Q7XG4gIGNvbnN0IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yID0gKHBhdGNoVGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUpID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBwYXRjaFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlLFxuICAgIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCJcbiAgKSA6IHZvaWQgMDtcbiAgaWYgKGhvc3RJZCA9PT0gbnVsbCB8fCBob3N0SWQgPT09IC0xIHx8ICFwYXRjaFRhcmdldCB8fCAhb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgIGdldCgpIHtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gKF9hMyA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0KHNoZWV0cykge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSAoX2EzID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcywgc2hlZXRzKTtcbiAgICAgIGlmIChob3N0SWQgIT09IG51bGwgJiYgaG9zdElkICE9PSAtMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGdldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgc2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXRcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKHtcbiAgc3R5bGVEZWNsYXJhdGlvbkNiLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gIHN0eWxlc2hlZXRNYW5hZ2VyXG59LCB7IHdpbiB9KSB7XG4gIGNvbnN0IHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xuICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcbiAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xuICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcbiAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gbmV3IFByb3h5KHJlbW92ZVByb3BlcnR5LCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgY29uc3QgW3Byb3BlcnR5XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICByZW1vdmU6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7XG4gIG1lZGlhSW50ZXJhY3Rpb25DYixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBzYW1wbGluZyxcbiAgZG9jXG59KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgKHR5cGUpID0+IHRocm90dGxlKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSwgbG9vcCB9ID0gdGFyZ2V0O1xuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgICB2b2x1bWUsXG4gICAgICAgICAgbXV0ZWQsXG4gICAgICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIHNhbXBsaW5nLm1lZGlhIHx8IDUwMFxuICAgIClcbiAgKTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgb24oXCJwbGF5XCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuUGxheSksIGRvYyksXG4gICAgb24oXCJwYXVzZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBhdXNlKSwgZG9jKSxcbiAgICBvbihcInNlZWtlZFwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlNlZWtlZCksIGRvYyksXG4gICAgb24oXCJ2b2x1bWVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5Wb2x1bWVDaGFuZ2UpLCBkb2MpLFxuICAgIG9uKFwicmF0ZWNoYW5nZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlJhdGVDaGFuZ2UpLCBkb2MpXG4gIF07XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdEZvbnRPYnNlcnZlcih7IGZvbnRDYiwgZG9jIH0pIHtcbiAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIXdpbikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBjb25zdCBmb250TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IG9yaWdpbmFsRm9udEZhY2UgPSB3aW4uRm9udEZhY2U7XG4gIHdpbi5Gb250RmFjZSA9IGZ1bmN0aW9uIEZvbnRGYWNlMihmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBmb250RmFjZSA9IG5ldyBvcmlnaW5hbEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycyk7XG4gICAgZm9udE1hcC5zZXQoZm9udEZhY2UsIHtcbiAgICAgIGZhbWlseSxcbiAgICAgIGJ1ZmZlcjogdHlwZW9mIHNvdXJjZSAhPT0gXCJzdHJpbmdcIixcbiAgICAgIGRlc2NyaXB0b3JzLFxuICAgICAgZm9udFNvdXJjZTogdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiA/IHNvdXJjZSA6IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoc291cmNlKSkpXG4gICAgfSk7XG4gICAgcmV0dXJuIGZvbnRGYWNlO1xuICB9O1xuICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgIGRvYy5mb250cyxcbiAgICBcImFkZFwiLFxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm9udEZhY2UpIHtcbiAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgIGZvbnRDYihwKTtcbiAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xuICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XG4gIH0pO1xuICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgY29uc3QgeyBkb2MsIG1pcnJvcjogbWlycm9yMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgfSA9IHBhcmFtO1xuICBsZXQgY29sbGFwc2VkID0gdHJ1ZTtcbiAgY29uc3QgdXBkYXRlU2VsZWN0aW9uID0gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgY29sbGFwc2VkICYmIChzZWxlY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkpIHJldHVybjtcbiAgICBjb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgZmFsc2U7XG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgY29uc3QgY291bnQgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fCAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjb3VudDsgaTIrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpMik7XG4gICAgICBjb25zdCB7IHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgfSA9IHJhbmdlO1xuICAgICAgY29uc3QgYmxvY2tlZCA9IGlzQmxvY2tlZChzdGFydENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkgfHwgaXNCbG9ja2VkKGVuZENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSk7XG4gICAgICBpZiAoYmxvY2tlZCkgY29udGludWU7XG4gICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBtaXJyb3IyLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZDogbWlycm9yMi5nZXRJZChlbmRDb250YWluZXIpLFxuICAgICAgICBlbmRPZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcbiAgfSk7XG4gIHVwZGF0ZVNlbGVjdGlvbigpO1xuICByZXR1cm4gb24oXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdXBkYXRlU2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIoe1xuICBkb2MsXG4gIGN1c3RvbUVsZW1lbnRDYlxufSkge1xuICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goXG4gICAgd2luLmN1c3RvbUVsZW1lbnRzLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XG4gICAgICAgICAgICBkZWZpbmU6IHtcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ3VzdG9tIGVsZW1lbnQgY2FsbGJhY2sgZmFpbGVkIGZvciAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9uc10pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIHJldHVybiByZXN0b3JlSGFuZGxlcjtcbn1cbmZ1bmN0aW9uIG1lcmdlSG9va3MobzIsIGhvb2tzKSB7XG4gIGNvbnN0IHtcbiAgICBtdXRhdGlvbkNiLFxuICAgIG1vdXNlbW92ZUNiLFxuICAgIG1vdXNlSW50ZXJhY3Rpb25DYixcbiAgICBzY3JvbGxDYixcbiAgICB2aWV3cG9ydFJlc2l6ZUNiLFxuICAgIGlucHV0Q2IsXG4gICAgbWVkaWFJbnRlcmFjdGlvbkNiLFxuICAgIHN0eWxlU2hlZXRSdWxlQ2IsXG4gICAgc3R5bGVEZWNsYXJhdGlvbkNiLFxuICAgIGNhbnZhc011dGF0aW9uQ2IsXG4gICAgZm9udENiLFxuICAgIHNlbGVjdGlvbkNiLFxuICAgIGN1c3RvbUVsZW1lbnRDYlxuICB9ID0gbzI7XG4gIG8yLm11dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5tdXRhdGlvbikge1xuICAgICAgaG9va3MubXV0YXRpb24oLi4ucCk7XG4gICAgfVxuICAgIG11dGF0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLm1vdXNlbW92ZUNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XG4gICAgICBob29rcy5tb3VzZW1vdmUoLi4ucCk7XG4gICAgfVxuICAgIG1vdXNlbW92ZUNiKC4uLnApO1xuICB9O1xuICBvMi5tb3VzZUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XG4gICAgICBob29rcy5tb3VzZUludGVyYWN0aW9uKC4uLnApO1xuICAgIH1cbiAgICBtb3VzZUludGVyYWN0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLnNjcm9sbENiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XG4gICAgICBob29rcy5zY3JvbGwoLi4ucCk7XG4gICAgfVxuICAgIHNjcm9sbENiKC4uLnApO1xuICB9O1xuICBvMi52aWV3cG9ydFJlc2l6ZUNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcbiAgICAgIGhvb2tzLnZpZXdwb3J0UmVzaXplKC4uLnApO1xuICAgIH1cbiAgICB2aWV3cG9ydFJlc2l6ZUNiKC4uLnApO1xuICB9O1xuICBvMi5pbnB1dENiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MuaW5wdXQpIHtcbiAgICAgIGhvb2tzLmlucHV0KC4uLnApO1xuICAgIH1cbiAgICBpbnB1dENiKC4uLnApO1xuICB9O1xuICBvMi5tZWRpYUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcbiAgICAgIGhvb2tzLm1lZGlhSW50ZWFjdGlvbiguLi5wKTtcbiAgICB9XG4gICAgbWVkaWFJbnRlcmFjdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5zdHlsZVNoZWV0UnVsZUNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcbiAgICAgIGhvb2tzLnN0eWxlU2hlZXRSdWxlKC4uLnApO1xuICAgIH1cbiAgICBzdHlsZVNoZWV0UnVsZUNiKC4uLnApO1xuICB9O1xuICBvMi5zdHlsZURlY2xhcmF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XG4gICAgICBob29rcy5zdHlsZURlY2xhcmF0aW9uKC4uLnApO1xuICAgIH1cbiAgICBzdHlsZURlY2xhcmF0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLmNhbnZhc011dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xuICAgICAgaG9va3MuY2FudmFzTXV0YXRpb24oLi4ucCk7XG4gICAgfVxuICAgIGNhbnZhc011dGF0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLmZvbnRDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLmZvbnQpIHtcbiAgICAgIGhvb2tzLmZvbnQoLi4ucCk7XG4gICAgfVxuICAgIGZvbnRDYiguLi5wKTtcbiAgfTtcbiAgbzIuc2VsZWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcbiAgICAgIGhvb2tzLnNlbGVjdGlvbiguLi5wKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLmN1c3RvbUVsZW1lbnRDYiA9ICguLi5jMikgPT4ge1xuICAgIGlmIChob29rcy5jdXN0b21FbGVtZW50KSB7XG4gICAgICBob29rcy5jdXN0b21FbGVtZW50KC4uLmMyKTtcbiAgICB9XG4gICAgY3VzdG9tRWxlbWVudENiKC4uLmMyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGluaXRPYnNlcnZlcnMobzIsIGhvb2tzID0ge30pIHtcbiAgY29uc3QgY3VycmVudFdpbmRvdyA9IG8yLmRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIG1lcmdlSG9va3MobzIsIGhvb2tzKTtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gIH1cbiAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8yKTtcbiAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobzIsIHtcbiAgICB3aW46IGN1cnJlbnRXaW5kb3dcbiAgfSk7XG4gIGNvbnN0IGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8yKTtcbiAgY29uc3QgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgbGV0IHN0eWxlU2hlZXRPYnNlcnZlciA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBmb250T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8yLCB7IHdpbjogY3VycmVudFdpbmRvdyB9KTtcbiAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvMiwge1xuICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgfSk7XG4gICAgaWYgKG8yLmNvbGxlY3RGb250cykge1xuICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8yKTtcbiAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvMik7XG4gIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XG4gIGZvciAoY29uc3QgcGx1Z2luMyBvZiBvMi5wbHVnaW5zKSB7XG4gICAgcGx1Z2luSGFuZGxlcnMucHVzaChcbiAgICAgIHBsdWdpbjMub2JzZXJ2ZXIocGx1Z2luMy5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luMy5vcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGIpID0+IGIucmVzZXQoKSk7XG4gICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xuICAgIG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc2Nyb2xsSGFuZGxlcigpO1xuICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xuICAgIGlucHV0SGFuZGxlcigpO1xuICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xuICAgIGZvbnRPYnNlcnZlcigpO1xuICAgIHNlbGVjdGlvbk9ic2VydmVyKCk7XG4gICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XG4gICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3dbcHJvcF0gIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIE5vdGU6IEdlbmVyYWxseSwgdGhpcyBjaGVjayBfc2hvdWxkbid0XyBiZSBuZWNlc3NhcnlcbiAgICAvLyBIb3dldmVyLCBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBqc2RvbSkgdGhpcyBjYW4gc29tZXRpbWVzIGZhaWwsIHNvIHdlIGNoZWNrIGZvciBpdCBoZXJlXG4gICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImluc2VydFJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmIFwiZGVsZXRlUnVsZVwiIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGVcbiAgKTtcbn1cbmNsYXNzIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZUlkVG9SZW1vdGVJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZVJlbW90ZUlkVG9JZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XG4gIH1cbiAgZ2V0SWQoaWZyYW1lLCByZW1vdGVJZCwgaWRUb1JlbW90ZU1hcCwgcmVtb3RlVG9JZE1hcCkge1xuICAgIGNvbnN0IGlkVG9SZW1vdGVJZE1hcCA9IGlkVG9SZW1vdGVNYXAgfHwgdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSByZW1vdGVUb0lkTWFwIHx8IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgbGV0IGlkID0gaWRUb1JlbW90ZUlkTWFwLmdldChyZW1vdGVJZCk7XG4gICAgaWYgKCFpZCkge1xuICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xuICAgICAgaWRUb1JlbW90ZUlkTWFwLnNldChyZW1vdGVJZCwgaWQpO1xuICAgICAgcmVtb3RlSWRUb0lkTWFwLnNldChpZCwgcmVtb3RlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZ2V0SWRzKGlmcmFtZSwgcmVtb3RlSWQpIHtcbiAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgcmV0dXJuIHJlbW90ZUlkLm1hcChcbiAgICAgIChpZCkgPT4gdGhpcy5nZXRJZChpZnJhbWUsIGlkLCBpZFRvUmVtb3RlSWRNYXAsIHJlbW90ZUlkVG9JZE1hcClcbiAgICApO1xuICB9XG4gIGdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIG1hcCkge1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IG1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwibnVtYmVyXCIpIHJldHVybiBpZDtcbiAgICBjb25zdCByZW1vdGVJZCA9IHJlbW90ZUlkVG9JZE1hcC5nZXQoaWQpO1xuICAgIGlmICghcmVtb3RlSWQpIHJldHVybiAtMTtcbiAgICByZXR1cm4gcmVtb3RlSWQ7XG4gIH1cbiAgZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XG4gICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICByZXR1cm4gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgcmVtb3RlSWRUb0lkTWFwKSk7XG4gIH1cbiAgcmVzZXQoaWZyYW1lKSB7XG4gICAgaWYgKCFpZnJhbWUpIHtcbiAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgfVxuICBnZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKSB7XG4gICAgbGV0IGlkVG9SZW1vdGVJZE1hcCA9IHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLmdldChpZnJhbWUpO1xuICAgIGlmICghaWRUb1JlbW90ZUlkTWFwKSB7XG4gICAgICBpZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuc2V0KGlmcmFtZSwgaWRUb1JlbW90ZUlkTWFwKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkVG9SZW1vdGVJZE1hcDtcbiAgfVxuICBnZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKSB7XG4gICAgbGV0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmdldChpZnJhbWUpO1xuICAgIGlmICghcmVtb3RlSWRUb0lkTWFwKSB7XG4gICAgICByZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuc2V0KGlmcmFtZSwgcmVtb3RlSWRUb0lkTWFwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZUlkVG9JZE1hcDtcbiAgfVxufVxuY2xhc3MgSWZyYW1lTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWZyYW1lc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3JcIiwgbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3cmFwcGVkRW1pdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9hZExpc3RlbmVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzXCIpO1xuICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICB0aGlzLndyYXBwZWRFbWl0ID0gb3B0aW9ucy53cmFwcGVkRW1pdDtcbiAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyID0gb3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICB0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IG9wdGlvbnMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzO1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihcbiAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IuZ2VuZXJhdGVJZC5iaW5kKFxuICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xuICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgYWRkSWZyYW1lKGlmcmFtZUVsKSB7XG4gICAgdGhpcy5pZnJhbWVzLnNldChpZnJhbWVFbCwgdHJ1ZSk7XG4gICAgaWYgKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpXG4gICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLnNldChpZnJhbWVFbC5jb250ZW50V2luZG93LCBpZnJhbWVFbCk7XG4gIH1cbiAgYWRkTG9hZExpc3RlbmVyKGNiKSB7XG4gICAgdGhpcy5sb2FkTGlzdGVuZXIgPSBjYjtcbiAgfVxuICBhdHRhY2hJZnJhbWUoaWZyYW1lRWwsIGNoaWxkU24pIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgYWRkczogW1xuICAgICAgICB7XG4gICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcbiAgICAgICAgICBuZXh0SWQ6IG51bGwsXG4gICAgICAgICAgbm9kZTogY2hpbGRTblxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmVtb3ZlczogW10sXG4gICAgICB0ZXh0czogW10sXG4gICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKVxuICAgICAgKF9hMiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIChfYiA9IHRoaXMubG9hZExpc3RlbmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBpZnJhbWVFbCk7XG4gICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcbiAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhcbiAgICAgICAgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyxcbiAgICAgICAgdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwuY29udGVudERvY3VtZW50KVxuICAgICAgKTtcbiAgfVxuICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudCA9IG1lc3NhZ2U7XG4gICAgaWYgKGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEudHlwZSAhPT0gXCJycndlYlwiIHx8IC8vIFRvIGZpbHRlciBvdXQgdGhlIHJyd2ViIG1lc3NhZ2VzIHdoaWNoIGFyZSBmb3J3YXJkZWQgYnkgc29tZSBzaXRlcy5cbiAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5vcmlnaW4gIT09IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEub3JpZ2luKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlmcmFtZVNvdXJjZVdpbmRvdyA9IG1lc3NhZ2Uuc291cmNlO1xuICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KSByZXR1cm47XG4gICAgY29uc3QgaWZyYW1lRWwgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLmdldChtZXNzYWdlLnNvdXJjZSk7XG4gICAgaWYgKCFpZnJhbWVFbCkgcmV0dXJuO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkRXZlbnQgPSB0aGlzLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoXG4gICAgICBpZnJhbWVFbCxcbiAgICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuZXZlbnRcbiAgICApO1xuICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KVxuICAgICAgdGhpcy53cmFwcGVkRW1pdChcbiAgICAgICAgdHJhbnNmb3JtZWRFdmVudCxcbiAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5pc0NoZWNrb3V0XG4gICAgICApO1xuICB9XG4gIHRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGUyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBzd2l0Y2ggKGUyLnR5cGUpIHtcbiAgICAgIGNhc2UgRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdDoge1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoZTIuZGF0YS5ub2RlLCBpZnJhbWVFbCk7XG4gICAgICAgIGNvbnN0IHJvb3RJZCA9IGUyLmRhdGEubm9kZS5pZDtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XG4gICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZTIuZGF0YS5ub2RlLCByb290SWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpbWVzdGFtcDogZTIudGltZXN0YW1wLFxuICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlOiBlMi5kYXRhLm5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRXZlbnRUeXBlLk1ldGE6XG4gICAgICBjYXNlIEV2ZW50VHlwZS5Mb2FkOlxuICAgICAgY2FzZSBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZDoge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjYXNlIEV2ZW50VHlwZS5QbHVnaW46IHtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuQ3VzdG9tOiB7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkcyhcbiAgICAgICAgICBlMi5kYXRhLnBheWxvYWQsXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgW1wiaWRcIiwgXCJwYXJlbnRJZFwiLCBcInByZXZpb3VzSWRcIiwgXCJuZXh0SWRcIl1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdDoge1xuICAgICAgICBzd2l0Y2ggKGUyLmRhdGEuc291cmNlKSB7XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5hZGRzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0SWRcIixcbiAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIlxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobjIubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgIHJvb3RJZCAmJiB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKG4yLm5vZGUsIHJvb3RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUyLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJwYXJlbnRJZFwiLCBcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS50ZXh0cy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlOiB7XG4gICAgICAgICAgICBlMi5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNjcm9sbDpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wic3R5bGVJZFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRm9udDoge1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgW1wic3RhcnRcIiwgXCJlbmRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcInN0eWxlSWRzXCJdKTtcbiAgICAgICAgICAgIChfYTIgPSBlMi5kYXRhLnN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFtcInN0eWxlSWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgdHlwZW9mIG9ialtrZXldICE9PSBcIm51bWJlclwiKSBjb250aW51ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgb2JqW2tleV1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkKGlmcmFtZUVsLCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmVwbGFjZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlSWRPbk5vZGUobm9kZTIsIGlmcmFtZUVsKSB7XG4gICAgdGhpcy5yZXBsYWNlSWRzKG5vZGUyLCBpZnJhbWVFbCwgW1wiaWRcIiwgXCJyb290SWRcIl0pO1xuICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlMikge1xuICAgICAgbm9kZTIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShjaGlsZCwgaWZyYW1lRWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUyLCByb290SWQpIHtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gTm9kZVR5cGUuRG9jdW1lbnQgJiYgIW5vZGUyLnJvb3RJZCkgbm9kZTIucm9vdElkID0gcm9vdElkO1xuICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlMikge1xuICAgICAgbm9kZTIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKGNoaWxkLCByb290SWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBTaGFkb3dEb21NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dEb21zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2Nyb2xsQ2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJ5cGFzc09wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzdG9yZUhhbmRsZXJzXCIsIFtdKTtcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XG4gICAgdGhpcy5ieXBhc3NPcHRpb25zID0gb3B0aW9ucy5ieXBhc3NPcHRpb25zO1xuICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhFbGVtZW50LCBkb2N1bWVudCk7XG4gIH1cbiAgYWRkU2hhZG93Um9vdChzaGFkb3dSb290MiwgZG9jKSB7XG4gICAgaWYgKCFpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290MikpIHJldHVybjtcbiAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290MikpIHJldHVybjtcbiAgICB0aGlzLnNoYWRvd0RvbXMuYWRkKHNoYWRvd1Jvb3QyKTtcbiAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKFxuICAgICAge1xuICAgICAgICAuLi50aGlzLmJ5cGFzc09wdGlvbnMsXG4gICAgICAgIGRvYyxcbiAgICAgICAgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLFxuICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyOiB0aGlzXG4gICAgICB9LFxuICAgICAgc2hhZG93Um9vdDJcbiAgICApO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpKTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKFxuICAgICAgaW5pdFNjcm9sbE9ic2VydmVyKHtcbiAgICAgICAgLi4udGhpcy5ieXBhc3NPcHRpb25zLFxuICAgICAgICBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYixcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcHJhdmVlbnB1Z2xpYS8wODMyZGE2ODdlZDVhNWQ3YTA5MDcwNDZjOWVmMTgxM1xuICAgICAgICAvLyBzY3JvbGwgaXMgbm90IGFsbG93ZWQgdG8gcGFzcyB0aGUgYm91bmRhcnksIHNvIHdlIG5lZWQgdG8gbGlzdGVuIHRoZSBzaGFkb3cgZG9jdW1lbnRcbiAgICAgICAgZG9jOiBzaGFkb3dSb290MixcbiAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxuICAgICAgfSlcbiAgICApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHNoYWRvd1Jvb3QyLmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcbiAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoXG4gICAgICAgICAgc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICAgIHRoaXMubWlycm9yLmdldElkKGluZGV4Lmhvc3Qoc2hhZG93Um9vdDIpKVxuICAgICAgICApO1xuICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChcbiAgICAgICAgaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiB0aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNoYWRvd1Jvb3QyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCAnYXR0YWNoU2hhZG93JyBvZiBhbiBJRnJhbWVFbGVtZW50IHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqL1xuICBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcbiAgICBpZiAoIWlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdyB8fCAhaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpIHJldHVybjtcbiAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KFxuICAgICAgaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93LkVsZW1lbnQsXG4gICAgICBpZnJhbWVFbGVtZW50LmNvbnRlbnREb2N1bWVudFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoICdhdHRhY2hTaGFkb3cnIHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqL1xuICBwYXRjaEF0dGFjaFNoYWRvdyhlbGVtZW50LCBkb2MpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKFxuICAgICAgcGF0Y2goXG4gICAgICAgIGVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICBcImF0dGFjaFNoYWRvd1wiLFxuICAgICAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNSb290ID0gb3JpZ2luYWwuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdEVsID0gaW5kZXguc2hhZG93Um9vdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290RWwgJiYgaW5Eb20odGhpcykpXG4gICAgICAgICAgICAgIG1hbmFnZXIuYWRkU2hhZG93Um9vdChzaGFkb3dSb290RWwsIGRvYyk7XG4gICAgICAgICAgICByZXR1cm4gc1Jvb3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuc2hhZG93RG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICB9XG59XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoYXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpMiwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHtcbiAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTJdID4+IDJdO1xuICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaTJdICYgMykgPDwgNCB8IGJ5dGVzW2kyICsgMV0gPj4gNF07XG4gICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdO1xuICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpMiArIDJdICYgNjNdO1xuICB9XG4gIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gIH1cbiAgcmV0dXJuIGJhc2U2NDtcbn07XG5jb25zdCBjYW52YXNWYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBjdG9yKSB7XG4gIGxldCBjb250ZXh0TWFwID0gY2FudmFzVmFyTWFwLmdldChjdHgpO1xuICBpZiAoIWNvbnRleHRNYXApIHtcbiAgICBjb250ZXh0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjYW52YXNWYXJNYXAuc2V0KGN0eCwgY29udGV4dE1hcCk7XG4gIH1cbiAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xuICAgIGNvbnRleHRNYXAuc2V0KGN0b3IsIFtdKTtcbiAgfVxuICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XG59XG5jb25zdCBzYXZlV2ViR0xWYXIgPSAodmFsdWUsIHdpbiwgY3R4KSA9PiB7XG4gIGlmICghdmFsdWUgfHwgIShpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpKVxuICAgIHJldHVybjtcbiAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGNvbnN0IGxpc3QyID0gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBuYW1lKTtcbiAgbGV0IGluZGV4MiA9IGxpc3QyLmluZGV4T2YodmFsdWUpO1xuICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgIGluZGV4MiA9IGxpc3QyLmxlbmd0aDtcbiAgICBsaXN0Mi5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gaW5kZXgyO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFyZyh2YWx1ZSwgd2luLCBjdHgpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgcnJfdHlwZTogbmFtZSxcbiAgICAgIGFyZ3M6IFtPYmplY3QudmFsdWVzKHZhbHVlKV1cbiAgICB9O1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIFNoYXJlZEFycmF5QnVmZmVyIGRpc2FibGVkIG9uIG1vc3QgYnJvd3NlcnMgZHVlIHRvIHNwZWN0cmUuXG4gICAgLy8gTW9yZSBpbmZvOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TaGFyZWRBcnJheUJ1ZmZlci9TaGFyZWRBcnJheUJ1ZmZlclxuICAgIC8vIHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIgfHxcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICkge1xuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBiYXNlNjRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgcnJfdHlwZTogbmFtZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAgc2VyaWFsaXplQXJnKHZhbHVlLmJ1ZmZlciwgd2luLCBjdHgpLFxuICAgICAgICB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICBdXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCB7IHNyYyB9ID0gdmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICBjb25zdCBuYW1lID0gXCJIVE1MSW1hZ2VFbGVtZW50XCI7XG4gICAgY29uc3Qgc3JjID0gdmFsdWUudG9EYXRhVVJMKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBhcmdzOiBbc2VyaWFsaXplQXJnKHZhbHVlLmRhdGEsIHdpbiwgY3R4KSwgdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodF1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IGluZGV4MiA9IHNhdmVXZWJHTFZhcih2YWx1ZSwgd2luLCBjdHgpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgaW5kZXg6IGluZGV4MlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3Qgc2VyaWFsaXplQXJncyA9IChhcmdzLCB3aW4sIGN0eCkgPT4ge1xuICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpKTtcbn07XG5jb25zdCBpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCA9ICh2YWx1ZSwgd2luKSA9PiB7XG4gIGNvbnN0IHdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IFtcbiAgICBcIldlYkdMQWN0aXZlSW5mb1wiLFxuICAgIFwiV2ViR0xCdWZmZXJcIixcbiAgICBcIldlYkdMRnJhbWVidWZmZXJcIixcbiAgICBcIldlYkdMUHJvZ3JhbVwiLFxuICAgIFwiV2ViR0xSZW5kZXJidWZmZXJcIixcbiAgICBcIldlYkdMU2hhZGVyXCIsXG4gICAgXCJXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdFwiLFxuICAgIFwiV2ViR0xUZXh0dXJlXCIsXG4gICAgXCJXZWJHTFVuaWZvcm1Mb2NhdGlvblwiLFxuICAgIFwiV2ViR0xWZXJ0ZXhBcnJheU9iamVjdFwiLFxuICAgIC8vIEluIG9sZCBDaHJvbWUgdmVyc2lvbnMsIHZhbHVlIHdvbid0IGJlIGFuIGluc3RhbmNlb2YgV2ViR0xWZXJ0ZXhBcnJheU9iamVjdC5cbiAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RPRVNcIlxuICBdO1xuICBjb25zdCBzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMgPSB3ZWJHTENvbnN0cnVjdG9yTmFtZXMuZmlsdGVyKFxuICAgIChuYW1lKSA9PiB0eXBlb2Ygd2luW25hbWVdID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbmQoXG4gICAgICAobmFtZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiB3aW5bbmFtZV1cbiAgICApXG4gICk7XG59O1xuZnVuY3Rpb24gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIGNvbnN0IHByb3BzMkQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhcbiAgICB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVxuICApO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMyRCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgICAgICB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIoXG4gICAgICAgIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLFxuICAgICAgICBwcm9wLFxuICAgICAgICB7XG4gICAgICAgICAgc2V0KHYyKSB7XG4gICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICBhcmdzOiBbdjJdLFxuICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpIHtcbiAgcmV0dXJuIGNvbnRleHRUeXBlID09PSBcImV4cGVyaW1lbnRhbC13ZWJnbFwiID8gXCJ3ZWJnbFwiIDogY29udGV4dFR5cGU7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICAgIHdpbi5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICBcImdldENvbnRleHRcIixcbiAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0VHlwZSwgLi4uYXJncykge1xuICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHhOYW1lID0gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKTtcbiAgICAgICAgICAgIGlmICghKFwiX19jb250ZXh0XCIgaW4gdGhpcykpIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcbiAgICAgICAgICAgIGlmIChzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUgJiYgW1wid2ViZ2xcIiwgXCJ3ZWJnbDJcIl0uaW5jbHVkZXMoY3R4TmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDEsIHtcbiAgICAgICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbY29udGV4dFR5cGUsIC4uLmFyZ3NdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICB9IGNhdGNoIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIHBhdGNoIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0XCIpO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGNoR0xQcm90b3R5cGUocHJvdG90eXBlLCB0eXBlLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgd2luKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgaWYgKFxuICAgICAgLy9wcm9wLnN0YXJ0c1dpdGgoJ2dldCcpIHx8ICAvLyBlLmcuIGdldFByb2dyYW1QYXJhbWV0ZXIsIGJ1dCB0b28gcmlza3lcbiAgICAgIFtcbiAgICAgICAgXCJpc0NvbnRleHRMb3N0XCIsXG4gICAgICAgIFwiY2FudmFzXCIsXG4gICAgICAgIFwiZHJhd2luZ0J1ZmZlcldpZHRoXCIsXG4gICAgICAgIFwiZHJhd2luZ0J1ZmZlckhlaWdodFwiXG4gICAgICBdLmluY2x1ZGVzKHByb3ApXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgICAgICBwcm90b3R5cGUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHNhdmVXZWJHTFZhcihyZXN1bHQyLCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKFwidGFnTmFtZVwiIGluIHRoaXMuY2FudmFzICYmICFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywgbXV0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICBzZXQodjIpIHtcbiAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgYXJnczogW3YyXSxcbiAgICAgICAgICAgIHNldHRlcjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlcnM7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgaGFuZGxlcnMucHVzaChcbiAgICAuLi5wYXRjaEdMUHJvdG90eXBlKFxuICAgICAgd2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsXG4gICAgICBDYW52YXNDb250ZXh0LldlYkdMLFxuICAgICAgY2IsXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHdpblxuICAgIClcbiAgKTtcbiAgaWYgKHR5cGVvZiB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGhhbmRsZXJzLnB1c2goXG4gICAgICAuLi5wYXRjaEdMUHJvdG90eXBlKFxuICAgICAgICB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsXG4gICAgICAgIENhbnZhc0NvbnRleHQuV2ViR0wyLFxuICAgICAgICBjYixcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgd2luXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5jb25zdCBlbmNvZGVkSnMgPSBcIktHWjFibU4wYVc5dUtDa2dld29nSUNKMWMyVWdjM1J5YVdOMElqc0tJQ0IyWVhJZ1kyaGhjbk1nUFNBaVFVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UxUlZWbGRZV1ZwaFltTmtaV1puYUdscWEyeHRibTl3Y1hKemRIVjJkM2g1ZWpBeE1qTTBOVFkzT0Rrckx5STdDaUFnZG1GeUlHeHZiMnQxY0NBOUlIUjVjR1Z2WmlCVmFXNTBPRUZ5Y21GNUlEMDlQU0FpZFc1a1pXWnBibVZrSWlBL0lGdGRJRG9nYm1WM0lGVnBiblE0UVhKeVlYa29NalUyS1RzS0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05vWVhKekxteGxibWQwYURzZ2FTc3JLU0I3Q2lBZ0lDQnNiMjlyZFhCYlkyaGhjbk11WTJoaGNrTnZaR1ZCZENocEtWMGdQU0JwT3dvZ0lIMEtJQ0IyWVhJZ1pXNWpiMlJsSUQwZ1puVnVZM1JwYjI0b1lYSnlZWGxpZFdabVpYSXBJSHNLSUNBZ0lIWmhjaUJpZVhSbGN5QTlJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHRnljbUY1WW5WbVptVnlLU3dnYVRJc0lHeGxiaUE5SUdKNWRHVnpMbXhsYm1kMGFDd2dZbUZ6WlRZMElEMGdJaUk3Q2lBZ0lDQm1iM0lnS0dreUlEMGdNRHNnYVRJZ1BDQnNaVzQ3SUdreUlDczlJRE1wSUhzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXMko1ZEdWelcya3lYU0ErUGlBeVhUc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6V3loaWVYUmxjMXRwTWwwZ0ppQXpLU0E4UENBMElId2dZbmwwWlhOYmFUSWdLeUF4WFNBK1BpQTBYVHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKeld5aGllWFJsYzF0cE1pQXJJREZkSUNZZ01UVXBJRHc4SURJZ2ZDQmllWFJsYzF0cE1pQXJJREpkSUQ0K0lEWmRPd29nSUNBZ0lDQmlZWE5sTmpRZ0t6MGdZMmhoY25OYllubDBaWE5iYVRJZ0t5QXlYU0FtSURZelhUc0tJQ0FnSUgwS0lDQWdJR2xtSUNoc1pXNGdKU0F6SUQwOVBTQXlLU0I3Q2lBZ0lDQWdJR0poYzJVMk5DQTlJR0poYzJVMk5DNXpkV0p6ZEhKcGJtY29NQ3dnWW1GelpUWTBMbXhsYm1kMGFDQXRJREVwSUNzZ0lqMGlPd29nSUNBZ2ZTQmxiSE5sSUdsbUlDaHNaVzRnSlNBeklEMDlQU0F4S1NCN0NpQWdJQ0FnSUdKaGMyVTJOQ0E5SUdKaGMyVTJOQzV6ZFdKemRISnBibWNvTUN3Z1ltRnpaVFkwTG14bGJtZDBhQ0F0SURJcElDc2dJajA5SWpzS0lDQWdJSDBLSUNBZ0lISmxkSFZ5YmlCaVlYTmxOalE3Q2lBZ2ZUc0tJQ0JqYjI1emRDQnNZWE4wUW14dllrMWhjQ0E5SUM4cUlFQmZYMUJWVWtWZlh5QXFMeUJ1WlhjZ1RXRndLQ2s3Q2lBZ1kyOXVjM1FnZEhKaGJuTndZWEpsYm5SQ2JHOWlUV0Z3SUQwZ0x5b2dRRjlmVUZWU1JWOWZJQ292SUc1bGR5Qk5ZWEFvS1RzS0lDQmhjM2x1WXlCbWRXNWpkR2x2YmlCblpYUlVjbUZ1YzNCaGNtVnVkRUpzYjJKR2IzSW9kMmxrZEdnc0lHaGxhV2RvZEN3Z1pHRjBZVlZTVEU5d2RHbHZibk1wSUhzS0lDQWdJR052Ym5OMElHbGtJRDBnWUNSN2QybGtkR2g5TFNSN2FHVnBaMmgwZldBN0NpQWdJQ0JwWmlBb0lrOW1abk5qY21WbGJrTmhiblpoY3lJZ2FXNGdaMnh2WW1Gc1ZHaHBjeWtnZXdvZ0lDQWdJQ0JwWmlBb2RISmhibk53WVhKbGJuUkNiRzlpVFdGd0xtaGhjeWhwWkNrcElISmxkSFZ5YmlCMGNtRnVjM0JoY21WdWRFSnNiMkpOWVhBdVoyVjBLR2xrS1RzS0lDQWdJQ0FnWTI5dWMzUWdiMlptYzJOeVpXVnVJRDBnYm1WM0lFOW1abk5qY21WbGJrTmhiblpoY3loM2FXUjBhQ3dnYUdWcFoyaDBLVHNLSUNBZ0lDQWdiMlptYzJOeVpXVnVMbWRsZEVOdmJuUmxlSFFvSWpKa0lpazdDaUFnSUNBZ0lHTnZibk4wSUdKc2IySWdQU0JoZDJGcGRDQnZabVp6WTNKbFpXNHVZMjl1ZG1WeWRGUnZRbXh2WWloa1lYUmhWVkpNVDNCMGFXOXVjeWs3Q2lBZ0lDQWdJR052Ym5OMElHRnljbUY1UW5WbVptVnlJRDBnWVhkaGFYUWdZbXh2WWk1aGNuSmhlVUoxWm1abGNpZ3BPd29nSUNBZ0lDQmpiMjV6ZENCaVlYTmxOalFnUFNCbGJtTnZaR1VvWVhKeVlYbENkV1ptWlhJcE93b2dJQ0FnSUNCMGNtRnVjM0JoY21WdWRFSnNiMkpOWVhBdWMyVjBLR2xrTENCaVlYTmxOalFwT3dvZ0lDQWdJQ0J5WlhSMWNtNGdZbUZ6WlRZME93b2dJQ0FnZlNCbGJITmxJSHNLSUNBZ0lDQWdjbVYwZFhKdUlDSWlPd29nSUNBZ2ZRb2dJSDBLSUNCamIyNXpkQ0IzYjNKclpYSWdQU0J6Wld4bU93b2dJSGR2Y210bGNpNXZibTFsYzNOaFoyVWdQU0JoYzNsdVl5Qm1kVzVqZEdsdmJpaGxLU0I3Q2lBZ0lDQnBaaUFvSWs5bVpuTmpjbVZsYmtOaGJuWmhjeUlnYVc0Z1oyeHZZbUZzVkdocGN5a2dld29nSUNBZ0lDQmpiMjV6ZENCN0lHbGtMQ0JpYVhSdFlYQXNJSGRwWkhSb0xDQm9aV2xuYUhRc0lHUmhkR0ZWVWt4UGNIUnBiMjV6SUgwZ1BTQmxMbVJoZEdFN0NpQWdJQ0FnSUdOdmJuTjBJSFJ5WVc1emNHRnlaVzUwUW1GelpUWTBJRDBnWjJWMFZISmhibk53WVhKbGJuUkNiRzlpUm05eUtBb2dJQ0FnSUNBZ0lIZHBaSFJvTEFvZ0lDQWdJQ0FnSUdobGFXZG9kQ3dLSUNBZ0lDQWdJQ0JrWVhSaFZWSk1UM0IwYVc5dWN3b2dJQ0FnSUNBcE93b2dJQ0FnSUNCamIyNXpkQ0J2Wm1aelkzSmxaVzRnUFNCdVpYY2dUMlptYzJOeVpXVnVRMkZ1ZG1GektIZHBaSFJvTENCb1pXbG5hSFFwT3dvZ0lDQWdJQ0JqYjI1emRDQmpkSGdnUFNCdlptWnpZM0psWlc0dVoyVjBRMjl1ZEdWNGRDZ2lNbVFpS1RzS0lDQWdJQ0FnWTNSNExtUnlZWGRKYldGblpTaGlhWFJ0WVhBc0lEQXNJREFwT3dvZ0lDQWdJQ0JpYVhSdFlYQXVZMnh2YzJVb0tUc0tJQ0FnSUNBZ1kyOXVjM1FnWW14dllpQTlJR0YzWVdsMElHOW1abk5qY21WbGJpNWpiMjUyWlhKMFZHOUNiRzlpS0dSaGRHRlZVa3hQY0hScGIyNXpLVHNLSUNBZ0lDQWdZMjl1YzNRZ2RIbHdaU0E5SUdKc2IySXVkSGx3WlRzS0lDQWdJQ0FnWTI5dWMzUWdZWEp5WVhsQ2RXWm1aWElnUFNCaGQyRnBkQ0JpYkc5aUxtRnljbUY1UW5WbVptVnlLQ2s3Q2lBZ0lDQWdJR052Ym5OMElHSmhjMlUyTkNBOUlHVnVZMjlrWlNoaGNuSmhlVUoxWm1abGNpazdDaUFnSUNBZ0lHbG1JQ2doYkdGemRFSnNiMkpOWVhBdWFHRnpLR2xrS1NBbUppQmhkMkZwZENCMGNtRnVjM0JoY21WdWRFSmhjMlUyTkNBOVBUMGdZbUZ6WlRZMEtTQjdDaUFnSUNBZ0lDQWdiR0Z6ZEVKc2IySk5ZWEF1YzJWMEtHbGtMQ0JpWVhObE5qUXBPd29nSUNBZ0lDQWdJSEpsZEhWeWJpQjNiM0pyWlhJdWNHOXpkRTFsYzNOaFoyVW9leUJwWkNCOUtUc0tJQ0FnSUNBZ2ZRb2dJQ0FnSUNCcFppQW9iR0Z6ZEVKc2IySk5ZWEF1WjJWMEtHbGtLU0E5UFQwZ1ltRnpaVFkwS1NCeVpYUjFjbTRnZDI5eWEyVnlMbkJ2YzNSTlpYTnpZV2RsS0hzZ2FXUWdmU2s3Q2lBZ0lDQWdJSGR2Y210bGNpNXdiM04wVFdWemMyRm5aU2g3Q2lBZ0lDQWdJQ0FnYVdRc0NpQWdJQ0FnSUNBZ2RIbHdaU3dLSUNBZ0lDQWdJQ0JpWVhObE5qUXNDaUFnSUNBZ0lDQWdkMmxrZEdnc0NpQWdJQ0FnSUNBZ2FHVnBaMmgwQ2lBZ0lDQWdJSDBwT3dvZ0lDQWdJQ0JzWVhOMFFteHZZazFoY0M1elpYUW9hV1FzSUdKaGMyVTJOQ2s3Q2lBZ0lDQjlJR1ZzYzJVZ2V3b2dJQ0FnSUNCeVpYUjFjbTRnZDI5eWEyVnlMbkJ2YzNSTlpYTnpZV2RsS0hzZ2FXUTZJR1V1WkdGMFlTNXBaQ0I5S1RzS0lDQWdJSDBLSUNCOU93cDlLU2dwT3dvdkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMXBiV0ZuWlMxaWFYUnRZWEF0WkdGMFlTMTFjbXd0ZDI5eWEyVnlMVWxLY0VNM1oxOWlMbXB6TG0xaGNBbz1cIjtcbmNvbnN0IGRlY29kZUJhc2U2NCA9IChiYXNlNjQpID0+IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJhc2U2NCksIChjMikgPT4gYzIuY2hhckNvZGVBdCgwKSk7XG5jb25zdCBibG9iID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuQmxvYiAmJiBuZXcgQmxvYihbZGVjb2RlQmFzZTY0KGVuY29kZWRKcyldLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLThcIiB9KTtcbmZ1bmN0aW9uIFdvcmtlcldyYXBwZXIob3B0aW9ucykge1xuICBsZXQgb2JqVVJMO1xuICB0cnkge1xuICAgIG9ialVSTCA9IGJsb2IgJiYgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGlmICghb2JqVVJMKSB0aHJvdyBcIlwiO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIob2JqVVJMLCB7XG4gICAgICBuYW1lOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWVcbiAgICB9KTtcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgIH0pO1xuICAgIHJldHVybiB3b3JrZXI7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIoXG4gICAgICBcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGVuY29kZWRKcyxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lXG4gICAgICB9XG4gICAgKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBvYmpVUkwgJiYgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKG9ialVSTCk7XG4gIH1cbn1cbmNsYXNzIENhbnZhc01hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlbmRpbmdDYW52YXNNdXRhdGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJhZlN0YW1wc1wiLCB7IGxhdGVzdElkOiAwLCBpbnZva2VJZDogbnVsbCB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNldE9ic2VydmVyc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJvemVuXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9ja2VkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uXCIsICh0YXJnZXQsIG11dGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBuZXdGcmFtZSA9IHRoaXMucmFmU3RhbXBzLmludm9rZUlkICYmIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcbiAgICAgIGlmIChuZXdGcmFtZSB8fCAhdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpXG4gICAgICAgIHRoaXMucmFmU3RhbXBzLmludm9rZUlkID0gdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldCh0YXJnZXQpLnB1c2gobXV0YXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHNhbXBsaW5nID0gXCJhbGxcIixcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgZGF0YVVSTE9wdGlvbnNcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICBpZiAocmVjb3JkQ2FudmFzICYmIHNhbXBsaW5nID09PSBcImFsbFwiKVxuICAgICAgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSBcIm51bWJlclwiKVxuICAgICAgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xuICAgICAgICBkYXRhVVJMT3B0aW9uc1xuICAgICAgfSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5yZXNldE9ic2VydmVycyAmJiB0aGlzLnJlc2V0T2JzZXJ2ZXJzKCk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgfVxuICB1bmZyZWV6ZSgpIHtcbiAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICB9XG4gIHVubG9jaygpIHtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB9XG4gIGluaXRDYW52YXNGUFNPYnNlcnZlcihmcHMsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIoXG4gICAgICB3aW4sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbnN0IHNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcldyYXBwZXIoKTtcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKGUyKSA9PiB7XG4gICAgICBjb25zdCB7IGlkIH0gPSBlMi5kYXRhO1xuICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgZmFsc2UpO1xuICAgICAgaWYgKCEoXCJiYXNlNjRcIiBpbiBlMi5kYXRhKSkgcmV0dXJuO1xuICAgICAgY29uc3QgeyBiYXNlNjQsIHR5cGUsIHdpZHRoLCBoZWlnaHQgfSA9IGUyLmRhdGE7XG4gICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICBjb21tYW5kczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImNsZWFyUmVjdFwiLFxuICAgICAgICAgICAgLy8gd2lwZSBjYW52YXNcbiAgICAgICAgICAgIGFyZ3M6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvcGVydHk6IFwiZHJhd0ltYWdlXCIsXG4gICAgICAgICAgICAvLyBkcmF3cyAoc2VtaS10cmFuc3BhcmVudCkgaW1hZ2VcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiSW1hZ2VCaXRtYXBcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiQmxvYlwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbeyBycl90eXBlOiBcIkFycmF5QnVmZmVyXCIsIGJhc2U2NCB9XSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDFlMyAvIGZwcztcbiAgICBsZXQgbGFzdFNuYXBzaG90VGltZSA9IDA7XG4gICAgbGV0IHJhZklkO1xuICAgIGNvbnN0IGdldENhbnZhcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZWRDYW52YXMgPSBbXTtcbiAgICAgIHdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiY2FudmFzXCIpLmZvckVhY2goKGNhbnZhcykgPT4ge1xuICAgICAgICBpZiAoIWlzQmxvY2tlZChjYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgbWF0Y2hlZENhbnZhcy5wdXNoKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XG4gICAgfTtcbiAgICBjb25zdCB0YWtlQ2FudmFzU25hcHNob3RzID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgaWYgKGxhc3RTbmFwc2hvdFRpbWUgJiYgdGltZXN0YW1wIC0gbGFzdFNuYXBzaG90VGltZSA8IHRpbWVCZXR3ZWVuU25hcHNob3RzKSB7XG4gICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xuICAgICAgZ2V0Q2FudmFzKCkuZm9yRWFjaChhc3luYyAoY2FudmFzKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcbiAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKSByZXR1cm47XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKFtcIndlYmdsXCIsIFwid2ViZ2wyXCJdLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xuICAgICAgICAgIGlmICgoKF9hMiA9IGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGV4dC5jbGVhcihjb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChjYW52YXMpO1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBiaXRtYXAsXG4gICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtiaXRtYXBdXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgIH07XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XG4gICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcbiAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgIH07XG4gIH1cbiAgaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgdGhpcy5zdGFydFJBRlRpbWVzdGFtcGluZygpO1xuICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XG4gICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcihcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGNvbnN0IGNhbnZhczJEUmVzZXQgPSBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yXG4gICAgKTtcbiAgICBjb25zdCBjYW52YXNXZWJHTDFhbmQyUmVzZXQgPSBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yXG4gICAgKTtcbiAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gKCkgPT4ge1xuICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XG4gICAgICBjYW52YXMyRFJlc2V0KCk7XG4gICAgICBjYW52YXNXZWJHTDFhbmQyUmVzZXQoKTtcbiAgICB9O1xuICB9XG4gIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSk7XG4gIH1cbiAgc3RhcnRSQUZUaW1lc3RhbXBpbmcoKSB7XG4gICAgY29uc3Qgc2V0TGF0ZXN0UkFGVGltZXN0YW1wID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgPSB0aW1lc3RhbXA7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgICB9O1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xuICB9XG4gIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpIHtcbiAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZm9yRWFjaChcbiAgICAgIChfdmFsdWVzLCBjYW52YXMpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xuICAgICAgICB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xuICB9XG4gIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpIHtcbiAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzV2l0aFR5cGUgPSB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KGNhbnZhcyk7XG4gICAgaWYgKCF2YWx1ZXNXaXRoVHlwZSB8fCBpZCA9PT0gLTEpIHJldHVybjtcbiAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZXNXaXRoVHlwZS5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7IHR5cGU6IHR5cGUyLCAuLi5yZXN0IH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gdmFsdWVzV2l0aFR5cGVbMF07XG4gICAgdGhpcy5tdXRhdGlvbkNiKHsgaWQsIHR5cGUsIGNvbW1hbmRzOiB2YWx1ZXMgfSk7XG4gICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmRlbGV0ZShjYW52YXMpO1xuICB9XG59XG5jbGFzcyBTdHlsZXNoZWV0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHJhY2tlZExpbmtFbGVtZW50c1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkb3B0ZWRTdHlsZVNoZWV0Q2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlTWlycm9yXCIsIG5ldyBTdHlsZVNoZWV0TWlycm9yKCkpO1xuICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IgPSBvcHRpb25zLmFkb3B0ZWRTdHlsZVNoZWV0Q2I7XG4gIH1cbiAgYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKSB7XG4gICAgaWYgKFwiX2Nzc1RleHRcIiBpbiBjaGlsZFNuLmF0dHJpYnV0ZXMpXG4gICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICBhZGRzOiBbXSxcbiAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBjaGlsZFNuLmlkLFxuICAgICAgICAgICAgYXR0cmlidXRlczogY2hpbGRTbi5hdHRyaWJ1dGVzXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB0aGlzLnRyYWNrTGlua0VsZW1lbnQobGlua0VsKTtcbiAgfVxuICB0cmFja0xpbmtFbGVtZW50KGxpbmtFbCkge1xuICAgIGlmICh0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuaGFzKGxpbmtFbCkpIHJldHVybjtcbiAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuYWRkKGxpbmtFbCk7XG4gICAgdGhpcy50cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KGxpbmtFbCk7XG4gIH1cbiAgYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCkge1xuICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgYWRvcHRlZFN0eWxlU2hlZXREYXRhID0ge1xuICAgICAgaWQ6IGhvc3RJZCxcbiAgICAgIHN0eWxlSWRzOiBbXVxuICAgIH07XG4gICAgY29uc3Qgc3R5bGVzID0gW107XG4gICAgZm9yIChjb25zdCBzaGVldCBvZiBzaGVldHMpIHtcbiAgICAgIGxldCBzdHlsZUlkO1xuICAgICAgaWYgKCF0aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcbiAgICAgICAgc3R5bGVJZCA9IHRoaXMuc3R5bGVNaXJyb3IuYWRkKHNoZWV0KTtcbiAgICAgICAgc3R5bGVzLnB1c2goe1xuICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgcnVsZXM6IEFycmF5LmZyb20oc2hlZXQucnVsZXMgfHwgQ1NTUnVsZSwgKHIyLCBpbmRleDIpID0+ICh7XG4gICAgICAgICAgICBydWxlOiBzdHJpbmdpZnlSdWxlKHIyLCBzaGVldC5ocmVmKSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Ugc3R5bGVJZCA9IHRoaXMuc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XG4gICAgfVxuICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlcyA9IHN0eWxlcztcbiAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IoYWRvcHRlZFN0eWxlU2hlZXREYXRhKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0eWxlTWlycm9yLnJlc2V0KCk7XG4gICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gIH1cbiAgLy8gVE9ETzogdGFrZSBzbmFwc2hvdCBvbiBzdHlsZXNoZWV0IHJlbG9hZCBieSBhcHBseWluZyBldmVudCBsaXN0ZW5lclxuICB0cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KF9saW5rRWwpIHtcbiAgfVxufVxuY2xhc3MgUHJvY2Vzc2VkTm9kZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibm9kZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFjdGl2ZVwiLCBmYWxzZSk7XG4gIH1cbiAgaW5PdGhlckJ1ZmZlcihub2RlMiwgdGhpc0J1ZmZlcikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKTtcbiAgICByZXR1cm4gYnVmZmVycyAmJiBBcnJheS5mcm9tKGJ1ZmZlcnMpLnNvbWUoKGJ1ZmZlcikgPT4gYnVmZmVyICE9PSB0aGlzQnVmZmVyKTtcbiAgfVxuICBhZGQobm9kZTIsIGJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMubm9kZU1hcC5zZXQobm9kZTIsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKS5hZGQoYnVmZmVyKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxubGV0IHdyYXBwZWRFbWl0O1xubGV0IHRha2VGdWxsU25hcHNob3QkMTtcbmxldCBjYW52YXNNYW5hZ2VyO1xubGV0IHJlY29yZGluZyA9IGZhbHNlO1xudHJ5IHtcbiAgaWYgKEFycmF5LmZyb20oWzFdLCAoeDIpID0+IHgyICogMilbMF0gIT09IDIpIHtcbiAgICBjb25zdCBjbGVhbkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsZWFuRnJhbWUpO1xuICAgIEFycmF5LmZyb20gPSAoKF9hID0gY2xlYW5GcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuQXJyYXkuZnJvbSkgfHwgQXJyYXkuZnJvbTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsZWFuRnJhbWUpO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgY29uc29sZS5kZWJ1ZyhcIlVuYWJsZSB0byBvdmVycmlkZSBBcnJheS5mcm9tXCIsIGVycik7XG59XG5jb25zdCBtaXJyb3IgPSBjcmVhdGVNaXJyb3IkMigpO1xuZnVuY3Rpb24gcmVjb3JkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZW1pdCxcbiAgICBjaGVja291dEV2ZXJ5Tm1zLFxuICAgIGNoZWNrb3V0RXZlcnlOdGgsXG4gICAgYmxvY2tDbGFzcyA9IFwicnItYmxvY2tcIixcbiAgICBibG9ja1NlbGVjdG9yID0gbnVsbCxcbiAgICBpZ25vcmVDbGFzcyA9IFwicnItaWdub3JlXCIsXG4gICAgaWdub3JlU2VsZWN0b3IgPSBudWxsLFxuICAgIG1hc2tUZXh0Q2xhc3MgPSBcInJyLW1hc2tcIixcbiAgICBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSxcbiAgICBtYXNrQWxsSW5wdXRzLFxuICAgIG1hc2tJbnB1dE9wdGlvbnM6IF9tYXNrSW5wdXRPcHRpb25zLFxuICAgIHNsaW1ET01PcHRpb25zOiBfc2xpbURPTU9wdGlvbnMsXG4gICAgbWFza0lucHV0Rm4sXG4gICAgbWFza1RleHRGbixcbiAgICBob29rcyxcbiAgICBwYWNrRm4sXG4gICAgc2FtcGxpbmcgPSB7fSxcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIG1vdXNlbW92ZVdhaXQsXG4gICAgcmVjb3JkRE9NID0gdHJ1ZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBmYWxzZSxcbiAgICByZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiID8gb3B0aW9ucy5yZWNvcmRBZnRlciA6IFwibG9hZFwiLFxuICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsXG4gICAgY29sbGVjdEZvbnRzID0gZmFsc2UsXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcGx1Z2lucyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pLFxuICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyMlxuICB9ID0gb3B0aW9ucztcbiAgcmVnaXN0ZXJFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyMik7XG4gIGNvbnN0IGluRW1pdHRpbmdGcmFtZSA9IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdyA6IHRydWU7XG4gIGxldCBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xuICBpZiAoIWluRW1pdHRpbmdGcmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAod2luZG93LnBhcmVudC5kb2N1bWVudCkge1xuICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpbkVtaXR0aW5nRnJhbWUgJiYgIWVtaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbWl0IGZ1bmN0aW9uIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmICghaW5FbWl0dGluZ0ZyYW1lICYmICFwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBpZiAobW91c2Vtb3ZlV2FpdCAhPT0gdm9pZCAwICYmIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gdm9pZCAwKSB7XG4gICAgc2FtcGxpbmcubW91c2Vtb3ZlID0gbW91c2Vtb3ZlV2FpdDtcbiAgfVxuICBtaXJyb3IucmVzZXQoKTtcbiAgY29uc3QgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgY29sb3I6IHRydWUsXG4gICAgZGF0ZTogdHJ1ZSxcbiAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgZW1haWw6IHRydWUsXG4gICAgbW9udGg6IHRydWUsXG4gICAgbnVtYmVyOiB0cnVlLFxuICAgIHJhbmdlOiB0cnVlLFxuICAgIHNlYXJjaDogdHJ1ZSxcbiAgICB0ZWw6IHRydWUsXG4gICAgdGV4dDogdHJ1ZSxcbiAgICB0aW1lOiB0cnVlLFxuICAgIHVybDogdHJ1ZSxcbiAgICB3ZWVrOiB0cnVlLFxuICAgIHRleHRhcmVhOiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZSxcbiAgICBwYXNzd29yZDogdHJ1ZVxuICB9IDogX21hc2tJbnB1dE9wdGlvbnMgIT09IHZvaWQgMCA/IF9tYXNrSW5wdXRPcHRpb25zIDogeyBwYXNzd29yZDogdHJ1ZSB9O1xuICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIgPyB7XG4gICAgc2NyaXB0OiB0cnVlLFxuICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb2ZmIGZvciBzbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSxcbiAgICAvLyBhcyB0aGV5IGRlc3Ryb3kgc29tZSAoaGlkZGVuKSBpbmZvOlxuICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIsXG4gICAgaGVhZFRpdGxlTXV0YXRpb25zOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCJcbiAgfSA6IF9zbGltRE9NT3B0aW9ucyA/IF9zbGltRE9NT3B0aW9ucyA6IHt9O1xuICBwb2x5ZmlsbCQxKCk7XG4gIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XG4gIGxldCBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICBjb25zdCBldmVudFByb2Nlc3NvciA9IChlMikgPT4ge1xuICAgIGZvciAoY29uc3QgcGx1Z2luMyBvZiBwbHVnaW5zIHx8IFtdKSB7XG4gICAgICBpZiAocGx1Z2luMy5ldmVudFByb2Nlc3Nvcikge1xuICAgICAgICBlMiA9IHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IoZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFja0ZuICYmIC8vIERpc2FibGUgcGFja2luZyBldmVudHMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIHRvIHBhcmVudCBmcmFtZXMuXG4gICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICBlMiA9IHBhY2tGbihlMik7XG4gICAgfVxuICAgIHJldHVybiBlMjtcbiAgfTtcbiAgd3JhcHBlZEVtaXQgPSAocjIsIGlzQ2hlY2tvdXQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IGUyID0gcjI7XG4gICAgZTIudGltZXN0YW1wID0gbm93VGltZXN0YW1wKCk7XG4gICAgaWYgKCgoX2EyID0gbXV0YXRpb25CdWZmZXJzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlzRnJvemVuKCkpICYmIGUyLnR5cGUgIT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QgJiYgIShlMi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCAmJiBlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24pKSB7XG4gICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5mcmVlemUoKSk7XG4gICAgfVxuICAgIGlmIChpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICAgIGVtaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGVtaXQoZXZlbnRQcm9jZXNzb3IoZTIpLCBpc0NoZWNrb3V0KTtcbiAgICB9IGVsc2UgaWYgKHBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBcInJyd2ViXCIsXG4gICAgICAgIGV2ZW50OiBldmVudFByb2Nlc3NvcihlMiksXG4gICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgaXNDaGVja291dFxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgXCIqXCIpO1xuICAgIH1cbiAgICBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCkge1xuICAgICAgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50ID0gZTI7XG4gICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QpIHtcbiAgICAgIGlmIChlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24gJiYgZTIuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQrKztcbiAgICAgIGNvbnN0IGV4Y2VlZENvdW50ID0gY2hlY2tvdXRFdmVyeU50aCAmJiBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPj0gY2hlY2tvdXRFdmVyeU50aDtcbiAgICAgIGNvbnN0IGV4Y2VlZFRpbWUgPSBjaGVja291dEV2ZXJ5Tm1zICYmIGUyLnRpbWVzdGFtcCAtIGxhc3RGdWxsU25hcHNob3RFdmVudC50aW1lc3RhbXAgPiBjaGVja291dEV2ZXJ5Tm1zO1xuICAgICAgaWYgKGV4Y2VlZENvdW50IHx8IGV4Y2VlZFRpbWUpIHtcbiAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCQxKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd3JhcHBlZE11dGF0aW9uRW1pdCA9IChtKSA9PiB7XG4gICAgd3JhcHBlZEVtaXQoe1xuICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgIC4uLm1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgd3JhcHBlZFNjcm9sbEVtaXQgPSAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgIGRhdGE6IHtcbiAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsLFxuICAgICAgLi4ucFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQgPSAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgIGRhdGE6IHtcbiAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb24sXG4gICAgICAuLi5wXG4gICAgfVxuICB9KTtcbiAgY29uc3Qgd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCA9IChhMikgPT4gd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgIGRhdGE6IHtcbiAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQsXG4gICAgICAuLi5hMlxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgIGFkb3B0ZWRTdHlsZVNoZWV0Q2I6IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXRcbiAgfSk7XG4gIGNvbnN0IGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XG4gICAgbWlycm9yLFxuICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLFxuICAgIHdyYXBwZWRFbWl0XG4gIH0pO1xuICBmb3IgKGNvbnN0IHBsdWdpbjMgb2YgcGx1Z2lucyB8fCBbXSkge1xuICAgIGlmIChwbHVnaW4zLmdldE1pcnJvcilcbiAgICAgIHBsdWdpbjMuZ2V0TWlycm9yKHtcbiAgICAgICAgbm9kZU1pcnJvcjogbWlycm9yLFxuICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcbiAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXG4gICAgICB9KTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWROb2RlTWFuYWdlciA9IG5ldyBQcm9jZXNzZWROb2RlTWFuYWdlcigpO1xuICBjYW52YXNNYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xuICAgIHJlY29yZENhbnZhcyxcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxuICAgIHdpbjogd2luZG93LFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBtaXJyb3IsXG4gICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcbiAgICBkYXRhVVJMT3B0aW9uc1xuICB9KTtcbiAgY29uc3Qgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICBieXBhc3NPcHRpb25zOiB7XG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICBtYXNrSW5wdXRGbixcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGlubGluZUltYWdlcyxcbiAgICAgIHNhbXBsaW5nLFxuICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICBpZnJhbWVNYW5hZ2VyLFxuICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICBjYW52YXNNYW5hZ2VyLFxuICAgICAga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXJcbiAgICB9LFxuICAgIG1pcnJvclxuICB9KTtcbiAgdGFrZUZ1bGxTbmFwc2hvdCQxID0gKGlzQ2hlY2tvdXQgPSBmYWxzZSkgPT4ge1xuICAgIGlmICghcmVjb3JkRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdyYXBwZWRFbWl0KFxuICAgICAge1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuTWV0YSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGhyZWY6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxuICAgICAgICAgIGhlaWdodDogZ2V0V2luZG93SGVpZ2h0KClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzQ2hlY2tvdXRcbiAgICApO1xuICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnJlc2V0KCk7XG4gICAgc2hhZG93RG9tTWFuYWdlci5pbml0KCk7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLmxvY2soKSk7XG4gICAgY29uc3Qgbm9kZTIgPSBzbmFwc2hvdChkb2N1bWVudCwge1xuICAgICAgbWlycm9yLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgbWFza1RleHRGbixcbiAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgc2xpbURPTTogc2xpbURPTU9wdGlvbnMsXG4gICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGlubGluZUltYWdlcyxcbiAgICAgIG9uU2VyaWFsaXplOiAobjIpID0+IHtcbiAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yKSkge1xuICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChuMiwgbWlycm9yKSkge1xuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChpbmRleC5zaGFkb3dSb290KG4yKSwgZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25JZnJhbWVMb2FkOiAoaWZyYW1lLCBjaGlsZFNuKSA9PiB7XG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XG4gICAgICAgIHNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgfSxcbiAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rRWwsIGNoaWxkU24pID0+IHtcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKTtcbiAgICAgIH0sXG4gICAgICBrZWVwSWZyYW1lU3JjRm5cbiAgICB9KTtcbiAgICBpZiAoIW5vZGUyKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudFwiKTtcbiAgICB9XG4gICAgd3JhcHBlZEVtaXQoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5GdWxsU25hcHNob3QsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgICBpbml0aWFsT2Zmc2V0OiBnZXRXaW5kb3dTY3JvbGwod2luZG93KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNDaGVja291dFxuICAgICk7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVubG9jaygpKTtcbiAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxuICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhcbiAgICAgICAgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICBtaXJyb3IuZ2V0SWQoZG9jdW1lbnQpXG4gICAgICApO1xuICB9O1xuICB0cnkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XG4gICAgY29uc3Qgb2JzZXJ2ZSA9IChkb2MpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGluaXRPYnNlcnZlcnMpKFxuICAgICAgICB7XG4gICAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgICBtb3VzZW1vdmVDYjogKHBvc2l0aW9ucywgc291cmNlKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBwb3NpdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uLFxuICAgICAgICAgICAgICAuLi5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSxcbiAgICAgICAgICAgICAgLi4uZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGlucHV0Q2I6ICh2MikgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQsXG4gICAgICAgICAgICAgIC4uLnYyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiOiAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2I6IChyMikgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGUsXG4gICAgICAgICAgICAgIC4uLnIyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiAocjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgIC4uLnIyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICAgICAgICBmb250Q2I6IChwKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Gb250LFxuICAgICAgICAgICAgICAuLi5wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2VsZWN0aW9uQ2I6IChwKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogKGMyKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICAgIC4uLmMyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBpZ25vcmVDbGFzcyxcbiAgICAgICAgICBpZ25vcmVTZWxlY3RvcixcbiAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIHNhbXBsaW5nLFxuICAgICAgICAgIHJlY29yZERPTSxcbiAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0LFxuICAgICAgICAgIGNvbGxlY3RGb250cyxcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgICAgbWFza1RleHRGbixcbiAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICBtaXJyb3IsXG4gICAgICAgICAgaWZyYW1lTWFuYWdlcixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLFxuICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLFxuICAgICAgICAgIGNhbnZhc01hbmFnZXIsXG4gICAgICAgICAgaWdub3JlQ1NTQXR0cmlidXRlcyxcbiAgICAgICAgICBwbHVnaW5zOiAoKF9hMiA9IHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuZmlsdGVyKChwKSA9PiBwLm9ic2VydmVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tYXAoKHApID0+ICh7XG4gICAgICAgICAgICBvYnNlcnZlcjogcC5vYnNlcnZlcixcbiAgICAgICAgICAgIG9wdGlvbnM6IHAub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAocGF5bG9hZCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUGx1Z2luLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcGx1Z2luOiBwLm5hbWUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pKSkgfHwgW11cbiAgICAgICAgfSxcbiAgICAgICAgaG9va3NcbiAgICAgICk7XG4gICAgfTtcbiAgICBpZnJhbWVNYW5hZ2VyLmFkZExvYWRMaXN0ZW5lcigoaWZyYW1lRWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgIHRha2VGdWxsU25hcHNob3QkMSgpO1xuICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XG4gICAgICByZWNvcmRpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucHVzaChcbiAgICAgICAgb24oXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZCxcbiAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSBcIkRPTUNvbnRlbnRMb2FkZWRcIikgaW5pdCgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2goXG4gICAgICAgIG9uKFxuICAgICAgICAgIFwibG9hZFwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvYWQsXG4gICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gXCJsb2FkXCIpIGluaXQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdpbmRvd1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgIHJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgdW5yZWdpc3RlckVycm9ySGFuZGxlcigpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxufVxucmVjb3JkLmFkZEN1c3RvbUV2ZW50ID0gKHRhZywgcGF5bG9hZCkgPT4ge1xuICBpZiAoIXJlY29yZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBsZWFzZSBhZGQgY3VzdG9tIGV2ZW50IGFmdGVyIHN0YXJ0IHJlY29yZGluZ1wiKTtcbiAgfVxuICB3cmFwcGVkRW1pdCh7XG4gICAgdHlwZTogRXZlbnRUeXBlLkN1c3RvbSxcbiAgICBkYXRhOiB7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkXG4gICAgfVxuICB9KTtcbn07XG5yZWNvcmQuZnJlZXplUGFnZSA9ICgpID0+IHtcbiAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLmZyZWV6ZSgpKTtcbn07XG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdCA9IChpc0NoZWNrb3V0KSA9PiB7XG4gIGlmICghcmVjb3JkaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIHRha2UgZnVsbCBzbmFwc2hvdCBhZnRlciBzdGFydCByZWNvcmRpbmdcIik7XG4gIH1cbiAgdGFrZUZ1bGxTbmFwc2hvdCQxKGlzQ2hlY2tvdXQpO1xufTtcbnJlY29yZC5taXJyb3IgPSBtaXJyb3I7XG52YXIgbjtcbiFmdW5jdGlvbih0Mikge1xuICB0Mlt0Mi5Ob3RTdGFydGVkID0gMF0gPSBcIk5vdFN0YXJ0ZWRcIiwgdDJbdDIuUnVubmluZyA9IDFdID0gXCJSdW5uaW5nXCIsIHQyW3QyLlN0b3BwZWQgPSAyXSA9IFwiU3RvcHBlZFwiO1xufShuIHx8IChuID0ge30pKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb3JkLmpzLm1hcFxuXG47Ly8gLi9ub2RlX21vZHVsZXMvQHJyd2ViL3R5cGVzL2Rpc3QvdHlwZXMuanNcbnZhciB0eXBlc19FdmVudFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFdmVudFR5cGUyKSA9PiB7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRnVsbFNuYXBzaG90XCJdID0gMl0gPSBcIkZ1bGxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkN1c3RvbVwiXSA9IDVdID0gXCJDdXN0b21cIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xuICByZXR1cm4gRXZlbnRUeXBlMjtcbn0pKHR5cGVzX0V2ZW50VHlwZSB8fCB7fSk7XG52YXIgdHlwZXNfSW5jcmVtZW50YWxTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KSh0eXBlc19JbmNyZW1lbnRhbFNvdXJjZSB8fCB7fSk7XG52YXIgdHlwZXNfTW91c2VJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChNb3VzZUludGVyYWN0aW9uczIpID0+IHtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlVXBcIl0gPSAwXSA9IFwiTW91c2VVcFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VEb3duXCJdID0gMV0gPSBcIk1vdXNlRG93blwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNvbnRleHRNZW51XCJdID0gM10gPSBcIkNvbnRleHRNZW51XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJEYmxDbGlja1wiXSA9IDRdID0gXCJEYmxDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkJsdXJcIl0gPSA2XSA9IFwiQmx1clwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hTdGFydFwiXSA9IDddID0gXCJUb3VjaFN0YXJ0XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaEVuZFwiXSA9IDldID0gXCJUb3VjaEVuZFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hDYW5jZWxcIl0gPSAxMF0gPSBcIlRvdWNoQ2FuY2VsXCI7XG4gIHJldHVybiBNb3VzZUludGVyYWN0aW9uczI7XG59KSh0eXBlc19Nb3VzZUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgdHlwZXNfUG9pbnRlclR5cGVzID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlclR5cGVzMikgPT4ge1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJNb3VzZVwiXSA9IDBdID0gXCJNb3VzZVwiO1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJQZW5cIl0gPSAxXSA9IFwiUGVuXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlRvdWNoXCJdID0gMl0gPSBcIlRvdWNoXCI7XG4gIHJldHVybiBQb2ludGVyVHlwZXMyO1xufSkodHlwZXNfUG9pbnRlclR5cGVzIHx8IHt9KTtcbnZhciB0eXBlc19DYW52YXNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovICgoQ2FudmFzQ29udGV4dDIpID0+IHtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCIyRFwiXSA9IDBdID0gXCIyRFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0wyXCJdID0gMl0gPSBcIldlYkdMMlwiO1xuICByZXR1cm4gQ2FudmFzQ29udGV4dDI7XG59KSh0eXBlc19DYW52YXNDb250ZXh0IHx8IHt9KTtcbnZhciB0eXBlc19NZWRpYUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1lZGlhSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGxheVwiXSA9IDBdID0gXCJQbGF5XCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQYXVzZVwiXSA9IDFdID0gXCJQYXVzZVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiU2Vla2VkXCJdID0gMl0gPSBcIlNlZWtlZFwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiVm9sdW1lQ2hhbmdlXCJdID0gM10gPSBcIlZvbHVtZUNoYW5nZVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUmF0ZUNoYW5nZVwiXSA9IDRdID0gXCJSYXRlQ2hhbmdlXCI7XG4gIHJldHVybiBNZWRpYUludGVyYWN0aW9uczI7XG59KSh0eXBlc19NZWRpYUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgUmVwbGF5ZXJFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gKChSZXBsYXllckV2ZW50czIpID0+IHtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiU3RhcnRcIl0gPSBcInN0YXJ0XCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIlBhdXNlXCJdID0gXCJwYXVzZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJSZXN1bWVcIl0gPSBcInJlc3VtZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJSZXNpemVcIl0gPSBcInJlc2l6ZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJGaW5pc2hcIl0gPSBcImZpbmlzaFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJGdWxsc25hcHNob3RSZWJ1aWxkZWRcIl0gPSBcImZ1bGxzbmFwc2hvdC1yZWJ1aWxkZWRcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiTG9hZFN0eWxlc2hlZXRTdGFydFwiXSA9IFwibG9hZC1zdHlsZXNoZWV0LXN0YXJ0XCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIkxvYWRTdHlsZXNoZWV0RW5kXCJdID0gXCJsb2FkLXN0eWxlc2hlZXQtZW5kXCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIlNraXBTdGFydFwiXSA9IFwic2tpcC1zdGFydFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJTa2lwRW5kXCJdID0gXCJza2lwLWVuZFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gXCJtb3VzZS1pbnRlcmFjdGlvblwiO1xuICBSZXBsYXllckV2ZW50czJbXCJFdmVudENhc3RcIl0gPSBcImV2ZW50LWNhc3RcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiQ3VzdG9tRXZlbnRcIl0gPSBcImN1c3RvbS1ldmVudFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJGbHVzaFwiXSA9IFwiZmx1c2hcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiU3RhdGVDaGFuZ2VcIl0gPSBcInN0YXRlLWNoYW5nZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJQbGF5QmFja1wiXSA9IFwicGxheS1iYWNrXCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIkRlc3Ryb3lcIl0gPSBcImRlc3Ryb3lcIjtcbiAgcmV0dXJuIFJlcGxheWVyRXZlbnRzMjtcbn0pKFJlcGxheWVyRXZlbnRzIHx8IHt9KTtcbnZhciB0eXBlc19Ob2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5vZGVUeXBlMikgPT4ge1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gIHJldHVybiBOb2RlVHlwZTI7XG59KSh0eXBlc19Ob2RlVHlwZSB8fCB7fSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcFxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3RyYWNpbmcvaHJ0aW1lLmpzXG52YXIgaHJ0aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbjsvLyAuL3NyYy9icm93c2VyL3JlcGxheS9yZWNvcmRlci5qc1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUgJiYgciAmJiBcIm51bWJlclwiID09IHR5cGVvZiByLmxlbmd0aCkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoZSwgdCwgYSkgeyBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSwgdC5zZXQoZSwgYSk7IH1cbmZ1bmN0aW9uIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpIHsgaWYgKHQuaGFzKGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgdGhlIHNhbWUgcHJpdmF0ZSBlbGVtZW50cyB0d2ljZSBvbiBhbiBvYmplY3RcIik7IH1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldChzLCBhKSB7IHJldHVybiBzLmdldChfYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSk7IH1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZFNldChzLCBhLCByKSB7IHJldHVybiBzLnNldChfYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSwgciksIHI7IH1cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzc0JyYW5kKGUsIHQsIG4pIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPT09IHQgOiBlLmhhcyh0KSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdCA6IG47IHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgb24gdGhpcyBvYmplY3RcIik7IH1cblxuXG5cbnZhciBfb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9zdG9wRm4gPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfcmVjb3JkRm4gPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfZXZlbnRzID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgUmVjb3JkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSZWNvcmRlciBpbnN0YW5jZSBmb3IgY2FwdHVyaW5nIERPTSBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSByZWNvcmRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVjb3JkRm49cnJ3ZWJSZWNvcmRGbl0gLSBUaGUgcmVjb3JkaW5nIGZ1bmN0aW9uIHRvIHVzZVxuICAgKi9cbiAgZnVuY3Rpb24gUmVjb3JkZXIob3B0aW9ucykge1xuICAgIHZhciByZWNvcmRGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcmVjb3JkO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWNvcmRlcik7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX29wdGlvbnMsIHZvaWQgMCk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX3N0b3BGbiwgbnVsbCk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX3JlY29yZEZuLCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9ldmVudHMsIHtcbiAgICAgIHByZXZpb3VzOiBbXSxcbiAgICAgIGN1cnJlbnQ6IFtdXG4gICAgfSk7XG4gICAgaWYgKCFyZWNvcmRGbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdyZWNvcmRGbicgdG8gYmUgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlcjogSW5pdGlhbGl6aW5nLi4uJyk7XG4gICAgY29uc29sZS5sb2coJ29wdGlvbnMnLCBvcHRpb25zKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX29wdGlvbnMsIHRoaXMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX3JlY29yZEZuLCB0aGlzLCByZWNvcmRGbik7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZWNvcmRlciwgW3tcbiAgICBrZXk6IFwiaXNSZWNvcmRpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY2xhc3NQcml2YXRlRmllbGRHZXQoX3N0b3BGbiwgdGhpcykgIT09IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY2xhc3NQcml2YXRlRmllbGRHZXQoX29wdGlvbnMsIHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3T3B0aW9ucykge1xuICAgICAgdGhpcy5jb25maWd1cmUobmV3T3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ3VyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmUobmV3T3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcgJiYgbmV3T3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfb3B0aW9ucywgdGhpcywgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcmVjb3JkZWQgZXZlbnRzIGludG8gYSBmb3JtYXR0ZWQgcGF5bG9hZCByZWFkeSBmb3IgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgdGhlIHJlY29yZGVyJ3Mgc3RvcmVkIGV2ZW50cywgY3JlYXRlcyBhIG5ldyBzcGFuIHdpdGggdGhlXG4gICAgICogcHJvdmlkZWQgdHJhY2luZyBjb250ZXh0LCBhdHRhY2hlcyBhbGwgZXZlbnRzIHdpdGggdGhlaXIgdGltZXN0YW1wcyBhcyBzcGFuXG4gICAgICogZXZlbnRzLCBhbmQgdGhlbiByZXR1cm5zIGEgcGF5bG9hZCByZWFkeSBmb3IgdHJhbnNwb3J0IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhY2luZyAtIFRoZSB0cmFjaW5nIHN5c3RlbSBpbnN0YW5jZSB0byBjcmVhdGUgc3BhbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBVbmlxdWUgaWRlbnRpZmllciB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIHJlcGxheSByZWNvcmRpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IEEgZm9ybWF0dGVkIHBheWxvYWQgY29udGFpbmluZyBzcGFucyBkYXRhIGluIE9UTFAgZm9ybWF0LCBvciBudWxsIGlmIG5vIGV2ZW50cyBleGlzdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImR1bXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVtcCh0cmFjaW5nLCByZXBsYXlJZCwgb2NjdXJyZW5jZVV1aWQpIHtcbiAgICAgIHZhciBldmVudHMgPSBfY2xhc3NQcml2YXRlRmllbGRHZXQoX2V2ZW50cywgdGhpcykucHJldmlvdXMuY29uY2F0KF9jbGFzc1ByaXZhdGVGaWVsZEdldChfZXZlbnRzLCB0aGlzKS5jdXJyZW50KTtcbiAgICAgIGlmIChldmVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJSZWNvcmRlci5kdW1wOiBNaW4gMiBldmVudHMgcmVxLiBGb3VuZCBcIi5jb25jYXQoZXZlbnRzLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKFwiUmVjb3JkZXIuZHVtcDogRHVtcGluZyBcIi5jb25jYXQoZXZlbnRzLmxlbmd0aCwgXCIgZXZlbnRzXCIpKTtcbiAgICAgIHZhciByZWNvcmRpbmdTcGFuID0gdHJhY2luZy5zdGFydFNwYW4oJ3Jyd2ViLXJlcGxheS1yZWNvcmRpbmcnLCB7fSk7XG4gICAgICByZWNvcmRpbmdTcGFuLnNldEF0dHJpYnV0ZSgncm9sbGJhci5yZXBsYXkuaWQnLCByZXBsYXlJZCk7XG4gICAgICBpZiAob2NjdXJyZW5jZVV1aWQpIHtcbiAgICAgICAgcmVjb3JkaW5nU3Bhbi5zZXRBdHRyaWJ1dGUoJ3JvbGxiYXIub2NjdXJyZW5jZS51dWlkJywgb2NjdXJyZW5jZVV1aWQpO1xuICAgICAgfVxuICAgICAgdmFyIGVhcmxpZXN0RXZlbnQgPSBldmVudHMucmVkdWNlKGZ1bmN0aW9uIChlYXJsaWVzdEV2ZW50LCBldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQudGltZXN0YW1wIDwgZWFybGllc3RFdmVudC50aW1lc3RhbXAgPyBldmVudCA6IGVhcmxpZXN0RXZlbnQ7XG4gICAgICB9KTtcbiAgICAgIHJlY29yZGluZ1NwYW4uc3Bhbi5zdGFydFRpbWUgPSBocnRpbWUvKiBkZWZhdWx0ICovLkEuZnJvbU1pbGxpcyhlYXJsaWVzdEV2ZW50LnRpbWVzdGFtcCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZXZlbnRzKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBldmVudCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHJlY29yZGluZ1NwYW4uYWRkRXZlbnQoJ3Jyd2ViLXJlcGxheS1ldmVudHMnLCB7XG4gICAgICAgICAgICBldmVudFR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICBqc29uOiBKU09OLnN0cmluZ2lmeShldmVudC5kYXRhKSxcbiAgICAgICAgICAgICdyb2xsYmFyLnJlcGxheS5pZCc6IHJlcGxheUlkXG4gICAgICAgICAgfSwgaHJ0aW1lLyogZGVmYXVsdCAqLy5BLmZyb21NaWxsaXMoZXZlbnQudGltZXN0YW1wKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZGluZ1NwYW4uZW5kKCk7XG4gICAgICByZXR1cm4gdHJhY2luZy5leHBvcnRlci50b1BheWxvYWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcgfHwgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVjb3JkaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBBbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IERpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBTdGFydGluZy4uLicpO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KF9zdG9wRm4sIHRoaXMsIF9jbGFzc1ByaXZhdGVGaWVsZEdldChfcmVjb3JkRm4sIHRoaXMpLmNhbGwodGhpcywgX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGlzQ2hlY2tvdXQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkb3B0aW9ucyRkZWJ1ZztcbiAgICAgICAgICBpZiAoKF90aGlzJG9wdGlvbnMkZGVidWcgPSBfdGhpcy5vcHRpb25zLmRlYnVnKSAhPT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zJGRlYnVnICE9PSB2b2lkIDAgJiYgX3RoaXMkb3B0aW9ucyRkZWJ1Zy5sb2dFbWl0cykge1xuICAgICAgICAgICAgX3RoaXMuX2xvZ0V2ZW50KGV2ZW50LCBpc0NoZWNrb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ2hlY2tvdXQgJiYgZXZlbnQudHlwZSA9PT0gdHlwZXNfRXZlbnRUeXBlLk1ldGEpIHtcbiAgICAgICAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldChfZXZlbnRzLCBfdGhpcykucHJldmlvdXMgPSBfY2xhc3NQcml2YXRlRmllbGRHZXQoX2V2ZW50cywgX3RoaXMpLmN1cnJlbnQ7XG4gICAgICAgICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQoX2V2ZW50cywgX3RoaXMpLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9ldmVudHMsIF90aGlzKS5jdXJyZW50LnB1c2goZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja291dEV2ZXJ5Tm1zOiA1ICogNjAgKiAxMDAwXG4gICAgICB9LCB0aGlzLm9wdGlvbnMpKSk7XG4gICAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IFN0YXJ0ZWQnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBBbHJlYWR5IHN0b3BwZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBTdG9wcGluZy4uLicpO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9zdG9wRm4sIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX3N0b3BGbiwgdGhpcywgbnVsbCk7XG4gICAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IFN0b3BwZWQnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfZXZlbnRzLCB0aGlzLCB7XG4gICAgICAgIHByZXZpb3VzOiBbXSxcbiAgICAgICAgY3VycmVudDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbG9nRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ0V2ZW50KGV2ZW50LCBpc0NoZWNrb3V0KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlY29yZGVyOiBcIi5jb25jYXQoaXNDaGVja291dCA/ICdjaGVja291dCcgOiAnJywgXCIgZXZlbnRcXG5cIiksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBzZWVuID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGUsIGZ1bmN0aW9uIChfLCB2KSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YodikgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2KSkgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgICAgIHNlZW4uYWRkKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSwgMik7XG4gICAgICB9KGV2ZW50KSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyMjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcbnZhciB0cmF2ZXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xuZnVuY3Rpb24gc2NydWIoZGF0YSwgc2NydWJGaWVsZHMsIHNjcnViUGF0aHMpIHtcbiAgc2NydWJGaWVsZHMgPSBzY3J1YkZpZWxkcyB8fCBbXTtcbiAgaWYgKHNjcnViUGF0aHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViUGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNjcnViUGF0aChkYXRhLCBzY3J1YlBhdGhzW2ldKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmFtUmVzID0gX2dldFNjcnViRmllbGRSZWdleHMoc2NydWJGaWVsZHMpO1xuICB2YXIgcXVlcnlSZXMgPSBfZ2V0U2NydWJRdWVyeVBhcmFtUmVnZXhzKHNjcnViRmllbGRzKTtcbiAgZnVuY3Rpb24gcmVkYWN0UXVlcnlQYXJhbShkdW1teTAsIHBhcmFtUGFydCkge1xuICAgIHJldHVybiBwYXJhbVBhcnQgKyBfLnJlZGFjdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcmFtU2NydWJiZXIodikge1xuICAgIHZhciBpO1xuICAgIGlmIChfLmlzVHlwZSh2LCAnc3RyaW5nJykpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBxdWVyeVJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2ID0gdi5yZXBsYWNlKHF1ZXJ5UmVzW2ldLCByZWRhY3RRdWVyeVBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgZnVuY3Rpb24gdmFsU2NydWJiZXIoaywgdikge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbVJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHBhcmFtUmVzW2ldLnRlc3QoaykpIHtcbiAgICAgICAgdiA9IF8ucmVkYWN0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBmdW5jdGlvbiBzY3J1YmJlcihrLCB2LCBzZWVuKSB7XG4gICAgdmFyIHRtcFYgPSB2YWxTY3J1YmJlcihrLCB2KTtcbiAgICBpZiAodG1wViA9PT0gdikge1xuICAgICAgaWYgKF8uaXNUeXBlKHYsICdvYmplY3QnKSB8fCBfLmlzVHlwZSh2LCAnYXJyYXknKSkge1xuICAgICAgICByZXR1cm4gdHJhdmVyc2Uodiwgc2NydWJiZXIsIHNlZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtU2NydWJiZXIodG1wVik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0bXBWO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhdmVyc2UoZGF0YSwgc2NydWJiZXIpO1xufVxuZnVuY3Rpb24gc2NydWJQYXRoKG9iaiwgcGF0aCkge1xuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIGxhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGFzdDsgKytpKSB7XG4gICAgICBpZiAoaSA8IGxhc3QpIHtcbiAgICAgICAgb2JqID0gb2JqW2tleXNbaV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleXNbaV1dID0gXy5yZWRhY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBNaXNzaW5nIGtleSBpcyBPSztcbiAgfVxufVxuZnVuY3Rpb24gX2dldFNjcnViRmllbGRSZWdleHMoc2NydWJGaWVsZHMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgcGF0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgcGF0ID0gJ15cXFxcWz8oJTVbYkJdKT8nICsgc2NydWJGaWVsZHNbaV0gKyAnXFxcXFs/KCU1W2JCXSk/XFxcXF0/KCU1W2REXSk/JCc7XG4gICAgcmV0LnB1c2gobmV3IFJlZ0V4cChwYXQsICdpJykpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBfZ2V0U2NydWJRdWVyeVBhcmFtUmVnZXhzKHNjcnViRmllbGRzKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIHBhdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3J1YkZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgIHBhdCA9ICdcXFxcWz8oJTVbYkJdKT8nICsgc2NydWJGaWVsZHNbaV0gKyAnXFxcXFs/KCU1W2JCXSk/XFxcXF0/KCU1W2REXSk/JztcbiAgICByZXQucHVzaChuZXcgUmVnRXhwKCcoJyArIHBhdCArICc9KShbXiZcXFxcbl0rKScsICdpZ20nKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbm1vZHVsZS5leHBvcnRzID0gc2NydWI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Mzk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4NSk7XG5cbi8qXG4gKiBOb3RpZmllciAtIHRoZSBpbnRlcm5hbCBvYmplY3QgcmVzcG9uc2libGUgZm9yIGRlbGVnYXRpbmcgYmV0d2VlbiB0aGUgY2xpZW50IGV4cG9zZWQgQVBJLCB0aGVcbiAqIGNoYWluIG9mIHRyYW5zZm9ybXMgbmVjZXNzYXJ5IHRvIHR1cm4gYW4gaXRlbSBpbnRvIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBzZW50IHRvIFJvbGxiYXIsIGFuZCB0aGVcbiAqIHF1ZXVlIHdoaWNoIGhhbmRsZXMgdGhlIGNvbW11bmNhdGlvbiB3aXRoIHRoZSBSb2xsYmFyIEFQSSBzZXJ2ZXJzLlxuICpcbiAqIEBwYXJhbSBxdWV1ZSAtIGFuIG9iamVjdCB0aGF0IGNvbmZvcm1zIHRvIHRoZSBpbnRlcmZhY2U6IGFkZEl0ZW0oaXRlbSwgY2FsbGJhY2spXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG9wdGlvbnMgdG8gYmUgc2V0IGZvciB0aGlzIG5vdGlmaWVyLCB0aGlzIHNob3VsZCBoYXZlXG4gKiBhbnkgZGVmYXVsdHMgYWxyZWFkeSBzZXQgYnkgdGhlIGNhbGxlclxuICovXG5mdW5jdGlvbiBOb3RpZmllcihxdWV1ZSwgb3B0aW9ucykge1xuICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLmRpYWdub3N0aWMgPSB7fTtcbn1cblxuLypcbiAqIGNvbmZpZ3VyZSAtIHVwZGF0ZXMgdGhlIG9wdGlvbnMgZm9yIHRoaXMgbm90aWZpZXIgd2l0aCB0aGUgcGFzc2VkIGluIG9iamVjdFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gYW4gb2JqZWN0IHdoaWNoIGdldHMgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgb3B0aW9ucyBzZXQgb24gdGhpcyBub3RpZmllclxuICogQHJldHVybnMgdGhpc1xuICovXG5Ob3RpZmllci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdGhpcy5xdWV1ZSAmJiB0aGlzLnF1ZXVlLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob2xkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIGFkZFRyYW5zZm9ybSAtIGFkZHMgYSB0cmFuc2Zvcm0gb250byB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBvZiB0cmFuc2Zvcm1zIGZvciB0aGlzIG5vdGlmaWVyXG4gKlxuICogQHBhcmFtIHRyYW5zZm9ybSAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhyZWUgYXJndW1lbnRzOlxuICogICAgKiBpdGVtOiBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIHRvIGV2ZW50dWFsbHkgYmUgc2VudCB0byBSb2xsYmFyXG4gKiAgICAqIG9wdGlvbnM6IFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBvcHRpb25zIGZvciB0aGlzIG5vdGlmaWVyXG4gKiAgICAqIGNhbGxiYWNrOiBmdW5jdGlvbihlcnI6IChOdWxsfEVycm9yKSwgaXRlbTogKE51bGx8T2JqZWN0KSkgdGhlIHRyYW5zZm9ybSBtdXN0IGNhbGwgdGhpc1xuICogICAgY2FsbGJhY2sgd2l0aCBhIG51bGwgdmFsdWUgZm9yIGVycm9yIGlmIGl0IHdhbnRzIHRoZSBwcm9jZXNzaW5nIGNoYWluIHRvIGNvbnRpbnVlLCBvdGhlcndpc2VcbiAqICAgIHdpdGggYW4gZXJyb3IgdG8gdGVybWluYXRlIHRoZSBwcm9jZXNzaW5nLiBUaGUgaXRlbSBzaG91bGQgYmUgdGhlIHVwZGF0ZWQgaXRlbSBhZnRlciB0aGlzXG4gKiAgICB0cmFuc2Zvcm0gaXMgZmluaXNoZWQgbW9kaWZ5aW5nIGl0LlxuICovXG5Ob3RpZmllci5wcm90b3R5cGUuYWRkVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICBpZiAoXy5pc0Z1bmN0aW9uKHRyYW5zZm9ybSkpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIGxvZyAtIHRoZSBpbnRlcm5hbCBsb2cgZnVuY3Rpb24gd2hpY2ggYXBwbGllcyB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm1zIGFuZCB0aGVuIHB1c2hlcyBvbnRvIHRoZVxuICogcXVldWUgdG8gYmUgc2VudCB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICogICAgbWVzc2FnZSBbU3RyaW5nXSAtIEFuIG9wdGlvbmFsIHN0cmluZyB0byBiZSBzZW50IHRvIHJvbGxiYXJcbiAqICAgIGVycm9yIFtFcnJvcl0gLSBBbiBvcHRpb25hbCBlcnJvclxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gb2YgdHlwZSBmdW5jdGlvbihlcnIsIHJlc3ApIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggZXhhY3RseSBvbmVcbiAqIG51bGwgYXJndW1lbnQgYW5kIG9uZSBub24tbnVsbCBhcmd1bWVudC4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uY2UsIGVpdGhlciBkdXJpbmcgdGhlXG4gKiB0cmFuc2Zvcm0gc3RhZ2UgaWYgYW4gZXJyb3Igb2NjdXJzIGluc2lkZSBhIHRyYW5zZm9ybSwgb3IgaW4gcmVzcG9uc2UgdG8gdGhlIGNvbW11bmljYXRpb24gd2l0aFxuICogdGhlIGJhY2tlbmQuIFRoZSBzZWNvbmQgYXJndW1lbnQgd2lsbCBiZSB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgYmFja2VuZCBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayB8fCAhXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7fTtcbiAgfVxuICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignUm9sbGJhciBpcyBub3QgZW5hYmxlZCcpKTtcbiAgfVxuICB0aGlzLnF1ZXVlLmFkZFBlbmRpbmdJdGVtKGl0ZW0pO1xuICB2YXIgb3JpZ2luYWxFcnJvciA9IGl0ZW0uZXJyO1xuICB0aGlzLl9hcHBseVRyYW5zZm9ybXMoaXRlbSwgZnVuY3Rpb24gKGVyciwgaSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMucXVldWUucmVtb3ZlUGVuZGluZ0l0ZW0oaXRlbSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZS5hZGRJdGVtKGksIGNhbGxiYWNrLCBvcmlnaW5hbEVycm9yLCBpdGVtKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qIEludGVybmFsICovXG5cbi8qXG4gKiBfYXBwbHlUcmFuc2Zvcm1zIC0gQXBwbGllcyB0aGUgdHJhbnNmb3JtcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIG5vdGlmaWVyIHNlcXVlbnRpYWxseS4gU2VlXG4gKiBgYWRkVHJhbnNmb3JtYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIEFuIGl0ZW0gdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gb2YgdHlwZSBmdW5jdGlvbihlcnIsIGl0ZW0pIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBub24tbnVsbFxuICogZXJyb3IgYW5kIGEgbnVsbCBpdGVtIGluIHRoZSBjYXNlIG9mIGEgdHJhbnNmb3JtIGZhaWx1cmUsIG9yIGEgbnVsbCBlcnJvciBhbmQgbm9uLW51bGwgaXRlbSBhZnRlclxuICogYWxsIHRyYW5zZm9ybXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5fYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuc2Zvcm1JbmRleCA9IC0xO1xuICB2YXIgdHJhbnNmb3Jtc0xlbmd0aCA9IHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7XG4gIHZhciB0cmFuc2Zvcm1zID0gdGhpcy50cmFuc2Zvcm1zO1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIF9jYiA9IGZ1bmN0aW9uIGNiKGVyciwgaSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYW5zZm9ybUluZGV4Kys7XG4gICAgaWYgKHRyYW5zZm9ybUluZGV4ID09PSB0cmFuc2Zvcm1zTGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNmb3Jtc1t0cmFuc2Zvcm1JbmRleF0oaSwgb3B0aW9ucywgX2NiKTtcbiAgfTtcbiAgX2NiKG51bGwsIGl0ZW0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm90aWZpZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFJhdGVMaW1pdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEpO1xudmFyIFF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgTm90aWZpZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzOSk7XG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTg1KTtcblxuLypcbiAqIFJvbGxiYXIgLSB0aGUgaW50ZXJmYWNlIHRvIFJvbGxiYXJcbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGFwaVxuICogQHBhcmFtIGxvZ2dlclxuICovXG5mdW5jdGlvbiBSb2xsYmFyKG9wdGlvbnMsIGFwaSwgbG9nZ2VyLCB0ZWxlbWV0ZXIsIHRyYWNpbmcsIHJlcGxheU1hcCwgcGxhdGZvcm0pIHtcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvcHRpb25zKTtcbiAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIFJvbGxiYXIucmF0ZUxpbWl0ZXIuY29uZmlndXJlR2xvYmFsKHRoaXMub3B0aW9ucyk7XG4gIFJvbGxiYXIucmF0ZUxpbWl0ZXIuc2V0UGxhdGZvcm1PcHRpb25zKHBsYXRmb3JtLCB0aGlzLm9wdGlvbnMpO1xuICB0aGlzLmFwaSA9IGFwaTtcbiAgdGhpcy5xdWV1ZSA9IG5ldyBRdWV1ZShSb2xsYmFyLnJhdGVMaW1pdGVyLCBhcGksIGxvZ2dlciwgdGhpcy5vcHRpb25zLCByZXBsYXlNYXApO1xuICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuXG4gIC8vIExlZ2FjeSBPcGVuVHJhY2luZyBzdXBwb3J0XG4gIC8vIFRoaXMgbXVzdCBoYXBwZW4gYmVmb3JlIHRoZSBOb3RpZmllciBpcyBjcmVhdGVkXG4gIHZhciB0cmFjZXIgPSB0aGlzLm9wdGlvbnMudHJhY2VyIHx8IG51bGw7XG4gIGlmICh2YWxpZGF0ZVRyYWNlcih0cmFjZXIpKSB7XG4gICAgdGhpcy50cmFjZXIgPSB0cmFjZXI7XG4gICAgLy8gc2V0IHRvIGEgc3RyaW5nIGZvciBhcGkgcmVzcG9uc2Ugc2VyaWFsaXphdGlvblxuICAgIHRoaXMub3B0aW9ucy50cmFjZXIgPSAnb3BlbnRyYWNpbmctdHJhY2VyLWVuYWJsZWQnO1xuICAgIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMudHJhY2VyID0gJ29wZW50cmFjaW5nLXRyYWNlci1lbmFibGVkJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYWNlciA9IG51bGw7XG4gIH1cbiAgdGhpcy5ub3RpZmllciA9IG5ldyBOb3RpZmllcih0aGlzLnF1ZXVlLCB0aGlzLm9wdGlvbnMpO1xuICB0aGlzLnRlbGVtZXRlciA9IHRlbGVtZXRlcjtcbiAgc2V0U3RhY2tUcmFjZUxpbWl0KG9wdGlvbnMpO1xuICB0aGlzLmxhc3RFcnJvciA9IG51bGw7XG4gIHRoaXMubGFzdEVycm9ySGFzaCA9ICdub25lJztcbn1cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbWF4SXRlbXM6IDAsXG4gIGl0ZW1zUGVyTWludXRlOiA2MFxufTtcblJvbGxiYXIucmF0ZUxpbWl0ZXIgPSBuZXcgUmF0ZUxpbWl0ZXIoZGVmYXVsdE9wdGlvbnMpO1xuUm9sbGJhci5wcm90b3R5cGUuZ2xvYmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgUm9sbGJhci5yYXRlTGltaXRlci5jb25maWd1cmVHbG9iYWwob3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblJvbGxiYXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXlsb2FkRGF0YSkge1xuICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIHBheWxvYWQgPSB7fTtcbiAgaWYgKHBheWxvYWREYXRhKSB7XG4gICAgcGF5bG9hZCA9IHtcbiAgICAgIHBheWxvYWQ6IHBheWxvYWREYXRhXG4gICAgfTtcbiAgfVxuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9sZE9wdGlvbnMsIG9wdGlvbnMsIHBheWxvYWQpO1xuXG4gIC8vIExlZ2FjeSBPcGVuVHJhY2luZyBzdXBwb3J0XG4gIC8vIFRoaXMgbXVzdCBoYXBwZW4gYmVmb3JlIHRoZSBOb3RpZmllciBpcyBjb25maWd1cmVkXG4gIHZhciB0cmFjZXIgPSB0aGlzLm9wdGlvbnMudHJhY2VyIHx8IG51bGw7XG4gIGlmICh2YWxpZGF0ZVRyYWNlcih0cmFjZXIpKSB7XG4gICAgdGhpcy50cmFjZXIgPSB0cmFjZXI7XG4gICAgLy8gc2V0IHRvIGEgc3RyaW5nIGZvciBhcGkgcmVzcG9uc2Ugc2VyaWFsaXphdGlvblxuICAgIHRoaXMub3B0aW9ucy50cmFjZXIgPSAnb3BlbnRyYWNpbmctdHJhY2VyLWVuYWJsZWQnO1xuICAgIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMudHJhY2VyID0gJ29wZW50cmFjaW5nLXRyYWNlci1lbmFibGVkJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYWNlciA9IG51bGw7XG4gIH1cbiAgdGhpcy5ub3RpZmllciAmJiB0aGlzLm5vdGlmaWVyLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMpO1xuICB0aGlzLnRlbGVtZXRlciAmJiB0aGlzLnRlbGVtZXRlci5jb25maWd1cmUodGhpcy5vcHRpb25zKTtcbiAgc2V0U3RhY2tUcmFjZUxpbWl0KG9wdGlvbnMpO1xuICB0aGlzLmdsb2JhbCh0aGlzLm9wdGlvbnMpO1xuICBpZiAodmFsaWRhdGVUcmFjZXIob3B0aW9ucy50cmFjZXIpKSB7XG4gICAgdGhpcy50cmFjZXIgPSBvcHRpb25zLnRyYWNlcjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9kZWZhdWx0TG9nTGV2ZWwoKTtcbiAgcmV0dXJuIHRoaXMuX2xvZyhsZXZlbCwgaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ2RlYnVnJywgaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHRoaXMuX2xvZygnaW5mbycsIGl0ZW0pO1xufTtcblJvbGxiYXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ3dhcm5pbmcnLCBpdGVtKTtcbn07XG5Sb2xsYmFyLnByb3RvdHlwZS53YXJuaW5nID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdGhpcy5fbG9nKCd3YXJuaW5nJywgaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ2Vycm9yJywgaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuY3JpdGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ2NyaXRpY2FsJywgaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUud2FpdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnF1ZXVlLndhaXQoY2FsbGJhY2spO1xufTtcblJvbGxiYXIucHJvdG90eXBlLmNhcHR1cmVFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwpIHtcbiAgcmV0dXJuIHRoaXMudGVsZW1ldGVyICYmIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVFdmVudCh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwpO1xufTtcblJvbGxiYXIucHJvdG90eXBlLmNhcHR1cmVEb21Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKHRzKSB7XG4gIHJldHVybiB0aGlzLnRlbGVtZXRlciAmJiB0aGlzLnRlbGVtZXRlci5jYXB0dXJlRG9tQ29udGVudExvYWRlZCh0cyk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuY2FwdHVyZUxvYWQgPSBmdW5jdGlvbiAodHMpIHtcbiAgcmV0dXJuIHRoaXMudGVsZW1ldGVyICYmIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVMb2FkKHRzKTtcbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5idWlsZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgcmV0dXJuIHRoaXMuYXBpLmJ1aWxkSnNvblBheWxvYWQoaXRlbSk7XG59O1xuUm9sbGJhci5wcm90b3R5cGUuc2VuZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKGpzb25QYXlsb2FkKSB7XG4gIHRoaXMuYXBpLnBvc3RKc29uUGF5bG9hZChqc29uUGF5bG9hZCk7XG59O1xuXG4vKiBJbnRlcm5hbCAqL1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKGRlZmF1bHRMZXZlbCwgaXRlbSkge1xuICB2YXIgY2FsbGJhY2s7XG4gIGlmIChpdGVtLmNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBpdGVtLmNhbGxiYWNrO1xuICAgIGRlbGV0ZSBpdGVtLmNhbGxiYWNrO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlRHVwbGljYXRlRXJyb3JzICYmIHRoaXMuX3NhbWVBc0xhc3RFcnJvcihpdGVtKSkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdpZ25vcmVkIGlkZW50aWNhbCBpdGVtJyk7XG4gICAgICBlcnJvci5pdGVtID0gaXRlbTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgdGhpcy5fYWRkVHJhY2luZ0F0dHJpYnV0ZXMoaXRlbSk7XG5cbiAgICAvLyBMZWdhY3kgT3BlblRyYWNpbmcgc3VwcG9ydFxuICAgIHRoaXMuX2FkZFRyYWNpbmdJbmZvKGl0ZW0pO1xuICAgIGl0ZW0ubGV2ZWwgPSBpdGVtLmxldmVsIHx8IGRlZmF1bHRMZXZlbDtcbiAgICB2YXIgdGVsZW1ldGVyID0gdGhpcy50ZWxlbWV0ZXI7XG4gICAgaWYgKHRlbGVtZXRlcikge1xuICAgICAgdGVsZW1ldGVyLl9jYXB0dXJlUm9sbGJhckl0ZW0oaXRlbSk7XG4gICAgICBpdGVtLnRlbGVtZXRyeUV2ZW50cyA9IHRlbGVtZXRlci5jb3B5RXZlbnRzKCkgfHwgW107XG4gICAgICBpZiAodGVsZW1ldGVyLnRlbGVtZXRyeVNwYW4pIHtcbiAgICAgICAgdGVsZW1ldGVyLnRlbGVtZXRyeVNwYW4uZW5kKCk7XG4gICAgICAgIHRlbGVtZXRlci50ZWxlbWV0cnlTcGFuID0gdGVsZW1ldGVyLnRyYWNpbmcuc3RhcnRTcGFuKCdyb2xsYmFyLXRlbGVtZXRyeScsIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ub3RpZmllci5sb2coaXRlbSwgY2FsbGJhY2spO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gIH1cbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5fYWRkVHJhY2luZ0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgX3RoaXMkdHJhY2luZztcbiAgdmFyIHNwYW4gPSAoX3RoaXMkdHJhY2luZyA9IHRoaXMudHJhY2luZykgPT09IG51bGwgfHwgX3RoaXMkdHJhY2luZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkdHJhY2luZy5nZXRTcGFuKCk7XG4gIGlmICghc3Bhbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXR0cmlidXRlcyA9IFt7XG4gICAga2V5OiAnc2Vzc2lvbl9pZCcsXG4gICAgdmFsdWU6IHRoaXMudHJhY2luZy5zZXNzaW9uSWRcbiAgfSwge1xuICAgIGtleTogJ3NwYW5faWQnLFxuICAgIHZhbHVlOiBzcGFuLnNwYW5JZFxuICB9LCB7XG4gICAga2V5OiAndHJhY2VfaWQnLFxuICAgIHZhbHVlOiBzcGFuLnRyYWNlSWRcbiAgfV07XG4gIF8uYWRkSXRlbUF0dHJpYnV0ZXMoaXRlbSwgYXR0cmlidXRlcyk7XG4gIHNwYW4uYWRkRXZlbnQoJ3JvbGxiYXIub2NjdXJyZW5jZScsIFt7XG4gICAga2V5OiAncm9sbGJhci5vY2N1cnJlbmNlLnV1aWQnLFxuICAgIHZhbHVlOiBpdGVtLnV1aWRcbiAgfV0pO1xufTtcblJvbGxiYXIucHJvdG90eXBlLl9kZWZhdWx0TG9nTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMubG9nTGV2ZWwgfHwgJ2RlYnVnJztcbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5fc2FtZUFzTGFzdEVycm9yID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgaWYgKCFpdGVtLl9pc1VuY2F1Z2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpdGVtSGFzaCA9IGdlbmVyYXRlSXRlbUhhc2goaXRlbSk7XG4gIGlmICh0aGlzLmxhc3RFcnJvckhhc2ggPT09IGl0ZW1IYXNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdGhpcy5sYXN0RXJyb3IgPSBpdGVtLmVycjtcbiAgdGhpcy5sYXN0RXJyb3JIYXNoID0gaXRlbUhhc2g7XG4gIHJldHVybiBmYWxzZTtcbn07XG5Sb2xsYmFyLnByb3RvdHlwZS5fYWRkVHJhY2luZ0luZm8gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAvLyBUcmFjZXIgdmFsaWRhdGlvbiBvY2N1cnMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGluIHRoZSBSb2xsYmFyLnByb3RvdHlwZS5jb25maWd1cmUgbWV0aG9kc1xuICBpZiAodGhpcy50cmFjZXIpIHtcbiAgICAvLyBhZGQgcm9sbGJhciBvY2N1cnJlbmNlIHV1aWQgdG8gc3BhblxuICAgIHZhciBzcGFuID0gdGhpcy50cmFjZXIuc2NvcGUoKS5hY3RpdmUoKTtcbiAgICBpZiAodmFsaWRhdGVTcGFuKHNwYW4pKSB7XG4gICAgICBzcGFuLnNldFRhZygncm9sbGJhci5lcnJvcl91dWlkJywgaXRlbS51dWlkKTtcbiAgICAgIHNwYW4uc2V0VGFnKCdyb2xsYmFyLmhhc19lcnJvcicsIHRydWUpO1xuICAgICAgc3Bhbi5zZXRUYWcoJ2Vycm9yJywgdHJ1ZSk7XG4gICAgICBzcGFuLnNldFRhZygncm9sbGJhci5pdGVtX3VybCcsIFwiaHR0cHM6Ly9yb2xsYmFyLmNvbS9pdGVtL3V1aWQvP3V1aWQ9XCIuY29uY2F0KGl0ZW0udXVpZCkpO1xuICAgICAgc3Bhbi5zZXRUYWcoJ3JvbGxiYXIub2NjdXJyZW5jZV91cmwnLCBcImh0dHBzOi8vcm9sbGJhci5jb20vb2NjdXJyZW5jZS91dWlkLz91dWlkPVwiLmNvbmNhdChpdGVtLnV1aWQpKTtcblxuICAgICAgLy8gYWRkIHNwYW4gSUQgJiB0cmFjZSBJRCB0byBvY2N1cnJlbmNlXG4gICAgICB2YXIgb3BlbnRyYWNpbmdTcGFuSWQgPSBzcGFuLmNvbnRleHQoKS50b1NwYW5JZCgpO1xuICAgICAgdmFyIG9wZW50cmFjaW5nVHJhY2VJZCA9IHNwYW4uY29udGV4dCgpLnRvVHJhY2VJZCgpO1xuICAgICAgaWYgKGl0ZW0uY3VzdG9tKSB7XG4gICAgICAgIGl0ZW0uY3VzdG9tLm9wZW50cmFjaW5nX3NwYW5faWQgPSBvcGVudHJhY2luZ1NwYW5JZDtcbiAgICAgICAgaXRlbS5jdXN0b20ub3BlbnRyYWNpbmdfdHJhY2VfaWQgPSBvcGVudHJhY2luZ1RyYWNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLmN1c3RvbSA9IHtcbiAgICAgICAgICBvcGVudHJhY2luZ19zcGFuX2lkOiBvcGVudHJhY2luZ1NwYW5JZCxcbiAgICAgICAgICBvcGVudHJhY2luZ190cmFjZV9pZDogb3BlbnRyYWNpbmdUcmFjZUlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gZ2VuZXJhdGVJdGVtSGFzaChpdGVtKSB7XG4gIHZhciBtZXNzYWdlID0gaXRlbS5tZXNzYWdlIHx8ICcnO1xuICB2YXIgc3RhY2sgPSAoaXRlbS5lcnIgfHwge30pLnN0YWNrIHx8IFN0cmluZyhpdGVtLmVycik7XG4gIHJldHVybiBtZXNzYWdlICsgJzo6JyArIHN0YWNrO1xufVxuXG4vLyBOb2RlLmpzLCBDaHJvbWUsIFNhZmFyaSwgYW5kIHNvbWUgb3RoZXIgYnJvd3NlcnMgc3VwcG9ydCB0aGlzIHByb3BlcnR5XG4vLyB3aGljaCBnbG9iYWxseSBzZXRzIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzIHJldHVybmVkIGluIGFuIEVycm9yIG9iamVjdC5cbi8vIElmIGEgYnJvd3NlciBjYW4ndCB1c2UgaXQsIG5vIGhhcm0gZG9uZS5cbmZ1bmN0aW9uIHNldFN0YWNrVHJhY2VMaW1pdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0YWNrVHJhY2VMaW1pdCkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IG9wdGlvbnMuc3RhY2tUcmFjZUxpbWl0O1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIFRyYWNlciBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIENsaWVudFxuICogaXMgdmFsaWQgZm9yIG91ciBPcGVudHJhY2luZyB1c2UgY2FzZS5cbiAqIEBwYXJhbSB7b3BlbnRyYWNlci5UcmFjZXJ9IHRyYWNlclxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYWNlcih0cmFjZXIpIHtcbiAgaWYgKCF0cmFjZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCF0cmFjZXIuc2NvcGUgfHwgdHlwZW9mIHRyYWNlci5zY29wZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2NvcGUgPSB0cmFjZXIuc2NvcGUoKTtcbiAgaWYgKCFzY29wZSB8fCAhc2NvcGUuYWN0aXZlIHx8IHR5cGVvZiBzY29wZS5hY3RpdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIFNwYW4gb2JqZWN0IHByb3ZpZGVkXG4gKiBAcGFyYW0ge29wZW50cmFjZXIuU3Bhbn0gc3BhblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNwYW4oc3Bhbikge1xuICBpZiAoIXNwYW4gfHwgIXNwYW4uY29udGV4dCB8fCB0eXBlb2Ygc3Bhbi5jb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzcGFuQ29udGV4dCA9IHNwYW4uY29udGV4dCgpO1xuICBpZiAoIXNwYW5Db250ZXh0IHx8ICFzcGFuQ29udGV4dC50b1NwYW5JZCB8fCAhc3BhbkNvbnRleHQudG9UcmFjZUlkIHx8IHR5cGVvZiBzcGFuQ29udGV4dC50b1NwYW5JZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc3BhbkNvbnRleHQudG9UcmFjZUlkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBSb2xsYmFyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTYwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1ODUpO1xuZnVuY3Rpb24gaXRlbVRvUGF5bG9hZChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZGF0YSA9IGl0ZW0uZGF0YTtcbiAgaWYgKGl0ZW0uX2lzVW5jYXVnaHQpIHtcbiAgICBkYXRhLl9pc1VuY2F1Z2h0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXRlbS5fb3JpZ2luYWxBcmdzKSB7XG4gICAgZGF0YS5fb3JpZ2luYWxBcmdzID0gaXRlbS5fb3JpZ2luYWxBcmdzO1xuICB9XG4gIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xufVxuZnVuY3Rpb24gYWRkUGF5bG9hZE9wdGlvbnMoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHBheWxvYWRPcHRpb25zID0gb3B0aW9ucy5wYXlsb2FkIHx8IHt9O1xuICBpZiAocGF5bG9hZE9wdGlvbnMuYm9keSkge1xuICAgIGRlbGV0ZSBwYXlsb2FkT3B0aW9ucy5ib2R5O1xuICB9XG4gIGl0ZW0uZGF0YSA9IF8ubWVyZ2UoaXRlbS5kYXRhLCBwYXlsb2FkT3B0aW9ucyk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuZnVuY3Rpb24gYWRkVGVsZW1ldHJ5RGF0YShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoaXRlbS50ZWxlbWV0cnlFdmVudHMpIHtcbiAgICBfLnNldChpdGVtLCAnZGF0YS5ib2R5LnRlbGVtZXRyeScsIGl0ZW0udGVsZW1ldHJ5RXZlbnRzKTtcbiAgfVxuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGFkZE1lc3NhZ2VXaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFpdGVtLm1lc3NhZ2UpIHtcbiAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRyYWNlUGF0aCA9ICdkYXRhLmJvZHkudHJhY2VfY2hhaW4uMCc7XG4gIHZhciB0cmFjZSA9IF8uZ2V0KGl0ZW0sIHRyYWNlUGF0aCk7XG4gIGlmICghdHJhY2UpIHtcbiAgICB0cmFjZVBhdGggPSAnZGF0YS5ib2R5LnRyYWNlJztcbiAgICB0cmFjZSA9IF8uZ2V0KGl0ZW0sIHRyYWNlUGF0aCk7XG4gIH1cbiAgaWYgKHRyYWNlKSB7XG4gICAgaWYgKCEodHJhY2UuZXhjZXB0aW9uICYmIHRyYWNlLmV4Y2VwdGlvbi5kZXNjcmlwdGlvbikpIHtcbiAgICAgIF8uc2V0KGl0ZW0sIHRyYWNlUGF0aCArICcuZXhjZXB0aW9uLmRlc2NyaXB0aW9uJywgaXRlbS5tZXNzYWdlKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXh0cmEgPSBfLmdldChpdGVtLCB0cmFjZVBhdGggKyAnLmV4dHJhJykgfHwge307XG4gICAgdmFyIG5ld0V4dHJhID0gXy5tZXJnZShleHRyYSwge1xuICAgICAgbWVzc2FnZTogaXRlbS5tZXNzYWdlXG4gICAgfSk7XG4gICAgXy5zZXQoaXRlbSwgdHJhY2VQYXRoICsgJy5leHRyYScsIG5ld0V4dHJhKTtcbiAgfVxuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIHVzZXJUcmFuc2Zvcm0obG9nZ2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgbmV3SXRlbSA9IF8ubWVyZ2UoaXRlbSk7XG4gICAgdmFyIHJlc3BvbnNlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBvcHRpb25zLnRyYW5zZm9ybShuZXdJdGVtLmRhdGEsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9wdGlvbnMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgY2FsbGluZyBjdXN0b20gdHJhbnNmb3JtKCkgZnVuY3Rpb24uIFJlbW92aW5nIGN1c3RvbSB0cmFuc2Zvcm0oKS4nLCBlKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoXy5pc1Byb21pc2UocmVzcG9uc2UpKSB7XG4gICAgICByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChwcm9taXNlZEl0ZW0pIHtcbiAgICAgICAgaWYgKHByb21pc2VkSXRlbSkge1xuICAgICAgICAgIG5ld0l0ZW0uZGF0YSA9IHByb21pc2VkSXRlbTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBuZXdJdGVtKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgaXRlbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCwgbmV3SXRlbSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkQ29uZmlnVG9QYXlsb2FkKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5zZW5kQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9XG4gIHZhciBjb25maWdLZXkgPSAnX3JvbGxiYXJDb25maWcnO1xuICB2YXIgY3VzdG9tID0gXy5nZXQoaXRlbSwgJ2RhdGEuY3VzdG9tJykgfHwge307XG4gIGN1c3RvbVtjb25maWdLZXldID0gb3B0aW9ucztcbiAgaXRlbS5kYXRhLmN1c3RvbSA9IGN1c3RvbTtcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5mdW5jdGlvbiBhZGRGdW5jdGlvbk9wdGlvbihvcHRpb25zLCBuYW1lKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9uc1tuYW1lXSkpIHtcbiAgICBvcHRpb25zW25hbWVdID0gb3B0aW9uc1tuYW1lXS50b1N0cmluZygpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRDb25maWd1cmVkT3B0aW9ucyhpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgY29uZmlndXJlZE9wdGlvbnMgPSBvcHRpb25zLl9jb25maWd1cmVkT3B0aW9ucztcblxuICAvLyBUaGVzZSBtdXN0IGJlIHN0cmluZ2lmaWVkIG9yIHRoZXknbGwgZ2V0IGRyb3BwZWQgZHVyaW5nIHNlcmlhbGl6YXRpb24uXG4gIGFkZEZ1bmN0aW9uT3B0aW9uKGNvbmZpZ3VyZWRPcHRpb25zLCAndHJhbnNmb3JtJyk7XG4gIGFkZEZ1bmN0aW9uT3B0aW9uKGNvbmZpZ3VyZWRPcHRpb25zLCAnY2hlY2tJZ25vcmUnKTtcbiAgYWRkRnVuY3Rpb25PcHRpb24oY29uZmlndXJlZE9wdGlvbnMsICdvblNlbmRDYWxsYmFjaycpO1xuICBkZWxldGUgY29uZmlndXJlZE9wdGlvbnMuYWNjZXNzVG9rZW47XG4gIGl0ZW0uZGF0YS5ub3RpZmllci5jb25maWd1cmVkX29wdGlvbnMgPSBjb25maWd1cmVkT3B0aW9ucztcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5mdW5jdGlvbiBhZGREaWFnbm9zdGljS2V5cyhpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZGlhZ25vc3RpYyA9IF8ubWVyZ2UoaXRlbS5ub3RpZmllci5jbGllbnQubm90aWZpZXIuZGlhZ25vc3RpYywgaXRlbS5kaWFnbm9zdGljKTtcbiAgaWYgKF8uZ2V0KGl0ZW0sICdlcnIuX2lzQW5vbnltb3VzJykpIHtcbiAgICBkaWFnbm9zdGljLmlzX2Fub255bW91cyA9IHRydWU7XG4gIH1cbiAgaWYgKGl0ZW0uX2lzVW5jYXVnaHQpIHtcbiAgICBkaWFnbm9zdGljLmlzX3VuY2F1Z2h0ID0gaXRlbS5faXNVbmNhdWdodDtcbiAgfVxuICBpZiAoaXRlbS5lcnIpIHtcbiAgICB0cnkge1xuICAgICAgZGlhZ25vc3RpYy5yYXdfZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6IGl0ZW0uZXJyLm1lc3NhZ2UsXG4gICAgICAgIG5hbWU6IGl0ZW0uZXJyLm5hbWUsXG4gICAgICAgIGNvbnN0cnVjdG9yX25hbWU6IGl0ZW0uZXJyLmNvbnN0cnVjdG9yICYmIGl0ZW0uZXJyLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgIGZpbGVuYW1lOiBpdGVtLmVyci5maWxlTmFtZSxcbiAgICAgICAgbGluZTogaXRlbS5lcnIubGluZU51bWJlcixcbiAgICAgICAgY29sdW1uOiBpdGVtLmVyci5jb2x1bW5OdW1iZXIsXG4gICAgICAgIHN0YWNrOiBpdGVtLmVyci5zdGFja1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkaWFnbm9zdGljLnJhd19lcnJvciA9IHtcbiAgICAgICAgZmFpbGVkOiBTdHJpbmcoZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGl0ZW0uZGF0YS5ub3RpZmllci5kaWFnbm9zdGljID0gXy5tZXJnZShpdGVtLmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYywgZGlhZ25vc3RpYyk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGl0ZW1Ub1BheWxvYWQ6IGl0ZW1Ub1BheWxvYWQsXG4gIGFkZFBheWxvYWRPcHRpb25zOiBhZGRQYXlsb2FkT3B0aW9ucyxcbiAgYWRkVGVsZW1ldHJ5RGF0YTogYWRkVGVsZW1ldHJ5RGF0YSxcbiAgYWRkTWVzc2FnZVdpdGhFcnJvcjogYWRkTWVzc2FnZVdpdGhFcnJvcixcbiAgdXNlclRyYW5zZm9ybTogdXNlclRyYW5zZm9ybSxcbiAgYWRkQ29uZmlnVG9QYXlsb2FkOiBhZGRDb25maWdUb1BheWxvYWQsXG4gIGFkZENvbmZpZ3VyZWRPcHRpb25zOiBhZGRDb25maWd1cmVkT3B0aW9ucyxcbiAgYWRkRGlhZ25vc3RpY0tleXM6IGFkZERpYWdub3N0aWNLZXlzXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTY1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhhc093bkNvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcbiAgdmFyIGhhc0lzUHJvdG90eXBlT2YgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSAmJiBoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuICAvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG4gIGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc093bkNvbnN0cnVjdG9yICYmICFoYXNJc1Byb3RvdHlwZU9mKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG4gIC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAvKiovXG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn07XG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgdmFyIGksXG4gICAgc3JjLFxuICAgIGNvcHksXG4gICAgY2xvbmUsXG4gICAgbmFtZSxcbiAgICByZXN1bHQgPSB7fSxcbiAgICBjdXJyZW50ID0gbnVsbCxcbiAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50ID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gY3VycmVudCkge1xuICAgICAgc3JjID0gcmVzdWx0W25hbWVdO1xuICAgICAgY29weSA9IGN1cnJlbnRbbmFtZV07XG4gICAgICBpZiAocmVzdWx0ICE9PSBjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ICYmIGlzUGxhaW5PYmplY3QoY29weSkpIHtcbiAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSBtZXJnZShjbG9uZSwgY29weSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvcHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gY29weTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvbGxiYXIudW1kLmpzLm1hcCIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvKiBnbG9iYWxzIGV4cGVjdCAqL1xuLyogZ2xvYmFscyBkZXNjcmliZSAqL1xuLyogZ2xvYmFscyBpdCAqL1xuXG4vLyBJbXBvcnQgUm9sbGJhciBkaXJlY3RseSBmcm9tIHRoZSBzb3VyY2VcbnZhciBSb2xsYmFyID0gcmVxdWlyZSgnLi4vLi4vZGlzdC9yb2xsYmFyLnVtZC5qcycpO1xuXG5kZXNjcmliZSgnQW5ndWxhciBpbnRlZ3JhdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYSB0ZXN0LWVuYWJsZWQgUm9sbGJhciBpbnN0YW5jZVxuICBmdW5jdGlvbiBjcmVhdGVUZXN0Um9sbGJhcihjYXB0dXJlUGF5bG9hZCkge1xuICAgIHZhciByb2xsYmFyID0gbmV3IFJvbGxiYXIoe1xuICAgICAgYWNjZXNzVG9rZW46ICdST0xMQkFSX1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICAgICAgLy8gT3ZlcnJpZGUgbG9nZ2luZyB0byB0ZXN0XG4gICAgICBhdXRvSW5zdHJ1bWVudDogZmFsc2UsXG4gICAgICAvLyBPdmVycmlkZSBlbmRwb2ludCB0byBwcmV2ZW50IGFjdHVhbCBBUEkgY2FsbHNcbiAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly90ZXN0LmV4YW1wbGUuY29tL2FwaScsXG4gICAgICAvLyBTZXQgbG9nIGxldmVsIHRvIGRlYnVnIHRvIGNhdGNoIGFsbCBtZXNzYWdlc1xuICAgICAgbG9nTGV2ZWw6ICdkZWJ1ZydcbiAgICB9KTtcblxuICAgIC8vIE92ZXJyaWRlIHRoZSBhY3R1YWwgQVBJIGNhbGwgd2l0aCBvdXIgdGVzdCBob29rXG4gICAgdmFyIG9yaWdpbmFsUXVldWUgPSByb2xsYmFyLmNsaWVudC5xdWV1ZS5hZGRJdGVtO1xuICAgIHJvbGxiYXIuY2xpZW50LnF1ZXVlLmFkZEl0ZW0gPSBmdW5jdGlvbihpdGVtLCBjYWxsYmFjaykge1xuICAgICAgLy8gQ2FwdHVyZSB0aGUgcGF5bG9hZCBmb3IgdmVyaWZpY2F0aW9uXG4gICAgICBjYXB0dXJlUGF5bG9hZChpdGVtKTtcbiAgICAgIC8vIENhbGwgdGhlIG9yaWdpbmFsIHRvIG1haW50YWluIHByb3BlciBiZWhhdmlvclxuICAgICAgcmV0dXJuIG9yaWdpbmFsUXVldWUuY2FsbCh0aGlzLCBpdGVtLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHJldHVybiByb2xsYmFyO1xuICB9XG5cbiAgaXQoJ3Nob3VsZCBjb3JyZWN0bHkgY29uZmlndXJlIFJvbGxiYXIgd2l0aCBBbmd1bGFyIGNvbmZpZyBvcHRpb25zJywgZnVuY3Rpb24gKCkge1xuICAgIC8vIFZlcmlmeSB0aGUgaW50ZWdyYXRpb24gYnkgZXZhbHVhdGluZyB0aGUgUm9sbGJhciBjb25maWd1cmF0aW9uIHBhdHRlcm5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdST0xMQkFSX1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICAgICAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IHRydWUsXG4gICAgICBlbnZpcm9ubWVudDogJ3Byb2R1Y3Rpb24nXG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgUm9sbGJhciBsaWtlIHRoZSBBbmd1bGFyIGFwcCB3b3VsZFxuICAgIHZhciByb2xsYmFyID0gbmV3IFJvbGxiYXIoY29uZmlnKTtcblxuICAgIC8vIENoZWNrIHRoYXQgUm9sbGJhciB3YXMgaW5pdGlhbGl6ZWQgY29ycmVjdGx5XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5hY2Nlc3NUb2tlbikudG8uZXF1YWwoJ1JPTExCQVJfUE9TVF9DTElFTlRfSVRFTV9UT0tFTicpO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuY2FwdHVyZVVuY2F1Z2h0KS50by5lcXVhbCh0cnVlKTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLmNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zKS50by5lcXVhbCh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBwcm9jZXNzIGFuZCBzZW5kIGVycm9ycyB3aXRoIGNvcnJlY3QgZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9jZXNzZWRJdGVtID0gbnVsbDtcblxuICAgIC8vIENyZWF0ZSBhIFJvbGxiYXIgaW5zdGFuY2Ugd2l0aCBvdXIgdGVzdCBob29rXG4gICAgdmFyIHJvbGxiYXIgPSBjcmVhdGVUZXN0Um9sbGJhcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICBwcm9jZXNzZWRJdGVtID0gaXRlbTtcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhIHRlc3QgZXJyb3JcbiAgICB2YXIgdGVzdEVycm9yID0gbmV3IEVycm9yKCdUZXN0IEFuZ3VsYXIgRXJyb3InKTtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IHsgY29tcG9uZW50OiAnVGVzdENvbXBvbmVudCcgfTtcblxuICAgIC8vIENhbGwgZXJyb3IgbWV0aG9kXG4gICAgcm9sbGJhci5lcnJvcih0ZXN0RXJyb3IsIGN1c3RvbURhdGEpO1xuXG4gICAgLy8gVmVyaWZ5IHRoZSBlcnJvciB3YXMgcHJvY2Vzc2VkXG4gICAgZXhwZWN0KHByb2Nlc3NlZEl0ZW0pLnRvLm5vdC5lcXVhbChudWxsKTtcblxuICAgIC8vIFZlcmlmeSB0aGUgZXJyb3IgbGV2ZWwgaXMgc2V0IGNvcnJlY3RseVxuICAgIGV4cGVjdChwcm9jZXNzZWRJdGVtLmxldmVsKS50by5lcXVhbCgnZXJyb3InKTtcblxuICAgIC8vIFZlcmlmeSB0aGUgZXJyb3IgbWVzc2FnZSBpcyBpbmNsdWRlZFxuICAgIGV4cGVjdChwcm9jZXNzZWRJdGVtLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxdWFsKCdUZXN0IEFuZ3VsYXIgRXJyb3InKTtcblxuICAgIC8vIFZlcmlmeSBjdXN0b20gZGF0YSBpcyBpbmNsdWRlZFxuICAgIGV4cGVjdChwcm9jZXNzZWRJdGVtLmN1c3RvbS5jb21wb25lbnQpLnRvLmVxdWFsKCdUZXN0Q29tcG9uZW50Jyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJvY2VzcyBhbmQgc2VuZCB3YXJuaW5ncyB3aXRoIGNvcnJlY3QgZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9jZXNzZWRJdGVtID0gbnVsbDtcblxuICAgIC8vIENyZWF0ZSBhIFJvbGxiYXIgaW5zdGFuY2Ugd2l0aCBvdXIgdGVzdCBob29rXG4gICAgdmFyIHJvbGxiYXIgPSBjcmVhdGVUZXN0Um9sbGJhcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICBwcm9jZXNzZWRJdGVtID0gaXRlbTtcbiAgICB9KTtcblxuICAgIC8vIENhbGwgd2FybmluZyBtZXRob2RcbiAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSAnVGVzdCBBbmd1bGFyIFdhcm5pbmcnO1xuICAgIHZhciBjdXN0b21EYXRhID0geyBzZXZlcml0eTogJ21lZGl1bScgfTtcblxuICAgIHJvbGxiYXIud2FybmluZyh3YXJuaW5nTWVzc2FnZSwgY3VzdG9tRGF0YSk7XG5cbiAgICAvLyBWZXJpZnkgdGhlIHdhcm5pbmcgd2FzIHByb2Nlc3NlZFxuICAgIGV4cGVjdChwcm9jZXNzZWRJdGVtKS50by5ub3QuZXF1YWwobnVsbCk7XG5cbiAgICAvLyBWZXJpZnkgdGhlIHdhcm5pbmcgbGV2ZWwgaXMgc2V0IGNvcnJlY3RseVxuICAgIGV4cGVjdChwcm9jZXNzZWRJdGVtLmxldmVsKS50by5lcXVhbCgnd2FybmluZycpO1xuXG4gICAgLy8gVmVyaWZ5IHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgaW5jbHVkZWRcbiAgICBleHBlY3QocHJvY2Vzc2VkSXRlbS5ib2R5Lm1lc3NhZ2UuYm9keSkudG8uZXF1YWwoJ1Rlc3QgQW5ndWxhciBXYXJuaW5nJyk7XG5cbiAgICAvLyBWZXJpZnkgY3VzdG9tIGRhdGEgaXMgaW5jbHVkZWRcbiAgICBleHBlY3QocHJvY2Vzc2VkSXRlbS5jdXN0b20uc2V2ZXJpdHkpLnRvLmVxdWFsKCdtZWRpdW0nKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBpbmNsdWRlIEFuZ3VsYXItc3BlY2lmaWMgcHJvcGVydGllcyBpbiBlcnJvciBkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb2Nlc3NlZEl0ZW0gPSBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIGEgUm9sbGJhciBpbnN0YW5jZSB3aXRoIG91ciB0ZXN0IGhvb2tcbiAgICB2YXIgcm9sbGJhciA9IGNyZWF0ZVRlc3RSb2xsYmFyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHByb2Nlc3NlZEl0ZW0gPSBpdGVtO1xuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGFuIEFuZ3VsYXItc3BlY2lmaWMgZXJyb3Igd2l0aCBuZ0RlYnVnQ29udGV4dFxuICAgIHZhciBhbmd1bGFyRXJyb3IgPSBuZXcgRXJyb3IoJ0FuZ3VsYXIgQ29tcG9uZW50IEVycm9yJyk7XG5cbiAgICAvLyBDcmVhdGUgYSBjdXN0b20gb2JqZWN0IHRoYXQgaW5jbHVkZXMgQW5ndWxhci1zcGVjaWZpYyBjb250ZXh0XG4gICAgdmFyIGN1c3RvbURhdGEgPSB7XG4gICAgICBuZ0RlYnVnQ29udGV4dDoge1xuICAgICAgICBjb21wb25lbnQ6ICdUZXN0QW5ndWxhckNvbXBvbmVudCcsXG4gICAgICAgIGNvbnRleHQ6IHsgbmFtZTogJ0FuZ3VsYXJDb250ZXh0JyB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhbGwgZXJyb3IgbWV0aG9kIHdpdGggdGhlIGN1c3RvbSBkYXRhIHRoYXQgaW5jbHVkZXMgQW5ndWxhciBkZWJ1ZyBjb250ZXh0XG4gICAgcm9sbGJhci5lcnJvcihhbmd1bGFyRXJyb3IsIGN1c3RvbURhdGEpO1xuXG4gICAgLy8gVmVyaWZ5IHRoZSBlcnJvciB3YXMgcHJvY2Vzc2VkXG4gICAgZXhwZWN0KHByb2Nlc3NlZEl0ZW0pLnRvLm5vdC5lcXVhbChudWxsKTtcblxuICAgIC8vIFZlcmlmeSB0aGUgZXJyb3IgbWVzc2FnZSBpcyBpbmNsdWRlZFxuICAgIGV4cGVjdChwcm9jZXNzZWRJdGVtLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxdWFsKCdBbmd1bGFyIENvbXBvbmVudCBFcnJvcicpO1xuXG4gICAgLy8gVmVyaWZ5IEFuZ3VsYXItc3BlY2lmaWMgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgaW4gY3VzdG9tIGRhdGFcbiAgICBleHBlY3QodHlwZW9mIHByb2Nlc3NlZEl0ZW0uY3VzdG9tLm5nRGVidWdDb250ZXh0KS50by5lcXVhbCgnb2JqZWN0Jyk7XG4gICAgZXhwZWN0KHByb2Nlc3NlZEl0ZW0uY3VzdG9tLm5nRGVidWdDb250ZXh0LmNvbXBvbmVudCkudG8uZXF1YWwoJ1Rlc3RBbmd1bGFyQ29tcG9uZW50Jyk7XG4gICAgZXhwZWN0KHByb2Nlc3NlZEl0ZW0uY3VzdG9tLm5nRGVidWdDb250ZXh0LmNvbnRleHQubmFtZSkudG8uZXF1YWwoJ0FuZ3VsYXJDb250ZXh0Jyk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=