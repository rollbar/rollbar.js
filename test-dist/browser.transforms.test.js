(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@rrweb/record/dist/record.js":
/*!***************************************************!*\
  !*** ./node_modules/@rrweb/record/dist/record.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   record: () => (/* binding */ record)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var NodeType$3 = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType$3 || {});
const testableAccessors$1 = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
};
const testableMethods$1 = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
};
const untaintedBasePrototype$1 = {};
const isAngularZonePresent$1 = () => {
  return !!globalThis.Zone;
};
function getUntaintedPrototype$1(key) {
  if (untaintedBasePrototype$1[key])
    return untaintedBasePrototype$1[key];
  const defaultObj = globalThis[key];
  const defaultPrototype = defaultObj.prototype;
  const accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;
  const isUntaintedAccessors = Boolean(
    accessorNames && // @ts-expect-error 2345
    accessorNames.every(
      (accessor) => {
        var _a2, _b;
        return Boolean(
          (_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes("[native code]")
        );
      }
    )
  );
  const methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;
  const isUntaintedMethods = Boolean(
    methodNames && methodNames.every(
      // @ts-expect-error 2345
      (method) => {
        var _a2;
        return typeof defaultPrototype[method] === "function" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes("[native code]"));
      }
    )
  );
  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {
    untaintedBasePrototype$1[key] = defaultObj.prototype;
    return defaultObj.prototype;
  }
  try {
    const iframeEl = document.createElement("iframe");
    document.body.appendChild(iframeEl);
    const win = iframeEl.contentWindow;
    if (!win) return defaultObj.prototype;
    const untaintedObject = win[key].prototype;
    document.body.removeChild(iframeEl);
    if (!untaintedObject) return defaultPrototype;
    return untaintedBasePrototype$1[key] = untaintedObject;
  } catch {
    return defaultPrototype;
  }
}
const untaintedAccessorCache$1 = {};
function getUntaintedAccessor$1(key, instance, accessor) {
  var _a2;
  const cacheKey = `${key}.${String(accessor)}`;
  if (untaintedAccessorCache$1[cacheKey])
    return untaintedAccessorCache$1[cacheKey].call(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype$1(key);
  const untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(
    untaintedPrototype,
    accessor
  )) == null ? void 0 : _a2.get;
  if (!untaintedAccessor) return instance[accessor];
  untaintedAccessorCache$1[cacheKey] = untaintedAccessor;
  return untaintedAccessor.call(instance);
}
const untaintedMethodCache$1 = {};
function getUntaintedMethod$1(key, instance, method) {
  const cacheKey = `${key}.${String(method)}`;
  if (untaintedMethodCache$1[cacheKey])
    return untaintedMethodCache$1[cacheKey].bind(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype$1(key);
  const untaintedMethod = untaintedPrototype[method];
  if (typeof untaintedMethod !== "function") return instance[method];
  untaintedMethodCache$1[cacheKey] = untaintedMethod;
  return untaintedMethod.bind(instance);
}
function childNodes$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "childNodes");
}
function parentNode$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "parentNode");
}
function parentElement$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "parentElement");
}
function textContent$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "textContent");
}
function contains$1(n2, other) {
  return getUntaintedMethod$1("Node", n2, "contains")(other);
}
function getRootNode$1(n2) {
  return getUntaintedMethod$1("Node", n2, "getRootNode")();
}
function host$1(n2) {
  if (!n2 || !("host" in n2)) return null;
  return getUntaintedAccessor$1("ShadowRoot", n2, "host");
}
function styleSheets$1(n2) {
  return n2.styleSheets;
}
function shadowRoot$1(n2) {
  if (!n2 || !("shadowRoot" in n2)) return null;
  return getUntaintedAccessor$1("Element", n2, "shadowRoot");
}
function querySelector$1(n2, selectors) {
  return getUntaintedAccessor$1("Element", n2, "querySelector")(selectors);
}
function querySelectorAll$1(n2, selectors) {
  return getUntaintedAccessor$1("Element", n2, "querySelectorAll")(selectors);
}
function mutationObserverCtor$1() {
  return getUntaintedPrototype$1("MutationObserver").constructor;
}
const index$1 = {
  childNodes: childNodes$1,
  parentNode: parentNode$1,
  parentElement: parentElement$1,
  textContent: textContent$1,
  contains: contains$1,
  getRootNode: getRootNode$1,
  host: host$1,
  styleSheets: styleSheets$1,
  shadowRoot: shadowRoot$1,
  querySelector: querySelector$1,
  querySelectorAll: querySelectorAll$1,
  mutationObserver: mutationObserverCtor$1
};
function isElement(n2) {
  return n2.nodeType === n2.ELEMENT_NODE;
}
function isShadowRoot(n2) {
  const hostEl = (
    // anchor and textarea elements also have a `host` property
    // but only shadow roots have a `mode` property
    n2 && "host" in n2 && "mode" in n2 && index$1.host(n2) || null
  );
  return Boolean(
    hostEl && "shadowRoot" in hostEl && index$1.shadowRoot(hostEl) === n2
  );
}
function isNativeShadowDom(shadowRoot2) {
  return Object.prototype.toString.call(shadowRoot2) === "[object ShadowRoot]";
}
function fixBrowserCompatibilityIssuesInCSS(cssText) {
  if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {
    cssText = cssText.replace(
      /\sbackground-clip:\s*text;/g,
      " -webkit-background-clip: text; background-clip: text;"
    );
  }
  return cssText;
}
function escapeImportStatement(rule2) {
  const { cssText } = rule2;
  if (cssText.split('"').length < 3) return cssText;
  const statement = ["@import", `url(${JSON.stringify(rule2.href)})`];
  if (rule2.layerName === "") {
    statement.push(`layer`);
  } else if (rule2.layerName) {
    statement.push(`layer(${rule2.layerName})`);
  }
  if (rule2.supportsText) {
    statement.push(`supports(${rule2.supportsText})`);
  }
  if (rule2.media.length) {
    statement.push(rule2.media.mediaText);
  }
  return statement.join(" ") + ";";
}
function stringifyStylesheet(s2) {
  try {
    const rules2 = s2.rules || s2.cssRules;
    if (!rules2) {
      return null;
    }
    let sheetHref = s2.href;
    if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {
      sheetHref = s2.ownerNode.ownerDocument.location.href;
    }
    const stringifiedRules = Array.from(
      rules2,
      (rule2) => stringifyRule(rule2, sheetHref)
    ).join("");
    return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);
  } catch (error) {
    return null;
  }
}
function stringifyRule(rule2, sheetHref) {
  if (isCSSImportRule(rule2)) {
    let importStringified;
    try {
      importStringified = // for same-origin stylesheets,
      // we can access the imported stylesheet rules directly
      stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement
      escapeImportStatement(rule2);
    } catch (error) {
      importStringified = rule2.cssText;
    }
    if (rule2.styleSheet.href) {
      return absolutifyURLs(importStringified, rule2.styleSheet.href);
    }
    return importStringified;
  } else {
    let ruleStringified = rule2.cssText;
    if (isCSSStyleRule(rule2) && rule2.selectorText.includes(":")) {
      ruleStringified = fixSafariColons(ruleStringified);
    }
    if (sheetHref) {
      return absolutifyURLs(ruleStringified, sheetHref);
    }
    return ruleStringified;
  }
}
function fixSafariColons(cssStringified) {
  const regex = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return cssStringified.replace(regex, "$1\\$2");
}
function isCSSImportRule(rule2) {
  return "styleSheet" in rule2;
}
function isCSSStyleRule(rule2) {
  return "selectorText" in rule2;
}
class Mirror {
  constructor() {
    __publicField$1(this, "idNodeMap", /* @__PURE__ */ new Map());
    __publicField$1(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());
  }
  getId(n2) {
    var _a2;
    if (!n2) return -1;
    const id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;
    return id ?? -1;
  }
  getNode(id) {
    return this.idNodeMap.get(id) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(n2) {
    return this.nodeMetaMap.get(n2) || null;
  }
  // removes the node from idNodeMap
  // doesn't remove the node from nodeMetaMap
  removeNodeFromMap(n2) {
    const id = this.getId(n2);
    this.idNodeMap.delete(id);
    if (n2.childNodes) {
      n2.childNodes.forEach(
        (childNode) => this.removeNodeFromMap(childNode)
      );
    }
  }
  has(id) {
    return this.idNodeMap.has(id);
  }
  hasNode(node2) {
    return this.nodeMetaMap.has(node2);
  }
  add(n2, meta) {
    const id = meta.id;
    this.idNodeMap.set(id, n2);
    this.nodeMetaMap.set(n2, meta);
  }
  replace(id, n2) {
    const oldNode = this.getNode(id);
    if (oldNode) {
      const meta = this.nodeMetaMap.get(oldNode);
      if (meta) this.nodeMetaMap.set(n2, meta);
    }
    this.idNodeMap.set(id, n2);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map();
    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function createMirror$2() {
  return new Mirror();
}
function maskInputValue({
  element,
  maskInputOptions,
  tagName,
  type,
  value,
  maskInputFn
}) {
  let text = value || "";
  const actualType = type && toLowerCase(type);
  if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {
    if (maskInputFn) {
      text = maskInputFn(text, element);
    } else {
      text = "*".repeat(text.length);
    }
  }
  return text;
}
function toLowerCase(str) {
  return str.toLowerCase();
}
const ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";
function is2DCanvasBlank(canvas) {
  const ctx = canvas.getContext("2d");
  if (!ctx) return true;
  const chunkSize = 50;
  for (let x2 = 0; x2 < canvas.width; x2 += chunkSize) {
    for (let y = 0; y < canvas.height; y += chunkSize) {
      const getImageData = ctx.getImageData;
      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;
      const pixelBuffer = new Uint32Array(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        originalGetImageData.call(
          ctx,
          x2,
          y,
          Math.min(chunkSize, canvas.width - x2),
          Math.min(chunkSize, canvas.height - y)
        ).data.buffer
      );
      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;
    }
  }
  return true;
}
function getInputType(element) {
  const type = element.type;
  return element.hasAttribute("data-rr-is-password") ? "password" : type ? (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    toLowerCase(type)
  ) : null;
}
function extractFileExtension(path, baseURL) {
  let url;
  try {
    url = new URL(path, baseURL ?? window.location.href);
  } catch (err) {
    return null;
  }
  const regex = /\.([0-9a-z]+)(?:$)/i;
  const match = url.pathname.match(regex);
  return (match == null ? void 0 : match[1]) ?? null;
}
function extractOrigin(url) {
  let origin = "";
  if (url.indexOf("//") > -1) {
    origin = url.split("/").slice(0, 3).join("/");
  } else {
    origin = url.split("/")[0];
  }
  origin = origin.split("?")[0];
  return origin;
}
const URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
const URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i;
const URL_WWW_MATCH = /^www\..*/i;
const DATA_URI = /^(data:)([^,]*),(.*)/i;
function absolutifyURLs(cssText, href) {
  return (cssText || "").replace(
    URL_IN_CSS_REF,
    (origin, quote1, path1, quote2, path2, path3) => {
      const filePath = path1 || path2 || path3;
      const maybeQuote = quote1 || quote2 || "";
      if (!filePath) {
        return origin;
      }
      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (DATA_URI.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (filePath[0] === "/") {
        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;
      }
      const stack = href.split("/");
      const parts = filePath.split("/");
      stack.pop();
      for (const part of parts) {
        if (part === ".") {
          continue;
        } else if (part === "..") {
          stack.pop();
        } else {
          stack.push(part);
        }
      }
      return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;
    }
  );
}
function normalizeCssString(cssText) {
  return cssText.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "");
}
function splitCssText(cssText, style) {
  const childNodes2 = Array.from(style.childNodes);
  const splits = [];
  if (childNodes2.length > 1 && cssText && typeof cssText === "string") {
    const cssTextNorm = normalizeCssString(cssText);
    for (let i2 = 1; i2 < childNodes2.length; i2++) {
      if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === "string") {
        const textContentNorm = normalizeCssString(childNodes2[i2].textContent);
        for (let j = 3; j < textContentNorm.length; j++) {
          const bit = textContentNorm.substring(0, j);
          if (cssTextNorm.split(bit).length === 2) {
            const splitNorm = cssTextNorm.indexOf(bit);
            for (let k = splitNorm; k < cssText.length; k++) {
              if (normalizeCssString(cssText.substring(0, k)).length === splitNorm) {
                splits.push(cssText.substring(0, k));
                cssText = cssText.substring(k);
                break;
              }
            }
            break;
          }
        }
      }
    }
  }
  splits.push(cssText);
  return splits;
}
function markCssSplits(cssText, style) {
  return splitCssText(cssText, style).join("/* rr_split */");
}
let _id = 1;
const tagNameRegex = new RegExp("[^a-z0-9-_:]");
const IGNORED_NODE = -2;
function genId() {
  return _id++;
}
function getValidTagName$1(element) {
  if (element instanceof HTMLFormElement) {
    return "form";
  }
  const processedTagName = toLowerCase(element.tagName);
  if (tagNameRegex.test(processedTagName)) {
    return "div";
  }
  return processedTagName;
}
let canvasService;
let canvasCtx;
const SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
const SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
function getAbsoluteSrcsetString(doc, attributeValue) {
  if (attributeValue.trim() === "") {
    return attributeValue;
  }
  let pos = 0;
  function collectCharacters(regEx) {
    let chars2;
    const match = regEx.exec(attributeValue.substring(pos));
    if (match) {
      chars2 = match[0];
      pos += chars2.length;
      return chars2;
    }
    return "";
  }
  const output = [];
  while (true) {
    collectCharacters(SRCSET_COMMAS_OR_SPACES);
    if (pos >= attributeValue.length) {
      break;
    }
    let url = collectCharacters(SRCSET_NOT_SPACES);
    if (url.slice(-1) === ",") {
      url = absoluteToDoc(doc, url.substring(0, url.length - 1));
      output.push(url);
    } else {
      let descriptorsStr = "";
      url = absoluteToDoc(doc, url);
      let inParens = false;
      while (true) {
        const c2 = attributeValue.charAt(pos);
        if (c2 === "") {
          output.push((url + descriptorsStr).trim());
          break;
        } else if (!inParens) {
          if (c2 === ",") {
            pos += 1;
            output.push((url + descriptorsStr).trim());
            break;
          } else if (c2 === "(") {
            inParens = true;
          }
        } else {
          if (c2 === ")") {
            inParens = false;
          }
        }
        descriptorsStr += c2;
        pos += 1;
      }
    }
  }
  return output.join(", ");
}
const cachedDocument = /* @__PURE__ */ new WeakMap();
function absoluteToDoc(doc, attributeValue) {
  if (!attributeValue || attributeValue.trim() === "") {
    return attributeValue;
  }
  return getHref(doc, attributeValue);
}
function isSVGElement(el) {
  return Boolean(el.tagName === "svg" || el.ownerSVGElement);
}
function getHref(doc, customHref) {
  let a2 = cachedDocument.get(doc);
  if (!a2) {
    a2 = doc.createElement("a");
    cachedDocument.set(doc, a2);
  }
  if (!customHref) {
    customHref = "";
  } else if (customHref.startsWith("blob:") || customHref.startsWith("data:")) {
    return customHref;
  }
  a2.setAttribute("href", customHref);
  return a2.href;
}
function transformAttribute(doc, tagName, name, value) {
  if (!value) {
    return value;
  }
  if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {
    return absoluteToDoc(doc, value);
  } else if (name === "xlink:href" && value[0] !== "#") {
    return absoluteToDoc(doc, value);
  } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {
    return absoluteToDoc(doc, value);
  } else if (name === "srcset") {
    return getAbsoluteSrcsetString(doc, value);
  } else if (name === "style") {
    return absolutifyURLs(value, getHref(doc));
  } else if (tagName === "object" && name === "data") {
    return absoluteToDoc(doc, value);
  }
  return value;
}
function ignoreAttribute(tagName, name, _value) {
  return (tagName === "video" || tagName === "audio") && name === "autoplay";
}
function _isBlockedElement(element, blockClass, blockSelector) {
  try {
    if (typeof blockClass === "string") {
      if (element.classList.contains(blockClass)) {
        return true;
      }
    } else {
      for (let eIndex = element.classList.length; eIndex--; ) {
        const className = element.classList[eIndex];
        if (blockClass.test(className)) {
          return true;
        }
      }
    }
    if (blockSelector) {
      return element.matches(blockSelector);
    }
  } catch (e2) {
  }
  return false;
}
function classMatchesRegex(node2, regex, checkAncestors) {
  if (!node2) return false;
  if (node2.nodeType !== node2.ELEMENT_NODE) {
    if (!checkAncestors) return false;
    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);
  }
  for (let eIndex = node2.classList.length; eIndex--; ) {
    const className = node2.classList[eIndex];
    if (regex.test(className)) {
      return true;
    }
  }
  if (!checkAncestors) return false;
  return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);
}
function needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {
  let el;
  if (isElement(node2)) {
    el = node2;
    if (!index$1.childNodes(el).length) {
      return false;
    }
  } else if (index$1.parentElement(node2) === null) {
    return false;
  } else {
    el = index$1.parentElement(node2);
  }
  try {
    if (typeof maskTextClass === "string") {
      if (checkAncestors) {
        if (el.closest(`.${maskTextClass}`)) return true;
      } else {
        if (el.classList.contains(maskTextClass)) return true;
      }
    } else {
      if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;
    }
    if (maskTextSelector) {
      if (checkAncestors) {
        if (el.closest(maskTextSelector)) return true;
      } else {
        if (el.matches(maskTextSelector)) return true;
      }
    }
  } catch (e2) {
  }
  return false;
}
function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
  const win = iframeEl.contentWindow;
  if (!win) {
    return;
  }
  let fired = false;
  let readyState;
  try {
    readyState = win.document.readyState;
  } catch (error) {
    return;
  }
  if (readyState !== "complete") {
    const timer = setTimeout(() => {
      if (!fired) {
        listener();
        fired = true;
      }
    }, iframeLoadTimeout);
    iframeEl.addEventListener("load", () => {
      clearTimeout(timer);
      fired = true;
      listener();
    });
    return;
  }
  const blankUrl = "about:blank";
  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {
    setTimeout(listener, 0);
    return iframeEl.addEventListener("load", listener);
  }
  iframeEl.addEventListener("load", listener);
}
function onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {
  let fired = false;
  let styleSheetLoaded;
  try {
    styleSheetLoaded = link.sheet;
  } catch (error) {
    return;
  }
  if (styleSheetLoaded) return;
  const timer = setTimeout(() => {
    if (!fired) {
      listener();
      fired = true;
    }
  }, styleSheetLoadTimeout);
  link.addEventListener("load", () => {
    clearTimeout(timer);
    fired = true;
    listener();
  });
}
function serializeNode(n2, options) {
  const {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions = {},
    maskTextFn,
    maskInputFn,
    dataURLOptions = {},
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement = false,
    cssCaptured = false
  } = options;
  const rootId = getRootId(doc, mirror2);
  switch (n2.nodeType) {
    case n2.DOCUMENT_NODE:
      if (n2.compatMode !== "CSS1Compat") {
        return {
          type: NodeType$3.Document,
          childNodes: [],
          compatMode: n2.compatMode
          // probably "BackCompat"
        };
      } else {
        return {
          type: NodeType$3.Document,
          childNodes: []
        };
      }
    case n2.DOCUMENT_TYPE_NODE:
      return {
        type: NodeType$3.DocumentType,
        name: n2.name,
        publicId: n2.publicId,
        systemId: n2.systemId,
        rootId
      };
    case n2.ELEMENT_NODE:
      return serializeElementNode(n2, {
        doc,
        blockClass,
        blockSelector,
        inlineStylesheet,
        maskInputOptions,
        maskInputFn,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        keepIframeSrcFn,
        newlyAddedElement,
        rootId
      });
    case n2.TEXT_NODE:
      return serializeTextNode(n2, {
        doc,
        needsMask,
        maskTextFn,
        rootId,
        cssCaptured
      });
    case n2.CDATA_SECTION_NODE:
      return {
        type: NodeType$3.CDATA,
        textContent: "",
        rootId
      };
    case n2.COMMENT_NODE:
      return {
        type: NodeType$3.Comment,
        textContent: index$1.textContent(n2) || "",
        rootId
      };
    default:
      return false;
  }
}
function getRootId(doc, mirror2) {
  if (!mirror2.hasNode(doc)) return void 0;
  const docId = mirror2.getId(doc);
  return docId === 1 ? void 0 : docId;
}
function serializeTextNode(n2, options) {
  const { needsMask, maskTextFn, rootId, cssCaptured } = options;
  const parent = index$1.parentNode(n2);
  const parentTagName = parent && parent.tagName;
  let textContent2 = "";
  const isStyle = parentTagName === "STYLE" ? true : void 0;
  const isScript = parentTagName === "SCRIPT" ? true : void 0;
  if (isScript) {
    textContent2 = "SCRIPT_PLACEHOLDER";
  } else if (!cssCaptured) {
    textContent2 = index$1.textContent(n2);
    if (isStyle && textContent2) {
      textContent2 = absolutifyURLs(textContent2, getHref(options.doc));
    }
  }
  if (!isStyle && !isScript && textContent2 && needsMask) {
    textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\S]/g, "*");
  }
  return {
    type: NodeType$3.Text,
    textContent: textContent2 || "",
    rootId
  };
}
function serializeElementNode(n2, options) {
  const {
    doc,
    blockClass,
    blockSelector,
    inlineStylesheet,
    maskInputOptions = {},
    maskInputFn,
    dataURLOptions = {},
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement = false,
    rootId
  } = options;
  const needBlock = _isBlockedElement(n2, blockClass, blockSelector);
  const tagName = getValidTagName$1(n2);
  let attributes = {};
  const len = n2.attributes.length;
  for (let i2 = 0; i2 < len; i2++) {
    const attr = n2.attributes[i2];
    if (!ignoreAttribute(tagName, attr.name, attr.value)) {
      attributes[attr.name] = transformAttribute(
        doc,
        tagName,
        toLowerCase(attr.name),
        attr.value
      );
    }
  }
  if (tagName === "link" && inlineStylesheet) {
    const stylesheet = Array.from(doc.styleSheets).find((s2) => {
      return s2.href === n2.href;
    });
    let cssText = null;
    if (stylesheet) {
      cssText = stringifyStylesheet(stylesheet);
    }
    if (cssText) {
      delete attributes.rel;
      delete attributes.href;
      attributes._cssText = cssText;
    }
  }
  if (tagName === "style" && n2.sheet) {
    let cssText = stringifyStylesheet(
      n2.sheet
    );
    if (cssText) {
      if (n2.childNodes.length > 1) {
        cssText = markCssSplits(cssText, n2);
      }
      attributes._cssText = cssText;
    }
  }
  if (tagName === "input" || tagName === "textarea" || tagName === "select") {
    const value = n2.value;
    const checked = n2.checked;
    if (attributes.type !== "radio" && attributes.type !== "checkbox" && attributes.type !== "submit" && attributes.type !== "button" && value) {
      attributes.value = maskInputValue({
        element: n2,
        type: getInputType(n2),
        tagName,
        value,
        maskInputOptions,
        maskInputFn
      });
    } else if (checked) {
      attributes.checked = checked;
    }
  }
  if (tagName === "option") {
    if (n2.selected && !maskInputOptions["select"]) {
      attributes.selected = true;
    } else {
      delete attributes.selected;
    }
  }
  if (tagName === "dialog" && n2.open) {
    attributes.rr_open_mode = n2.matches("dialog:modal") ? "modal" : "non-modal";
  }
  if (tagName === "canvas" && recordCanvas) {
    if (n2.__context === "2d") {
      if (!is2DCanvasBlank(n2)) {
        attributes.rr_dataURL = n2.toDataURL(
          dataURLOptions.type,
          dataURLOptions.quality
        );
      }
    } else if (!("__context" in n2)) {
      const canvasDataURL = n2.toDataURL(
        dataURLOptions.type,
        dataURLOptions.quality
      );
      const blankCanvas = doc.createElement("canvas");
      blankCanvas.width = n2.width;
      blankCanvas.height = n2.height;
      const blankCanvasDataURL = blankCanvas.toDataURL(
        dataURLOptions.type,
        dataURLOptions.quality
      );
      if (canvasDataURL !== blankCanvasDataURL) {
        attributes.rr_dataURL = canvasDataURL;
      }
    }
  }
  if (tagName === "img" && inlineImages) {
    if (!canvasService) {
      canvasService = doc.createElement("canvas");
      canvasCtx = canvasService.getContext("2d");
    }
    const image = n2;
    const imageSrc = image.currentSrc || image.getAttribute("src") || "<unknown-src>";
    const priorCrossOrigin = image.crossOrigin;
    const recordInlineImage = () => {
      image.removeEventListener("load", recordInlineImage);
      try {
        canvasService.width = image.naturalWidth;
        canvasService.height = image.naturalHeight;
        canvasCtx.drawImage(image, 0, 0);
        attributes.rr_dataURL = canvasService.toDataURL(
          dataURLOptions.type,
          dataURLOptions.quality
        );
      } catch (err) {
        if (image.crossOrigin !== "anonymous") {
          image.crossOrigin = "anonymous";
          if (image.complete && image.naturalWidth !== 0)
            recordInlineImage();
          else image.addEventListener("load", recordInlineImage);
          return;
        } else {
          console.warn(
            `Cannot inline img src=${imageSrc}! Error: ${err}`
          );
        }
      }
      if (image.crossOrigin === "anonymous") {
        priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute("crossorigin");
      }
    };
    if (image.complete && image.naturalWidth !== 0) recordInlineImage();
    else image.addEventListener("load", recordInlineImage);
  }
  if (tagName === "audio" || tagName === "video") {
    const mediaAttributes = attributes;
    mediaAttributes.rr_mediaState = n2.paused ? "paused" : "played";
    mediaAttributes.rr_mediaCurrentTime = n2.currentTime;
    mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;
    mediaAttributes.rr_mediaMuted = n2.muted;
    mediaAttributes.rr_mediaLoop = n2.loop;
    mediaAttributes.rr_mediaVolume = n2.volume;
  }
  if (!newlyAddedElement) {
    if (n2.scrollLeft) {
      attributes.rr_scrollLeft = n2.scrollLeft;
    }
    if (n2.scrollTop) {
      attributes.rr_scrollTop = n2.scrollTop;
    }
  }
  if (needBlock) {
    const { width, height } = n2.getBoundingClientRect();
    attributes = {
      class: attributes.class,
      rr_width: `${width}px`,
      rr_height: `${height}px`
    };
  }
  if (tagName === "iframe" && !keepIframeSrcFn(attributes.src)) {
    if (!n2.contentDocument) {
      attributes.rr_src = attributes.src;
    }
    delete attributes.src;
  }
  let isCustomElement;
  try {
    if (customElements.get(tagName)) isCustomElement = true;
  } catch (e2) {
  }
  return {
    type: NodeType$3.Element,
    tagName,
    attributes,
    childNodes: [],
    isSVG: isSVGElement(n2) || void 0,
    needBlock,
    rootId,
    isCustom: isCustomElement
  };
}
function lowerIfExists(maybeAttr) {
  if (maybeAttr === void 0 || maybeAttr === null) {
    return "";
  } else {
    return maybeAttr.toLowerCase();
  }
}
function slimDOMExcluded(sn, slimDOMOptions) {
  if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {
    return true;
  } else if (sn.type === NodeType$3.Element) {
    if (slimDOMOptions.script && // script tag
    (sn.tagName === "script" || // (module)preload link
    sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") && sn.attributes.as === "script" || // prefetch link
    sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && extractFileExtension(sn.attributes.href) === "js")) {
      return true;
    } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(
      /^msapplication-tile(image|color)$/
    ) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {
      return true;
    } else if (sn.tagName === "meta") {
      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
        return true;
      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)
      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {
        return true;
      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {
        return true;
      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {
        return true;
      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {
        return true;
      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {
        return true;
      }
    }
  }
  return false;
}
function serializeNodeWithId(n2, options) {
  const {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild = false,
    inlineStylesheet = true,
    maskInputOptions = {},
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions = {},
    inlineImages = false,
    recordCanvas = false,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout = 5e3,
    onStylesheetLoad,
    stylesheetLoadTimeout = 5e3,
    keepIframeSrcFn = () => false,
    newlyAddedElement = false,
    cssCaptured = false
  } = options;
  let { needsMask } = options;
  let { preserveWhiteSpace = true } = options;
  if (!needsMask) {
    const checkAncestors = needsMask === void 0;
    needsMask = needMaskingText(
      n2,
      maskTextClass,
      maskTextSelector,
      checkAncestors
    );
  }
  const _serializedNode = serializeNode(n2, {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement,
    cssCaptured
  });
  if (!_serializedNode) {
    console.warn(n2, "not serialized");
    return null;
  }
  let id;
  if (mirror2.hasNode(n2)) {
    id = mirror2.getId(n2);
  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\s+|\s+$/gm, "").length) {
    id = IGNORED_NODE;
  } else {
    id = genId();
  }
  const serializedNode = Object.assign(_serializedNode, { id });
  mirror2.add(n2, serializedNode);
  if (id === IGNORED_NODE) {
    return null;
  }
  if (onSerialize) {
    onSerialize(n2);
  }
  let recordChild = !skipChild;
  if (serializedNode.type === NodeType$3.Element) {
    recordChild = recordChild && !serializedNode.needBlock;
    delete serializedNode.needBlock;
    const shadowRootEl = index$1.shadowRoot(n2);
    if (shadowRootEl && isNativeShadowDom(shadowRootEl))
      serializedNode.isShadowHost = true;
  }
  if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {
    if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === "head") {
      preserveWhiteSpace = false;
    }
    const bypassOptions = {
      doc,
      mirror: mirror2,
      blockClass,
      blockSelector,
      needsMask,
      maskTextClass,
      maskTextSelector,
      skipChild,
      inlineStylesheet,
      maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOMOptions,
      dataURLOptions,
      inlineImages,
      recordCanvas,
      preserveWhiteSpace,
      onSerialize,
      onIframeLoad,
      iframeLoadTimeout,
      onStylesheetLoad,
      stylesheetLoadTimeout,
      keepIframeSrcFn,
      cssCaptured: false
    };
    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "textarea" && serializedNode.attributes.value !== void 0) ;
    else {
      if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === "string") {
        bypassOptions.cssCaptured = true;
      }
      for (const childN of Array.from(index$1.childNodes(n2))) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
    let shadowRootEl = null;
    if (isElement(n2) && (shadowRootEl = index$1.shadowRoot(n2))) {
      for (const childN of Array.from(index$1.childNodes(shadowRootEl))) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          isNativeShadowDom(shadowRootEl) && (serializedChildNode.isShadow = true);
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
  }
  const parent = index$1.parentNode(n2);
  if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {
    serializedNode.isShadow = true;
  }
  if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "iframe") {
    onceIframeLoaded(
      n2,
      () => {
        const iframeDoc = n2.contentDocument;
        if (iframeDoc && onIframeLoad) {
          const serializedIframeNode = serializeNodeWithId(iframeDoc, {
            doc: iframeDoc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            needsMask,
            maskTextClass,
            maskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedIframeNode) {
            onIframeLoad(
              n2,
              serializedIframeNode
            );
          }
        }
      },
      iframeLoadTimeout
    );
  }
  if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "link" && typeof serializedNode.attributes.rel === "string" && (serializedNode.attributes.rel === "stylesheet" || serializedNode.attributes.rel === "preload" && typeof serializedNode.attributes.href === "string" && extractFileExtension(serializedNode.attributes.href) === "css")) {
    onceStylesheetLoaded(
      n2,
      () => {
        if (onStylesheetLoad) {
          const serializedLinkNode = serializeNodeWithId(n2, {
            doc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            needsMask,
            maskTextClass,
            maskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedLinkNode) {
            onStylesheetLoad(
              n2,
              serializedLinkNode
            );
          }
        }
      },
      stylesheetLoadTimeout
    );
  }
  return serializedNode;
}
function snapshot(n2, options) {
  const {
    mirror: mirror2 = new Mirror(),
    blockClass = "rr-block",
    blockSelector = null,
    maskTextClass = "rr-mask",
    maskTextSelector = null,
    inlineStylesheet = true,
    inlineImages = false,
    recordCanvas = false,
    maskAllInputs = false,
    maskTextFn,
    maskInputFn,
    slimDOM = false,
    dataURLOptions,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn = () => false
  } = options || {};
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : maskAllInputs === false ? {
    password: true
  } : maskAllInputs;
  const slimDOMOptions = slimDOM === true || slimDOM === "all" ? (
    // if true: set of sensible options that should not throw away any information
    {
      script: true,
      comment: true,
      headFavicon: true,
      headWhitespace: true,
      headMetaDescKeywords: slimDOM === "all",
      // destructive
      headMetaSocial: true,
      headMetaRobots: true,
      headMetaHttpEquiv: true,
      headMetaAuthorship: true,
      headMetaVerification: true
    }
  ) : slimDOM === false ? {} : slimDOM;
  return serializeNodeWithId(n2, {
    doc: n2,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild: false,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn,
    newlyAddedElement: false
  });
}
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace$1(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var picocolors_browser$1 = { exports: {} };
var x$1 = String;
var create$1 = function() {
  return { isColorSupported: false, reset: x$1, bold: x$1, dim: x$1, italic: x$1, underline: x$1, inverse: x$1, hidden: x$1, strikethrough: x$1, black: x$1, red: x$1, green: x$1, yellow: x$1, blue: x$1, magenta: x$1, cyan: x$1, white: x$1, gray: x$1, bgBlack: x$1, bgRed: x$1, bgGreen: x$1, bgYellow: x$1, bgBlue: x$1, bgMagenta: x$1, bgCyan: x$1, bgWhite: x$1 };
};
picocolors_browser$1.exports = create$1();
picocolors_browser$1.exports.createColors = create$1;
var picocolors_browserExports$1 = picocolors_browser$1.exports;
const __viteBrowserExternal$2 = {};
const __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal$2
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);
let pico$1 = picocolors_browserExports$1;
let terminalHighlight$1$1 = require$$2$1;
let CssSyntaxError$3$1 = class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin22) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin22) {
      this.plugin = plugin22;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css = this.source;
    if (color == null) color = pico$1.isColorSupported;
    if (terminalHighlight$1$1) {
      if (color) css = terminalHighlight$1$1(css);
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold, gray, red } = pico$1.createColors(true);
      mark = (text) => bold(red(text));
      aside = (text) => gray(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index2) => {
      let number = start + 1 + index2;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join("\n");
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = "\n\n" + code + "\n";
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError$1 = CssSyntaxError$3$1;
CssSyntaxError$3$1.default = CssSyntaxError$3$1;
var symbols$1 = {};
symbols$1.isClean = Symbol("isClean");
symbols$1.my = Symbol("my");
const DEFAULT_RAW$1 = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize$1(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2$1 = class Stringifier {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node2, semicolon) {
    let name = "@" + node2.name;
    let params = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name += node2.raws.afterName;
    } else if (params) {
      name += " ";
    }
    if (node2.nodes) {
      this.block(node2, name + params);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name + params + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last = node2.nodes.length - 1;
    while (last > 0) {
      if (node2.nodes[last].type !== "comment") break;
      last -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW$1[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize$1(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW$1[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier$1 = Stringifier$2$1;
Stringifier$2$1.default = Stringifier$2$1;
let Stringifier$1$1 = stringifier$1;
function stringify$4$1(node2, builder) {
  let str = new Stringifier$1$1(builder);
  str.stringify(node2);
}
var stringify_1$1 = stringify$4$1;
stringify$4$1.default = stringify$4$1;
let { isClean: isClean$2$1, my: my$2$1 } = symbols$1;
let CssSyntaxError$2$1 = cssSyntaxError$1;
let Stringifier2$1 = stringifier$1;
let stringify$3$1 = stringify_1$1;
function cloneNode$1(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode$1(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode$1(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
let Node$4$1 = class Node2 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2$1] = false;
    this[my$2$1] = true;
    for (let name in defaults) {
      if (name === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s2 = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode$1(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2$1(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2$1]) {
      this[isClean$2$1] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2$1] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
    }
    return pos;
  }
  positionInside(index2, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i2 = 0; i2 < index2; i2++) {
      if (string[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) {
        start = this.positionInside(index2, stringRepresentation);
        end = this.positionInside(index2 + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier2$1();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        continue;
      }
      if (name === "parent" || name === "proxyCache") continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3$1) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node$1 = Node$4$1;
Node$4$1.default = Node$4$1;
let Node$3$1 = node$1;
let Declaration$4$1 = class Declaration extends Node$3$1 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration$1 = Declaration$4$1;
Declaration$4$1.default = Declaration$4$1;
let urlAlphabet$1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet$1 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1$1 = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet$1[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure$1 = { nanoid: nanoid$1$1, customAlphabet: customAlphabet$1 };
let { SourceMapConsumer: SourceMapConsumer$2$1, SourceMapGenerator: SourceMapGenerator$2$1 } = require$$2$1;
let { existsSync: existsSync$1, readFileSync: readFileSync$1 } = require$$2$1;
let { dirname: dirname$1$1, join: join$1 } = require$$2$1;
function fromBase64$1(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2$1 = class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1$1(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2$1(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64$1(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map) {
    if (typeof map !== "object") return false;
    return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments) return;
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname$1$1(path);
    if (existsSync$1(path)) {
      this.mapFile = path;
      return readFileSync$1(path, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer$2$1) {
        return SourceMapGenerator$2$1.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2$1) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join$1(dirname$1$1(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap$1 = PreviousMap$2$1;
PreviousMap$2$1.default = PreviousMap$2$1;
let { SourceMapConsumer: SourceMapConsumer$1$1, SourceMapGenerator: SourceMapGenerator$1$1 } = require$$2$1;
let { fileURLToPath: fileURLToPath$1, pathToFileURL: pathToFileURL$1$1 } = require$$2$1;
let { isAbsolute: isAbsolute$1, resolve: resolve$1$1 } = require$$2$1;
let { nanoid: nanoid$2 } = nonSecure$1;
let terminalHighlight$2 = require$$2$1;
let CssSyntaxError$1$1 = cssSyntaxError$1;
let PreviousMap$1$1 = previousMap$1;
let fromOffsetCache$1 = Symbol("fromOffsetCache");
let sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);
let pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);
let Input$4$1 = class Input {
  constructor(css, opts = {}) {
    if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1$1 || /^\w+:\/\//.test(opts.from) || isAbsolute$1(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1$1(opts.from);
      }
    }
    if (pathAvailable$1$1 && sourceMapAvailable$1$1) {
      let map = new PreviousMap$1$1(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid$2(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result2, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1$1) {
        result2.input.url = pathToFileURL$1$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache$1]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache$1] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache$1];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({ column, line });
    if (!from.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute$1(from.source)) {
      fromUrl = pathToFileURL$1$1(from.source);
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath$1) {
        result2.file = fileURLToPath$1(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name of ["hasBOM", "css", "file", "id"]) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input$1 = Input$4$1;
Input$4$1.default = Input$4$1;
if (terminalHighlight$2 && terminalHighlight$2.registerInput) {
  terminalHighlight$2.registerInput(Input$4$1);
}
let { SourceMapConsumer: SourceMapConsumer$3, SourceMapGenerator: SourceMapGenerator$3 } = require$$2$1;
let { dirname: dirname$2, relative: relative$1, resolve: resolve$2, sep: sep$1 } = require$$2$1;
let { pathToFileURL: pathToFileURL$2 } = require$$2$1;
let Input$3$1 = input$1;
let sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);
let pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);
let MapGenerator$2$1 = class MapGenerator {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname$2(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer$3(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator$3.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator$3({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator$3({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf("\n");
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname$2(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from = dirname$2(resolve$2(from, this.mapOpts.annotation));
    }
    let path = relative$1(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map = node2.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input2 = new Input$3$1(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from = node2.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL$2) {
      let fileURL = pathToFileURL$2(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep$1 === "\\") {
      path = path.replace(/\\/g, "/");
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
};
var mapGenerator$1 = MapGenerator$2$1;
let Node$2$1 = node$1;
let Comment$4$1 = class Comment extends Node$2$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment$1 = Comment$4$1;
Comment$4$1.default = Comment$4$1;
let { isClean: isClean$1$1, my: my$1$1 } = symbols$1;
let Declaration$3$1 = declaration$1;
let Comment$3$1 = comment$1;
let Node$1$1 = node$1;
let parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;
function cleanSource$1(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markDirtyUp$1(node2) {
  node2[isClean$1$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markDirtyUp$1(i2);
    }
  }
}
let Container$7$1 = class Container extends Node$1$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index2, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index2 = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index2], index2);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index2) => i2(child.toProxy(), index2);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex < index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex <= index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource$1(parse$4$1(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3$1(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4$1(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4$1(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3$1(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1$1]) Container.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1$1]) markDirtyUp$1(i2);
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (index2 >= child) {
        this.indexes[id] = index2 - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7$1.registerParse = (dependant) => {
  parse$4$1 = dependant;
};
Container$7$1.registerRule = (dependant) => {
  Rule$4$1 = dependant;
};
Container$7$1.registerAtRule = (dependant) => {
  AtRule$4$1 = dependant;
};
Container$7$1.registerRoot = (dependant) => {
  Root$6$1 = dependant;
};
var container$1 = Container$7$1;
Container$7$1.default = Container$7$1;
Container$7$1.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4$1.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4$1.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3$1.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3$1.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6$1.prototype);
  }
  node2[my$1$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7$1.rebuild(child);
    });
  }
};
let Container$6$1 = container$1;
let LazyResult$4$1, Processor$3$1;
let Document$3$1 = class Document2 extends Container$6$1 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);
    return lazy.stringify();
  }
};
Document$3$1.registerLazyResult = (dependant) => {
  LazyResult$4$1 = dependant;
};
Document$3$1.registerProcessor = (dependant) => {
  Processor$3$1 = dependant;
};
var document$1$1 = Document$3$1;
Document$3$1.default = Document$3$1;
let printed$1 = {};
var warnOnce$2$1 = function warnOnce(message) {
  if (printed$1[message]) return;
  printed$1[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Warning$2$1 = class Warning {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning$1 = Warning$2$1;
Warning$2$1.default = Warning$2$1;
let Warning$1$1 = warning$1;
let Result$3$1 = class Result {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result$1 = Result$3$1;
Result$3$1.default = Result$3$1;
const SINGLE_QUOTE$1 = "'".charCodeAt(0);
const DOUBLE_QUOTE$1 = '"'.charCodeAt(0);
const BACKSLASH$1 = "\\".charCodeAt(0);
const SLASH$1 = "/".charCodeAt(0);
const NEWLINE$1 = "\n".charCodeAt(0);
const SPACE$1 = " ".charCodeAt(0);
const FEED$1 = "\f".charCodeAt(0);
const TAB$1 = "	".charCodeAt(0);
const CR$1 = "\r".charCodeAt(0);
const OPEN_SQUARE$1 = "[".charCodeAt(0);
const CLOSE_SQUARE$1 = "]".charCodeAt(0);
const OPEN_PARENTHESES$1 = "(".charCodeAt(0);
const CLOSE_PARENTHESES$1 = ")".charCodeAt(0);
const OPEN_CURLY$1 = "{".charCodeAt(0);
const CLOSE_CURLY$1 = "}".charCodeAt(0);
const SEMICOLON$1 = ";".charCodeAt(0);
const ASTERISK$1 = "*".charCodeAt(0);
const COLON$1 = ":".charCodeAt(0);
const AT$1 = "@".charCodeAt(0);
const RE_AT_END$1 = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END$1 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET$1 = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE$1 = /[\da-f]/i;
var tokenize$1 = function tokenizer(input2, options = {}) {
  let css = input2.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, next, quote, content, escape;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE$1:
      case SPACE$1:
      case TAB$1:
      case CR$1:
      case FEED$1: {
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);
        currentToken = ["space", css.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE$1:
      case CLOSE_SQUARE$1:
      case OPEN_CURLY$1:
      case CLOSE_CURLY$1:
      case COLON$1:
      case SEMICOLON$1:
      case CLOSE_PARENTHESES$1: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES$1: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH$1) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css.indexOf(")", pos + 1);
          content = css.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET$1.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE$1:
      case DOUBLE_QUOTE$1: {
        quote = code === SINGLE_QUOTE$1 ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === BACKSLASH$1) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT$1: {
        RE_AT_END$1.lastIndex = pos + 1;
        RE_AT_END$1.test(css);
        if (RE_AT_END$1.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END$1.lastIndex - 2;
        }
        currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH$1: {
        next = pos;
        escape = true;
        while (css.charCodeAt(next + 1) === BACKSLASH$1) {
          next += 1;
          escape = !escape;
        }
        code = css.charCodeAt(next + 1);
        if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {
          next += 1;
          if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE$1.test(css.charAt(next + 1))) {
              next += 1;
            }
            if (css.charCodeAt(next + 1) === SPACE$1) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {
          next = css.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END$1.lastIndex = pos + 1;
          RE_WORD_END$1.test(css);
          if (RE_WORD_END$1.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END$1.lastIndex - 2;
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let Container$5$1 = container$1;
let AtRule$3$1 = class AtRule extends Container$5$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule$1 = AtRule$3$1;
AtRule$3$1.default = AtRule$3$1;
Container$5$1.registerAtRule(AtRule$3$1);
let Container$4$1 = container$1;
let LazyResult$3$1, Processor$2$1;
let Root$5$1 = class Root extends Container$4$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index2 = this.index(child);
    if (!ignore && index2 === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index2].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);
    return lazy.stringify();
  }
};
Root$5$1.registerLazyResult = (dependant) => {
  LazyResult$3$1 = dependant;
};
Root$5$1.registerProcessor = (dependant) => {
  Processor$2$1 = dependant;
};
var root$1 = Root$5$1;
Root$5$1.default = Root$5$1;
Container$4$1.registerRoot(Root$5$1);
let list$2$1 = {
  comma(string) {
    return list$2$1.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2$1.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === "\\") {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1$1 = list$2$1;
list$2$1.default = list$2$1;
let Container$3$1 = container$1;
let list$1$1 = list_1$1;
let Rule$3$1 = class Rule extends Container$3$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule$1 = Rule$3$1;
Rule$3$1.default = Rule$3$1;
Container$3$1.registerRule(Rule$3$1);
let Declaration$2$1 = declaration$1;
let tokenizer2$1 = tokenize$1;
let Comment$2$1 = comment$1;
let AtRule$2$1 = atRule$1;
let Root$4$1 = root$1;
let Rule$2$1 = rule$1;
const SAFE_COMMENT_NEIGHBOR$1 = {
  empty: true,
  space: true
};
function findLastWithPosition$1(tokens) {
  for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
    let token = tokens[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1$1 = class Parser {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4$1();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$2$1();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node2, "params", params);
      if (last) {
        token = params[params.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens) {
    let brackets = 0;
    let token, type, prev;
    for (let [i2, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$2$1();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node2.text = "";
      node2.raws.left = text;
      node2.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer2$1(this.input);
  }
  decl(tokens, customProperty) {
    let node2 = new Declaration$2$1();
    this.init(node2, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node2.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition$1(tokens)
    );
    node2.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1) this.unknownWord(tokens);
      node2.raws.before += tokens.shift()[1];
    }
    node2.source.start = this.getPosition(tokens[0][2]);
    node2.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens, i2);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node2.important = true;
          node2.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$2$1();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length; i2 += 1) {
      token = tokens[i2];
      type = token[0];
      if (type === "space" && i2 === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
        next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node2 = new Rule$2$1();
    this.init(node2, tokens[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node2, "selector", tokens);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result2 = "";
    for (let i2 = from; i2 < tokens.length; i2++) {
      result2 += tokens[i2][1];
    }
    tokens.splice(from, tokens.length - from);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser$1 = Parser$1$1;
let Container$2$1 = container$1;
let Parser2$1 = parser$1;
let Input$2$1 = input$1;
function parse$3$1(css, opts) {
  let input2 = new Input$2$1(css, opts);
  let parser2 = new Parser2$1(input2);
  try {
    parser2.parse();
  } catch (e2) {
    if (true) {
      if (e2.name === "CssSyntaxError" && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
        } else if (/\.sass/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
        } else if (/\.less$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
        }
      }
    }
    throw e2;
  }
  return parser2.root;
}
var parse_1$1 = parse$3$1;
parse$3$1.default = parse$3$1;
Container$2$1.registerParse(parse$3$1);
let { isClean: isClean$3, my: my$3 } = symbols$1;
let MapGenerator$1$1 = mapGenerator$1;
let stringify$2$1 = stringify_1$1;
let Container$1$1 = container$1;
let Document$2$1 = document$1$1;
let warnOnce$1$1 = warnOnce$2$1;
let Result$2$1 = result$1;
let parse$2$1 = parse_1$1;
let Root$3$1 = root$1;
const TYPE_TO_CLASS_NAME$1 = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS$1 = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS$1 = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN$1 = 0;
function isPromise$1(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents$1(node2) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME$1[node2.type];
  if (node2.type === "decl") {
    key = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key = node2.name.toLowerCase();
  }
  if (key && node2.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN$1,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node2.append) {
    return [type, CHILDREN$1, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack$1(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN$1, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN$1, "RootExit"];
  } else {
    events = getEvents$1(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks$1(node2) {
  node2[isClean$3] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks$1(i2));
  return node2;
}
let postcss$2$1 = {};
let LazyResult$2$1 = class LazyResult {
  constructor(processor2, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
      root2 = cleanMarks$1(css);
    } else if (css instanceof LazyResult || css instanceof Result$2$1) {
      root2 = cleanMarks$1(css.root);
      if (css.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser2 = parse$2$1;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my$3]) {
        Container$1$1.rebuild(root2);
      }
    }
    this.result = new Result$2$1(processor2, root2, opts);
    this.helpers = { ...postcss$2$1, postcss: postcss$2$1, result: this.result };
    this.plugins = this.processor.plugins.map((plugin22) => {
      if (typeof plugin22 === "object" && plugin22.prepare) {
        return { ...plugin22, ...plugin22.prepare(this.result) };
      } else {
        return plugin22;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin22 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin22.postcssPlugin;
        error.setMessage();
      } else if (plugin22.postcssVersion) {
        if (true) {
          let pluginName = plugin22.postcssPlugin;
          let pluginVer = plugin22.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a2 = pluginVer.split(".");
          let b = runtimeVer.split(".");
          if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {
            console.error(
              "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
            );
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin22, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin22, cb]);
    };
    for (let plugin22 of this.plugins) {
      if (typeof plugin22 === "object") {
        for (let event in plugin22) {
          if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin22.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS$1[event]) {
            if (typeof plugin22[event] === "object") {
              for (let filter in plugin22[event]) {
                if (filter === "*") {
                  add(plugin22, event, plugin22[event][filter]);
                } else {
                  add(
                    plugin22,
                    event + "-" + filter.toLowerCase(),
                    plugin22[event][filter]
                  );
                }
              }
            } else if (typeof plugin22[event] === "function") {
              add(plugin22, event, plugin22[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin22 = this.plugins[i2];
      let promise = this.runOnRoot(plugin22);
      if (isPromise$1(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean$3]) {
        root2[isClean$3] = true;
        let stack = [toStack$1(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise$1(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e2, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin22, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin22;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin22) {
    this.result.lastPlugin = plugin22;
    try {
      if (typeof plugin22 === "object" && plugin22.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin22.Once(root2, this.helpers)
          );
          if (isPromise$1(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin22.Once(this.result.root, this.helpers);
      } else if (typeof plugin22 === "function") {
        return plugin22(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2$1;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator$1$1(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin22 of this.plugins) {
      let promise = this.runOnRoot(plugin22);
      if (isPromise$1(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean$3]) {
        root2[isClean$3] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this.opts)) {
        warnOnce$1$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin22, visitor] of visitors) {
      this.result.lastPlugin = plugin22;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise$1(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit2 = stack[stack.length - 1];
    let { node: node2, visitors } = visit2;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
      let [plugin22, visitor] = visitors[visit2.visitorIndex];
      visit2.visitorIndex += 1;
      if (visit2.visitorIndex === visitors.length) {
        visit2.visitors = [];
        visit2.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin22;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2);
      }
    }
    if (visit2.iterator !== 0) {
      let iterator = visit2.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean$3]) {
          child[isClean$3] = true;
          stack.push(toStack$1(child));
          return;
        }
      }
      visit2.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit2.events;
    while (visit2.eventIndex < events.length) {
      let event = events[visit2.eventIndex];
      visit2.eventIndex += 1;
      if (event === CHILDREN$1) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean$3] = true;
          visit2.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit2.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean$3] = true;
    let events = getEvents$1(node2);
    for (let event of events) {
      if (event === CHILDREN$1) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean$3]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2$1.registerPostcss = (dependant) => {
  postcss$2$1 = dependant;
};
var lazyResult$1 = LazyResult$2$1;
LazyResult$2$1.default = LazyResult$2$1;
Root$3$1.registerLazyResult(LazyResult$2$1);
Document$2$1.registerLazyResult(LazyResult$2$1);
let MapGenerator2$1 = mapGenerator$1;
let stringify$1$1 = stringify_1$1;
let warnOnce2$1 = warnOnce$2$1;
let parse$1$1 = parse_1$1;
const Result$1$1 = result$1;
let NoWorkResult$1$1 = class NoWorkResult {
  constructor(processor2, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1$1;
    this.result = new Result$1$1(this._processor, root2, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator2$1(str, root2, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this._opts)) {
        warnOnce2$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult$1 = NoWorkResult$1$1;
NoWorkResult$1$1.default = NoWorkResult$1$1;
let NoWorkResult2$1 = noWorkResult$1;
let LazyResult$1$1 = lazyResult$1;
let Document$1$1 = document$1$1;
let Root$2$1 = root$1;
let Processor$1$1 = class Processor {
  constructor(plugins = []) {
    this.version = "8.4.38";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (true) {
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
        }
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult2$1(this, css, opts);
    } else {
      return new LazyResult$1$1(this, css, opts);
    }
  }
  use(plugin22) {
    this.plugins = this.plugins.concat(this.normalize([plugin22]));
    return this;
  }
};
var processor$1 = Processor$1$1;
Processor$1$1.default = Processor$1$1;
Root$2$1.registerProcessor(Processor$1$1);
Document$1$1.registerProcessor(Processor$1$1);
let Declaration$1$1 = declaration$1;
let PreviousMap2$1 = previousMap$1;
let Comment$1$1 = comment$1;
let AtRule$1$1 = atRule$1;
let Input$1$1 = input$1;
let Root$1$1 = root$1;
let Rule$1$1 = rule$1;
function fromJSON$1$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n2) => fromJSON$1$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap2$1.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$1$1(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1$1 = fromJSON$1$1;
fromJSON$1$1.default = fromJSON$1$1;
let CssSyntaxError2$1 = cssSyntaxError$1;
let Declaration2$1 = declaration$1;
let LazyResult2$1 = lazyResult$1;
let Container2$1 = container$1;
let Processor2$1 = processor$1;
let stringify$5 = stringify_1$1;
let fromJSON$2 = fromJSON_1$1;
let Document22 = document$1$1;
let Warning2$1 = warning$1;
let Comment2$1 = comment$1;
let AtRule2$1 = atRule$1;
let Result2$1 = result$1;
let Input2$1 = input$1;
let parse$5 = parse_1$1;
let list$3 = list_1$1;
let Rule2$1 = rule$1;
let Root2$1 = root$1;
let Node2$1 = node$1;
function postcss$3(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor2$1(plugins);
}
postcss$3.plugin = function plugin(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name + ":  postcss.plugin . :\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor2$1().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function(css, processOpts, pluginOpts) {
    return postcss$3([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss$3.stringify = stringify$5;
postcss$3.parse = parse$5;
postcss$3.fromJSON = fromJSON$2;
postcss$3.list = list$3;
postcss$3.comment = (defaults) => new Comment2$1(defaults);
postcss$3.atRule = (defaults) => new AtRule2$1(defaults);
postcss$3.decl = (defaults) => new Declaration2$1(defaults);
postcss$3.rule = (defaults) => new Rule2$1(defaults);
postcss$3.root = (defaults) => new Root2$1(defaults);
postcss$3.document = (defaults) => new Document22(defaults);
postcss$3.CssSyntaxError = CssSyntaxError2$1;
postcss$3.Declaration = Declaration2$1;
postcss$3.Container = Container2$1;
postcss$3.Processor = Processor2$1;
postcss$3.Document = Document22;
postcss$3.Comment = Comment2$1;
postcss$3.Warning = Warning2$1;
postcss$3.AtRule = AtRule2$1;
postcss$3.Result = Result2$1;
postcss$3.Input = Input2$1;
postcss$3.Rule = Rule2$1;
postcss$3.Root = Root2$1;
postcss$3.Node = Node2$1;
LazyResult2$1.registerPostcss(postcss$3);
var postcss_1$1 = postcss$3;
postcss$3.default = postcss$3;
const postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);
postcss$1$1.stringify;
postcss$1$1.fromJSON;
postcss$1$1.plugin;
postcss$1$1.parse;
postcss$1$1.list;
postcss$1$1.document;
postcss$1$1.comment;
postcss$1$1.atRule;
postcss$1$1.rule;
postcss$1$1.decl;
postcss$1$1.root;
postcss$1$1.CssSyntaxError;
postcss$1$1.Declaration;
postcss$1$1.Container;
postcss$1$1.Processor;
postcss$1$1.Document;
postcss$1$1.Comment;
postcss$1$1.Warning;
postcss$1$1.AtRule;
postcss$1$1.Result;
postcss$1$1.Input;
postcss$1$1.Rule;
postcss$1$1.Root;
postcss$1$1.Node;
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var picocolors_browser = { exports: {} };
var x = String;
var create = function() {
  return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
};
picocolors_browser.exports = create();
picocolors_browser.exports.createColors = create;
var picocolors_browserExports = picocolors_browser.exports;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
let pico = picocolors_browserExports;
let terminalHighlight$1 = require$$2;
let CssSyntaxError$3 = class CssSyntaxError2 extends Error {
  constructor(message, line, column, source, file, plugin22) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin22) {
      this.plugin = plugin22;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError2);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css = this.source;
    if (color == null) color = pico.isColorSupported;
    if (terminalHighlight$1) {
      if (color) css = terminalHighlight$1(css);
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold, gray, red } = pico.createColors(true);
      mark = (text) => bold(red(text));
      aside = (text) => gray(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index2) => {
      let number = start + 1 + index2;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join("\n");
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = "\n\n" + code + "\n";
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError = CssSyntaxError$3;
CssSyntaxError$3.default = CssSyntaxError$3;
var symbols = {};
symbols.isClean = Symbol("isClean");
symbols.my = Symbol("my");
const DEFAULT_RAW = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2 = class Stringifier2 {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node2, semicolon) {
    let name = "@" + node2.name;
    let params = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name += node2.raws.afterName;
    } else if (params) {
      name += " ";
    }
    if (node2.nodes) {
      this.block(node2, name + params);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name + params + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last = node2.nodes.length - 1;
    while (last > 0) {
      if (node2.nodes[last].type !== "comment") break;
      last -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier = Stringifier$2;
Stringifier$2.default = Stringifier$2;
let Stringifier$1 = stringifier;
function stringify$4(node2, builder) {
  let str = new Stringifier$1(builder);
  str.stringify(node2);
}
var stringify_1 = stringify$4;
stringify$4.default = stringify$4;
let { isClean: isClean$2, my: my$2 } = symbols;
let CssSyntaxError$2 = cssSyntaxError;
let Stringifier22 = stringifier;
let stringify$3 = stringify_1;
function cloneNode(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
let Node$4 = class Node3 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2] = false;
    this[my$2] = true;
    for (let name in defaults) {
      if (name === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s2 = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2]) {
      this[isClean$2] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
    }
    return pos;
  }
  positionInside(index2, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i2 = 0; i2 < index2; i2++) {
      if (string[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) {
        start = this.positionInside(index2, stringRepresentation);
        end = this.positionInside(index2 + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier22();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        continue;
      }
      if (name === "parent" || name === "proxyCache") continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node = Node$4;
Node$4.default = Node$4;
let Node$3 = node;
let Declaration$4 = class Declaration2 extends Node$3 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration = Declaration$4;
Declaration$4.default = Declaration$4;
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1 = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure = { nanoid: nanoid$1, customAlphabet };
let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require$$2;
let { existsSync, readFileSync } = require$$2;
let { dirname: dirname$1, join } = require$$2;
function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2 = class PreviousMap2 {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map) {
    if (typeof map !== "object") return false;
    return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments) return;
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname$1(path);
    if (existsSync(path)) {
      this.mapFile = path;
      return readFileSync(path, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer$2) {
        return SourceMapGenerator$2.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join(dirname$1(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap = PreviousMap$2;
PreviousMap$2.default = PreviousMap$2;
let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require$$2;
let { fileURLToPath, pathToFileURL: pathToFileURL$1 } = require$$2;
let { isAbsolute, resolve: resolve$1 } = require$$2;
let { nanoid } = nonSecure;
let terminalHighlight = require$$2;
let CssSyntaxError$1 = cssSyntaxError;
let PreviousMap$1 = previousMap;
let fromOffsetCache = Symbol("fromOffsetCache");
let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
let pathAvailable$1 = Boolean(resolve$1 && isAbsolute);
let Input$4 = class Input2 {
  constructor(css, opts = {}) {
    if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1(opts.from);
      }
    }
    if (pathAvailable$1 && sourceMapAvailable$1) {
      let map = new PreviousMap$1(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result2, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1) {
        result2.input.url = pathToFileURL$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({ column, line });
    if (!from.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL$1(from.source);
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath) {
        result2.file = fileURLToPath(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name of ["hasBOM", "css", "file", "id"]) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input = Input$4;
Input$4.default = Input$4;
if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input$4);
}
let { SourceMapConsumer, SourceMapGenerator } = require$$2;
let { dirname, relative, resolve, sep } = require$$2;
let { pathToFileURL } = require$$2;
let Input$3 = input;
let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
let pathAvailable = Boolean(dirname && resolve && relative && sep);
let MapGenerator$2 = class MapGenerator2 {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf("\n");
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from = dirname(resolve(from, this.mapOpts.annotation));
    }
    let path = relative(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map = node2.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input2 = new Input$3(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from = node2.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep === "\\") {
      path = path.replace(/\\/g, "/");
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
};
var mapGenerator = MapGenerator$2;
let Node$2 = node;
let Comment$4 = class Comment2 extends Node$2 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment = Comment$4;
Comment$4.default = Comment$4;
let { isClean: isClean$1, my: my$1 } = symbols;
let Declaration$3 = declaration;
let Comment$3 = comment;
let Node$1 = node;
let parse$4, Rule$4, AtRule$4, Root$6;
function cleanSource(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markDirtyUp(node2) {
  node2[isClean$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markDirtyUp(i2);
    }
  }
}
let Container$7 = class Container2 extends Node$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index2, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index2 = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index2], index2);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index2) => i2(child.toProxy(), index2);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex < index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex <= index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource(parse$4(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1]) Container2.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1]) markDirtyUp(i2);
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (index2 >= child) {
        this.indexes[id] = index2 - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7.registerParse = (dependant) => {
  parse$4 = dependant;
};
Container$7.registerRule = (dependant) => {
  Rule$4 = dependant;
};
Container$7.registerAtRule = (dependant) => {
  AtRule$4 = dependant;
};
Container$7.registerRoot = (dependant) => {
  Root$6 = dependant;
};
var container = Container$7;
Container$7.default = Container$7;
Container$7.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6.prototype);
  }
  node2[my$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7.rebuild(child);
    });
  }
};
let Container$6 = container;
let LazyResult$4, Processor$3;
let Document$3 = class Document23 extends Container$6 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4(new Processor$3(), this, opts);
    return lazy.stringify();
  }
};
Document$3.registerLazyResult = (dependant) => {
  LazyResult$4 = dependant;
};
Document$3.registerProcessor = (dependant) => {
  Processor$3 = dependant;
};
var document$1 = Document$3;
Document$3.default = Document$3;
let printed = {};
var warnOnce$2 = function warnOnce2(message) {
  if (printed[message]) return;
  printed[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Warning$2 = class Warning2 {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning = Warning$2;
Warning$2.default = Warning$2;
let Warning$1 = warning;
let Result$3 = class Result2 {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result = Result$3;
Result$3.default = Result$3;
const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = "\\".charCodeAt(0);
const SLASH = "/".charCodeAt(0);
const NEWLINE = "\n".charCodeAt(0);
const SPACE = " ".charCodeAt(0);
const FEED = "\f".charCodeAt(0);
const TAB = "	".charCodeAt(0);
const CR = "\r".charCodeAt(0);
const OPEN_SQUARE = "[".charCodeAt(0);
const CLOSE_SQUARE = "]".charCodeAt(0);
const OPEN_PARENTHESES = "(".charCodeAt(0);
const CLOSE_PARENTHESES = ")".charCodeAt(0);
const OPEN_CURLY = "{".charCodeAt(0);
const CLOSE_CURLY = "}".charCodeAt(0);
const SEMICOLON = ";".charCodeAt(0);
const ASTERISK = "*".charCodeAt(0);
const COLON = ":".charCodeAt(0);
const AT = "@".charCodeAt(0);
const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE = /[\da-f]/i;
var tokenize = function tokenizer2(input2, options = {}) {
  let css = input2.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, next, quote, content, escape;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
        currentToken = ["space", css.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css.indexOf(")", pos + 1);
          content = css.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT: {
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css);
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }
        currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH: {
        next = pos;
        escape = true;
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape = !escape;
        }
        code = css.charCodeAt(next + 1);
        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1;
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css);
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let Container$5 = container;
let AtRule$3 = class AtRule2 extends Container$5 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule = AtRule$3;
AtRule$3.default = AtRule$3;
Container$5.registerAtRule(AtRule$3);
let Container$4 = container;
let LazyResult$3, Processor$2;
let Root$5 = class Root2 extends Container$4 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index2 = this.index(child);
    if (!ignore && index2 === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index2].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3(new Processor$2(), this, opts);
    return lazy.stringify();
  }
};
Root$5.registerLazyResult = (dependant) => {
  LazyResult$3 = dependant;
};
Root$5.registerProcessor = (dependant) => {
  Processor$2 = dependant;
};
var root = Root$5;
Root$5.default = Root$5;
Container$4.registerRoot(Root$5);
let list$2 = {
  comma(string) {
    return list$2.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === "\\") {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1 = list$2;
list$2.default = list$2;
let Container$3 = container;
let list$1 = list_1;
let Rule$3 = class Rule2 extends Container$3 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule = Rule$3;
Rule$3.default = Rule$3;
Container$3.registerRule(Rule$3);
let Declaration$2 = declaration;
let tokenizer22 = tokenize;
let Comment$2 = comment;
let AtRule$2 = atRule;
let Root$4 = root;
let Rule$2 = rule;
const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};
function findLastWithPosition(tokens) {
  for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
    let token = tokens[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1 = class Parser2 {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$2();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node2, "params", params);
      if (last) {
        token = params[params.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens) {
    let brackets = 0;
    let token, type, prev;
    for (let [i2, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$2();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node2.text = "";
      node2.raws.left = text;
      node2.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer22(this.input);
  }
  decl(tokens, customProperty) {
    let node2 = new Declaration$2();
    this.init(node2, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node2.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    );
    node2.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1) this.unknownWord(tokens);
      node2.raws.before += tokens.shift()[1];
    }
    node2.source.start = this.getPosition(tokens[0][2]);
    node2.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens, i2);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node2.important = true;
          node2.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$2();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length; i2 += 1) {
      token = tokens[i2];
      type = token[0];
      if (type === "space" && i2 === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
        next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node2 = new Rule$2();
    this.init(node2, tokens[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node2, "selector", tokens);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result2 = "";
    for (let i2 = from; i2 < tokens.length; i2++) {
      result2 += tokens[i2][1];
    }
    tokens.splice(from, tokens.length - from);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser = Parser$1;
let Container$2 = container;
let Parser22 = parser;
let Input$2 = input;
function parse$3(css, opts) {
  let input2 = new Input$2(css, opts);
  let parser2 = new Parser22(input2);
  try {
    parser2.parse();
  } catch (e2) {
    if (true) {
      if (e2.name === "CssSyntaxError" && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
        } else if (/\.sass/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
        } else if (/\.less$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
        }
      }
    }
    throw e2;
  }
  return parser2.root;
}
var parse_1 = parse$3;
parse$3.default = parse$3;
Container$2.registerParse(parse$3);
let { isClean, my } = symbols;
let MapGenerator$1 = mapGenerator;
let stringify$2 = stringify_1;
let Container$1 = container;
let Document$2 = document$1;
let warnOnce$1 = warnOnce$2;
let Result$2 = result;
let parse$2 = parse_1;
let Root$3 = root;
const TYPE_TO_CLASS_NAME = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN = 0;
function isPromise(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents(node2) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME[node2.type];
  if (node2.type === "decl") {
    key = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key = node2.name.toLowerCase();
  }
  if (key && node2.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node2.append) {
    return [type, CHILDREN, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN, "RootExit"];
  } else {
    events = getEvents(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks(node2) {
  node2[isClean] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks(i2));
  return node2;
}
let postcss$2 = {};
let LazyResult$2 = class LazyResult2 {
  constructor(processor2, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
      root2 = cleanMarks(css);
    } else if (css instanceof LazyResult2 || css instanceof Result$2) {
      root2 = cleanMarks(css.root);
      if (css.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser2 = parse$2;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my]) {
        Container$1.rebuild(root2);
      }
    }
    this.result = new Result$2(processor2, root2, opts);
    this.helpers = { ...postcss$2, postcss: postcss$2, result: this.result };
    this.plugins = this.processor.plugins.map((plugin22) => {
      if (typeof plugin22 === "object" && plugin22.prepare) {
        return { ...plugin22, ...plugin22.prepare(this.result) };
      } else {
        return plugin22;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin22 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin22.postcssPlugin;
        error.setMessage();
      } else if (plugin22.postcssVersion) {
        if (true) {
          let pluginName = plugin22.postcssPlugin;
          let pluginVer = plugin22.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a2 = pluginVer.split(".");
          let b = runtimeVer.split(".");
          if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {
            console.error(
              "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
            );
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin22, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin22, cb]);
    };
    for (let plugin22 of this.plugins) {
      if (typeof plugin22 === "object") {
        for (let event in plugin22) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin22.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin22[event] === "object") {
              for (let filter in plugin22[event]) {
                if (filter === "*") {
                  add(plugin22, event, plugin22[event][filter]);
                } else {
                  add(
                    plugin22,
                    event + "-" + filter.toLowerCase(),
                    plugin22[event][filter]
                  );
                }
              }
            } else if (typeof plugin22[event] === "function") {
              add(plugin22, event, plugin22[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin22 = this.plugins[i2];
      let promise = this.runOnRoot(plugin22);
      if (isPromise(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        let stack = [toStack(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e2, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin22, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin22;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin22) {
    this.result.lastPlugin = plugin22;
    try {
      if (typeof plugin22 === "object" && plugin22.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin22.Once(root2, this.helpers)
          );
          if (isPromise(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin22.Once(this.result.root, this.helpers);
      } else if (typeof plugin22 === "function") {
        return plugin22(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator$1(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin22 of this.plugins) {
      let promise = this.runOnRoot(plugin22);
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this.opts)) {
        warnOnce$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin22, visitor] of visitors) {
      this.result.lastPlugin = plugin22;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit2 = stack[stack.length - 1];
    let { node: node2, visitors } = visit2;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
      let [plugin22, visitor] = visitors[visit2.visitorIndex];
      visit2.visitorIndex += 1;
      if (visit2.visitorIndex === visitors.length) {
        visit2.visitors = [];
        visit2.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin22;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2);
      }
    }
    if (visit2.iterator !== 0) {
      let iterator = visit2.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean]) {
          child[isClean] = true;
          stack.push(toStack(child));
          return;
        }
      }
      visit2.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit2.events;
    while (visit2.eventIndex < events.length) {
      let event = events[visit2.eventIndex];
      visit2.eventIndex += 1;
      if (event === CHILDREN) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean] = true;
          visit2.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit2.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean] = true;
    let events = getEvents(node2);
    for (let event of events) {
      if (event === CHILDREN) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2.registerPostcss = (dependant) => {
  postcss$2 = dependant;
};
var lazyResult = LazyResult$2;
LazyResult$2.default = LazyResult$2;
Root$3.registerLazyResult(LazyResult$2);
Document$2.registerLazyResult(LazyResult$2);
let MapGenerator22 = mapGenerator;
let stringify$1 = stringify_1;
let warnOnce22 = warnOnce$2;
let parse$1 = parse_1;
const Result$1 = result;
let NoWorkResult$1 = class NoWorkResult2 {
  constructor(processor2, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1;
    this.result = new Result$1(this._processor, root2, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator22(str, root2, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this._opts)) {
        warnOnce22(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult = NoWorkResult$1;
NoWorkResult$1.default = NoWorkResult$1;
let NoWorkResult22 = noWorkResult;
let LazyResult$1 = lazyResult;
let Document$1 = document$1;
let Root$2 = root;
let Processor$1 = class Processor2 {
  constructor(plugins = []) {
    this.version = "8.4.38";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (true) {
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
        }
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult22(this, css, opts);
    } else {
      return new LazyResult$1(this, css, opts);
    }
  }
  use(plugin22) {
    this.plugins = this.plugins.concat(this.normalize([plugin22]));
    return this;
  }
};
var processor = Processor$1;
Processor$1.default = Processor$1;
Root$2.registerProcessor(Processor$1);
Document$1.registerProcessor(Processor$1);
let Declaration$1 = declaration;
let PreviousMap22 = previousMap;
let Comment$1 = comment;
let AtRule$1 = atRule;
let Input$1 = input;
let Root$1 = root;
let Rule$1 = rule;
function fromJSON$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n2) => fromJSON$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap22.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$1(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1 = fromJSON$1;
fromJSON$1.default = fromJSON$1;
let CssSyntaxError22 = cssSyntaxError;
let Declaration22 = declaration;
let LazyResult22 = lazyResult;
let Container22 = container;
let Processor22 = processor;
let stringify = stringify_1;
let fromJSON = fromJSON_1;
let Document222 = document$1;
let Warning22 = warning;
let Comment22 = comment;
let AtRule22 = atRule;
let Result22 = result;
let Input22 = input;
let parse = parse_1;
let list = list_1;
let Rule22 = rule;
let Root22 = root;
let Node22 = node;
function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor22(plugins);
}
postcss.plugin = function plugin2(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name + ":  postcss.plugin . :\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor22().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function(css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss.stringify = stringify;
postcss.parse = parse;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = (defaults) => new Comment22(defaults);
postcss.atRule = (defaults) => new AtRule22(defaults);
postcss.decl = (defaults) => new Declaration22(defaults);
postcss.rule = (defaults) => new Rule22(defaults);
postcss.root = (defaults) => new Root22(defaults);
postcss.document = (defaults) => new Document222(defaults);
postcss.CssSyntaxError = CssSyntaxError22;
postcss.Declaration = Declaration22;
postcss.Container = Container22;
postcss.Processor = Processor22;
postcss.Document = Document222;
postcss.Comment = Comment22;
postcss.Warning = Warning22;
postcss.AtRule = AtRule22;
postcss.Result = Result22;
postcss.Input = Input22;
postcss.Rule = Rule22;
postcss.Root = Root22;
postcss.Node = Node22;
LazyResult22.registerPostcss(postcss);
var postcss_1 = postcss;
postcss.default = postcss;
const postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);
postcss$1.stringify;
postcss$1.fromJSON;
postcss$1.plugin;
postcss$1.parse;
postcss$1.list;
postcss$1.document;
postcss$1.comment;
postcss$1.atRule;
postcss$1.rule;
postcss$1.decl;
postcss$1.root;
postcss$1.CssSyntaxError;
postcss$1.Declaration;
postcss$1.Container;
postcss$1.Processor;
postcss$1.Document;
postcss$1.Comment;
postcss$1.Warning;
postcss$1.AtRule;
postcss$1.Result;
postcss$1.Input;
postcss$1.Rule;
postcss$1.Root;
postcss$1.Node;
class BaseRRNode {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  constructor(..._args) {
    __publicField2(this, "parentElement", null);
    __publicField2(this, "parentNode", null);
    __publicField2(this, "ownerDocument");
    __publicField2(this, "firstChild", null);
    __publicField2(this, "lastChild", null);
    __publicField2(this, "previousSibling", null);
    __publicField2(this, "nextSibling", null);
    __publicField2(this, "ELEMENT_NODE", 1);
    __publicField2(this, "TEXT_NODE", 3);
    __publicField2(this, "nodeType");
    __publicField2(this, "nodeName");
    __publicField2(this, "RRNodeType");
  }
  get childNodes() {
    const childNodes2 = [];
    let childIterator = this.firstChild;
    while (childIterator) {
      childNodes2.push(childIterator);
      childIterator = childIterator.nextSibling;
    }
    return childNodes2;
  }
  contains(node2) {
    if (!(node2 instanceof BaseRRNode)) return false;
    else if (node2.ownerDocument !== this.ownerDocument) return false;
    else if (node2 === this) return true;
    while (node2.parentNode) {
      if (node2.parentNode === this) return true;
      node2 = node2.parentNode;
    }
    return false;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  appendChild(_newChild) {
    throw new Error(
      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  insertBefore(_newChild, _refChild) {
    throw new Error(
      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeChild(_node) {
    throw new Error(
      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  toString() {
    return "RRNode";
  }
}
const testableAccessors = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
};
const testableMethods = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
};
const untaintedBasePrototype = {};
const isAngularZonePresent = () => {
  return !!globalThis.Zone;
};
function getUntaintedPrototype(key) {
  if (untaintedBasePrototype[key])
    return untaintedBasePrototype[key];
  const defaultObj = globalThis[key];
  const defaultPrototype = defaultObj.prototype;
  const accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;
  const isUntaintedAccessors = Boolean(
    accessorNames && // @ts-expect-error 2345
    accessorNames.every(
      (accessor) => {
        var _a2, _b;
        return Boolean(
          (_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes("[native code]")
        );
      }
    )
  );
  const methodNames = key in testableMethods ? testableMethods[key] : void 0;
  const isUntaintedMethods = Boolean(
    methodNames && methodNames.every(
      // @ts-expect-error 2345
      (method) => {
        var _a2;
        return typeof defaultPrototype[method] === "function" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes("[native code]"));
      }
    )
  );
  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {
    untaintedBasePrototype[key] = defaultObj.prototype;
    return defaultObj.prototype;
  }
  try {
    const iframeEl = document.createElement("iframe");
    document.body.appendChild(iframeEl);
    const win = iframeEl.contentWindow;
    if (!win) return defaultObj.prototype;
    const untaintedObject = win[key].prototype;
    document.body.removeChild(iframeEl);
    if (!untaintedObject) return defaultPrototype;
    return untaintedBasePrototype[key] = untaintedObject;
  } catch {
    return defaultPrototype;
  }
}
const untaintedAccessorCache = {};
function getUntaintedAccessor(key, instance, accessor) {
  var _a2;
  const cacheKey = `${key}.${String(accessor)}`;
  if (untaintedAccessorCache[cacheKey])
    return untaintedAccessorCache[cacheKey].call(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype(key);
  const untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(
    untaintedPrototype,
    accessor
  )) == null ? void 0 : _a2.get;
  if (!untaintedAccessor) return instance[accessor];
  untaintedAccessorCache[cacheKey] = untaintedAccessor;
  return untaintedAccessor.call(instance);
}
const untaintedMethodCache = {};
function getUntaintedMethod(key, instance, method) {
  const cacheKey = `${key}.${String(method)}`;
  if (untaintedMethodCache[cacheKey])
    return untaintedMethodCache[cacheKey].bind(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype(key);
  const untaintedMethod = untaintedPrototype[method];
  if (typeof untaintedMethod !== "function") return instance[method];
  untaintedMethodCache[cacheKey] = untaintedMethod;
  return untaintedMethod.bind(instance);
}
function childNodes(n2) {
  return getUntaintedAccessor("Node", n2, "childNodes");
}
function parentNode(n2) {
  return getUntaintedAccessor("Node", n2, "parentNode");
}
function parentElement(n2) {
  return getUntaintedAccessor("Node", n2, "parentElement");
}
function textContent(n2) {
  return getUntaintedAccessor("Node", n2, "textContent");
}
function contains(n2, other) {
  return getUntaintedMethod("Node", n2, "contains")(other);
}
function getRootNode(n2) {
  return getUntaintedMethod("Node", n2, "getRootNode")();
}
function host(n2) {
  if (!n2 || !("host" in n2)) return null;
  return getUntaintedAccessor("ShadowRoot", n2, "host");
}
function styleSheets(n2) {
  return n2.styleSheets;
}
function shadowRoot(n2) {
  if (!n2 || !("shadowRoot" in n2)) return null;
  return getUntaintedAccessor("Element", n2, "shadowRoot");
}
function querySelector(n2, selectors) {
  return getUntaintedAccessor("Element", n2, "querySelector")(selectors);
}
function querySelectorAll(n2, selectors) {
  return getUntaintedAccessor("Element", n2, "querySelectorAll")(selectors);
}
function mutationObserverCtor() {
  return getUntaintedPrototype("MutationObserver").constructor;
}
const index = {
  childNodes,
  parentNode,
  parentElement,
  textContent,
  contains,
  getRootNode,
  host,
  styleSheets,
  shadowRoot,
  querySelector,
  querySelectorAll,
  mutationObserver: mutationObserverCtor
};
function on(type, fn, target = document) {
  const options = { capture: true, passive: true };
  target.addEventListener(type, fn, options);
  return () => target.removeEventListener(type, fn, options);
}
const DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
let _mirror = {
  map: {},
  getId() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return -1;
  },
  getNode() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return null;
  },
  removeNodeFromMap() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  },
  has() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return false;
  },
  reset() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  }
};
if (typeof window !== "undefined" && window.Proxy && window.Reflect) {
  _mirror = new Proxy(_mirror, {
    get(target, prop, receiver) {
      if (prop === "map") {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function throttle(func, wait, options = {}) {
  let timeout = null;
  let previous = 0;
  return function(...args) {
    const now = Date.now();
    if (!previous && options.leading === false) {
      previous = now;
    }
    const remaining = wait - (now - previous);
    const context = this;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      func.apply(context, args);
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(() => {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}
function hookSetter(target, key, d, isRevoked, win = window) {
  const original = win.Object.getOwnPropertyDescriptor(target, key);
  win.Object.defineProperty(
    target,
    key,
    isRevoked ? d : {
      set(value) {
        setTimeout(() => {
          d.set.call(this, value);
        }, 0);
        if (original && original.set) {
          original.set.call(this, value);
        }
      }
    }
  );
  return () => hookSetter(target, key, original || {}, true);
}
function patch(source, name, replacement) {
  try {
    if (!(name in source)) {
      return () => {
      };
    }
    const original = source[name];
    const wrapped = replacement(original);
    if (typeof wrapped === "function") {
      wrapped.prototype = wrapped.prototype || {};
      Object.defineProperties(wrapped, {
        __rrweb_original__: {
          enumerable: false,
          value: original
        }
      });
    }
    source[name] = wrapped;
    return () => {
      source[name] = original;
    };
  } catch {
    return () => {
    };
  }
}
let nowTimestamp = Date.now;
if (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {
  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();
}
function getWindowScroll(win) {
  var _a2, _b, _c, _d;
  const doc = win.document;
  return {
    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,
    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0
  };
}
function getWindowHeight() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function getWindowWidth() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function closestElementOfNode(node2) {
  if (!node2) {
    return null;
  }
  const el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);
  return el;
}
function isBlocked(node2, blockClass, blockSelector, checkAncestors) {
  if (!node2) {
    return false;
  }
  const el = closestElementOfNode(node2);
  if (!el) {
    return false;
  }
  try {
    if (typeof blockClass === "string") {
      if (el.classList.contains(blockClass)) return true;
      if (checkAncestors && el.closest("." + blockClass) !== null) return true;
    } else {
      if (classMatchesRegex(el, blockClass, checkAncestors)) return true;
    }
  } catch (e2) {
  }
  if (blockSelector) {
    if (el.matches(blockSelector)) return true;
    if (checkAncestors && el.closest(blockSelector) !== null) return true;
  }
  return false;
}
function isSerialized(n2, mirror2) {
  return mirror2.getId(n2) !== -1;
}
function isIgnored(n2, mirror2, slimDOMOptions) {
  if (n2.tagName === "TITLE" && slimDOMOptions.headTitleMutations) {
    return true;
  }
  return mirror2.getId(n2) === IGNORED_NODE;
}
function isAncestorRemoved(target, mirror2) {
  if (isShadowRoot(target)) {
    return false;
  }
  const id = mirror2.getId(target);
  if (!mirror2.has(id)) {
    return true;
  }
  const parent = index.parentNode(target);
  if (parent && parent.nodeType === target.DOCUMENT_NODE) {
    return false;
  }
  if (!parent) {
    return true;
  }
  return isAncestorRemoved(parent, mirror2);
}
function legacy_isTouchEvent(event) {
  return Boolean(event.changedTouches);
}
function polyfill$1(win = window) {
  if ("NodeList" in win && !win.NodeList.prototype.forEach) {
    win.NodeList.prototype.forEach = Array.prototype.forEach;
  }
  if ("DOMTokenList" in win && !win.DOMTokenList.prototype.forEach) {
    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;
  }
}
function isSerializedIframe(n2, mirror2) {
  return Boolean(n2.nodeName === "IFRAME" && mirror2.getMeta(n2));
}
function isSerializedStylesheet(n2, mirror2) {
  return Boolean(
    n2.nodeName === "LINK" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute("rel") === "stylesheet" && mirror2.getMeta(n2)
  );
}
function hasShadowRoot(n2) {
  if (!n2) return false;
  if (n2 instanceof BaseRRNode && "shadowRoot" in n2) {
    return Boolean(n2.shadowRoot);
  }
  return Boolean(index.shadowRoot(n2));
}
class StyleSheetMirror {
  constructor() {
    __publicField(this, "id", 1);
    __publicField(this, "styleIDMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "idStyleMap", /* @__PURE__ */ new Map());
  }
  getId(stylesheet) {
    return this.styleIDMap.get(stylesheet) ?? -1;
  }
  has(stylesheet) {
    return this.styleIDMap.has(stylesheet);
  }
  /**
   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.
   */
  add(stylesheet, id) {
    if (this.has(stylesheet)) return this.getId(stylesheet);
    let newId;
    if (id === void 0) {
      newId = this.id++;
    } else newId = id;
    this.styleIDMap.set(stylesheet, newId);
    this.idStyleMap.set(newId, stylesheet);
    return newId;
  }
  getStyle(id) {
    return this.idStyleMap.get(id) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap();
    this.idStyleMap = /* @__PURE__ */ new Map();
    this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function getShadowHost(n2) {
  var _a2;
  let shadowHost = null;
  if ("getRootNode" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2)))
    shadowHost = index.host(index.getRootNode(n2));
  return shadowHost;
}
function getRootShadowHost(n2) {
  let rootShadowHost = n2;
  let shadowHost;
  while (shadowHost = getShadowHost(rootShadowHost))
    rootShadowHost = shadowHost;
  return rootShadowHost;
}
function shadowHostInDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc) return false;
  const shadowHost = getRootShadowHost(n2);
  return index.contains(doc, shadowHost);
}
function inDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc) return false;
  return index.contains(doc, n2) || shadowHostInDom(n2);
}
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType || {});
var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource || {});
var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(MouseInteractions || {});
var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(PointerTypes || {});
var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(CanvasContext || {});
var MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
  return MediaInteractions2;
})(MediaInteractions || {});
var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType || {});
function isNodeInLinkedList(n2) {
  return "__ln" in n2;
}
class DoubleLinkedList {
  constructor() {
    __publicField(this, "length", 0);
    __publicField(this, "head", null);
    __publicField(this, "tail", null);
  }
  get(position) {
    if (position >= this.length) {
      throw new Error("Position outside of list range");
    }
    let current = this.head;
    for (let index2 = 0; index2 < position; index2++) {
      current = (current == null ? void 0 : current.next) || null;
    }
    return current;
  }
  addNode(n2) {
    const node2 = {
      value: n2,
      previous: null,
      next: null
    };
    n2.__ln = node2;
    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {
      const current = n2.previousSibling.__ln.next;
      node2.next = current;
      node2.previous = n2.previousSibling.__ln;
      n2.previousSibling.__ln.next = node2;
      if (current) {
        current.previous = node2;
      }
    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {
      const current = n2.nextSibling.__ln.previous;
      node2.previous = current;
      node2.next = n2.nextSibling.__ln;
      n2.nextSibling.__ln.previous = node2;
      if (current) {
        current.next = node2;
      }
    } else {
      if (this.head) {
        this.head.previous = node2;
      }
      node2.next = this.head;
      this.head = node2;
    }
    if (node2.next === null) {
      this.tail = node2;
    }
    this.length++;
  }
  removeNode(n2) {
    const current = n2.__ln;
    if (!this.head) {
      return;
    }
    if (!current.previous) {
      this.head = current.next;
      if (this.head) {
        this.head.previous = null;
      } else {
        this.tail = null;
      }
    } else {
      current.previous.next = current.next;
      if (current.next) {
        current.next.previous = current.previous;
      } else {
        this.tail = current.previous;
      }
    }
    if (n2.__ln) {
      delete n2.__ln;
    }
    this.length--;
  }
}
const moveKey = (id, parentId) => `${id}@${parentId}`;
class MutationBuffer {
  constructor() {
    __publicField(this, "frozen", false);
    __publicField(this, "locked", false);
    __publicField(this, "texts", []);
    __publicField(this, "attributes", []);
    __publicField(this, "attributeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "removes", []);
    __publicField(this, "mapRemoves", []);
    __publicField(this, "movedMap", {});
    __publicField(this, "addedSet", /* @__PURE__ */ new Set());
    __publicField(this, "movedSet", /* @__PURE__ */ new Set());
    __publicField(this, "droppedSet", /* @__PURE__ */ new Set());
    __publicField(this, "removesSubTreeCache", /* @__PURE__ */ new Set());
    __publicField(this, "mutationCb");
    __publicField(this, "blockClass");
    __publicField(this, "blockSelector");
    __publicField(this, "maskTextClass");
    __publicField(this, "maskTextSelector");
    __publicField(this, "inlineStylesheet");
    __publicField(this, "maskInputOptions");
    __publicField(this, "maskTextFn");
    __publicField(this, "maskInputFn");
    __publicField(this, "keepIframeSrcFn");
    __publicField(this, "recordCanvas");
    __publicField(this, "inlineImages");
    __publicField(this, "slimDOMOptions");
    __publicField(this, "dataURLOptions");
    __publicField(this, "doc");
    __publicField(this, "mirror");
    __publicField(this, "iframeManager");
    __publicField(this, "stylesheetManager");
    __publicField(this, "shadowDomManager");
    __publicField(this, "canvasManager");
    __publicField(this, "processedNodeManager");
    __publicField(this, "unattachedDoc");
    __publicField(this, "processMutations", (mutations) => {
      mutations.forEach(this.processMutation);
      this.emit();
    });
    __publicField(this, "emit", () => {
      if (this.frozen || this.locked) {
        return;
      }
      const adds = [];
      const addedIds = /* @__PURE__ */ new Set();
      const addList = new DoubleLinkedList();
      const getNextId = (n2) => {
        let ns = n2;
        let nextId = IGNORED_NODE;
        while (nextId === IGNORED_NODE) {
          ns = ns && ns.nextSibling;
          nextId = ns && this.mirror.getId(ns);
        }
        return nextId;
      };
      const pushAdd = (n2) => {
        const parent = index.parentNode(n2);
        if (!parent || !inDom(n2)) {
          return;
        }
        let cssCaptured = false;
        if (n2.nodeType === Node.TEXT_NODE) {
          const parentTag = parent.tagName;
          if (parentTag === "TEXTAREA") {
            return;
          } else if (parentTag === "STYLE" && this.addedSet.has(parent)) {
            cssCaptured = true;
          }
        }
        const parentId = isShadowRoot(parent) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(parent);
        const nextId = getNextId(n2);
        if (parentId === -1 || nextId === -1) {
          return addList.addNode(n2);
        }
        const sn = serializeNodeWithId(n2, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: true,
          newlyAddedElement: true,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          onSerialize: (currentN) => {
            if (isSerializedIframe(currentN, this.mirror)) {
              this.iframeManager.addIframe(currentN);
            }
            if (isSerializedStylesheet(currentN, this.mirror)) {
              this.stylesheetManager.trackLinkElement(
                currentN
              );
            }
            if (hasShadowRoot(n2)) {
              this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), this.doc);
            }
          },
          onIframeLoad: (iframe, childSn) => {
            this.iframeManager.attachIframe(iframe, childSn);
            this.shadowDomManager.observeAttachShadow(iframe);
          },
          onStylesheetLoad: (link, childSn) => {
            this.stylesheetManager.attachLinkElement(link, childSn);
          },
          cssCaptured
        });
        if (sn) {
          adds.push({
            parentId,
            nextId,
            node: sn
          });
          addedIds.add(sn.id);
        }
      };
      while (this.mapRemoves.length) {
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      }
      for (const n2 of this.movedSet) {
        if (isParentRemoved(this.removesSubTreeCache, n2, this.mirror) && !this.movedSet.has(index.parentNode(n2))) {
          continue;
        }
        pushAdd(n2);
      }
      for (const n2 of this.addedSet) {
        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removesSubTreeCache, n2, this.mirror)) {
          pushAdd(n2);
        } else if (isAncestorInSet(this.movedSet, n2)) {
          pushAdd(n2);
        } else {
          this.droppedSet.add(n2);
        }
      }
      let candidate = null;
      while (addList.length) {
        let node2 = null;
        if (candidate) {
          const parentId = this.mirror.getId(index.parentNode(candidate.value));
          const nextId = getNextId(candidate.value);
          if (parentId !== -1 && nextId !== -1) {
            node2 = candidate;
          }
        }
        if (!node2) {
          let tailNode = addList.tail;
          while (tailNode) {
            const _node = tailNode;
            tailNode = tailNode.previous;
            if (_node) {
              const parentId = this.mirror.getId(index.parentNode(_node.value));
              const nextId = getNextId(_node.value);
              if (nextId === -1) continue;
              else if (parentId !== -1) {
                node2 = _node;
                break;
              } else {
                const unhandledNode = _node.value;
                const parent = index.parentNode(unhandledNode);
                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const shadowHost = index.host(parent);
                  const parentId2 = this.mirror.getId(shadowHost);
                  if (parentId2 !== -1) {
                    node2 = _node;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!node2) {
          while (addList.head) {
            addList.removeNode(addList.head.value);
          }
          break;
        }
        candidate = node2.previous;
        addList.removeNode(node2.value);
        pushAdd(node2.value);
      }
      const payload = {
        texts: this.texts.map((text) => {
          const n2 = text.node;
          const parent = index.parentNode(n2);
          if (parent && parent.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(parent);
          }
          return {
            id: this.mirror.getId(n2),
            value: text.value
          };
        }).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),
        attributes: this.attributes.map((attribute) => {
          const { attributes } = attribute;
          if (typeof attributes.style === "string") {
            const diffAsStr = JSON.stringify(attribute.styleDiff);
            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);
            if (diffAsStr.length < attributes.style.length) {
              if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {
                attributes.style = attribute.styleDiff;
              }
            }
          }
          return {
            id: this.mirror.getId(attribute.node),
            attributes
          };
        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),
        removes: this.removes,
        adds
      };
      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
        return;
      }
      this.texts = [];
      this.attributes = [];
      this.attributeMap = /* @__PURE__ */ new WeakMap();
      this.removes = [];
      this.addedSet = /* @__PURE__ */ new Set();
      this.movedSet = /* @__PURE__ */ new Set();
      this.droppedSet = /* @__PURE__ */ new Set();
      this.removesSubTreeCache = /* @__PURE__ */ new Set();
      this.movedMap = {};
      this.mutationCb(payload);
    });
    __publicField(this, "genTextAreaValueMutation", (textarea) => {
      let item = this.attributeMap.get(textarea);
      if (!item) {
        item = {
          node: textarea,
          attributes: {},
          styleDiff: {},
          _unchangedStyles: {}
        };
        this.attributes.push(item);
        this.attributeMap.set(textarea, item);
      }
      item.attributes.value = Array.from(
        index.childNodes(textarea),
        (cn) => index.textContent(cn) || ""
      ).join("");
    });
    __publicField(this, "processMutation", (m) => {
      if (isIgnored(m.target, this.mirror, this.slimDOMOptions)) {
        return;
      }
      switch (m.type) {
        case "characterData": {
          const value = index.textContent(m.target);
          if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {
            this.texts.push({
              value: needMaskingText(
                m.target,
                this.maskTextClass,
                this.maskTextSelector,
                true
                // checkAncestors
              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\S]/g, "*") : value,
              node: m.target
            });
          }
          break;
        }
        case "attributes": {
          const target = m.target;
          let attributeName = m.attributeName;
          let value = m.target.getAttribute(attributeName);
          if (attributeName === "value") {
            const type = getInputType(target);
            value = maskInputValue({
              element: target,
              maskInputOptions: this.maskInputOptions,
              tagName: target.tagName,
              type,
              value,
              maskInputFn: this.maskInputFn
            });
          }
          if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {
            return;
          }
          let item = this.attributeMap.get(m.target);
          if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {
            if (!target.contentDocument) {
              attributeName = "rr_src";
            } else {
              return;
            }
          }
          if (!item) {
            item = {
              node: m.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            };
            this.attributes.push(item);
            this.attributeMap.set(m.target, item);
          }
          if (attributeName === "type" && target.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
            target.setAttribute("data-rr-is-password", "true");
          }
          if (!ignoreAttribute(target.tagName, attributeName)) {
            item.attributes[attributeName] = transformAttribute(
              this.doc,
              toLowerCase(target.tagName),
              toLowerCase(attributeName),
              value
            );
            if (attributeName === "style") {
              if (!this.unattachedDoc) {
                try {
                  this.unattachedDoc = document.implementation.createHTMLDocument();
                } catch (e2) {
                  this.unattachedDoc = this.doc;
                }
              }
              const old = this.unattachedDoc.createElement("span");
              if (m.oldValue) {
                old.setAttribute("style", m.oldValue);
              }
              for (const pname of Array.from(target.style)) {
                const newValue = target.style.getPropertyValue(pname);
                const newPriority = target.style.getPropertyPriority(pname);
                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {
                  if (newPriority === "") {
                    item.styleDiff[pname] = newValue;
                  } else {
                    item.styleDiff[pname] = [newValue, newPriority];
                  }
                } else {
                  item._unchangedStyles[pname] = [newValue, newPriority];
                }
              }
              for (const pname of Array.from(old.style)) {
                if (target.style.getPropertyValue(pname) === "") {
                  item.styleDiff[pname] = false;
                }
              }
            } else if (attributeName === "open" && target.tagName === "DIALOG") {
              if (target.matches("dialog:modal")) {
                item.attributes["rr_open_mode"] = "modal";
              } else {
                item.attributes["rr_open_mode"] = "non-modal";
              }
            }
          }
          break;
        }
        case "childList": {
          if (isBlocked(m.target, this.blockClass, this.blockSelector, true))
            return;
          if (m.target.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(m.target);
            return;
          }
          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));
          m.removedNodes.forEach((n2) => {
            const nodeId = this.mirror.getId(n2);
            const parentId = isShadowRoot(m.target) ? this.mirror.getId(index.host(m.target)) : this.mirror.getId(m.target);
            if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n2, this.mirror, this.slimDOMOptions) || !isSerialized(n2, this.mirror)) {
              return;
            }
            if (this.addedSet.has(n2)) {
              deepDelete(this.addedSet, n2);
              this.droppedSet.add(n2);
            } else if (this.addedSet.has(m.target) && nodeId === -1) ;
            else if (isAncestorRemoved(m.target, this.mirror)) ;
            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {
              deepDelete(this.movedSet, n2);
            } else {
              this.removes.push({
                parentId,
                id: nodeId,
                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0
              });
              processRemoves(n2, this.removesSubTreeCache);
            }
            this.mapRemoves.push(n2);
          });
          break;
        }
      }
    });
    __publicField(this, "genAdds", (n2, target) => {
      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;
      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;
      if (this.mirror.hasNode(n2)) {
        if (isIgnored(n2, this.mirror, this.slimDOMOptions)) {
          return;
        }
        this.movedSet.add(n2);
        let targetId = null;
        if (target && this.mirror.hasNode(target)) {
          targetId = this.mirror.getId(target);
        }
        if (targetId && targetId !== -1) {
          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;
        }
      } else {
        this.addedSet.add(n2);
        this.droppedSet.delete(n2);
      }
      if (!isBlocked(n2, this.blockClass, this.blockSelector, false)) {
        index.childNodes(n2).forEach((childN) => this.genAdds(childN));
        if (hasShadowRoot(n2)) {
          index.childNodes(index.shadowRoot(n2)).forEach((childN) => {
            this.processedNodeManager.add(childN, this);
            this.genAdds(childN, n2);
          });
        }
      }
    });
  }
  init(options) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((key) => {
      this[key] = options[key];
    });
  }
  freeze() {
    this.frozen = true;
    this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = false;
    this.canvasManager.unfreeze();
    this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = true;
    this.canvasManager.lock();
  }
  unlock() {
    this.locked = false;
    this.canvasManager.unlock();
    this.emit();
  }
  reset() {
    this.shadowDomManager.reset();
    this.canvasManager.reset();
  }
}
function deepDelete(addsSet, n2) {
  addsSet.delete(n2);
  index.childNodes(n2).forEach((childN) => deepDelete(addsSet, childN));
}
function processRemoves(n2, cache) {
  const queue = [n2];
  while (queue.length) {
    const next = queue.pop();
    if (cache.has(next)) continue;
    cache.add(next);
    index.childNodes(next).forEach((n22) => queue.push(n22));
  }
  return;
}
function isParentRemoved(removes, n2, mirror2) {
  if (removes.size === 0) return false;
  return _isParentRemoved(removes, n2);
}
function _isParentRemoved(removes, n2, _mirror2) {
  const node2 = index.parentNode(n2);
  if (!node2) return false;
  return removes.has(node2);
}
function isAncestorInSet(set, n2) {
  if (set.size === 0) return false;
  return _isAncestorInSet(set, n2);
}
function _isAncestorInSet(set, n2) {
  const parent = index.parentNode(n2);
  if (!parent) {
    return false;
  }
  if (set.has(parent)) {
    return true;
  }
  return _isAncestorInSet(set, parent);
}
let errorHandler;
function registerErrorHandler(handler) {
  errorHandler = handler;
}
function unregisterErrorHandler() {
  errorHandler = void 0;
}
const callbackWrapper = (cb) => {
  if (!errorHandler) {
    return cb;
  }
  const rrwebWrapped = (...rest) => {
    try {
      return cb(...rest);
    } catch (error) {
      if (errorHandler && errorHandler(error) === true) {
        return;
      }
      throw error;
    }
  };
  return rrwebWrapped;
};
const mutationBuffers = [];
function getEventTarget(event) {
  try {
    if ("composedPath" in event) {
      const path = event.composedPath();
      if (path.length) {
        return path[0];
      }
    } else if ("path" in event && event.path.length) {
      return event.path[0];
    }
  } catch {
  }
  return event && event.target;
}
function initMutationObserver(options, rootEl) {
  const mutationBuffer = new MutationBuffer();
  mutationBuffers.push(mutationBuffer);
  mutationBuffer.init(options);
  const observer = new (mutationObserverCtor())(
    callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer))
  );
  observer.observe(rootEl, {
    attributes: true,
    attributeOldValue: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  });
  return observer;
}
function initMoveObserver({
  mousemoveCb,
  sampling,
  doc,
  mirror: mirror2
}) {
  if (sampling.mousemove === false) {
    return () => {
    };
  }
  const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;
  const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;
  let positions = [];
  let timeBaseline;
  const wrappedCb = throttle(
    callbackWrapper(
      (source) => {
        const totalOffset = Date.now() - timeBaseline;
        mousemoveCb(
          positions.map((p) => {
            p.timeOffset -= totalOffset;
            return p;
          }),
          source
        );
        positions = [];
        timeBaseline = null;
      }
    ),
    callbackThreshold
  );
  const updatePosition = callbackWrapper(
    throttle(
      callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;
        if (!timeBaseline) {
          timeBaseline = nowTimestamp();
        }
        positions.push({
          x: clientX,
          y: clientY,
          id: mirror2.getId(target),
          timeOffset: nowTimestamp() - timeBaseline
        });
        wrappedCb(
          typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove
        );
      }),
      threshold,
      {
        trailing: false
      }
    )
  );
  const handlers = [
    on("mousemove", updatePosition, doc),
    on("touchmove", updatePosition, doc),
    on("drag", updatePosition, doc)
  ];
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initMouseInteractionObserver({
  mouseInteractionCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  sampling
}) {
  if (sampling.mouseInteraction === false) {
    return () => {
    };
  }
  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;
  const handlers = [];
  let currentPointerType = null;
  const getHandler = (eventKey) => {
    return (event) => {
      const target = getEventTarget(event);
      if (isBlocked(target, blockClass, blockSelector, true)) {
        return;
      }
      let pointerType = null;
      let thisEventKey = eventKey;
      if ("pointerType" in event) {
        switch (event.pointerType) {
          case "mouse":
            pointerType = PointerTypes.Mouse;
            break;
          case "touch":
            pointerType = PointerTypes.Touch;
            break;
          case "pen":
            pointerType = PointerTypes.Pen;
            break;
        }
        if (pointerType === PointerTypes.Touch) {
          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {
            thisEventKey = "TouchStart";
          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {
            thisEventKey = "TouchEnd";
          }
        } else if (pointerType === PointerTypes.Pen) ;
      } else if (legacy_isTouchEvent(event)) {
        pointerType = PointerTypes.Touch;
      }
      if (pointerType !== null) {
        currentPointerType = pointerType;
        if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {
          pointerType = null;
        }
      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {
        pointerType = currentPointerType;
        currentPointerType = null;
      }
      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;
      if (!e2) {
        return;
      }
      const id = mirror2.getId(target);
      const { clientX, clientY } = e2;
      callbackWrapper(mouseInteractionCb)({
        type: MouseInteractions[thisEventKey],
        id,
        x: clientX,
        y: clientY,
        ...pointerType !== null && { pointerType }
      });
    };
  };
  Object.keys(MouseInteractions).filter(
    (key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false
  ).forEach((eventKey) => {
    let eventName = toLowerCase(eventKey);
    const handler = getHandler(eventKey);
    if (window.PointerEvent) {
      switch (MouseInteractions[eventKey]) {
        case MouseInteractions.MouseDown:
        case MouseInteractions.MouseUp:
          eventName = eventName.replace(
            "mouse",
            "pointer"
          );
          break;
        case MouseInteractions.TouchStart:
        case MouseInteractions.TouchEnd:
          return;
      }
    }
    handlers.push(on(eventName, handler, doc));
  });
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initScrollObserver({
  scrollCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  sampling
}) {
  const updatePosition = callbackWrapper(
    throttle(
      callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const id = mirror2.getId(target);
        if (target === doc && doc.defaultView) {
          const scrollLeftTop = getWindowScroll(doc.defaultView);
          scrollCb({
            id,
            x: scrollLeftTop.left,
            y: scrollLeftTop.top
          });
        } else {
          scrollCb({
            id,
            x: target.scrollLeft,
            y: target.scrollTop
          });
        }
      }),
      sampling.scroll || 100
    )
  );
  return on("scroll", updatePosition, doc);
}
function initViewportResizeObserver({ viewportResizeCb }, { win }) {
  let lastH = -1;
  let lastW = -1;
  const updateDimension = callbackWrapper(
    throttle(
      callbackWrapper(() => {
        const height = getWindowHeight();
        const width = getWindowWidth();
        if (lastH !== height || lastW !== width) {
          viewportResizeCb({
            width: Number(width),
            height: Number(height)
          });
          lastH = height;
          lastW = width;
        }
      }),
      200
    )
  );
  return on("resize", updateDimension, win);
}
const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
const lastInputValueMap = /* @__PURE__ */ new WeakMap();
function initInputObserver({
  inputCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  ignoreClass,
  ignoreSelector,
  maskInputOptions,
  maskInputFn,
  sampling,
  userTriggeredOnInput
}) {
  function eventHandler(event) {
    let target = getEventTarget(event);
    const userTriggered = event.isTrusted;
    const tagName = target && target.tagName;
    if (target && tagName === "OPTION") {
      target = index.parentElement(target);
    }
    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {
      return;
    }
    if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {
      return;
    }
    let text = target.value;
    let isChecked = false;
    const type = getInputType(target) || "";
    if (type === "radio" || type === "checkbox") {
      isChecked = target.checked;
    } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {
      text = maskInputValue({
        element: target,
        maskInputOptions,
        tagName,
        type,
        value: text,
        maskInputFn
      });
    }
    cbWithDedup(
      target,
      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }
    );
    const name = target.name;
    if (type === "radio" && name && isChecked) {
      doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el) => {
        if (el !== target) {
          const text2 = el.value;
          cbWithDedup(
            el,
            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }
          );
        }
      });
    }
  }
  function cbWithDedup(target, v2) {
    const lastInputValue = lastInputValueMap.get(target);
    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {
      lastInputValueMap.set(target, v2);
      const id = mirror2.getId(target);
      callbackWrapper(inputCb)({
        ...v2,
        id
      });
    }
  }
  const events = sampling.input === "last" ? ["change"] : ["input", "change"];
  const handlers = events.map(
    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)
  );
  const currentWindow = doc.defaultView;
  if (!currentWindow) {
    return () => {
      handlers.forEach((h) => h());
    };
  }
  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(
    currentWindow.HTMLInputElement.prototype,
    "value"
  );
  const hookProperties = [
    [currentWindow.HTMLInputElement.prototype, "value"],
    [currentWindow.HTMLInputElement.prototype, "checked"],
    [currentWindow.HTMLSelectElement.prototype, "value"],
    [currentWindow.HTMLTextAreaElement.prototype, "value"],
    // Some UI library use selectedIndex to set select value
    [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],
    [currentWindow.HTMLOptionElement.prototype, "selected"]
  ];
  if (propertyDescriptor && propertyDescriptor.set) {
    handlers.push(
      ...hookProperties.map(
        (p) => hookSetter(
          p[0],
          p[1],
          {
            set() {
              callbackWrapper(eventHandler)({
                target: this,
                isTrusted: false
                // userTriggered to false as this could well be programmatic
              });
            }
          },
          false,
          currentWindow
        )
      )
    );
  }
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function getNestedCSSRulePositions(rule2) {
  const positions = [];
  function recurse(childRule, pos) {
    if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {
      const rules2 = Array.from(
        childRule.parentRule.cssRules
      );
      const index2 = rules2.indexOf(childRule);
      pos.unshift(index2);
    } else if (childRule.parentStyleSheet) {
      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);
      const index2 = rules2.indexOf(childRule);
      pos.unshift(index2);
    }
    return pos;
  }
  return recurse(rule2, positions);
}
function getIdAndStyleId(sheet, mirror2, styleMirror) {
  let id, styleId;
  if (!sheet) return {};
  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);
  else styleId = styleMirror.getId(sheet);
  return {
    styleId,
    id
  };
}
function initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {
  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {
    return () => {
    };
  }
  const insertRule = win.CSSStyleSheet.prototype.insertRule;
  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        const [rule2, index2] = argumentsList;
        const { id, styleId } = getIdAndStyleId(
          thisArg,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id,
            styleId,
            adds: [{ rule: rule2, index: index2 }]
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2 = this.cssRules.length) {
    const rule2 = `${selector} { ${styleBlock} }`;
    return win.CSSStyleSheet.prototype.insertRule.apply(this, [rule2, index2]);
  };
  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;
  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        const [index2] = argumentsList;
        const { id, styleId } = getIdAndStyleId(
          thisArg,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id,
            styleId,
            removes: [{ index: index2 }]
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  win.CSSStyleSheet.prototype.removeRule = function(index2) {
    return win.CSSStyleSheet.prototype.deleteRule.apply(this, [index2]);
  };
  let replace;
  if (win.CSSStyleSheet.prototype.replace) {
    replace = win.CSSStyleSheet.prototype.replace;
    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {
      apply: callbackWrapper(
        (target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id, styleId } = getIdAndStyleId(
            thisArg,
            mirror2,
            stylesheetManager.styleMirror
          );
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              replace: text
            });
          }
          return target.apply(thisArg, argumentsList);
        }
      )
    });
  }
  let replaceSync;
  if (win.CSSStyleSheet.prototype.replaceSync) {
    replaceSync = win.CSSStyleSheet.prototype.replaceSync;
    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {
      apply: callbackWrapper(
        (target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id, styleId } = getIdAndStyleId(
            thisArg,
            mirror2,
            stylesheetManager.styleMirror
          );
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              replaceSync: text
            });
          }
          return target.apply(thisArg, argumentsList);
        }
      )
    });
  }
  const supportedNestedCSSRuleTypes = {};
  if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;
  } else {
    if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;
    }
  }
  const unmodifiedFunctions = {};
  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
    unmodifiedFunctions[typeKey] = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      insertRule: type.prototype.insertRule,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      deleteRule: type.prototype.deleteRule
    };
    type.prototype.insertRule = new Proxy(
      unmodifiedFunctions[typeKey].insertRule,
      {
        apply: callbackWrapper(
          (target, thisArg, argumentsList) => {
            const [rule2, index2] = argumentsList;
            const { id, styleId } = getIdAndStyleId(
              thisArg.parentStyleSheet,
              mirror2,
              stylesheetManager.styleMirror
            );
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                adds: [
                  {
                    rule: rule2,
                    index: [
                      ...getNestedCSSRulePositions(thisArg),
                      index2 || 0
                      // defaults to 0
                    ]
                  }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          }
        )
      }
    );
    type.prototype.deleteRule = new Proxy(
      unmodifiedFunctions[typeKey].deleteRule,
      {
        apply: callbackWrapper(
          (target, thisArg, argumentsList) => {
            const [index2] = argumentsList;
            const { id, styleId } = getIdAndStyleId(
              thisArg.parentStyleSheet,
              mirror2,
              stylesheetManager.styleMirror
            );
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                removes: [
                  { index: [...getNestedCSSRulePositions(thisArg), index2] }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          }
        )
      }
    );
  });
  return callbackWrapper(() => {
    win.CSSStyleSheet.prototype.insertRule = insertRule;
    win.CSSStyleSheet.prototype.deleteRule = deleteRule;
    replace && (win.CSSStyleSheet.prototype.replace = replace);
    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);
    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;
      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;
    });
  });
}
function initAdoptedStyleSheetObserver({
  mirror: mirror2,
  stylesheetManager
}, host2) {
  var _a2, _b, _c;
  let hostId = null;
  if (host2.nodeName === "#document") hostId = mirror2.getId(host2);
  else hostId = mirror2.getId(index.host(host2));
  const patchTarget = host2.nodeName === "#document" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;
  const originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(
    patchTarget == null ? void 0 : patchTarget.prototype,
    "adoptedStyleSheets"
  ) : void 0;
  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)
    return () => {
    };
  Object.defineProperty(host2, "adoptedStyleSheets", {
    configurable: originalPropertyDescriptor.configurable,
    enumerable: originalPropertyDescriptor.enumerable,
    get() {
      var _a3;
      return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);
    },
    set(sheets) {
      var _a3;
      const result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);
      if (hostId !== null && hostId !== -1) {
        try {
          stylesheetManager.adoptStyleSheets(sheets, hostId);
        } catch (e2) {
        }
      }
      return result2;
    }
  });
  return callbackWrapper(() => {
    Object.defineProperty(host2, "adoptedStyleSheets", {
      configurable: originalPropertyDescriptor.configurable,
      enumerable: originalPropertyDescriptor.enumerable,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      get: originalPropertyDescriptor.get,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      set: originalPropertyDescriptor.set
    });
  });
}
function initStyleDeclarationObserver({
  styleDeclarationCb,
  mirror: mirror2,
  ignoreCSSAttributes,
  stylesheetManager
}, { win }) {
  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;
  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        var _a2;
        const [property, value, priority] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return setProperty.apply(thisArg, [property, value, priority]);
        }
        const { id, styleId } = getIdAndStyleId(
          (_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id,
            styleId,
            set: {
              property,
              value,
              priority
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;
  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        var _a2;
        const [property] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return removeProperty.apply(thisArg, [property]);
        }
        const { id, styleId } = getIdAndStyleId(
          (_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id,
            styleId,
            remove: {
              property
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  return callbackWrapper(() => {
    win.CSSStyleDeclaration.prototype.setProperty = setProperty;
    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;
  });
}
function initMediaInteractionObserver({
  mediaInteractionCb,
  blockClass,
  blockSelector,
  mirror: mirror2,
  sampling,
  doc
}) {
  const handler = callbackWrapper(
    (type) => throttle(
      callbackWrapper((event) => {
        const target = getEventTarget(event);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const { currentTime, volume, muted, playbackRate, loop } = target;
        mediaInteractionCb({
          type,
          id: mirror2.getId(target),
          currentTime,
          volume,
          muted,
          playbackRate,
          loop
        });
      }),
      sampling.media || 500
    )
  );
  const handlers = [
    on("play", handler(MediaInteractions.Play), doc),
    on("pause", handler(MediaInteractions.Pause), doc),
    on("seeked", handler(MediaInteractions.Seeked), doc),
    on("volumechange", handler(MediaInteractions.VolumeChange), doc),
    on("ratechange", handler(MediaInteractions.RateChange), doc)
  ];
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initFontObserver({ fontCb, doc }) {
  const win = doc.defaultView;
  if (!win) {
    return () => {
    };
  }
  const handlers = [];
  const fontMap = /* @__PURE__ */ new WeakMap();
  const originalFontFace = win.FontFace;
  win.FontFace = function FontFace2(family, source, descriptors) {
    const fontFace = new originalFontFace(family, source, descriptors);
    fontMap.set(fontFace, {
      family,
      buffer: typeof source !== "string",
      descriptors,
      fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))
    });
    return fontFace;
  };
  const restoreHandler = patch(
    doc.fonts,
    "add",
    function(original) {
      return function(fontFace) {
        setTimeout(
          callbackWrapper(() => {
            const p = fontMap.get(fontFace);
            if (p) {
              fontCb(p);
              fontMap.delete(fontFace);
            }
          }),
          0
        );
        return original.apply(this, [fontFace]);
      };
    }
  );
  handlers.push(() => {
    win.FontFace = originalFontFace;
  });
  handlers.push(restoreHandler);
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initSelectionObserver(param) {
  const { doc, mirror: mirror2, blockClass, blockSelector, selectionCb } = param;
  let collapsed = true;
  const updateSelection = callbackWrapper(() => {
    const selection = doc.getSelection();
    if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;
    collapsed = selection.isCollapsed || false;
    const ranges = [];
    const count = selection.rangeCount || 0;
    for (let i2 = 0; i2 < count; i2++) {
      const range = selection.getRangeAt(i2);
      const { startContainer, startOffset, endContainer, endOffset } = range;
      const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);
      if (blocked) continue;
      ranges.push({
        start: mirror2.getId(startContainer),
        startOffset,
        end: mirror2.getId(endContainer),
        endOffset
      });
    }
    selectionCb({ ranges });
  });
  updateSelection();
  return on("selectionchange", updateSelection);
}
function initCustomElementObserver({
  doc,
  customElementCb
}) {
  const win = doc.defaultView;
  if (!win || !win.customElements) return () => {
  };
  const restoreHandler = patch(
    win.customElements,
    "define",
    function(original) {
      return function(name, constructor, options) {
        try {
          customElementCb({
            define: {
              name
            }
          });
        } catch (e2) {
          console.warn(`Custom element callback failed for ${name}`);
        }
        return original.apply(this, [name, constructor, options]);
      };
    }
  );
  return restoreHandler;
}
function mergeHooks(o2, hooks) {
  const {
    mutationCb,
    mousemoveCb,
    mouseInteractionCb,
    scrollCb,
    viewportResizeCb,
    inputCb,
    mediaInteractionCb,
    styleSheetRuleCb,
    styleDeclarationCb,
    canvasMutationCb,
    fontCb,
    selectionCb,
    customElementCb
  } = o2;
  o2.mutationCb = (...p) => {
    if (hooks.mutation) {
      hooks.mutation(...p);
    }
    mutationCb(...p);
  };
  o2.mousemoveCb = (...p) => {
    if (hooks.mousemove) {
      hooks.mousemove(...p);
    }
    mousemoveCb(...p);
  };
  o2.mouseInteractionCb = (...p) => {
    if (hooks.mouseInteraction) {
      hooks.mouseInteraction(...p);
    }
    mouseInteractionCb(...p);
  };
  o2.scrollCb = (...p) => {
    if (hooks.scroll) {
      hooks.scroll(...p);
    }
    scrollCb(...p);
  };
  o2.viewportResizeCb = (...p) => {
    if (hooks.viewportResize) {
      hooks.viewportResize(...p);
    }
    viewportResizeCb(...p);
  };
  o2.inputCb = (...p) => {
    if (hooks.input) {
      hooks.input(...p);
    }
    inputCb(...p);
  };
  o2.mediaInteractionCb = (...p) => {
    if (hooks.mediaInteaction) {
      hooks.mediaInteaction(...p);
    }
    mediaInteractionCb(...p);
  };
  o2.styleSheetRuleCb = (...p) => {
    if (hooks.styleSheetRule) {
      hooks.styleSheetRule(...p);
    }
    styleSheetRuleCb(...p);
  };
  o2.styleDeclarationCb = (...p) => {
    if (hooks.styleDeclaration) {
      hooks.styleDeclaration(...p);
    }
    styleDeclarationCb(...p);
  };
  o2.canvasMutationCb = (...p) => {
    if (hooks.canvasMutation) {
      hooks.canvasMutation(...p);
    }
    canvasMutationCb(...p);
  };
  o2.fontCb = (...p) => {
    if (hooks.font) {
      hooks.font(...p);
    }
    fontCb(...p);
  };
  o2.selectionCb = (...p) => {
    if (hooks.selection) {
      hooks.selection(...p);
    }
    selectionCb(...p);
  };
  o2.customElementCb = (...c2) => {
    if (hooks.customElement) {
      hooks.customElement(...c2);
    }
    customElementCb(...c2);
  };
}
function initObservers(o2, hooks = {}) {
  const currentWindow = o2.doc.defaultView;
  if (!currentWindow) {
    return () => {
    };
  }
  mergeHooks(o2, hooks);
  let mutationObserver;
  if (o2.recordDOM) {
    mutationObserver = initMutationObserver(o2, o2.doc);
  }
  const mousemoveHandler = initMoveObserver(o2);
  const mouseInteractionHandler = initMouseInteractionObserver(o2);
  const scrollHandler = initScrollObserver(o2);
  const viewportResizeHandler = initViewportResizeObserver(o2, {
    win: currentWindow
  });
  const inputHandler = initInputObserver(o2);
  const mediaInteractionHandler = initMediaInteractionObserver(o2);
  let styleSheetObserver = () => {
  };
  let adoptedStyleSheetObserver = () => {
  };
  let styleDeclarationObserver = () => {
  };
  let fontObserver = () => {
  };
  if (o2.recordDOM) {
    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });
    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);
    styleDeclarationObserver = initStyleDeclarationObserver(o2, {
      win: currentWindow
    });
    if (o2.collectFonts) {
      fontObserver = initFontObserver(o2);
    }
  }
  const selectionObserver = initSelectionObserver(o2);
  const customElementObserver = initCustomElementObserver(o2);
  const pluginHandlers = [];
  for (const plugin3 of o2.plugins) {
    pluginHandlers.push(
      plugin3.observer(plugin3.callback, currentWindow, plugin3.options)
    );
  }
  return callbackWrapper(() => {
    mutationBuffers.forEach((b) => b.reset());
    mutationObserver == null ? void 0 : mutationObserver.disconnect();
    mousemoveHandler();
    mouseInteractionHandler();
    scrollHandler();
    viewportResizeHandler();
    inputHandler();
    mediaInteractionHandler();
    styleSheetObserver();
    adoptedStyleSheetObserver();
    styleDeclarationObserver();
    fontObserver();
    selectionObserver();
    customElementObserver();
    pluginHandlers.forEach((h) => h());
  });
}
function hasNestedCSSRule(prop) {
  return typeof window[prop] !== "undefined";
}
function canMonkeyPatchNestedCSSRule(prop) {
  return Boolean(
    typeof window[prop] !== "undefined" && // Note: Generally, this check _shouldn't_ be necessary
    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here
    window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype
  );
}
class CrossOriginIframeMirror {
  constructor(generateIdFn) {
    __publicField(this, "iframeIdToRemoteIdMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "iframeRemoteIdToIdMap", /* @__PURE__ */ new WeakMap());
    this.generateIdFn = generateIdFn;
  }
  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {
    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);
    let id = idToRemoteIdMap.get(remoteId);
    if (!id) {
      id = this.generateIdFn();
      idToRemoteIdMap.set(remoteId, id);
      remoteIdToIdMap.set(id, remoteId);
    }
    return id;
  }
  getIds(iframe, remoteId) {
    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return remoteId.map(
      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)
    );
  }
  getRemoteId(iframe, id, map) {
    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);
    if (typeof id !== "number") return id;
    const remoteId = remoteIdToIdMap.get(id);
    if (!remoteId) return -1;
    return remoteId;
  }
  getRemoteIds(iframe, ids) {
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));
  }
  reset(iframe) {
    if (!iframe) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(iframe);
    this.iframeRemoteIdToIdMap.delete(iframe);
  }
  getIdToRemoteIdMap(iframe) {
    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);
    if (!idToRemoteIdMap) {
      idToRemoteIdMap = /* @__PURE__ */ new Map();
      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);
    }
    return idToRemoteIdMap;
  }
  getRemoteIdToIdMap(iframe) {
    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);
    if (!remoteIdToIdMap) {
      remoteIdToIdMap = /* @__PURE__ */ new Map();
      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);
    }
    return remoteIdToIdMap;
  }
}
class IframeManager {
  constructor(options) {
    __publicField(this, "iframes", /* @__PURE__ */ new WeakMap());
    __publicField(this, "crossOriginIframeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "crossOriginIframeMirror", new CrossOriginIframeMirror(genId));
    __publicField(this, "crossOriginIframeStyleMirror");
    __publicField(this, "crossOriginIframeRootIdMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "mirror");
    __publicField(this, "mutationCb");
    __publicField(this, "wrappedEmit");
    __publicField(this, "loadListener");
    __publicField(this, "stylesheetManager");
    __publicField(this, "recordCrossOriginIframes");
    this.mutationCb = options.mutationCb;
    this.wrappedEmit = options.wrappedEmit;
    this.stylesheetManager = options.stylesheetManager;
    this.recordCrossOriginIframes = options.recordCrossOriginIframes;
    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(
      this.stylesheetManager.styleMirror.generateId.bind(
        this.stylesheetManager.styleMirror
      )
    );
    this.mirror = options.mirror;
    if (this.recordCrossOriginIframes) {
      window.addEventListener("message", this.handleMessage.bind(this));
    }
  }
  addIframe(iframeEl) {
    this.iframes.set(iframeEl, true);
    if (iframeEl.contentWindow)
      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);
  }
  addLoadListener(cb) {
    this.loadListener = cb;
  }
  attachIframe(iframeEl, childSn) {
    var _a2, _b;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(iframeEl),
          nextId: null,
          node: childSn
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: true
    });
    if (this.recordCrossOriginIframes)
      (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(
        "message",
        this.handleMessage.bind(this)
      );
    (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);
    if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)
      this.stylesheetManager.adoptStyleSheets(
        iframeEl.contentDocument.adoptedStyleSheets,
        this.mirror.getId(iframeEl.contentDocument)
      );
  }
  handleMessage(message) {
    const crossOriginMessageEvent = message;
    if (crossOriginMessageEvent.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.
    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)
      return;
    const iframeSourceWindow = message.source;
    if (!iframeSourceWindow) return;
    const iframeEl = this.crossOriginIframeMap.get(message.source);
    if (!iframeEl) return;
    const transformedEvent = this.transformCrossOriginEvent(
      iframeEl,
      crossOriginMessageEvent.data.event
    );
    if (transformedEvent)
      this.wrappedEmit(
        transformedEvent,
        crossOriginMessageEvent.data.isCheckout
      );
  }
  transformCrossOriginEvent(iframeEl, e2) {
    var _a2;
    switch (e2.type) {
      case EventType.FullSnapshot: {
        this.crossOriginIframeMirror.reset(iframeEl);
        this.crossOriginIframeStyleMirror.reset(iframeEl);
        this.replaceIdOnNode(e2.data.node, iframeEl);
        const rootId = e2.data.node.id;
        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);
        this.patchRootIdOnNode(e2.data.node, rootId);
        return {
          timestamp: e2.timestamp,
          type: EventType.IncrementalSnapshot,
          data: {
            source: IncrementalSource.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(iframeEl),
                nextId: null,
                node: e2.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: true
          }
        };
      }
      case EventType.Meta:
      case EventType.Load:
      case EventType.DomContentLoaded: {
        return false;
      }
      case EventType.Plugin: {
        return e2;
      }
      case EventType.Custom: {
        this.replaceIds(
          e2.data.payload,
          iframeEl,
          ["id", "parentId", "previousId", "nextId"]
        );
        return e2;
      }
      case EventType.IncrementalSnapshot: {
        switch (e2.data.source) {
          case IncrementalSource.Mutation: {
            e2.data.adds.forEach((n2) => {
              this.replaceIds(n2, iframeEl, [
                "parentId",
                "nextId",
                "previousId"
              ]);
              this.replaceIdOnNode(n2.node, iframeEl);
              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);
              rootId && this.patchRootIdOnNode(n2.node, rootId);
            });
            e2.data.removes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["parentId", "id"]);
            });
            e2.data.attributes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            e2.data.texts.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource.Drag:
          case IncrementalSource.TouchMove:
          case IncrementalSource.MouseMove: {
            e2.data.positions.forEach((p) => {
              this.replaceIds(p, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource.ViewportResize: {
            return false;
          }
          case IncrementalSource.MediaInteraction:
          case IncrementalSource.MouseInteraction:
          case IncrementalSource.Scroll:
          case IncrementalSource.CanvasMutation:
          case IncrementalSource.Input: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            return e2;
          }
          case IncrementalSource.StyleSheetRule:
          case IncrementalSource.StyleDeclaration: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleId"]);
            return e2;
          }
          case IncrementalSource.Font: {
            return e2;
          }
          case IncrementalSource.Selection: {
            e2.data.ranges.forEach((range) => {
              this.replaceIds(range, iframeEl, ["start", "end"]);
            });
            return e2;
          }
          case IncrementalSource.AdoptedStyleSheet: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleIds"]);
            (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach((style) => {
              this.replaceStyleIds(style, iframeEl, ["styleId"]);
            });
            return e2;
          }
        }
      }
    }
    return false;
  }
  replace(iframeMirror, obj, iframeEl, keys) {
    for (const key of keys) {
      if (!Array.isArray(obj[key]) && typeof obj[key] !== "number") continue;
      if (Array.isArray(obj[key])) {
        obj[key] = iframeMirror.getIds(
          iframeEl,
          obj[key]
        );
      } else {
        obj[key] = iframeMirror.getId(iframeEl, obj[key]);
      }
    }
    return obj;
  }
  replaceIds(obj, iframeEl, keys) {
    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);
  }
  replaceStyleIds(obj, iframeEl, keys) {
    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);
  }
  replaceIdOnNode(node2, iframeEl) {
    this.replaceIds(node2, iframeEl, ["id", "rootId"]);
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.replaceIdOnNode(child, iframeEl);
      });
    }
  }
  patchRootIdOnNode(node2, rootId) {
    if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.patchRootIdOnNode(child, rootId);
      });
    }
  }
}
class ShadowDomManager {
  constructor(options) {
    __publicField(this, "shadowDoms", /* @__PURE__ */ new WeakSet());
    __publicField(this, "mutationCb");
    __publicField(this, "scrollCb");
    __publicField(this, "bypassOptions");
    __publicField(this, "mirror");
    __publicField(this, "restoreHandlers", []);
    this.mutationCb = options.mutationCb;
    this.scrollCb = options.scrollCb;
    this.bypassOptions = options.bypassOptions;
    this.mirror = options.mirror;
    this.init();
  }
  init() {
    this.reset();
    this.patchAttachShadow(Element, document);
  }
  addShadowRoot(shadowRoot2, doc) {
    if (!isNativeShadowDom(shadowRoot2)) return;
    if (this.shadowDoms.has(shadowRoot2)) return;
    this.shadowDoms.add(shadowRoot2);
    const observer = initMutationObserver(
      {
        ...this.bypassOptions,
        doc,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      },
      shadowRoot2
    );
    this.restoreHandlers.push(() => observer.disconnect());
    this.restoreHandlers.push(
      initScrollObserver({
        ...this.bypassOptions,
        scrollCb: this.scrollCb,
        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813
        // scroll is not allowed to pass the boundary, so we need to listen the shadow document
        doc: shadowRoot2,
        mirror: this.mirror
      })
    );
    setTimeout(() => {
      if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0)
        this.bypassOptions.stylesheetManager.adoptStyleSheets(
          shadowRoot2.adoptedStyleSheets,
          this.mirror.getId(index.host(shadowRoot2))
        );
      this.restoreHandlers.push(
        initAdoptedStyleSheetObserver(
          {
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          },
          shadowRoot2
        )
      );
    }, 0);
  }
  /**
   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.
   */
  observeAttachShadow(iframeElement) {
    if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;
    this.patchAttachShadow(
      iframeElement.contentWindow.Element,
      iframeElement.contentDocument
    );
  }
  /**
   * Patch 'attachShadow' to observe newly added shadow doms.
   */
  patchAttachShadow(element, doc) {
    const manager = this;
    this.restoreHandlers.push(
      patch(
        element.prototype,
        "attachShadow",
        function(original) {
          return function(option) {
            const sRoot = original.call(this, option);
            const shadowRootEl = index.shadowRoot(this);
            if (shadowRootEl && inDom(this))
              manager.addShadowRoot(shadowRootEl, doc);
            return sRoot;
          };
        }
      )
    );
  }
  reset() {
    this.restoreHandlers.forEach((handler) => {
      try {
        handler();
      } catch (e2) {
      }
    });
    this.restoreHandlers = [];
    this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) {
  lookup[chars.charCodeAt(i$1)] = i$1;
}
var encode = function(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
  for (i2 = 0; i2 < len; i2 += 3) {
    base64 += chars[bytes[i2] >> 2];
    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
    base64 += chars[bytes[i2 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
const canvasVarMap = /* @__PURE__ */ new Map();
function variableListFor$1(ctx, ctor) {
  let contextMap = canvasVarMap.get(ctx);
  if (!contextMap) {
    contextMap = /* @__PURE__ */ new Map();
    canvasVarMap.set(ctx, contextMap);
  }
  if (!contextMap.has(ctor)) {
    contextMap.set(ctor, []);
  }
  return contextMap.get(ctor);
}
const saveWebGLVar = (value, win, ctx) => {
  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === "object"))
    return;
  const name = value.constructor.name;
  const list2 = variableListFor$1(ctx, name);
  let index2 = list2.indexOf(value);
  if (index2 === -1) {
    index2 = list2.length;
    list2.push(value);
  }
  return index2;
};
function serializeArg(value, win, ctx) {
  if (value instanceof Array) {
    return value.map((arg) => serializeArg(arg, win, ctx));
  } else if (value === null) {
    return value;
  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [Object.values(value)]
    };
  } else if (
    // SharedArrayBuffer disabled on most browsers due to spectre.
    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer
    // value instanceof SharedArrayBuffer ||
    value instanceof ArrayBuffer
  ) {
    const name = value.constructor.name;
    const base64 = encode(value);
    return {
      rr_type: name,
      base64
    };
  } else if (value instanceof DataView) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [
        serializeArg(value.buffer, win, ctx),
        value.byteOffset,
        value.byteLength
      ]
    };
  } else if (value instanceof HTMLImageElement) {
    const name = value.constructor.name;
    const { src } = value;
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof HTMLCanvasElement) {
    const name = "HTMLImageElement";
    const src = value.toDataURL();
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof ImageData) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [serializeArg(value.data, win, ctx), value.width, value.height]
    };
  } else if (isInstanceOfWebGLObject(value, win) || typeof value === "object") {
    const name = value.constructor.name;
    const index2 = saveWebGLVar(value, win, ctx);
    return {
      rr_type: name,
      index: index2
    };
  }
  return value;
}
const serializeArgs = (args, win, ctx) => {
  return args.map((arg) => serializeArg(arg, win, ctx));
};
const isInstanceOfWebGLObject = (value, win) => {
  const webGLConstructorNames = [
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLFramebuffer",
    "WebGLProgram",
    "WebGLRenderbuffer",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLTexture",
    "WebGLUniformLocation",
    "WebGLVertexArrayObject",
    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.
    "WebGLVertexArrayObjectOES"
  ];
  const supportedWebGLConstructorNames = webGLConstructorNames.filter(
    (name) => typeof win[name] === "function"
  );
  return Boolean(
    supportedWebGLConstructorNames.find(
      (name) => value instanceof win[name]
    )
  );
};
function initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {
  const handlers = [];
  const props2D = Object.getOwnPropertyNames(
    win.CanvasRenderingContext2D.prototype
  );
  for (const prop of props2D) {
    try {
      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch(
        win.CanvasRenderingContext2D.prototype,
        prop,
        function(original) {
          return function(...args) {
            if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {
              setTimeout(() => {
                const recordArgs = serializeArgs(args, win, this);
                cb(this.canvas, {
                  type: CanvasContext["2D"],
                  property: prop,
                  args: recordArgs
                });
              }, 0);
            }
            return original.apply(this, args);
          };
        }
      );
      handlers.push(restoreHandler);
    } catch {
      const hookHandler = hookSetter(
        win.CanvasRenderingContext2D.prototype,
        prop,
        {
          set(v2) {
            cb(this.canvas, {
              type: CanvasContext["2D"],
              property: prop,
              args: [v2],
              setter: true
            });
          }
        }
      );
      handlers.push(hookHandler);
    }
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
function getNormalizedContextName(contextType) {
  return contextType === "experimental-webgl" ? "webgl" : contextType;
}
function initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {
  const handlers = [];
  try {
    const restoreHandler = patch(
      win.HTMLCanvasElement.prototype,
      "getContext",
      function(original) {
        return function(contextType, ...args) {
          if (!isBlocked(this, blockClass, blockSelector, true)) {
            const ctxName = getNormalizedContextName(contextType);
            if (!("__context" in this)) this.__context = ctxName;
            if (setPreserveDrawingBufferToTrue && ["webgl", "webgl2"].includes(ctxName)) {
              if (args[0] && typeof args[0] === "object") {
                const contextAttributes = args[0];
                if (!contextAttributes.preserveDrawingBuffer) {
                  contextAttributes.preserveDrawingBuffer = true;
                }
              } else {
                args.splice(0, 1, {
                  preserveDrawingBuffer: true
                });
              }
            }
          }
          return original.apply(this, [contextType, ...args]);
        };
      }
    );
    handlers.push(restoreHandler);
  } catch {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
function patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {
  const handlers = [];
  const props = Object.getOwnPropertyNames(prototype);
  for (const prop of props) {
    if (
      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky
      [
        "isContextLost",
        "canvas",
        "drawingBufferWidth",
        "drawingBufferHeight"
      ].includes(prop)
    ) {
      continue;
    }
    try {
      if (typeof prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch(
        prototype,
        prop,
        function(original) {
          return function(...args) {
            const result2 = original.apply(this, args);
            saveWebGLVar(result2, win, this);
            if ("tagName" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {
              const recordArgs = serializeArgs(args, win, this);
              const mutation = {
                type,
                property: prop,
                args: recordArgs
              };
              cb(this.canvas, mutation);
            }
            return result2;
          };
        }
      );
      handlers.push(restoreHandler);
    } catch {
      const hookHandler = hookSetter(prototype, prop, {
        set(v2) {
          cb(this.canvas, {
            type,
            property: prop,
            args: [v2],
            setter: true
          });
        }
      });
      handlers.push(hookHandler);
    }
  }
  return handlers;
}
function initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {
  const handlers = [];
  handlers.push(
    ...patchGLPrototype(
      win.WebGLRenderingContext.prototype,
      CanvasContext.WebGL,
      cb,
      blockClass,
      blockSelector,
      win
    )
  );
  if (typeof win.WebGL2RenderingContext !== "undefined") {
    handlers.push(
      ...patchGLPrototype(
        win.WebGL2RenderingContext.prototype,
        CanvasContext.WebGL2,
        cb,
        blockClass,
        blockSelector,
        win
      )
    );
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
const encodedJs = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=";
const decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0));
const blob = typeof window !== "undefined" && window.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e2) {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
class CanvasManager {
  constructor(options) {
    __publicField(this, "pendingCanvasMutations", /* @__PURE__ */ new Map());
    __publicField(this, "rafStamps", { latestId: 0, invokeId: null });
    __publicField(this, "mirror");
    __publicField(this, "mutationCb");
    __publicField(this, "resetObservers");
    __publicField(this, "frozen", false);
    __publicField(this, "locked", false);
    __publicField(this, "processMutation", (target, mutation) => {
      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
      if (newFrame || !this.rafStamps.invokeId)
        this.rafStamps.invokeId = this.rafStamps.latestId;
      if (!this.pendingCanvasMutations.has(target)) {
        this.pendingCanvasMutations.set(target, []);
      }
      this.pendingCanvasMutations.get(target).push(mutation);
    });
    const {
      sampling = "all",
      win,
      blockClass,
      blockSelector,
      recordCanvas,
      dataURLOptions
    } = options;
    this.mutationCb = options.mutationCb;
    this.mirror = options.mirror;
    if (recordCanvas && sampling === "all")
      this.initCanvasMutationObserver(win, blockClass, blockSelector);
    if (recordCanvas && typeof sampling === "number")
      this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {
        dataURLOptions
      });
  }
  reset() {
    this.pendingCanvasMutations.clear();
    this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = true;
  }
  unfreeze() {
    this.frozen = false;
  }
  lock() {
    this.locked = true;
  }
  unlock() {
    this.locked = false;
  }
  initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {
    const canvasContextReset = initCanvasContextObserver(
      win,
      blockClass,
      blockSelector,
      true
    );
    const snapshotInProgressMap = /* @__PURE__ */ new Map();
    const worker = new WorkerWrapper();
    worker.onmessage = (e2) => {
      const { id } = e2.data;
      snapshotInProgressMap.set(id, false);
      if (!("base64" in e2.data)) return;
      const { base64, type, width, height } = e2.data;
      this.mutationCb({
        id,
        type: CanvasContext["2D"],
        commands: [
          {
            property: "clearRect",
            // wipe canvas
            args: [0, 0, width, height]
          },
          {
            property: "drawImage",
            // draws (semi-transparent) image
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64 }],
                    type
                  }
                ]
              },
              0,
              0
            ]
          }
        ]
      });
    };
    const timeBetweenSnapshots = 1e3 / fps;
    let lastSnapshotTime = 0;
    let rafId;
    const getCanvas = () => {
      const matchedCanvas = [];
      win.document.querySelectorAll("canvas").forEach((canvas) => {
        if (!isBlocked(canvas, blockClass, blockSelector, true)) {
          matchedCanvas.push(canvas);
        }
      });
      return matchedCanvas;
    };
    const takeCanvasSnapshots = (timestamp) => {
      if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {
        rafId = requestAnimationFrame(takeCanvasSnapshots);
        return;
      }
      lastSnapshotTime = timestamp;
      getCanvas().forEach(async (canvas) => {
        var _a2;
        const id = this.mirror.getId(canvas);
        if (snapshotInProgressMap.get(id)) return;
        if (canvas.width === 0 || canvas.height === 0) return;
        snapshotInProgressMap.set(id, true);
        if (["webgl", "webgl2"].includes(canvas.__context)) {
          const context = canvas.getContext(canvas.__context);
          if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {
            context.clear(context.COLOR_BUFFER_BIT);
          }
        }
        const bitmap = await createImageBitmap(canvas);
        worker.postMessage(
          {
            id,
            bitmap,
            width: canvas.width,
            height: canvas.height,
            dataURLOptions: options.dataURLOptions
          },
          [bitmap]
        );
      });
      rafId = requestAnimationFrame(takeCanvasSnapshots);
    };
    rafId = requestAnimationFrame(takeCanvasSnapshots);
    this.resetObservers = () => {
      canvasContextReset();
      cancelAnimationFrame(rafId);
    };
  }
  initCanvasMutationObserver(win, blockClass, blockSelector) {
    this.startRAFTimestamping();
    this.startPendingCanvasMutationFlusher();
    const canvasContextReset = initCanvasContextObserver(
      win,
      blockClass,
      blockSelector,
      false
    );
    const canvas2DReset = initCanvas2DMutationObserver(
      this.processMutation.bind(this),
      win,
      blockClass,
      blockSelector
    );
    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(
      this.processMutation.bind(this),
      win,
      blockClass,
      blockSelector
    );
    this.resetObservers = () => {
      canvasContextReset();
      canvas2DReset();
      canvasWebGL1and2Reset();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const setLatestRAFTimestamp = (timestamp) => {
      this.rafStamps.latestId = timestamp;
      requestAnimationFrame(setLatestRAFTimestamp);
    };
    requestAnimationFrame(setLatestRAFTimestamp);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach(
      (_values, canvas) => {
        const id = this.mirror.getId(canvas);
        this.flushPendingCanvasMutationFor(canvas, id);
      }
    );
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(canvas, id) {
    if (this.frozen || this.locked) {
      return;
    }
    const valuesWithType = this.pendingCanvasMutations.get(canvas);
    if (!valuesWithType || id === -1) return;
    const values = valuesWithType.map((value) => {
      const { type: type2, ...rest } = value;
      return rest;
    });
    const { type } = valuesWithType[0];
    this.mutationCb({ id, type, commands: values });
    this.pendingCanvasMutations.delete(canvas);
  }
}
class StylesheetManager {
  constructor(options) {
    __publicField(this, "trackedLinkElements", /* @__PURE__ */ new WeakSet());
    __publicField(this, "mutationCb");
    __publicField(this, "adoptedStyleSheetCb");
    __publicField(this, "styleMirror", new StyleSheetMirror());
    this.mutationCb = options.mutationCb;
    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;
  }
  attachLinkElement(linkEl, childSn) {
    if ("_cssText" in childSn.attributes)
      this.mutationCb({
        adds: [],
        removes: [],
        texts: [],
        attributes: [
          {
            id: childSn.id,
            attributes: childSn.attributes
          }
        ]
      });
    this.trackLinkElement(linkEl);
  }
  trackLinkElement(linkEl) {
    if (this.trackedLinkElements.has(linkEl)) return;
    this.trackedLinkElements.add(linkEl);
    this.trackStylesheetInLinkElement(linkEl);
  }
  adoptStyleSheets(sheets, hostId) {
    if (sheets.length === 0) return;
    const adoptedStyleSheetData = {
      id: hostId,
      styleIds: []
    };
    const styles = [];
    for (const sheet of sheets) {
      let styleId;
      if (!this.styleMirror.has(sheet)) {
        styleId = this.styleMirror.add(sheet);
        styles.push({
          styleId,
          rules: Array.from(sheet.rules || CSSRule, (r2, index2) => ({
            rule: stringifyRule(r2, sheet.href),
            index: index2
          }))
        });
      } else styleId = this.styleMirror.getId(sheet);
      adoptedStyleSheetData.styleIds.push(styleId);
    }
    if (styles.length > 0) adoptedStyleSheetData.styles = styles;
    this.adoptedStyleSheetCb(adoptedStyleSheetData);
  }
  reset() {
    this.styleMirror.reset();
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  // TODO: take snapshot on stylesheet reload by applying event listener
  trackStylesheetInLinkElement(_linkEl) {
  }
}
class ProcessedNodeManager {
  constructor() {
    __publicField(this, "nodeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "active", false);
  }
  inOtherBuffer(node2, thisBuffer) {
    const buffers = this.nodeMap.get(node2);
    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);
  }
  add(node2, buffer) {
    if (!this.active) {
      this.active = true;
      requestAnimationFrame(() => {
        this.nodeMap = /* @__PURE__ */ new WeakMap();
        this.active = false;
      });
    }
    this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));
  }
  destroy() {
  }
}
let wrappedEmit;
let takeFullSnapshot$1;
let canvasManager;
let recording = false;
try {
  if (Array.from([1], (x2) => x2 * 2)[0] !== 2) {
    const cleanFrame = document.createElement("iframe");
    document.body.appendChild(cleanFrame);
    Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;
    document.body.removeChild(cleanFrame);
  }
} catch (err) {
  console.debug("Unable to override Array.from", err);
}
const mirror = createMirror$2();
function record(options = {}) {
  const {
    emit,
    checkoutEveryNms,
    checkoutEveryNth,
    blockClass = "rr-block",
    blockSelector = null,
    ignoreClass = "rr-ignore",
    ignoreSelector = null,
    maskTextClass = "rr-mask",
    maskTextSelector = null,
    inlineStylesheet = true,
    maskAllInputs,
    maskInputOptions: _maskInputOptions,
    slimDOMOptions: _slimDOMOptions,
    maskInputFn,
    maskTextFn,
    hooks,
    packFn,
    sampling = {},
    dataURLOptions = {},
    mousemoveWait,
    recordDOM = true,
    recordCanvas = false,
    recordCrossOriginIframes = false,
    recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load",
    userTriggeredOnInput = false,
    collectFonts = false,
    inlineImages = false,
    plugins,
    keepIframeSrcFn = () => false,
    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),
    errorHandler: errorHandler2
  } = options;
  registerErrorHandler(errorHandler2);
  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;
  let passEmitsToParent = false;
  if (!inEmittingFrame) {
    try {
      if (window.parent.document) {
        passEmitsToParent = false;
      }
    } catch (e2) {
      passEmitsToParent = true;
    }
  }
  if (inEmittingFrame && !emit) {
    throw new Error("emit function is required");
  }
  if (!inEmittingFrame && !passEmitsToParent) {
    return () => {
    };
  }
  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {
    sampling.mousemove = mousemoveWait;
  }
  mirror.reset();
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : _maskInputOptions !== void 0 ? _maskInputOptions : { password: true };
  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {
    script: true,
    comment: true,
    headFavicon: true,
    headWhitespace: true,
    headMetaSocial: true,
    headMetaRobots: true,
    headMetaHttpEquiv: true,
    headMetaVerification: true,
    // the following are off for slimDOMOptions === true,
    // as they destroy some (hidden) info:
    headMetaAuthorship: _slimDOMOptions === "all",
    headMetaDescKeywords: _slimDOMOptions === "all",
    headTitleMutations: _slimDOMOptions === "all"
  } : _slimDOMOptions ? _slimDOMOptions : {};
  polyfill$1();
  let lastFullSnapshotEvent;
  let incrementalSnapshotCount = 0;
  const eventProcessor = (e2) => {
    for (const plugin3 of plugins || []) {
      if (plugin3.eventProcessor) {
        e2 = plugin3.eventProcessor(e2);
      }
    }
    if (packFn && // Disable packing events which will be emitted to parent frames.
    !passEmitsToParent) {
      e2 = packFn(e2);
    }
    return e2;
  };
  wrappedEmit = (r2, isCheckout) => {
    var _a2;
    const e2 = r2;
    e2.timestamp = nowTimestamp();
    if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {
      mutationBuffers.forEach((buf) => buf.unfreeze());
    }
    if (inEmittingFrame) {
      emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);
    } else if (passEmitsToParent) {
      const message = {
        type: "rrweb",
        event: eventProcessor(e2),
        origin: window.location.origin,
        isCheckout
      };
      window.parent.postMessage(message, "*");
    }
    if (e2.type === EventType.FullSnapshot) {
      lastFullSnapshotEvent = e2;
      incrementalSnapshotCount = 0;
    } else if (e2.type === EventType.IncrementalSnapshot) {
      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {
        return;
      }
      incrementalSnapshotCount++;
      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
      const exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
      if (exceedCount || exceedTime) {
        takeFullSnapshot$1(true);
      }
    }
  };
  const wrappedMutationEmit = (m) => {
    wrappedEmit({
      type: EventType.IncrementalSnapshot,
      data: {
        source: IncrementalSource.Mutation,
        ...m
      }
    });
  };
  const wrappedScrollEmit = (p) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.Scroll,
      ...p
    }
  });
  const wrappedCanvasMutationEmit = (p) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.CanvasMutation,
      ...p
    }
  });
  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.AdoptedStyleSheet,
      ...a2
    }
  });
  const stylesheetManager = new StylesheetManager({
    mutationCb: wrappedMutationEmit,
    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit
  });
  const iframeManager = new IframeManager({
    mirror,
    mutationCb: wrappedMutationEmit,
    stylesheetManager,
    recordCrossOriginIframes,
    wrappedEmit
  });
  for (const plugin3 of plugins || []) {
    if (plugin3.getMirror)
      plugin3.getMirror({
        nodeMirror: mirror,
        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror
      });
  }
  const processedNodeManager = new ProcessedNodeManager();
  canvasManager = new CanvasManager({
    recordCanvas,
    mutationCb: wrappedCanvasMutationEmit,
    win: window,
    blockClass,
    blockSelector,
    mirror,
    sampling: sampling.canvas,
    dataURLOptions
  });
  const shadowDomManager = new ShadowDomManager({
    mutationCb: wrappedMutationEmit,
    scrollCb: wrappedScrollEmit,
    bypassOptions: {
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskInputOptions,
      dataURLOptions,
      maskTextFn,
      maskInputFn,
      recordCanvas,
      inlineImages,
      sampling,
      slimDOMOptions,
      iframeManager,
      stylesheetManager,
      canvasManager,
      keepIframeSrcFn,
      processedNodeManager
    },
    mirror
  });
  takeFullSnapshot$1 = (isCheckout = false) => {
    if (!recordDOM) {
      return;
    }
    wrappedEmit(
      {
        type: EventType.Meta,
        data: {
          href: window.location.href,
          width: getWindowWidth(),
          height: getWindowHeight()
        }
      },
      isCheckout
    );
    stylesheetManager.reset();
    shadowDomManager.init();
    mutationBuffers.forEach((buf) => buf.lock());
    const node2 = snapshot(document, {
      mirror,
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskAllInputs: maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOM: slimDOMOptions,
      dataURLOptions,
      recordCanvas,
      inlineImages,
      onSerialize: (n2) => {
        if (isSerializedIframe(n2, mirror)) {
          iframeManager.addIframe(n2);
        }
        if (isSerializedStylesheet(n2, mirror)) {
          stylesheetManager.trackLinkElement(n2);
        }
        if (hasShadowRoot(n2)) {
          shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);
        }
      },
      onIframeLoad: (iframe, childSn) => {
        iframeManager.attachIframe(iframe, childSn);
        shadowDomManager.observeAttachShadow(iframe);
      },
      onStylesheetLoad: (linkEl, childSn) => {
        stylesheetManager.attachLinkElement(linkEl, childSn);
      },
      keepIframeSrcFn
    });
    if (!node2) {
      return console.warn("Failed to snapshot the document");
    }
    wrappedEmit(
      {
        type: EventType.FullSnapshot,
        data: {
          node: node2,
          initialOffset: getWindowScroll(window)
        }
      },
      isCheckout
    );
    mutationBuffers.forEach((buf) => buf.unlock());
    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
      stylesheetManager.adoptStyleSheets(
        document.adoptedStyleSheets,
        mirror.getId(document)
      );
  };
  try {
    const handlers = [];
    const observe = (doc) => {
      var _a2;
      return callbackWrapper(initObservers)(
        {
          mutationCb: wrappedMutationEmit,
          mousemoveCb: (positions, source) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source,
              positions
            }
          }),
          mouseInteractionCb: (d) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MouseInteraction,
              ...d
            }
          }),
          scrollCb: wrappedScrollEmit,
          viewportResizeCb: (d) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.ViewportResize,
              ...d
            }
          }),
          inputCb: (v2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Input,
              ...v2
            }
          }),
          mediaInteractionCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MediaInteraction,
              ...p
            }
          }),
          styleSheetRuleCb: (r2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleSheetRule,
              ...r2
            }
          }),
          styleDeclarationCb: (r2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleDeclaration,
              ...r2
            }
          }),
          canvasMutationCb: wrappedCanvasMutationEmit,
          fontCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Font,
              ...p
            }
          }),
          selectionCb: (p) => {
            wrappedEmit({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.Selection,
                ...p
              }
            });
          },
          customElementCb: (c2) => {
            wrappedEmit({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.CustomElement,
                ...c2
              }
            });
          },
          blockClass,
          ignoreClass,
          ignoreSelector,
          maskTextClass,
          maskTextSelector,
          maskInputOptions,
          inlineStylesheet,
          sampling,
          recordDOM,
          recordCanvas,
          inlineImages,
          userTriggeredOnInput,
          collectFonts,
          doc,
          maskInputFn,
          maskTextFn,
          keepIframeSrcFn,
          blockSelector,
          slimDOMOptions,
          dataURLOptions,
          mirror,
          iframeManager,
          stylesheetManager,
          shadowDomManager,
          processedNodeManager,
          canvasManager,
          ignoreCSSAttributes,
          plugins: ((_a2 = plugins == null ? void 0 : plugins.filter((p) => p.observer)) == null ? void 0 : _a2.map((p) => ({
            observer: p.observer,
            options: p.options,
            callback: (payload) => wrappedEmit({
              type: EventType.Plugin,
              data: {
                plugin: p.name,
                payload
              }
            })
          }))) || []
        },
        hooks
      );
    };
    iframeManager.addLoadListener((iframeEl) => {
      try {
        handlers.push(observe(iframeEl.contentDocument));
      } catch (error) {
        console.warn(error);
      }
    });
    const init = () => {
      takeFullSnapshot$1();
      handlers.push(observe(document));
      recording = true;
    };
    if (document.readyState === "interactive" || document.readyState === "complete") {
      init();
    } else {
      handlers.push(
        on("DOMContentLoaded", () => {
          wrappedEmit({
            type: EventType.DomContentLoaded,
            data: {}
          });
          if (recordAfter === "DOMContentLoaded") init();
        })
      );
      handlers.push(
        on(
          "load",
          () => {
            wrappedEmit({
              type: EventType.Load,
              data: {}
            });
            if (recordAfter === "load") init();
          },
          window
        )
      );
    }
    return () => {
      handlers.forEach((h) => h());
      processedNodeManager.destroy();
      recording = false;
      unregisterErrorHandler();
    };
  } catch (error) {
    console.warn(error);
  }
}
record.addCustomEvent = (tag, payload) => {
  if (!recording) {
    throw new Error("please add custom event after start recording");
  }
  wrappedEmit({
    type: EventType.Custom,
    data: {
      tag,
      payload
    }
  });
};
record.freezePage = () => {
  mutationBuffers.forEach((buf) => buf.freeze());
};
record.takeFullSnapshot = (isCheckout) => {
  if (!recording) {
    throw new Error("please take full snapshot after start recording");
  }
  takeFullSnapshot$1(isCheckout);
};
record.mirror = mirror;
var n;
!function(t2) {
  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
}(n || (n = {}));

//# sourceMappingURL=record.js.map


/***/ }),

/***/ "./node_modules/@rrweb/types/dist/types.js":
/*!*************************************************!*\
  !*** ./node_modules/@rrweb/types/dist/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasContext: () => (/* binding */ CanvasContext),
/* harmony export */   EventType: () => (/* binding */ EventType),
/* harmony export */   IncrementalSource: () => (/* binding */ IncrementalSource),
/* harmony export */   MediaInteractions: () => (/* binding */ MediaInteractions),
/* harmony export */   MouseInteractions: () => (/* binding */ MouseInteractions),
/* harmony export */   NodeType: () => (/* binding */ NodeType),
/* harmony export */   PointerTypes: () => (/* binding */ PointerTypes),
/* harmony export */   ReplayerEvents: () => (/* binding */ ReplayerEvents)
/* harmony export */ });
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType || {});
var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource || {});
var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(MouseInteractions || {});
var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(PointerTypes || {});
var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(CanvasContext || {});
var MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
  return MediaInteractions2;
})(MediaInteractions || {});
var ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {
  ReplayerEvents2["Start"] = "start";
  ReplayerEvents2["Pause"] = "pause";
  ReplayerEvents2["Resume"] = "resume";
  ReplayerEvents2["Resize"] = "resize";
  ReplayerEvents2["Finish"] = "finish";
  ReplayerEvents2["FullsnapshotRebuilded"] = "fullsnapshot-rebuilded";
  ReplayerEvents2["LoadStylesheetStart"] = "load-stylesheet-start";
  ReplayerEvents2["LoadStylesheetEnd"] = "load-stylesheet-end";
  ReplayerEvents2["SkipStart"] = "skip-start";
  ReplayerEvents2["SkipEnd"] = "skip-end";
  ReplayerEvents2["MouseInteraction"] = "mouse-interaction";
  ReplayerEvents2["EventCast"] = "event-cast";
  ReplayerEvents2["CustomEvent"] = "custom-event";
  ReplayerEvents2["Flush"] = "flush";
  ReplayerEvents2["StateChange"] = "state-change";
  ReplayerEvents2["PlayBack"] = "play-back";
  ReplayerEvents2["Destroy"] = "destroy";
  return ReplayerEvents2;
})(ReplayerEvents || {});
var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType || {});

//# sourceMappingURL=types.js.map


/***/ }),

/***/ "./node_modules/console-polyfill/index.js":
/*!************************************************!*\
  !*** ./node_modules/console-polyfill/index.js ***!
  \************************************************/
/***/ (function() {

// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function(global) {
  'use strict';
  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function() {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);


/***/ }),

/***/ "./node_modules/error-stack-parser/error-stack-parser.js":
/*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/error-stack-parser/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                    .replace(/<anonymous function(: (\w+))?>/, '$2')
                    .replace(/\([^)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ "./node_modules/error-stack-parser/node_modules/stackframe/stackframe.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/error-stack-parser/node_modules/stackframe/stackframe.js ***!
  \*******************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./src/api.js":
/*!********************!*\
  !*** ./src/api.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var helpers = __webpack_require__(/*! ./apiUtility */ "./src/apiUtility.js");
var defaultOptions = {
  hostname: 'api.rollbar.com',
  path: '/api/1/item/',
  search: null,
  version: '1',
  protocol: 'https:',
  port: 443
};
var OTLPDefaultOptions = {
  hostname: 'api.rollbar.com',
  path: '/api/1/session/',
  search: null,
  version: '1',
  protocol: 'https:',
  port: 443
};

/**
 * Api is an object that encapsulates methods of communicating with
 * the Rollbar API.  It is a standard interface with some parts implemented
 * differently for server or browser contexts.  It is an object that should
 * be instantiated when used so it can contain non-global options that may
 * be different for another instance of RollbarApi.
 *
 * @param options {
 *    accessToken: the accessToken to use for posting items to rollbar
 *    endpoint: an alternative endpoint to send errors to
 *        must be a valid, fully qualified URL.
 *        The default is: https://api.rollbar.com/api/1/item
 *    proxy: if you wish to proxy requests provide an object
 *        with the following keys:
 *          host or hostname (required): foo.example.com
 *          port (optional): 123
 *          protocol (optional): https
 * }
 */
function Api(options, transport, urllib, truncation) {
  this.options = options;
  this.transport = transport;
  this.url = urllib;
  this.truncation = truncation;
  this.accessToken = options.accessToken;
  this.transportOptions = _getTransport(options, urllib);
  this.OTLPTransportOptions = _getOTLPTransport(options, urllib);
}

/**
 * Wraps transport.post in a Promise to support async/await
 *
 * @param {Object} options - Options for the API request
 * @param {string} options.accessToken - The access token for authentication
 * @param {Object} options.transportOptions - Options for the transport
 * @param {Object} options.payload - The data payload to send
 * @returns {Promise} A promise that resolves with the response or rejects with an error
 * @private
 */
Api.prototype._postPromise = function (_ref) {
  var accessToken = _ref.accessToken,
    transportOptions = _ref.transportOptions,
    payload = _ref.payload;
  var self = this;
  return new Promise(function (resolve, reject) {
    self.transport.post(accessToken, transportOptions, payload, function (err, resp) {
      return err ? reject(err) : resolve(resp);
    });
  });
};

/**
 *
 * @param data
 * @param callback
 */
Api.prototype.postItem = function (data, callback) {
  var transportOptions = helpers.transportOptions(this.transportOptions, 'POST');
  var payload = helpers.buildPayload(data);
  var self = this;

  // ensure the network request is scheduled after the current tick.
  setTimeout(function () {
    self.transport.post(self.accessToken, transportOptions, payload, callback);
  }, 0);
};

/**
 * Posts spans to the Rollbar API using the session endpoint
 *
 * @param {Array} payload - The spans to send
 * @returns {Promise<Object>} A promise that resolves with the API response
 */
Api.prototype.postSpans = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(payload) {
    var transportOptions;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          transportOptions = helpers.transportOptions(this.OTLPTransportOptions, 'POST');
          _context.next = 3;
          return this._postPromise({
            accessToken: this.accessToken,
            transportOptions: transportOptions,
            payload: payload
          });
        case 3:
          return _context.abrupt("return", _context.sent);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  }));
  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 *
 * @param data
 * @param callback
 */
Api.prototype.buildJsonPayload = function (data, callback) {
  var payload = helpers.buildPayload(data);
  var stringifyResult;
  if (this.truncation) {
    stringifyResult = this.truncation.truncate(payload);
  } else {
    stringifyResult = _.stringify(payload);
  }
  if (stringifyResult.error) {
    if (callback) {
      callback(stringifyResult.error);
    }
    return null;
  }
  return stringifyResult.value;
};

/**
 *
 * @param jsonPayload
 * @param callback
 */
Api.prototype.postJsonPayload = function (jsonPayload, callback) {
  var transportOptions = helpers.transportOptions(this.transportOptions, 'POST');
  this.transport.postJsonPayload(this.accessToken, transportOptions, jsonPayload, callback);
};
Api.prototype.configure = function (options) {
  var oldOptions = this.oldOptions;
  this.options = _.merge(oldOptions, options);
  this.transportOptions = _getTransport(this.options, this.url);
  this.OTLPTransportOptions = _getOTLPTransport(this.options, this.url);
  if (this.options.accessToken !== undefined) {
    this.accessToken = this.options.accessToken;
  }
  return this;
};
function _getTransport(options, url) {
  return helpers.getTransportFromOptions(options, defaultOptions, url);
}
function _getOTLPTransport(options, url) {
  var _options$tracing;
  options = _objectSpread(_objectSpread({}, options), {}, {
    endpoint: (_options$tracing = options.tracing) === null || _options$tracing === void 0 ? void 0 : _options$tracing.endpoint
  });
  return helpers.getTransportFromOptions(options, OTLPDefaultOptions, url);
}
module.exports = Api;

/***/ }),

/***/ "./src/apiUtility.js":
/*!***************************!*\
  !*** ./src/apiUtility.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
function buildPayload(data) {
  if (!_.isType(data.context, 'string')) {
    var contextResult = _.stringify(data.context);
    if (contextResult.error) {
      data.context = "Error: could not serialize 'context'";
    } else {
      data.context = contextResult.value || '';
    }
    if (data.context.length > 255) {
      data.context = data.context.substr(0, 255);
    }
  }
  return {
    data: data
  };
}
function getTransportFromOptions(options, defaults, url) {
  var hostname = defaults.hostname;
  var protocol = defaults.protocol;
  var port = defaults.port;
  var path = defaults.path;
  var search = defaults.search;
  var timeout = options.timeout;
  var transport = detectTransport(options);
  var proxy = options.proxy;
  if (options.endpoint) {
    var opts = url.parse(options.endpoint);
    hostname = opts.hostname;
    protocol = opts.protocol;
    port = opts.port;
    path = opts.pathname;
    search = opts.search;
  }
  return {
    timeout: timeout,
    hostname: hostname,
    protocol: protocol,
    port: port,
    path: path,
    search: search,
    proxy: proxy,
    transport: transport
  };
}
function detectTransport(options) {
  var gWindow = typeof window != 'undefined' && window || typeof self != 'undefined' && self;
  var transport = options.defaultTransport || 'xhr';
  if (typeof gWindow.fetch === 'undefined') transport = 'xhr';
  if (typeof gWindow.XMLHttpRequest === 'undefined') transport = 'fetch';
  return transport;
}
function transportOptions(transport, method) {
  var protocol = transport.protocol || 'https:';
  var port = transport.port || (protocol === 'http:' ? 80 : protocol === 'https:' ? 443 : undefined);
  var hostname = transport.hostname;
  var path = transport.path;
  var timeout = transport.timeout;
  var transportAPI = transport.transport;
  if (transport.search) {
    path = path + transport.search;
  }
  if (transport.proxy) {
    path = protocol + '//' + hostname + path;
    hostname = transport.proxy.host || transport.proxy.hostname;
    port = transport.proxy.port;
    protocol = transport.proxy.protocol || protocol;
  }
  return {
    timeout: timeout,
    protocol: protocol,
    hostname: hostname,
    path: path,
    port: port,
    method: method,
    transport: transportAPI
  };
}
function appendPathToPath(base, path) {
  var baseTrailingSlash = /\/$/.test(base);
  var pathBeginningSlash = /^\//.test(path);
  if (baseTrailingSlash && pathBeginningSlash) {
    path = path.substring(1);
  } else if (!baseTrailingSlash && !pathBeginningSlash) {
    path = '/' + path;
  }
  return base + path;
}
module.exports = {
  buildPayload: buildPayload,
  getTransportFromOptions: getTransportFromOptions,
  transportOptions: transportOptions,
  appendPathToPath: appendPathToPath
};

/***/ }),

/***/ "./src/browser/core.js":
/*!*****************************!*\
  !*** ./src/browser/core.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Client = __webpack_require__(/*! ../rollbar */ "./src/rollbar.js");
var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var API = __webpack_require__(/*! ../api */ "./src/api.js");
var logger = __webpack_require__(/*! ./logger */ "./src/browser/logger.js");
var globals = __webpack_require__(/*! ./globalSetup */ "./src/browser/globalSetup.js");
var Transport = __webpack_require__(/*! ./transport */ "./src/browser/transport.js");
var urllib = __webpack_require__(/*! ./url */ "./src/browser/url.js");
var transforms = __webpack_require__(/*! ./transforms */ "./src/browser/transforms.js");
var sharedTransforms = __webpack_require__(/*! ../transforms */ "./src/transforms.js");
var predicates = __webpack_require__(/*! ./predicates */ "./src/browser/predicates.js");
var sharedPredicates = __webpack_require__(/*! ../predicates */ "./src/predicates.js");
var errorParser = __webpack_require__(/*! ../errorParser */ "./src/errorParser.js");
var recorderDefaults = __webpack_require__(/*! ./replay/defaults */ "./src/browser/replay/defaults.js");
var tracingDefaults = __webpack_require__(/*! ../tracing/defaults */ "./src/tracing/defaults.js");
var ReplayMap = (__webpack_require__(/*! ./replay/replayMap */ "./src/browser/replay/replayMap.js")["default"]);
function Rollbar(options, client) {
  this.options = _.handleOptions(defaultOptions, options, null, logger);
  this.options._configuredOptions = options;
  var Telemeter = this.components.telemeter;
  var Instrumenter = this.components.instrumenter;
  var polyfillJSON = this.components.polyfillJSON;
  this.wrapGlobals = this.components.wrapGlobals;
  this.scrub = this.components.scrub;
  var truncation = this.components.truncation;
  var Tracing = this.components.tracing;
  var Recorder = this.components.recorder;
  var transport = new Transport(truncation);
  var api = new API(this.options, transport, urllib, truncation);
  if (Tracing) {
    this.tracing = new Tracing(_gWindow(), this.options);
    this.tracing.initSession();
  }
  if (Recorder && _.isBrowser()) {
    var recorderOptions = this.options.recorder;
    this.recorder = new Recorder(recorderOptions);
    this.replayMap = new ReplayMap({
      recorder: this.recorder,
      api: api,
      tracing: this.tracing
    });
    if (recorderOptions.enabled && recorderOptions.autoStart) {
      this.recorder.start();
    }
  }
  if (Telemeter) {
    this.telemeter = new Telemeter(this.options, this.tracing);
  }
  this.client = client || new Client(this.options, api, logger, this.telemeter, this.tracing, this.replayMap, 'browser');
  var gWindow = _gWindow();
  var gDocument = typeof document != 'undefined' && document;
  this.isChrome = gWindow.chrome && gWindow.chrome.runtime; // check .runtime to avoid Edge browsers
  this.anonymousErrorsPending = 0;
  addTransformsToNotifier(this.client.notifier, this, gWindow);
  addPredicatesToQueue(this.client.queue);
  this.setupUnhandledCapture();
  if (Instrumenter) {
    this.instrumenter = new Instrumenter(this.options, this.client.telemeter, this, gWindow, gDocument);
    this.instrumenter.instrument();
  }
  _.setupJSON(polyfillJSON);

  // Used with rollbar-react for rollbar-react-native compatibility.
  this.rollbar = this;
}
var _instance = null;
Rollbar.init = function (options, client) {
  if (_instance) {
    return _instance.global(options).configure(options);
  }
  _instance = new Rollbar(options, client);
  return _instance;
};
Rollbar.prototype.components = {};
Rollbar.setComponents = function (components) {
  Rollbar.prototype.components = components;
};
function handleUninitialized(maybeCallback) {
  var message = 'Rollbar is not initialized';
  logger.error(message);
  if (maybeCallback) {
    maybeCallback(new Error(message));
  }
}
Rollbar.prototype.global = function (options) {
  this.client.global(options);
  return this;
};
Rollbar.global = function (options) {
  if (_instance) {
    return _instance.global(options);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.configure = function (options, payloadData) {
  var _this$recorder;
  var oldOptions = this.options;
  var payload = {};
  if (payloadData) {
    payload = {
      payload: payloadData
    };
  }
  this.options = _.handleOptions(oldOptions, options, payload, logger);
  this.options._configuredOptions = _.handleOptions(oldOptions._configuredOptions, options, payload);
  (_this$recorder = this.recorder) === null || _this$recorder === void 0 || _this$recorder.configure(this.options);
  this.client.configure(this.options, payloadData);
  this.instrumenter && this.instrumenter.configure(this.options);
  this.setupUnhandledCapture();
  return this;
};
Rollbar.configure = function (options, payloadData) {
  if (_instance) {
    return _instance.configure(options, payloadData);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.lastError = function () {
  return this.client.lastError;
};
Rollbar.lastError = function () {
  if (_instance) {
    return _instance.lastError();
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.log = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.log(item);
  return {
    uuid: uuid
  };
};
Rollbar.log = function () {
  if (_instance) {
    return _instance.log.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.debug = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.debug(item);
  return {
    uuid: uuid
  };
};
Rollbar.debug = function () {
  if (_instance) {
    return _instance.debug.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.info = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.info(item);
  return {
    uuid: uuid
  };
};
Rollbar.info = function () {
  if (_instance) {
    return _instance.info.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.warn = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.warn(item);
  return {
    uuid: uuid
  };
};
Rollbar.warn = function () {
  if (_instance) {
    return _instance.warn.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.warning = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.warning(item);
  return {
    uuid: uuid
  };
};
Rollbar.warning = function () {
  if (_instance) {
    return _instance.warning.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.error = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.error(item);
  return {
    uuid: uuid
  };
};
Rollbar.error = function () {
  if (_instance) {
    return _instance.error.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.critical = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.critical(item);
  return {
    uuid: uuid
  };
};
Rollbar.critical = function () {
  if (_instance) {
    return _instance.critical.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.buildJsonPayload = function (item) {
  return this.client.buildJsonPayload(item);
};
Rollbar.buildJsonPayload = function () {
  if (_instance) {
    return _instance.buildJsonPayload.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.sendJsonPayload = function (jsonPayload) {
  return this.client.sendJsonPayload(jsonPayload);
};
Rollbar.sendJsonPayload = function () {
  if (_instance) {
    return _instance.sendJsonPayload.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.setupUnhandledCapture = function () {
  var gWindow = _gWindow();
  if (!this.unhandledExceptionsInitialized) {
    if (this.options.captureUncaught || this.options.handleUncaughtExceptions) {
      globals.captureUncaughtExceptions(gWindow, this);
      if (this.wrapGlobals && this.options.wrapGlobalEventHandlers) {
        this.wrapGlobals(gWindow, this);
      }
      this.unhandledExceptionsInitialized = true;
    }
  }
  if (!this.unhandledRejectionsInitialized) {
    if (this.options.captureUnhandledRejections || this.options.handleUnhandledRejections) {
      globals.captureUnhandledRejections(gWindow, this);
      this.unhandledRejectionsInitialized = true;
    }
  }
};
Rollbar.prototype.handleUncaughtException = function (message, url, lineno, colno, error, context) {
  if (!this.options.captureUncaught && !this.options.handleUncaughtExceptions) {
    return;
  }

  // Chrome will always send 5+ arguments and error will be valid or null, not undefined.
  // If error is undefined, we have a different caller.
  // Chrome also sends errors from web workers with null error, but does not invoke
  // prepareStackTrace() for these. Test for empty url to skip them.
  if (this.options.inspectAnonymousErrors && this.isChrome && error === null && url === '') {
    return 'anonymous';
  }
  var item;
  var stackInfo = _.makeUnhandledStackInfo(message, url, lineno, colno, error, 'onerror', 'uncaught exception', errorParser);
  if (_.isError(error)) {
    item = this._createItem([message, error, context]);
    item._unhandledStackInfo = stackInfo;
  } else if (_.isError(url)) {
    item = this._createItem([message, url, context]);
    item._unhandledStackInfo = stackInfo;
  } else {
    item = this._createItem([message, context]);
    item.stackInfo = stackInfo;
  }
  item.level = this.options.uncaughtErrorLevel;
  item._isUncaught = true;
  this.client.log(item);
};

/**
 * Chrome only. Other browsers will ignore.
 *
 * Use Error.prepareStackTrace to extract information about errors that
 * do not have a valid error object in onerror().
 *
 * In tested version of Chrome, onerror is called first but has no way
 * to communicate with prepareStackTrace. Use a counter to let this
 * handler know which errors to send to Rollbar.
 *
 * In config options, set inspectAnonymousErrors to enable.
 */
Rollbar.prototype.handleAnonymousErrors = function () {
  if (!this.options.inspectAnonymousErrors || !this.isChrome) {
    return;
  }
  var r = this;
  function prepareStackTrace(error, _stack) {
    if (r.options.inspectAnonymousErrors) {
      if (r.anonymousErrorsPending) {
        // This is the only known way to detect that onerror saw an anonymous error.
        // It depends on onerror reliably being called before Error.prepareStackTrace,
        // which so far holds true on tested versions of Chrome. If versions of Chrome
        // are tested that behave differently, this logic will need to be updated
        // accordingly.
        r.anonymousErrorsPending -= 1;
        if (!error) {
          // Not likely to get here, but calling handleUncaughtException from here
          // without an error object would throw off the anonymousErrorsPending counter,
          // so return now.
          return;
        }

        // Allow this to be tracked later.
        error._isAnonymous = true;

        // url, lineno, colno shouldn't be needed for these errors.
        // If that changes, update this accordingly, using the unused
        // _stack param as needed (rather than parse error.toString()).
        r.handleUncaughtException(error.message, null, null, null, error);
      }
    }

    // Workaround to ensure stack is preserved for normal errors.
    return error.stack;
  }

  // https://v8.dev/docs/stack-trace-api
  try {
    Error.prepareStackTrace = prepareStackTrace;
  } catch (e) {
    this.options.inspectAnonymousErrors = false;
    this.error('anonymous error handler failed', e);
  }
};
Rollbar.prototype.handleUnhandledRejection = function (reason, promise) {
  if (!this.options.captureUnhandledRejections && !this.options.handleUnhandledRejections) {
    return;
  }
  var message = 'unhandled rejection was null or undefined!';
  if (reason) {
    if (reason.message) {
      message = reason.message;
    } else {
      var reasonResult = _.stringify(reason);
      if (reasonResult.value) {
        message = reasonResult.value;
      }
    }
  }
  var context = reason && reason._rollbarContext || promise && promise._rollbarContext;
  var item;
  if (_.isError(reason)) {
    item = this._createItem([message, reason, context]);
  } else {
    item = this._createItem([message, reason, context]);
    item.stackInfo = _.makeUnhandledStackInfo(message, '', 0, 0, null, 'unhandledrejection', '', errorParser);
  }
  item.level = this.options.uncaughtErrorLevel;
  item._isUncaught = true;
  item._originalArgs = item._originalArgs || [];
  item._originalArgs.push(promise);
  this.client.log(item);
};
Rollbar.prototype.wrap = function (f, context, _before) {
  try {
    var ctxFn;
    if (_.isFunction(context)) {
      ctxFn = context;
    } else {
      ctxFn = function ctxFn() {
        return context || {};
      };
    }
    if (!_.isFunction(f)) {
      return f;
    }
    if (f._isWrap) {
      return f;
    }
    if (!f._rollbar_wrapped) {
      f._rollbar_wrapped = function () {
        if (_before && _.isFunction(_before)) {
          _before.apply(this, arguments);
        }
        try {
          return f.apply(this, arguments);
        } catch (exc) {
          var e = exc;
          if (e && window._rollbarWrappedError !== e) {
            if (_.isType(e, 'string')) {
              e = new String(e);
            }
            e._rollbarContext = ctxFn() || {};
            e._rollbarContext._wrappedSource = f.toString();
            window._rollbarWrappedError = e;
          }
          throw e;
        }
      };
      f._rollbar_wrapped._isWrap = true;
      if (f.hasOwnProperty) {
        for (var prop in f) {
          if (f.hasOwnProperty(prop) && prop !== '_rollbar_wrapped') {
            f._rollbar_wrapped[prop] = f[prop];
          }
        }
      }
    }
    return f._rollbar_wrapped;
  } catch (e) {
    // Return the original function if the wrap fails.
    return f;
  }
};
Rollbar.wrap = function (f, context) {
  if (_instance) {
    return _instance.wrap(f, context);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.captureEvent = function () {
  var event = _.createTelemetryEvent(arguments);
  return this.client.captureEvent(event.type, event.metadata, event.level);
};
Rollbar.captureEvent = function () {
  if (_instance) {
    return _instance.captureEvent.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};

// The following two methods are used internally and are not meant for public use
Rollbar.prototype.captureDomContentLoaded = function (e, ts) {
  if (!ts) {
    ts = new Date();
  }
  return this.client.captureDomContentLoaded(ts);
};
Rollbar.prototype.captureLoad = function (e, ts) {
  if (!ts) {
    ts = new Date();
  }
  return this.client.captureLoad(ts);
};

/* Internal */

function addTransformsToNotifier(notifier, rollbar, gWindow) {
  notifier.addTransform(transforms.handleDomException).addTransform(transforms.handleItemWithError).addTransform(transforms.ensureItemHasSomethingToSay).addTransform(transforms.addBaseInfo).addTransform(transforms.addRequestInfo(gWindow)).addTransform(transforms.addClientInfo(gWindow)).addTransform(transforms.addPluginInfo(gWindow)).addTransform(transforms.addBody).addTransform(sharedTransforms.addMessageWithError).addTransform(sharedTransforms.addTelemetryData).addTransform(sharedTransforms.addConfigToPayload).addTransform(transforms.addScrubber(rollbar.scrub)).addTransform(sharedTransforms.addPayloadOptions).addTransform(sharedTransforms.userTransform(logger)).addTransform(sharedTransforms.addConfiguredOptions).addTransform(sharedTransforms.addDiagnosticKeys).addTransform(sharedTransforms.itemToPayload);
}
function addPredicatesToQueue(queue) {
  queue.addPredicate(sharedPredicates.checkLevel).addPredicate(predicates.checkIgnore).addPredicate(sharedPredicates.userCheckIgnore(logger)).addPredicate(sharedPredicates.urlIsNotBlockListed(logger)).addPredicate(sharedPredicates.urlIsSafeListed(logger)).addPredicate(sharedPredicates.messageIsIgnored(logger));
}
Rollbar.prototype.loadFull = function () {
  logger.info('Unexpected Rollbar.loadFull() called on a Notifier instance. This can happen when Rollbar is loaded multiple times.');
};
Rollbar.prototype._createItem = function (args) {
  return _.createItem(args, logger, this);
};
function _getFirstFunction(args) {
  for (var i = 0, len = args.length; i < len; ++i) {
    if (_.isFunction(args[i])) {
      return args[i];
    }
  }
  return undefined;
}
function _gWindow() {
  return typeof window != 'undefined' && window || typeof self != 'undefined' && self;
}
var defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");
var scrubFields = __webpack_require__(/*! ./defaults/scrubFields */ "./src/browser/defaults/scrubFields.js");
var defaultOptions = {
  version: defaults.version,
  scrubFields: scrubFields.scrubFields,
  logLevel: defaults.logLevel,
  reportLevel: defaults.reportLevel,
  uncaughtErrorLevel: defaults.uncaughtErrorLevel,
  endpoint: defaults.endpoint,
  verbose: false,
  enabled: true,
  transmit: true,
  sendConfig: false,
  includeItemsInTelemetry: true,
  captureIp: true,
  inspectAnonymousErrors: true,
  ignoreDuplicateErrors: true,
  wrapGlobalEventHandlers: false,
  recorder: recorderDefaults,
  tracing: tracingDefaults
};
module.exports = Rollbar;

/***/ }),

/***/ "./src/browser/defaults/scrubFields.js":
/*!*********************************************!*\
  !*** ./src/browser/defaults/scrubFields.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = {
  scrubFields: ['pw', 'pass', 'passwd', 'password', 'secret', 'confirm_password', 'confirmPassword', 'password_confirmation', 'passwordConfirmation', 'access_token', 'accessToken', 'X-Rollbar-Access-Token', 'secret_key', 'secretKey', 'secretToken', 'cc-number', 'card number', 'cardnumber', 'cardnum', 'ccnum', 'ccnumber', 'cc num', 'creditcardnumber', 'credit card number', 'newcreditcardnumber', 'new credit card', 'creditcardno', 'credit card no', 'card#', 'card #', 'cc-csc', 'cvc', 'cvc2', 'cvv2', 'ccv2', 'security code', 'card verification', 'name on credit card', 'name on card', 'nameoncard', 'cardholder', 'card holder', 'name des karteninhabers', 'ccname', 'card type', 'cardtype', 'cc type', 'cctype', 'payment type', 'expiration date', 'expirationdate', 'expdate', 'cc-exp', 'ccmonth', 'ccyear']
};

/***/ }),

/***/ "./src/browser/detection.js":
/*!**********************************!*\
  !*** ./src/browser/detection.js ***!
  \**********************************/
/***/ ((module) => {

// This detection.js module is used to encapsulate any ugly browser/feature
// detection we may need to do.

// Figure out which version of IE we're using, if any.
// This is gleaned from http://stackoverflow.com/questions/5574842/best-way-to-check-for-ie-less-than-9-in-javascript-without-library
// Will return an integer on IE (i.e. 8)
// Will return undefined otherwise
function getIEVersion() {
  var undef;
  if (typeof document === 'undefined') {
    return undef;
  }
  var v = 3,
    div = document.createElement('div'),
    all = div.getElementsByTagName('i');
  while (div.innerHTML = '<!--[if gt IE ' + ++v + ']><i></i><![endif]-->', all[0]);
  return v > 4 ? v : undef;
}
var Detection = {
  ieVersion: getIEVersion
};
module.exports = Detection;

/***/ }),

/***/ "./src/browser/domUtility.js":
/*!***********************************!*\
  !*** ./src/browser/domUtility.js ***!
  \***********************************/
/***/ ((module) => {

function getElementType(e) {
  return (e.getAttribute('type') || '').toLowerCase();
}
function isDescribedElement(element, type, subtypes) {
  if (element.tagName.toLowerCase() !== type.toLowerCase()) {
    return false;
  }
  if (!subtypes) {
    return true;
  }
  element = getElementType(element);
  for (var i = 0; i < subtypes.length; i++) {
    if (subtypes[i] === element) {
      return true;
    }
  }
  return false;
}
function getElementFromEvent(evt, doc) {
  if (evt.target) {
    return evt.target;
  }
  if (doc && doc.elementFromPoint) {
    return doc.elementFromPoint(evt.clientX, evt.clientY);
  }
  return undefined;
}
function treeToArray(elem) {
  var MAX_HEIGHT = 5;
  var out = [];
  var nextDescription;
  for (var height = 0; elem && height < MAX_HEIGHT; height++) {
    nextDescription = describeElement(elem);
    if (nextDescription.tagName === 'html') {
      break;
    }
    out.unshift(nextDescription);
    elem = elem.parentNode;
  }
  return out;
}
function elementArrayToString(a) {
  var MAX_LENGTH = 80;
  var separator = ' > ',
    separatorLength = separator.length;
  var out = [],
    len = 0,
    nextStr,
    totalLength;
  for (var i = a.length - 1; i >= 0; i--) {
    nextStr = descriptionToString(a[i]);
    totalLength = len + out.length * separatorLength + nextStr.length;
    if (i < a.length - 1 && totalLength >= MAX_LENGTH + 3) {
      out.unshift('...');
      break;
    }
    out.unshift(nextStr);
    len += nextStr.length;
  }
  return out.join(separator);
}
function descriptionToString(desc) {
  if (!desc || !desc.tagName) {
    return '';
  }
  var out = [desc.tagName];
  if (desc.id) {
    out.push('#' + desc.id);
  }
  if (desc.classes) {
    out.push('.' + desc.classes.join('.'));
  }
  for (var i = 0; i < desc.attributes.length; i++) {
    out.push('[' + desc.attributes[i].key + '="' + desc.attributes[i].value + '"]');
  }
  return out.join('');
}

/**
 * Input: a dom element
 * Output: null if tagName is falsey or input is falsey, else
 *  {
 *    tagName: String,
 *    id: String | undefined,
 *    classes: [String] | undefined,
 *    attributes: [
 *      {
 *        key: OneOf(type, name, title, alt),
 *        value: String
 *      }
 *    ]
 *  }
 */
function describeElement(elem) {
  if (!elem || !elem.tagName) {
    return null;
  }
  var out = {},
    className,
    key,
    attr,
    i;
  out.tagName = elem.tagName.toLowerCase();
  if (elem.id) {
    out.id = elem.id;
  }
  className = elem.className;
  if (className && typeof className === 'string') {
    out.classes = className.split(/\s+/);
  }
  var attributes = ['type', 'name', 'title', 'alt'];
  out.attributes = [];
  for (i = 0; i < attributes.length; i++) {
    key = attributes[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.attributes.push({
        key: key,
        value: attr
      });
    }
  }
  return out;
}
module.exports = {
  describeElement: describeElement,
  descriptionToString: descriptionToString,
  elementArrayToString: elementArrayToString,
  treeToArray: treeToArray,
  getElementFromEvent: getElementFromEvent,
  isDescribedElement: isDescribedElement,
  getElementType: getElementType
};

/***/ }),

/***/ "./src/browser/globalSetup.js":
/*!************************************!*\
  !*** ./src/browser/globalSetup.js ***!
  \************************************/
/***/ ((module) => {

function captureUncaughtExceptions(window, handler, shim) {
  if (!window) {
    return;
  }
  var oldOnError;
  if (typeof handler._rollbarOldOnError === 'function') {
    oldOnError = handler._rollbarOldOnError;
  } else if (window.onerror) {
    oldOnError = window.onerror;
    while (oldOnError._rollbarOldOnError) {
      oldOnError = oldOnError._rollbarOldOnError;
    }
    handler._rollbarOldOnError = oldOnError;
  }
  handler.handleAnonymousErrors();
  var fn = function fn() {
    var args = Array.prototype.slice.call(arguments, 0);
    _rollbarWindowOnError(window, handler, oldOnError, args);
  };
  if (shim) {
    fn._rollbarOldOnError = oldOnError;
  }
  window.onerror = fn;
}
function _rollbarWindowOnError(window, r, old, args) {
  if (window._rollbarWrappedError) {
    if (!args[4]) {
      args[4] = window._rollbarWrappedError;
    }
    if (!args[5]) {
      args[5] = window._rollbarWrappedError._rollbarContext;
    }
    window._rollbarWrappedError = null;
  }
  var ret = r.handleUncaughtException.apply(r, args);
  if (old) {
    old.apply(window, args);
  }

  // Let other chained onerror handlers above run before setting this.
  // If an error is thrown and caught within a chained onerror handler,
  // Error.prepareStackTrace() will see that one before the one we want.
  if (ret === 'anonymous') {
    r.anonymousErrorsPending += 1; // See Rollbar.prototype.handleAnonymousErrors()
  }
}
function captureUnhandledRejections(window, handler, shim) {
  if (!window) {
    return;
  }
  if (typeof window._rollbarURH === 'function' && window._rollbarURH.belongsToShim) {
    window.removeEventListener('unhandledrejection', window._rollbarURH);
  }
  var rejectionHandler = function rejectionHandler(evt) {
    var reason, promise, detail;
    try {
      reason = evt.reason;
    } catch (e) {
      reason = undefined;
    }
    try {
      promise = evt.promise;
    } catch (e) {
      promise = '[unhandledrejection] error getting `promise` from event';
    }
    try {
      detail = evt.detail;
      if (!reason && detail) {
        reason = detail.reason;
        promise = detail.promise;
      }
    } catch (e) {
      // Ignore
    }
    if (!reason) {
      reason = '[unhandledrejection] error getting `reason` from event';
    }
    if (handler && handler.handleUnhandledRejection) {
      handler.handleUnhandledRejection(reason, promise);
    }
  };
  rejectionHandler.belongsToShim = shim;
  window._rollbarURH = rejectionHandler;
  window.addEventListener('unhandledrejection', rejectionHandler);
}
module.exports = {
  captureUncaughtExceptions: captureUncaughtExceptions,
  captureUnhandledRejections: captureUnhandledRejections
};

/***/ }),

/***/ "./src/browser/logger.js":
/*!*******************************!*\
  !*** ./src/browser/logger.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-console */
__webpack_require__(/*! console-polyfill */ "./node_modules/console-polyfill/index.js");
var detection = __webpack_require__(/*! ./detection */ "./src/browser/detection.js");
var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
function error() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.error(_.formatArgsAsString(args));
  } else {
    console.error.apply(console, args);
  }
}
function info() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.info(_.formatArgsAsString(args));
  } else {
    console.info.apply(console, args);
  }
}
function log() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.log(_.formatArgsAsString(args));
  } else {
    console.log.apply(console, args);
  }
}

/* eslint-enable no-console */

module.exports = {
  error: error,
  info: info,
  log: log
};

/***/ }),

/***/ "./src/browser/predicates.js":
/*!***********************************!*\
  !*** ./src/browser/predicates.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
function checkIgnore(item, settings) {
  if (_.get(settings, 'plugins.jquery.ignoreAjaxErrors')) {
    return !_.get(item, 'body.message.extra.isAjax');
  }
  return true;
}
module.exports = {
  checkIgnore: checkIgnore
};

/***/ }),

/***/ "./src/browser/replay/defaults.js":
/*!****************************************!*\
  !*** ./src/browser/replay/defaults.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Default options for the rrweb recorder
 * See https://github.com/rrweb-io/rrweb/blob/master/guide.md#options for details
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  enabled: false,
  // Whether recording is enabled
  autoStart: true,
  // Start recording automatically when Rollbar initializes
  debug: {
    logEmits: false // Whether to log emitted events
  },
  // Recording options
  inlineStylesheet: true,
  // Whether to inline stylesheets to improve replay accuracy
  inlineImages: false,
  // Whether to record the image content
  collectFonts: true,
  // Whether to collect fonts in the website

  // Privacy options
  // Fine-grained control over which input types to mask
  // By default only password inputs are masked if maskInputs is true
  maskInputOptions: {
    password: true,
    email: false,
    tel: false,
    text: false,
    color: false,
    date: false,
    'datetime-local': false,
    month: false,
    number: false,
    range: false,
    search: false,
    time: false,
    url: false,
    week: false
  },
  // Remove unnecessary parts of the DOM
  // By default all removable elements are removed
  slimDOMOptions: {
    script: true,
    // Remove script elements
    comment: true,
    // Remove comments
    headFavicon: true,
    // Remove favicons in the head
    headWhitespace: true,
    // Remove whitespace in head
    headMetaDescKeywords: true,
    // Remove meta description and keywords
    headMetaSocial: true,
    // Remove social media meta tags
    headMetaRobots: true,
    // Remove robots meta directives
    headMetaHttpEquiv: true,
    // Remove http-equiv meta directives
    headMetaAuthorship: true,
    // Remove authorship meta directives
    headMetaVerification: true // Remove verification meta directives
  }

  // Custom callbacks for advanced use cases
  // These are undefined by default and can be set programmatically
  // maskInputFn: undefined,      // Custom function to mask input values
  // maskTextFn: undefined,       // Custom function to mask text content
  // errorHandler: undefined,     // Custom error handler for recording errors

  // Plugin system
  // plugins: []                  // List of plugins to use (must be set programmatically)
});

/***/ }),

/***/ "./src/browser/replay/recorder.js":
/*!****************************************!*\
  !*** ./src/browser/replay/recorder.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Recorder)
/* harmony export */ });
/* harmony import */ var _rrweb_record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rrweb/record */ "./node_modules/@rrweb/record/dist/record.js");
/* harmony import */ var _rrweb_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rrweb/types */ "./node_modules/@rrweb/types/dist/types.js");
/* harmony import */ var _tracing_hrtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tracing/hrtime.js */ "./src/tracing/hrtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _options = /*#__PURE__*/new WeakMap();
var _stopFn = /*#__PURE__*/new WeakMap();
var _recordFn = /*#__PURE__*/new WeakMap();
var _events = /*#__PURE__*/new WeakMap();
var Recorder = /*#__PURE__*/function () {
  /**
   * Creates a new Recorder instance for capturing DOM events
   *
   * @param {Object} options - Configuration options for the recorder
   * @param {Function} [recordFn=rrwebRecordFn] - The recording function to use
   */
  function Recorder(options) {
    var recordFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _rrweb_record__WEBPACK_IMPORTED_MODULE_0__.record;
    _classCallCheck(this, Recorder);
    _classPrivateFieldInitSpec(this, _options, void 0);
    _classPrivateFieldInitSpec(this, _stopFn, null);
    _classPrivateFieldInitSpec(this, _recordFn, void 0);
    _classPrivateFieldInitSpec(this, _events, {
      previous: [],
      current: []
    });
    if (!recordFn) {
      throw new TypeError("Expected 'recordFn' to be provided");
    }
    console.log('Recorder: Initializing...');
    console.log('options', options);
    _classPrivateFieldSet(_options, this, options !== null && options !== void 0 ? options : {});
    _classPrivateFieldSet(_recordFn, this, recordFn);
  }
  return _createClass(Recorder, [{
    key: "isRecording",
    get: function get() {
      return _classPrivateFieldGet(_stopFn, this) !== null;
    }
  }, {
    key: "options",
    get: function get() {
      return _classPrivateFieldGet(_options, this);
    },
    set: function set(newOptions) {
      this.configure(newOptions);
    }
  }, {
    key: "configure",
    value: function configure(newOptions) {
      if (this.isRecording && newOptions.enabled === false) {
        this.stop();
      }
      _classPrivateFieldSet(_options, this, newOptions);
    }

    /**
     * Converts recorded events into a formatted payload ready for transport.
     *
     * This method takes the recorder's stored events, creates a new span with the
     * provided tracing context, attaches all events with their timestamps as span
     * events, and then returns a payload ready for transport to the server.
     *
     * @param {Object} tracing - The tracing system instance to create spans
     * @param {string} replayId - Unique identifier to associate with this replay recording
     * @returns {Object|null} A formatted payload containing spans data in OTLP format, or null if no events exist
     */
  }, {
    key: "dump",
    value: function dump(tracing, replayId, occurrenceUuid) {
      var events = _classPrivateFieldGet(_events, this).previous.concat(_classPrivateFieldGet(_events, this).current);
      if (events.length < 2) {
        console.warn("Recorder.dump: Min 2 events req. Found ".concat(events.length));
        return null;
      }
      console.log("Recorder.dump: Dumping ".concat(events.length, " events"));
      var recordingSpan = tracing.startSpan('rrweb-replay-recording', {});
      recordingSpan.setAttribute('rollbar.replay.id', replayId);
      if (occurrenceUuid) {
        recordingSpan.setAttribute('rollbar.occurrence.uuid', occurrenceUuid);
      }
      var earliestEvent = events.reduce(function (earliestEvent, event) {
        return event.timestamp < earliestEvent.timestamp ? event : earliestEvent;
      });
      recordingSpan.span.startTime = _tracing_hrtime_js__WEBPACK_IMPORTED_MODULE_2__["default"].fromMillis(earliestEvent.timestamp);
      var _iterator = _createForOfIteratorHelper(events),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var event = _step.value;
          recordingSpan.addEvent('rrweb-replay-events', {
            eventType: event.type,
            json: JSON.stringify(event.data),
            'rollbar.replay.id': replayId
          }, _tracing_hrtime_js__WEBPACK_IMPORTED_MODULE_2__["default"].fromMillis(event.timestamp));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      recordingSpan.end();
      return tracing.exporter.toPayload();
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;
      if (this.isRecording || this.options.enabled === false) {
        if (this.isRecording) {
          console.log('Recorder: Already started');
        } else {
          console.log('Recorder: Disabled');
        }
        return;
      }
      console.log('Recorder: Starting...');
      this.clear();
      _classPrivateFieldSet(_stopFn, this, _classPrivateFieldGet(_recordFn, this).call(this, _objectSpread({
        emit: function emit(event, isCheckout) {
          var _this$options$debug;
          if ((_this$options$debug = _this.options.debug) !== null && _this$options$debug !== void 0 && _this$options$debug.logEmits) {
            _this._logEvent(event, isCheckout);
          }
          if (isCheckout && event.type === _rrweb_types__WEBPACK_IMPORTED_MODULE_1__.EventType.Meta) {
            _classPrivateFieldGet(_events, _this).previous = _classPrivateFieldGet(_events, _this).current;
            _classPrivateFieldGet(_events, _this).current = [];
          }
          _classPrivateFieldGet(_events, _this).current.push(event);
        },
        checkoutEveryNms: 5 * 60 * 1000
      }, this.options)));
      console.log('Recorder: Started');
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.isRecording) {
        console.log('Recorder: Already stopped');
        return;
      }
      console.log('Recorder: Stopping...');
      _classPrivateFieldGet(_stopFn, this).call(this);
      _classPrivateFieldSet(_stopFn, this, null);
      console.log('Recorder: Stopped');
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldSet(_events, this, {
        previous: [],
        current: []
      });
    }
  }, {
    key: "_logEvent",
    value: function _logEvent(event, isCheckout) {
      console.log("Recorder: ".concat(isCheckout ? 'checkout' : '', " event\n"), function (e) {
        var seen = new WeakSet();
        return JSON.stringify(e, function (_, v) {
          if (_typeof(v) === 'object' && v !== null) {
            if (seen.has(v)) return '[Circular]';
            seen.add(v);
          }
          return v;
        }, 2);
      }(event));
    }
  }]);
}();


/***/ }),

/***/ "./src/browser/replay/replayMap.js":
/*!*****************************************!*\
  !*** ./src/browser/replay/replayMap.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplayMap)
/* harmony export */ });
/* harmony import */ var _tracing_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tracing/id.js */ "./src/tracing/id.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }


/**
 * ReplayMap - Manages the mapping between error occurrences and their associated
 * session recordings. This class handles the coordination between when recordings
 * are dumped and when they are eventually sent to the backend.
 */
var _map = /*#__PURE__*/new WeakMap();
var _recorder = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _tracing = /*#__PURE__*/new WeakMap();
var ReplayMap = /*#__PURE__*/function () {
  /**
   * Creates a new ReplayMap instance
   *
   * @param {Object} props - Configuration props
   * @param {Object} props.recorder - The recorder instance that dumps replay data into spans
   * @param {Object} props.api - The API instance used to send replay payloads to the backend
   * @param {Object} props.tracing - The tracing instance used to create spans and manage context
   */
  function ReplayMap(_ref) {
    var recorder = _ref.recorder,
      api = _ref.api,
      tracing = _ref.tracing;
    _classCallCheck(this, ReplayMap);
    _classPrivateFieldInitSpec(this, _map, void 0);
    _classPrivateFieldInitSpec(this, _recorder, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _tracing, void 0);
    if (!recorder) {
      throw new TypeError("Expected 'recorder' to be provided");
    }
    if (!api) {
      throw new TypeError("Expected 'api' to be provided");
    }
    if (!tracing) {
      throw new TypeError("Expected 'tracing' to be provided");
    }
    _classPrivateFieldSet(_map, this, new Map());
    _classPrivateFieldSet(_recorder, this, recorder);
    _classPrivateFieldSet(_api, this, api);
    _classPrivateFieldSet(_tracing, this, tracing);
  }

  /**
   * Processes a replay by converting recorder events into a transport-ready payload.
   *
   * Calls recorder.dump() to capture events as spans, formats them into a proper payload,
   * and stores the result in the map using replayId as the key.
   *
   * @param {string} replayId - The unique ID for this replay
   * @returns {Promise<string>} A promise resolving to the processed replayId
   * @private
   */
  return _createClass(ReplayMap, [{
    key: "_processReplay",
    value: (function () {
      var _processReplay2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(replayId, occurrenceUuid) {
        var payload;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              try {
                payload = _classPrivateFieldGet(_recorder, this).dump(_classPrivateFieldGet(_tracing, this), replayId, occurrenceUuid);
                _classPrivateFieldGet(_map, this).set(replayId, payload);
              } catch (transformError) {
                console.error('Error transforming spans:', transformError);
                _classPrivateFieldGet(_map, this).set(replayId, null); // TODO(matux): Error span?
              }
              return _context.abrupt("return", replayId);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _processReplay(_x, _x2) {
        return _processReplay2.apply(this, arguments);
      }
      return _processReplay;
    }()
    /**
     * Adds a replay to the map and returns a uniquely generated replay ID.
     *
     * This method immediately returns the replayId and asynchronously processes
     * the replay data in the background. The processing involves converting
     * recorder events into a payload format and storing it in the map.
     *
     * @returns {string} A unique identifier for this replay
     */
    )
  }, {
    key: "add",
    value: function add(occurrenceUuid) {
      var replayId = _tracing_id_js__WEBPACK_IMPORTED_MODULE_0__["default"].gen(8);
      this._processReplay(replayId, occurrenceUuid)["catch"](function (error) {
        console.error('Failed to process replay:', error);
      });
      return replayId;
    }

    /**
     * Sends the replay payload associated with the given replayId to the backend
     * and removes it from the map.
     *
     * Retrieves the payload from the map, checks if it's valid, then sends it
     * to the API endpoint for processing. The payload can be either a spans array
     * or a formatted OTLP payload object.
     *
     * @param {string} replayId - The ID of the replay to send
     * @returns {Promise<boolean>} A promise that resolves to true if the payload was found and sent, false otherwise
     */
  }, {
    key: "send",
    value: (function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(replayId) {
        var payload, isEmpty;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (replayId) {
                _context2.next = 3;
                break;
              }
              console.warn('ReplayMap.send: No replayId provided');
              return _context2.abrupt("return", false);
            case 3:
              if (_classPrivateFieldGet(_map, this).has(replayId)) {
                _context2.next = 6;
                break;
              }
              console.warn("ReplayMap.send: No replay found for replayId: ".concat(replayId));
              return _context2.abrupt("return", false);
            case 6:
              payload = _classPrivateFieldGet(_map, this).get(replayId);
              _classPrivateFieldGet(_map, this)["delete"](replayId);

              // Check if payload is empty (could be raw spans array or OTLP payload)
              isEmpty = !payload || Array.isArray(payload) && payload.length === 0 || payload.resourceSpans && payload.resourceSpans.length === 0;
              if (!isEmpty) {
                _context2.next = 12;
                break;
              }
              console.warn("ReplayMap.send: No payload found for replayId: ".concat(replayId));
              return _context2.abrupt("return", false);
            case 12:
              _context2.prev = 12;
              _context2.next = 15;
              return _classPrivateFieldGet(_api, this).postSpans(payload);
            case 15:
              return _context2.abrupt("return", true);
            case 18:
              _context2.prev = 18;
              _context2.t0 = _context2["catch"](12);
              console.error('Error sending replay:', _context2.t0);
              return _context2.abrupt("return", false);
            case 22:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[12, 18]]);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
    /**
     * Discards the replay associated with the given replay ID by removing
     * it from the map without sending it.
     *
     * @param {string} replayId - The ID of the replay to discard
     * @returns {boolean} True if a replay was found and discarded, false otherwise
     */
    )
  }, {
    key: "discard",
    value: function discard(replayId) {
      if (!replayId) {
        console.warn('ReplayMap.discard: No replayId provided');
        return false;
      }
      if (!_classPrivateFieldGet(_map, this).has(replayId)) {
        console.warn("ReplayMap.discard: No replay found for replayId: ".concat(replayId));
        return false;
      }
      _classPrivateFieldGet(_map, this)["delete"](replayId);
      return true;
    }

    /**
     * Gets spans for the given replay ID
     *
     * @param {string} replayId - The ID to retrieve spans for
     * @returns {Array|null} The spans array or null if not found
     */
  }, {
    key: "getSpans",
    value: function getSpans(replayId) {
      var _classPrivateFieldGet2;
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_map, this).get(replayId)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
    }

    /**
     * Sets spans for a given replay ID
     *
     * @param {string} replayId - The ID to set spans for
     * @param {Array} spans - The spans to set
     */
  }, {
    key: "setSpans",
    value: function setSpans(replayId, spans) {
      _classPrivateFieldGet(_map, this).set(replayId, spans);
    }

    /**
     * Returns the size of the map (number of stored replays)
     *
     * @returns {number} The number of replays currently stored
     */
  }, {
    key: "size",
    get: function get() {
      return _classPrivateFieldGet(_map, this).size;
    }

    /**
     * Clears all stored replays without sending them
     */
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldGet(_map, this).clear();
    }
  }]);
}();


/***/ }),

/***/ "./src/browser/rollbar.js":
/*!********************************!*\
  !*** ./src/browser/rollbar.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Rollbar = __webpack_require__(/*! ./core */ "./src/browser/core.js");
var telemeter = __webpack_require__(/*! ../telemetry */ "./src/telemetry.js");
var instrumenter = __webpack_require__(/*! ./telemetry */ "./src/browser/telemetry.js");
var polyfillJSON = __webpack_require__(/*! ../utility/polyfillJSON */ "./src/utility/polyfillJSON.js");
var wrapGlobals = __webpack_require__(/*! ./wrapGlobals */ "./src/browser/wrapGlobals.js");
var scrub = __webpack_require__(/*! ../scrub */ "./src/scrub.js");
var truncation = __webpack_require__(/*! ../truncation */ "./src/truncation.js");
var Tracing = __webpack_require__(/*! ../tracing/tracing */ "./src/tracing/tracing.js");
var Recorder = __webpack_require__(/*! ./replay/recorder */ "./src/browser/replay/recorder.js");
Rollbar.setComponents({
  telemeter: telemeter,
  instrumenter: instrumenter,
  polyfillJSON: polyfillJSON,
  wrapGlobals: wrapGlobals,
  scrub: scrub,
  truncation: truncation,
  tracing: Tracing["default"],
  recorder: Recorder["default"]
});
module.exports = Rollbar;

/***/ }),

/***/ "./src/browser/telemetry.js":
/*!**********************************!*\
  !*** ./src/browser/telemetry.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var headers = __webpack_require__(/*! ../utility/headers */ "./src/utility/headers.js");
var replace = __webpack_require__(/*! ../utility/replace */ "./src/utility/replace.js");
var scrub = __webpack_require__(/*! ../scrub */ "./src/scrub.js");
var urlparser = __webpack_require__(/*! ./url */ "./src/browser/url.js");
var domUtil = __webpack_require__(/*! ./domUtility */ "./src/browser/domUtility.js");
var defaults = {
  network: true,
  networkResponseHeaders: false,
  networkResponseBody: false,
  networkRequestHeaders: false,
  networkRequestBody: false,
  networkErrorOnHttp5xx: false,
  networkErrorOnHttp4xx: false,
  networkErrorOnHttp0: false,
  log: true,
  dom: true,
  navigation: true,
  connectivity: true,
  contentSecurityPolicy: true,
  errorOnContentSecurityPolicy: false
};
function restore(replacements, type) {
  var b;
  while (replacements[type].length) {
    b = replacements[type].shift();
    b[0][b[1]] = b[2];
  }
}
function nameFromDescription(description) {
  if (!description || !description.attributes) {
    return null;
  }
  var attrs = description.attributes;
  for (var a = 0; a < attrs.length; ++a) {
    if (attrs[a].key === 'name') {
      return attrs[a].value;
    }
  }
  return null;
}
function defaultValueScrubber(scrubFields) {
  var patterns = [];
  for (var i = 0; i < scrubFields.length; ++i) {
    patterns.push(new RegExp(scrubFields[i], 'i'));
  }
  return function (description) {
    var name = nameFromDescription(description);
    if (!name) {
      return false;
    }
    for (var i = 0; i < patterns.length; ++i) {
      if (patterns[i].test(name)) {
        return true;
      }
    }
    return false;
  };
}
function Instrumenter(options, telemeter, rollbar, _window, _document) {
  this.options = options;
  var autoInstrument = options.autoInstrument;
  if (options.enabled === false || autoInstrument === false) {
    this.autoInstrument = {};
  } else {
    if (!_.isType(autoInstrument, 'object')) {
      autoInstrument = defaults;
    }
    this.autoInstrument = _.merge(defaults, autoInstrument);
  }
  this.scrubTelemetryInputs = !!options.scrubTelemetryInputs;
  this.telemetryScrubber = options.telemetryScrubber;
  this.defaultValueScrubber = defaultValueScrubber(options.scrubFields);
  this.telemeter = telemeter;
  this.rollbar = rollbar;
  this.diagnostic = rollbar.client.notifier.diagnostic;
  this._window = _window || {};
  this._document = _document || {};
  this.replacements = {
    network: [],
    log: [],
    navigation: [],
    connectivity: []
  };
  this.eventRemovers = {
    dom: [],
    connectivity: [],
    contentsecuritypolicy: []
  };
  this._location = this._window.location;
  this._lastHref = this._location && this._location.href;
}
Instrumenter.prototype.configure = function (options) {
  this.options = _.merge(this.options, options);
  var autoInstrument = options.autoInstrument;
  var oldSettings = _.merge(this.autoInstrument);
  if (options.enabled === false || autoInstrument === false) {
    this.autoInstrument = {};
  } else {
    if (!_.isType(autoInstrument, 'object')) {
      autoInstrument = defaults;
    }
    this.autoInstrument = _.merge(defaults, autoInstrument);
  }
  this.instrument(oldSettings);
  if (options.scrubTelemetryInputs !== undefined) {
    this.scrubTelemetryInputs = !!options.scrubTelemetryInputs;
  }
  if (options.telemetryScrubber !== undefined) {
    this.telemetryScrubber = options.telemetryScrubber;
  }
};

// eslint-disable-next-line complexity
Instrumenter.prototype.instrument = function (oldSettings) {
  if (this.autoInstrument.network && !(oldSettings && oldSettings.network)) {
    this.instrumentNetwork();
  } else if (!this.autoInstrument.network && oldSettings && oldSettings.network) {
    this.deinstrumentNetwork();
  }
  if (this.autoInstrument.log && !(oldSettings && oldSettings.log)) {
    this.instrumentConsole();
  } else if (!this.autoInstrument.log && oldSettings && oldSettings.log) {
    this.deinstrumentConsole();
  }
  if (this.autoInstrument.dom && !(oldSettings && oldSettings.dom)) {
    this.instrumentDom();
  } else if (!this.autoInstrument.dom && oldSettings && oldSettings.dom) {
    this.deinstrumentDom();
  }
  if (this.autoInstrument.navigation && !(oldSettings && oldSettings.navigation)) {
    this.instrumentNavigation();
  } else if (!this.autoInstrument.navigation && oldSettings && oldSettings.navigation) {
    this.deinstrumentNavigation();
  }
  if (this.autoInstrument.connectivity && !(oldSettings && oldSettings.connectivity)) {
    this.instrumentConnectivity();
  } else if (!this.autoInstrument.connectivity && oldSettings && oldSettings.connectivity) {
    this.deinstrumentConnectivity();
  }
  if (this.autoInstrument.contentSecurityPolicy && !(oldSettings && oldSettings.contentSecurityPolicy)) {
    this.instrumentContentSecurityPolicy();
  } else if (!this.autoInstrument.contentSecurityPolicy && oldSettings && oldSettings.contentSecurityPolicy) {
    this.deinstrumentContentSecurityPolicy();
  }
};
Instrumenter.prototype.deinstrumentNetwork = function () {
  restore(this.replacements, 'network');
};
Instrumenter.prototype.instrumentNetwork = function () {
  var self = this;
  function wrapProp(prop, xhr) {
    if (prop in xhr && _.isFunction(xhr[prop])) {
      replace(xhr, prop, function (orig) {
        return self.rollbar.wrap(orig);
      });
    }
  }
  if ('XMLHttpRequest' in this._window) {
    var xhrp = this._window.XMLHttpRequest.prototype;
    replace(xhrp, 'open', function (orig) {
      return function (method, url) {
        var isUrlObject = _isUrlObject(url);
        if (_.isType(url, 'string') || isUrlObject) {
          url = isUrlObject ? url.toString() : url;
          if (this.__rollbar_xhr) {
            this.__rollbar_xhr.method = method;
            this.__rollbar_xhr.url = url;
            this.__rollbar_xhr.status_code = null;
            this.__rollbar_xhr.start_time_ms = _.now();
            this.__rollbar_xhr.end_time_ms = null;
          } else {
            this.__rollbar_xhr = {
              method: method,
              url: url,
              status_code: null,
              start_time_ms: _.now(),
              end_time_ms: null
            };
          }
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
    replace(xhrp, 'setRequestHeader', function (orig) {
      return function (header, value) {
        // If xhr.open is async, __rollbar_xhr may not be initialized yet.
        if (!this.__rollbar_xhr) {
          this.__rollbar_xhr = {};
        }
        if (_.isType(header, 'string') && _.isType(value, 'string')) {
          if (self.autoInstrument.networkRequestHeaders) {
            if (!this.__rollbar_xhr.request_headers) {
              this.__rollbar_xhr.request_headers = {};
            }
            this.__rollbar_xhr.request_headers[header] = value;
          }
          // We want the content type even if request header telemetry is off.
          if (header.toLowerCase() === 'content-type') {
            this.__rollbar_xhr.request_content_type = value;
          }
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
    replace(xhrp, 'send', function (orig) {
      /* eslint-disable no-unused-vars */
      return function (data) {
        /* eslint-enable no-unused-vars */
        var xhr = this;
        function onreadystatechangeHandler() {
          if (xhr.__rollbar_xhr) {
            if (xhr.__rollbar_xhr.status_code === null) {
              xhr.__rollbar_xhr.status_code = 0;
              if (self.autoInstrument.networkRequestBody) {
                xhr.__rollbar_xhr.request = data;
              }
              xhr.__rollbar_event = self.captureNetwork(xhr.__rollbar_xhr, 'xhr', undefined);
            }
            if (xhr.readyState < 2) {
              xhr.__rollbar_xhr.start_time_ms = _.now();
            }
            if (xhr.readyState > 3) {
              xhr.__rollbar_xhr.end_time_ms = _.now();
              var headers = null;
              xhr.__rollbar_xhr.response_content_type = xhr.getResponseHeader('Content-Type');
              if (self.autoInstrument.networkResponseHeaders) {
                var headersConfig = self.autoInstrument.networkResponseHeaders;
                headers = {};
                try {
                  var header, i;
                  if (headersConfig === true) {
                    var allHeaders = xhr.getAllResponseHeaders();
                    if (allHeaders) {
                      var arr = allHeaders.trim().split(/[\r\n]+/);
                      var parts, value;
                      for (i = 0; i < arr.length; i++) {
                        parts = arr[i].split(': ');
                        header = parts.shift();
                        value = parts.join(': ');
                        headers[header] = value;
                      }
                    }
                  } else {
                    for (i = 0; i < headersConfig.length; i++) {
                      header = headersConfig[i];
                      headers[header] = xhr.getResponseHeader(header);
                    }
                  }
                } catch (e) {
                  /* we ignore the errors here that could come from different
                   * browser issues with the xhr methods */
                }
              }
              var body = null;
              if (self.autoInstrument.networkResponseBody) {
                try {
                  body = xhr.responseText;
                } catch (e) {
                  /* ignore errors from reading responseText */
                }
              }
              var response = null;
              if (body || headers) {
                response = {};
                if (body) {
                  if (self.isJsonContentType(xhr.__rollbar_xhr.response_content_type)) {
                    response.body = self.scrubJson(body);
                  } else {
                    response.body = body;
                  }
                }
                if (headers) {
                  response.headers = headers;
                }
              }
              if (response) {
                xhr.__rollbar_xhr.response = response;
              }
              try {
                var code = xhr.status;
                code = code === 1223 ? 204 : code;
                xhr.__rollbar_xhr.status_code = code;
                xhr.__rollbar_event.level = self.telemeter.levelFromStatus(code);
                self.errorOnHttpStatus(xhr.__rollbar_xhr);
              } catch (e) {
                /* ignore possible exception from xhr.status */
              }
            }
          }
        }
        wrapProp('onload', xhr);
        wrapProp('onerror', xhr);
        wrapProp('onprogress', xhr);
        if ('onreadystatechange' in xhr && _.isFunction(xhr.onreadystatechange)) {
          replace(xhr, 'onreadystatechange', function (orig) {
            return self.rollbar.wrap(orig, undefined, onreadystatechangeHandler);
          });
        } else {
          xhr.onreadystatechange = onreadystatechangeHandler;
        }
        if (xhr.__rollbar_xhr && self.trackHttpErrors()) {
          xhr.__rollbar_xhr.stack = new Error().stack;
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
  }
  if ('fetch' in this._window) {
    replace(this._window, 'fetch', function (orig) {
      /* eslint-disable no-unused-vars */
      return function (fn, t) {
        /* eslint-enable no-unused-vars */
        var args = new Array(arguments.length);
        for (var i = 0, len = args.length; i < len; i++) {
          args[i] = arguments[i];
        }
        var input = args[0];
        var method = 'GET';
        var url;
        var isUrlObject = _isUrlObject(input);
        if (_.isType(input, 'string') || isUrlObject) {
          url = isUrlObject ? input.toString() : input;
        } else if (input) {
          url = input.url;
          if (input.method) {
            method = input.method;
          }
        }
        if (args[1] && args[1].method) {
          method = args[1].method;
        }
        var metadata = {
          method: method,
          url: url,
          status_code: null,
          start_time_ms: _.now(),
          end_time_ms: null
        };
        if (args[1] && args[1].headers) {
          // Argument may be a Headers object, or plain object. Ensure here that
          // we are working with a Headers object with case-insensitive keys.
          var reqHeaders = headers(args[1].headers);
          metadata.request_content_type = reqHeaders.get('Content-Type');
          if (self.autoInstrument.networkRequestHeaders) {
            metadata.request_headers = self.fetchHeaders(reqHeaders, self.autoInstrument.networkRequestHeaders);
          }
        }
        if (self.autoInstrument.networkRequestBody) {
          if (args[1] && args[1].body) {
            metadata.request = args[1].body;
          } else if (args[0] && !_.isType(args[0], 'string') && args[0].body) {
            metadata.request = args[0].body;
          }
        }
        self.captureNetwork(metadata, 'fetch', undefined);
        if (self.trackHttpErrors()) {
          metadata.stack = new Error().stack;
        }

        // Start our handler before returning the promise. This allows resp.clone()
        // to execute before other handlers touch the response.
        return orig.apply(this, args).then(function (resp) {
          metadata.end_time_ms = _.now();
          metadata.status_code = resp.status;
          metadata.response_content_type = resp.headers.get('Content-Type');
          var headers = null;
          if (self.autoInstrument.networkResponseHeaders) {
            headers = self.fetchHeaders(resp.headers, self.autoInstrument.networkResponseHeaders);
          }
          var body = null;
          if (self.autoInstrument.networkResponseBody) {
            if (typeof resp.text === 'function') {
              // Response.text() is not implemented on some platforms
              // The response must be cloned to prevent reading (and locking) the original stream.
              // This must be done before other handlers touch the response.
              body = resp.clone().text(); //returns a Promise
            }
          }
          if (headers || body) {
            metadata.response = {};
            if (body) {
              // Test to ensure body is a Promise, which it should always be.
              if (typeof body.then === 'function') {
                body.then(function (text) {
                  if (text && self.isJsonContentType(metadata.response_content_type)) {
                    metadata.response.body = self.scrubJson(text);
                  } else {
                    metadata.response.body = text;
                  }
                });
              } else {
                metadata.response.body = body;
              }
            }
            if (headers) {
              metadata.response.headers = headers;
            }
          }
          self.errorOnHttpStatus(metadata);
          return resp;
        });
      };
    }, this.replacements, 'network');
  }
};
Instrumenter.prototype.captureNetwork = function (metadata, subtype, rollbarUUID) {
  if (metadata.request && this.isJsonContentType(metadata.request_content_type)) {
    metadata.request = this.scrubJson(metadata.request);
  }
  return this.telemeter.captureNetwork(metadata, subtype, rollbarUUID);
};
Instrumenter.prototype.isJsonContentType = function (contentType) {
  return contentType && _.isType(contentType, 'string') && contentType.toLowerCase().includes('json') ? true : false;
};
Instrumenter.prototype.scrubJson = function (json) {
  return JSON.stringify(scrub(JSON.parse(json), this.options.scrubFields));
};
Instrumenter.prototype.fetchHeaders = function (inHeaders, headersConfig) {
  var outHeaders = {};
  try {
    var i;
    if (headersConfig === true) {
      if (typeof inHeaders.entries === 'function') {
        // Headers.entries() is not implemented in IE
        var allHeaders = inHeaders.entries();
        var currentHeader = allHeaders.next();
        while (!currentHeader.done) {
          outHeaders[currentHeader.value[0]] = currentHeader.value[1];
          currentHeader = allHeaders.next();
        }
      }
    } else {
      for (i = 0; i < headersConfig.length; i++) {
        var header = headersConfig[i];
        outHeaders[header] = inHeaders.get(header);
      }
    }
  } catch (e) {
    /* ignore probable IE errors */
  }
  return outHeaders;
};
Instrumenter.prototype.trackHttpErrors = function () {
  return this.autoInstrument.networkErrorOnHttp5xx || this.autoInstrument.networkErrorOnHttp4xx || this.autoInstrument.networkErrorOnHttp0;
};
Instrumenter.prototype.errorOnHttpStatus = function (metadata) {
  var status = metadata.status_code;
  if (status >= 500 && this.autoInstrument.networkErrorOnHttp5xx || status >= 400 && this.autoInstrument.networkErrorOnHttp4xx || status === 0 && this.autoInstrument.networkErrorOnHttp0) {
    var error = new Error('HTTP request failed with Status ' + status);
    error.stack = metadata.stack;
    this.rollbar.error(error, {
      skipFrames: 1
    });
  }
};
Instrumenter.prototype.deinstrumentConsole = function () {
  if (!('console' in this._window && this._window.console.log)) {
    return;
  }
  var b;
  while (this.replacements['log'].length) {
    b = this.replacements['log'].shift();
    this._window.console[b[0]] = b[1];
  }
};
Instrumenter.prototype.instrumentConsole = function () {
  if (!('console' in this._window && this._window.console.log)) {
    return;
  }
  var self = this;
  var c = this._window.console;
  function wrapConsole(method) {
    'use strict';

    // See https://github.com/rollbar/rollbar.js/pull/778
    var orig = c[method];
    var origConsole = c;
    var level = method === 'warn' ? 'warning' : method;
    c[method] = function () {
      var args = Array.prototype.slice.call(arguments);
      var message = _.formatArgsAsString(args);
      self.telemeter.captureLog(message, level, null, _.now());
      if (orig) {
        Function.prototype.apply.call(orig, origConsole, args);
      }
    };
    self.replacements['log'].push([method, orig]);
  }
  var methods = ['debug', 'info', 'warn', 'error', 'log'];
  try {
    for (var i = 0, len = methods.length; i < len; i++) {
      wrapConsole(methods[i]);
    }
  } catch (e) {
    this.diagnostic.instrumentConsole = {
      error: e.message
    };
  }
};
Instrumenter.prototype.deinstrumentDom = function () {
  if (!('addEventListener' in this._window || 'attachEvent' in this._window)) {
    return;
  }
  this.removeListeners('dom');
};
Instrumenter.prototype.instrumentDom = function () {
  if (!('addEventListener' in this._window || 'attachEvent' in this._window)) {
    return;
  }
  var clickHandler = this.handleClick.bind(this);
  var blurHandler = this.handleBlur.bind(this);
  this.addListener('dom', this._window, 'click', 'onclick', clickHandler, true);
  this.addListener('dom', this._window, 'blur', 'onfocusout', blurHandler, true);
};
Instrumenter.prototype.handleClick = function (evt) {
  try {
    var e = domUtil.getElementFromEvent(evt, this._document);
    var hasTag = e && e.tagName;
    var anchorOrButton = domUtil.isDescribedElement(e, 'a') || domUtil.isDescribedElement(e, 'button');
    if (hasTag && (anchorOrButton || domUtil.isDescribedElement(e, 'input', ['button', 'submit']))) {
      this.captureDomEvent('click', e);
    } else if (domUtil.isDescribedElement(e, 'input', ['checkbox', 'radio'])) {
      this.captureDomEvent('input', e, e.value, e.checked);
    }
  } catch (exc) {
    // TODO: Not sure what to do here
  }
};
Instrumenter.prototype.handleBlur = function (evt) {
  try {
    var e = domUtil.getElementFromEvent(evt, this._document);
    if (e && e.tagName) {
      if (domUtil.isDescribedElement(e, 'textarea')) {
        this.captureDomEvent('input', e, e.value);
      } else if (domUtil.isDescribedElement(e, 'select') && e.options && e.options.length) {
        this.handleSelectInputChanged(e);
      } else if (domUtil.isDescribedElement(e, 'input') && !domUtil.isDescribedElement(e, 'input', ['button', 'submit', 'hidden', 'checkbox', 'radio'])) {
        this.captureDomEvent('input', e, e.value);
      }
    }
  } catch (exc) {
    // TODO: Not sure what to do here
  }
};
Instrumenter.prototype.handleSelectInputChanged = function (elem) {
  if (elem.multiple) {
    for (var i = 0; i < elem.options.length; i++) {
      if (elem.options[i].selected) {
        this.captureDomEvent('input', elem, elem.options[i].value);
      }
    }
  } else if (elem.selectedIndex >= 0 && elem.options[elem.selectedIndex]) {
    this.captureDomEvent('input', elem, elem.options[elem.selectedIndex].value);
  }
};
Instrumenter.prototype.captureDomEvent = function (subtype, element, value, isChecked) {
  if (value !== undefined) {
    if (this.scrubTelemetryInputs || domUtil.getElementType(element) === 'password') {
      value = '[scrubbed]';
    } else {
      var description = domUtil.describeElement(element);
      if (this.telemetryScrubber) {
        if (this.telemetryScrubber(description)) {
          value = '[scrubbed]';
        }
      } else if (this.defaultValueScrubber(description)) {
        value = '[scrubbed]';
      }
    }
  }
  var elementString = domUtil.elementArrayToString(domUtil.treeToArray(element));
  this.telemeter.captureDom(subtype, elementString, value, isChecked);
};
Instrumenter.prototype.deinstrumentNavigation = function () {
  var chrome = this._window.chrome;
  var chromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  // See https://github.com/angular/angular.js/pull/13945/files
  var hasPushState = !chromePackagedApp && this._window.history && this._window.history.pushState;
  if (!hasPushState) {
    return;
  }
  restore(this.replacements, 'navigation');
};
Instrumenter.prototype.instrumentNavigation = function () {
  var chrome = this._window.chrome;
  var chromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  // See https://github.com/angular/angular.js/pull/13945/files
  var hasPushState = !chromePackagedApp && this._window.history && this._window.history.pushState;
  if (!hasPushState) {
    return;
  }
  var self = this;
  replace(this._window, 'onpopstate', function (orig) {
    return function () {
      var current = self._location.href;
      self.handleUrlChange(self._lastHref, current);
      if (orig) {
        orig.apply(this, arguments);
      }
    };
  }, this.replacements, 'navigation');
  replace(this._window.history, 'pushState', function (orig) {
    return function () {
      var url = arguments.length > 2 ? arguments[2] : undefined;
      if (url) {
        self.handleUrlChange(self._lastHref, url + '');
      }
      return orig.apply(this, arguments);
    };
  }, this.replacements, 'navigation');
};
Instrumenter.prototype.handleUrlChange = function (from, to) {
  var parsedHref = urlparser.parse(this._location.href);
  var parsedTo = urlparser.parse(to);
  var parsedFrom = urlparser.parse(from);
  this._lastHref = to;
  if (parsedHref.protocol === parsedTo.protocol && parsedHref.host === parsedTo.host) {
    to = parsedTo.path + (parsedTo.hash || '');
  }
  if (parsedHref.protocol === parsedFrom.protocol && parsedHref.host === parsedFrom.host) {
    from = parsedFrom.path + (parsedFrom.hash || '');
  }
  this.telemeter.captureNavigation(from, to, _.now());
};
Instrumenter.prototype.deinstrumentConnectivity = function () {
  if (!('addEventListener' in this._window || 'body' in this._document)) {
    return;
  }
  if (this._window.addEventListener) {
    this.removeListeners('connectivity');
  } else {
    restore(this.replacements, 'connectivity');
  }
};
Instrumenter.prototype.instrumentConnectivity = function () {
  if (!('addEventListener' in this._window || 'body' in this._document)) {
    return;
  }
  if (this._window.addEventListener) {
    this.addListener('connectivity', this._window, 'online', undefined, function () {
      this.telemeter.captureConnectivityChange('online');
    }.bind(this), true);
    this.addListener('connectivity', this._window, 'offline', undefined, function () {
      this.telemeter.captureConnectivityChange('offline');
    }.bind(this), true);
  } else {
    var self = this;
    replace(this._document.body, 'ononline', function (orig) {
      return function () {
        self.telemeter.captureConnectivityChange('online');
        if (orig) {
          orig.apply(this, arguments);
        }
      };
    }, this.replacements, 'connectivity');
    replace(this._document.body, 'onoffline', function (orig) {
      return function () {
        self.telemeter.captureConnectivityChange('offline');
        if (orig) {
          orig.apply(this, arguments);
        }
      };
    }, this.replacements, 'connectivity');
  }
};
Instrumenter.prototype.handleCspEvent = function (cspEvent) {
  var message = 'Security Policy Violation: ' + 'blockedURI: ' + cspEvent.blockedURI + ', ' + 'violatedDirective: ' + cspEvent.violatedDirective + ', ' + 'effectiveDirective: ' + cspEvent.effectiveDirective + ', ';
  if (cspEvent.sourceFile) {
    message += 'location: ' + cspEvent.sourceFile + ', ' + 'line: ' + cspEvent.lineNumber + ', ' + 'col: ' + cspEvent.columnNumber + ', ';
  }
  message += 'originalPolicy: ' + cspEvent.originalPolicy;
  this.telemeter.captureLog(message, 'error', null, _.now());
  this.handleCspError(message);
};
Instrumenter.prototype.handleCspError = function (message) {
  if (this.autoInstrument.errorOnContentSecurityPolicy) {
    this.rollbar.error(message);
  }
};
Instrumenter.prototype.deinstrumentContentSecurityPolicy = function () {
  if (!('addEventListener' in this._document)) {
    return;
  }
  this.removeListeners('contentsecuritypolicy');
};
Instrumenter.prototype.instrumentContentSecurityPolicy = function () {
  if (!('addEventListener' in this._document)) {
    return;
  }
  var cspHandler = this.handleCspEvent.bind(this);
  this.addListener('contentsecuritypolicy', this._document, 'securitypolicyviolation', null, cspHandler, false);
};
Instrumenter.prototype.addListener = function (section, obj, type, altType, handler, capture) {
  if (obj.addEventListener) {
    obj.addEventListener(type, handler, capture);
    this.eventRemovers[section].push(function () {
      obj.removeEventListener(type, handler, capture);
    });
  } else if (altType) {
    obj.attachEvent(altType, handler);
    this.eventRemovers[section].push(function () {
      obj.detachEvent(altType, handler);
    });
  }
};
Instrumenter.prototype.removeListeners = function (section) {
  var r;
  while (this.eventRemovers[section].length) {
    r = this.eventRemovers[section].shift();
    r();
  }
};
function _isUrlObject(input) {
  return typeof URL !== 'undefined' && input instanceof URL;
}
module.exports = Instrumenter;

/***/ }),

/***/ "./src/browser/transforms.js":
/*!***********************************!*\
  !*** ./src/browser/transforms.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var errorParser = __webpack_require__(/*! ../errorParser */ "./src/errorParser.js");
var logger = __webpack_require__(/*! ./logger */ "./src/browser/logger.js");
function handleDomException(item, options, callback) {
  if (item.err && errorParser.Stack(item.err).name === 'DOMException') {
    var originalError = new Error();
    originalError.name = item.err.name;
    originalError.message = item.err.message;
    originalError.stack = item.err.stack;
    originalError.nested = item.err;
    item.err = originalError;
  }
  callback(null, item);
}
function handleItemWithError(item, options, callback) {
  item.data = item.data || {};
  if (item.err) {
    try {
      item.stackInfo = item.err._savedStackTrace || errorParser.parse(item.err, item.skipFrames);
      if (options.addErrorContext) {
        addErrorContext(item);
      }
    } catch (e) {
      logger.error('Error while parsing the error object.', e);
      try {
        item.message = item.err.message || item.err.description || item.message || String(item.err);
      } catch (e2) {
        item.message = String(item.err) || String(e2);
      }
      delete item.err;
    }
  }
  callback(null, item);
}
function addErrorContext(item) {
  var chain = [];
  var err = item.err;
  chain.push(err);
  while (err.nested || err.cause) {
    err = err.nested || err.cause;
    chain.push(err);
  }
  _.addErrorContext(item, chain);
}
function ensureItemHasSomethingToSay(item, options, callback) {
  if (!item.message && !item.stackInfo && !item.custom) {
    callback(new Error('No message, stack info, or custom data'), null);
  }
  callback(null, item);
}
function addBaseInfo(item, options, callback) {
  var environment = options.payload && options.payload.environment || options.environment;
  item.data = _.merge(item.data, {
    environment: environment,
    level: item.level,
    endpoint: options.endpoint,
    platform: 'browser',
    framework: 'browser-js',
    language: 'javascript',
    server: {},
    uuid: item.uuid,
    notifier: {
      name: 'rollbar-browser-js',
      version: options.version
    },
    custom: item.custom
  });
  callback(null, item);
}
function addRequestInfo(window) {
  return function (item, options, callback) {
    var requestInfo = {};
    if (window && window.location) {
      requestInfo.url = window.location.href;
      requestInfo.query_string = window.location.search;
    }
    var remoteString = '$remote_ip';
    if (!options.captureIp) {
      remoteString = null;
    } else if (options.captureIp !== true) {
      remoteString += '_anonymize';
    }
    if (remoteString) requestInfo.user_ip = remoteString;
    if (Object.keys(requestInfo).length > 0) {
      _.set(item, 'data.request', requestInfo);
    }
    callback(null, item);
  };
}
function addClientInfo(window) {
  return function (item, options, callback) {
    if (!window) {
      return callback(null, item);
    }
    var nav = window.navigator || {};
    var scr = window.screen || {};
    _.set(item, 'data.client', {
      runtime_ms: item.timestamp - window._rollbarStartTime,
      timestamp: Math.round(item.timestamp / 1000),
      javascript: {
        browser: nav.userAgent,
        language: nav.language,
        cookie_enabled: nav.cookieEnabled,
        screen: {
          width: scr.width,
          height: scr.height
        }
      }
    });
    callback(null, item);
  };
}
function addPluginInfo(window) {
  return function (item, options, callback) {
    if (!window || !window.navigator) {
      return callback(null, item);
    }
    var plugins = [];
    var navPlugins = window.navigator.plugins || [];
    var cur;
    for (var i = 0, l = navPlugins.length; i < l; ++i) {
      cur = navPlugins[i];
      plugins.push({
        name: cur.name,
        description: cur.description
      });
    }
    _.set(item, 'data.client.javascript.plugins', plugins);
    callback(null, item);
  };
}
function addBody(item, options, callback) {
  if (item.stackInfo) {
    if (item.stackInfo.traceChain) {
      addBodyTraceChain(item, options, callback);
    } else {
      addBodyTrace(item, options, callback);
    }
  } else {
    addBodyMessage(item, options, callback);
  }
}
function addBodyMessage(item, options, callback) {
  var message = item.message;
  var custom = item.custom;
  if (!message) {
    message = 'Item sent with null or missing arguments.';
  }
  var result = {
    body: message
  };
  if (custom) {
    result.extra = _.merge(custom);
  }
  _.set(item, 'data.body', {
    message: result
  });
  callback(null, item);
}
function stackFromItem(item) {
  // Transform a TraceKit stackInfo object into a Rollbar trace
  var stack = item.stackInfo.stack;
  if (stack && stack.length === 0 && item._unhandledStackInfo && item._unhandledStackInfo.stack) {
    stack = item._unhandledStackInfo.stack;
  }
  return stack;
}
function addBodyTraceChain(item, options, callback) {
  var traceChain = item.stackInfo.traceChain;
  var traces = [];
  var traceChainLength = traceChain.length;
  for (var i = 0; i < traceChainLength; i++) {
    var trace = buildTrace(item, traceChain[i], options);
    traces.push(trace);
  }
  _.set(item, 'data.body', {
    trace_chain: traces
  });
  callback(null, item);
}
function addBodyTrace(item, options, callback) {
  var stack = stackFromItem(item);
  if (stack) {
    var trace = buildTrace(item, item.stackInfo, options);
    _.set(item, 'data.body', {
      trace: trace
    });
    callback(null, item);
  } else {
    var stackInfo = item.stackInfo;
    var guess = errorParser.guessErrorClass(stackInfo.message);
    var className = errorClass(stackInfo, guess[0], options);
    var message = guess[1];
    item.message = className + ': ' + message;
    addBodyMessage(item, options, callback);
  }
}
function buildTrace(item, stackInfo, options) {
  var description = item && item.data.description;
  var custom = item && item.custom;
  var stack = stackFromItem(item);
  var guess = errorParser.guessErrorClass(stackInfo.message);
  var className = errorClass(stackInfo, guess[0], options);
  var message = guess[1];
  var trace = {
    exception: {
      "class": className,
      message: message
    }
  };
  if (description) {
    trace.exception.description = description;
  }
  if (stack) {
    if (stack.length === 0) {
      trace.exception.stack = stackInfo.rawStack;
      trace.exception.raw = String(stackInfo.rawException);
    }
    var stackFrame;
    var frame;
    var code;
    var pre;
    var post;
    var contextLength;
    var i, mid;
    trace.frames = [];
    for (i = 0; i < stack.length; ++i) {
      stackFrame = stack[i];
      frame = {
        filename: stackFrame.url ? _.sanitizeUrl(stackFrame.url) : '(unknown)',
        lineno: stackFrame.line || null,
        method: !stackFrame.func || stackFrame.func === '?' ? '[anonymous]' : stackFrame.func,
        colno: stackFrame.column
      };
      if (options.sendFrameUrl) {
        frame.url = stackFrame.url;
      }
      if (frame.method && frame.method.endsWith && frame.method.endsWith('_rollbar_wrapped')) {
        continue;
      }
      code = pre = post = null;
      contextLength = stackFrame.context ? stackFrame.context.length : 0;
      if (contextLength) {
        mid = Math.floor(contextLength / 2);
        pre = stackFrame.context.slice(0, mid);
        code = stackFrame.context[mid];
        post = stackFrame.context.slice(mid);
      }
      if (code) {
        frame.code = code;
      }
      if (pre || post) {
        frame.context = {};
        if (pre && pre.length) {
          frame.context.pre = pre;
        }
        if (post && post.length) {
          frame.context.post = post;
        }
      }
      if (stackFrame.args) {
        frame.args = stackFrame.args;
      }
      trace.frames.push(frame);
    }

    // NOTE(cory): reverse the frames since rollbar.com expects the most recent call last
    trace.frames.reverse();
    if (custom) {
      trace.extra = _.merge(custom);
    }
  }
  return trace;
}
function errorClass(stackInfo, guess, options) {
  if (stackInfo.name) {
    return stackInfo.name;
  } else if (options.guessErrorClass) {
    return guess;
  } else {
    return '(unknown)';
  }
}
function addScrubber(scrubFn) {
  return function (item, options, callback) {
    if (scrubFn) {
      var scrubFields = options.scrubFields || [];
      var scrubPaths = options.scrubPaths || [];
      item.data = scrubFn(item.data, scrubFields, scrubPaths);
    }
    callback(null, item);
  };
}
module.exports = {
  handleDomException: handleDomException,
  handleItemWithError: handleItemWithError,
  ensureItemHasSomethingToSay: ensureItemHasSomethingToSay,
  addBaseInfo: addBaseInfo,
  addRequestInfo: addRequestInfo,
  addClientInfo: addClientInfo,
  addPluginInfo: addPluginInfo,
  addBody: addBody,
  addScrubber: addScrubber
};

/***/ }),

/***/ "./src/browser/transport.js":
/*!**********************************!*\
  !*** ./src/browser/transport.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var makeFetchRequest = __webpack_require__(/*! ./transport/fetch */ "./src/browser/transport/fetch.js");
var makeXhrRequest = __webpack_require__(/*! ./transport/xhr */ "./src/browser/transport/xhr.js");

/*
 * accessToken may be embedded in payload but that should not
 *   be assumed
 *
 * options: {
 *   hostname
 *   protocol
 *   path
 *   port
 *   method
 *   transport ('xhr' | 'fetch')
 * }
 *
 *  params is an object containing key/value pairs. These
 *    will be appended to the path as 'key=value&key=value'
 *
 * payload is an unserialized object
 */
function Transport(truncation) {
  this.truncation = truncation;
}
Transport.prototype.get = function (accessToken, options, params, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  _.addParamsAndAccessTokenToPath(accessToken, options, params);
  var method = 'GET';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, null, callback, requestFactory, options.timeout, options.transport);
};
Transport.prototype.post = function (accessToken, options, payload, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  if (!payload) {
    return callback(new Error('Cannot send empty request'));
  }
  var stringifyResult;
  if (this.truncation) {
    stringifyResult = this.truncation.truncate(payload);
  } else {
    stringifyResult = _.stringify(payload);
  }
  if (stringifyResult.error) {
    return callback(stringifyResult.error);
  }
  var writeData = stringifyResult.value;
  var method = 'POST';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, writeData, callback, requestFactory, options.timeout, options.transport);
};
Transport.prototype.postJsonPayload = function (accessToken, options, jsonPayload, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  var method = 'POST';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, jsonPayload, callback, requestFactory, options.timeout, options.transport);
};

// Wraps `_makeRequest` if zone.js is being used, ensuring that Rollbar
// API calls are not intercepted by any child forked zones.
// This is equivalent to `NgZone.runOutsideAngular` in Angular.
Transport.prototype._makeZoneRequest = function () {
  var gWindow = typeof window != 'undefined' && window || typeof self != 'undefined' && self;
  // Whenever zone.js is loaded and `Zone` is exposed globally, access
  // the root zone to ensure that requests are always made within it.
  // This approach is framework-agnostic, regardless of which
  // framework zone.js is used with.
  var rootZone = gWindow && gWindow.Zone && gWindow.Zone.root;
  var args = Array.prototype.slice.call(arguments);
  if (rootZone) {
    var self = this;
    rootZone.run(function () {
      self._makeRequest.apply(undefined, args);
    });
  } else {
    this._makeRequest.apply(undefined, args);
  }
};
Transport.prototype._makeRequest = function (accessToken, url, method, data, callback, requestFactory, timeout, transport) {
  if (typeof RollbarProxy !== 'undefined') {
    return _proxyRequest(data, callback);
  }
  if (transport === 'fetch') {
    makeFetchRequest(accessToken, url, method, data, callback, timeout);
  } else {
    makeXhrRequest(accessToken, url, method, data, callback, requestFactory, timeout);
  }
};

/* global RollbarProxy */
function _proxyRequest(json, callback) {
  var rollbarProxy = new RollbarProxy();
  rollbarProxy.sendJsonPayload(json, function (_msg) {
    /* do nothing */
  },
  // eslint-disable-line no-unused-vars
  function (err) {
    callback(new Error(err));
  });
}
module.exports = Transport;

/***/ }),

/***/ "./src/browser/transport/fetch.js":
/*!****************************************!*\
  !*** ./src/browser/transport/fetch.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var logger = __webpack_require__(/*! ../logger */ "./src/browser/logger.js");
var _ = __webpack_require__(/*! ../../utility */ "./src/utility.js");
function makeFetchRequest(accessToken, url, method, data, callback, timeout) {
  var controller;
  var timeoutId;
  if (_.isFiniteNumber(timeout)) {
    controller = new AbortController();
    timeoutId = setTimeout(function () {
      controller.abort();
    }, timeout);
  }
  fetch(url, {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-Rollbar-Access-Token': accessToken,
      signal: controller && controller.signal
    },
    body: data
  }).then(function (response) {
    if (timeoutId) clearTimeout(timeoutId);
    return response.json();
  }).then(function (data) {
    callback(null, data);
  })["catch"](function (error) {
    logger.error(error.message);
    callback(error);
  });
}
module.exports = makeFetchRequest;

/***/ }),

/***/ "./src/browser/transport/xhr.js":
/*!**************************************!*\
  !*** ./src/browser/transport/xhr.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global XDomainRequest*/

var _ = __webpack_require__(/*! ../../utility */ "./src/utility.js");
var logger = __webpack_require__(/*! ../logger */ "./src/browser/logger.js");
function makeXhrRequest(accessToken, url, method, data, callback, requestFactory, timeout) {
  var request;
  if (requestFactory) {
    request = requestFactory();
  } else {
    request = _createXMLHTTPObject();
  }
  if (!request) {
    // Give up, no way to send requests
    return callback(new Error('No way to send a request'));
  }
  try {
    try {
      var _onreadystatechange = function onreadystatechange() {
        try {
          if (_onreadystatechange && request.readyState === 4) {
            _onreadystatechange = undefined;
            var parseResponse = _.jsonParse(request.responseText);
            if (_isSuccess(request)) {
              callback(parseResponse.error, parseResponse.value);
              return;
            } else if (_isNormalFailure(request)) {
              if (request.status === 403) {
                // likely caused by using a server access token
                var message = parseResponse.value && parseResponse.value.message;
                logger.error(message);
              }
              // return valid http status codes
              callback(new Error(String(request.status)));
            } else {
              // IE will return a status 12000+ on some sort of connection failure,
              // so we return a blank error
              // http://msdn.microsoft.com/en-us/library/aa383770%28VS.85%29.aspx
              var msg = 'XHR response had no status code (likely connection failure)';
              callback(_newRetriableError(msg));
            }
          }
        } catch (ex) {
          //jquery source mentions firefox may error out while accessing the
          //request members if there is a network error
          //https://github.com/jquery/jquery/blob/a938d7b1282fc0e5c52502c225ae8f0cef219f0a/src/ajax/xhr.js#L111
          var exc;
          if (ex && ex.stack) {
            exc = ex;
          } else {
            exc = new Error(ex);
          }
          callback(exc);
        }
      };
      request.open(method, url, true);
      if (request.setRequestHeader) {
        request.setRequestHeader('Content-Type', 'application/json');
        request.setRequestHeader('X-Rollbar-Access-Token', accessToken);
      }
      if (_.isFiniteNumber(timeout)) {
        request.timeout = timeout;
      }
      request.onreadystatechange = _onreadystatechange;
      request.send(data);
    } catch (e1) {
      // Sending using the normal xmlhttprequest object didn't work, try XDomainRequest
      if (typeof XDomainRequest !== 'undefined') {
        // Assume we are in a really old browser which has a bunch of limitations:
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

        // Extreme paranoia: if we have XDomainRequest then we have a window, but just in case
        if (!window || !window.location) {
          return callback(new Error('No window available during request, unknown environment'));
        }

        // If the current page is http, try and send over http
        if (window.location.href.substring(0, 5) === 'http:' && url.substring(0, 5) === 'https') {
          url = 'http' + url.substring(5);
        }
        var xdomainrequest = new XDomainRequest();
        xdomainrequest.onprogress = function () {};
        xdomainrequest.ontimeout = function () {
          var msg = 'Request timed out';
          var code = 'ETIMEDOUT';
          callback(_newRetriableError(msg, code));
        };
        xdomainrequest.onerror = function () {
          callback(new Error('Error during request'));
        };
        xdomainrequest.onload = function () {
          var parseResponse = _.jsonParse(xdomainrequest.responseText);
          callback(parseResponse.error, parseResponse.value);
        };
        xdomainrequest.open(method, url, true);
        xdomainrequest.send(data);
      } else {
        callback(new Error('Cannot find a method to transport a request'));
      }
    }
  } catch (e2) {
    callback(e2);
  }
}
function _createXMLHTTPObject() {
  /* global ActiveXObject:false */

  var factories = [function () {
    return new XMLHttpRequest();
  }, function () {
    return new ActiveXObject('Msxml2.XMLHTTP');
  }, function () {
    return new ActiveXObject('Msxml3.XMLHTTP');
  }, function () {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }];
  var xmlhttp;
  var i;
  var numFactories = factories.length;
  for (i = 0; i < numFactories; i++) {
    /* eslint-disable no-empty */
    try {
      xmlhttp = factories[i]();
      break;
    } catch (e) {
      // pass
    }
    /* eslint-enable no-empty */
  }
  return xmlhttp;
}
function _isSuccess(r) {
  return r && r.status && r.status === 200;
}
function _isNormalFailure(r) {
  return r && _.isType(r.status, 'number') && r.status >= 400 && r.status < 600;
}
function _newRetriableError(message, code) {
  var err = new Error(message);
  err.code = code || 'ENOTFOUND';
  return err;
}
module.exports = makeXhrRequest;

/***/ }),

/***/ "./src/browser/url.js":
/*!****************************!*\
  !*** ./src/browser/url.js ***!
  \****************************/
/***/ ((module) => {

// See https://nodejs.org/docs/latest/api/url.html
function parse(url) {
  var result = {
    protocol: null,
    auth: null,
    host: null,
    path: null,
    hash: null,
    href: url,
    hostname: null,
    port: null,
    pathname: null,
    search: null,
    query: null
  };
  var i, last;
  i = url.indexOf('//');
  if (i !== -1) {
    result.protocol = url.substring(0, i);
    last = i + 2;
  } else {
    last = 0;
  }
  i = url.indexOf('@', last);
  if (i !== -1) {
    result.auth = url.substring(last, i);
    last = i + 1;
  }
  i = url.indexOf('/', last);
  if (i === -1) {
    i = url.indexOf('?', last);
    if (i === -1) {
      i = url.indexOf('#', last);
      if (i === -1) {
        result.host = url.substring(last);
      } else {
        result.host = url.substring(last, i);
        result.hash = url.substring(i);
      }
      result.hostname = result.host.split(':')[0];
      result.port = result.host.split(':')[1];
      if (result.port) {
        result.port = parseInt(result.port, 10);
      }
      return result;
    } else {
      result.host = url.substring(last, i);
      result.hostname = result.host.split(':')[0];
      result.port = result.host.split(':')[1];
      if (result.port) {
        result.port = parseInt(result.port, 10);
      }
      last = i;
    }
  } else {
    result.host = url.substring(last, i);
    result.hostname = result.host.split(':')[0];
    result.port = result.host.split(':')[1];
    if (result.port) {
      result.port = parseInt(result.port, 10);
    }
    last = i;
  }
  i = url.indexOf('#', last);
  if (i === -1) {
    result.path = url.substring(last);
  } else {
    result.path = url.substring(last, i);
    result.hash = url.substring(i);
  }
  if (result.path) {
    var pathParts = result.path.split('?');
    result.pathname = pathParts[0];
    result.query = pathParts[1];
    result.search = result.query ? '?' + result.query : null;
  }
  return result;
}
module.exports = {
  parse: parse
};

/***/ }),

/***/ "./src/browser/wrapGlobals.js":
/*!************************************!*\
  !*** ./src/browser/wrapGlobals.js ***!
  \************************************/
/***/ ((module) => {

function wrapGlobals(window, handler, shim) {
  if (!window) {
    return;
  }
  // Adapted from https://github.com/bugsnag/bugsnag-js
  var globals = 'EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload'.split(',');
  var i, global;
  for (i = 0; i < globals.length; ++i) {
    global = globals[i];
    if (window[global] && window[global].prototype) {
      _extendListenerPrototype(handler, window[global].prototype, shim);
    }
  }
}
function _extendListenerPrototype(handler, prototype, shim) {
  if (prototype.hasOwnProperty && prototype.hasOwnProperty('addEventListener')) {
    var oldAddEventListener = prototype.addEventListener;
    while (oldAddEventListener._rollbarOldAdd && oldAddEventListener.belongsToShim) {
      oldAddEventListener = oldAddEventListener._rollbarOldAdd;
    }
    var addFn = function addFn(event, callback, bubble) {
      oldAddEventListener.call(this, event, handler.wrap(callback), bubble);
    };
    addFn._rollbarOldAdd = oldAddEventListener;
    addFn.belongsToShim = shim;
    prototype.addEventListener = addFn;
    var oldRemoveEventListener = prototype.removeEventListener;
    while (oldRemoveEventListener._rollbarOldRemove && oldRemoveEventListener.belongsToShim) {
      oldRemoveEventListener = oldRemoveEventListener._rollbarOldRemove;
    }
    var removeFn = function removeFn(event, callback, bubble) {
      oldRemoveEventListener.call(this, event, callback && callback._rollbar_wrapped || callback, bubble);
    };
    removeFn._rollbarOldRemove = oldRemoveEventListener;
    removeFn.belongsToShim = shim;
    prototype.removeEventListener = removeFn;
  }
}
module.exports = wrapGlobals;

/***/ }),

/***/ "./src/defaults.js":
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/***/ ((module) => {

module.exports = {
  version: '3.0.0-alpha.0',
  endpoint: 'api.rollbar.com/api/1/item/',
  logLevel: 'debug',
  reportLevel: 'debug',
  uncaughtErrorLevel: 'error',
  maxItems: 0,
  itemsPerMin: 60
};

/***/ }),

/***/ "./src/errorParser.js":
/*!****************************!*\
  !*** ./src/errorParser.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ErrorStackParser = __webpack_require__(/*! error-stack-parser */ "./node_modules/error-stack-parser/error-stack-parser.js");
var UNKNOWN_FUNCTION = '?';
var ERR_CLASS_REGEXP = new RegExp('^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ');
function guessFunctionName() {
  return UNKNOWN_FUNCTION;
}
function gatherContext() {
  return null;
}
function Frame(stackFrame) {
  var data = {};
  data._stackFrame = stackFrame;
  data.url = stackFrame.fileName;
  data.line = stackFrame.lineNumber;
  data.func = stackFrame.functionName;
  data.column = stackFrame.columnNumber;
  data.args = stackFrame.args;
  data.context = gatherContext();
  return data;
}
function Stack(exception, skip) {
  function getStack() {
    var parserStack = [];
    skip = skip || 0;
    try {
      parserStack = ErrorStackParser.parse(exception);
    } catch (e) {
      parserStack = [];
    }
    var stack = [];
    for (var i = skip; i < parserStack.length; i++) {
      stack.push(new Frame(parserStack[i]));
    }
    return stack;
  }
  return {
    stack: getStack(),
    message: exception.message,
    name: _mostSpecificErrorName(exception),
    rawStack: exception.stack,
    rawException: exception
  };
}
function parse(e, skip) {
  var err = e;
  if (err.nested || err.cause) {
    var traceChain = [];
    while (err) {
      traceChain.push(new Stack(err, skip));
      err = err.nested || err.cause;
      skip = 0; // Only apply skip value to primary error
    }

    // Return primary error with full trace chain attached.
    traceChain[0].traceChain = traceChain;
    return traceChain[0];
  } else {
    return new Stack(err, skip);
  }
}
function guessErrorClass(errMsg) {
  if (!errMsg || !errMsg.match) {
    return ['Unknown error. There was no error message to display.', ''];
  }
  var errClassMatch = errMsg.match(ERR_CLASS_REGEXP);
  var errClass = '(unknown)';
  if (errClassMatch) {
    errClass = errClassMatch[errClassMatch.length - 1];
    errMsg = errMsg.replace((errClassMatch[errClassMatch.length - 2] || '') + errClass + ':', '');
    errMsg = errMsg.replace(/(^[\s]+|[\s]+$)/g, '');
  }
  return [errClass, errMsg];
}

// * Prefers any value over an empty string
// * Prefers any value over 'Error' where possible
// * Prefers name over constructor.name when both are more specific than 'Error'
function _mostSpecificErrorName(error) {
  var name = error.name && error.name.length && error.name;
  var constructorName = error.constructor.name && error.constructor.name.length && error.constructor.name;
  if (!name || !constructorName) {
    return name || constructorName;
  }
  if (name === 'Error') {
    return constructorName;
  }
  return name;
}
module.exports = {
  guessFunctionName: guessFunctionName,
  guessErrorClass: guessErrorClass,
  gatherContext: gatherContext,
  parse: parse,
  Stack: Stack,
  Frame: Frame
};

/***/ }),

/***/ "./src/merge.js":
/*!**********************!*\
  !*** ./src/merge.js ***!
  \**********************/
/***/ ((module) => {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var isPlainObject = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== '[object Object]') {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, 'constructor');
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  // Not own constructor property must be Object
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {
    /**/
  }
  return typeof key === 'undefined' || hasOwn.call(obj, key);
};
function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = {},
    current = null,
    length = arguments.length;
  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {
      continue;
    }
    for (name in current) {
      src = result[name];
      copy = current[name];
      if (result !== copy) {
        if (copy && isPlainObject(copy)) {
          clone = src && isPlainObject(src) ? src : {};
          result[name] = merge(clone, copy);
        } else if (typeof copy !== 'undefined') {
          result[name] = copy;
        }
      }
    }
  }
  return result;
}
module.exports = merge;

/***/ }),

/***/ "./src/notifier.js":
/*!*************************!*\
  !*** ./src/notifier.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * Notifier - the internal object responsible for delegating between the client exposed API, the
 * chain of transforms necessary to turn an item into something that can be sent to Rollbar, and the
 * queue which handles the communcation with the Rollbar API servers.
 *
 * @param queue - an object that conforms to the interface: addItem(item, callback)
 * @param options - an object representing the options to be set for this notifier, this should have
 * any defaults already set by the caller
 */
function Notifier(queue, options) {
  this.queue = queue;
  this.options = options;
  this.transforms = [];
  this.diagnostic = {};
}

/*
 * configure - updates the options for this notifier with the passed in object
 *
 * @param options - an object which gets merged with the current options set on this notifier
 * @returns this
 */
Notifier.prototype.configure = function (options) {
  this.queue && this.queue.configure(options);
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  return this;
};

/*
 * addTransform - adds a transform onto the end of the queue of transforms for this notifier
 *
 * @param transform - a function which takes three arguments:
 *    * item: An Object representing the data to eventually be sent to Rollbar
 *    * options: The current value of the options for this notifier
 *    * callback: function(err: (Null|Error), item: (Null|Object)) the transform must call this
 *    callback with a null value for error if it wants the processing chain to continue, otherwise
 *    with an error to terminate the processing. The item should be the updated item after this
 *    transform is finished modifying it.
 */
Notifier.prototype.addTransform = function (transform) {
  if (_.isFunction(transform)) {
    this.transforms.push(transform);
  }
  return this;
};

/*
 * log - the internal log function which applies the configured transforms and then pushes onto the
 * queue to be sent to the backend.
 *
 * @param item - An object with the following structure:
 *    message [String] - An optional string to be sent to rollbar
 *    error [Error] - An optional error
 *
 * @param callback - A function of type function(err, resp) which will be called with exactly one
 * null argument and one non-null argument. The callback will be called once, either during the
 * transform stage if an error occurs inside a transform, or in response to the communication with
 * the backend. The second argument will be the response from the backend in case of success.
 */
Notifier.prototype.log = function (item, callback) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  if (!this.options.enabled) {
    return callback(new Error('Rollbar is not enabled'));
  }
  this.queue.addPendingItem(item);
  var originalError = item.err;
  this._applyTransforms(item, function (err, i) {
    if (err) {
      this.queue.removePendingItem(item);
      return callback(err, null);
    }
    this.queue.addItem(i, callback, originalError, item);
  }.bind(this));
};

/* Internal */

/*
 * _applyTransforms - Applies the transforms that have been added to this notifier sequentially. See
 * `addTransform` for more information.
 *
 * @param item - An item to be transformed
 * @param callback - A function of type function(err, item) which will be called with a non-null
 * error and a null item in the case of a transform failure, or a null error and non-null item after
 * all transforms have been applied.
 */
Notifier.prototype._applyTransforms = function (item, callback) {
  var transformIndex = -1;
  var transformsLength = this.transforms.length;
  var transforms = this.transforms;
  var options = this.options;
  var _cb = function cb(err, i) {
    if (err) {
      callback(err, null);
      return;
    }
    transformIndex++;
    if (transformIndex === transformsLength) {
      callback(null, i);
      return;
    }
    transforms[transformIndex](i, options, _cb);
  };
  _cb(null, item);
};
module.exports = Notifier;

/***/ }),

/***/ "./src/predicates.js":
/*!***************************!*\
  !*** ./src/predicates.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
function checkLevel(item, settings) {
  var level = item.level;
  var levelVal = _.LEVELS[level] || 0;
  var reportLevel = settings.reportLevel;
  var reportLevelVal = _.LEVELS[reportLevel] || 0;
  if (levelVal < reportLevelVal) {
    return false;
  }
  return true;
}
function userCheckIgnore(logger) {
  return function (item, settings) {
    var isUncaught = !!item._isUncaught;
    delete item._isUncaught;
    var args = item._originalArgs;
    delete item._originalArgs;
    try {
      if (_.isFunction(settings.onSendCallback)) {
        settings.onSendCallback(isUncaught, args, item);
      }
    } catch (e) {
      settings.onSendCallback = null;
      logger.error('Error while calling onSendCallback, removing', e);
    }
    try {
      if (_.isFunction(settings.checkIgnore) && settings.checkIgnore(isUncaught, args, item)) {
        return false;
      }
    } catch (e) {
      settings.checkIgnore = null;
      logger.error('Error while calling custom checkIgnore(), removing', e);
    }
    return true;
  };
}
function urlIsNotBlockListed(logger) {
  return function (item, settings) {
    return !urlIsOnAList(item, settings, 'blocklist', logger);
  };
}
function urlIsSafeListed(logger) {
  return function (item, settings) {
    return urlIsOnAList(item, settings, 'safelist', logger);
  };
}
function matchFrames(trace, list, block) {
  if (!trace) {
    return !block;
  }
  var frames = trace.frames;
  if (!frames || frames.length === 0) {
    return !block;
  }
  var frame, filename, url, urlRegex;
  var listLength = list.length;
  var frameLength = frames.length;
  for (var i = 0; i < frameLength; i++) {
    frame = frames[i];
    filename = frame.filename;
    if (!_.isType(filename, 'string')) {
      return !block;
    }
    for (var j = 0; j < listLength; j++) {
      url = list[j];
      urlRegex = new RegExp(url);
      if (urlRegex.test(filename)) {
        return true;
      }
    }
  }
  return false;
}
function urlIsOnAList(item, settings, safeOrBlock, logger) {
  // safelist is the default
  var block = false;
  if (safeOrBlock === 'blocklist') {
    block = true;
  }
  var list, traces;
  try {
    list = block ? settings.hostBlockList : settings.hostSafeList;
    traces = _.get(item, 'body.trace_chain') || [_.get(item, 'body.trace')];

    // These two checks are important to come first as they are defaults
    // in case the list is missing or the trace is missing or not well-formed
    if (!list || list.length === 0) {
      return !block;
    }
    if (traces.length === 0 || !traces[0]) {
      return !block;
    }
    var tracesLength = traces.length;
    for (var i = 0; i < tracesLength; i++) {
      if (matchFrames(traces[i], list, block)) {
        return true;
      }
    }
  } catch (e
  /* istanbul ignore next */) {
    if (block) {
      settings.hostBlockList = null;
    } else {
      settings.hostSafeList = null;
    }
    var listName = block ? 'hostBlockList' : 'hostSafeList';
    logger.error("Error while reading your configuration's " + listName + ' option. Removing custom ' + listName + '.', e);
    return !block;
  }
  return false;
}
function messageIsIgnored(logger) {
  return function (item, settings) {
    var i, j, ignoredMessages, len, messageIsIgnored, rIgnoredMessage, messages;
    try {
      messageIsIgnored = false;
      ignoredMessages = settings.ignoredMessages;
      if (!ignoredMessages || ignoredMessages.length === 0) {
        return true;
      }
      messages = messagesFromItem(item);
      if (messages.length === 0) {
        return true;
      }
      len = ignoredMessages.length;
      for (i = 0; i < len; i++) {
        rIgnoredMessage = new RegExp(ignoredMessages[i], 'gi');
        for (j = 0; j < messages.length; j++) {
          messageIsIgnored = rIgnoredMessage.test(messages[j]);
          if (messageIsIgnored) {
            return false;
          }
        }
      }
    } catch (e
    /* istanbul ignore next */) {
      settings.ignoredMessages = null;
      logger.error("Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.");
    }
    return true;
  };
}
function messagesFromItem(item) {
  var body = item.body;
  var messages = [];

  // The payload schema only allows one of trace_chain, message, or trace.
  // However, existing test cases are based on having both trace and message present.
  // So here we preserve the ability to collect strings from any combination of these keys.
  if (body.trace_chain) {
    var traceChain = body.trace_chain;
    for (var i = 0; i < traceChain.length; i++) {
      var trace = traceChain[i];
      messages.push(_.get(trace, 'exception.message'));
    }
  }
  if (body.trace) {
    messages.push(_.get(body, 'trace.exception.message'));
  }
  if (body.message) {
    messages.push(_.get(body, 'message.body'));
  }
  return messages;
}
module.exports = {
  checkLevel: checkLevel,
  userCheckIgnore: userCheckIgnore,
  urlIsNotBlockListed: urlIsNotBlockListed,
  urlIsSafeListed: urlIsSafeListed,
  messageIsIgnored: messageIsIgnored
};

/***/ }),

/***/ "./src/queue.js":
/*!**********************!*\
  !*** ./src/queue.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * Queue - an object which handles which handles a queue of items to be sent to Rollbar.
 *   This object handles rate limiting via a passed in rate limiter, retries based on connection
 *   errors, and filtering of items based on a set of configurable predicates. The communication to
 *   the backend is performed via a given API object.
 *
 * @param rateLimiter - An object which conforms to the interface
 *    rateLimiter.shouldSend(item) -> bool
 * @param api - An object which conforms to the interface
 *    api.postItem(payload, function(err, response))
 * @param logger - An object used to log verbose messages if desired
 * @param options - see Queue.prototype.configure
 * @param replayMap - Optional ReplayMap for coordinating session replay with error occurrences
 */
function Queue(rateLimiter, api, logger, options, replayMap) {
  this.rateLimiter = rateLimiter;
  this.api = api;
  this.logger = logger;
  this.options = options;
  this.replayMap = replayMap;
  this.predicates = [];
  this.pendingItems = [];
  this.pendingRequests = [];
  this.retryQueue = [];
  this.retryHandle = null;
  this.waitCallback = null;
  this.waitIntervalID = null;
}

/*
 * configure - updates the options this queue uses
 *
 * @param options
 */
Queue.prototype.configure = function (options) {
  this.api && this.api.configure(options);
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  return this;
};

/*
 * addPredicate - adds a predicate to the end of the list of predicates for this queue
 *
 * @param predicate - function(item, options) -> (bool|{err: Error})
 *  Returning true means that this predicate passes and the item is okay to go on the queue
 *  Returning false means do not add the item to the queue, but it is not an error
 *  Returning {err: Error} means do not add the item to the queue, and the given error explains why
 *  Returning {err: undefined} is equivalent to returning true but don't do that
 */
Queue.prototype.addPredicate = function (predicate) {
  if (_.isFunction(predicate)) {
    this.predicates.push(predicate);
  }
  return this;
};
Queue.prototype.addPendingItem = function (item) {
  this.pendingItems.push(item);
};
Queue.prototype.removePendingItem = function (item) {
  var idx = this.pendingItems.indexOf(item);
  if (idx !== -1) {
    this.pendingItems.splice(idx, 1);
  }
};

/*
 * addItem - Send an item to the Rollbar API if all of the predicates are satisfied
 *
 * @param item - The payload to send to the backend
 * @param callback - function(error, repsonse) which will be called with the response from the API
 *  in the case of a success, otherwise response will be null and error will have a value. If both
 *  error and response are null then the item was stopped by a predicate which did not consider this
 *  to be an error condition, but nonetheless did not send the item to the API.
 *  @param originalError - The original error before any transformations that is to be logged if any
 */
Queue.prototype.addItem = function (item, callback, originalError, originalItem) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {
      return;
    };
  }
  var predicateResult = this._applyPredicates(item);
  if (predicateResult.stop) {
    this.removePendingItem(originalItem);
    callback(predicateResult.err);
    return;
  }
  this._maybeLog(item, originalError);
  this.removePendingItem(originalItem);
  if (!this.options.transmit) {
    callback(new Error('Transmit disabled'));
    return;
  }
  if (this.replayMap && item.body) {
    var replayId = this.replayMap.add(item.uuid);
    item.replayId = replayId;
  }
  this.pendingRequests.push(item);
  try {
    this._makeApiRequest(item, function (err, resp) {
      this._dequeuePendingRequest(item);
      if (!err && resp && item.replayId) {
        this._handleReplayResponse(item.replayId, resp);
      }
      callback(err, resp);
    }.bind(this));
  } catch (e) {
    this._dequeuePendingRequest(item);
    callback(e);
  }
};

/*
 * wait - Stop any further errors from being added to the queue, and get called back when all items
 *   currently processing have finished sending to the backend.
 *
 * @param callback - function() called when all pending items have been sent
 */
Queue.prototype.wait = function (callback) {
  if (!_.isFunction(callback)) {
    return;
  }
  this.waitCallback = callback;
  if (this._maybeCallWait()) {
    return;
  }
  if (this.waitIntervalID) {
    this.waitIntervalID = clearInterval(this.waitIntervalID);
  }
  this.waitIntervalID = setInterval(function () {
    this._maybeCallWait();
  }.bind(this), 500);
};

/* _applyPredicates - Sequentially applies the predicates that have been added to the queue to the
 *   given item with the currently configured options.
 *
 * @param item - An item in the queue
 * @returns {stop: bool, err: (Error|null)} - stop being true means do not add item to the queue,
 *   the error value should be passed up to a callbak if we are stopping.
 */
Queue.prototype._applyPredicates = function (item) {
  var p = null;
  for (var i = 0, len = this.predicates.length; i < len; i++) {
    p = this.predicates[i](item, this.options);
    if (!p || p.err !== undefined) {
      return {
        stop: true,
        err: p.err
      };
    }
  }
  return {
    stop: false,
    err: null
  };
};

/*
 * _makeApiRequest - Send an item to Rollbar, callback when done, if there is an error make an
 *   effort to retry if we are configured to do so.
 *
 * @param item - an item ready to send to the backend
 * @param callback - function(err, response)
 */
Queue.prototype._makeApiRequest = function (item, callback) {
  var rateLimitResponse = this.rateLimiter.shouldSend(item);
  if (rateLimitResponse.shouldSend) {
    this.api.postItem(item, function (err, resp) {
      if (err) {
        this._maybeRetry(err, item, callback);
      } else {
        callback(err, resp);
      }
    }.bind(this));
  } else if (rateLimitResponse.error) {
    callback(rateLimitResponse.error);
  } else {
    this.api.postItem(rateLimitResponse.payload, callback);
  }
};

// These are errors basically mean there is no internet connection
var RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE', 'EAI_AGAIN'];

/*
 * _maybeRetry - Given the error returned by the API, decide if we should retry or just callback
 *   with the error.
 *
 * @param err - an error returned by the API transport
 * @param item - the item that was trying to be sent when this error occured
 * @param callback - function(err, response)
 */
Queue.prototype._maybeRetry = function (err, item, callback) {
  var shouldRetry = false;
  if (this.options.retryInterval) {
    for (var i = 0, len = RETRIABLE_ERRORS.length; i < len; i++) {
      if (err.code === RETRIABLE_ERRORS[i]) {
        shouldRetry = true;
        break;
      }
    }
    if (shouldRetry && _.isFiniteNumber(this.options.maxRetries)) {
      item.retries = item.retries ? item.retries + 1 : 1;
      if (item.retries > this.options.maxRetries) {
        shouldRetry = false;
      }
    }
  }
  if (shouldRetry) {
    this._retryApiRequest(item, callback);
  } else {
    callback(err);
  }
};

/*
 * _retryApiRequest - Add an item and a callback to a queue and possibly start a timer to process
 *   that queue based on the retryInterval in the options for this queue.
 *
 * @param item - an item that failed to send due to an error we deem retriable
 * @param callback - function(err, response)
 */
Queue.prototype._retryApiRequest = function (item, callback) {
  this.retryQueue.push({
    item: item,
    callback: callback
  });
  if (!this.retryHandle) {
    this.retryHandle = setInterval(function () {
      while (this.retryQueue.length) {
        var retryObject = this.retryQueue.shift();
        this._makeApiRequest(retryObject.item, retryObject.callback);
      }
    }.bind(this), this.options.retryInterval);
  }
};

/*
 * _dequeuePendingRequest - Removes the item from the pending request queue, this queue is used to
 *   enable to functionality of providing a callback that clients can pass to `wait` to be notified
 *   when the pending request queue has been emptied. This must be called when the API finishes
 *   processing this item. If a `wait` callback is configured, it is called by this function.
 *
 * @param item - the item previously added to the pending request queue
 */
Queue.prototype._dequeuePendingRequest = function (item) {
  var idx = this.pendingRequests.indexOf(item);
  if (idx !== -1) {
    this.pendingRequests.splice(idx, 1);
    this._maybeCallWait();
  }
};
Queue.prototype._maybeLog = function (data, originalError) {
  if (this.logger && this.options.verbose) {
    var message = originalError;
    message = message || _.get(data, 'body.trace.exception.message');
    message = message || _.get(data, 'body.trace_chain.0.exception.message');
    if (message) {
      this.logger.error(message);
      return;
    }
    message = _.get(data, 'body.message.body');
    if (message) {
      this.logger.log(message);
    }
  }
};
Queue.prototype._maybeCallWait = function () {
  if (_.isFunction(this.waitCallback) && this.pendingItems.length === 0 && this.pendingRequests.length === 0) {
    if (this.waitIntervalID) {
      this.waitIntervalID = clearInterval(this.waitIntervalID);
    }
    this.waitCallback();
    return true;
  }
  return false;
};

/**
 * Handles the API response for an item with a replay ID.
 * Based on the success or failure status of the response,
 * it either sends or discards the associated session replay.
 *
 * @param {string} replayId - The ID of the replay to handle
 * @param {Object} response - The API response
 * @returns {Promise<boolean>} A promise that resolves to true if replay was sent successfully,
 *                             false if replay was discarded or an error occurred
 * @private
 */
Queue.prototype._handleReplayResponse = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(replayId, response) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (this.replayMap) {
            _context.next = 3;
            break;
          }
          console.warn('Queue._handleReplayResponse: ReplayMap not available');
          return _context.abrupt("return", false);
        case 3:
          if (replayId) {
            _context.next = 6;
            break;
          }
          console.warn('Queue._handleReplayResponse: No replayId provided');
          return _context.abrupt("return", false);
        case 6:
          _context.prev = 6;
          if (!(response && response.err === 0)) {
            _context.next = 14;
            break;
          }
          _context.next = 10;
          return this.replayMap.send(replayId);
        case 10:
          result = _context.sent;
          return _context.abrupt("return", result);
        case 14:
          this.replayMap.discard(replayId);
          return _context.abrupt("return", false);
        case 16:
          _context.next = 22;
          break;
        case 18:
          _context.prev = 18;
          _context.t0 = _context["catch"](6);
          console.error('Error handling replay response:', _context.t0);
          return _context.abrupt("return", false);
        case 22:
        case "end":
          return _context.stop();
      }
    }, _callee, this, [[6, 18]]);
  }));
  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
module.exports = Queue;

/***/ }),

/***/ "./src/rateLimiter.js":
/*!****************************!*\
  !*** ./src/rateLimiter.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * RateLimiter - an object that encapsulates the logic for counting items sent to Rollbar
 *
 * @param options - the same options that are accepted by configureGlobal offered as a convenience
 */
function RateLimiter(options) {
  this.startTime = _.now();
  this.counter = 0;
  this.perMinCounter = 0;
  this.platform = null;
  this.platformOptions = {};
  this.configureGlobal(options);
}
RateLimiter.globalSettings = {
  startTime: _.now(),
  maxItems: undefined,
  itemsPerMinute: undefined
};

/*
 * configureGlobal - set the global rate limiter options
 *
 * @param options - Only the following values are recognized:
 *    startTime: a timestamp of the form returned by (new Date()).getTime()
 *    maxItems: the maximum items
 *    itemsPerMinute: the max number of items to send in a given minute
 */
RateLimiter.prototype.configureGlobal = function (options) {
  if (options.startTime !== undefined) {
    RateLimiter.globalSettings.startTime = options.startTime;
  }
  if (options.maxItems !== undefined) {
    RateLimiter.globalSettings.maxItems = options.maxItems;
  }
  if (options.itemsPerMinute !== undefined) {
    RateLimiter.globalSettings.itemsPerMinute = options.itemsPerMinute;
  }
};

/*
 * shouldSend - determine if we should send a given item based on rate limit settings
 *
 * @param item - the item we are about to send
 * @returns An object with the following structure:
 *  error: (Error|null)
 *  shouldSend: bool
 *  payload: (Object|null)
 *  If shouldSend is false, the item passed as a parameter should not be sent to Rollbar, and
 *  exactly one of error or payload will be non-null. If error is non-null, the returned Error will
 *  describe the situation, but it means that we were already over a rate limit (either globally or
 *  per minute) when this item was checked. If error is null, and therefore payload is non-null, it
 *  means this item put us over the global rate limit and the payload should be sent to Rollbar in
 *  place of the passed in item.
 */
RateLimiter.prototype.shouldSend = function (item, now) {
  now = now || _.now();
  var elapsedTime = now - this.startTime;
  if (elapsedTime < 0 || elapsedTime >= 60000) {
    this.startTime = now;
    this.perMinCounter = 0;
  }
  var globalRateLimit = RateLimiter.globalSettings.maxItems;
  var globalRateLimitPerMin = RateLimiter.globalSettings.itemsPerMinute;
  if (checkRate(item, globalRateLimit, this.counter)) {
    return shouldSendValue(this.platform, this.platformOptions, globalRateLimit + ' max items reached', false);
  } else if (checkRate(item, globalRateLimitPerMin, this.perMinCounter)) {
    return shouldSendValue(this.platform, this.platformOptions, globalRateLimitPerMin + ' items per minute reached', false);
  }
  this.counter++;
  this.perMinCounter++;
  var shouldSend = !checkRate(item, globalRateLimit, this.counter);
  var perMinute = shouldSend;
  shouldSend = shouldSend && !checkRate(item, globalRateLimitPerMin, this.perMinCounter);
  return shouldSendValue(this.platform, this.platformOptions, null, shouldSend, globalRateLimit, globalRateLimitPerMin, perMinute);
};
RateLimiter.prototype.setPlatformOptions = function (platform, options) {
  this.platform = platform;
  this.platformOptions = options;
};

/* Helpers */

function checkRate(item, limit, counter) {
  return !item.ignoreRateLimit && limit >= 1 && counter > limit;
}
function shouldSendValue(platform, options, error, shouldSend, globalRateLimit, limitPerMin, perMinute) {
  var payload = null;
  if (error) {
    error = new Error(error);
  }
  if (!error && !shouldSend) {
    payload = rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute);
  }
  return {
    error: error,
    shouldSend: shouldSend,
    payload: payload
  };
}
function rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute) {
  var environment = options.environment || options.payload && options.payload.environment;
  var msg;
  if (perMinute) {
    msg = 'item per minute limit reached, ignoring errors until timeout';
  } else {
    msg = 'maxItems has been hit, ignoring errors until reset.';
  }
  var item = {
    body: {
      message: {
        body: msg,
        extra: {
          maxItems: globalRateLimit,
          itemsPerMinute: limitPerMin
        }
      }
    },
    language: 'javascript',
    environment: environment,
    notifier: {
      version: options.notifier && options.notifier.version || options.version
    }
  };
  if (platform === 'browser') {
    item.platform = 'browser';
    item.framework = 'browser-js';
    item.notifier.name = 'rollbar-browser-js';
  } else if (platform === 'server') {
    item.framework = options.framework || 'node-js';
    item.notifier.name = options.notifier.name;
  } else if (platform === 'react-native') {
    item.framework = options.framework || 'react-native';
    item.notifier.name = options.notifier.name;
  }
  return item;
}
module.exports = RateLimiter;

/***/ }),

/***/ "./src/rollbar.js":
/*!************************!*\
  !*** ./src/rollbar.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var RateLimiter = __webpack_require__(/*! ./rateLimiter */ "./src/rateLimiter.js");
var Queue = __webpack_require__(/*! ./queue */ "./src/queue.js");
var Notifier = __webpack_require__(/*! ./notifier */ "./src/notifier.js");
var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * Rollbar - the interface to Rollbar
 *
 * @param options
 * @param api
 * @param logger
 */
function Rollbar(options, api, logger, telemeter, tracing, replayMap, platform) {
  this.options = _.merge(options);
  this.logger = logger;
  Rollbar.rateLimiter.configureGlobal(this.options);
  Rollbar.rateLimiter.setPlatformOptions(platform, this.options);
  this.api = api;
  this.queue = new Queue(Rollbar.rateLimiter, api, logger, this.options, replayMap);
  this.tracing = tracing;

  // Legacy OpenTracing support
  // This must happen before the Notifier is created
  var tracer = this.options.tracer || null;
  if (validateTracer(tracer)) {
    this.tracer = tracer;
    // set to a string for api response serialization
    this.options.tracer = 'opentracing-tracer-enabled';
    this.options._configuredOptions.tracer = 'opentracing-tracer-enabled';
  } else {
    this.tracer = null;
  }
  this.notifier = new Notifier(this.queue, this.options);
  this.telemeter = telemeter;
  setStackTraceLimit(options);
  this.lastError = null;
  this.lastErrorHash = 'none';
}
var defaultOptions = {
  maxItems: 0,
  itemsPerMinute: 60
};
Rollbar.rateLimiter = new RateLimiter(defaultOptions);
Rollbar.prototype.global = function (options) {
  Rollbar.rateLimiter.configureGlobal(options);
  return this;
};
Rollbar.prototype.configure = function (options, payloadData) {
  var oldOptions = this.options;
  var payload = {};
  if (payloadData) {
    payload = {
      payload: payloadData
    };
  }
  this.options = _.merge(oldOptions, options, payload);

  // Legacy OpenTracing support
  // This must happen before the Notifier is configured
  var tracer = this.options.tracer || null;
  if (validateTracer(tracer)) {
    this.tracer = tracer;
    // set to a string for api response serialization
    this.options.tracer = 'opentracing-tracer-enabled';
    this.options._configuredOptions.tracer = 'opentracing-tracer-enabled';
  } else {
    this.tracer = null;
  }
  this.notifier && this.notifier.configure(this.options);
  this.telemeter && this.telemeter.configure(this.options);
  setStackTraceLimit(options);
  this.global(this.options);
  if (validateTracer(options.tracer)) {
    this.tracer = options.tracer;
  }
  return this;
};
Rollbar.prototype.log = function (item) {
  var level = this._defaultLogLevel();
  return this._log(level, item);
};
Rollbar.prototype.debug = function (item) {
  this._log('debug', item);
};
Rollbar.prototype.info = function (item) {
  this._log('info', item);
};
Rollbar.prototype.warn = function (item) {
  this._log('warning', item);
};
Rollbar.prototype.warning = function (item) {
  this._log('warning', item);
};
Rollbar.prototype.error = function (item) {
  this._log('error', item);
};
Rollbar.prototype.critical = function (item) {
  this._log('critical', item);
};
Rollbar.prototype.wait = function (callback) {
  this.queue.wait(callback);
};
Rollbar.prototype.captureEvent = function (type, metadata, level) {
  return this.telemeter && this.telemeter.captureEvent(type, metadata, level);
};
Rollbar.prototype.captureDomContentLoaded = function (ts) {
  return this.telemeter && this.telemeter.captureDomContentLoaded(ts);
};
Rollbar.prototype.captureLoad = function (ts) {
  return this.telemeter && this.telemeter.captureLoad(ts);
};
Rollbar.prototype.buildJsonPayload = function (item) {
  return this.api.buildJsonPayload(item);
};
Rollbar.prototype.sendJsonPayload = function (jsonPayload) {
  this.api.postJsonPayload(jsonPayload);
};

/* Internal */

Rollbar.prototype._log = function (defaultLevel, item) {
  var callback;
  if (item.callback) {
    callback = item.callback;
    delete item.callback;
  }
  if (this.options.ignoreDuplicateErrors && this._sameAsLastError(item)) {
    if (callback) {
      var error = new Error('ignored identical item');
      error.item = item;
      callback(error);
    }
    return;
  }
  try {
    this._addTracingAttributes(item);

    // Legacy OpenTracing support
    this._addTracingInfo(item);
    item.level = item.level || defaultLevel;
    var telemeter = this.telemeter;
    if (telemeter) {
      telemeter._captureRollbarItem(item);
      item.telemetryEvents = telemeter.copyEvents() || [];
      if (telemeter.telemetrySpan) {
        telemeter.telemetrySpan.end();
        telemeter.telemetrySpan = telemeter.tracing.startSpan('rollbar-telemetry', {});
      }
    }
    this.notifier.log(item, callback);
  } catch (e) {
    if (callback) {
      callback(e);
    }
    this.logger.error(e);
  }
};
Rollbar.prototype._addTracingAttributes = function (item) {
  var _this$tracing;
  var span = (_this$tracing = this.tracing) === null || _this$tracing === void 0 ? void 0 : _this$tracing.getSpan();
  if (!span) {
    return;
  }
  var attributes = [{
    key: 'session_id',
    value: this.tracing.sessionId
  }, {
    key: 'span_id',
    value: span.spanId
  }, {
    key: 'trace_id',
    value: span.traceId
  }];
  _.addItemAttributes(item, attributes);
  span.addEvent('rollbar.occurrence', [{
    key: 'rollbar.occurrence.uuid',
    value: item.uuid
  }]);
};
Rollbar.prototype._defaultLogLevel = function () {
  return this.options.logLevel || 'debug';
};
Rollbar.prototype._sameAsLastError = function (item) {
  if (!item._isUncaught) {
    return false;
  }
  var itemHash = generateItemHash(item);
  if (this.lastErrorHash === itemHash) {
    return true;
  }
  this.lastError = item.err;
  this.lastErrorHash = itemHash;
  return false;
};
Rollbar.prototype._addTracingInfo = function (item) {
  // Tracer validation occurs in the constructor
  // or in the Rollbar.prototype.configure methods
  if (this.tracer) {
    // add rollbar occurrence uuid to span
    var span = this.tracer.scope().active();
    if (validateSpan(span)) {
      span.setTag('rollbar.error_uuid', item.uuid);
      span.setTag('rollbar.has_error', true);
      span.setTag('error', true);
      span.setTag('rollbar.item_url', "https://rollbar.com/item/uuid/?uuid=".concat(item.uuid));
      span.setTag('rollbar.occurrence_url', "https://rollbar.com/occurrence/uuid/?uuid=".concat(item.uuid));

      // add span ID & trace ID to occurrence
      var opentracingSpanId = span.context().toSpanId();
      var opentracingTraceId = span.context().toTraceId();
      if (item.custom) {
        item.custom.opentracing_span_id = opentracingSpanId;
        item.custom.opentracing_trace_id = opentracingTraceId;
      } else {
        item.custom = {
          opentracing_span_id: opentracingSpanId,
          opentracing_trace_id: opentracingTraceId
        };
      }
    }
  }
};
function generateItemHash(item) {
  var message = item.message || '';
  var stack = (item.err || {}).stack || String(item.err);
  return message + '::' + stack;
}

// Node.js, Chrome, Safari, and some other browsers support this property
// which globally sets the number of stack frames returned in an Error object.
// If a browser can't use it, no harm done.
function setStackTraceLimit(options) {
  if (options.stackTraceLimit) {
    Error.stackTraceLimit = options.stackTraceLimit;
  }
}

/**
 * Validate the Tracer object provided to the Client
 * is valid for our Opentracing use case.
 * @param {opentracer.Tracer} tracer
 */
function validateTracer(tracer) {
  if (!tracer) {
    return false;
  }
  if (!tracer.scope || typeof tracer.scope !== 'function') {
    return false;
  }
  var scope = tracer.scope();
  if (!scope || !scope.active || typeof scope.active !== 'function') {
    return false;
  }
  return true;
}

/**
 * Validate the Span object provided
 * @param {opentracer.Span} span
 */
function validateSpan(span) {
  if (!span || !span.context || typeof span.context !== 'function') {
    return false;
  }
  var spanContext = span.context();
  if (!spanContext || !spanContext.toSpanId || !spanContext.toTraceId || typeof spanContext.toSpanId !== 'function' || typeof spanContext.toTraceId !== 'function') {
    return false;
  }
  return true;
}
module.exports = Rollbar;

/***/ }),

/***/ "./src/scrub.js":
/*!**********************!*\
  !*** ./src/scrub.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var traverse = __webpack_require__(/*! ./utility/traverse */ "./src/utility/traverse.js");
function scrub(data, scrubFields, scrubPaths) {
  scrubFields = scrubFields || [];
  if (scrubPaths) {
    for (var i = 0; i < scrubPaths.length; ++i) {
      scrubPath(data, scrubPaths[i]);
    }
  }
  var paramRes = _getScrubFieldRegexs(scrubFields);
  var queryRes = _getScrubQueryParamRegexs(scrubFields);
  function redactQueryParam(dummy0, paramPart) {
    return paramPart + _.redact();
  }
  function paramScrubber(v) {
    var i;
    if (_.isType(v, 'string')) {
      for (i = 0; i < queryRes.length; ++i) {
        v = v.replace(queryRes[i], redactQueryParam);
      }
    }
    return v;
  }
  function valScrubber(k, v) {
    var i;
    for (i = 0; i < paramRes.length; ++i) {
      if (paramRes[i].test(k)) {
        v = _.redact();
        break;
      }
    }
    return v;
  }
  function scrubber(k, v, seen) {
    var tmpV = valScrubber(k, v);
    if (tmpV === v) {
      if (_.isType(v, 'object') || _.isType(v, 'array')) {
        return traverse(v, scrubber, seen);
      }
      return paramScrubber(tmpV);
    } else {
      return tmpV;
    }
  }
  return traverse(data, scrubber);
}
function scrubPath(obj, path) {
  var keys = path.split('.');
  var last = keys.length - 1;
  try {
    for (var i = 0; i <= last; ++i) {
      if (i < last) {
        obj = obj[keys[i]];
      } else {
        obj[keys[i]] = _.redact();
      }
    }
  } catch (e) {
    // Missing key is OK;
  }
}
function _getScrubFieldRegexs(scrubFields) {
  var ret = [];
  var pat;
  for (var i = 0; i < scrubFields.length; ++i) {
    pat = '^\\[?(%5[bB])?' + scrubFields[i] + '\\[?(%5[bB])?\\]?(%5[dD])?$';
    ret.push(new RegExp(pat, 'i'));
  }
  return ret;
}
function _getScrubQueryParamRegexs(scrubFields) {
  var ret = [];
  var pat;
  for (var i = 0; i < scrubFields.length; ++i) {
    pat = '\\[?(%5[bB])?' + scrubFields[i] + '\\[?(%5[bB])?\\]?(%5[dD])?';
    ret.push(new RegExp('(' + pat + '=)([^&\\n]+)', 'igm'));
  }
  return ret;
}
module.exports = scrub;

/***/ }),

/***/ "./src/telemetry.js":
/*!**************************!*\
  !*** ./src/telemetry.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var MAX_EVENTS = 100;

// Temporary workaround while solving commonjs -> esm issues in Node 18 - 20.
function fromMillis(millis) {
  return [Math.trunc(millis / 1000), Math.round(millis % 1000 * 1e6)];
}
function Telemeter(options, tracing) {
  var _this$tracing;
  this.queue = [];
  this.options = _.merge(options);
  var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
  this.maxQueueSize = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
  this.tracing = tracing;
  this.telemetrySpan = (_this$tracing = this.tracing) === null || _this$tracing === void 0 ? void 0 : _this$tracing.startSpan('rollbar-telemetry', {});
}
Telemeter.prototype.configure = function (options) {
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
  var newMaxEvents = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
  var deleteCount = 0;
  if (this.queue.length > newMaxEvents) {
    deleteCount = this.queue.length - newMaxEvents;
  }
  this.maxQueueSize = newMaxEvents;
  this.queue.splice(0, deleteCount);
};
Telemeter.prototype.copyEvents = function () {
  var events = Array.prototype.slice.call(this.queue, 0);
  if (_.isFunction(this.options.filterTelemetry)) {
    try {
      var i = events.length;
      while (i--) {
        if (this.options.filterTelemetry(events[i])) {
          events.splice(i, 1);
        }
      }
    } catch (e) {
      this.options.filterTelemetry = null;
    }
  }
  return events;
};
Telemeter.prototype.capture = function (type, metadata, level, rollbarUUID, timestamp) {
  var e = {
    level: getLevel(type, level),
    type: type,
    timestamp_ms: timestamp || _.now(),
    body: metadata,
    source: 'client'
  };
  if (rollbarUUID) {
    e.uuid = rollbarUUID;
  }
  try {
    if (_.isFunction(this.options.filterTelemetry) && this.options.filterTelemetry(e)) {
      return false;
    }
  } catch (exc) {
    this.options.filterTelemetry = null;
  }
  this.push(e);
  return e;
};
Telemeter.prototype.captureEvent = function (type, metadata, level, rollbarUUID) {
  return this.capture(type, metadata, level, rollbarUUID);
};
Telemeter.prototype.captureError = function (err, level, rollbarUUID, timestamp) {
  var _this$telemetrySpan;
  var message = err.message || String(err);
  var metadata = {
    message: message
  };
  if (err.stack) {
    metadata.stack = err.stack;
  }
  (_this$telemetrySpan = this.telemetrySpan) === null || _this$telemetrySpan === void 0 || _this$telemetrySpan.addEvent('rollbar-occurrence-event', {
    message: message,
    level: level,
    type: 'error',
    uuid: rollbarUUID,
    'occurrence.type': 'error',
    // deprecated
    'occurrence.uuid': rollbarUUID // deprecated
  }, fromMillis(timestamp));
  return this.capture('error', metadata, level, rollbarUUID, timestamp);
};
Telemeter.prototype.captureLog = function (message, level, rollbarUUID, timestamp) {
  // If the uuid is present, this is a message occurrence.
  if (rollbarUUID) {
    var _this$telemetrySpan2;
    (_this$telemetrySpan2 = this.telemetrySpan) === null || _this$telemetrySpan2 === void 0 || _this$telemetrySpan2.addEvent('rollbar-occurrence-event', {
      message: message,
      level: level,
      type: 'message',
      uuid: rollbarUUID,
      'occurrence.type': 'message',
      // deprecated
      'occurrence.uuid': rollbarUUID // deprecated
    }, fromMillis(timestamp));
  } else {
    var _this$telemetrySpan3;
    (_this$telemetrySpan3 = this.telemetrySpan) === null || _this$telemetrySpan3 === void 0 || _this$telemetrySpan3.addEvent('log-event', {
      message: message,
      level: level
    }, fromMillis(timestamp));
  }
  return this.capture('log', {
    message: message
  }, level, rollbarUUID, timestamp);
};
Telemeter.prototype.captureNetwork = function (metadata, subtype, rollbarUUID, requestData) {
  subtype = subtype || 'xhr';
  metadata.subtype = metadata.subtype || subtype;
  if (requestData) {
    metadata.request = requestData;
  }
  var level = this.levelFromStatus(metadata.status_code);
  return this.capture('network', metadata, level, rollbarUUID);
};
Telemeter.prototype.levelFromStatus = function (statusCode) {
  if (statusCode >= 200 && statusCode < 400) {
    return 'info';
  }
  if (statusCode === 0 || statusCode >= 400) {
    return 'error';
  }
  return 'info';
};
Telemeter.prototype.captureDom = function (subtype, element, value, checked, rollbarUUID) {
  var metadata = {
    subtype: subtype,
    element: element
  };
  if (value !== undefined) {
    metadata.value = value;
  }
  if (checked !== undefined) {
    metadata.checked = checked;
  }
  return this.capture('dom', metadata, 'info', rollbarUUID);
};
Telemeter.prototype.captureNavigation = function (from, to, rollbarUUID, timestamp) {
  var _this$telemetrySpan4;
  (_this$telemetrySpan4 = this.telemetrySpan) === null || _this$telemetrySpan4 === void 0 || _this$telemetrySpan4.addEvent('session-navigation-event', {
    'previous.url.full': from,
    'url.full': to
  }, fromMillis(timestamp));
  return this.capture('navigation', {
    from: from,
    to: to
  }, 'info', rollbarUUID, timestamp);
};
Telemeter.prototype.captureDomContentLoaded = function (ts) {
  return this.capture('navigation', {
    subtype: 'DOMContentLoaded'
  }, 'info', undefined, ts && ts.getTime());
  /**
   * If we decide to make this a dom event instead, then use the line below:
  return this.capture('dom', {subtype: 'DOMContentLoaded'}, 'info', undefined, ts && ts.getTime());
  */
};
Telemeter.prototype.captureLoad = function (ts) {
  return this.capture('navigation', {
    subtype: 'load'
  }, 'info', undefined, ts && ts.getTime());
  /**
   * If we decide to make this a dom event instead, then use the line below:
  return this.capture('dom', {subtype: 'load'}, 'info', undefined, ts && ts.getTime());
  */
};
Telemeter.prototype.captureConnectivityChange = function (type, rollbarUUID) {
  return this.captureNetwork({
    change: type
  }, 'connectivity', rollbarUUID);
};

// Only intended to be used internally by the notifier
Telemeter.prototype._captureRollbarItem = function (item) {
  if (!this.options.includeItemsInTelemetry) {
    return;
  }
  if (item.err) {
    return this.captureError(item.err, item.level, item.uuid, item.timestamp);
  }
  if (item.message) {
    return this.captureLog(item.message, item.level, item.uuid, item.timestamp);
  }
  if (item.custom) {
    return this.capture('log', item.custom, item.level, item.uuid, item.timestamp);
  }
};
Telemeter.prototype.push = function (e) {
  this.queue.push(e);
  if (this.queue.length > this.maxQueueSize) {
    this.queue.shift();
  }
};
function getLevel(type, level) {
  if (level) {
    return level;
  }
  var defaultLevel = {
    error: 'error',
    manual: 'info'
  };
  return defaultLevel[type] || 'info';
}
module.exports = Telemeter;

/***/ }),

/***/ "./src/tracing/context.js":
/*!********************************!*\
  !*** ./src/tracing/context.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Context: () => (/* binding */ Context),
/* harmony export */   ROOT_CONTEXT: () => (/* binding */ ROOT_CONTEXT)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Context = /*#__PURE__*/function () {
  function Context(parentContext) {
    _classCallCheck(this, Context);
    this._currentContext = parentContext ? new Map(parentContext) : new Map();
  }
  return _createClass(Context, [{
    key: "getValue",
    value: function getValue(key) {
      return this._currentContext.get(key);
    }
  }, {
    key: "setValue",
    value: function setValue(key, value) {
      var context = new Context(this._currentContext);
      context._currentContext.set(key, value);
      return context;
    }
  }, {
    key: "deleteValue",
    value: function deleteValue(key) {
      var context = new Context(self._currentContext);
      context._currentContext["delete"](key);
      return context;
    }
  }]);
}();
var ROOT_CONTEXT = new Context();

/***/ }),

/***/ "./src/tracing/contextManager.js":
/*!***************************************!*\
  !*** ./src/tracing/contextManager.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContextManager: () => (/* binding */ ContextManager),
/* harmony export */   createContextKey: () => (/* binding */ createContextKey)
/* harmony export */ });
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ "./src/tracing/context.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var ContextManager = /*#__PURE__*/function () {
  function ContextManager() {
    _classCallCheck(this, ContextManager);
    this.currentContext = _context_js__WEBPACK_IMPORTED_MODULE_0__.ROOT_CONTEXT;
  }
  return _createClass(ContextManager, [{
    key: "active",
    value: function active() {
      return this.currentContext;
    }
  }, {
    key: "enterContext",
    value: function enterContext(context) {
      var previousContext = this.currentContext;
      this.currentContext = context || _context_js__WEBPACK_IMPORTED_MODULE_0__.ROOT_CONTEXT;
      return previousContext;
    }
  }, {
    key: "exitContext",
    value: function exitContext(context) {
      this.currentContext = context;
      return this.currentContext;
    }
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var previousContext = this.enterContext(context);
      try {
        for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          args[_key - 3] = arguments[_key];
        }
        return fn.call.apply(fn, [thisArg].concat(args));
      } finally {
        this.exitContext(previousContext);
      }
    }
  }]);
}();
function createContextKey(key) {
  // Use Symbol for OpenTelemetry compatibility.
  return Symbol["for"](key);
}

/***/ }),

/***/ "./src/tracing/defaults.js":
/*!*********************************!*\
  !*** ./src/tracing/defaults.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Default tracing options
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  enabled: false,
  endpoint: 'api.rollbar.com/api/1/session/'
});

/***/ }),

/***/ "./src/tracing/exporter.js":
/*!*********************************!*\
  !*** ./src/tracing/exporter.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpanExporter: () => (/* binding */ SpanExporter),
/* harmony export */   spanExportQueue: () => (/* binding */ spanExportQueue)
/* harmony export */ });
/* harmony import */ var _hrtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hrtime */ "./src/tracing/hrtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


/**
 * SpanExporter is responsible for exporting ReadableSpan objects
 * and transforming them into the OTLP-compatible format.
 */
var SpanExporter = /*#__PURE__*/function () {
  function SpanExporter() {
    _classCallCheck(this, SpanExporter);
  }
  return _createClass(SpanExporter, [{
    key: "export",
    value:
    /**
     * Export spans to the span export queue
     *
     * @param {Array} spans - Array of ReadableSpan objects to export
     * @param {Function} _resultCallback - Optional callback (not used)
     */
    function _export(spans, _resultCallback) {
      console.log(spans); // console exporter, TODO: make optional
      spanExportQueue.push.apply(spanExportQueue, _toConsumableArray(spans));
    }

    /**
     * Transforms an array of ReadableSpan objects into the OTLP format payload
     * compatible with the Rollbar API. This follows the OpenTelemetry protocol
     * specification for traces.
     *
     * @returns {Object} OTLP format payload for API transmission
     */
  }, {
    key: "toPayload",
    value: function toPayload() {
      var _this = this;
      var spans = spanExportQueue.slice();
      spanExportQueue.length = 0;
      if (!spans || !spans.length) {
        return {
          resourceSpans: []
        };
      }
      var resource = spans[0] && spans[0].resource || {};
      var scopeMap = new Map();
      var _iterator = _createForOfIteratorHelper(spans),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var span = _step.value;
          var scopeKey = span.instrumentationScope ? "".concat(span.instrumentationScope.name, ":").concat(span.instrumentationScope.version) : 'default:1.0.0';
          if (!scopeMap.has(scopeKey)) {
            scopeMap.set(scopeKey, {
              scope: span.instrumentationScope || {
                name: 'default',
                version: '1.0.0',
                attributes: []
              },
              spans: []
            });
          }
          scopeMap.get(scopeKey).spans.push(this._transformSpan(span));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        resourceSpans: [{
          resource: this._transformResource(resource),
          scopeSpans: Array.from(scopeMap.values()).map(function (scopeData) {
            return {
              scope: _this._transformInstrumentationScope(scopeData.scope),
              spans: scopeData.spans
            };
          })
        }]
      };
    }

    /**
     * Transforms a ReadableSpan into the OTLP Span format
     *
     * @private
     * @param {Object} span - ReadableSpan object to transform
     * @returns {Object} OTLP Span format
     */
  }, {
    key: "_transformSpan",
    value: function _transformSpan(span) {
      var _this2 = this;
      var transformAttributes = function transformAttributes(attributes) {
        return Object.entries(attributes || {}).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return {
            key: key,
            value: _this2._transformAnyValue(value)
          };
        });
      };
      var transformEvents = function transformEvents(events) {
        return (events || []).map(function (event) {
          return {
            timeUnixNano: _hrtime__WEBPACK_IMPORTED_MODULE_0__["default"].toNanos(event.time),
            name: event.name,
            attributes: transformAttributes(event.attributes)
          };
        });
      };
      return {
        traceId: span.spanContext.traceId,
        spanId: span.spanContext.spanId,
        parentSpanId: span.parentSpanId || '',
        name: span.name,
        kind: span.kind || 1,
        // INTERNAL by default
        startTimeUnixNano: _hrtime__WEBPACK_IMPORTED_MODULE_0__["default"].toNanos(span.startTime),
        endTimeUnixNano: _hrtime__WEBPACK_IMPORTED_MODULE_0__["default"].toNanos(span.endTime),
        attributes: transformAttributes(span.attributes),
        events: transformEvents(span.events)
      };
    }

    /**
     * Transforms a resource object into OTLP Resource format
     *
     * @private
     * @param {Object} resource - Resource information
     * @returns {Object} OTLP Resource format
     */
  }, {
    key: "_transformResource",
    value: function _transformResource(resource) {
      var _this3 = this;
      var attributes = resource.attributes || {};
      var keyValues = Object.entries(attributes).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];
        return {
          key: key,
          value: _this3._transformAnyValue(value)
        };
      });
      return {
        attributes: keyValues
      };
    }

    /**
     * Transforms an instrumentation scope into OTLP InstrumentationScope format
     *
     * @private
     * @param {Object} scope - Instrumentation scope information
     * @returns {Object} OTLP InstrumentationScope format
     */
  }, {
    key: "_transformInstrumentationScope",
    value: function _transformInstrumentationScope(scope) {
      var _this4 = this;
      return {
        name: scope.name || '',
        version: scope.version || '',
        attributes: (scope.attributes || []).map(function (attr) {
          return {
            key: attr.key,
            value: _this4._transformAnyValue(attr.value)
          };
        })
      };
    }

    /**
     * Transforms a JavaScript value into an OTLP AnyValue
     *
     * @private
     * @param {any} value - Value to transform
     * @returns {Object} OTLP AnyValue format
     */
  }, {
    key: "_transformAnyValue",
    value: function _transformAnyValue(value) {
      var _this5 = this;
      if (value === null || value === undefined) {
        return {
          stringValue: ''
        };
      }
      var type = _typeof(value);
      if (type === 'string') {
        return {
          stringValue: value
        };
      } else if (type === 'number') {
        if (Number.isInteger(value)) {
          return {
            intValue: value.toString()
          };
        } else {
          return {
            doubleValue: value
          };
        }
      } else if (type === 'boolean') {
        return {
          boolValue: value
        };
      } else if (Array.isArray(value)) {
        return {
          arrayValue: {
            values: value.map(function (v) {
              return _this5._transformAnyValue(v);
            })
          }
        };
      } else if (type === 'object') {
        return {
          kvlistValue: {
            values: Object.entries(value).map(function (_ref5) {
              var _ref6 = _slicedToArray(_ref5, 2),
                k = _ref6[0],
                v = _ref6[1];
              return {
                key: k,
                value: _this5._transformAnyValue(v)
              };
            })
          }
        };
      }
      return {
        stringValue: String(value)
      };
    }
  }]);
}();
var spanExportQueue = [];

/***/ }),

/***/ "./src/tracing/hrtime.js":
/*!*******************************!*\
  !*** ./src/tracing/hrtime.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module hrtime
 *
 * @description Methods for handling OpenTelemetry hrtime.
 */

/**
 * Convert a duration in milliseconds to an OpenTelemetry hrtime tuple.
 *
 * @param {number} millis - The duration in milliseconds.
 * @returns {[number, number]} An array where the first element is seconds
 *   and the second is nanoseconds.
 */
function fromMillis(millis) {
  return [Math.trunc(millis / 1000), Math.round(millis % 1000 * 1e6)];
}

/**
 * Convert an OpenTelemetry hrtime tuple back to a duration in milliseconds.
 *
 * @param {[number, number]} hrtime - The hrtime tuple [seconds, nanoseconds].
 * @returns {number} The total duration in milliseconds.
 */
function toMillis(hrtime) {
  return hrtime[0] * 1e3 + Math.round(hrtime[1] / 1e6);
}

/**
 * Convert an OpenTelemetry hrtime tuple back to a duration in nanoseconds.
 *
 * @param {[number, number]} hrtime - The hrtime tuple [seconds, nanoseconds].
 * @returns {number} The total duration in nanoseconds.
 */
function toNanos(hrtime) {
  return hrtime[0] * 1e9 + hrtime[1];
}

/**
 * Adds two OpenTelemetry hrtime tuples.
 *
 * @param {[number, number]} a - The first hrtime tuple [s, ns].
 * @param {[number, number]} b - The second hrtime tuple [s, ns].
 * @returns {[number, number]} Summed hrtime tuple, normalized.
 *
 */
function add(a, b) {
  return [a[0] + b[0] + Math.trunc((a[1] + b[1]) / 1e9), (a[1] + b[1]) % 1e9];
}

/**
 * Get the current high-resolution time as an OpenTelemetry hrtime tuple.
 *
 * Uses the Performance API (timeOrigin + now()).
 *
 * @returns {[number, number]} The current hrtime tuple [s, ns].
 */
function now() {
  return add(fromMillis(performance.timeOrigin), fromMillis(performance.now()));
}

/**
 * Check if a value is a valid OpenTelemetry hrtime tuple.
 *
 * An hrtime tuple is an Array of exactly two numbers:
 *   [seconds, nanoseconds]
 *
 * @param {*} value  anything to test
 * @returns {boolean} true if `value` is a [number, number] array of length 2
 *
 * @example
 * isHrTime([ 1, 500 ]);         // true
 * isHrTime([ 0, 1e9 ]);         // true
 * isHrTime([ '1', 500 ]);       // false
 * isHrTime({ 0: 1, 1: 500 });   // false
 */
function isHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}

/**
 * Methods for handling hrtime. OpenTelemetry uses the [seconds, nanoseconds]
 * format for hrtime in the `ReadableSpan` interface.
 *
 * @example
 * import hrtime from '@tracing/hrtime.js';
 *
 * hrtime.fromMillis(1000);
 * hrtime.toMillis([0, 1000]);
 * hrtime.add([0, 0], [0, 1000]);
 * hrtime.now();
 * hrtime.isHrTime([0, 1000]);
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  fromMillis: fromMillis,
  toMillis: toMillis,
  toNanos: toNanos,
  add: add,
  now: now,
  isHrTime: isHrTime
});

/***/ }),

/***/ "./src/tracing/id.js":
/*!***************************!*\
  !*** ./src/tracing/id.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Generate a random hexadecimal ID of specified byte length
 *
 * @param {number} bytes - Number of bytes for the ID (default: 16)
 * @returns {string} - Hexadecimal string representation
 */
function gen() {
  var bytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var randomBytes = new Uint8Array(bytes);
  crypto.getRandomValues(randomBytes);
  var randHex = Array.from(randomBytes, function (_byte) {
    return _byte.toString(16).padStart(2, '0');
  }).join('');
  return randHex;
}

/**
 * Tracing id generation utils
 *
 * @example
 * import id from './id.js';
 *
 * const spanId = id.gen(8); // => "a1b2c3d4e5f6..."
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  gen: gen
});

/***/ }),

/***/ "./src/tracing/session.js":
/*!********************************!*\
  !*** ./src/tracing/session.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Session: () => (/* binding */ Session)
/* harmony export */ });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./src/tracing/id.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var SESSION_KEY = 'RollbarSession';
var Session = /*#__PURE__*/function () {
  function Session(tracing, options) {
    _classCallCheck(this, Session);
    this.options = options;
    this.tracing = tracing;
    this.window = tracing.window;
    this.session = null;
  }
  return _createClass(Session, [{
    key: "init",
    value: function init() {
      if (this.session) {
        return this;
      }
      return this.getSession() || this.createSession();
    }
  }, {
    key: "getSession",
    value: function getSession() {
      try {
        var serializedSession = this.window.sessionStorage.getItem(SESSION_KEY);
        if (!serializedSession) {
          return null;
        }
        this.session = JSON.parse(serializedSession);
      } catch (_unused) {
        return null;
      }
      return this;
    }
  }, {
    key: "createSession",
    value: function createSession() {
      this.session = {
        id: _id_js__WEBPACK_IMPORTED_MODULE_0__["default"].gen(),
        createdAt: Date.now()
      };
      return this.setSession(this.session);
    }
  }, {
    key: "setSession",
    value: function setSession(session) {
      var sessionString = JSON.stringify(session);
      try {
        this.window.sessionStorage.setItem(SESSION_KEY, sessionString);
      } catch (_unused2) {
        return null;
      }
      return this;
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/span.js":
/*!*****************************!*\
  !*** ./src/tracing/span.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Span: () => (/* binding */ Span)
/* harmony export */ });
/* harmony import */ var _hrtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hrtime.js */ "./src/tracing/hrtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Span = /*#__PURE__*/function () {
  function Span(options) {
    _classCallCheck(this, Span);
    this.initReadableSpan(options);
    this.spanProcessor = options.spanProcessor;
    this.spanProcessor.onStart(this, options.context);
    if (options.attributes) {
      this.setAttributes(options.attributes);
    }
    return this;
  }
  return _createClass(Span, [{
    key: "initReadableSpan",
    value: function initReadableSpan(options) {
      this.span = {
        name: options.name,
        kind: options.kind,
        spanContext: options.spanContext,
        parentSpanId: options.parentSpanId,
        startTime: options.startTime || _hrtime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now(),
        endTime: [0, 0],
        status: {
          code: 0,
          message: ''
        },
        attributes: {
          'session.id': options.session.id
        },
        links: [],
        events: [],
        duration: 0,
        ended: false,
        resource: options.resource,
        instrumentationScope: options.scope,
        droppedAttributesCount: 0,
        droppedEventsCount: 0,
        droppedLinksCount: 0
      };
    }
  }, {
    key: "spanContext",
    value: function spanContext() {
      return this.span.spanContext;
    }
  }, {
    key: "spanId",
    get: function get() {
      return this.span.spanContext.spanId;
    }
  }, {
    key: "traceId",
    get: function get() {
      return this.span.spanContext.traceId;
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(key, value) {
      if (value == null || this.ended) return this;
      if (key.length === 0) return this;
      this.span.attributes[key] = value;
      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          k = _Object$entries$_i[0],
          v = _Object$entries$_i[1];
        this.setAttribute(k, v);
      }
      return this;
    }
  }, {
    key: "addEvent",
    value: function addEvent(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var time = arguments.length > 2 ? arguments[2] : undefined;
      if (this.span.ended) return this;
      this.span.events.push({
        name: name,
        attributes: attributes,
        time: time || _hrtime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now(),
        droppedAttributesCount: 0
      });
      return this;
    }
  }, {
    key: "isRecording",
    value: function isRecording() {
      return this.span.ended === false;
    }
  }, {
    key: "end",
    value: function end(attributes, time) {
      if (attributes) this.setAttributes(attributes);
      this.span.endTime = time || _hrtime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now();
      this.span.ended = true;
      this.spanProcessor.onEnd(this);
    }
  }, {
    key: "export",
    value: function _export() {
      return this.span;
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/spanProcessor.js":
/*!**************************************!*\
  !*** ./src/tracing/spanProcessor.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpanProcessor: () => (/* binding */ SpanProcessor)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SpanProcessor = /*#__PURE__*/function () {
  function SpanProcessor(exporter) {
    _classCallCheck(this, SpanProcessor);
    this.exporter = exporter;
    this.pendingSpans = new Map();
  }
  return _createClass(SpanProcessor, [{
    key: "onStart",
    value: function onStart(span, _parentContext) {
      this.pendingSpans.set(span.span.spanContext.spanId, span);
    }
  }, {
    key: "onEnd",
    value: function onEnd(span) {
      this.exporter["export"]([span["export"]()]);
      this.pendingSpans["delete"](span.span.spanContext.spanId);
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/tracer.js":
/*!*******************************!*\
  !*** ./src/tracing/tracer.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tracer: () => (/* binding */ Tracer)
/* harmony export */ });
/* harmony import */ var _span_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./span.js */ "./src/tracing/span.js");
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id.js */ "./src/tracing/id.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var Tracer = /*#__PURE__*/function () {
  function Tracer(tracing, spanProcessor) {
    _classCallCheck(this, Tracer);
    this.spanProcessor = spanProcessor;
    this.tracing = tracing;
  }
  return _createClass(Tracer, [{
    key: "startSpan",
    value: function startSpan(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tracing.contextManager.active();
      var parentSpan = this.tracing.getSpan(context);
      var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
      var spanId = _id_js__WEBPACK_IMPORTED_MODULE_1__["default"].gen(8);
      var traceId;
      var traceFlags = 0;
      var traceState = null;
      var parentSpanId;
      if (parentSpanContext) {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        parentSpanId = parentSpanContext.spanId;
      } else {
        traceId = _id_js__WEBPACK_IMPORTED_MODULE_1__["default"].gen(16);
      }
      var kind = 0;
      var spanContext = {
        traceId: traceId,
        spanId: spanId,
        traceFlags: traceFlags,
        traceState: traceState
      };
      var span = new _span_js__WEBPACK_IMPORTED_MODULE_0__.Span({
        resource: this.tracing.resource,
        scope: this.tracing.scope,
        session: this.tracing.session.session,
        context: context,
        spanContext: spanContext,
        name: name,
        kind: kind,
        parentSpanId: parentSpanId,
        spanProcessor: this.spanProcessor
      });
      return span;
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/tracing.js":
/*!********************************!*\
  !*** ./src/tracing/tracing.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tracing)
/* harmony export */ });
/* harmony import */ var _contextManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contextManager.js */ "./src/tracing/contextManager.js");
/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./session.js */ "./src/tracing/session.js");
/* harmony import */ var _exporter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exporter.js */ "./src/tracing/exporter.js");
/* harmony import */ var _spanProcessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./spanProcessor.js */ "./src/tracing/spanProcessor.js");
/* harmony import */ var _tracer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tracer.js */ "./src/tracing/tracer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





var SPAN_KEY = (0,_contextManager_js__WEBPACK_IMPORTED_MODULE_0__.createContextKey)('Rollbar Context Key SPAN');
var Tracing = /*#__PURE__*/function () {
  function Tracing(gWindow, options) {
    _classCallCheck(this, Tracing);
    this.options = options;
    this.window = gWindow;
    this.session = new _session_js__WEBPACK_IMPORTED_MODULE_1__.Session(this, options);
    this.createTracer();
  }
  return _createClass(Tracing, [{
    key: "initSession",
    value: function initSession() {
      if (this.session) {
        this.session.init();
      }
    }
  }, {
    key: "sessionId",
    get: function get() {
      if (this.session) {
        return this.session.session.id;
      }
      return null;
    }
  }, {
    key: "resource",
    get: function get() {
      var _this$options$payload, _this$options$payload2;
      return {
        attributes: _objectSpread(_objectSpread({}, this.options.resource || {}), {}, {
          'rollbar.environment': (_this$options$payload = (_this$options$payload2 = this.options.payload) === null || _this$options$payload2 === void 0 ? void 0 : _this$options$payload2.environment) !== null && _this$options$payload !== void 0 ? _this$options$payload : this.options.environment
        })
      };
    }
  }, {
    key: "scope",
    get: function get() {
      return {
        name: 'rollbar-browser-js',
        version: this.options.version
      };
    }
  }, {
    key: "createTracer",
    value: function createTracer() {
      this.contextManager = new _contextManager_js__WEBPACK_IMPORTED_MODULE_0__.ContextManager();
      this.exporter = new _exporter_js__WEBPACK_IMPORTED_MODULE_2__.SpanExporter();
      this.spanProcessor = new _spanProcessor_js__WEBPACK_IMPORTED_MODULE_3__.SpanProcessor(this.exporter);
      this.tracer = new _tracer_js__WEBPACK_IMPORTED_MODULE_4__.Tracer(this, this.spanProcessor);
    }
  }, {
    key: "getTracer",
    value: function getTracer() {
      return this.tracer;
    }
  }, {
    key: "getSpan",
    value: function getSpan() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextManager.active();
      return context.getValue(SPAN_KEY);
    }
  }, {
    key: "setSpan",
    value: function setSpan() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextManager.active();
      var span = arguments.length > 1 ? arguments[1] : undefined;
      return context.setValue(SPAN_KEY, span);
    }
  }, {
    key: "startSpan",
    value: function startSpan(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.contextManager.active();
      return this.tracer.startSpan(name, options, context);
    }
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var _this$contextManager;
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      return (_this$contextManager = this.contextManager)["with"].apply(_this$contextManager, [context, fn, thisArg].concat(args));
    }
  }, {
    key: "withSpan",
    value: function withSpan(name, options, fn, thisArg) {
      var span = this.startSpan(name, options);
      return this["with"](this.setSpan(this.contextManager.active(), span), fn, thisArg, span);
    }
  }]);
}();


/***/ }),

/***/ "./src/transforms.js":
/*!***************************!*\
  !*** ./src/transforms.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
function itemToPayload(item, options, callback) {
  var data = item.data;
  if (item._isUncaught) {
    data._isUncaught = true;
  }
  if (item._originalArgs) {
    data._originalArgs = item._originalArgs;
  }
  callback(null, data);
}
function addPayloadOptions(item, options, callback) {
  var payloadOptions = options.payload || {};
  if (payloadOptions.body) {
    delete payloadOptions.body;
  }
  item.data = _.merge(item.data, payloadOptions);
  callback(null, item);
}
function addTelemetryData(item, options, callback) {
  if (item.telemetryEvents) {
    _.set(item, 'data.body.telemetry', item.telemetryEvents);
  }
  callback(null, item);
}
function addMessageWithError(item, options, callback) {
  if (!item.message) {
    callback(null, item);
    return;
  }
  var tracePath = 'data.body.trace_chain.0';
  var trace = _.get(item, tracePath);
  if (!trace) {
    tracePath = 'data.body.trace';
    trace = _.get(item, tracePath);
  }
  if (trace) {
    if (!(trace.exception && trace.exception.description)) {
      _.set(item, tracePath + '.exception.description', item.message);
      callback(null, item);
      return;
    }
    var extra = _.get(item, tracePath + '.extra') || {};
    var newExtra = _.merge(extra, {
      message: item.message
    });
    _.set(item, tracePath + '.extra', newExtra);
  }
  callback(null, item);
}
function userTransform(logger) {
  return function (item, options, callback) {
    var newItem = _.merge(item);
    var response = null;
    try {
      if (_.isFunction(options.transform)) {
        response = options.transform(newItem.data, item);
      }
    } catch (e) {
      options.transform = null;
      logger.error('Error while calling custom transform() function. Removing custom transform().', e);
      callback(null, item);
      return;
    }
    if (_.isPromise(response)) {
      response.then(function (promisedItem) {
        if (promisedItem) {
          newItem.data = promisedItem;
        }
        callback(null, newItem);
      }, function (error) {
        callback(error, item);
      });
    } else {
      callback(null, newItem);
    }
  };
}
function addConfigToPayload(item, options, callback) {
  if (!options.sendConfig) {
    return callback(null, item);
  }
  var configKey = '_rollbarConfig';
  var custom = _.get(item, 'data.custom') || {};
  custom[configKey] = options;
  item.data.custom = custom;
  callback(null, item);
}
function addFunctionOption(options, name) {
  if (_.isFunction(options[name])) {
    options[name] = options[name].toString();
  }
}
function addConfiguredOptions(item, options, callback) {
  var configuredOptions = options._configuredOptions;

  // These must be stringified or they'll get dropped during serialization.
  addFunctionOption(configuredOptions, 'transform');
  addFunctionOption(configuredOptions, 'checkIgnore');
  addFunctionOption(configuredOptions, 'onSendCallback');
  delete configuredOptions.accessToken;
  item.data.notifier.configured_options = configuredOptions;
  callback(null, item);
}
function addDiagnosticKeys(item, options, callback) {
  var diagnostic = _.merge(item.notifier.client.notifier.diagnostic, item.diagnostic);
  if (_.get(item, 'err._isAnonymous')) {
    diagnostic.is_anonymous = true;
  }
  if (item._isUncaught) {
    diagnostic.is_uncaught = item._isUncaught;
  }
  if (item.err) {
    try {
      diagnostic.raw_error = {
        message: item.err.message,
        name: item.err.name,
        constructor_name: item.err.constructor && item.err.constructor.name,
        filename: item.err.fileName,
        line: item.err.lineNumber,
        column: item.err.columnNumber,
        stack: item.err.stack
      };
    } catch (e) {
      diagnostic.raw_error = {
        failed: String(e)
      };
    }
  }
  item.data.notifier.diagnostic = _.merge(item.data.notifier.diagnostic, diagnostic);
  callback(null, item);
}
module.exports = {
  itemToPayload: itemToPayload,
  addPayloadOptions: addPayloadOptions,
  addTelemetryData: addTelemetryData,
  addMessageWithError: addMessageWithError,
  userTransform: userTransform,
  addConfigToPayload: addConfigToPayload,
  addConfiguredOptions: addConfiguredOptions,
  addDiagnosticKeys: addDiagnosticKeys
};

/***/ }),

/***/ "./src/truncation.js":
/*!***************************!*\
  !*** ./src/truncation.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var traverse = __webpack_require__(/*! ./utility/traverse */ "./src/utility/traverse.js");
function raw(payload, jsonBackup) {
  return [payload, _.stringify(payload, jsonBackup)];
}
function selectFrames(frames, range) {
  var len = frames.length;
  if (len > range * 2) {
    return frames.slice(0, range).concat(frames.slice(len - range));
  }
  return frames;
}
function truncateFrames(payload, jsonBackup, range) {
  range = typeof range === 'undefined' ? 30 : range;
  var body = payload.data.body;
  var frames;
  if (body.trace_chain) {
    var chain = body.trace_chain;
    for (var i = 0; i < chain.length; i++) {
      frames = chain[i].frames;
      frames = selectFrames(frames, range);
      chain[i].frames = frames;
    }
  } else if (body.trace) {
    frames = body.trace.frames;
    frames = selectFrames(frames, range);
    body.trace.frames = frames;
  }
  return [payload, _.stringify(payload, jsonBackup)];
}
function maybeTruncateValue(len, val) {
  if (!val) {
    return val;
  }
  if (val.length > len) {
    return val.slice(0, len - 3).concat('...');
  }
  return val;
}
function truncateStrings(len, payload, jsonBackup) {
  function truncator(k, v, seen) {
    switch (_.typeName(v)) {
      case 'string':
        return maybeTruncateValue(len, v);
      case 'object':
      case 'array':
        return traverse(v, truncator, seen);
      default:
        return v;
    }
  }
  payload = traverse(payload, truncator);
  return [payload, _.stringify(payload, jsonBackup)];
}
function truncateTraceData(traceData) {
  if (traceData.exception) {
    delete traceData.exception.description;
    traceData.exception.message = maybeTruncateValue(255, traceData.exception.message);
  }
  traceData.frames = selectFrames(traceData.frames, 1);
  return traceData;
}
function minBody(payload, jsonBackup) {
  var body = payload.data.body;
  if (body.trace_chain) {
    var chain = body.trace_chain;
    for (var i = 0; i < chain.length; i++) {
      chain[i] = truncateTraceData(chain[i]);
    }
  } else if (body.trace) {
    body.trace = truncateTraceData(body.trace);
  }
  return [payload, _.stringify(payload, jsonBackup)];
}
function needsTruncation(payload, maxSize) {
  return _.maxByteSize(payload) > maxSize;
}
function truncate(payload, jsonBackup, maxSize) {
  maxSize = typeof maxSize === 'undefined' ? 512 * 1024 : maxSize;
  var strategies = [raw, truncateFrames, truncateStrings.bind(null, 1024), truncateStrings.bind(null, 512), truncateStrings.bind(null, 256), minBody];
  var strategy, results, result;
  while (strategy = strategies.shift()) {
    results = strategy(payload, jsonBackup);
    payload = results[0];
    result = results[1];
    if (result.error || !needsTruncation(result.value, maxSize)) {
      return result;
    }
  }
  return result;
}
module.exports = {
  truncate: truncate,
  /* for testing */
  raw: raw,
  truncateFrames: truncateFrames,
  truncateStrings: truncateStrings,
  maybeTruncateValue: maybeTruncateValue
};

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var merge = __webpack_require__(/*! ./merge */ "./src/merge.js");
var RollbarJSON = {};
function setupJSON(polyfillJSON) {
  if (isFunction(RollbarJSON.stringify) && isFunction(RollbarJSON.parse)) {
    return;
  }
  if (isDefined(JSON)) {
    // If polyfill is provided, prefer it over existing non-native shims.
    if (polyfillJSON) {
      if (isNativeFunction(JSON.stringify)) {
        RollbarJSON.stringify = JSON.stringify;
      }
      if (isNativeFunction(JSON.parse)) {
        RollbarJSON.parse = JSON.parse;
      }
    } else {
      // else accept any interface that is present.
      if (isFunction(JSON.stringify)) {
        RollbarJSON.stringify = JSON.stringify;
      }
      if (isFunction(JSON.parse)) {
        RollbarJSON.parse = JSON.parse;
      }
    }
  }
  if (!isFunction(RollbarJSON.stringify) || !isFunction(RollbarJSON.parse)) {
    polyfillJSON && polyfillJSON(RollbarJSON);
  }
}

/*
 * isType - Given a Javascript value and a string, returns true if the type of the value matches the
 * given string.
 *
 * @param x - any value
 * @param t - a lowercase string containing one of the following type names:
 *    - undefined
 *    - null
 *    - error
 *    - number
 *    - boolean
 *    - string
 *    - symbol
 *    - function
 *    - object
 *    - array
 * @returns true if x is of type t, otherwise false
 */
function isType(x, t) {
  return t === typeName(x);
}

/*
 * typeName - Given a Javascript value, returns the type of the object as a string
 */
function typeName(x) {
  var name = _typeof(x);
  if (name !== 'object') {
    return name;
  }
  if (!x) {
    return 'null';
  }
  if (x instanceof Error) {
    return 'error';
  }
  return {}.toString.call(x).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}

/* isFunction - a convenience function for checking if a value is a function
 *
 * @param f - any value
 * @returns true if f is a function, otherwise false
 */
function isFunction(f) {
  return isType(f, 'function');
}

/* isNativeFunction - a convenience function for checking if a value is a native JS function
 *
 * @param f - any value
 * @returns true if f is a native JS function, otherwise false
 */
function isNativeFunction(f) {
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var funcMatchString = Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?');
  var reIsNative = RegExp('^' + funcMatchString + '$');
  return isObject(f) && reIsNative.test(f);
}

/* isObject - Checks if the argument is an object
 *
 * @param value - any value
 * @returns true is value is an object function is an object)
 */
function isObject(value) {
  var type = _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

/* isString - Checks if the argument is a string
 *
 * @param value - any value
 * @returns true if value is a string
 */
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}

/**
 * isFiniteNumber - determines whether the passed value is a finite number
 *
 * @param {*} n - any value
 * @returns true if value is a finite number
 */
function isFiniteNumber(n) {
  return Number.isFinite(n);
}

/*
 * isDefined - a convenience function for checking if a value is not equal to undefined
 *
 * @param u - any value
 * @returns true if u is anything other than undefined
 */
function isDefined(u) {
  return !isType(u, 'undefined');
}

/*
 * isIterable - convenience function for checking if a value can be iterated, essentially
 * whether it is an object or an array.
 *
 * @param i - any value
 * @returns true if i is an object or an array as determined by `typeName`
 */
function isIterable(i) {
  var type = typeName(i);
  return type === 'object' || type === 'array';
}

/*
 * isError - convenience function for checking if a value is of an error type
 *
 * @param e - any value
 * @returns true if e is an error
 */
function isError(e) {
  // Detect both Error and Firefox Exception type
  return isType(e, 'error') || isType(e, 'exception');
}

/* isPromise - a convenience function for checking if a value is a promise
 *
 * @param p - any value
 * @returns true if f is a function, otherwise false
 */
function isPromise(p) {
  return isObject(p) && isType(p.then, 'function');
}

/**
 * isBrowser - a convenience function for checking if the code is running in a browser
 *
 * @returns true if the code is running in a browser environment
 */
function isBrowser() {
  return typeof window !== 'undefined';
}
function redact() {
  return '********';
}

// from http://stackoverflow.com/a/8809472/1138191
function uuid4() {
  var d = now();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
  });
  return uuid;
}
var LEVELS = {
  debug: 0,
  info: 1,
  warning: 2,
  error: 3,
  critical: 4
};
function sanitizeUrl(url) {
  var baseUrlParts = parseUri(url);
  if (!baseUrlParts) {
    return '(unknown)';
  }

  // remove a trailing # if there is no anchor
  if (baseUrlParts.anchor === '') {
    baseUrlParts.source = baseUrlParts.source.replace('#', '');
  }
  url = baseUrlParts.source.replace('?' + baseUrlParts.query, '');
  return url;
}
var parseUriOptions = {
  strictMode: false,
  key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
  q: {
    name: 'queryKey',
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};
function parseUri(str) {
  if (!isType(str, 'string')) {
    return undefined;
  }
  var o = parseUriOptions;
  var m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str);
  var uri = {};
  for (var i = 0, l = o.key.length; i < l; ++i) {
    uri[o.key[i]] = m[i] || '';
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) {
      uri[o.q.name][$1] = $2;
    }
  });
  return uri;
}
function addParamsAndAccessTokenToPath(accessToken, options, params) {
  params = params || {};
  params.access_token = accessToken;
  var paramsArray = [];
  var k;
  for (k in params) {
    if (Object.prototype.hasOwnProperty.call(params, k)) {
      paramsArray.push([k, params[k]].join('='));
    }
  }
  var query = '?' + paramsArray.sort().join('&');
  options = options || {};
  options.path = options.path || '';
  var qs = options.path.indexOf('?');
  var h = options.path.indexOf('#');
  var p;
  if (qs !== -1 && (h === -1 || h > qs)) {
    p = options.path;
    options.path = p.substring(0, qs) + query + '&' + p.substring(qs + 1);
  } else {
    if (h !== -1) {
      p = options.path;
      options.path = p.substring(0, h) + query + p.substring(h);
    } else {
      options.path = options.path + query;
    }
  }
}
function formatUrl(u, protocol) {
  protocol = protocol || u.protocol;
  if (!protocol && u.port) {
    if (u.port === 80) {
      protocol = 'http:';
    } else if (u.port === 443) {
      protocol = 'https:';
    }
  }
  protocol = protocol || 'https:';
  if (!u.hostname) {
    return null;
  }
  var result = protocol + '//' + u.hostname;
  if (u.port) {
    result = result + ':' + u.port;
  }
  if (u.path) {
    result = result + u.path;
  }
  return result;
}
function stringify(obj, backup) {
  var value, error;
  try {
    value = RollbarJSON.stringify(obj);
  } catch (jsonError) {
    if (backup && isFunction(backup)) {
      try {
        value = backup(obj);
      } catch (backupError) {
        error = backupError;
      }
    } else {
      error = jsonError;
    }
  }
  return {
    error: error,
    value: value
  };
}
function maxByteSize(string) {
  // The transport will use utf-8, so assume utf-8 encoding.
  //
  // This minimal implementation will accurately count bytes for all UCS-2 and
  // single code point UTF-16. If presented with multi code point UTF-16,
  // which should be rare, it will safely overcount, not undercount.
  //
  // While robust utf-8 encoders exist, this is far smaller and far more performant.
  // For quickly counting payload size for truncation, smaller is better.

  var count = 0;
  var length = string.length;
  for (var i = 0; i < length; i++) {
    var code = string.charCodeAt(i);
    if (code < 128) {
      // up to 7 bits
      count = count + 1;
    } else if (code < 2048) {
      // up to 11 bits
      count = count + 2;
    } else if (code < 65536) {
      // up to 16 bits
      count = count + 3;
    }
  }
  return count;
}
function jsonParse(s) {
  var value, error;
  try {
    value = RollbarJSON.parse(s);
  } catch (e) {
    error = e;
  }
  return {
    error: error,
    value: value
  };
}
function makeUnhandledStackInfo(message, url, lineno, colno, error, mode, backupMessage, errorParser) {
  var location = {
    url: url || '',
    line: lineno,
    column: colno
  };
  location.func = errorParser.guessFunctionName(location.url, location.line);
  location.context = errorParser.gatherContext(location.url, location.line);
  var href = typeof document !== 'undefined' && document && document.location && document.location.href;
  var useragent = typeof window !== 'undefined' && window && window.navigator && window.navigator.userAgent;
  return {
    mode: mode,
    message: error ? String(error) : message || backupMessage,
    url: href,
    stack: [location],
    useragent: useragent
  };
}
function wrapCallback(logger, f) {
  return function (err, resp) {
    try {
      f(err, resp);
    } catch (e) {
      logger.error(e);
    }
  };
}
function nonCircularClone(obj) {
  var seen = [obj];
  function clone(obj, seen) {
    var value,
      name,
      newSeen,
      result = {};
    try {
      for (name in obj) {
        value = obj[name];
        if (value && (isType(value, 'object') || isType(value, 'array'))) {
          if (seen.includes(value)) {
            result[name] = 'Removed circular reference: ' + typeName(value);
          } else {
            newSeen = seen.slice();
            newSeen.push(value);
            result[name] = clone(value, newSeen);
          }
          continue;
        }
        result[name] = value;
      }
    } catch (e) {
      result = 'Failed cloning custom data: ' + e.message;
    }
    return result;
  }
  return clone(obj, seen);
}
function createItem(args, logger, notifier, requestKeys, lambdaContext) {
  var message, err, custom, callback, request;
  var arg;
  var extraArgs = [];
  var diagnostic = {};
  var argTypes = [];
  for (var i = 0, l = args.length; i < l; ++i) {
    arg = args[i];
    var typ = typeName(arg);
    argTypes.push(typ);
    switch (typ) {
      case 'undefined':
        break;
      case 'string':
        message ? extraArgs.push(arg) : message = arg;
        break;
      case 'function':
        callback = wrapCallback(logger, arg);
        break;
      case 'date':
        extraArgs.push(arg);
        break;
      case 'error':
      case 'domexception':
      case 'exception':
        // Firefox Exception type
        err ? extraArgs.push(arg) : err = arg;
        break;
      case 'object':
      case 'array':
        if (arg instanceof Error || typeof DOMException !== 'undefined' && arg instanceof DOMException) {
          err ? extraArgs.push(arg) : err = arg;
          break;
        }
        if (requestKeys && typ === 'object' && !request) {
          for (var j = 0, len = requestKeys.length; j < len; ++j) {
            if (arg[requestKeys[j]] !== undefined) {
              request = arg;
              break;
            }
          }
          if (request) {
            break;
          }
        }
        custom ? extraArgs.push(arg) : custom = arg;
        break;
      default:
        if (arg instanceof Error || typeof DOMException !== 'undefined' && arg instanceof DOMException) {
          err ? extraArgs.push(arg) : err = arg;
          break;
        }
        extraArgs.push(arg);
    }
  }

  // if custom is an array this turns it into an object with integer keys
  if (custom) custom = nonCircularClone(custom);
  if (extraArgs.length > 0) {
    if (!custom) custom = nonCircularClone({});
    custom.extraArgs = nonCircularClone(extraArgs);
  }
  var item = {
    message: message,
    err: err,
    custom: custom,
    timestamp: now(),
    callback: callback,
    notifier: notifier,
    diagnostic: diagnostic,
    uuid: uuid4()
  };
  item.data = item.data || {};
  setCustomItemKeys(item, custom);
  if (requestKeys && request) {
    item.request = request;
  }
  if (lambdaContext) {
    item.lambdaContext = lambdaContext;
  }
  item._originalArgs = args;
  item.diagnostic.original_arg_types = argTypes;
  return item;
}
function setCustomItemKeys(item, custom) {
  if (custom && custom.level !== undefined) {
    item.level = custom.level;
    delete custom.level;
  }
  if (custom && custom.skipFrames !== undefined) {
    item.skipFrames = custom.skipFrames;
    delete custom.skipFrames;
  }
}
function addErrorContext(item, errors) {
  var custom = item.data.custom || {};
  var contextAdded = false;
  try {
    for (var i = 0; i < errors.length; ++i) {
      if (errors[i].hasOwnProperty('rollbarContext')) {
        custom = merge(custom, nonCircularClone(errors[i].rollbarContext));
        contextAdded = true;
      }
    }

    // Avoid adding an empty object to the data.
    if (contextAdded) {
      item.data.custom = custom;
    }
  } catch (e) {
    item.diagnostic.error_context = 'Failed: ' + e.message;
  }
}
var TELEMETRY_TYPES = ['log', 'network', 'dom', 'navigation', 'error', 'manual'];
var TELEMETRY_LEVELS = ['critical', 'error', 'warning', 'info', 'debug'];
function arrayIncludes(arr, val) {
  for (var k = 0; k < arr.length; ++k) {
    if (arr[k] === val) {
      return true;
    }
  }
  return false;
}
function createTelemetryEvent(args) {
  var type, metadata, level;
  var arg;
  for (var i = 0, l = args.length; i < l; ++i) {
    arg = args[i];
    var typ = typeName(arg);
    switch (typ) {
      case 'string':
        if (!type && arrayIncludes(TELEMETRY_TYPES, arg)) {
          type = arg;
        } else if (!level && arrayIncludes(TELEMETRY_LEVELS, arg)) {
          level = arg;
        }
        break;
      case 'object':
        metadata = arg;
        break;
      default:
        break;
    }
  }
  var event = {
    type: type || 'manual',
    metadata: metadata || {},
    level: level
  };
  return event;
}
function addItemAttributes(item, attributes) {
  item.data.attributes = item.data.attributes || [];
  if (attributes) {
    var _item$data$attributes;
    (_item$data$attributes = item.data.attributes).push.apply(_item$data$attributes, _toConsumableArray(attributes));
  }
}

/*
 * get - given an obj/array and a keypath, return the value at that keypath or
 *       undefined if not possible.
 *
 * @param obj - an object or array
 * @param path - a string of keys separated by '.' such as 'plugin.jquery.0.message'
 *    which would correspond to 42 in `{plugin: {jquery: [{message: 42}]}}`
 */
function get(obj, path) {
  if (!obj) {
    return undefined;
  }
  var keys = path.split('.');
  var result = obj;
  try {
    for (var i = 0, len = keys.length; i < len; ++i) {
      result = result[keys[i]];
    }
  } catch (e) {
    result = undefined;
  }
  return result;
}
function set(obj, path, value) {
  if (!obj) {
    return;
  }
  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {
    obj[keys[0]] = value;
    return;
  }
  try {
    var temp = obj[keys[0]] || {};
    var replacement = temp;
    for (var i = 1; i < len - 1; ++i) {
      temp[keys[i]] = temp[keys[i]] || {};
      temp = temp[keys[i]];
    }
    temp[keys[len - 1]] = value;
    obj[keys[0]] = replacement;
  } catch (e) {
    return;
  }
}
function formatArgsAsString(args) {
  var i, len, arg;
  var result = [];
  for (i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    switch (typeName(arg)) {
      case 'object':
        arg = stringify(arg);
        arg = arg.error || arg.value;
        if (arg.length > 500) {
          arg = arg.substr(0, 497) + '...';
        }
        break;
      case 'null':
        arg = 'null';
        break;
      case 'undefined':
        arg = 'undefined';
        break;
      case 'symbol':
        arg = arg.toString();
        break;
    }
    result.push(arg);
  }
  return result.join(' ');
}
function now() {
  if (Date.now) {
    return +Date.now();
  }
  return +new Date();
}
function filterIp(requestData, captureIp) {
  if (!requestData || !requestData['user_ip'] || captureIp === true) {
    return;
  }
  var newIp = requestData['user_ip'];
  if (!captureIp) {
    newIp = null;
  } else {
    try {
      var parts;
      if (newIp.indexOf('.') !== -1) {
        parts = newIp.split('.');
        parts.pop();
        parts.push('0');
        newIp = parts.join('.');
      } else if (newIp.indexOf(':') !== -1) {
        parts = newIp.split(':');
        if (parts.length > 2) {
          var beginning = parts.slice(0, 3);
          var slashIdx = beginning[2].indexOf('/');
          if (slashIdx !== -1) {
            beginning[2] = beginning[2].substring(0, slashIdx);
          }
          var terminal = '0000:0000:0000:0000:0000';
          newIp = beginning.concat(terminal).join(':');
        }
      } else {
        newIp = null;
      }
    } catch (e) {
      newIp = null;
    }
  }
  requestData['user_ip'] = newIp;
}
function handleOptions(current, input, payload, logger) {
  var result = merge(current, input, payload);
  result = updateDeprecatedOptions(result, logger);
  if (!input || input.overwriteScrubFields) {
    return result;
  }
  if (input.scrubFields) {
    result.scrubFields = (current.scrubFields || []).concat(input.scrubFields);
  }
  return result;
}
function updateDeprecatedOptions(options, logger) {
  if (options.hostWhiteList && !options.hostSafeList) {
    options.hostSafeList = options.hostWhiteList;
    options.hostWhiteList = undefined;
    logger && logger.log('hostWhiteList is deprecated. Use hostSafeList.');
  }
  if (options.hostBlackList && !options.hostBlockList) {
    options.hostBlockList = options.hostBlackList;
    options.hostBlackList = undefined;
    logger && logger.log('hostBlackList is deprecated. Use hostBlockList.');
  }
  return options;
}
module.exports = {
  addParamsAndAccessTokenToPath: addParamsAndAccessTokenToPath,
  createItem: createItem,
  addErrorContext: addErrorContext,
  createTelemetryEvent: createTelemetryEvent,
  addItemAttributes: addItemAttributes,
  filterIp: filterIp,
  formatArgsAsString: formatArgsAsString,
  formatUrl: formatUrl,
  get: get,
  handleOptions: handleOptions,
  isError: isError,
  isFiniteNumber: isFiniteNumber,
  isFunction: isFunction,
  isIterable: isIterable,
  isNativeFunction: isNativeFunction,
  isObject: isObject,
  isString: isString,
  isType: isType,
  isPromise: isPromise,
  isBrowser: isBrowser,
  jsonParse: jsonParse,
  LEVELS: LEVELS,
  makeUnhandledStackInfo: makeUnhandledStackInfo,
  merge: merge,
  now: now,
  redact: redact,
  RollbarJSON: RollbarJSON,
  sanitizeUrl: sanitizeUrl,
  set: set,
  setupJSON: setupJSON,
  stringify: stringify,
  maxByteSize: maxByteSize,
  typeName: typeName,
  uuid4: uuid4
};

/***/ }),

/***/ "./src/utility/headers.js":
/*!********************************!*\
  !*** ./src/utility/headers.js ***!
  \********************************/
/***/ ((module) => {

/*
 * headers - Detect when fetch Headers are undefined and use a partial polyfill.
 *
 * A full polyfill is not used in order to keep package size as small as possible.
 * Since this is only used internally and is not added to the window object,
 * the full interface doesn't need to be supported.
 *
 * This implementation is modified from whatwg-fetch:
 * https://github.com/github/fetch
 */
function headers(headers) {
  if (typeof Headers === 'undefined') {
    return new FetchHeaders(headers);
  }
  return new Headers(headers);
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };
  return iterator;
}
function FetchHeaders(headers) {
  this.map = {};
  if (headers instanceof FetchHeaders) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
FetchHeaders.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
FetchHeaders.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
FetchHeaders.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
FetchHeaders.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
FetchHeaders.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
module.exports = headers;

/***/ }),

/***/ "./src/utility/polyfillJSON.js":
/*!*************************************!*\
  !*** ./src/utility/polyfillJSON.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var polyfillJSON = __webpack_require__(/*! ../../vendor/JSON-js/json3 */ "./vendor/JSON-js/json3.js");
module.exports = polyfillJSON;

/***/ }),

/***/ "./src/utility/replace.js":
/*!********************************!*\
  !*** ./src/utility/replace.js ***!
  \********************************/
/***/ ((module) => {

function replace(obj, name, replacement, replacements, type) {
  var orig = obj[name];
  obj[name] = replacement(orig);
  if (replacements) {
    replacements[type].push([obj, name, orig]);
  }
}
module.exports = replace;

/***/ }),

/***/ "./src/utility/traverse.js":
/*!*********************************!*\
  !*** ./src/utility/traverse.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
function traverse(obj, func, seen) {
  var k, v, i;
  var isObj = _.isType(obj, 'object');
  var isArray = _.isType(obj, 'array');
  var keys = [];
  var seenIndex;

  // Best might be to use Map here with `obj` as the keys, but we want to support IE < 11.
  seen = seen || {
    obj: [],
    mapped: []
  };
  if (isObj) {
    seenIndex = seen.obj.indexOf(obj);
    if (isObj && seenIndex !== -1) {
      // Prefer the mapped object if there is one.
      return seen.mapped[seenIndex] || seen.obj[seenIndex];
    }
    seen.obj.push(obj);
    seenIndex = seen.obj.length - 1;
  }
  if (isObj) {
    for (k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, k)) {
        keys.push(k);
      }
    }
  } else if (isArray) {
    for (i = 0; i < obj.length; ++i) {
      keys.push(i);
    }
  }
  var result = isObj ? {} : [];
  var same = true;
  for (i = 0; i < keys.length; ++i) {
    k = keys[i];
    v = obj[k];
    result[k] = func(k, v, seen);
    same = same && result[k] === obj[k];
  }
  if (isObj && !same) {
    seen.mapped[seenIndex] = result;
  }
  return !same ? result : obj;
}
module.exports = traverse;

/***/ }),

/***/ "./vendor/JSON-js/json3.js":
/*!*********************************!*\
  !*** ./vendor/JSON-js/json3.js ***!
  \*********************************/
/***/ ((module) => {

//  json3.js
//  2017-02-21
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.
//          This has been modified to use JSON-js/json_parse_state.js as the
//          parser instead of the one built around eval found in JSON-js/json2.js

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
  for, this
  */

/*property
  JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
  getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
  lastIndex, length, parse, prototype, push, replace, slice, stringify,
  test, toJSON, toString, valueOf
  */

var setupCustomJSON = function(JSON) {

  var rx_one = /^[\],:{}\s]*$/;
  var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
  var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
  var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

  function f(n) {
    // Format integers to have at least two digits.
    return n < 10
      ? "0" + n
      : n;
  }

  function this_value() {
    return this.valueOf();
  }

  if (typeof Date.prototype.toJSON !== "function") {

    Date.prototype.toJSON = function () {

      return isFinite(this.valueOf())
        ? this.getUTCFullYear() + "-" +
        f(this.getUTCMonth() + 1) + "-" +
        f(this.getUTCDate()) + "T" +
        f(this.getUTCHours()) + ":" +
        f(this.getUTCMinutes()) + ":" +
        f(this.getUTCSeconds()) + "Z"
        : null;
    };

    Boolean.prototype.toJSON = this_value;
    Number.prototype.toJSON = this_value;
    String.prototype.toJSON = this_value;
  }

  var gap;
  var indent;
  var meta;
  var rep;


  function quote(string) {

    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.

    rx_escapable.lastIndex = 0;
    return rx_escapable.test(string)
      ? "\"" + string.replace(rx_escapable, function (a) {
        var c = meta[a];
        return typeof c === "string"
          ? c
          : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + "\""
    : "\"" + string + "\"";
  }


  function str(key, holder) {

    // Produce a string from holder[key].

    var i;          // The loop counter.
    var k;          // The member key.
    var v;          // The member value.
    var length;
    var mind = gap;
    var partial;
    var value = holder[key];

    // If the value has a toJSON method, call it to obtain a replacement value.

    if (value && typeof value === "object" &&
        typeof value.toJSON === "function") {
      value = value.toJSON(key);
    }

    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.

    if (typeof rep === "function") {
      value = rep.call(holder, key, value);
    }

    // What happens next depends on the value's type.

    switch (typeof value) {
      case "string":
        return quote(value);

      case "number":

        // JSON numbers must be finite. Encode non-finite numbers as null.

        return isFinite(value)
          ? String(value)
          : "null";

      case "boolean":
      case "null":

        // If the value is a boolean or null, convert it to a string. Note:
        // typeof null does not produce "null". The case is included here in
        // the remote chance that this gets fixed someday.

        return String(value);

        // If the type is "object", we might be dealing with an object or an array or
        // null.

      case "object":

        // Due to a specification blunder in ECMAScript, typeof null is "object",
        // so watch out for that case.

        if (!value) {
          return "null";
        }

        // Make an array to hold the partial results of stringifying this object value.

        gap += indent;
        partial = [];

        // Is the value an array?

        if (Object.prototype.toString.apply(value) === "[object Array]") {

          // The value is an array. Stringify every element. Use null as a placeholder
          // for non-JSON values.

          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || "null";
          }

          // Join all of the elements together, separated with commas, and wrap them in
          // brackets.

          v = partial.length === 0
            ? "[]"
            : gap
            ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
            : "[" + partial.join(",") + "]";
          gap = mind;
          return v;
        }

        // If the replacer is an array, use it to select the members to be stringified.

        if (rep && typeof rep === "object") {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === "string") {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (
                      gap
                      ? ": "
                      : ":"
                      ) + v);
              }
            }
          }
        } else {

          // Otherwise, iterate through all of the keys in the object.

          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (
                      gap
                      ? ": "
                      : ":"
                      ) + v);
              }
            }
          }
        }

        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0
          ? "{}"
          : gap
          ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
          : "{" + partial.join(",") + "}";
        gap = mind;
        return v;
    }
  }

  // If the JSON object does not yet have a stringify method, give it one.

  if (typeof JSON.stringify !== "function") {
    meta = {    // table of character substitutions
      "\b": "\\b",
      "\t": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      "\"": "\\\"",
      "\\": "\\\\"
    };
    JSON.stringify = function (value, replacer, space) {

      // The stringify method takes a value and an optional replacer, and an optional
      // space parameter, and returns a JSON text. The replacer can be a function
      // that can replace values, or an array of strings that will select the keys.
      // A default replacer method can be provided. Use of the space parameter can
      // produce text that is more easily readable.

      var i;
      gap = "";
      indent = "";

      // If the space parameter is a number, make an indent string containing that
      // many spaces.

      if (typeof space === "number") {
        for (i = 0; i < space; i += 1) {
          indent += " ";
        }

        // If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === "string") {
        indent = space;
      }

      // If there is a replacer, it must be a function or an array.
      // Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== "function" &&
          (typeof replacer !== "object" ||
           typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }

      // Make a fake root object containing our value under the key of "".
      // Return the result of stringifying the value.

      return str("", {"": value});
    };
  }


  // If the JSON object does not yet have a parse method, give it one.

  if (typeof JSON.parse !== "function") {
    JSON.parse = (function () {

      // This function creates a JSON parse function that uses a state machine rather
      // than the dangerous eval function to parse a JSON text.

      var state;      // The state of the parser, one of
      // 'go'         The starting state
      // 'ok'         The final, accepting state
      // 'firstokey'  Ready for the first key of the object or
      //              the closing of an empty object
      // 'okey'       Ready for the next key of the object
      // 'colon'      Ready for the colon
      // 'ovalue'     Ready for the value half of a key/value pair
      // 'ocomma'     Ready for a comma or closing }
      // 'firstavalue' Ready for the first value of an array or
      //              an empty array
      // 'avalue'     Ready for the next value of an array
      // 'acomma'     Ready for a comma or closing ]
      var stack;      // The stack, for controlling nesting.
      var container;  // The current container object or array
      var key;        // The current key
      var value;      // The current value
      var escapes = { // Escapement translation table
        "\\": "\\",
        "\"": "\"",
        "/": "/",
        "t": "\t",
        "n": "\n",
        "r": "\r",
        "f": "\f",
        "b": "\b"
      };
      var string = {   // The actions for string tokens
        go: function () {
          state = "ok";
        },
        firstokey: function () {
          key = value;
          state = "colon";
        },
        okey: function () {
          key = value;
          state = "colon";
        },
        ovalue: function () {
          state = "ocomma";
        },
        firstavalue: function () {
          state = "acomma";
        },
        avalue: function () {
          state = "acomma";
        }
      };
      var number = {   // The actions for number tokens
        go: function () {
          state = "ok";
        },
        ovalue: function () {
          state = "ocomma";
        },
        firstavalue: function () {
          state = "acomma";
        },
        avalue: function () {
          state = "acomma";
        }
      };
      var action = {

        // The action table describes the behavior of the machine. It contains an
        // object for each token. Each object contains a method that is called when
        // a token is matched in a state. An object will lack a method for illegal
        // states.

        "{": {
          go: function () {
            stack.push({state: "ok"});
            container = {};
            state = "firstokey";
          },
          ovalue: function () {
            stack.push({container: container, state: "ocomma", key: key});
            container = {};
            state = "firstokey";
          },
          firstavalue: function () {
            stack.push({container: container, state: "acomma"});
            container = {};
            state = "firstokey";
          },
          avalue: function () {
            stack.push({container: container, state: "acomma"});
            container = {};
            state = "firstokey";
          }
        },
        "}": {
          firstokey: function () {
            var pop = stack.pop();
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          },
          ocomma: function () {
            var pop = stack.pop();
            container[key] = value;
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          }
        },
        "[": {
          go: function () {
            stack.push({state: "ok"});
            container = [];
            state = "firstavalue";
          },
          ovalue: function () {
            stack.push({container: container, state: "ocomma", key: key});
            container = [];
            state = "firstavalue";
          },
          firstavalue: function () {
            stack.push({container: container, state: "acomma"});
            container = [];
            state = "firstavalue";
          },
          avalue: function () {
            stack.push({container: container, state: "acomma"});
            container = [];
            state = "firstavalue";
          }
        },
        "]": {
          firstavalue: function () {
            var pop = stack.pop();
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          },
          acomma: function () {
            var pop = stack.pop();
            container.push(value);
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          }
        },
        ":": {
          colon: function () {
            if (Object.hasOwnProperty.call(container, key)) {
              throw new SyntaxError("Duplicate key '" + key + "\"");
            }
            state = "ovalue";
          }
        },
        ",": {
          ocomma: function () {
            container[key] = value;
            state = "okey";
          },
          acomma: function () {
            container.push(value);
            state = "avalue";
          }
        },
        "true": {
          go: function () {
            value = true;
            state = "ok";
          },
          ovalue: function () {
            value = true;
            state = "ocomma";
          },
          firstavalue: function () {
            value = true;
            state = "acomma";
          },
          avalue: function () {
            value = true;
            state = "acomma";
          }
        },
        "false": {
          go: function () {
            value = false;
            state = "ok";
          },
          ovalue: function () {
            value = false;
            state = "ocomma";
          },
          firstavalue: function () {
            value = false;
            state = "acomma";
          },
          avalue: function () {
            value = false;
            state = "acomma";
          }
        },
        "null": {
          go: function () {
            value = null;
            state = "ok";
          },
          ovalue: function () {
            value = null;
            state = "ocomma";
          },
          firstavalue: function () {
            value = null;
            state = "acomma";
          },
          avalue: function () {
            value = null;
            state = "acomma";
          }
        }
      };

      function debackslashify(text) {

        // Remove and replace any backslash escapement.

        return text.replace(/\\(?:u(.{4})|([^u]))/g, function (ignore, b, c) {
          return b
            ? String.fromCharCode(parseInt(b, 16))
            : escapes[c];
        });
      }

      return function (source, reviver) {

        // A regular expression is used to extract tokens from the JSON text.
        // The extraction process is cautious.

        var result;
        var tx = /^[\u0020\t\n\r]*(?:([,:\[\]{}]|true|false|null)|(-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)|"((?:[^\r\n\t\\\"]|\\(?:["\\\/trnfb]|u[0-9a-fA-F]{4}))*)")/;

        // Set the starting state.

        state = "go";

        // The stack records the container, key, and state for each object or array
        // that contains another object or array while processing nested structures.

        stack = [];

        // If any error occurs, we will catch it and ultimately throw a syntax error.

        try {

          // For each token...

          while (true) {
            result = tx.exec(source);
            if (!result) {
              break;
            }

            // result is the result array from matching the tokenizing regular expression.
            //  result[0] contains everything that matched, including any initial whitespace.
            //  result[1] contains any punctuation that was matched, or true, false, or null.
            //  result[2] contains a matched number, still in string form.
            //  result[3] contains a matched string, without quotes but with escapement.

            if (result[1]) {

              // Token: Execute the action for this state and token.

              action[result[1]][state]();

            } else if (result[2]) {

              // Number token: Convert the number string into a number value and execute
              // the action for this state and number.

              value = +result[2];
              number[state]();
            } else {

              // String token: Replace the escapement sequences and execute the action for
              // this state and string.

              value = debackslashify(result[3]);
              string[state]();
            }

            // Remove the token from the string. The loop will continue as long as there
            // are tokens. This is a slow process, but it allows the use of ^ matching,
            // which assures that no illegal tokens slip through.

            source = source.slice(result[0].length);
          }

          // If we find a state/token combination that is illegal, then the action will
          // cause an error. We handle the error by simply changing the state.

        } catch (e) {
          state = e;
        }

        // The parsing is finished. If we are not in the final "ok" state, or if the
        // remaining source contains anything except whitespace, then we did not have
        //a well-formed JSON text.

        if (state !== "ok" || (/[^\u0020\t\n\r]/.test(source))) {
          throw (state instanceof SyntaxError)
            ? state
            : new SyntaxError("JSON");
        }

        // If there is a reviver function, we recursively walk the new structure,
        // passing each name/value pair to the reviver function for possible
        // transformation, starting with a temporary root object that holds the current
        // value in an empty key. If there is not a reviver function, we simply return
        // that value.

        return (typeof reviver === "function")
          ? (function walk(holder, key) {
            var k;
            var v;
            var val = holder[key];
            if (val && typeof val === "object") {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(val, k)) {
                  v = walk(val, k);
                  if (v !== undefined) {
                    val[k] = v;
                  } else {
                    delete val[k];
                  }
                }
              }
            }
            return reviver.call(holder, key, val);
          }({"": value}, ""))
        : value;
      };
    }());
  }
}

module.exports = setupCustomJSON;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!*****************************************!*\
  !*** ./test/browser.transforms.test.js ***!
  \*****************************************/
/* globals expect */
/* globals describe */
/* globals it */
/* globals sinon */

var Rollbar = __webpack_require__(/*! ../src/browser/rollbar */ "./src/browser/rollbar.js");
var t = __webpack_require__(/*! ../src/browser/transforms */ "./src/browser/transforms.js");

function TestClientGen() {
  var TestClient = function () {
    this.notifier = {
      addTransform: function () {
        return this.notifier;
      }.bind(this),
    };
    this.queue = {
      addPredicate: function () {
        return this.queue;
      }.bind(this),
    };
  };
  return TestClient;
}

function itemFromArgs(args) {
  var client = new (TestClientGen())();
  var rollbar = new Rollbar({ autoInstrument: false }, client);
  var item = rollbar._createItem(args);
  item.level = 'debug';
  return item;
}

function chromeMajorVersion() {
  return parseInt(navigator.userAgent.match(/Chrome\/([0-9]+)\./)[1]);
}

describe('handleDomException', function () {
  it('should do nothing if not a DOMException', function (done) {
    var err = new Error('test');
    var args = ['a message', err];
    var item = itemFromArgs(args);
    var options = {};
    t.handleDomException(item, options, function (e, i) {
      expect(item.err).to.eql(item.err);
      expect(item.err.nested).to.not.be.ok();
      done(e);
    });
  });
  it('should create nested exception for DOMException', function (done) {
    var err = new DOMException('dom error');
    var args = ['a message', err];
    var item = itemFromArgs(args);
    var options = {};
    t.handleDomException(item, options, function (e, i) {
      expect(item.err.nested.constructor.name).to.eql('DOMException');
      expect(item.err.constructor.name).to.eql('Error');
      done(e);
    });
  });
});
describe('handleItemWithError', function () {
  it('should do nothing if there is no err', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = {};
    t.handleItemWithError(item, options, function (e, i) {
      expect(i).to.eql(item);
      done(e);
    });
  });
  it('should set stack info from error if it is already saved', function (done) {
    var err = new Error('bork');
    var myTrace = { trace: { frames: [1, 2, 3] } };
    err._savedStackTrace = myTrace;
    var args = ['a message', err];
    var item = itemFromArgs(args);
    var options = {};
    t.handleItemWithError(item, options, function (e, i) {
      expect(i.stackInfo).to.eql(myTrace);
      done(e);
    });
  });
  it('should set stack info from error', function (done) {
    var err;
    try {
      throw new Error('bork');
    } catch (e) {
      err = e;
    }
    var args = ['a message', err];
    var item = itemFromArgs(args);
    var options = {};
    t.handleItemWithError(item, options, function (e, i) {
      expect(i.message).to.eql('a message');
      expect(i.stackInfo).to.be.ok();
      done(e);
    });
  });
  it('should handle bad errors and still set stackInfo', function (done) {
    var err = { description: 'bork' };
    var args = ['a message', 'fuzz'];
    var item = itemFromArgs(args);
    item.err = err;
    var options = {};
    t.handleItemWithError(item, options, function (e, i) {
      expect(i.stackInfo).to.be.ok();
      expect(i.message).to.eql('a message');
      done(e);
    });
  });
  it('should use most specific error name', function (done) {
    var err = new Error('bork');
    var args = ['a message', err];
    var options = {};

    var names = [
      { name: 'TypeError', constructor: 'EvalError', result: 'TypeError' },
      { name: 'TypeError', constructor: 'Error', result: 'TypeError' },
      { name: 'Error', constructor: 'TypeError', result: 'TypeError' },
      { name: 'Error', constructor: '', result: 'Error' },
      { name: '', constructor: 'Error', result: 'Error' },
      { name: '', constructor: '', result: '' },
    ];

    for (var i = 0; i < names.length; i++) {
      err.name = names[i].name;
      err.constructor = { name: names[i].constructor };
      var item = itemFromArgs(args);
      var result = names[i].result;

      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo.name).to.eql(result);
      });
    }
    done();
  });
});

describe('ensureItemHasSomethingToSay', function () {
  it('should error if item has nothing', function (done) {
    var args = [];
    var item = itemFromArgs(args);
    var options = {};
    t.ensureItemHasSomethingToSay(item, options, function (e, i) {
      expect(e).to.be.ok();
      done(i);
    });
  });
  it('should do nothing if item has a message', function (done) {
    var args = [];
    var item = itemFromArgs(args);
    item.message = 'bork';
    var options = {};
    t.ensureItemHasSomethingToSay(item, options, function (e, i) {
      expect(i).to.be.ok();
      done(e);
    });
  });
  it('should do nothing if item has stackInfo', function (done) {
    var args = [];
    var item = itemFromArgs(args);
    item.data = item.data || {};
    item.stackInfo = {};
    var options = {};
    t.ensureItemHasSomethingToSay(item, options, function (e, i) {
      expect(i).to.be.ok();
      done(e);
    });
  });
  it('should do nothing if item has custom data', function (done) {
    var args = [];
    var item = itemFromArgs(args);
    item.custom = {};
    var options = {};
    t.ensureItemHasSomethingToSay(item, options, function (e, i) {
      expect(i).to.be.ok();
      done(e);
    });
  });
});

describe('addBaseInfo', function () {
  it('should add all of the expected data', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    item.level = 'critical';
    var options = {};
    t.addBaseInfo(item, options, function (e, i) {
      expect(i.data.level).to.eql('critical');
      expect(i.data.platform).to.eql('browser');
      expect(i.data.framework).to.eql('browser-js');
      expect(i.data.language).to.eql('javascript');
      expect(i.data.notifier.name).to.eql('rollbar-browser-js');
      done(e);
    });
  });
  it('should pull data from options', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = {
      environment: 'dev',
      endpoint: 'api.rollbar.com',
      version: '42',
    };
    t.addBaseInfo(item, options, function (e, i) {
      expect(i.data.environment).to.eql('dev');
      expect(i.data.endpoint).to.eql('api.rollbar.com');
      expect(i.data.notifier.version).to.eql('42');
      done(e);
    });
  });
  it('should pull environment from payload options', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = {
      payload: { environment: 'dev' },
    };
    t.addBaseInfo(item, options, function (e, i) {
      expect(i.data.environment).to.eql('dev');
      done(e);
    });
  });
});

describe('addRequestInfo', function () {
  it('should use window info to set request properties', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = { captureIp: 'anonymize' };
    t.addRequestInfo(window)(item, options, function (e, i) {
      expect(i.data.request).to.be.ok();
      expect(i.data.request.user_ip).to.eql('$remote_ip_anonymize');
      done(e);
    });
  });
  it('should do nothing without window', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    item.data = {};
    var options = {};
    var w = null;
    t.addRequestInfo(w)(item, options, function (e, i) {
      expect(i.data.request).to.not.be.ok();
      done(e);
    });
  });
  it('should honor captureIp without window', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    item.data = {};
    var options = { captureIp: true };
    var w = null;
    t.addRequestInfo(w)(item, options, function (e, i) {
      expect(i.data.request.url).to.not.be.ok();
      expect(i.data.request.query_string).to.not.be.ok();
      expect(i.data.request.user_ip).to.eql('$remote_ip');
      done(e);
    });
  });
});

describe('addClientInfo', function () {
  it('should do nothing without a window', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    item.data = {};
    var options = {};
    var w = null;
    t.addClientInfo(w)(item, options, function (e, i) {
      expect(i.data.client).to.not.be.ok();
      done(e);
    });
  });
  it('should use window info to set client properties', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = {};
    t.addClientInfo(window)(item, options, function (e, i) {
      expect(i.data.client).to.be.ok();
      expect(i.data.client.javascript).to.be.ok();
      done(e);
    });
  });
});

describe('addPluginInfo', function () {
  it('should do nothing without a window', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = {};
    var w = null;
    t.addPluginInfo(w)(item, options, function (e, i) {
      expect(
        i.data &&
          i.data.client &&
          i.data.client.javascript &&
          i.data.client.javascript.plugins,
      ).to.not.be.ok();
      done(e);
    });
  });
  it('should add plugin data from the window', function (done) {
    var args = ['a message'];
    var item = itemFromArgs(args);
    var options = {};
    var w = { navigator: { plugins: [] } };
    w.navigator.plugins.push({ name: 'plugin 1', description: '1' });
    w.navigator.plugins.push({ name: 'plugin 2', description: '2' });
    t.addPluginInfo(w)(item, options, function (e, i) {
      expect(i.data.client.javascript.plugins).to.be.ok();
      expect(i.data.client.javascript.plugins.length).to.eql(2);
      expect(i.data.client.javascript.plugins[0].name).to.eql('plugin 1');
      done(e);
    });
  });
});

describe('addBody', function () {
  describe('with stackInfo', function () {
    it('should use the stackInfo to add a trace to the body', function (done) {
      var err;
      try {
        throw new Error('bork');
      } catch (e) {
        err = e;
      }
      var args = ['a message', err, { custom: 'stuff' }];
      var item = itemFromArgs(args);
      item.description = 'borked';
      var options = {};
      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo).to.be.ok();
        t.addBody(i, options, function (e, i) {
          expect(i.data.body.trace).to.be.ok();
          done(e);
        });
      });
    });
    it('should add a message with a bad stackInfo', function (done) {
      var args = ['a message'];
      var item = itemFromArgs(args);
      item.description = 'borked';
      item.data = item.data || {};
      item.stackInfo = { name: 'bork' };
      var options = {};
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.trace).to.not.be.ok();
        expect(i.data.body.message.body).to.be.ok();
        done(e);
      });
    });
  });
  describe('without stackInfo', function () {
    it('should add a message as the body', function (done) {
      var args = ['a message', { custom: 'stuff' }];
      var item = itemFromArgs(args);
      var options = {};
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.message.body).to.be.ok();
        done(e);
      });
    });
    it('should send message when sent without a message', function (done) {
      var args = [{ custom: 'stuff' }];
      var item = itemFromArgs(args);
      var options = {};
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.message.body).to.eql(
          'Item sent with null or missing arguments.',
        );
        done(e);
      });
    });
  });
  describe('without stackInfo.name', function () {
    it('should set error class unknown', function (done) {
      var err;
      try {
        throw new Error('bork');
      } catch (e) {
        err = e;
      }
      var args = ['a message', err, { custom: 'stuff' }];
      var item = itemFromArgs(args);
      item.description = 'borked';
      var options = {};
      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo).to.be.ok();
        i.stackInfo.name = null; // force alternate path to determine error class.
        t.addBody(i, options, function (e, i) {
          expect(i.data.body.trace.exception.class).to.eql('(unknown)');
          expect(i.data.body.trace.exception.message).to.eql('bork');
          done(e);
        });
      });
    });
    describe('when config.guessErrorClass is set', function () {
      it('should guess error class ', function (done) {
        var err;
        try {
          throw new Error('GuessedError: bork');
        } catch (e) {
          err = e;
        }
        var args = [err, { custom: 'stuff' }];
        var item = itemFromArgs(args);
        item.description = 'borked';
        var options = { guessErrorClass: true };
        t.handleItemWithError(item, options, function (e, i) {
          expect(i.stackInfo).to.be.ok();
          i.stackInfo.name = null; // force alternate path to determine error class.
          t.addBody(i, options, function (e, i) {
            expect(i.data.body.trace.exception.class).to.eql('GuessedError');
            expect(i.data.body.trace.exception.message).to.eql('bork');
            done(e);
          });
        });
      });
      it('should set error class unknown', function (done) {
        var err;
        try {
          throw new Error('bork');
        } catch (e) {
          err = e;
        }
        var args = [err, { custom: 'stuff' }];
        var item = itemFromArgs(args);
        item.description = 'borked';
        var options = { guessErrorClass: true };
        t.handleItemWithError(item, options, function (e, i) {
          expect(i.stackInfo).to.be.ok();
          i.stackInfo.name = null; // force alternate path to determine error class.
          t.addBody(i, options, function (e, i) {
            expect(i.data.body.trace.exception.class).to.eql('(unknown)');
            expect(i.data.body.trace.exception.message).to.eql('bork');
            done(e);
          });
        });
      });
    });
  });
  describe('with nested error', function () {
    it('should create trace_chain', function (done) {
      var nestedErr = new Error('nested error');
      var err = new Error('test error');
      err.nested = nestedErr;
      var args = ['a message', err];
      var item = itemFromArgs(args);
      var options = {};
      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo).to.be.ok();
      });
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.trace_chain.length).to.eql(2);
        expect(i.data.body.trace_chain[0].exception.message).to.eql(
          'test error',
        );
        expect(i.data.body.trace_chain[1].exception.message).to.eql(
          'nested error',
        );
        done(e);
      });
    });
    it('should create add error context as custom data', function (done) {
      var nestedErr = new Error('nested error');
      nestedErr.rollbarContext = { err1: 'nested context' };
      var err = new Error('test error');
      err.rollbarContext = { err2: 'error context' };
      err.nested = nestedErr;
      var args = ['a message', err];
      var item = itemFromArgs(args);
      var options = { addErrorContext: true };
      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo).to.be.ok();
      });
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.trace_chain.length).to.eql(2);
        expect(i.data.custom.err1).to.eql('nested context');
        expect(i.data.custom.err2).to.eql('error context');
        done(e);
      });
    });
  });
  describe('with error cause', function () {
    // Error cause was introduced in Chrome 93.
    if (chromeMajorVersion() < 93) return;

    it('should create trace_chain', function (done) {
      var causeErr = new Error('cause error');
      var err = new Error('test error', { cause: causeErr });
      var args = ['a message', err];
      var item = itemFromArgs(args);
      var options = {};
      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo).to.be.ok();
      });
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.trace_chain.length).to.eql(2);
        expect(i.data.body.trace_chain[0].exception.message).to.eql(
          'test error',
        );
        expect(i.data.body.trace_chain[1].exception.message).to.eql(
          'cause error',
        );
        done(e);
      });
    });
    it('should create add error context as custom data', function (done) {
      var causeErr = new Error('cause error');
      causeErr.rollbarContext = { err1: 'cause context' };
      var err = new Error('test error', { cause: causeErr });
      err.rollbarContext = { err2: 'error context' };
      var args = ['a message', err];
      var item = itemFromArgs(args);
      var options = { addErrorContext: true };
      t.handleItemWithError(item, options, function (e, i) {
        expect(i.stackInfo).to.be.ok();
      });
      t.addBody(item, options, function (e, i) {
        expect(i.data.body.trace_chain.length).to.eql(2);
        expect(i.data.custom.err1).to.eql('cause context');
        expect(i.data.custom.err2).to.eql('error context');
        done(e);
      });
    });
  });
});

describe('scrubPayload', function () {
  it('only scrubs payload data', function (done) {
    var args = [
      'a message',
      { scooby: 'doo', okay: 'fizz=buzz&fuzz=baz', user: { id: 42 } },
    ];
    var item = itemFromArgs(args);
    var accessToken = 'abc123';
    var options = {
      endpoint: 'api.rollbar.com/',
      scrubFields: ['access_token', 'accessToken', 'scooby', 'fizz', 'user'],
    };
    var payload = {
      access_token: accessToken,
      data: item,
    };
    expect(payload.access_token).to.eql(accessToken);
    expect(payload.data.custom.scooby).to.eql('doo');
    expect(payload.data.custom.okay).to.eql('fizz=buzz&fuzz=baz');
    expect(payload.data.custom.user.id).to.eql(42);

    var scrub = __webpack_require__(/*! ../src/scrub */ "./src/scrub.js");
    t.addScrubber(scrub)(payload, options, function (e, i) {
      expect(i.access_token).to.eql(accessToken);
      expect(i.data.custom.scooby).to.not.eql('doo');
      expect(payload.data.custom.okay).to.not.eql('fizz=buzz&fuzz=baz');
      expect(payload.data.custom.okay).to.match(/fizz=\*+&fuzz=baz/);
      expect(payload.data.custom.user.id).to.not.be.ok();
      expect(payload.data.custom.user).to.match(/\*+/);
      expect(i.data.message).to.eql('a message');
      done(e);
    });
  });
});

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQ0FBcUMsU0FBUyxXQUFXLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxZQUFZO0FBQ3BCLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUZBQXVGO0FBQzdGLE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0saURBQWlEO0FBQ3ZELE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3Qyx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUErQztBQUN2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QUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkRBQTZEO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixhQUFhLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxLQUFLLHVCQUF1QiwyQkFBMkIsd0JBQXdCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHLEdBQUcsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVCQUF1QixnQkFBZ0I7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBLEtBQUs7QUFDTCxZQUFZLE9BQU87QUFDbkIsc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUF1RDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxrQ0FBa0M7QUFDbEMsMENBQTBDLGlCQUFpQjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBbUQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsb0NBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcnJ3ZWIvcmVjb3JkL2Rpc3QvcmVjb3JkLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvQHJyd2ViL3R5cGVzL2Rpc3QvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL25vZGVfbW9kdWxlcy9jb25zb2xlLXBvbHlmaWxsL2luZGV4LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvZXJyb3Itc3RhY2stcGFyc2VyL2Vycm9yLXN0YWNrLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9ub2RlX21vZHVsZXMvc3RhY2tmcmFtZS9zdGFja2ZyYW1lLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYXBpLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYXBpVXRpbGl0eS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvY29yZS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvZGVmYXVsdHMvc2NydWJGaWVsZHMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL2RldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvZG9tVXRpbGl0eS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvZ2xvYmFsU2V0dXAuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvcHJlZGljYXRlcy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvcmVwbGF5L2RlZmF1bHRzLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9yZXBsYXkvcmVjb3JkZXIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3JlcGxheS9yZXBsYXlNYXAuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3JvbGxiYXIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3RlbGVtZXRyeS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvdHJhbnNmb3Jtcy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvdHJhbnNwb3J0LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci90cmFuc3BvcnQvZmV0Y2guanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3RyYW5zcG9ydC94aHIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3VybC5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvd3JhcEdsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Vycm9yUGFyc2VyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9ub3RpZmllci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3ByZWRpY2F0ZXMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9xdWV1ZS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3JhdGVMaW1pdGVyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvcm9sbGJhci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3NjcnViLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdGVsZW1ldHJ5LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9jb250ZXh0LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9jb250ZXh0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3RyYWNpbmcvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL2V4cG9ydGVyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9ocnRpbWUuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL2lkLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9zZXNzaW9uLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9zcGFuLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9zcGFuUHJvY2Vzc29yLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy90cmFjZXIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL3RyYWNpbmcuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFuc2Zvcm1zLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJ1bmNhdGlvbi5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3V0aWxpdHkuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy91dGlsaXR5L2hlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy91dGlsaXR5L3BvbHlmaWxsSlNPTi5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3V0aWxpdHkvcmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3V0aWxpdHkvdHJhdmVyc2UuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3ZlbmRvci9KU09OLWpzL2pzb24zLmpzIiwid2VicGFjazovL3JvbGxiYXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3JvbGxiYXIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vdGVzdC9icm93c2VyLnRyYW5zZm9ybXMudGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG52YXIgX2E7XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbnZhciBOb2RlVHlwZSQzID0gLyogQF9fUFVSRV9fICovICgoTm9kZVR5cGUyKSA9PiB7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFwiXSA9IDBdID0gXCJEb2N1bWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRWxlbWVudFwiXSA9IDJdID0gXCJFbGVtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJUZXh0XCJdID0gM10gPSBcIlRleHRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDb21tZW50XCJdID0gNV0gPSBcIkNvbW1lbnRcIjtcbiAgcmV0dXJuIE5vZGVUeXBlMjtcbn0pKE5vZGVUeXBlJDMgfHwge30pO1xuY29uc3QgdGVzdGFibGVBY2Nlc3NvcnMkMSA9IHtcbiAgTm9kZTogW1wiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIiwgXCJwYXJlbnRFbGVtZW50XCIsIFwidGV4dENvbnRlbnRcIl0sXG4gIFNoYWRvd1Jvb3Q6IFtcImhvc3RcIiwgXCJzdHlsZVNoZWV0c1wiXSxcbiAgRWxlbWVudDogW1wic2hhZG93Um9vdFwiLCBcInF1ZXJ5U2VsZWN0b3JcIiwgXCJxdWVyeVNlbGVjdG9yQWxsXCJdLFxuICBNdXRhdGlvbk9ic2VydmVyOiBbXVxufTtcbmNvbnN0IHRlc3RhYmxlTWV0aG9kcyQxID0ge1xuICBOb2RlOiBbXCJjb250YWluc1wiLCBcImdldFJvb3ROb2RlXCJdLFxuICBTaGFkb3dSb290OiBbXCJnZXRTZWxlY3Rpb25cIl0sXG4gIEVsZW1lbnQ6IFtdLFxuICBNdXRhdGlvbk9ic2VydmVyOiBbXCJjb25zdHJ1Y3RvclwiXVxufTtcbmNvbnN0IHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMSA9IHt9O1xuY29uc3QgaXNBbmd1bGFyWm9uZVByZXNlbnQkMSA9ICgpID0+IHtcbiAgcmV0dXJuICEhZ2xvYmFsVGhpcy5ab25lO1xufTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSkge1xuICBpZiAodW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldO1xuICBjb25zdCBkZWZhdWx0T2JqID0gZ2xvYmFsVGhpc1trZXldO1xuICBjb25zdCBkZWZhdWx0UHJvdG90eXBlID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVBY2Nlc3NvcnMkMSA/IHRlc3RhYmxlQWNjZXNzb3JzJDFba2V5XSA6IHZvaWQgMDtcbiAgY29uc3QgaXNVbnRhaW50ZWRBY2Nlc3NvcnMgPSBCb29sZWFuKFxuICAgIGFjY2Vzc29yTmFtZXMgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgYWNjZXNzb3JOYW1lcy5ldmVyeShcbiAgICAgIChhY2Nlc3NvcikgPT4ge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICAgICAgKF9iID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdFByb3RvdHlwZSwgYWNjZXNzb3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKVxuICApO1xuICBjb25zdCBtZXRob2ROYW1lcyA9IGtleSBpbiB0ZXN0YWJsZU1ldGhvZHMkMSA/IHRlc3RhYmxlTWV0aG9kcyQxW2tleV0gOiB2b2lkIDA7XG4gIGNvbnN0IGlzVW50YWludGVkTWV0aG9kcyA9IEJvb2xlYW4oXG4gICAgbWV0aG9kTmFtZXMgJiYgbWV0aG9kTmFtZXMuZXZlcnkoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIiAmJiAoKF9hMiA9IGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b1N0cmluZygpLmluY2x1ZGVzKFwiW25hdGl2ZSBjb2RlXVwiKSk7XG4gICAgICB9XG4gICAgKVxuICApO1xuICBpZiAoaXNVbnRhaW50ZWRBY2Nlc3NvcnMgJiYgaXNVbnRhaW50ZWRNZXRob2RzICYmICFpc0FuZ3VsYXJab25lUHJlc2VudCQxKCkpIHtcbiAgICB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGlmcmFtZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICBjb25zdCB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgY29uc3QgdW50YWludGVkT2JqZWN0ID0gd2luW2tleV0ucHJvdG90eXBlO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgIGlmICghdW50YWludGVkT2JqZWN0KSByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0gPSB1bnRhaW50ZWRPYmplY3Q7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICB9XG59XG5jb25zdCB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDEgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtrZXl9LiR7U3RyaW5nKGFjY2Vzc29yKX1gO1xuICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XS5jYWxsKFxuICAgICAgaW5zdGFuY2VcbiAgICApO1xuICBjb25zdCB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpO1xuICBjb25zdCB1bnRhaW50ZWRBY2Nlc3NvciA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIHVudGFpbnRlZFByb3RvdHlwZSxcbiAgICBhY2Nlc3NvclxuICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldDtcbiAgaWYgKCF1bnRhaW50ZWRBY2Nlc3NvcikgcmV0dXJuIGluc3RhbmNlW2FjY2Vzc29yXTtcbiAgdW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XSA9IHVudGFpbnRlZEFjY2Vzc29yO1xuICByZXR1cm4gdW50YWludGVkQWNjZXNzb3IuY2FsbChpbnN0YW5jZSk7XG59XG5jb25zdCB1bnRhaW50ZWRNZXRob2RDYWNoZSQxID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRNZXRob2QkMShrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtrZXl9LiR7U3RyaW5nKG1ldGhvZCl9YDtcbiAgaWYgKHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldKVxuICAgIHJldHVybiB1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XS5iaW5kKFxuICAgICAgaW5zdGFuY2VcbiAgICApO1xuICBjb25zdCB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpO1xuICBjb25zdCB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgaWYgKHR5cGVvZiB1bnRhaW50ZWRNZXRob2QgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGluc3RhbmNlW21ldGhvZF07XG4gIHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldID0gdW50YWludGVkTWV0aG9kO1xuICByZXR1cm4gdW50YWludGVkTWV0aG9kLmJpbmQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2hpbGROb2RlcyQxKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJjaGlsZE5vZGVzXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZSQxKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnROb2RlXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50RWxlbWVudCQxKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnRFbGVtZW50XCIpO1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnQkMShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwidGV4dENvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBjb250YWlucyQxKG4yLCBvdGhlcikge1xuICByZXR1cm4gZ2V0VW50YWludGVkTWV0aG9kJDEoXCJOb2RlXCIsIG4yLCBcImNvbnRhaW5zXCIpKG90aGVyKTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlJDEobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZCQxKFwiTm9kZVwiLCBuMiwgXCJnZXRSb290Tm9kZVwiKSgpO1xufVxuZnVuY3Rpb24gaG9zdCQxKG4yKSB7XG4gIGlmICghbjIgfHwgIShcImhvc3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIlNoYWRvd1Jvb3RcIiwgbjIsIFwiaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIHN0eWxlU2hlZXRzJDEobjIpIHtcbiAgcmV0dXJuIG4yLnN0eWxlU2hlZXRzO1xufVxuZnVuY3Rpb24gc2hhZG93Um9vdCQxKG4yKSB7XG4gIGlmICghbjIgfHwgIShcInNoYWRvd1Jvb3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIkVsZW1lbnRcIiwgbjIsIFwic2hhZG93Um9vdFwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IkMShuMiwgc2VsZWN0b3JzKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsJDEobjIsIHNlbGVjdG9ycykge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvckFsbFwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gbXV0YXRpb25PYnNlcnZlckN0b3IkMSgpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZFByb3RvdHlwZSQxKFwiTXV0YXRpb25PYnNlcnZlclwiKS5jb25zdHJ1Y3Rvcjtcbn1cbmNvbnN0IGluZGV4JDEgPSB7XG4gIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMkMSxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSQxLFxuICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50JDEsXG4gIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCQxLFxuICBjb250YWluczogY29udGFpbnMkMSxcbiAgZ2V0Um9vdE5vZGU6IGdldFJvb3ROb2RlJDEsXG4gIGhvc3Q6IGhvc3QkMSxcbiAgc3R5bGVTaGVldHM6IHN0eWxlU2hlZXRzJDEsXG4gIHNoYWRvd1Jvb3Q6IHNoYWRvd1Jvb3QkMSxcbiAgcXVlcnlTZWxlY3RvcjogcXVlcnlTZWxlY3RvciQxLFxuICBxdWVyeVNlbGVjdG9yQWxsOiBxdWVyeVNlbGVjdG9yQWxsJDEsXG4gIG11dGF0aW9uT2JzZXJ2ZXI6IG11dGF0aW9uT2JzZXJ2ZXJDdG9yJDFcbn07XG5mdW5jdGlvbiBpc0VsZW1lbnQobjIpIHtcbiAgcmV0dXJuIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREU7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QobjIpIHtcbiAgY29uc3QgaG9zdEVsID0gKFxuICAgIC8vIGFuY2hvciBhbmQgdGV4dGFyZWEgZWxlbWVudHMgYWxzbyBoYXZlIGEgYGhvc3RgIHByb3BlcnR5XG4gICAgLy8gYnV0IG9ubHkgc2hhZG93IHJvb3RzIGhhdmUgYSBgbW9kZWAgcHJvcGVydHlcbiAgICBuMiAmJiBcImhvc3RcIiBpbiBuMiAmJiBcIm1vZGVcIiBpbiBuMiAmJiBpbmRleCQxLmhvc3QobjIpIHx8IG51bGxcbiAgKTtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgaG9zdEVsICYmIFwic2hhZG93Um9vdFwiIGluIGhvc3RFbCAmJiBpbmRleCQxLnNoYWRvd1Jvb3QoaG9zdEVsKSA9PT0gbjJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2hhZG93Um9vdDIpID09PSBcIltvYmplY3QgU2hhZG93Um9vdF1cIjtcbn1cbmZ1bmN0aW9uIGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1MoY3NzVGV4dCkge1xuICBpZiAoY3NzVGV4dC5pbmNsdWRlcyhcIiBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpICYmICFjc3NUZXh0LmluY2x1ZGVzKFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSkge1xuICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoXG4gICAgICAvXFxzYmFja2dyb3VuZC1jbGlwOlxccyp0ZXh0Oy9nLFxuICAgICAgXCIgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7IGJhY2tncm91bmQtY2xpcDogdGV4dDtcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5mdW5jdGlvbiBlc2NhcGVJbXBvcnRTdGF0ZW1lbnQocnVsZTIpIHtcbiAgY29uc3QgeyBjc3NUZXh0IH0gPSBydWxlMjtcbiAgaWYgKGNzc1RleHQuc3BsaXQoJ1wiJykubGVuZ3RoIDwgMykgcmV0dXJuIGNzc1RleHQ7XG4gIGNvbnN0IHN0YXRlbWVudCA9IFtcIkBpbXBvcnRcIiwgYHVybCgke0pTT04uc3RyaW5naWZ5KHJ1bGUyLmhyZWYpfSlgXTtcbiAgaWYgKHJ1bGUyLmxheWVyTmFtZSA9PT0gXCJcIikge1xuICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcmApO1xuICB9IGVsc2UgaWYgKHJ1bGUyLmxheWVyTmFtZSkge1xuICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcigke3J1bGUyLmxheWVyTmFtZX0pYCk7XG4gIH1cbiAgaWYgKHJ1bGUyLnN1cHBvcnRzVGV4dCkge1xuICAgIHN0YXRlbWVudC5wdXNoKGBzdXBwb3J0cygke3J1bGUyLnN1cHBvcnRzVGV4dH0pYCk7XG4gIH1cbiAgaWYgKHJ1bGUyLm1lZGlhLmxlbmd0aCkge1xuICAgIHN0YXRlbWVudC5wdXNoKHJ1bGUyLm1lZGlhLm1lZGlhVGV4dCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlbWVudC5qb2luKFwiIFwiKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVzaGVldChzMikge1xuICB0cnkge1xuICAgIGNvbnN0IHJ1bGVzMiA9IHMyLnJ1bGVzIHx8IHMyLmNzc1J1bGVzO1xuICAgIGlmICghcnVsZXMyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHNoZWV0SHJlZiA9IHMyLmhyZWY7XG4gICAgaWYgKCFzaGVldEhyZWYgJiYgczIub3duZXJOb2RlICYmIHMyLm93bmVyTm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICBzaGVldEhyZWYgPSBzMi5vd25lck5vZGUub3duZXJEb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdpZmllZFJ1bGVzID0gQXJyYXkuZnJvbShcbiAgICAgIHJ1bGVzMixcbiAgICAgIChydWxlMikgPT4gc3RyaW5naWZ5UnVsZShydWxlMiwgc2hlZXRIcmVmKVxuICAgICkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhzdHJpbmdpZmllZFJ1bGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlMiwgc2hlZXRIcmVmKSB7XG4gIGlmIChpc0NTU0ltcG9ydFJ1bGUocnVsZTIpKSB7XG4gICAgbGV0IGltcG9ydFN0cmluZ2lmaWVkO1xuICAgIHRyeSB7XG4gICAgICBpbXBvcnRTdHJpbmdpZmllZCA9IC8vIGZvciBzYW1lLW9yaWdpbiBzdHlsZXNoZWV0cyxcbiAgICAgIC8vIHdlIGNhbiBhY2Nlc3MgdGhlIGltcG9ydGVkIHN0eWxlc2hlZXQgcnVsZXMgZGlyZWN0bHlcbiAgICAgIHN0cmluZ2lmeVN0eWxlc2hlZXQocnVsZTIuc3R5bGVTaGVldCkgfHwgLy8gd29yayBhcm91bmQgYnJvd3NlciBpc3N1ZXMgd2l0aCB0aGUgcmF3IHN0cmluZyBgQGltcG9ydCB1cmwoLi4uKWAgc3RhdGVtZW50XG4gICAgICBlc2NhcGVJbXBvcnRTdGF0ZW1lbnQocnVsZTIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbXBvcnRTdHJpbmdpZmllZCA9IHJ1bGUyLmNzc1RleHQ7XG4gICAgfVxuICAgIGlmIChydWxlMi5zdHlsZVNoZWV0LmhyZWYpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyhpbXBvcnRTdHJpbmdpZmllZCwgcnVsZTIuc3R5bGVTaGVldC5ocmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydFN0cmluZ2lmaWVkO1xuICB9IGVsc2Uge1xuICAgIGxldCBydWxlU3RyaW5naWZpZWQgPSBydWxlMi5jc3NUZXh0O1xuICAgIGlmIChpc0NTU1N0eWxlUnVsZShydWxlMikgJiYgcnVsZTIuc2VsZWN0b3JUZXh0LmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgcnVsZVN0cmluZ2lmaWVkID0gZml4U2FmYXJpQ29sb25zKHJ1bGVTdHJpbmdpZmllZCk7XG4gICAgfVxuICAgIGlmIChzaGVldEhyZWYpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyhydWxlU3RyaW5naWZpZWQsIHNoZWV0SHJlZik7XG4gICAgfVxuICAgIHJldHVybiBydWxlU3RyaW5naWZpZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpeFNhZmFyaUNvbG9ucyhjc3NTdHJpbmdpZmllZCkge1xuICBjb25zdCByZWdleCA9IC8oXFxbKD86W1xcdy1dKylbXlxcXFxdKSg6KD86W1xcdy1dKylcXF0pL2dtO1xuICByZXR1cm4gY3NzU3RyaW5naWZpZWQucmVwbGFjZShyZWdleCwgXCIkMVxcXFwkMlwiKTtcbn1cbmZ1bmN0aW9uIGlzQ1NTSW1wb3J0UnVsZShydWxlMikge1xuICByZXR1cm4gXCJzdHlsZVNoZWV0XCIgaW4gcnVsZTI7XG59XG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlMikge1xuICByZXR1cm4gXCJzZWxlY3RvclRleHRcIiBpbiBydWxlMjtcbn1cbmNsYXNzIE1pcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlkTm9kZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJub2RlTWV0YU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gIH1cbiAgZ2V0SWQobjIpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghbjIpIHJldHVybiAtMTtcbiAgICBjb25zdCBpZCA9IChfYTIgPSB0aGlzLmdldE1ldGEobjIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlkO1xuICAgIHJldHVybiBpZCA/PyAtMTtcbiAgfVxuICBnZXROb2RlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRJZHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcbiAgfVxuICBnZXRNZXRhKG4yKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuZ2V0KG4yKSB8fCBudWxsO1xuICB9XG4gIC8vIHJlbW92ZXMgdGhlIG5vZGUgZnJvbSBpZE5vZGVNYXBcbiAgLy8gZG9lc24ndCByZW1vdmUgdGhlIG5vZGUgZnJvbSBub2RlTWV0YU1hcFxuICByZW1vdmVOb2RlRnJvbU1hcChuMikge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZChuMik7XG4gICAgdGhpcy5pZE5vZGVNYXAuZGVsZXRlKGlkKTtcbiAgICBpZiAobjIuY2hpbGROb2Rlcykge1xuICAgICAgbjIuY2hpbGROb2Rlcy5mb3JFYWNoKFxuICAgICAgICAoY2hpbGROb2RlKSA9PiB0aGlzLnJlbW92ZU5vZGVGcm9tTWFwKGNoaWxkTm9kZSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhcyhpZCkge1xuICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5oYXMoaWQpO1xuICB9XG4gIGhhc05vZGUobm9kZTIpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5oYXMobm9kZTIpO1xuICB9XG4gIGFkZChuMiwgbWV0YSkge1xuICAgIGNvbnN0IGlkID0gbWV0YS5pZDtcbiAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4yKTtcbiAgICB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gIH1cbiAgcmVwbGFjZShpZCwgbjIpIHtcbiAgICBjb25zdCBvbGROb2RlID0gdGhpcy5nZXROb2RlKGlkKTtcbiAgICBpZiAob2xkTm9kZSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xuICAgICAgaWYgKG1ldGEpIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pZE5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubm9kZU1ldGFNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWlycm9yJDIoKSB7XG4gIHJldHVybiBuZXcgTWlycm9yKCk7XG59XG5mdW5jdGlvbiBtYXNrSW5wdXRWYWx1ZSh7XG4gIGVsZW1lbnQsXG4gIG1hc2tJbnB1dE9wdGlvbnMsXG4gIHRhZ05hbWUsXG4gIHR5cGUsXG4gIHZhbHVlLFxuICBtYXNrSW5wdXRGblxufSkge1xuICBsZXQgdGV4dCA9IHZhbHVlIHx8IFwiXCI7XG4gIGNvbnN0IGFjdHVhbFR5cGUgPSB0eXBlICYmIHRvTG93ZXJDYXNlKHR5cGUpO1xuICBpZiAobWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IGFjdHVhbFR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1thY3R1YWxUeXBlXSkge1xuICAgIGlmIChtYXNrSW5wdXRGbikge1xuICAgICAgdGV4dCA9IG1hc2tJbnB1dEZuKHRleHQsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gXCIqXCIucmVwZWF0KHRleHQubGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuY29uc3QgT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgPSBcIl9fcnJ3ZWJfb3JpZ2luYWxfX1wiO1xuZnVuY3Rpb24gaXMyRENhbnZhc0JsYW5rKGNhbnZhcykge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpZiAoIWN0eCkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IDUwO1xuICBmb3IgKGxldCB4MiA9IDA7IHgyIDwgY2FudmFzLndpZHRoOyB4MiArPSBjaHVua1NpemUpIHtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkgKz0gY2h1bmtTaXplKSB7XG4gICAgICBjb25zdCBnZXRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhO1xuICAgICAgY29uc3Qgb3JpZ2luYWxHZXRJbWFnZURhdGEgPSBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSBpbiBnZXRJbWFnZURhdGEgPyBnZXRJbWFnZURhdGFbT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdIDogZ2V0SW1hZ2VEYXRhO1xuICAgICAgY29uc3QgcGl4ZWxCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgb3JpZ2luYWxHZXRJbWFnZURhdGEuY2FsbChcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgeDIsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy53aWR0aCAtIHgyKSxcbiAgICAgICAgICBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy5oZWlnaHQgLSB5KVxuICAgICAgICApLmRhdGEuYnVmZmVyXG4gICAgICApO1xuICAgICAgaWYgKHBpeGVsQnVmZmVyLnNvbWUoKHBpeGVsKSA9PiBwaXhlbCAhPT0gMCkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRJbnB1dFR5cGUoZWxlbWVudCkge1xuICBjb25zdCB0eXBlID0gZWxlbWVudC50eXBlO1xuICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJyLWlzLXBhc3N3b3JkXCIpID8gXCJwYXNzd29yZFwiIDogdHlwZSA/IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgdG9Mb3dlckNhc2UodHlwZSlcbiAgKSA6IG51bGw7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZUV4dGVuc2lvbihwYXRoLCBiYXNlVVJMKSB7XG4gIGxldCB1cmw7XG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMID8/IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVnZXggPSAvXFwuKFswLTlhLXpdKykoPzokKS9pO1xuICBjb25zdCBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XG4gIHJldHVybiAobWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoWzFdKSA/PyBudWxsO1xufVxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcbiAgbGV0IG9yaWdpbiA9IFwiXCI7XG4gIGlmICh1cmwuaW5kZXhPZihcIi8vXCIpID4gLTEpIHtcbiAgICBvcmlnaW4gPSB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpO1xuICB9IGVsc2Uge1xuICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIilbMF07XG4gIH1cbiAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KFwiP1wiKVswXTtcbiAgcmV0dXJuIG9yaWdpbjtcbn1cbmNvbnN0IFVSTF9JTl9DU1NfUkVGID0gL3VybFxcKCg/OignKShbXiddKiknfChcIikoLio/KVwifChbXildKikpXFwpL2dtO1xuY29uc3QgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XG5jb25zdCBVUkxfV1dXX01BVENIID0gL153d3dcXC4uKi9pO1xuY29uc3QgREFUQV9VUkkgPSAvXihkYXRhOikoW14sXSopLCguKikvaTtcbmZ1bmN0aW9uIGFic29sdXRpZnlVUkxzKGNzc1RleHQsIGhyZWYpIHtcbiAgcmV0dXJuIChjc3NUZXh0IHx8IFwiXCIpLnJlcGxhY2UoXG4gICAgVVJMX0lOX0NTU19SRUYsXG4gICAgKG9yaWdpbiwgcXVvdGUxLCBwYXRoMSwgcXVvdGUyLCBwYXRoMiwgcGF0aDMpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aDEgfHwgcGF0aDIgfHwgcGF0aDM7XG4gICAgICBjb25zdCBtYXliZVF1b3RlID0gcXVvdGUxIHx8IHF1b3RlMiB8fCBcIlwiO1xuICAgICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChEQVRBX1VSSS50ZXN0KGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVBhdGhbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2V4dHJhY3RPcmlnaW4oaHJlZikgKyBmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFjayA9IGhyZWYuc3BsaXQoXCIvXCIpO1xuICAgICAgY29uc3QgcGFydHMgPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtzdGFjay5qb2luKFwiL1wiKX0ke21heWJlUXVvdGV9KWA7XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZSgvKFxcL1xcKlteKl0qXFwqXFwvKXxbXFxzO10vZywgXCJcIik7XG59XG5mdW5jdGlvbiBzcGxpdENzc1RleHQoY3NzVGV4dCwgc3R5bGUpIHtcbiAgY29uc3QgY2hpbGROb2RlczIgPSBBcnJheS5mcm9tKHN0eWxlLmNoaWxkTm9kZXMpO1xuICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgaWYgKGNoaWxkTm9kZXMyLmxlbmd0aCA+IDEgJiYgY3NzVGV4dCAmJiB0eXBlb2YgY3NzVGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGNzc1RleHROb3JtID0gbm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQpO1xuICAgIGZvciAobGV0IGkyID0gMTsgaTIgPCBjaGlsZE5vZGVzMi5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGlmIChjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQgJiYgdHlwZW9mIGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB0ZXh0Q29udGVudE5vcm0gPSBub3JtYWxpemVDc3NTdHJpbmcoY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDM7IGogPCB0ZXh0Q29udGVudE5vcm0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBiaXQgPSB0ZXh0Q29udGVudE5vcm0uc3Vic3RyaW5nKDAsIGopO1xuICAgICAgICAgIGlmIChjc3NUZXh0Tm9ybS5zcGxpdChiaXQpLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXROb3JtID0gY3NzVGV4dE5vcm0uaW5kZXhPZihiaXQpO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IHNwbGl0Tm9ybTsgayA8IGNzc1RleHQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0LnN1YnN0cmluZygwLCBrKSkubGVuZ3RoID09PSBzcGxpdE5vcm0pIHtcbiAgICAgICAgICAgICAgICBzcGxpdHMucHVzaChjc3NUZXh0LnN1YnN0cmluZygwLCBrKSk7XG4gICAgICAgICAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQuc3Vic3RyaW5nKGspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3BsaXRzLnB1c2goY3NzVGV4dCk7XG4gIHJldHVybiBzcGxpdHM7XG59XG5mdW5jdGlvbiBtYXJrQ3NzU3BsaXRzKGNzc1RleHQsIHN0eWxlKSB7XG4gIHJldHVybiBzcGxpdENzc1RleHQoY3NzVGV4dCwgc3R5bGUpLmpvaW4oXCIvKiBycl9zcGxpdCAqL1wiKTtcbn1cbmxldCBfaWQgPSAxO1xuY29uc3QgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIlteYS16MC05LV86XVwiKTtcbmNvbnN0IElHTk9SRURfTk9ERSA9IC0yO1xuZnVuY3Rpb24gZ2VuSWQoKSB7XG4gIHJldHVybiBfaWQrKztcbn1cbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZSQxKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJmb3JtXCI7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc2VkVGFnTmFtZSA9IHRvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xuICAgIHJldHVybiBcImRpdlwiO1xuICB9XG4gIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xufVxubGV0IGNhbnZhc1NlcnZpY2U7XG5sZXQgY2FudmFzQ3R4O1xuY29uc3QgU1JDU0VUX05PVF9TUEFDRVMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy87XG5jb25zdCBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcbmZ1bmN0aW9uIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcbiAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbiAgfVxuICBsZXQgcG9zID0gMDtcbiAgZnVuY3Rpb24gY29sbGVjdENoYXJhY3RlcnMocmVnRXgpIHtcbiAgICBsZXQgY2hhcnMyO1xuICAgIGNvbnN0IG1hdGNoID0gcmVnRXguZXhlYyhhdHRyaWJ1dGVWYWx1ZS5zdWJzdHJpbmcocG9zKSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjaGFyczIgPSBtYXRjaFswXTtcbiAgICAgIHBvcyArPSBjaGFyczIubGVuZ3RoO1xuICAgICAgcmV0dXJuIGNoYXJzMjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMpO1xuICAgIGlmIChwb3MgPj0gYXR0cmlidXRlVmFsdWUubGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9OT1RfU1BBQ0VTKTtcbiAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XG4gICAgICBvdXRwdXQucHVzaCh1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVzY3JpcHRvcnNTdHIgPSBcIlwiO1xuICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybCk7XG4gICAgICBsZXQgaW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGMyID0gYXR0cmlidXRlVmFsdWUuY2hhckF0KHBvcyk7XG4gICAgICAgIGlmIChjMiA9PT0gXCJcIikge1xuICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICghaW5QYXJlbnMpIHtcbiAgICAgICAgICBpZiAoYzIgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYzIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICBpblBhcmVucyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjMiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlc2NyaXB0b3JzU3RyICs9IGMyO1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKFwiLCBcIik7XG59XG5jb25zdCBjYWNoZWREb2N1bWVudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYWJzb2x1dGVUb0RvYyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gIGlmICghYXR0cmlidXRlVmFsdWUgfHwgYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRIcmVmKGRvYywgYXR0cmlidXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsKSB7XG4gIHJldHVybiBCb29sZWFuKGVsLnRhZ05hbWUgPT09IFwic3ZnXCIgfHwgZWwub3duZXJTVkdFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhyZWYoZG9jLCBjdXN0b21IcmVmKSB7XG4gIGxldCBhMiA9IGNhY2hlZERvY3VtZW50LmdldChkb2MpO1xuICBpZiAoIWEyKSB7XG4gICAgYTIgPSBkb2MuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgY2FjaGVkRG9jdW1lbnQuc2V0KGRvYywgYTIpO1xuICB9XG4gIGlmICghY3VzdG9tSHJlZikge1xuICAgIGN1c3RvbUhyZWYgPSBcIlwiO1xuICB9IGVsc2UgaWYgKGN1c3RvbUhyZWYuc3RhcnRzV2l0aChcImJsb2I6XCIpIHx8IGN1c3RvbUhyZWYuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIGN1c3RvbUhyZWY7XG4gIH1cbiAgYTIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBjdXN0b21IcmVmKTtcbiAgcmV0dXJuIGEyLmhyZWY7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChuYW1lID09PSBcInNyY1wiIHx8IG5hbWUgPT09IFwiaHJlZlwiICYmICEodGFnTmFtZSA9PT0gXCJ1c2VcIiAmJiB2YWx1ZVswXSA9PT0gXCIjXCIpKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ4bGluazpocmVmXCIgJiYgdmFsdWVbMF0gIT09IFwiI1wiKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJiYWNrZ3JvdW5kXCIgJiYgKHRhZ05hbWUgPT09IFwidGFibGVcIiB8fCB0YWdOYW1lID09PSBcInRkXCIgfHwgdGFnTmFtZSA9PT0gXCJ0aFwiKSkge1xuICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3Jjc2V0XCIpIHtcbiAgICByZXR1cm4gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgcmV0dXJuIGFic29sdXRpZnlVUkxzKHZhbHVlLCBnZXRIcmVmKGRvYykpO1xuICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IFwib2JqZWN0XCIgJiYgbmFtZSA9PT0gXCJkYXRhXCIpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgbmFtZSwgX3ZhbHVlKSB7XG4gIHJldHVybiAodGFnTmFtZSA9PT0gXCJ2aWRlb1wiIHx8IHRhZ05hbWUgPT09IFwiYXVkaW9cIikgJiYgbmFtZSA9PT0gXCJhdXRvcGxheVwiO1xufVxuZnVuY3Rpb24gX2lzQmxvY2tlZEVsZW1lbnQoZWxlbWVudCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBlSW5kZXggPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOyApIHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc0xpc3RbZUluZGV4XTtcbiAgICAgICAgaWYgKGJsb2NrQ2xhc3MudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoYmxvY2tTZWxlY3Rvcik7XG4gICAgfVxuICB9IGNhdGNoIChlMikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUyLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgaWYgKCFub2RlMikgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZTIubm9kZVR5cGUgIT09IG5vZGUyLkVMRU1FTlRfTk9ERSkge1xuICAgIGlmICghY2hlY2tBbmNlc3RvcnMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgoaW5kZXgkMS5wYXJlbnROb2RlKG5vZGUyKSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcbiAgfVxuICBmb3IgKGxldCBlSW5kZXggPSBub2RlMi5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTsgKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gbm9kZTIuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgaWYgKHJlZ2V4LnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghY2hlY2tBbmNlc3RvcnMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KGluZGV4JDEucGFyZW50Tm9kZShub2RlMiksIHJlZ2V4LCBjaGVja0FuY2VzdG9ycyk7XG59XG5mdW5jdGlvbiBuZWVkTWFza2luZ1RleHQobm9kZTIsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XG4gIGxldCBlbDtcbiAgaWYgKGlzRWxlbWVudChub2RlMikpIHtcbiAgICBlbCA9IG5vZGUyO1xuICAgIGlmICghaW5kZXgkMS5jaGlsZE5vZGVzKGVsKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5kZXgkMS5wYXJlbnRFbGVtZW50KG5vZGUyKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBlbCA9IGluZGV4JDEucGFyZW50RWxlbWVudChub2RlMik7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIG1hc2tUZXh0Q2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChjaGVja0FuY2VzdG9ycykge1xuICAgICAgICBpZiAoZWwuY2xvc2VzdChgLiR7bWFza1RleHRDbGFzc31gKSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG1hc2tUZXh0Q2xhc3MpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBtYXNrVGV4dENsYXNzLCBjaGVja0FuY2VzdG9ycykpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobWFza1RleHRTZWxlY3Rvcikge1xuICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgICAgIGlmIChlbC5jbG9zZXN0KG1hc2tUZXh0U2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKG1hc2tUZXh0U2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25jZUlmcmFtZUxvYWRlZChpZnJhbWVFbCwgbGlzdGVuZXIsIGlmcmFtZUxvYWRUaW1lb3V0KSB7XG4gIGNvbnN0IHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gIGlmICghd2luKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBmaXJlZCA9IGZhbHNlO1xuICBsZXQgcmVhZHlTdGF0ZTtcbiAgdHJ5IHtcbiAgICByZWFkeVN0YXRlID0gd2luLmRvY3VtZW50LnJlYWR5U3RhdGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFmaXJlZCkge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xuICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBibGFua1VybCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fCBpZnJhbWVFbC5zcmMgPT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gXCJcIikge1xuICAgIHNldFRpbWVvdXQobGlzdGVuZXIsIDApO1xuICAgIHJldHVybiBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsaXN0ZW5lcik7XG4gIH1cbiAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gb25jZVN0eWxlc2hlZXRMb2FkZWQobGluaywgbGlzdGVuZXIsIHN0eWxlU2hlZXRMb2FkVGltZW91dCkge1xuICBsZXQgZmlyZWQgPSBmYWxzZTtcbiAgbGV0IHN0eWxlU2hlZXRMb2FkZWQ7XG4gIHRyeSB7XG4gICAgc3R5bGVTaGVldExvYWRlZCA9IGxpbmsuc2hlZXQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzdHlsZVNoZWV0TG9hZGVkKSByZXR1cm47XG4gIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHN0eWxlU2hlZXRMb2FkVGltZW91dCk7XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgZmlyZWQgPSB0cnVlO1xuICAgIGxpc3RlbmVyKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZG9jLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgbmVlZHNNYXNrLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgZGF0YVVSTE9wdGlvbnMgPSB7fSxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLFxuICAgIGNzc0NhcHR1cmVkID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJvb3RJZCA9IGdldFJvb3RJZChkb2MsIG1pcnJvcjIpO1xuICBzd2l0Y2ggKG4yLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBuMi5ET0NVTUVOVF9OT0RFOlxuICAgICAgaWYgKG4yLmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudCxcbiAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICBjb21wYXRNb2RlOiBuMi5jb21wYXRNb2RlXG4gICAgICAgICAgLy8gcHJvYmFibHkgXCJCYWNrQ29tcGF0XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudCxcbiAgICAgICAgICBjaGlsZE5vZGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgbjIuRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudFR5cGUsXG4gICAgICAgIG5hbWU6IG4yLm5hbWUsXG4gICAgICAgIHB1YmxpY0lkOiBuMi5wdWJsaWNJZCxcbiAgICAgICAgc3lzdGVtSWQ6IG4yLnN5c3RlbUlkLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgY2FzZSBuMi5FTEVNRU5UX05PREU6XG4gICAgICByZXR1cm4gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIHtcbiAgICAgICAgZG9jLFxuICAgICAgICBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgIGlubGluZUltYWdlcyxcbiAgICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50LFxuICAgICAgICByb290SWRcbiAgICAgIH0pO1xuICAgIGNhc2UgbjIuVEVYVF9OT0RFOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4yLCB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgbmVlZHNNYXNrLFxuICAgICAgICBtYXNrVGV4dEZuLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGNzc0NhcHR1cmVkXG4gICAgICB9KTtcbiAgICBjYXNlIG4yLkNEQVRBX1NFQ1RJT05fTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuQ0RBVEEsXG4gICAgICAgIHRleHRDb250ZW50OiBcIlwiLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgY2FzZSBuMi5DT01NRU5UX05PREU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkNvbW1lbnQsXG4gICAgICAgIHRleHRDb250ZW50OiBpbmRleCQxLnRleHRDb250ZW50KG4yKSB8fCBcIlwiLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Um9vdElkKGRvYywgbWlycm9yMikge1xuICBpZiAoIW1pcnJvcjIuaGFzTm9kZShkb2MpKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBkb2NJZCA9IG1pcnJvcjIuZ2V0SWQoZG9jKTtcbiAgcmV0dXJuIGRvY0lkID09PSAxID8gdm9pZCAwIDogZG9jSWQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZShuMiwgb3B0aW9ucykge1xuICBjb25zdCB7IG5lZWRzTWFzaywgbWFza1RleHRGbiwgcm9vdElkLCBjc3NDYXB0dXJlZCB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGFyZW50ID0gaW5kZXgkMS5wYXJlbnROb2RlKG4yKTtcbiAgY29uc3QgcGFyZW50VGFnTmFtZSA9IHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZTtcbiAgbGV0IHRleHRDb250ZW50MiA9IFwiXCI7XG4gIGNvbnN0IGlzU3R5bGUgPSBwYXJlbnRUYWdOYW1lID09PSBcIlNUWUxFXCIgPyB0cnVlIDogdm9pZCAwO1xuICBjb25zdCBpc1NjcmlwdCA9IHBhcmVudFRhZ05hbWUgPT09IFwiU0NSSVBUXCIgPyB0cnVlIDogdm9pZCAwO1xuICBpZiAoaXNTY3JpcHQpIHtcbiAgICB0ZXh0Q29udGVudDIgPSBcIlNDUklQVF9QTEFDRUhPTERFUlwiO1xuICB9IGVsc2UgaWYgKCFjc3NDYXB0dXJlZCkge1xuICAgIHRleHRDb250ZW50MiA9IGluZGV4JDEudGV4dENvbnRlbnQobjIpO1xuICAgIGlmIChpc1N0eWxlICYmIHRleHRDb250ZW50Mikge1xuICAgICAgdGV4dENvbnRlbnQyID0gYWJzb2x1dGlmeVVSTHModGV4dENvbnRlbnQyLCBnZXRIcmVmKG9wdGlvbnMuZG9jKSk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTdHlsZSAmJiAhaXNTY3JpcHQgJiYgdGV4dENvbnRlbnQyICYmIG5lZWRzTWFzaykge1xuICAgIHRleHRDb250ZW50MiA9IG1hc2tUZXh0Rm4gPyBtYXNrVGV4dEZuKHRleHRDb250ZW50MiwgaW5kZXgkMS5wYXJlbnRFbGVtZW50KG4yKSkgOiB0ZXh0Q29udGVudDIucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogTm9kZVR5cGUkMy5UZXh0LFxuICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudDIgfHwgXCJcIixcbiAgICByb290SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkb2MsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIGRhdGFVUkxPcHRpb25zID0ge30sXG4gICAgaW5saW5lSW1hZ2VzLFxuICAgIHJlY29yZENhbnZhcyxcbiAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSxcbiAgICByb290SWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5lZWRCbG9jayA9IF9pc0Jsb2NrZWRFbGVtZW50KG4yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgY29uc3QgdGFnTmFtZSA9IGdldFZhbGlkVGFnTmFtZSQxKG4yKTtcbiAgbGV0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbGVuID0gbjIuYXR0cmlidXRlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBsZW47IGkyKyspIHtcbiAgICBjb25zdCBhdHRyID0gbjIuYXR0cmlidXRlc1tpMl07XG4gICAgaWYgKCFpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSkge1xuICAgICAgYXR0cmlidXRlc1thdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKFxuICAgICAgICBkb2MsXG4gICAgICAgIHRhZ05hbWUsXG4gICAgICAgIHRvTG93ZXJDYXNlKGF0dHIubmFtZSksXG4gICAgICAgIGF0dHIudmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImxpbmtcIiAmJiBpbmxpbmVTdHlsZXNoZWV0KSB7XG4gICAgY29uc3Qgc3R5bGVzaGVldCA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maW5kKChzMikgPT4ge1xuICAgICAgcmV0dXJuIHMyLmhyZWYgPT09IG4yLmhyZWY7XG4gICAgfSk7XG4gICAgbGV0IGNzc1RleHQgPSBudWxsO1xuICAgIGlmIChzdHlsZXNoZWV0KSB7XG4gICAgICBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChzdHlsZXNoZWV0KTtcbiAgICB9XG4gICAgaWYgKGNzc1RleHQpIHtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJlbDtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmhyZWY7XG4gICAgICBhdHRyaWJ1dGVzLl9jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwic3R5bGVcIiAmJiBuMi5zaGVldCkge1xuICAgIGxldCBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChcbiAgICAgIG4yLnNoZWV0XG4gICAgKTtcbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgaWYgKG4yLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjc3NUZXh0ID0gbWFya0Nzc1NwbGl0cyhjc3NUZXh0LCBuMik7XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzLl9jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiaW5wdXRcIiB8fCB0YWdOYW1lID09PSBcInRleHRhcmVhXCIgfHwgdGFnTmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgIGNvbnN0IHZhbHVlID0gbjIudmFsdWU7XG4gICAgY29uc3QgY2hlY2tlZCA9IG4yLmNoZWNrZWQ7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJyYWRpb1wiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJjaGVja2JveFwiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJzdWJtaXRcIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwiYnV0dG9uXCIgJiYgdmFsdWUpIHtcbiAgICAgIGF0dHJpYnV0ZXMudmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgIGVsZW1lbnQ6IG4yLFxuICAgICAgICB0eXBlOiBnZXRJbnB1dFR5cGUobjIpLFxuICAgICAgICB0YWdOYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgbWFza0lucHV0Rm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2hlY2tlZCkge1xuICAgICAgYXR0cmlidXRlcy5jaGVja2VkID0gY2hlY2tlZDtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgICBpZiAobjIuc2VsZWN0ZWQgJiYgIW1hc2tJbnB1dE9wdGlvbnNbXCJzZWxlY3RcIl0pIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiZGlhbG9nXCIgJiYgbjIub3Blbikge1xuICAgIGF0dHJpYnV0ZXMucnJfb3Blbl9tb2RlID0gbjIubWF0Y2hlcyhcImRpYWxvZzptb2RhbFwiKSA/IFwibW9kYWxcIiA6IFwibm9uLW1vZGFsXCI7XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiY2FudmFzXCIgJiYgcmVjb3JkQ2FudmFzKSB7XG4gICAgaWYgKG4yLl9fY29udGV4dCA9PT0gXCIyZFwiKSB7XG4gICAgICBpZiAoIWlzMkRDYW52YXNCbGFuayhuMikpIHtcbiAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gbjIudG9EYXRhVVJMKFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMucXVhbGl0eVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcIl9fY29udGV4dFwiIGluIG4yKSkge1xuICAgICAgY29uc3QgY2FudmFzRGF0YVVSTCA9IG4yLnRvRGF0YVVSTChcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMucXVhbGl0eVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGJsYW5rQ2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBibGFua0NhbnZhcy53aWR0aCA9IG4yLndpZHRoO1xuICAgICAgYmxhbmtDYW52YXMuaGVpZ2h0ID0gbjIuaGVpZ2h0O1xuICAgICAgY29uc3QgYmxhbmtDYW52YXNEYXRhVVJMID0gYmxhbmtDYW52YXMudG9EYXRhVVJMKFxuICAgICAgICBkYXRhVVJMT3B0aW9ucy50eXBlLFxuICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICApO1xuICAgICAgaWYgKGNhbnZhc0RhdGFVUkwgIT09IGJsYW5rQ2FudmFzRGF0YVVSTCkge1xuICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNEYXRhVVJMO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJpbWdcIiAmJiBpbmxpbmVJbWFnZXMpIHtcbiAgICBpZiAoIWNhbnZhc1NlcnZpY2UpIHtcbiAgICAgIGNhbnZhc1NlcnZpY2UgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhc0N0eCA9IGNhbnZhc1NlcnZpY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IG4yO1xuICAgIGNvbnN0IGltYWdlU3JjID0gaW1hZ2UuY3VycmVudFNyYyB8fCBpbWFnZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCI8dW5rbm93bi1zcmM+XCI7XG4gICAgY29uc3QgcHJpb3JDcm9zc09yaWdpbiA9IGltYWdlLmNyb3NzT3JpZ2luO1xuICAgIGNvbnN0IHJlY29yZElubGluZUltYWdlID0gKCkgPT4ge1xuICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FudmFzU2VydmljZS53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICBjYW52YXNDdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzU2VydmljZS50b0RhdGFVUkwoXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luICE9PSBcImFub255bW91c1wiKSB7XG4gICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApXG4gICAgICAgICAgICByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgICAgICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgQ2Fubm90IGlubGluZSBpbWcgc3JjPSR7aW1hZ2VTcmN9ISBFcnJvcjogJHtlcnJ9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS5jcm9zc09yaWdpbiA9PT0gXCJhbm9ueW1vdXNcIikge1xuICAgICAgICBwcmlvckNyb3NzT3JpZ2luID8gYXR0cmlidXRlcy5jcm9zc09yaWdpbiA9IHByaW9yQ3Jvc3NPcmlnaW4gOiBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApIHJlY29yZElubGluZUltYWdlKCk7XG4gICAgZWxzZSBpbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiYXVkaW9cIiB8fCB0YWdOYW1lID09PSBcInZpZGVvXCIpIHtcbiAgICBjb25zdCBtZWRpYUF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVN0YXRlID0gbjIucGF1c2VkID8gXCJwYXVzZWRcIiA6IFwicGxheWVkXCI7XG4gICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhQ3VycmVudFRpbWUgPSBuMi5jdXJyZW50VGltZTtcbiAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFQbGF5YmFja1JhdGUgPSBuMi5wbGF5YmFja1JhdGU7XG4gICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTXV0ZWQgPSBuMi5tdXRlZDtcbiAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFMb29wID0gbjIubG9vcDtcbiAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFWb2x1bWUgPSBuMi52b2x1bWU7XG4gIH1cbiAgaWYgKCFuZXdseUFkZGVkRWxlbWVudCkge1xuICAgIGlmIChuMi5zY3JvbGxMZWZ0KSB7XG4gICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbExlZnQgPSBuMi5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBpZiAobjIuc2Nyb2xsVG9wKSB7XG4gICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbFRvcCA9IG4yLnNjcm9sbFRvcDtcbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRCbG9jaykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbjIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgYXR0cmlidXRlcyA9IHtcbiAgICAgIGNsYXNzOiBhdHRyaWJ1dGVzLmNsYXNzLFxuICAgICAgcnJfd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgIHJyX2hlaWdodDogYCR7aGVpZ2h0fXB4YFxuICAgIH07XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiaWZyYW1lXCIgJiYgIWtlZXBJZnJhbWVTcmNGbihhdHRyaWJ1dGVzLnNyYykpIHtcbiAgICBpZiAoIW4yLmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgYXR0cmlidXRlcy5ycl9zcmMgPSBhdHRyaWJ1dGVzLnNyYztcbiAgICB9XG4gICAgZGVsZXRlIGF0dHJpYnV0ZXMuc3JjO1xuICB9XG4gIGxldCBpc0N1c3RvbUVsZW1lbnQ7XG4gIHRyeSB7XG4gICAgaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkgaXNDdXN0b21FbGVtZW50ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IE5vZGVUeXBlJDMuRWxlbWVudCxcbiAgICB0YWdOYW1lLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGROb2RlczogW10sXG4gICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuMikgfHwgdm9pZCAwLFxuICAgIG5lZWRCbG9jayxcbiAgICByb290SWQsXG4gICAgaXNDdXN0b206IGlzQ3VzdG9tRWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gbG93ZXJJZkV4aXN0cyhtYXliZUF0dHIpIHtcbiAgaWYgKG1heWJlQXR0ciA9PT0gdm9pZCAwIHx8IG1heWJlQXR0ciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gc2xpbURPTUV4Y2x1ZGVkKHNuLCBzbGltRE9NT3B0aW9ucykge1xuICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZSQzLkNvbW1lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpIHtcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuc2NyaXB0ICYmIC8vIHNjcmlwdCB0YWdcbiAgICAoc24udGFnTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCAvLyAobW9kdWxlKXByZWxvYWQgbGlua1xuICAgIHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIChzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgfHwgc24uYXR0cmlidXRlcy5yZWwgPT09IFwibW9kdWxlcHJlbG9hZFwiKSAmJiBzbi5hdHRyaWJ1dGVzLmFzID09PSBcInNjcmlwdFwiIHx8IC8vIHByZWZldGNoIGxpbmtcbiAgICBzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVmZXRjaFwiICYmIHR5cGVvZiBzbi5hdHRyaWJ1dGVzLmhyZWYgPT09IFwic3RyaW5nXCIgJiYgZXh0cmFjdEZpbGVFeHRlbnNpb24oc24uYXR0cmlidXRlcy5ocmVmKSA9PT0gXCJqc1wiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkRmF2aWNvbiAmJiAoc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwic2hvcnRjdXQgaWNvblwiIHx8IHNuLnRhZ05hbWUgPT09IFwibWV0YVwiICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goXG4gICAgICAvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkL1xuICAgICkgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImFwcGxpY2F0aW9uLW5hbWVcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJpY29uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiYXBwbGUtdG91Y2gtaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcInNob3J0Y3V0IGljb25cIikpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNuLnRhZ05hbWUgPT09IFwibWV0YVwiKSB7XG4gICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFEZXNjS2V5d29yZHMgJiYgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eZGVzY3JpcHRpb258a2V5d29yZHMkLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhU29jaWFsICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eKG9nfHR3aXR0ZXJ8ZmIpOi8pIHx8IC8vIG9nID0gb3BlbmdyYXBoIChmYWNlYm9vaylcbiAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXihvZ3x0d2l0dGVyKTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicGludGVyZXN0XCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVJvYm90cyAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInJvYm90c1wiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnb29nbGVib3RcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYmluZ2JvdFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFIdHRwRXF1aXYgJiYgc24uYXR0cmlidXRlc1tcImh0dHAtZXF1aXZcIl0gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFBdXRob3JzaGlwICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYXV0aG9yXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdlbmVyYXRvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJmcmFtZXdvcmtcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicHVibGlzaGVyXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInByb2dpZFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15wcm9kdWN0Oi8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFWZXJpZmljYXRpb24gJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnb29nbGUtc2l0ZS12ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwieWFuZGV4LXZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJjc3JmLXRva2VuXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInA6ZG9tYWluX3ZlcmlmeVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ2ZXJpZnktdjFcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwidmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInNob3BpZnktY2hlY2tvdXQtYXBpLXRva2VuXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkb2MsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBtYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgc2tpcENoaWxkID0gZmFsc2UsXG4gICAgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgc2xpbURPTU9wdGlvbnMsXG4gICAgZGF0YVVSTE9wdGlvbnMgPSB7fSxcbiAgICBpbmxpbmVJbWFnZXMgPSBmYWxzZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICBvblNlcmlhbGl6ZSxcbiAgICBvbklmcmFtZUxvYWQsXG4gICAgaWZyYW1lTG9hZFRpbWVvdXQgPSA1ZTMsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQgPSA1ZTMsXG4gICAga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsXG4gICAgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSxcbiAgICBjc3NDYXB0dXJlZCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgeyBuZWVkc01hc2sgfSA9IG9wdGlvbnM7XG4gIGxldCB7IHByZXNlcnZlV2hpdGVTcGFjZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gIGlmICghbmVlZHNNYXNrKSB7XG4gICAgY29uc3QgY2hlY2tBbmNlc3RvcnMgPSBuZWVkc01hc2sgPT09IHZvaWQgMDtcbiAgICBuZWVkc01hc2sgPSBuZWVkTWFza2luZ1RleHQoXG4gICAgICBuMixcbiAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgY2hlY2tBbmNlc3RvcnNcbiAgICApO1xuICB9XG4gIGNvbnN0IF9zZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZU5vZGUobjIsIHtcbiAgICBkb2MsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBuZWVkc01hc2ssXG4gICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgaW5saW5lSW1hZ2VzLFxuICAgIHJlY29yZENhbnZhcyxcbiAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgbmV3bHlBZGRlZEVsZW1lbnQsXG4gICAgY3NzQ2FwdHVyZWRcbiAgfSk7XG4gIGlmICghX3NlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc29sZS53YXJuKG4yLCBcIm5vdCBzZXJpYWxpemVkXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBpZDtcbiAgaWYgKG1pcnJvcjIuaGFzTm9kZShuMikpIHtcbiAgICBpZCA9IG1pcnJvcjIuZ2V0SWQobjIpO1xuICB9IGVsc2UgaWYgKHNsaW1ET01FeGNsdWRlZChfc2VyaWFsaXplZE5vZGUsIHNsaW1ET01PcHRpb25zKSB8fCAhcHJlc2VydmVXaGl0ZVNwYWNlICYmIF9zZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLlRleHQgJiYgIV9zZXJpYWxpemVkTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nbSwgXCJcIikubGVuZ3RoKSB7XG4gICAgaWQgPSBJR05PUkVEX05PREU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBnZW5JZCgpO1xuICB9XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gT2JqZWN0LmFzc2lnbihfc2VyaWFsaXplZE5vZGUsIHsgaWQgfSk7XG4gIG1pcnJvcjIuYWRkKG4yLCBzZXJpYWxpemVkTm9kZSk7XG4gIGlmIChpZCA9PT0gSUdOT1JFRF9OT0RFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9uU2VyaWFsaXplKSB7XG4gICAgb25TZXJpYWxpemUobjIpO1xuICB9XG4gIGxldCByZWNvcmRDaGlsZCA9ICFza2lwQ2hpbGQ7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpIHtcbiAgICByZWNvcmRDaGlsZCA9IHJlY29yZENoaWxkICYmICFzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcbiAgICBjb25zdCBzaGFkb3dSb290RWwgPSBpbmRleCQxLnNoYWRvd1Jvb3QobjIpO1xuICAgIGlmIChzaGFkb3dSb290RWwgJiYgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdEVsKSlcbiAgICAgIHNlcmlhbGl6ZWROb2RlLmlzU2hhZG93SG9zdCA9IHRydWU7XG4gIH1cbiAgaWYgKChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkRvY3VtZW50IHx8IHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkgJiYgcmVjb3JkQ2hpbGQpIHtcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZFdoaXRlc3BhY2UgJiYgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwiaGVhZFwiKSB7XG4gICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYnlwYXNzT3B0aW9ucyA9IHtcbiAgICAgIGRvYyxcbiAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgbmVlZHNNYXNrLFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBza2lwQ2hpbGQsXG4gICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICBtYXNrSW5wdXRGbixcbiAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICByZWNvcmRDYW52YXMsXG4gICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICBvblNlcmlhbGl6ZSxcbiAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgIGNzc0NhcHR1cmVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcInRleHRhcmVhXCIgJiYgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy52YWx1ZSAhPT0gdm9pZCAwKSA7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuX2Nzc1RleHQgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5fY3NzVGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBieXBhc3NPcHRpb25zLmNzc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGROIG9mIEFycmF5LmZyb20oaW5kZXgkMS5jaGlsZE5vZGVzKG4yKSkpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcbiAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNoYWRvd1Jvb3RFbCA9IG51bGw7XG4gICAgaWYgKGlzRWxlbWVudChuMikgJiYgKHNoYWRvd1Jvb3RFbCA9IGluZGV4JDEuc2hhZG93Um9vdChuMikpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkTiBvZiBBcnJheS5mcm9tKGluZGV4JDEuY2hpbGROb2RlcyhzaGFkb3dSb290RWwpKSkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xuICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xuICAgICAgICAgIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3RFbCkgJiYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUuaXNTaGFkb3cgPSB0cnVlKTtcbiAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gaW5kZXgkMS5wYXJlbnROb2RlKG4yKTtcbiAgaWYgKHBhcmVudCAmJiBpc1NoYWRvd1Jvb3QocGFyZW50KSAmJiBpc05hdGl2ZVNoYWRvd0RvbShwYXJlbnQpKSB7XG4gICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3cgPSB0cnVlO1xuICB9XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJpZnJhbWVcIikge1xuICAgIG9uY2VJZnJhbWVMb2FkZWQoXG4gICAgICBuMixcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgaWZyYW1lRG9jID0gbjIuY29udGVudERvY3VtZW50O1xuICAgICAgICBpZiAoaWZyYW1lRG9jICYmIG9uSWZyYW1lTG9hZCkge1xuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRJZnJhbWVOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChpZnJhbWVEb2MsIHtcbiAgICAgICAgICAgIGRvYzogaWZyYW1lRG9jLFxuICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBuZWVkc01hc2ssXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzZXJpYWxpemVkSWZyYW1lTm9kZSkge1xuICAgICAgICAgICAgb25JZnJhbWVMb2FkKFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgc2VyaWFsaXplZElmcmFtZU5vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaWZyYW1lTG9hZFRpbWVvdXRcbiAgICApO1xuICB9XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInN0cmluZ1wiICYmIChzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwicHJlbG9hZFwiICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYgPT09IFwic3RyaW5nXCIgJiYgZXh0cmFjdEZpbGVFeHRlbnNpb24oc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5ocmVmKSA9PT0gXCJjc3NcIikpIHtcbiAgICBvbmNlU3R5bGVzaGVldExvYWRlZChcbiAgICAgIG4yLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5rTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbmVlZHNNYXNrLFxuICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgb25TZXJpYWxpemUsXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2VyaWFsaXplZExpbmtOb2RlKSB7XG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgc2VyaWFsaXplZExpbmtOb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuZnVuY3Rpb24gc25hcHNob3QobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG1pcnJvcjogbWlycm9yMiA9IG5ldyBNaXJyb3IoKSxcbiAgICBibG9ja0NsYXNzID0gXCJyci1ibG9ja1wiLFxuICAgIGJsb2NrU2VsZWN0b3IgPSBudWxsLFxuICAgIG1hc2tUZXh0Q2xhc3MgPSBcInJyLW1hc2tcIixcbiAgICBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSxcbiAgICBpbmxpbmVJbWFnZXMgPSBmYWxzZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICBtYXNrQWxsSW5wdXRzID0gZmFsc2UsXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBzbGltRE9NID0gZmFsc2UsXG4gICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgIG9uU2VyaWFsaXplLFxuICAgIG9uSWZyYW1lTG9hZCxcbiAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgY29sb3I6IHRydWUsXG4gICAgZGF0ZTogdHJ1ZSxcbiAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgZW1haWw6IHRydWUsXG4gICAgbW9udGg6IHRydWUsXG4gICAgbnVtYmVyOiB0cnVlLFxuICAgIHJhbmdlOiB0cnVlLFxuICAgIHNlYXJjaDogdHJ1ZSxcbiAgICB0ZWw6IHRydWUsXG4gICAgdGV4dDogdHJ1ZSxcbiAgICB0aW1lOiB0cnVlLFxuICAgIHVybDogdHJ1ZSxcbiAgICB3ZWVrOiB0cnVlLFxuICAgIHRleHRhcmVhOiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZSxcbiAgICBwYXNzd29yZDogdHJ1ZVxuICB9IDogbWFza0FsbElucHV0cyA9PT0gZmFsc2UgPyB7XG4gICAgcGFzc3dvcmQ6IHRydWVcbiAgfSA6IG1hc2tBbGxJbnB1dHM7XG4gIGNvbnN0IHNsaW1ET01PcHRpb25zID0gc2xpbURPTSA9PT0gdHJ1ZSB8fCBzbGltRE9NID09PSBcImFsbFwiID8gKFxuICAgIC8vIGlmIHRydWU6IHNldCBvZiBzZW5zaWJsZSBvcHRpb25zIHRoYXQgc2hvdWxkIG5vdCB0aHJvdyBhd2F5IGFueSBpbmZvcm1hdGlvblxuICAgIHtcbiAgICAgIHNjcmlwdDogdHJ1ZSxcbiAgICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcbiAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IHNsaW1ET00gPT09IFwiYWxsXCIsXG4gICAgICAvLyBkZXN0cnVjdGl2ZVxuICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiB0cnVlLFxuICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWVcbiAgICB9XG4gICkgOiBzbGltRE9NID09PSBmYWxzZSA/IHt9IDogc2xpbURPTTtcbiAgcmV0dXJuIHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICBkb2M6IG4yLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgbWFza1RleHRDbGFzcyxcbiAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgc2xpbURPTU9wdGlvbnMsXG4gICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgaW5saW5lSW1hZ2VzLFxuICAgIHJlY29yZENhbnZhcyxcbiAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgb25TZXJpYWxpemUsXG4gICAgb25JZnJhbWVMb2FkLFxuICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICBuZXdseUFkZGVkRWxlbWVudDogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyQxKHgyKSB7XG4gIHJldHVybiB4MiAmJiB4Mi5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJkZWZhdWx0XCIpID8geDJbXCJkZWZhdWx0XCJdIDogeDI7XG59XG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2UkMShuMikge1xuICBpZiAobjIuX19lc01vZHVsZSkgcmV0dXJuIG4yO1xuICB2YXIgZjIgPSBuMi5kZWZhdWx0O1xuICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBhMiA9IGZ1bmN0aW9uIGEyMigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYTIyKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgYTIucHJvdG90eXBlID0gZjIucHJvdG90eXBlO1xuICB9IGVsc2UgYTIgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmtleXMobjIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuMiwgayk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGEyO1xufVxudmFyIHBpY29jb2xvcnNfYnJvd3NlciQxID0geyBleHBvcnRzOiB7fSB9O1xudmFyIHgkMSA9IFN0cmluZztcbnZhciBjcmVhdGUkMSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyBpc0NvbG9yU3VwcG9ydGVkOiBmYWxzZSwgcmVzZXQ6IHgkMSwgYm9sZDogeCQxLCBkaW06IHgkMSwgaXRhbGljOiB4JDEsIHVuZGVybGluZTogeCQxLCBpbnZlcnNlOiB4JDEsIGhpZGRlbjogeCQxLCBzdHJpa2V0aHJvdWdoOiB4JDEsIGJsYWNrOiB4JDEsIHJlZDogeCQxLCBncmVlbjogeCQxLCB5ZWxsb3c6IHgkMSwgYmx1ZTogeCQxLCBtYWdlbnRhOiB4JDEsIGN5YW46IHgkMSwgd2hpdGU6IHgkMSwgZ3JheTogeCQxLCBiZ0JsYWNrOiB4JDEsIGJnUmVkOiB4JDEsIGJnR3JlZW46IHgkMSwgYmdZZWxsb3c6IHgkMSwgYmdCbHVlOiB4JDEsIGJnTWFnZW50YTogeCQxLCBiZ0N5YW46IHgkMSwgYmdXaGl0ZTogeCQxIH07XG59O1xucGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cyA9IGNyZWF0ZSQxKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzLmNyZWF0ZUNvbG9ycyA9IGNyZWF0ZSQxO1xudmFyIHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMkMSA9IHBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHM7XG5jb25zdCBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMiA9IHt9O1xuY29uc3QgX192aXRlQnJvd3NlckV4dGVybmFsJDEkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQyXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuY29uc3QgcmVxdWlyZSQkMiQxID0gLyogQF9fUFVSRV9fICovIGdldEF1Z21lbnRlZE5hbWVzcGFjZSQxKF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxJDEpO1xubGV0IHBpY28kMSA9IHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMkMTtcbmxldCB0ZXJtaW5hbEhpZ2hsaWdodCQxJDEgPSByZXF1aXJlJCQyJDE7XG5sZXQgQ3NzU3ludGF4RXJyb3IkMyQxID0gY2xhc3MgQ3NzU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4yMikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiQ3NzU3ludGF4RXJyb3JcIjtcbiAgICB0aGlzLnJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgfVxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAocGx1Z2luMjIpIHtcbiAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luMjI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29sdW1uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gbGluZS5jb2x1bW47XG4gICAgICAgIHRoaXMuZW5kTGluZSA9IGNvbHVtbi5saW5lO1xuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0TWVzc2FnZSgpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3NzU3ludGF4RXJyb3IpO1xuICAgIH1cbiAgfVxuICBzZXRNZXNzYWdlKCkge1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGx1Z2luID8gdGhpcy5wbHVnaW4gKyBcIjogXCIgOiBcIlwiO1xuICAgIHRoaXMubWVzc2FnZSArPSB0aGlzLmZpbGUgPyB0aGlzLmZpbGUgOiBcIjxjc3MgaW5wdXQ+XCI7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMubWVzc2FnZSArPSBcIjpcIiArIHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2x1bW47XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSArPSBcIjogXCIgKyB0aGlzLnJlYXNvbjtcbiAgfVxuICBzaG93U291cmNlQ29kZShjb2xvcikge1xuICAgIGlmICghdGhpcy5zb3VyY2UpIHJldHVybiBcIlwiO1xuICAgIGxldCBjc3MgPSB0aGlzLnNvdXJjZTtcbiAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSBwaWNvJDEuaXNDb2xvclN1cHBvcnRlZDtcbiAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSQxKSB7XG4gICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0JDEkMShjc3MpO1xuICAgIH1cbiAgICBsZXQgbGluZXMgPSBjc3Muc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCh0aGlzLmxpbmUgLSAzLCAwKTtcbiAgICBsZXQgZW5kID0gTWF0aC5taW4odGhpcy5saW5lICsgMiwgbGluZXMubGVuZ3RoKTtcbiAgICBsZXQgbWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGg7XG4gICAgbGV0IG1hcmssIGFzaWRlO1xuICAgIGlmIChjb2xvcikge1xuICAgICAgbGV0IHsgYm9sZCwgZ3JheSwgcmVkIH0gPSBwaWNvJDEuY3JlYXRlQ29sb3JzKHRydWUpO1xuICAgICAgbWFyayA9ICh0ZXh0KSA9PiBib2xkKHJlZCh0ZXh0KSk7XG4gICAgICBhc2lkZSA9ICh0ZXh0KSA9PiBncmF5KHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrID0gYXNpZGUgPSAoc3RyKSA9PiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoKGxpbmUsIGluZGV4MikgPT4ge1xuICAgICAgbGV0IG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4MjtcbiAgICAgIGxldCBndXR0ZXIgPSBcIiBcIiArIChcIiBcIiArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArIFwiIHwgXCI7XG4gICAgICBpZiAobnVtYmVyID09PSB0aGlzLmxpbmUpIHtcbiAgICAgICAgbGV0IHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSkgKyBsaW5lLnNsaWNlKDAsIHRoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIG1hcmsoXCI+XCIpICsgYXNpZGUoZ3V0dGVyKSArIGxpbmUgKyBcIlxcbiBcIiArIHNwYWNpbmcgKyBtYXJrKFwiXlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIiBcIiArIGFzaWRlKGd1dHRlcikgKyBsaW5lO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNvZGUgPSBcIlxcblxcblwiICsgY29kZSArIFwiXFxuXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICB9XG59O1xudmFyIGNzc1N5bnRheEVycm9yJDEgPSBDc3NTeW50YXhFcnJvciQzJDE7XG5Dc3NTeW50YXhFcnJvciQzJDEuZGVmYXVsdCA9IENzc1N5bnRheEVycm9yJDMkMTtcbnZhciBzeW1ib2xzJDEgPSB7fTtcbnN5bWJvbHMkMS5pc0NsZWFuID0gU3ltYm9sKFwiaXNDbGVhblwiKTtcbnN5bWJvbHMkMS5teSA9IFN5bWJvbChcIm15XCIpO1xuY29uc3QgREVGQVVMVF9SQVckMSA9IHtcbiAgYWZ0ZXI6IFwiXFxuXCIsXG4gIGJlZm9yZUNsb3NlOiBcIlxcblwiLFxuICBiZWZvcmVDb21tZW50OiBcIlxcblwiLFxuICBiZWZvcmVEZWNsOiBcIlxcblwiLFxuICBiZWZvcmVPcGVuOiBcIiBcIixcbiAgYmVmb3JlUnVsZTogXCJcXG5cIixcbiAgY29sb246IFwiOiBcIixcbiAgY29tbWVudExlZnQ6IFwiIFwiLFxuICBjb21tZW50UmlnaHQ6IFwiIFwiLFxuICBlbXB0eUJvZHk6IFwiXCIsXG4gIGluZGVudDogXCIgICAgXCIsXG4gIHNlbWljb2xvbjogZmFsc2Vcbn07XG5mdW5jdGlvbiBjYXBpdGFsaXplJDEoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmxldCBTdHJpbmdpZmllciQyJDEgPSBjbGFzcyBTdHJpbmdpZmllciB7XG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXIpIHtcbiAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICB9XG4gIGF0cnVsZShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgbGV0IG5hbWUgPSBcIkBcIiArIG5vZGUyLm5hbWU7XG4gICAgbGV0IHBhcmFtcyA9IG5vZGUyLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZTIsIFwicGFyYW1zXCIpIDogXCJcIjtcbiAgICBpZiAodHlwZW9mIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBuYW1lICs9IG5vZGUyLnJhd3MuYWZ0ZXJOYW1lO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICBuYW1lICs9IFwiIFwiO1xuICAgIH1cbiAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgIHRoaXMuYmxvY2sobm9kZTIsIG5hbWUgKyBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZW5kID0gKG5vZGUyLnJhd3MuYmV0d2VlbiB8fCBcIlwiKSArIChzZW1pY29sb24gPyBcIjtcIiA6IFwiXCIpO1xuICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUyKTtcbiAgICB9XG4gIH1cbiAgYmVmb3JlQWZ0ZXIobm9kZTIsIGRldGVjdCkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNvbW1lbnRcIik7XG4gICAgfSBlbHNlIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDbG9zZVwiKTtcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IG5vZGUyLnBhcmVudDtcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIHdoaWxlIChidWYgJiYgYnVmLnR5cGUgIT09IFwicm9vdFwiKSB7XG4gICAgICBkZXB0aCArPSAxO1xuICAgICAgYnVmID0gYnVmLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICBsZXQgaW5kZW50ID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiaW5kZW50XCIpO1xuICAgICAgaWYgKGluZGVudC5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKSB2YWx1ZSArPSBpbmRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBibG9jayhub2RlMiwgc3RhcnQpIHtcbiAgICBsZXQgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgIHRoaXMuYnVpbGRlcihzdGFydCArIGJldHdlZW4gKyBcIntcIiwgbm9kZTIsIFwic3RhcnRcIik7XG4gICAgbGV0IGFmdGVyO1xuICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIsIFwiZW1wdHlCb2R5XCIpO1xuICAgIH1cbiAgICBpZiAoYWZ0ZXIpIHRoaXMuYnVpbGRlcihhZnRlcik7XG4gICAgdGhpcy5idWlsZGVyKFwifVwiLCBub2RlMiwgXCJlbmRcIik7XG4gIH1cbiAgYm9keShub2RlMikge1xuICAgIGxldCBsYXN0ID0gbm9kZTIubm9kZXMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobGFzdCA+IDApIHtcbiAgICAgIGlmIChub2RlMi5ub2Rlc1tsYXN0XS50eXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICBsYXN0IC09IDE7XG4gICAgfVxuICAgIGxldCBzZW1pY29sb24gPSB0aGlzLnJhdyhub2RlMiwgXCJzZW1pY29sb25cIik7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5vZGUyLm5vZGVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZTIubm9kZXNbaTJdO1xuICAgICAgbGV0IGJlZm9yZSA9IHRoaXMucmF3KGNoaWxkLCBcImJlZm9yZVwiKTtcbiAgICAgIGlmIChiZWZvcmUpIHRoaXMuYnVpbGRlcihiZWZvcmUpO1xuICAgICAgdGhpcy5zdHJpbmdpZnkoY2hpbGQsIGxhc3QgIT09IGkyIHx8IHNlbWljb2xvbik7XG4gICAgfVxuICB9XG4gIGNvbW1lbnQobm9kZTIpIHtcbiAgICBsZXQgbGVmdCA9IHRoaXMucmF3KG5vZGUyLCBcImxlZnRcIiwgXCJjb21tZW50TGVmdFwiKTtcbiAgICBsZXQgcmlnaHQgPSB0aGlzLnJhdyhub2RlMiwgXCJyaWdodFwiLCBcImNvbW1lbnRSaWdodFwiKTtcbiAgICB0aGlzLmJ1aWxkZXIoXCIvKlwiICsgbGVmdCArIG5vZGUyLnRleHQgKyByaWdodCArIFwiKi9cIiwgbm9kZTIpO1xuICB9XG4gIGRlY2wobm9kZTIsIHNlbWljb2xvbikge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImNvbG9uXCIpO1xuICAgIGxldCBzdHJpbmcgPSBub2RlMi5wcm9wICsgYmV0d2VlbiArIHRoaXMucmF3VmFsdWUobm9kZTIsIFwidmFsdWVcIik7XG4gICAgaWYgKG5vZGUyLmltcG9ydGFudCkge1xuICAgICAgc3RyaW5nICs9IG5vZGUyLnJhd3MuaW1wb3J0YW50IHx8IFwiICFpbXBvcnRhbnRcIjtcbiAgICB9XG4gICAgaWYgKHNlbWljb2xvbikgc3RyaW5nICs9IFwiO1wiO1xuICAgIHRoaXMuYnVpbGRlcihzdHJpbmcsIG5vZGUyKTtcbiAgfVxuICBkb2N1bWVudChub2RlMikge1xuICAgIHRoaXMuYm9keShub2RlMik7XG4gIH1cbiAgcmF3KG5vZGUyLCBvd24sIGRldGVjdCkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoIWRldGVjdCkgZGV0ZWN0ID0gb3duO1xuICAgIGlmIChvd24pIHtcbiAgICAgIHZhbHVlID0gbm9kZTIucmF3c1tvd25dO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gbm9kZTIucGFyZW50O1xuICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC50eXBlID09PSBcInJvb3RcIiAmJiBwYXJlbnQuZmlyc3QgPT09IG5vZGUyKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuIERFRkFVTFRfUkFXJDFbZGV0ZWN0XTtcbiAgICBsZXQgcm9vdDIgPSBub2RlMi5yb290KCk7XG4gICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICBpZiAodHlwZW9mIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiByb290Mi5yYXdDYWNoZVtkZXRlY3RdO1xuICAgIH1cbiAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1ldGhvZCA9IFwicmF3XCIgKyBjYXBpdGFsaXplJDEoZGV0ZWN0KTtcbiAgICAgIGlmICh0aGlzW21ldGhvZF0pIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzW21ldGhvZF0ocm9vdDIsIG5vZGUyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBpMi5yYXdzW293bl07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikgdmFsdWUgPSBERUZBVUxUX1JBVyQxW2RldGVjdF07XG4gICAgcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVDbG9zZShyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVDb21tZW50KHJvb3QyLCBub2RlMikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrQ29tbWVudHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlRGVjbChyb290Miwgbm9kZTIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2Fsa0RlY2xzKChpMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZU9wZW4ocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi50eXBlICE9PSBcImRlY2xcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVSdWxlKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgKGkyLnBhcmVudCAhPT0gcm9vdDIgfHwgcm9vdDIuZmlyc3QgIT09IGkyKSkge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3Q29sb24ocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2Fsa0RlY2xzKChpMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJldHdlZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW4ucmVwbGFjZSgvW15cXHM6XS9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdFbXB0eUJvZHkocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0luZGVudChyb290Mikge1xuICAgIGlmIChyb290Mi5yYXdzLmluZGVudCkgcmV0dXJuIHJvb3QyLnJhd3MuaW5kZW50O1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgbGV0IHAgPSBpMi5wYXJlbnQ7XG4gICAgICBpZiAocCAmJiBwICE9PSByb290MiAmJiBwLnBhcmVudCAmJiBwLnBhcmVudCA9PT0gcm9vdDIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IGkyLnJhd3MuYmVmb3JlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIHZhbHVlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd1NlbWljb2xvbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCAmJiBpMi5sYXN0LnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5zZW1pY29sb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3VmFsdWUobm9kZTIsIHByb3ApIHtcbiAgICBsZXQgdmFsdWUgPSBub2RlMltwcm9wXTtcbiAgICBsZXQgcmF3ID0gbm9kZTIucmF3c1twcm9wXTtcbiAgICBpZiAocmF3ICYmIHJhdy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiByYXcucmF3O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcm9vdChub2RlMikge1xuICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgaWYgKG5vZGUyLnJhd3MuYWZ0ZXIpIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLmFmdGVyKTtcbiAgfVxuICBydWxlKG5vZGUyKSB7XG4gICAgdGhpcy5ibG9jayhub2RlMiwgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJzZWxlY3RvclwiKSk7XG4gICAgaWYgKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5vd25TZW1pY29sb24sIG5vZGUyLCBcImVuZFwiKTtcbiAgICB9XG4gIH1cbiAgc3RyaW5naWZ5KG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICBpZiAoIXRoaXNbbm9kZTIudHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIEFTVCBub2RlIHR5cGUgXCIgKyBub2RlMi50eXBlICsgXCIuIE1heWJlIHlvdSBuZWVkIHRvIGNoYW5nZSBQb3N0Q1NTIHN0cmluZ2lmaWVyLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzW25vZGUyLnR5cGVdKG5vZGUyLCBzZW1pY29sb24pO1xuICB9XG59O1xudmFyIHN0cmluZ2lmaWVyJDEgPSBTdHJpbmdpZmllciQyJDE7XG5TdHJpbmdpZmllciQyJDEuZGVmYXVsdCA9IFN0cmluZ2lmaWVyJDIkMTtcbmxldCBTdHJpbmdpZmllciQxJDEgPSBzdHJpbmdpZmllciQxO1xuZnVuY3Rpb24gc3RyaW5naWZ5JDQkMShub2RlMiwgYnVpbGRlcikge1xuICBsZXQgc3RyID0gbmV3IFN0cmluZ2lmaWVyJDEkMShidWlsZGVyKTtcbiAgc3RyLnN0cmluZ2lmeShub2RlMik7XG59XG52YXIgc3RyaW5naWZ5XzEkMSA9IHN0cmluZ2lmeSQ0JDE7XG5zdHJpbmdpZnkkNCQxLmRlZmF1bHQgPSBzdHJpbmdpZnkkNCQxO1xubGV0IHsgaXNDbGVhbjogaXNDbGVhbiQyJDEsIG15OiBteSQyJDEgfSA9IHN5bWJvbHMkMTtcbmxldCBDc3NTeW50YXhFcnJvciQyJDEgPSBjc3NTeW50YXhFcnJvciQxO1xubGV0IFN0cmluZ2lmaWVyMiQxID0gc3RyaW5naWZpZXIkMTtcbmxldCBzdHJpbmdpZnkkMyQxID0gc3RyaW5naWZ5XzEkMTtcbmZ1bmN0aW9uIGNsb25lTm9kZSQxKG9iaiwgcGFyZW50KSB7XG4gIGxldCBjbG9uZWQgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG4gIGZvciAobGV0IGkyIGluIG9iaikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkyID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgbGV0IHZhbHVlID0gb2JqW2kyXTtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAoaTIgPT09IFwicGFyZW50XCIgJiYgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHBhcmVudCkgY2xvbmVkW2kyXSA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKGkyID09PSBcInNvdXJjZVwiKSB7XG4gICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlLm1hcCgoaikgPT4gY2xvbmVOb2RlJDEoaiwgY2xvbmVkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB2YWx1ZSA9IGNsb25lTm9kZSQxKHZhbHVlKTtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmxldCBOb2RlJDQkMSA9IGNsYXNzIE5vZGUyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMgPSB7fSkge1xuICAgIHRoaXMucmF3cyA9IHt9O1xuICAgIHRoaXNbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgdGhpc1tteSQyJDFdID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbm9kZTIgb2YgZGVmYXVsdHNbbmFtZV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUyLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyLmNsb25lKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFkZFRvRXJyb3IoZXJyb3IpIHtcbiAgICBlcnJvci5wb3N0Y3NzTm9kZSA9IHRoaXM7XG4gICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICBsZXQgczIgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZShcbiAgICAgICAgL1xcblxcc3s0fWF0IC8sXG4gICAgICAgIGAkJiR7czIuaW5wdXQuZnJvbX06JHtzMi5zdGFydC5saW5lfToke3MyLnN0YXJ0LmNvbHVtbn0kJmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBhZnRlcihhZGQpIHtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBhZGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzc2lnbihvdmVycmlkZXMgPSB7fSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWZvcmUoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5iZWZvcmU7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlcjtcbiAgICBpZiAoIWtlZXBCZXR3ZWVuKSBkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47XG4gIH1cbiAgY2xvbmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gY2xvbmVOb2RlJDEodGhpcyk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBjbG9uZUFmdGVyKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBjbG9uZWQpO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgY2xvbmVCZWZvcmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBjbG9uZWQpO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgZXJyb3IobWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICBsZXQgeyBlbmQsIHN0YXJ0IH0gPSB0aGlzLnJhbmdlQnkob3B0cyk7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHsgY29sdW1uOiBzdGFydC5jb2x1bW4sIGxpbmU6IHN0YXJ0LmxpbmUgfSxcbiAgICAgICAgeyBjb2x1bW46IGVuZC5jb2x1bW4sIGxpbmU6IGVuZC5saW5lIH0sXG4gICAgICAgIG9wdHNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3NzU3ludGF4RXJyb3IkMiQxKG1lc3NhZ2UpO1xuICB9XG4gIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZTJbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgPT09IFwicHJvcFwiIHx8IHByb3AgPT09IFwidmFsdWVcIiB8fCBwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwiaW1wb3J0YW50XCIgfHwgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgcHJvcCA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIG1hcmtEaXJ0eSgpIHtcbiAgICBpZiAodGhpc1tpc0NsZWFuJDIkMV0pIHtcbiAgICAgIHRoaXNbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICBsZXQgbmV4dCA9IHRoaXM7XG4gICAgICB3aGlsZSAobmV4dCA9IG5leHQucGFyZW50KSB7XG4gICAgICAgIG5leHRbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICBsZXQgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiArIDFdO1xuICB9XG4gIHBvc2l0aW9uQnkob3B0cywgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICBsZXQgcG9zID0gdGhpcy5zb3VyY2Uuc3RhcnQ7XG4gICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgIH0gZWxzZSBpZiAob3B0cy53b3JkKSB7XG4gICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgIGxldCBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICBwb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgbGV0IHN0cmluZyA9IHN0cmluZ1JlcHJlc2VudGF0aW9uIHx8IHRoaXMudG9TdHJpbmcoKTtcbiAgICBsZXQgY29sdW1uID0gdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgIGxldCBsaW5lID0gdGhpcy5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgaW5kZXgyOyBpMisrKSB7XG4gICAgICBpZiAoc3RyaW5nW2kyXSA9PT0gXCJcXG5cIikge1xuICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICBsaW5lICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29sdW1uLCBsaW5lIH07XG4gIH1cbiAgcHJldigpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyIC0gMV07XG4gIH1cbiAgcmFuZ2VCeShvcHRzKSB7XG4gICAgbGV0IHN0YXJ0ID0ge1xuICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgfTtcbiAgICBsZXQgZW5kID0gdGhpcy5zb3VyY2UuZW5kID8ge1xuICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5lbmQuY29sdW1uICsgMSxcbiAgICAgIGxpbmU6IHRoaXMuc291cmNlLmVuZC5saW5lXG4gICAgfSA6IHtcbiAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICB9O1xuICAgIGlmIChvcHRzLndvcmQpIHtcbiAgICAgIGxldCBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgIGxldCBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICBpZiAoaW5kZXgyICE9PSAtMSkge1xuICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyICsgb3B0cy53b3JkLmxlbmd0aCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5zdGFydCkge1xuICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICBjb2x1bW46IG9wdHMuc3RhcnQuY29sdW1uLFxuICAgICAgICAgIGxpbmU6IG9wdHMuc3RhcnQubGluZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgbGluZTogb3B0cy5lbmQubGluZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5lbmRJbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuZW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kLmxpbmUgPCBzdGFydC5saW5lIHx8IGVuZC5saW5lID09PSBzdGFydC5saW5lICYmIGVuZC5jb2x1bW4gPD0gc3RhcnQuY29sdW1uKSB7XG4gICAgICBlbmQgPSB7IGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSwgbGluZTogc3RhcnQubGluZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmQsIHN0YXJ0IH07XG4gIH1cbiAgcmF3KHByb3AsIGRlZmF1bHRUeXBlKSB7XG4gICAgbGV0IHN0ciA9IG5ldyBTdHJpbmdpZmllcjIkMSgpO1xuICAgIHJldHVybiBzdHIucmF3KHRoaXMsIHByb3AsIGRlZmF1bHRUeXBlKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZVdpdGgoLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGxldCBib29rbWFyayA9IHRoaXM7XG4gICAgICBsZXQgZm91bmRTZWxmID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZTIgPT09IHRoaXMpIHtcbiAgICAgICAgICBmb3VuZFNlbGYgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kU2VsZikge1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgYm9va21hcmsgPSBub2RlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm9vdCgpIHtcbiAgICBsZXQgcmVzdWx0MiA9IHRoaXM7XG4gICAgd2hpbGUgKHJlc3VsdDIucGFyZW50ICYmIHJlc3VsdDIucGFyZW50LnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgcmVzdWx0MiA9IHJlc3VsdDIucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB0b0pTT04oXywgaW5wdXRzKSB7XG4gICAgbGV0IGZpeGVkID0ge307XG4gICAgbGV0IGVtaXRJbnB1dHMgPSBpbnB1dHMgPT0gbnVsbDtcbiAgICBpbnB1dHMgPSBpbnB1dHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgaW5wdXRzTmV4dEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwicGFyZW50XCIgfHwgbmFtZSA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgbGV0IHZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLm1hcCgoaTIpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIGkyLnRvSlNPTikge1xuICAgICAgICAgICAgcmV0dXJuIGkyLnRvSlNPTihudWxsLCBpbnB1dHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLnRvSlNPTihudWxsLCBpbnB1dHMpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgIGxldCBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dCk7XG4gICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICBpbnB1dElkID0gaW5wdXRzTmV4dEluZGV4O1xuICAgICAgICAgIGlucHV0cy5zZXQodmFsdWUuaW5wdXQsIGlucHV0c05leHRJbmRleCk7XG4gICAgICAgICAgaW5wdXRzTmV4dEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZml4ZWRbbmFtZV0gPSB7XG4gICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXG4gICAgICAgICAgaW5wdXRJZCxcbiAgICAgICAgICBzdGFydDogdmFsdWUuc3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbWl0SW5wdXRzKSB7XG4gICAgICBmaXhlZC5pbnB1dHMgPSBbLi4uaW5wdXRzLmtleXMoKV0ubWFwKChpbnB1dDIpID0+IGlucHV0Mi50b0pTT04oKSk7XG4gICAgfVxuICAgIHJldHVybiBmaXhlZDtcbiAgfVxuICB0b1Byb3h5KCkge1xuICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJveHlDYWNoZTtcbiAgfVxuICB0b1N0cmluZyhzdHJpbmdpZmllcjIgPSBzdHJpbmdpZnkkMyQxKSB7XG4gICAgaWYgKHN0cmluZ2lmaWVyMi5zdHJpbmdpZnkpIHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmaWVyMi5zdHJpbmdpZnk7XG4gICAgbGV0IHJlc3VsdDIgPSBcIlwiO1xuICAgIHN0cmluZ2lmaWVyMih0aGlzLCAoaTIpID0+IHtcbiAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgd2FybihyZXN1bHQyLCB0ZXh0LCBvcHRzKSB7XG4gICAgbGV0IGRhdGEgPSB7IG5vZGU6IHRoaXMgfTtcbiAgICBmb3IgKGxldCBpMiBpbiBvcHRzKSBkYXRhW2kyXSA9IG9wdHNbaTJdO1xuICAgIHJldHVybiByZXN1bHQyLndhcm4odGV4dCwgZGF0YSk7XG4gIH1cbiAgZ2V0IHByb3h5T2YoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgbm9kZSQxID0gTm9kZSQ0JDE7XG5Ob2RlJDQkMS5kZWZhdWx0ID0gTm9kZSQ0JDE7XG5sZXQgTm9kZSQzJDEgPSBub2RlJDE7XG5sZXQgRGVjbGFyYXRpb24kNCQxID0gY2xhc3MgRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlJDMkMSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgaWYgKGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRlZmF1bHRzID0geyAuLi5kZWZhdWx0cywgdmFsdWU6IFN0cmluZyhkZWZhdWx0cy52YWx1ZSkgfTtcbiAgICB9XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwiZGVjbFwiO1xuICB9XG4gIGdldCB2YXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLnN0YXJ0c1dpdGgoXCItLVwiKSB8fCB0aGlzLnByb3BbMF0gPT09IFwiJFwiO1xuICB9XG59O1xudmFyIGRlY2xhcmF0aW9uJDEgPSBEZWNsYXJhdGlvbiQ0JDE7XG5EZWNsYXJhdGlvbiQ0JDEuZGVmYXVsdCA9IERlY2xhcmF0aW9uJDQkMTtcbmxldCB1cmxBbHBoYWJldCQxID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCI7XG5sZXQgY3VzdG9tQWxwaGFiZXQkMSA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUgPSAyMSkgPT4ge1xuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9IFwiXCI7XG4gICAgbGV0IGkyID0gc2l6ZTtcbiAgICB3aGlsZSAoaTItLSkge1xuICAgICAgaWQgKz0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH07XG59O1xubGV0IG5hbm9pZCQxJDEgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9IFwiXCI7XG4gIGxldCBpMiA9IHNpemU7XG4gIHdoaWxlIChpMi0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXQkMVtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xudmFyIG5vblNlY3VyZSQxID0geyBuYW5vaWQ6IG5hbm9pZCQxJDEsIGN1c3RvbUFscGhhYmV0OiBjdXN0b21BbHBoYWJldCQxIH07XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lcjogU291cmNlTWFwQ29uc3VtZXIkMiQxLCBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvciQyJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IGV4aXN0c1N5bmM6IGV4aXN0c1N5bmMkMSwgcmVhZEZpbGVTeW5jOiByZWFkRmlsZVN5bmMkMSB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgZGlybmFtZTogZGlybmFtZSQxJDEsIGpvaW46IGpvaW4kMSB9ID0gcmVxdWlyZSQkMiQxO1xuZnVuY3Rpb24gZnJvbUJhc2U2NCQxKHN0cikge1xuICBpZiAoQnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2luZG93LmF0b2Ioc3RyKTtcbiAgfVxufVxubGV0IFByZXZpb3VzTWFwJDIkMSA9IGNsYXNzIFByZXZpb3VzTWFwIHtcbiAgY29uc3RydWN0b3IoY3NzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMubWFwID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKTtcbiAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgXCJkYXRhOlwiKTtcbiAgICBsZXQgcHJldiA9IG9wdHMubWFwID8gb3B0cy5tYXAucHJldiA6IHZvaWQgMDtcbiAgICBsZXQgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpO1xuICAgIGlmICghdGhpcy5tYXBGaWxlICYmIG9wdHMuZnJvbSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gb3B0cy5mcm9tO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXBGaWxlKSB0aGlzLnJvb3QgPSBkaXJuYW1lJDEkMSh0aGlzLm1hcEZpbGUpO1xuICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIGNvbnN1bWVyKCkge1xuICAgIGlmICghdGhpcy5jb25zdW1lckNhY2hlKSB7XG4gICAgICB0aGlzLmNvbnN1bWVyQ2FjaGUgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIkMiQxKHRoaXMudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnN1bWVyQ2FjaGU7XG4gIH1cbiAgZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICBsZXQgYmFzZUNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvO1xuICAgIGxldCBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICBsZXQgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsLztcbiAgICBsZXQgdXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbiwvO1xuICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICB9XG4gICAgaWYgKGJhc2VDaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgYmFzZVVyaS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm4gZnJvbUJhc2U2NCQxKHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7XG4gICAgfVxuICAgIGxldCBlbmNvZGluZyA9IHRleHQubWF0Y2goL2RhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXixdKyksLylbMV07XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyBcIiArIGVuY29kaW5nKTtcbiAgfVxuICBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZykge1xuICAgIHJldHVybiBzb3VyY2VNYXBTdHJpbmcucmVwbGFjZSgvXlxcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9LywgXCJcIikudHJpbSgpO1xuICB9XG4gIGlzTWFwKG1hcCkge1xuICAgIGlmICh0eXBlb2YgbWFwICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHR5cGVvZiBtYXAubWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShtYXAuc2VjdGlvbnMpO1xuICB9XG4gIGxvYWRBbm5vdGF0aW9uKGNzcykge1xuICAgIGxldCBjb21tZW50cyA9IGNzcy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vZ20pO1xuICAgIGlmICghY29tbWVudHMpIHJldHVybjtcbiAgICBsZXQgc3RhcnQgPSBjc3MubGFzdEluZGV4T2YoY29tbWVudHMucG9wKCkpO1xuICAgIGxldCBlbmQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHN0YXJ0KTtcbiAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uVVJMKGNzcy5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgIH1cbiAgfVxuICBsb2FkRmlsZShwYXRoKSB7XG4gICAgdGhpcy5yb290ID0gZGlybmFtZSQxJDEocGF0aCk7XG4gICAgaWYgKGV4aXN0c1N5bmMkMShwYXRoKSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgIHJldHVybiByZWFkRmlsZVN5bmMkMShwYXRoLCBcInV0Zi04XCIpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgIH1cbiAgfVxuICBsb2FkTWFwKGZpbGUsIHByZXYpIHtcbiAgICBpZiAocHJldiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxldCBwcmV2UGF0aCA9IHByZXYoZmlsZSk7XG4gICAgICAgIGlmIChwcmV2UGF0aCkge1xuICAgICAgICAgIGxldCBtYXAgPSB0aGlzLmxvYWRGaWxlKHByZXZQYXRoKTtcbiAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIlVuYWJsZSB0byBsb2FkIHByZXZpb3VzIHNvdXJjZSBtYXA6IFwiICsgcHJldlBhdGgudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgU291cmNlTWFwQ29uc3VtZXIkMiQxKSB7XG4gICAgICAgIHJldHVybiBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcEdlbmVyYXRvciQyJDEpIHtcbiAgICAgICAgcmV0dXJuIHByZXYudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hcChwcmV2KSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogXCIgKyBwcmV2LnRvU3RyaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbikge1xuICAgICAgbGV0IG1hcCA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgIGlmIChmaWxlKSBtYXAgPSBqb2luJDEoZGlybmFtZSQxJDEoZmlsZSksIG1hcCk7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXApO1xuICAgIH1cbiAgfVxuICBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgc3RhcnQubGVuZ3RoKSA9PT0gc3RhcnQ7XG4gIH1cbiAgd2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudCAmJiB0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQubGVuZ3RoID4gMCk7XG4gIH1cbn07XG52YXIgcHJldmlvdXNNYXAkMSA9IFByZXZpb3VzTWFwJDIkMTtcblByZXZpb3VzTWFwJDIkMS5kZWZhdWx0ID0gUHJldmlvdXNNYXAkMiQxO1xubGV0IHsgU291cmNlTWFwQ29uc3VtZXI6IFNvdXJjZU1hcENvbnN1bWVyJDEkMSwgU291cmNlTWFwR2VuZXJhdG9yOiBTb3VyY2VNYXBHZW5lcmF0b3IkMSQxIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBmaWxlVVJMVG9QYXRoOiBmaWxlVVJMVG9QYXRoJDEsIHBhdGhUb0ZpbGVVUkw6IHBhdGhUb0ZpbGVVUkwkMSQxIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBpc0Fic29sdXRlOiBpc0Fic29sdXRlJDEsIHJlc29sdmU6IHJlc29sdmUkMSQxIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBuYW5vaWQ6IG5hbm9pZCQyIH0gPSBub25TZWN1cmUkMTtcbmxldCB0ZXJtaW5hbEhpZ2hsaWdodCQyID0gcmVxdWlyZSQkMiQxO1xubGV0IENzc1N5bnRheEVycm9yJDEkMSA9IGNzc1N5bnRheEVycm9yJDE7XG5sZXQgUHJldmlvdXNNYXAkMSQxID0gcHJldmlvdXNNYXAkMTtcbmxldCBmcm9tT2Zmc2V0Q2FjaGUkMSA9IFN5bWJvbChcImZyb21PZmZzZXRDYWNoZVwiKTtcbmxldCBzb3VyY2VNYXBBdmFpbGFibGUkMSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxJDEgJiYgU291cmNlTWFwR2VuZXJhdG9yJDEkMSk7XG5sZXQgcGF0aEF2YWlsYWJsZSQxJDEgPSBCb29sZWFuKHJlc29sdmUkMSQxICYmIGlzQWJzb2x1dGUkMSk7XG5sZXQgSW5wdXQkNCQxID0gY2xhc3MgSW5wdXQge1xuICBjb25zdHJ1Y3Rvcihjc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmIChjc3MgPT09IG51bGwgfHwgdHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgY3NzID09PSBcIm9iamVjdFwiICYmICFjc3MudG9TdHJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zdENTUyByZWNlaXZlZCAke2Nzc30gaW5zdGVhZCBvZiBDU1Mgc3RyaW5nYCk7XG4gICAgfVxuICAgIHRoaXMuY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuY3NzWzBdID09PSBcIlxcdUZFRkZcIiB8fCB0aGlzLmNzc1swXSA9PT0gXCLvv75cIikge1xuICAgICAgdGhpcy5oYXNCT00gPSB0cnVlO1xuICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYXNCT00gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuZnJvbSkge1xuICAgICAgaWYgKCFwYXRoQXZhaWxhYmxlJDEkMSB8fCAvXlxcdys6XFwvXFwvLy50ZXN0KG9wdHMuZnJvbSkgfHwgaXNBYnNvbHV0ZSQxKG9wdHMuZnJvbSkpIHtcbiAgICAgICAgdGhpcy5maWxlID0gb3B0cy5mcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxJDEob3B0cy5mcm9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGhBdmFpbGFibGUkMSQxICYmIHNvdXJjZU1hcEF2YWlsYWJsZSQxJDEpIHtcbiAgICAgIGxldCBtYXAgPSBuZXcgUHJldmlvdXNNYXAkMSQxKHRoaXMuY3NzLCBvcHRzKTtcbiAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgbGV0IGZpbGUgPSBtYXAuY29uc3VtZXIoKS5maWxlO1xuICAgICAgICBpZiAoIXRoaXMuZmlsZSAmJiBmaWxlKSB0aGlzLmZpbGUgPSB0aGlzLm1hcFJlc29sdmUoZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5maWxlKSB7XG4gICAgICB0aGlzLmlkID0gXCI8aW5wdXQgY3NzIFwiICsgbmFub2lkJDIoNikgKyBcIj5cIjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwKSB0aGlzLm1hcC5maWxlID0gdGhpcy5mcm9tO1xuICB9XG4gIGVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgb3B0cyA9IHt9KSB7XG4gICAgbGV0IHJlc3VsdDIsIGVuZExpbmUsIGVuZENvbHVtbjtcbiAgICBpZiAobGluZSAmJiB0eXBlb2YgbGluZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgbGV0IHN0YXJ0ID0gbGluZTtcbiAgICAgIGxldCBlbmQgPSBjb2x1bW47XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIGxpbmUgPSBwb3MubGluZTtcbiAgICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUgPSBzdGFydC5saW5lO1xuICAgICAgICBjb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZnJvbU9mZnNldChlbmQub2Zmc2V0KTtcbiAgICAgICAgZW5kTGluZSA9IHBvcy5saW5lO1xuICAgICAgICBlbmRDb2x1bW4gPSBwb3MuY29sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lO1xuICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWNvbHVtbikge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuZnJvbU9mZnNldChsaW5lKTtcbiAgICAgIGxpbmUgPSBwb3MubGluZTtcbiAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgfVxuICAgIGxldCBvcmlnaW4gPSB0aGlzLm9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbik7XG4gICAgaWYgKG9yaWdpbikge1xuICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxJDEoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4ubGluZSA6IHsgY29sdW1uOiBvcmlnaW4uY29sdW1uLCBsaW5lOiBvcmlnaW4ubGluZSB9LFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmNvbHVtbiA6IHsgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLCBsaW5lOiBvcmlnaW4uZW5kTGluZSB9LFxuICAgICAgICBvcmlnaW4uc291cmNlLFxuICAgICAgICBvcmlnaW4uZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMSQxKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlbmRMaW5lID09PSB2b2lkIDAgPyBsaW5lIDogeyBjb2x1bW4sIGxpbmUgfSxcbiAgICAgICAgZW5kTGluZSA9PT0gdm9pZCAwID8gY29sdW1uIDogeyBjb2x1bW46IGVuZENvbHVtbiwgbGluZTogZW5kTGluZSB9LFxuICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgdGhpcy5maWxlLFxuICAgICAgICBvcHRzLnBsdWdpblxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzdWx0Mi5pbnB1dCA9IHsgY29sdW1uLCBlbmRDb2x1bW4sIGVuZExpbmUsIGxpbmUsIHNvdXJjZTogdGhpcy5jc3MgfTtcbiAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICBpZiAocGF0aFRvRmlsZVVSTCQxJDEpIHtcbiAgICAgICAgcmVzdWx0Mi5pbnB1dC51cmwgPSBwYXRoVG9GaWxlVVJMJDEkMSh0aGlzLmZpbGUpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQyLmlucHV0LmZpbGUgPSB0aGlzLmZpbGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGZyb21PZmZzZXQob2Zmc2V0KSB7XG4gICAgbGV0IGxhc3RMaW5lLCBsaW5lVG9JbmRleDtcbiAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlJDFdKSB7XG4gICAgICBsZXQgbGluZXMgPSB0aGlzLmNzcy5zcGxpdChcIlxcblwiKTtcbiAgICAgIGxpbmVUb0luZGV4ID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICBsZXQgcHJldkluZGV4ID0gMDtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgbDIgPSBsaW5lcy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspIHtcbiAgICAgICAgbGluZVRvSW5kZXhbaTJdID0gcHJldkluZGV4O1xuICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaTJdLmxlbmd0aCArIDE7XG4gICAgICB9XG4gICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXSA9IGxpbmVUb0luZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9JbmRleCA9IHRoaXNbZnJvbU9mZnNldENhY2hlJDFdO1xuICAgIH1cbiAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdO1xuICAgIGxldCBtaW4gPSAwO1xuICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyO1xuICAgICAgbGV0IG1pZDtcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVUb0luZGV4W21pZF0pIHtcbiAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgbGluZTogbWluICsgMVxuICAgIH07XG4gIH1cbiAgbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZSQxJDEodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHRoaXMubWFwLnJvb3QgfHwgXCIuXCIsIGZpbGUpO1xuICB9XG4gIG9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICAgIGlmICghdGhpcy5tYXApIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpO1xuICAgIGxldCBmcm9tID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbiwgbGluZSB9KTtcbiAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRvO1xuICAgIGlmICh0eXBlb2YgZW5kTGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdG8gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHsgY29sdW1uOiBlbmRDb2x1bW4sIGxpbmU6IGVuZExpbmUgfSk7XG4gICAgfVxuICAgIGxldCBmcm9tVXJsO1xuICAgIGlmIChpc0Fic29sdXRlJDEoZnJvbS5zb3VyY2UpKSB7XG4gICAgICBmcm9tVXJsID0gcGF0aFRvRmlsZVVSTCQxJDEoZnJvbS5zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVXJsID0gbmV3IFVSTChcbiAgICAgICAgZnJvbS5zb3VyY2UsXG4gICAgICAgIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMJDEkMSh0aGlzLm1hcC5tYXBGaWxlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDIgPSB7XG4gICAgICBjb2x1bW46IGZyb20uY29sdW1uLFxuICAgICAgZW5kQ29sdW1uOiB0byAmJiB0by5jb2x1bW4sXG4gICAgICBlbmRMaW5lOiB0byAmJiB0by5saW5lLFxuICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgdXJsOiBmcm9tVXJsLnRvU3RyaW5nKClcbiAgICB9O1xuICAgIGlmIChmcm9tVXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgIGlmIChmaWxlVVJMVG9QYXRoJDEpIHtcbiAgICAgICAgcmVzdWx0Mi5maWxlID0gZmlsZVVSTFRvUGF0aCQxKGZyb21VcmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWxlOiBwcm90b2NvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSkgcmVzdWx0Mi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBvZiBbXCJoYXNCT01cIiwgXCJjc3NcIiwgXCJmaWxlXCIsIFwiaWRcIl0pIHtcbiAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAganNvbltuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAganNvbi5tYXAgPSB7IC4uLnRoaXMubWFwIH07XG4gICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlIHx8IHRoaXMuaWQ7XG4gIH1cbn07XG52YXIgaW5wdXQkMSA9IElucHV0JDQkMTtcbklucHV0JDQkMS5kZWZhdWx0ID0gSW5wdXQkNCQxO1xuaWYgKHRlcm1pbmFsSGlnaGxpZ2h0JDIgJiYgdGVybWluYWxIaWdobGlnaHQkMi5yZWdpc3RlcklucHV0KSB7XG4gIHRlcm1pbmFsSGlnaGxpZ2h0JDIucmVnaXN0ZXJJbnB1dChJbnB1dCQ0JDEpO1xufVxubGV0IHsgU291cmNlTWFwQ29uc3VtZXI6IFNvdXJjZU1hcENvbnN1bWVyJDMsIFNvdXJjZU1hcEdlbmVyYXRvcjogU291cmNlTWFwR2VuZXJhdG9yJDMgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IGRpcm5hbWU6IGRpcm5hbWUkMiwgcmVsYXRpdmU6IHJlbGF0aXZlJDEsIHJlc29sdmU6IHJlc29sdmUkMiwgc2VwOiBzZXAkMSB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgcGF0aFRvRmlsZVVSTDogcGF0aFRvRmlsZVVSTCQyIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgSW5wdXQkMyQxID0gaW5wdXQkMTtcbmxldCBzb3VyY2VNYXBBdmFpbGFibGUkMiA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIkMyAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMyk7XG5sZXQgcGF0aEF2YWlsYWJsZSQyID0gQm9vbGVhbihkaXJuYW1lJDIgJiYgcmVzb2x2ZSQyICYmIHJlbGF0aXZlJDEgJiYgc2VwJDEpO1xubGV0IE1hcEdlbmVyYXRvciQyJDEgPSBjbGFzcyBNYXBHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihzdHJpbmdpZnkyLCByb290Miwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgIHRoaXMubWFwT3B0cyA9IG9wdHMubWFwIHx8IHt9O1xuICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jc3MgPSBjc3NTdHJpbmc7XG4gICAgdGhpcy5vcmlnaW5hbENTUyA9IGNzc1N0cmluZztcbiAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRBbm5vdGF0aW9uKCkge1xuICAgIGxldCBjb250ZW50O1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKHRoaXMub3B0cy50bywgdGhpcy5yb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgfVxuICAgIGxldCBlb2wgPSBcIlxcblwiO1xuICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICB0aGlzLmNzcyArPSBlb2wgKyBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY29udGVudCArIFwiICovXCI7XG4gIH1cbiAgYXBwbHlQcmV2TWFwcygpIHtcbiAgICBmb3IgKGxldCBwcmV2IG9mIHRoaXMucHJldmlvdXMoKSkge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgIGxldCByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lJDIocHJldi5maWxlKTtcbiAgICAgIGxldCBtYXA7XG4gICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICBtYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIkMyhwcmV2LnRleHQpO1xuICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwID0gcHJldi5jb25zdW1lcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmcm9tLCB0aGlzLnRvVXJsKHRoaXMucGF0aChyb290MikpKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICBsZXQgbm9kZTI7XG4gICAgICBmb3IgKGxldCBpMiA9IHRoaXMucm9vdC5ub2Rlcy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICAgIG5vZGUyID0gdGhpcy5yb290Lm5vZGVzW2kyXTtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiY29tbWVudFwiKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUyLnRleHQuaW5kZXhPZihcIiMgc291cmNlTWFwcGluZ1VSTD1cIikgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5yZXBsYWNlKC9cXG4qP1xcL1xcKiNbXFxTXFxzXSo/XFwqXFwvJC9nbSwgXCJcIik7XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlKCkge1xuICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHBhdGhBdmFpbGFibGUkMiAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMiAmJiB0aGlzLmlzTWFwKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKGkyKSA9PiB7XG4gICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbcmVzdWx0Ml07XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlTWFwKCkge1xuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVTdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxldCBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKCk7XG4gICAgICBwcmV2LmZpbGUgPSB0aGlzLm91dHB1dEZpbGUoKTtcbiAgICAgIHRoaXMubWFwID0gU291cmNlTWFwR2VuZXJhdG9yJDMuZnJvbVNvdXJjZU1hcChwcmV2LCB7XG4gICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yJDMoe1xuICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDogeyBjb2x1bW46IDAsIGxpbmU6IDEgfSxcbiAgICAgICAgb3JpZ2luYWw6IHsgY29sdW1uOiAwLCBsaW5lOiAxIH0sXG4gICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTb3VyY2VzQ29udGVudCgpKSB0aGlzLnNldFNvdXJjZXNDb250ZW50KCk7XG4gICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpO1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3NdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzLCB0aGlzLm1hcF07XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgIHRoaXMuY3NzID0gXCJcIjtcbiAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IkMyh7XG4gICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgbGV0IGxpbmUgPSAxO1xuICAgIGxldCBjb2x1bW4gPSAxO1xuICAgIGxldCBub1NvdXJjZSA9IFwiPG5vIHNvdXJjZT5cIjtcbiAgICBsZXQgbWFwcGluZyA9IHtcbiAgICAgIGdlbmVyYXRlZDogeyBjb2x1bW46IDAsIGxpbmU6IDAgfSxcbiAgICAgIG9yaWdpbmFsOiB7IGNvbHVtbjogMCwgbGluZTogMCB9LFxuICAgICAgc291cmNlOiBcIlwiXG4gICAgfTtcbiAgICBsZXQgbGluZXMsIGxhc3Q7XG4gICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCAoc3RyLCBub2RlMiwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5jc3MgKz0gc3RyO1xuICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwiZW5kXCIpIHtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLnN0YXJ0KSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XG4gICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgbGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGxhc3QgPSBzdHIubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIGNvbHVtbiA9IHN0ci5sZW5ndGggLSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJzdGFydFwiKSB7XG4gICAgICAgIGxldCBwID0gbm9kZTIucGFyZW50IHx8IHsgcmF3czoge30gfTtcbiAgICAgICAgbGV0IGNoaWxkbGVzcyA9IG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgIW5vZGUyLm5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkbGVzcyB8fCBub2RlMiAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5lbmQubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLmVuZC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAyO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlzQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKChpMikgPT4gaTIuYW5ub3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmU7XG4gICAgfVxuICAgIGxldCBhbm5vdGF0aW9uID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGFubm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZSgoaTIpID0+IGkyLmlubGluZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzTWFwKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuICEhdGhpcy5vcHRzLm1hcDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoKGkyKSA9PiBpMi53aXRoQ29udGVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb3V0cHV0RmlsZSgpIHtcbiAgICBpZiAodGhpcy5vcHRzLnRvKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy50byk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInRvLmNzc1wiO1xuICAgIH1cbiAgfVxuICBwYXRoKGZpbGUpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmFic29sdXRlKSByZXR1cm4gZmlsZTtcbiAgICBpZiAoZmlsZS5jaGFyQ29kZUF0KDApID09PSA2MCkgcmV0dXJuIGZpbGU7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlO1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkUGF0aHMuZ2V0KGZpbGUpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IGZyb20gPSB0aGlzLm9wdHMudG8gPyBkaXJuYW1lJDIodGhpcy5vcHRzLnRvKSA6IFwiLlwiO1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZyb20gPSBkaXJuYW1lJDIocmVzb2x2ZSQyKGZyb20sIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKSk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gcmVsYXRpdmUkMShmcm9tLCBmaWxlKTtcbiAgICB0aGlzLm1lbW9pemVkUGF0aHMuc2V0KGZpbGUsIHBhdGgpO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHByZXZpb3VzKCkge1xuICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNNYXBzID0gW107XG4gICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgIHRoaXMucm9vdC53YWxrKChub2RlMikgPT4ge1xuICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLmlucHV0Lm1hcCkge1xuICAgICAgICAgICAgbGV0IG1hcCA9IG5vZGUyLnNvdXJjZS5pbnB1dC5tYXA7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzLmluY2x1ZGVzKG1hcCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c01hcHMucHVzaChtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaW5wdXQyID0gbmV3IElucHV0JDMkMSh0aGlzLm9yaWdpbmFsQ1NTLCB0aGlzLm9wdHMpO1xuICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzO1xuICB9XG4gIHNldFNvdXJjZXNDb250ZW50KCkge1xuICAgIGxldCBhbHJlYWR5ID0ge307XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5yb290LndhbGsoKG5vZGUyKSA9PiB7XG4gICAgICAgIGlmIChub2RlMi5zb3VyY2UpIHtcbiAgICAgICAgICBsZXQgZnJvbSA9IG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tO1xuICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmcm9tVXJsID0gdGhpcy51c2VzRmlsZVVybHMgPyB0aGlzLnRvRmlsZVVybChmcm9tKSA6IHRoaXMudG9VcmwodGhpcy5wYXRoKGZyb20pKTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbVVybCwgbm9kZTIuc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICBsZXQgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgIH1cbiAgfVxuICBzb3VyY2VQYXRoKG5vZGUyKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVzZXNGaWxlVXJscykge1xuICAgICAgcmV0dXJuIHRoaXMudG9GaWxlVXJsKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKSk7XG4gICAgfVxuICB9XG4gIHRvQmFzZTY0KHN0cikge1xuICAgIGlmIChCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9XG4gIH1cbiAgdG9GaWxlVXJsKHBhdGgpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGlmIChwYXRoVG9GaWxlVVJMJDIpIHtcbiAgICAgIGxldCBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTCQyKHBhdGgpLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMuc2V0KHBhdGgsIGZpbGVVUkwpO1xuICAgICAgcmV0dXJuIGZpbGVVUkw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJgbWFwLmFic29sdXRlYCBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdG9VcmwocGF0aCkge1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkVVJMcy5nZXQocGF0aCk7XG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICBpZiAoc2VwJDEgPT09IFwiXFxcXFwiKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcbnZhciBtYXBHZW5lcmF0b3IkMSA9IE1hcEdlbmVyYXRvciQyJDE7XG5sZXQgTm9kZSQyJDEgPSBub2RlJDE7XG5sZXQgQ29tbWVudCQ0JDEgPSBjbGFzcyBDb21tZW50IGV4dGVuZHMgTm9kZSQyJDEge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImNvbW1lbnRcIjtcbiAgfVxufTtcbnZhciBjb21tZW50JDEgPSBDb21tZW50JDQkMTtcbkNvbW1lbnQkNCQxLmRlZmF1bHQgPSBDb21tZW50JDQkMTtcbmxldCB7IGlzQ2xlYW46IGlzQ2xlYW4kMSQxLCBteTogbXkkMSQxIH0gPSBzeW1ib2xzJDE7XG5sZXQgRGVjbGFyYXRpb24kMyQxID0gZGVjbGFyYXRpb24kMTtcbmxldCBDb21tZW50JDMkMSA9IGNvbW1lbnQkMTtcbmxldCBOb2RlJDEkMSA9IG5vZGUkMTtcbmxldCBwYXJzZSQ0JDEsIFJ1bGUkNCQxLCBBdFJ1bGUkNCQxLCBSb290JDYkMTtcbmZ1bmN0aW9uIGNsZWFuU291cmNlJDEobm9kZXMpIHtcbiAgcmV0dXJuIG5vZGVzLm1hcCgoaTIpID0+IHtcbiAgICBpZiAoaTIubm9kZXMpIGkyLm5vZGVzID0gY2xlYW5Tb3VyY2UkMShpMi5ub2Rlcyk7XG4gICAgZGVsZXRlIGkyLnNvdXJjZTtcbiAgICByZXR1cm4gaTI7XG4gIH0pO1xufVxuZnVuY3Rpb24gbWFya0RpcnR5VXAkMShub2RlMikge1xuICBub2RlMltpc0NsZWFuJDEkMV0gPSBmYWxzZTtcbiAgaWYgKG5vZGUyLnByb3h5T2Yubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpMiBvZiBub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgICBtYXJrRGlydHlVcCQxKGkyKTtcbiAgICB9XG4gIH1cbn1cbmxldCBDb250YWluZXIkNyQxID0gY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgTm9kZSQxJDEge1xuICBhcHBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMubGFzdCk7XG4gICAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2gobm9kZTIpO1xuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgIHN1cGVyLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7XG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIHRoaXMubm9kZXMpIG5vZGUyLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7XG4gICAgfVxuICB9XG4gIGVhY2goY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICBsZXQgaXRlcmF0b3IgPSB0aGlzLmdldEl0ZXJhdG9yKCk7XG4gICAgbGV0IGluZGV4MiwgcmVzdWx0MjtcbiAgICB3aGlsZSAodGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA8IHRoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICByZXN1bHQyID0gY2FsbGJhY2sodGhpcy5wcm94eU9mLm5vZGVzW2luZGV4Ml0sIGluZGV4Mik7XG4gICAgICBpZiAocmVzdWx0MiA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICBldmVyeShjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjb25kaXRpb24pO1xuICB9XG4gIGdldEl0ZXJhdG9yKCkge1xuICAgIGlmICghdGhpcy5sYXN0RWFjaCkgdGhpcy5sYXN0RWFjaCA9IDA7XG4gICAgaWYgKCF0aGlzLmluZGV4ZXMpIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgIHRoaXMubGFzdEVhY2ggKz0gMTtcbiAgICBsZXQgaXRlcmF0b3IgPSB0aGlzLmxhc3RFYWNoO1xuICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPSAwO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbiAgfVxuICBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgfSBlbHNlIGlmICghbm9kZTJbcHJvcF0pIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJlYWNoXCIgfHwgdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgJiYgcHJvcC5zdGFydHNXaXRoKFwid2Fsa1wiKSkge1xuICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKFxuICAgICAgICAgICAgICAuLi5hcmdzLm1hcCgoaTIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoY2hpbGQsIGluZGV4MikgPT4gaTIoY2hpbGQudG9Qcm94eSgpLCBpbmRleDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZXZlcnlcIiB8fCBwcm9wID09PSBcInNvbWVcIikge1xuICAgICAgICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXShcbiAgICAgICAgICAgICAgKGNoaWxkLCAuLi5vdGhlcikgPT4gY2IoY2hpbGQudG9Qcm94eSgpLCAuLi5vdGhlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgIHJldHVybiBub2RlMi5ub2Rlcy5tYXAoKGkyKSA9PiBpMi50b1Byb3h5KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZmlyc3RcIiB8fCBwcm9wID09PSBcImxhc3RcIikge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXS50b1Byb3h5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZTJbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJzZWxlY3RvclwiKSB7XG4gICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpbmRleChjaGlsZCkge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwibnVtYmVyXCIpIHJldHVybiBjaGlsZDtcbiAgICBpZiAoY2hpbGQucHJveHlPZikgY2hpbGQgPSBjaGlsZC5wcm94eU9mO1xuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gIH1cbiAgaW5zZXJ0QWZ0ZXIoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0pLnJldmVyc2UoKTtcbiAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCArIDEsIDAsIG5vZGUyKTtcbiAgICBsZXQgaW5kZXgyO1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIGlmIChleGlzdEluZGV4IDwgaW5kZXgyKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5zZXJ0QmVmb3JlKGV4aXN0LCBhZGQpIHtcbiAgICBsZXQgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGxldCB0eXBlID0gZXhpc3RJbmRleCA9PT0gMCA/IFwicHJlcGVuZFwiIDogZmFsc2U7XG4gICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0sIHR5cGUpLnJldmVyc2UoKTtcbiAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCwgMCwgbm9kZTIpO1xuICAgIGxldCBpbmRleDI7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgaWYgKGV4aXN0SW5kZXggPD0gaW5kZXgyKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbm9ybWFsaXplKG5vZGVzLCBzYW1wbGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBub2RlcyA9IGNsZWFuU291cmNlJDEocGFyc2UkNCQxKG5vZGVzKS5ub2Rlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG5vZGVzID0gW107XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkyIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSBcInJvb3RcIiAmJiB0aGlzLnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgbm9kZXMgPSBub2Rlcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkyIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfSBlbHNlIGlmIChub2Rlcy5wcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGVzLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGZpZWxkIGlzIG1pc3NlZCBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSBbbmV3IERlY2xhcmF0aW9uJDMkMShub2RlcyldO1xuICAgIH0gZWxzZSBpZiAobm9kZXMuc2VsZWN0b3IpIHtcbiAgICAgIG5vZGVzID0gW25ldyBSdWxlJDQkMShub2RlcyldO1xuICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgbm9kZXMgPSBbbmV3IEF0UnVsZSQ0JDEobm9kZXMpXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgIG5vZGVzID0gW25ldyBDb21tZW50JDMkMShub2RlcyldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZSBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkID0gbm9kZXMubWFwKChpMikgPT4ge1xuICAgICAgaWYgKCFpMltteSQxJDFdKSBDb250YWluZXIucmVidWlsZChpMik7XG4gICAgICBpMiA9IGkyLnByb3h5T2Y7XG4gICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgaWYgKGkyW2lzQ2xlYW4kMSQxXSkgbWFya0RpcnR5VXAkMShpMik7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzYW1wbGUgJiYgdHlwZW9mIHNhbXBsZS5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaTIucGFyZW50ID0gdGhpcy5wcm94eU9mO1xuICAgICAgcmV0dXJuIGkyO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gIH1cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5maXJzdCwgXCJwcmVwZW5kXCIpLnJldmVyc2UoKTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlMik7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IHRoaXMuaW5kZXhlc1tpZF0gKyBub2Rlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaChjaGlsZCkge1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUFsbCgpIHtcbiAgICBmb3IgKGxldCBub2RlMiBvZiB0aGlzLnByb3h5T2Yubm9kZXMpIG5vZGUyLnBhcmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMgPSBbXTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXNbY2hpbGRdLnBhcmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICBsZXQgaW5kZXgyO1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIGlmIChpbmRleDIgPj0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy53YWxrRGVjbHMoKGRlY2wpID0+IHtcbiAgICAgIGlmIChvcHRzLnByb3BzICYmICFvcHRzLnByb3BzLmluY2x1ZGVzKGRlY2wucHJvcCkpIHJldHVybjtcbiAgICAgIGlmIChvcHRzLmZhc3QgJiYgIWRlY2wudmFsdWUuaW5jbHVkZXMob3B0cy5mYXN0KSkgcmV0dXJuO1xuICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZShwYXR0ZXJuLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzb21lKGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgfVxuICB3YWxrKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaCgoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0MjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlMik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0MiAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICByZXN1bHQyID0gY2hpbGQud2FsayhjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9KTtcbiAgfVxuICB3YWxrQXRSdWxlcyhuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrQ29tbWVudHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrRGVjbHMocHJvcCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IHByb3A7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIGNoaWxkLnByb3AgPT09IHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2Fsa1J1bGVzKHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIGNoaWxkLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZmlyc3QoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1swXTtcbiAgfVxuICBnZXQgbGFzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzW3RoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJQYXJzZSA9IChkZXBlbmRhbnQpID0+IHtcbiAgcGFyc2UkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJSdWxlID0gKGRlcGVuZGFudCkgPT4ge1xuICBSdWxlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyQXRSdWxlID0gKGRlcGVuZGFudCkgPT4ge1xuICBBdFJ1bGUkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJSb290ID0gKGRlcGVuZGFudCkgPT4ge1xuICBSb290JDYkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgY29udGFpbmVyJDEgPSBDb250YWluZXIkNyQxO1xuQ29udGFpbmVyJDckMS5kZWZhdWx0ID0gQ29udGFpbmVyJDckMTtcbkNvbnRhaW5lciQ3JDEucmVidWlsZCA9IChub2RlMikgPT4ge1xuICBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQXRSdWxlJDQkMS5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSdWxlJDQkMS5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzJDEucHJvdG90eXBlKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQ29tbWVudCQzJDEucHJvdG90eXBlKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUm9vdCQ2JDEucHJvdG90eXBlKTtcbiAgfVxuICBub2RlMltteSQxJDFdID0gdHJ1ZTtcbiAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgbm9kZTIubm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIENvbnRhaW5lciQ3JDEucmVidWlsZChjaGlsZCk7XG4gICAgfSk7XG4gIH1cbn07XG5sZXQgQ29udGFpbmVyJDYkMSA9IGNvbnRhaW5lciQxO1xubGV0IExhenlSZXN1bHQkNCQxLCBQcm9jZXNzb3IkMyQxO1xubGV0IERvY3VtZW50JDMkMSA9IGNsYXNzIERvY3VtZW50MiBleHRlbmRzIENvbnRhaW5lciQ2JDEge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKHsgdHlwZTogXCJkb2N1bWVudFwiLCAuLi5kZWZhdWx0cyB9KTtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG4gIH1cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdCQ0JDEobmV3IFByb2Nlc3NvciQzJDEoKSwgdGhpcywgb3B0cyk7XG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gIH1cbn07XG5Eb2N1bWVudCQzJDEucmVnaXN0ZXJMYXp5UmVzdWx0ID0gKGRlcGVuZGFudCkgPT4ge1xuICBMYXp5UmVzdWx0JDQkMSA9IGRlcGVuZGFudDtcbn07XG5Eb2N1bWVudCQzJDEucmVnaXN0ZXJQcm9jZXNzb3IgPSAoZGVwZW5kYW50KSA9PiB7XG4gIFByb2Nlc3NvciQzJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGRvY3VtZW50JDEkMSA9IERvY3VtZW50JDMkMTtcbkRvY3VtZW50JDMkMS5kZWZhdWx0ID0gRG9jdW1lbnQkMyQxO1xubGV0IHByaW50ZWQkMSA9IHt9O1xudmFyIHdhcm5PbmNlJDIkMSA9IGZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgaWYgKHByaW50ZWQkMVttZXNzYWdlXSkgcmV0dXJuO1xuICBwcmludGVkJDFbbWVzc2FnZV0gPSB0cnVlO1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59O1xubGV0IFdhcm5pbmckMiQxID0gY2xhc3MgV2FybmluZyB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IFwid2FybmluZ1wiO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgaWYgKG9wdHMubm9kZSAmJiBvcHRzLm5vZGUuc291cmNlKSB7XG4gICAgICBsZXQgcmFuZ2UgPSBvcHRzLm5vZGUucmFuZ2VCeShvcHRzKTtcbiAgICAgIHRoaXMubGluZSA9IHJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICAgIHRoaXMuZW5kTGluZSA9IHJhbmdlLmVuZC5saW5lO1xuICAgICAgdGhpcy5lbmRDb2x1bW4gPSByYW5nZS5lbmQuY29sdW1uO1xuICAgIH1cbiAgICBmb3IgKGxldCBvcHQgaW4gb3B0cykgdGhpc1tvcHRdID0gb3B0c1tvcHRdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICBwbHVnaW46IHRoaXMucGx1Z2luLFxuICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnBsdWdpbikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1Z2luICsgXCI6IFwiICsgdGhpcy50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG59O1xudmFyIHdhcm5pbmckMSA9IFdhcm5pbmckMiQxO1xuV2FybmluZyQyJDEuZGVmYXVsdCA9IFdhcm5pbmckMiQxO1xubGV0IFdhcm5pbmckMSQxID0gd2FybmluZyQxO1xubGV0IFJlc3VsdCQzJDEgPSBjbGFzcyBSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IyLCByb290Miwgb3B0cykge1xuICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNzcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbiAgd2Fybih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB3YXJuaW5nMiA9IG5ldyBXYXJuaW5nJDEkMSh0ZXh0LCBvcHRzKTtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2god2FybmluZzIpO1xuICAgIHJldHVybiB3YXJuaW5nMjtcbiAgfVxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKGkyKSA9PiBpMi50eXBlID09PSBcIndhcm5pbmdcIik7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzO1xuICB9XG59O1xudmFyIHJlc3VsdCQxID0gUmVzdWx0JDMkMTtcblJlc3VsdCQzJDEuZGVmYXVsdCA9IFJlc3VsdCQzJDE7XG5jb25zdCBTSU5HTEVfUVVPVEUkMSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBET1VCTEVfUVVPVEUkMSA9ICdcIicuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEJBQ0tTTEFTSCQxID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNMQVNIJDEgPSBcIi9cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgTkVXTElORSQxID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgU1BBQ0UkMSA9IFwiIFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBGRUVEJDEgPSBcIlxcZlwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBUQUIkMSA9IFwiXHRcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ1IkMSA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fU1FVQVJFJDEgPSBcIltcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfU1FVQVJFJDEgPSBcIl1cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgT1BFTl9QQVJFTlRIRVNFUyQxID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX1BBUkVOVEhFU0VTJDEgPSBcIilcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgT1BFTl9DVVJMWSQxID0gXCJ7XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX0NVUkxZJDEgPSBcIn1cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgU0VNSUNPTE9OJDEgPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQVNURVJJU0skMSA9IFwiKlwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDT0xPTiQxID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEFUJDEgPSBcIkBcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgUkVfQVRfRU5EJDEgPSAvW1xcdFxcblxcZlxcciBcIiMnKCkvO1tcXFxcXFxde31dL2c7XG5jb25zdCBSRV9XT1JEX0VORCQxID0gL1tcXHRcXG5cXGZcXHIgIVwiIycoKTo7QFtcXFxcXFxde31dfFxcLyg/PVxcKikvZztcbmNvbnN0IFJFX0JBRF9CUkFDS0VUJDEgPSAvLltcXHJcXG5cIicoL1xcXFxdLztcbmNvbnN0IFJFX0hFWF9FU0NBUEUkMSA9IC9bXFxkYS1mXS9pO1xudmFyIHRva2VuaXplJDEgPSBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQyLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGNzcyA9IGlucHV0Mi5jc3MudmFsdWVPZigpO1xuICBsZXQgaWdub3JlID0gb3B0aW9ucy5pZ25vcmVFcnJvcnM7XG4gIGxldCBjb2RlLCBuZXh0LCBxdW90ZSwgY29udGVudCwgZXNjYXBlO1xuICBsZXQgZXNjYXBlZCwgZXNjYXBlUG9zLCBwcmV2LCBuMiwgY3VycmVudFRva2VuO1xuICBsZXQgbGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBidWZmZXIgPSBbXTtcbiAgbGV0IHJldHVybmVkID0gW107XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCkge1xuICAgIHRocm93IGlucHV0Mi5lcnJvcihcIlVuY2xvc2VkIFwiICsgd2hhdCwgcG9zKTtcbiAgfVxuICBmdW5jdGlvbiBlbmRPZkZpbGUoKSB7XG4gICAgcmV0dXJuIHJldHVybmVkLmxlbmd0aCA9PT0gMCAmJiBwb3MgPj0gbGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpO1xuICAgIGlmIChwb3MgPj0gbGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZTtcbiAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKTtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgTkVXTElORSQxOlxuICAgICAgY2FzZSBTUEFDRSQxOlxuICAgICAgY2FzZSBUQUIkMTpcbiAgICAgIGNhc2UgQ1IkMTpcbiAgICAgIGNhc2UgRkVFRCQxOiB7XG4gICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICB9IHdoaWxlIChjb2RlID09PSBTUEFDRSQxIHx8IGNvZGUgPT09IE5FV0xJTkUkMSB8fCBjb2RlID09PSBUQUIkMSB8fCBjb2RlID09PSBDUiQxIHx8IGNvZGUgPT09IEZFRUQkMSk7XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcInNwYWNlXCIsIGNzcy5zbGljZShwb3MsIG5leHQpXTtcbiAgICAgICAgcG9zID0gbmV4dCAtIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBPUEVOX1NRVUFSRSQxOlxuICAgICAgY2FzZSBDTE9TRV9TUVVBUkUkMTpcbiAgICAgIGNhc2UgT1BFTl9DVVJMWSQxOlxuICAgICAgY2FzZSBDTE9TRV9DVVJMWSQxOlxuICAgICAgY2FzZSBDT0xPTiQxOlxuICAgICAgY2FzZSBTRU1JQ09MT04kMTpcbiAgICAgIGNhc2UgQ0xPU0VfUEFSRU5USEVTRVMkMToge1xuICAgICAgICBsZXQgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbY29udHJvbENoYXIsIGNvbnRyb2xDaGFyLCBwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUyQxOiB7XG4gICAgICAgIHByZXYgPSBidWZmZXIubGVuZ3RoID8gYnVmZmVyLnBvcCgpWzFdIDogXCJcIjtcbiAgICAgICAgbjIgPSBjc3MuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICAgICAgaWYgKHByZXYgPT09IFwidXJsXCIgJiYgbjIgIT09IFNJTkdMRV9RVU9URSQxICYmIG4yICE9PSBET1VCTEVfUVVPVEUkMSAmJiBuMiAhPT0gU1BBQ0UkMSAmJiBuMiAhPT0gTkVXTElORSQxICYmIG4yICE9PSBUQUIkMSAmJiBuMiAhPT0gRkVFRCQxICYmIG4yICE9PSBDUiQxKSB7XG4gICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIG5leHQgKyAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmNsb3NlZChcImJyYWNrZXRcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG4gICAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCQxKSB7XG4gICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgY3VycmVudFRva2VuID0gW1wiYnJhY2tldHNcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBwb3MgKyAxKTtcbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVCQxLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcIihcIiwgXCIoXCIsIHBvc107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcImJyYWNrZXRzXCIsIGNvbnRlbnQsIHBvcywgbmV4dF07XG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgU0lOR0xFX1FVT1RFJDE6XG4gICAgICBjYXNlIERPVUJMRV9RVU9URSQxOiB7XG4gICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFJDEgPyBcIidcIiA6ICdcIic7XG4gICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKHF1b3RlLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuY2xvc2VkKFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIJDEpIHtcbiAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcInN0cmluZ1wiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBBVCQxOiB7XG4gICAgICAgIFJFX0FUX0VORCQxLmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgIFJFX0FUX0VORCQxLnRlc3QoY3NzKTtcbiAgICAgICAgaWYgKFJFX0FUX0VORCQxLmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gUkVfQVRfRU5EJDEubGFzdEluZGV4IC0gMjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJhdC13b3JkXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEJBQ0tTTEFTSCQxOiB7XG4gICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IEJBQ0tTTEFTSCQxKSB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgICAgaWYgKGVzY2FwZSAmJiBjb2RlICE9PSBTTEFTSCQxICYmIGNvZGUgIT09IFNQQUNFJDEgJiYgY29kZSAhPT0gTkVXTElORSQxICYmIGNvZGUgIT09IFRBQiQxICYmIGNvZGUgIT09IENSJDEgJiYgY29kZSAhPT0gRkVFRCQxKSB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGlmIChSRV9IRVhfRVNDQVBFJDEudGVzdChjc3MuY2hhckF0KG5leHQpKSkge1xuICAgICAgICAgICAgd2hpbGUgKFJFX0hFWF9FU0NBUEUkMS50ZXN0KGNzcy5jaGFyQXQobmV4dCArIDEpKSkge1xuICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBTUEFDRSQxKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRva2VuID0gW1wid29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0gkMSAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0skMSkge1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHBvcyArIDIpICsgMTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuY2xvc2VkKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFRva2VuID0gW1wiY29tbWVudFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSRV9XT1JEX0VORCQxLmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgUkVfV09SRF9FTkQkMS50ZXN0KGNzcyk7XG4gICAgICAgICAgaWYgKFJFX1dPUkRfRU5EJDEubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORCQxLmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcIndvcmRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgfVxuICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgcmV0dXJuZWQucHVzaCh0b2tlbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYWNrLFxuICAgIGVuZE9mRmlsZSxcbiAgICBuZXh0VG9rZW4sXG4gICAgcG9zaXRpb25cbiAgfTtcbn07XG5sZXQgQ29udGFpbmVyJDUkMSA9IGNvbnRhaW5lciQxO1xubGV0IEF0UnVsZSQzJDEgPSBjbGFzcyBBdFJ1bGUgZXh0ZW5kcyBDb250YWluZXIkNSQxIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJhdHJ1bGVcIjtcbiAgfVxuICBhcHBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHJldHVybiBzdXBlci5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICB9XG4gIHByZXBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHJldHVybiBzdXBlci5wcmVwZW5kKC4uLmNoaWxkcmVuKTtcbiAgfVxufTtcbnZhciBhdFJ1bGUkMSA9IEF0UnVsZSQzJDE7XG5BdFJ1bGUkMyQxLmRlZmF1bHQgPSBBdFJ1bGUkMyQxO1xuQ29udGFpbmVyJDUkMS5yZWdpc3RlckF0UnVsZShBdFJ1bGUkMyQxKTtcbmxldCBDb250YWluZXIkNCQxID0gY29udGFpbmVyJDE7XG5sZXQgTGF6eVJlc3VsdCQzJDEsIFByb2Nlc3NvciQyJDE7XG5sZXQgUm9vdCQ1JDEgPSBjbGFzcyBSb290IGV4dGVuZHMgQ29udGFpbmVyJDQkMSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICB9XG4gIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgbGV0IG5vZGVzID0gc3VwZXIubm9ybWFsaXplKGNoaWxkKTtcbiAgICBpZiAoc2FtcGxlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHNhbXBsZS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQsIGlnbm9yZSkge1xuICAgIGxldCBpbmRleDIgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICBpZiAoIWlnbm9yZSAmJiBpbmRleDIgPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleDJdLnJhd3MuYmVmb3JlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRvUmVzdWx0KG9wdHMgPSB7fSkge1xuICAgIGxldCBsYXp5ID0gbmV3IExhenlSZXN1bHQkMyQxKG5ldyBQcm9jZXNzb3IkMiQxKCksIHRoaXMsIG9wdHMpO1xuICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICB9XG59O1xuUm9vdCQ1JDEucmVnaXN0ZXJMYXp5UmVzdWx0ID0gKGRlcGVuZGFudCkgPT4ge1xuICBMYXp5UmVzdWx0JDMkMSA9IGRlcGVuZGFudDtcbn07XG5Sb290JDUkMS5yZWdpc3RlclByb2Nlc3NvciA9IChkZXBlbmRhbnQpID0+IHtcbiAgUHJvY2Vzc29yJDIkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgcm9vdCQxID0gUm9vdCQ1JDE7XG5Sb290JDUkMS5kZWZhdWx0ID0gUm9vdCQ1JDE7XG5Db250YWluZXIkNCQxLnJlZ2lzdGVyUm9vdChSb290JDUkMSk7XG5sZXQgbGlzdCQyJDEgPSB7XG4gIGNvbW1hKHN0cmluZykge1xuICAgIHJldHVybiBsaXN0JDIkMS5zcGxpdChzdHJpbmcsIFtcIixcIl0sIHRydWUpO1xuICB9LFxuICBzcGFjZShzdHJpbmcpIHtcbiAgICBsZXQgc3BhY2VzID0gW1wiIFwiLCBcIlxcblwiLCBcIlx0XCJdO1xuICAgIHJldHVybiBsaXN0JDIkMS5zcGxpdChzdHJpbmcsIHNwYWNlcyk7XG4gIH0sXG4gIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgIGxldCBhcnJheSA9IFtdO1xuICAgIGxldCBjdXJyZW50ID0gXCJcIjtcbiAgICBsZXQgc3BsaXQgPSBmYWxzZTtcbiAgICBsZXQgZnVuYyA9IDA7XG4gICAgbGV0IGluUXVvdGUgPSBmYWxzZTtcbiAgICBsZXQgcHJldlF1b3RlID0gXCJcIjtcbiAgICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgbGV0dGVyIG9mIHN0cmluZykge1xuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3RlKSB7XG4gICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgcHJldlF1b3RlID0gbGV0dGVyO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKFwiKSB7XG4gICAgICAgIGZ1bmMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIilcIikge1xuICAgICAgICBpZiAoZnVuYyA+IDApIGZ1bmMgLT0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmNsdWRlcyhsZXR0ZXIpKSBzcGxpdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgc3BsaXQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCB8fCBjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG52YXIgbGlzdF8xJDEgPSBsaXN0JDIkMTtcbmxpc3QkMiQxLmRlZmF1bHQgPSBsaXN0JDIkMTtcbmxldCBDb250YWluZXIkMyQxID0gY29udGFpbmVyJDE7XG5sZXQgbGlzdCQxJDEgPSBsaXN0XzEkMTtcbmxldCBSdWxlJDMkMSA9IGNsYXNzIFJ1bGUgZXh0ZW5kcyBDb250YWluZXIkMyQxIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJydWxlXCI7XG4gICAgaWYgKCF0aGlzLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gIH1cbiAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gbGlzdCQxJDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gIH1cbiAgc2V0IHNlbGVjdG9ycyh2YWx1ZXMpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKSA6IG51bGw7XG4gICAgbGV0IHNlcDIgPSBtYXRjaCA/IG1hdGNoWzBdIDogXCIsXCIgKyB0aGlzLnJhdyhcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgIHRoaXMuc2VsZWN0b3IgPSB2YWx1ZXMuam9pbihzZXAyKTtcbiAgfVxufTtcbnZhciBydWxlJDEgPSBSdWxlJDMkMTtcblJ1bGUkMyQxLmRlZmF1bHQgPSBSdWxlJDMkMTtcbkNvbnRhaW5lciQzJDEucmVnaXN0ZXJSdWxlKFJ1bGUkMyQxKTtcbmxldCBEZWNsYXJhdGlvbiQyJDEgPSBkZWNsYXJhdGlvbiQxO1xubGV0IHRva2VuaXplcjIkMSA9IHRva2VuaXplJDE7XG5sZXQgQ29tbWVudCQyJDEgPSBjb21tZW50JDE7XG5sZXQgQXRSdWxlJDIkMSA9IGF0UnVsZSQxO1xubGV0IFJvb3QkNCQxID0gcm9vdCQxO1xubGV0IFJ1bGUkMiQxID0gcnVsZSQxO1xuY29uc3QgU0FGRV9DT01NRU5UX05FSUdIQk9SJDEgPSB7XG4gIGVtcHR5OiB0cnVlLFxuICBzcGFjZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGZpbmRMYXN0V2l0aFBvc2l0aW9uJDEodG9rZW5zKSB7XG4gIGZvciAobGV0IGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgIGxldCBwb3MgPSB0b2tlblszXSB8fCB0b2tlblsyXTtcbiAgICBpZiAocG9zKSByZXR1cm4gcG9zO1xuICB9XG59XG5sZXQgUGFyc2VyJDEkMSA9IGNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0Mikge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDI7XG4gICAgdGhpcy5yb290ID0gbmV3IFJvb3QkNCQxKCk7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgdGhpcy5yb290LnNvdXJjZSA9IHsgaW5wdXQ6IGlucHV0Miwgc3RhcnQ6IHsgY29sdW1uOiAxLCBsaW5lOiAxLCBvZmZzZXQ6IDAgfSB9O1xuICB9XG4gIGF0cnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBBdFJ1bGUkMiQxKCk7XG4gICAgbm9kZTIubmFtZSA9IHRva2VuWzFdLnNsaWNlKDEpO1xuICAgIGlmIChub2RlMi5uYW1lID09PSBcIlwiKSB7XG4gICAgICB0aGlzLnVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IHByZXY7XG4gICAgbGV0IHNoaWZ0O1xuICAgIGxldCBsYXN0ID0gZmFsc2U7XG4gICAgbGV0IG9wZW4gPSBmYWxzZTtcbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiICYmIGJyYWNrZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSk7XG4gICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdO1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgJiYgcHJldlswXSA9PT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihwcmV2WzNdIHx8IHByZXZbMl0pO1xuICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgICAgbGFzdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZChwYXJhbXMpO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTtcbiAgICAgIHRoaXMucmF3KG5vZGUyLCBcInBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgdG9rZW4gPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gbm9kZTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IFwiXCI7XG4gICAgICBub2RlMi5wYXJhbXMgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAob3Blbikge1xuICAgICAgbm9kZTIubm9kZXMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgIH1cbiAgfVxuICBjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpIHtcbiAgICBsZXQgY29sb24gPSB0aGlzLmNvbG9uKHRva2Vucyk7XG4gICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGxldCBmb3VuZGVkID0gMDtcbiAgICBsZXQgdG9rZW47XG4gICAgZm9yIChsZXQgaiA9IGNvbG9uIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2pdO1xuICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgZm91bmRlZCArPSAxO1xuICAgICAgICBpZiAoZm91bmRlZCA9PT0gMikgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIk1pc3NlZCBzZW1pY29sb25cIixcbiAgICAgIHRva2VuWzBdID09PSBcIndvcmRcIiA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdXG4gICAgKTtcbiAgfVxuICBjb2xvbih0b2tlbnMpIHtcbiAgICBsZXQgYnJhY2tldHMgPSAwO1xuICAgIGxldCB0b2tlbiwgdHlwZSwgcHJldjtcbiAgICBmb3IgKGxldCBbaTIsIGVsZW1lbnRdIG9mIHRva2Vucy5lbnRyaWVzKCkpIHtcbiAgICAgIHRva2VuID0gZWxlbWVudDtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcIihcIikge1xuICAgICAgICBicmFja2V0cyArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiKVwiKSB7XG4gICAgICAgIGJyYWNrZXRzIC09IDE7XG4gICAgICB9XG4gICAgICBpZiAoYnJhY2tldHMgPT09IDAgJiYgdHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgdGhpcy5kb3VibGVDb2xvbih0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldlswXSA9PT0gXCJ3b3JkXCIgJiYgcHJldlsxXSA9PT0gXCJwcm9naWRcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldiA9IHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29tbWVudCh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBDb21tZW50JDIkMSgpO1xuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzNdIHx8IHRva2VuWzJdKTtcbiAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgIGxldCB0ZXh0ID0gdG9rZW5bMV0uc2xpY2UoMiwgLTIpO1xuICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICBub2RlMi50ZXh0ID0gXCJcIjtcbiAgICAgIG5vZGUyLnJhd3MubGVmdCA9IHRleHQ7XG4gICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1hdGNoID0gdGV4dC5tYXRjaCgvXihcXHMqKShbXl0qXFxTKShcXHMqKSQvKTtcbiAgICAgIG5vZGUyLnRleHQgPSBtYXRjaFsyXTtcbiAgICAgIG5vZGUyLnJhd3MubGVmdCA9IG1hdGNoWzFdO1xuICAgICAgbm9kZTIucmF3cy5yaWdodCA9IG1hdGNoWzNdO1xuICAgIH1cbiAgfVxuICBjcmVhdGVUb2tlbml6ZXIoKSB7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIyJDEodGhpcy5pbnB1dCk7XG4gIH1cbiAgZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgbGV0IG5vZGUyID0gbmV3IERlY2xhcmF0aW9uJDIkMSgpO1xuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICBsZXQgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RbMF0gPT09IFwiO1wiKSB7XG4gICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICB0b2tlbnMucG9wKCk7XG4gICAgfVxuICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKFxuICAgICAgbGFzdFszXSB8fCBsYXN0WzJdIHx8IGZpbmRMYXN0V2l0aFBvc2l0aW9uJDEodG9rZW5zKVxuICAgICk7XG4gICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICB3aGlsZSAodG9rZW5zWzBdWzBdICE9PSBcIndvcmRcIikge1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgbm9kZTIucHJvcCA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxldCB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUyLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgbGV0IHRva2VuO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgaWYgKHRva2VuWzBdID09PSBcIjpcIikge1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSBcIndvcmRcIiAmJiAvXFx3Ly50ZXN0KHRva2VuWzFdKSkge1xuICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW3Rva2VuXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZTIucHJvcFswXSA9PT0gXCJfXCIgfHwgbm9kZTIucHJvcFswXSA9PT0gXCIqXCIpIHtcbiAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IG5vZGUyLnByb3BbMF07XG4gICAgICBub2RlMi5wcm9wID0gbm9kZTIucHJvcC5zbGljZSgxKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0U3BhY2VzID0gW107XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIGZpcnN0U3BhY2VzLnB1c2godG9rZW5zLnNoaWZ0KCkpO1xuICAgIH1cbiAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgZm9yIChsZXQgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiIWltcG9ydGFudFwiKSB7XG4gICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nO1xuICAgICAgICBpZiAoc3RyaW5nICE9PSBcIiAhaW1wb3J0YW50XCIpIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICBsZXQgY2FjaGUgPSB0b2tlbnMuc2xpY2UoMCk7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBqID0gaTI7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwICYmIHR5cGUgIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGNhY2hlLnBvcCgpWzFdICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwKSB7XG4gICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cjtcbiAgICAgICAgICB0b2tlbnMgPSBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIgJiYgdG9rZW5bMF0gIT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGFzV29yZCA9IHRva2Vucy5zb21lKChpMikgPT4gaTJbMF0gIT09IFwic3BhY2VcIiAmJiBpMlswXSAhPT0gXCJjb21tZW50XCIpO1xuICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKChpMikgPT4gaTJbMV0pLmpvaW4oXCJcIik7XG4gICAgICBmaXJzdFNwYWNlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnJhdyhub2RlMiwgXCJ2YWx1ZVwiLCBmaXJzdFNwYWNlcy5jb25jYXQodG9rZW5zKSwgY3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChub2RlMi52YWx1ZS5pbmNsdWRlcyhcIjpcIikgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgfVxuICB9XG4gIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiRG91YmxlIGNvbG9uXCIsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aCB9XG4gICAgKTtcbiAgfVxuICBlbXB0eVJ1bGUodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgUnVsZSQyJDEoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICBub2RlMi5zZWxlY3RvciA9IFwiXCI7XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgfVxuICBlbmQodG9rZW4pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8IFwiXCIpICsgdGhpcy5zcGFjZXM7XG4gICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWRDbG9zZSh0b2tlbik7XG4gICAgfVxuICB9XG4gIGVuZEZpbGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHRoaXMudW5jbG9zZWRCbG9jaygpO1xuICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8IFwiXCIpICsgdGhpcy5zcGFjZXM7XG4gICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpO1xuICB9XG4gIGZyZWVTZW1pY29sb24odG9rZW4pIHtcbiAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwicnVsZVwiICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgIHByZXYucmF3cy5vd25TZW1pY29sb24gPSB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBIZWxwZXJzXG4gIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmlucHV0LmZyb21PZmZzZXQob2Zmc2V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uOiBwb3MuY29sLFxuICAgICAgbGluZTogcG9zLmxpbmUsXG4gICAgICBvZmZzZXRcbiAgICB9O1xuICB9XG4gIGluaXQobm9kZTIsIG9mZnNldCkge1xuICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUyKTtcbiAgICBub2RlMi5zb3VyY2UgPSB7XG4gICAgICBpbnB1dDogdGhpcy5pbnB1dCxcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFBvc2l0aW9uKG9mZnNldClcbiAgICB9O1xuICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gdGhpcy5zcGFjZXM7XG4gICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgfVxuICBvdGhlcihzdGFydCkge1xuICAgIGxldCBlbmQgPSBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgbGV0IGNvbG9uID0gZmFsc2U7XG4gICAgbGV0IGJyYWNrZXQgPSBudWxsO1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjdXN0b21Qcm9wZXJ0eSA9IHN0YXJ0WzFdLnN0YXJ0c1dpdGgoXCItLVwiKTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IHRva2VuID0gc3RhcnQ7XG4gICAgd2hpbGUgKHRva2VuKSB7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VzdG9tUHJvcGVydHkgJiYgY29sb24gJiYgdHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgaWYgKGNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgIHRoaXMucnVsZSh0b2tlbnMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgY29sb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSBicmFja2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZTtcbiAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldCk7XG4gICAgaWYgKGVuZCAmJiBjb2xvbikge1xuICAgICAgaWYgKCFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgIHRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICBpZiAodG9rZW4gIT09IFwic3BhY2VcIiAmJiB0b2tlbiAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgfVxuICB9XG4gIHBhcnNlKCkge1xuICAgIGxldCB0b2tlbjtcbiAgICB3aGlsZSAoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICBjYXNlIFwic3BhY2VcIjpcbiAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICB0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXQtd29yZFwiOlxuICAgICAgICAgIHRoaXMuYXRydWxlKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICB0aGlzLmVtcHR5UnVsZSh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5vdGhlcih0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5kRmlsZSgpO1xuICB9XG4gIHByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKCkge1xuICB9XG4gIHJhdyhub2RlMiwgcHJvcCwgdG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCB0b2tlbiwgdHlwZTtcbiAgICBsZXQgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxldCBjbGVhbiA9IHRydWU7XG4gICAgbGV0IG5leHQsIHByZXY7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwic3BhY2VcIiAmJiBpMiA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgcHJldiA9IHRva2Vuc1tpMiAtIDFdID8gdG9rZW5zW2kyIC0gMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgIG5leHQgPSB0b2tlbnNbaTIgKyAxXSA/IHRva2Vuc1tpMiArIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICBpZiAoIVNBRkVfQ09NTUVOVF9ORUlHSEJPUiQxW3ByZXZdICYmICFTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMVtuZXh0XSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2xlYW4pIHtcbiAgICAgIGxldCByYXcgPSB0b2tlbnMucmVkdWNlKChhbGwsIGkyKSA9PiBhbGwgKyBpMlsxXSwgXCJcIik7XG4gICAgICBub2RlMi5yYXdzW3Byb3BdID0geyByYXcsIHZhbHVlIH07XG4gICAgfVxuICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gIH1cbiAgcnVsZSh0b2tlbnMpIHtcbiAgICB0b2tlbnMucG9wKCk7XG4gICAgbGV0IG5vZGUyID0gbmV3IFJ1bGUkMiQxKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyk7XG4gICAgdGhpcy5yYXcobm9kZTIsIFwic2VsZWN0b3JcIiwgdG9rZW5zKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgfVxuICBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGU7XG4gICAgbGV0IHNwYWNlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIiAmJiBsYXN0VG9rZW5UeXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgLy8gRXJyb3JzXG4gIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucykge1xuICAgIGxldCBuZXh0O1xuICAgIGxldCBzcGFjZXMgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgc3BhY2VzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFRva2VuVHlwZTtcbiAgICBsZXQgc3BhY2VzID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiKSBicmVhaztcbiAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlcztcbiAgfVxuICBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpMiA9IGZyb207IGkyIDwgdG9rZW5zLmxlbmd0aDsgaTIrKykge1xuICAgICAgcmVzdWx0MiArPSB0b2tlbnNbaTJdWzFdO1xuICAgIH1cbiAgICB0b2tlbnMuc3BsaWNlKGZyb20sIHRva2Vucy5sZW5ndGggLSBmcm9tKTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB1bmNsb3NlZEJsb2NrKCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0O1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBibG9ja1wiLCBwb3MubGluZSwgcG9zLmNvbHVtbik7XG4gIH1cbiAgdW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmNsb3NlZCBicmFja2V0XCIsXG4gICAgICB7IG9mZnNldDogYnJhY2tldFsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IGJyYWNrZXRbMl0gKyAxIH1cbiAgICApO1xuICB9XG4gIHVuZXhwZWN0ZWRDbG9zZSh0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgfVwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyAxIH1cbiAgICApO1xuICB9XG4gIHVua25vd25Xb3JkKHRva2Vucykge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIlVua25vd24gd29yZFwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSArIHRva2Vuc1swXVsxXS5sZW5ndGggfVxuICAgICk7XG4gIH1cbiAgdW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJBdC1ydWxlIHdpdGhvdXQgbmFtZVwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGggfVxuICAgICk7XG4gIH1cbn07XG52YXIgcGFyc2VyJDEgPSBQYXJzZXIkMSQxO1xubGV0IENvbnRhaW5lciQyJDEgPSBjb250YWluZXIkMTtcbmxldCBQYXJzZXIyJDEgPSBwYXJzZXIkMTtcbmxldCBJbnB1dCQyJDEgPSBpbnB1dCQxO1xuZnVuY3Rpb24gcGFyc2UkMyQxKGNzcywgb3B0cykge1xuICBsZXQgaW5wdXQyID0gbmV3IElucHV0JDIkMShjc3MsIG9wdHMpO1xuICBsZXQgcGFyc2VyMiA9IG5ldyBQYXJzZXIyJDEoaW5wdXQyKTtcbiAgdHJ5IHtcbiAgICBwYXJzZXIyLnBhcnNlKCk7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKGUyLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiBvcHRzICYmIG9wdHMuZnJvbSkge1xuICAgICAgICBpZiAoL1xcLnNjc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcLnNhc3MvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFwubGVzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlMjtcbiAgfVxuICByZXR1cm4gcGFyc2VyMi5yb290O1xufVxudmFyIHBhcnNlXzEkMSA9IHBhcnNlJDMkMTtcbnBhcnNlJDMkMS5kZWZhdWx0ID0gcGFyc2UkMyQxO1xuQ29udGFpbmVyJDIkMS5yZWdpc3RlclBhcnNlKHBhcnNlJDMkMSk7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDMsIG15OiBteSQzIH0gPSBzeW1ib2xzJDE7XG5sZXQgTWFwR2VuZXJhdG9yJDEkMSA9IG1hcEdlbmVyYXRvciQxO1xubGV0IHN0cmluZ2lmeSQyJDEgPSBzdHJpbmdpZnlfMSQxO1xubGV0IENvbnRhaW5lciQxJDEgPSBjb250YWluZXIkMTtcbmxldCBEb2N1bWVudCQyJDEgPSBkb2N1bWVudCQxJDE7XG5sZXQgd2Fybk9uY2UkMSQxID0gd2Fybk9uY2UkMiQxO1xubGV0IFJlc3VsdCQyJDEgPSByZXN1bHQkMTtcbmxldCBwYXJzZSQyJDEgPSBwYXJzZV8xJDE7XG5sZXQgUm9vdCQzJDEgPSByb290JDE7XG5jb25zdCBUWVBFX1RPX0NMQVNTX05BTUUkMSA9IHtcbiAgYXRydWxlOiBcIkF0UnVsZVwiLFxuICBjb21tZW50OiBcIkNvbW1lbnRcIixcbiAgZGVjbDogXCJEZWNsYXJhdGlvblwiLFxuICBkb2N1bWVudDogXCJEb2N1bWVudFwiLFxuICByb290OiBcIlJvb3RcIixcbiAgcnVsZTogXCJSdWxlXCJcbn07XG5jb25zdCBQTFVHSU5fUFJPUFMkMSA9IHtcbiAgQXRSdWxlOiB0cnVlLFxuICBBdFJ1bGVFeGl0OiB0cnVlLFxuICBDb21tZW50OiB0cnVlLFxuICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgRGVjbGFyYXRpb246IHRydWUsXG4gIERlY2xhcmF0aW9uRXhpdDogdHJ1ZSxcbiAgRG9jdW1lbnQ6IHRydWUsXG4gIERvY3VtZW50RXhpdDogdHJ1ZSxcbiAgT25jZTogdHJ1ZSxcbiAgT25jZUV4aXQ6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWUsXG4gIFJvb3Q6IHRydWUsXG4gIFJvb3RFeGl0OiB0cnVlLFxuICBSdWxlOiB0cnVlLFxuICBSdWxlRXhpdDogdHJ1ZVxufTtcbmNvbnN0IE5PVF9WSVNJVE9SUyQxID0ge1xuICBPbmNlOiB0cnVlLFxuICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICBwcmVwYXJlOiB0cnVlXG59O1xuY29uc3QgQ0hJTERSRU4kMSA9IDA7XG5mdW5jdGlvbiBpc1Byb21pc2UkMShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRFdmVudHMkMShub2RlMikge1xuICBsZXQga2V5ID0gZmFsc2U7XG4gIGxldCB0eXBlID0gVFlQRV9UT19DTEFTU19OQU1FJDFbbm9kZTIudHlwZV07XG4gIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgIGtleSA9IG5vZGUyLnByb3AudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAga2V5ID0gbm9kZTIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGlmIChrZXkgJiYgbm9kZTIuYXBwZW5kKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGUsXG4gICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICBDSElMRFJFTiQxLFxuICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgIF07XG4gIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIFt0eXBlLCB0eXBlICsgXCItXCIgKyBrZXksIHR5cGUgKyBcIkV4aXRcIiwgdHlwZSArIFwiRXhpdC1cIiArIGtleV07XG4gIH0gZWxzZSBpZiAobm9kZTIuYXBwZW5kKSB7XG4gICAgcmV0dXJuIFt0eXBlLCBDSElMRFJFTiQxLCB0eXBlICsgXCJFeGl0XCJdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArIFwiRXhpdFwiXTtcbiAgfVxufVxuZnVuY3Rpb24gdG9TdGFjayQxKG5vZGUyKSB7XG4gIGxldCBldmVudHM7XG4gIGlmIChub2RlMi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICBldmVudHMgPSBbXCJEb2N1bWVudFwiLCBDSElMRFJFTiQxLCBcIkRvY3VtZW50RXhpdFwiXTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgIGV2ZW50cyA9IFtcIlJvb3RcIiwgQ0hJTERSRU4kMSwgXCJSb290RXhpdFwiXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBnZXRFdmVudHMkMShub2RlMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBldmVudEluZGV4OiAwLFxuICAgIGV2ZW50cyxcbiAgICBpdGVyYXRvcjogMCxcbiAgICBub2RlOiBub2RlMixcbiAgICB2aXNpdG9ySW5kZXg6IDAsXG4gICAgdmlzaXRvcnM6IFtdXG4gIH07XG59XG5mdW5jdGlvbiBjbGVhbk1hcmtzJDEobm9kZTIpIHtcbiAgbm9kZTJbaXNDbGVhbiQzXSA9IGZhbHNlO1xuICBpZiAobm9kZTIubm9kZXMpIG5vZGUyLm5vZGVzLmZvckVhY2goKGkyKSA9PiBjbGVhbk1hcmtzJDEoaTIpKTtcbiAgcmV0dXJuIG5vZGUyO1xufVxubGV0IHBvc3Rjc3MkMiQxID0ge307XG5sZXQgTGF6eVJlc3VsdCQyJDEgPSBjbGFzcyBMYXp5UmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgbGV0IHJvb3QyO1xuICAgIGlmICh0eXBlb2YgY3NzID09PSBcIm9iamVjdFwiICYmIGNzcyAhPT0gbnVsbCAmJiAoY3NzLnR5cGUgPT09IFwicm9vdFwiIHx8IGNzcy50eXBlID09PSBcImRvY3VtZW50XCIpKSB7XG4gICAgICByb290MiA9IGNsZWFuTWFya3MkMShjc3MpO1xuICAgIH0gZWxzZSBpZiAoY3NzIGluc3RhbmNlb2YgTGF6eVJlc3VsdCB8fCBjc3MgaW5zdGFuY2VvZiBSZXN1bHQkMiQxKSB7XG4gICAgICByb290MiA9IGNsZWFuTWFya3MkMShjc3Mucm9vdCk7XG4gICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWFwID09PSBcInVuZGVmaW5lZFwiKSBvcHRzLm1hcCA9IHt9O1xuICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2U7XG4gICAgICAgIG9wdHMubWFwLnByZXYgPSBjc3MubWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFyc2VyMiA9IHBhcnNlJDIkMTtcbiAgICAgIGlmIChvcHRzLnN5bnRheCkgcGFyc2VyMiA9IG9wdHMuc3ludGF4LnBhcnNlO1xuICAgICAgaWYgKG9wdHMucGFyc2VyKSBwYXJzZXIyID0gb3B0cy5wYXJzZXI7XG4gICAgICBpZiAocGFyc2VyMi5wYXJzZSkgcGFyc2VyMiA9IHBhcnNlcjIucGFyc2U7XG4gICAgICB0cnkge1xuICAgICAgICByb290MiA9IHBhcnNlcjIoY3NzLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QyICYmICFyb290MltteSQzXSkge1xuICAgICAgICBDb250YWluZXIkMSQxLnJlYnVpbGQocm9vdDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMiQxKHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKTtcbiAgICB0aGlzLmhlbHBlcnMgPSB7IC4uLnBvc3Rjc3MkMiQxLCBwb3N0Y3NzOiBwb3N0Y3NzJDIkMSwgcmVzdWx0OiB0aGlzLnJlc3VsdCB9O1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucHJvY2Vzc29yLnBsdWdpbnMubWFwKChwbHVnaW4yMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5wcmVwYXJlKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnBsdWdpbjIyLCAuLi5wbHVnaW4yMi5wcmVwYXJlKHRoaXMucmVzdWx0KSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbjIyO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nO1xuICB9XG4gIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgfVxuICBnZXRBc3luY0Vycm9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnNcIik7XG4gIH1cbiAgaGFuZGxlRXJyb3IoZXJyb3IsIG5vZGUyKSB7XG4gICAgbGV0IHBsdWdpbjIyID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpbjtcbiAgICB0cnkge1xuICAgICAgaWYgKG5vZGUyKSBub2RlMi5hZGRUb0Vycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICBlcnJvci5zZXRNZXNzYWdlKCk7XG4gICAgICB9IGVsc2UgaWYgKHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgcGx1Z2luTmFtZSA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgbGV0IHBsdWdpblZlciA9IHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uO1xuICAgICAgICAgIGxldCBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb247XG4gICAgICAgICAgbGV0IGEyID0gcGx1Z2luVmVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICBsZXQgYiA9IHJ1bnRpbWVWZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGlmIChhMlswXSAhPT0gYlswXSB8fCBwYXJzZUludChhMlsxXSkgPiBwYXJzZUludChiWzFdKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVbmtub3duIGVycm9yIGZyb20gUG9zdENTUyBwbHVnaW4uIFlvdXIgY3VycmVudCBQb3N0Q1NTIHZlcnNpb24gaXMgXCIgKyBydW50aW1lVmVyICsgXCIsIGJ1dCBcIiArIHBsdWdpbk5hbWUgKyBcIiB1c2VzIFwiICsgcGx1Z2luVmVyICsgXCIuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHByZXBhcmVWaXNpdG9ycygpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIGxldCBhZGQgPSAocGx1Z2luMjIsIHR5cGUsIGNiKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChbcGx1Z2luMjIsIGNiXSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBwbHVnaW4yMiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gcGx1Z2luMjIpIHtcbiAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QUyQxW2V2ZW50XSAmJiAvXltBLVpdLy50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5rbm93biBldmVudCAke2V2ZW50fSBpbiAke3BsdWdpbjIyLnBvc3Rjc3NQbHVnaW59LiBUcnkgdG8gdXBkYXRlIFBvc3RDU1MgKCR7dGhpcy5wcm9jZXNzb3IudmVyc2lvbn0gbm93KS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIU5PVF9WSVNJVE9SUyQxW2V2ZW50XSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgZmlsdGVyIGluIHBsdWdpbjIyW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50LCBwbHVnaW4yMltldmVudF1bZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkZChcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ICsgXCItXCIgKyBmaWx0ZXIudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50LCBwbHVnaW4yMltldmVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDA7XG4gIH1cbiAgYXN5bmMgcnVuQXN5bmMoKSB7XG4gICAgdGhpcy5wbHVnaW4gPSAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBsZXQgcGx1Z2luMjIgPSB0aGlzLnBsdWdpbnNbaTJdO1xuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICBpZiAoaXNQcm9taXNlJDEocHJvbWlzZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICB3aGlsZSAoIXJvb3QyW2lzQ2xlYW4kM10pIHtcbiAgICAgICAgcm9vdDJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgIGxldCBzdGFjayA9IFt0b1N0YWNrJDEocm9vdDIpXTtcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcHJvbWlzZSA9IHRoaXMudmlzaXRUaWNrKHN0YWNrKTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlJDEocHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICBsZXQgbm9kZTIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgZm9yIChsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSBvZiB0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICBsZXQgcm9vdHMgPSByb290Mi5ub2Rlcy5tYXAoXG4gICAgICAgICAgICAgICAgKHN1YlJvb3QpID0+IHZpc2l0b3Ioc3ViUm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyb290cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhd2FpdCB2aXNpdG9yKHJvb3QyLCB0aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpO1xuICB9XG4gIHJ1bk9uUm9vdChwbHVnaW4yMikge1xuICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5PbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdC5yb290LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgIGxldCByb290cyA9IHRoaXMucmVzdWx0LnJvb3Qubm9kZXMubWFwKFxuICAgICAgICAgICAgKHJvb3QyKSA9PiBwbHVnaW4yMi5PbmNlKHJvb3QyLCB0aGlzLmhlbHBlcnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlJDEocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm9vdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbjIyKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHN0cmluZ2lmeSgpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICBpZiAodGhpcy5zdHJpbmdpZmllZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSB0cnVlO1xuICAgIHRoaXMuc3luYygpO1xuICAgIGxldCBvcHRzID0gdGhpcy5yZXN1bHQub3B0cztcbiAgICBsZXQgc3RyID0gc3RyaW5naWZ5JDIkMTtcbiAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeTtcbiAgICBpZiAob3B0cy5zdHJpbmdpZmllcikgc3RyID0gb3B0cy5zdHJpbmdpZmllcjtcbiAgICBpZiAoc3RyLnN0cmluZ2lmeSkgc3RyID0gc3RyLnN0cmluZ2lmeTtcbiAgICBsZXQgbWFwID0gbmV3IE1hcEdlbmVyYXRvciQxJDEoc3RyLCB0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdC5vcHRzKTtcbiAgICBsZXQgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgIHRoaXMucmVzdWx0LmNzcyA9IGRhdGFbMF07XG4gICAgdGhpcy5yZXN1bHQubWFwID0gZGF0YVsxXTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbjIyIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICBpZiAoaXNQcm9taXNlJDEocHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICB3aGlsZSAoIXJvb3QyW2lzQ2xlYW4kM10pIHtcbiAgICAgICAgcm9vdDJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgIHRoaXMud2Fsa1N5bmMocm9vdDIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgIGlmIChyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICBmb3IgKGxldCBzdWJSb290IG9mIHJvb3QyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgc3ViUm9vdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCByb290Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9XG4gIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLm9wdHMpKSB7XG4gICAgICAgIHdhcm5PbmNlJDEkMShcbiAgICAgICAgICBcIldpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbiAgdmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMikge1xuICAgIGZvciAobGV0IFtwbHVnaW4yMiwgdmlzaXRvcl0gb2YgdmlzaXRvcnMpIHtcbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgIGxldCBwcm9taXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZTIsIHRoaXMuaGVscGVycyk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMi5wcm94eU9mKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmlzaXRUaWNrKHN0YWNrKSB7XG4gICAgbGV0IHZpc2l0MiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGxldCB7IG5vZGU6IG5vZGUyLCB2aXNpdG9ycyB9ID0gdmlzaXQyO1xuICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0Mi52aXNpdG9ySW5kZXggPCB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxldCBbcGx1Z2luMjIsIHZpc2l0b3JdID0gdmlzaXRvcnNbdmlzaXQyLnZpc2l0b3JJbmRleF07XG4gICAgICB2aXNpdDIudmlzaXRvckluZGV4ICs9IDE7XG4gICAgICBpZiAodmlzaXQyLnZpc2l0b3JJbmRleCA9PT0gdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IFtdO1xuICAgICAgICB2aXNpdDIudmlzaXRvckluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUyLnRvUHJveHkoKSwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpc2l0Mi5pdGVyYXRvciAhPT0gMCkge1xuICAgICAgbGV0IGl0ZXJhdG9yID0gdmlzaXQyLml0ZXJhdG9yO1xuICAgICAgbGV0IGNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkID0gbm9kZTIubm9kZXNbbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl1dKSB7XG4gICAgICAgIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgICAgIGlmICghY2hpbGRbaXNDbGVhbiQzXSkge1xuICAgICAgICAgIGNoaWxkW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayQxKGNoaWxkKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2aXNpdDIuaXRlcmF0b3IgPSAwO1xuICAgICAgZGVsZXRlIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgIH1cbiAgICBsZXQgZXZlbnRzID0gdmlzaXQyLmV2ZW50cztcbiAgICB3aGlsZSAodmlzaXQyLmV2ZW50SW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBsZXQgZXZlbnQgPSBldmVudHNbdmlzaXQyLmV2ZW50SW5kZXhdO1xuICAgICAgdmlzaXQyLmV2ZW50SW5kZXggKz0gMTtcbiAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4kMSkge1xuICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZTJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgdmlzaXQyLml0ZXJhdG9yID0gbm9kZTIuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cbiAgd2Fsa1N5bmMobm9kZTIpIHtcbiAgICBub2RlMltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICBsZXQgZXZlbnRzID0gZ2V0RXZlbnRzJDEobm9kZTIpO1xuICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTiQxKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgIG5vZGUyLmVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW4kM10pIHRoaXMud2Fsa1N5bmMoY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgIGlmICh0aGlzLnZpc2l0U3luYyh2aXNpdG9ycywgbm9kZTIudG9Qcm94eSgpKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNvbnRlbnQ7XG4gIH1cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3M7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXA7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlcztcbiAgfVxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgfVxuICBnZXQgcHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gIH1cbiAgZ2V0IHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLnJvb3Q7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkxhenlSZXN1bHRcIjtcbiAgfVxufTtcbkxhenlSZXN1bHQkMiQxLnJlZ2lzdGVyUG9zdGNzcyA9IChkZXBlbmRhbnQpID0+IHtcbiAgcG9zdGNzcyQyJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGxhenlSZXN1bHQkMSA9IExhenlSZXN1bHQkMiQxO1xuTGF6eVJlc3VsdCQyJDEuZGVmYXVsdCA9IExhenlSZXN1bHQkMiQxO1xuUm9vdCQzJDEucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMiQxKTtcbkRvY3VtZW50JDIkMS5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyJDEpO1xubGV0IE1hcEdlbmVyYXRvcjIkMSA9IG1hcEdlbmVyYXRvciQxO1xubGV0IHN0cmluZ2lmeSQxJDEgPSBzdHJpbmdpZnlfMSQxO1xubGV0IHdhcm5PbmNlMiQxID0gd2Fybk9uY2UkMiQxO1xubGV0IHBhcnNlJDEkMSA9IHBhcnNlXzEkMTtcbmNvbnN0IFJlc3VsdCQxJDEgPSByZXN1bHQkMTtcbmxldCBOb1dvcmtSZXN1bHQkMSQxID0gY2xhc3MgTm9Xb3JrUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgdGhpcy5fY3NzID0gY3NzO1xuICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgICBsZXQgcm9vdDI7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeSQxJDE7XG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDEkMSh0aGlzLl9wcm9jZXNzb3IsIHJvb3QyLCB0aGlzLl9vcHRzKTtcbiAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3M7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc3VsdCwgXCJyb290XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucm9vdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbWFwID0gbmV3IE1hcEdlbmVyYXRvcjIkMShzdHIsIHJvb3QyLCB0aGlzLl9vcHRzLCBjc3MpO1xuICAgIGlmIChtYXAuaXNNYXAoKSkge1xuICAgICAgbGV0IFtnZW5lcmF0ZWRDU1MsIGdlbmVyYXRlZE1hcF0gPSBtYXAuZ2VuZXJhdGUoKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRDU1MpIHtcbiAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gZ2VuZXJhdGVkQ1NTO1xuICAgICAgfVxuICAgICAgaWYgKGdlbmVyYXRlZE1hcCkge1xuICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBnZW5lcmF0ZWRNYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcC5jbGVhckFubm90YXRpb24oKTtcbiAgICAgIHRoaXMucmVzdWx0LmNzcyA9IG1hcC5jc3M7XG4gICAgfVxuICB9XG4gIGFzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdCk7XG4gIH1cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gIH1cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICB9XG4gIHN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9XG4gIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLl9vcHRzKSkge1xuICAgICAgICB3YXJuT25jZTIkMShcbiAgICAgICAgICBcIldpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3NzO1xuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICB9XG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgfVxuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5tYXA7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgfVxuICBnZXQgcHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gIH1cbiAgZ2V0IHJvb3QoKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH1cbiAgICBsZXQgcm9vdDI7XG4gICAgbGV0IHBhcnNlcjIgPSBwYXJzZSQxJDE7XG4gICAgdHJ5IHtcbiAgICAgIHJvb3QyID0gcGFyc2VyMih0aGlzLl9jc3MsIHRoaXMuX29wdHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yb290ID0gcm9vdDI7XG4gICAgICByZXR1cm4gcm9vdDI7XG4gICAgfVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJOb1dvcmtSZXN1bHRcIjtcbiAgfVxufTtcbnZhciBub1dvcmtSZXN1bHQkMSA9IE5vV29ya1Jlc3VsdCQxJDE7XG5Ob1dvcmtSZXN1bHQkMSQxLmRlZmF1bHQgPSBOb1dvcmtSZXN1bHQkMSQxO1xubGV0IE5vV29ya1Jlc3VsdDIkMSA9IG5vV29ya1Jlc3VsdCQxO1xubGV0IExhenlSZXN1bHQkMSQxID0gbGF6eVJlc3VsdCQxO1xubGV0IERvY3VtZW50JDEkMSA9IGRvY3VtZW50JDEkMTtcbmxldCBSb290JDIkMSA9IHJvb3QkMTtcbmxldCBQcm9jZXNzb3IkMSQxID0gY2xhc3MgUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3IocGx1Z2lucyA9IFtdKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gXCI4LjQuMzhcIjtcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLm5vcm1hbGl6ZShwbHVnaW5zKTtcbiAgfVxuICBub3JtYWxpemUocGx1Z2lucykge1xuICAgIGxldCBub3JtYWxpemVkID0gW107XG4gICAgZm9yIChsZXQgaTIgb2YgcGx1Z2lucykge1xuICAgICAgaWYgKGkyLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgaTIgPSBpMigpO1xuICAgICAgfSBlbHNlIGlmIChpMi5wb3N0Y3NzKSB7XG4gICAgICAgIGkyID0gaTIucG9zdGNzcztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShpMi5wbHVnaW5zKSkge1xuICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaTIucGx1Z2lucyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBpMi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChpMik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChpMik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiAoaTIucGFyc2UgfHwgaTIuc3RyaW5naWZ5KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJQb3N0Q1NTIHN5bnRheGVzIGNhbm5vdCBiZSB1c2VkIGFzIHBsdWdpbnMuIEluc3RlYWQsIHBsZWFzZSB1c2Ugb25lIG9mIHRoZSBzeW50YXgvcGFyc2VyL3N0cmluZ2lmaWVyIG9wdGlvbnMgYXMgb3V0bGluZWQgaW4geW91ciBQb3N0Q1NTIHJ1bm5lciBkb2N1bWVudGF0aW9uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkyICsgXCIgaXMgbm90IGEgUG9zdENTUyBwbHVnaW5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG4gIHByb2Nlc3MoY3NzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMucGx1Z2lucy5sZW5ndGggJiYgIW9wdHMucGFyc2VyICYmICFvcHRzLnN0cmluZ2lmaWVyICYmICFvcHRzLnN5bnRheCkge1xuICAgICAgcmV0dXJuIG5ldyBOb1dvcmtSZXN1bHQyJDEodGhpcywgY3NzLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgIH1cbiAgfVxuICB1c2UocGx1Z2luMjIpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuY29uY2F0KHRoaXMubm9ybWFsaXplKFtwbHVnaW4yMl0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBwcm9jZXNzb3IkMSA9IFByb2Nlc3NvciQxJDE7XG5Qcm9jZXNzb3IkMSQxLmRlZmF1bHQgPSBQcm9jZXNzb3IkMSQxO1xuUm9vdCQyJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG5Eb2N1bWVudCQxJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG5sZXQgRGVjbGFyYXRpb24kMSQxID0gZGVjbGFyYXRpb24kMTtcbmxldCBQcmV2aW91c01hcDIkMSA9IHByZXZpb3VzTWFwJDE7XG5sZXQgQ29tbWVudCQxJDEgPSBjb21tZW50JDE7XG5sZXQgQXRSdWxlJDEkMSA9IGF0UnVsZSQxO1xubGV0IElucHV0JDEkMSA9IGlucHV0JDE7XG5sZXQgUm9vdCQxJDEgPSByb290JDE7XG5sZXQgUnVsZSQxJDEgPSBydWxlJDE7XG5mdW5jdGlvbiBmcm9tSlNPTiQxJDEoanNvbiwgaW5wdXRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSByZXR1cm4ganNvbi5tYXAoKG4yKSA9PiBmcm9tSlNPTiQxJDEobjIpKTtcbiAgbGV0IHsgaW5wdXRzOiBvd25JbnB1dHMsIC4uLmRlZmF1bHRzIH0gPSBqc29uO1xuICBpZiAob3duSW5wdXRzKSB7XG4gICAgaW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQyIG9mIG93bklucHV0cykge1xuICAgICAgbGV0IGlucHV0SHlkcmF0ZWQgPSB7IC4uLmlucHV0MiwgX19wcm90b19fOiBJbnB1dCQxJDEucHJvdG90eXBlIH07XG4gICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgaW5wdXRIeWRyYXRlZC5tYXAgPSB7XG4gICAgICAgICAgLi4uaW5wdXRIeWRyYXRlZC5tYXAsXG4gICAgICAgICAgX19wcm90b19fOiBQcmV2aW91c01hcDIkMS5wcm90b3R5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKGlucHV0SHlkcmF0ZWQpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICBkZWZhdWx0cy5ub2RlcyA9IGpzb24ubm9kZXMubWFwKChuMikgPT4gZnJvbUpTT04kMSQxKG4yLCBpbnB1dHMpKTtcbiAgfVxuICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgbGV0IHsgaW5wdXRJZCwgLi4uc291cmNlIH0gPSBkZWZhdWx0cy5zb3VyY2U7XG4gICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgcmV0dXJuIG5ldyBSb290JDEkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uJDEkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUkMSQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIHJldHVybiBuZXcgQ29tbWVudCQxJDEoZGVmYXVsdHMpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICByZXR1cm4gbmV3IEF0UnVsZSQxJDEoZGVmYXVsdHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gIH1cbn1cbnZhciBmcm9tSlNPTl8xJDEgPSBmcm9tSlNPTiQxJDE7XG5mcm9tSlNPTiQxJDEuZGVmYXVsdCA9IGZyb21KU09OJDEkMTtcbmxldCBDc3NTeW50YXhFcnJvcjIkMSA9IGNzc1N5bnRheEVycm9yJDE7XG5sZXQgRGVjbGFyYXRpb24yJDEgPSBkZWNsYXJhdGlvbiQxO1xubGV0IExhenlSZXN1bHQyJDEgPSBsYXp5UmVzdWx0JDE7XG5sZXQgQ29udGFpbmVyMiQxID0gY29udGFpbmVyJDE7XG5sZXQgUHJvY2Vzc29yMiQxID0gcHJvY2Vzc29yJDE7XG5sZXQgc3RyaW5naWZ5JDUgPSBzdHJpbmdpZnlfMSQxO1xubGV0IGZyb21KU09OJDIgPSBmcm9tSlNPTl8xJDE7XG5sZXQgRG9jdW1lbnQyMiA9IGRvY3VtZW50JDEkMTtcbmxldCBXYXJuaW5nMiQxID0gd2FybmluZyQxO1xubGV0IENvbW1lbnQyJDEgPSBjb21tZW50JDE7XG5sZXQgQXRSdWxlMiQxID0gYXRSdWxlJDE7XG5sZXQgUmVzdWx0MiQxID0gcmVzdWx0JDE7XG5sZXQgSW5wdXQyJDEgPSBpbnB1dCQxO1xubGV0IHBhcnNlJDUgPSBwYXJzZV8xJDE7XG5sZXQgbGlzdCQzID0gbGlzdF8xJDE7XG5sZXQgUnVsZTIkMSA9IHJ1bGUkMTtcbmxldCBSb290MiQxID0gcm9vdCQxO1xubGV0IE5vZGUyJDEgPSBub2RlJDE7XG5mdW5jdGlvbiBwb3N0Y3NzJDMoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICB9XG4gIHJldHVybiBuZXcgUHJvY2Vzc29yMiQxKHBsdWdpbnMpO1xufVxucG9zdGNzcyQzLnBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihuYW1lLCBpbml0aWFsaXplcikge1xuICBsZXQgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmICF3YXJuaW5nUHJpbnRlZCkge1xuICAgICAgd2FybmluZ1ByaW50ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIlxuICAgICAgKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5MQU5HICYmIHByb2Nlc3MuZW52LkxBTkcuc3RhcnRzV2l0aChcImNuXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncyk7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1ZlcnNpb24gPSBuZXcgUHJvY2Vzc29yMiQxKCkudmVyc2lvbjtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gIH1cbiAgbGV0IGNhY2hlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgXCJwb3N0Y3NzXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoIWNhY2hlKSBjYWNoZSA9IGNyZWF0b3IoKTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0pO1xuICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbihjc3MsIHByb2Nlc3NPcHRzLCBwbHVnaW5PcHRzKSB7XG4gICAgcmV0dXJuIHBvc3Rjc3MkMyhbY3JlYXRvcihwbHVnaW5PcHRzKV0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gIH07XG4gIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3MkMy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkkNTtcbnBvc3Rjc3MkMy5wYXJzZSA9IHBhcnNlJDU7XG5wb3N0Y3NzJDMuZnJvbUpTT04gPSBmcm9tSlNPTiQyO1xucG9zdGNzcyQzLmxpc3QgPSBsaXN0JDM7XG5wb3N0Y3NzJDMuY29tbWVudCA9IChkZWZhdWx0cykgPT4gbmV3IENvbW1lbnQyJDEoZGVmYXVsdHMpO1xucG9zdGNzcyQzLmF0UnVsZSA9IChkZWZhdWx0cykgPT4gbmV3IEF0UnVsZTIkMShkZWZhdWx0cyk7XG5wb3N0Y3NzJDMuZGVjbCA9IChkZWZhdWx0cykgPT4gbmV3IERlY2xhcmF0aW9uMiQxKGRlZmF1bHRzKTtcbnBvc3Rjc3MkMy5ydWxlID0gKGRlZmF1bHRzKSA9PiBuZXcgUnVsZTIkMShkZWZhdWx0cyk7XG5wb3N0Y3NzJDMucm9vdCA9IChkZWZhdWx0cykgPT4gbmV3IFJvb3QyJDEoZGVmYXVsdHMpO1xucG9zdGNzcyQzLmRvY3VtZW50ID0gKGRlZmF1bHRzKSA9PiBuZXcgRG9jdW1lbnQyMihkZWZhdWx0cyk7XG5wb3N0Y3NzJDMuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIkMTtcbnBvc3Rjc3MkMy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMiQxO1xucG9zdGNzcyQzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIkMTtcbnBvc3Rjc3MkMy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyJDE7XG5wb3N0Y3NzJDMuRG9jdW1lbnQgPSBEb2N1bWVudDIyO1xucG9zdGNzcyQzLkNvbW1lbnQgPSBDb21tZW50MiQxO1xucG9zdGNzcyQzLldhcm5pbmcgPSBXYXJuaW5nMiQxO1xucG9zdGNzcyQzLkF0UnVsZSA9IEF0UnVsZTIkMTtcbnBvc3Rjc3MkMy5SZXN1bHQgPSBSZXN1bHQyJDE7XG5wb3N0Y3NzJDMuSW5wdXQgPSBJbnB1dDIkMTtcbnBvc3Rjc3MkMy5SdWxlID0gUnVsZTIkMTtcbnBvc3Rjc3MkMy5Sb290ID0gUm9vdDIkMTtcbnBvc3Rjc3MkMy5Ob2RlID0gTm9kZTIkMTtcbkxhenlSZXN1bHQyJDEucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MkMyk7XG52YXIgcG9zdGNzc18xJDEgPSBwb3N0Y3NzJDM7XG5wb3N0Y3NzJDMuZGVmYXVsdCA9IHBvc3Rjc3MkMztcbmNvbnN0IHBvc3Rjc3MkMSQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEocG9zdGNzc18xJDEpO1xucG9zdGNzcyQxJDEuc3RyaW5naWZ5O1xucG9zdGNzcyQxJDEuZnJvbUpTT047XG5wb3N0Y3NzJDEkMS5wbHVnaW47XG5wb3N0Y3NzJDEkMS5wYXJzZTtcbnBvc3Rjc3MkMSQxLmxpc3Q7XG5wb3N0Y3NzJDEkMS5kb2N1bWVudDtcbnBvc3Rjc3MkMSQxLmNvbW1lbnQ7XG5wb3N0Y3NzJDEkMS5hdFJ1bGU7XG5wb3N0Y3NzJDEkMS5ydWxlO1xucG9zdGNzcyQxJDEuZGVjbDtcbnBvc3Rjc3MkMSQxLnJvb3Q7XG5wb3N0Y3NzJDEkMS5Dc3NTeW50YXhFcnJvcjtcbnBvc3Rjc3MkMSQxLkRlY2xhcmF0aW9uO1xucG9zdGNzcyQxJDEuQ29udGFpbmVyO1xucG9zdGNzcyQxJDEuUHJvY2Vzc29yO1xucG9zdGNzcyQxJDEuRG9jdW1lbnQ7XG5wb3N0Y3NzJDEkMS5Db21tZW50O1xucG9zdGNzcyQxJDEuV2FybmluZztcbnBvc3Rjc3MkMSQxLkF0UnVsZTtcbnBvc3Rjc3MkMSQxLlJlc3VsdDtcbnBvc3Rjc3MkMSQxLklucHV0O1xucG9zdGNzcyQxJDEuUnVsZTtcbnBvc3Rjc3MkMSQxLlJvb3Q7XG5wb3N0Y3NzJDEkMS5Ob2RlO1xudmFyIF9fZGVmUHJvcDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcDIob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeDIpIHtcbiAgcmV0dXJuIHgyICYmIHgyLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcImRlZmF1bHRcIikgPyB4MltcImRlZmF1bHRcIl0gOiB4Mjtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuMikge1xuICBpZiAobjIuX19lc01vZHVsZSkgcmV0dXJuIG4yO1xuICB2YXIgZjIgPSBuMi5kZWZhdWx0O1xuICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBhMiA9IGZ1bmN0aW9uIGEyMigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYTIyKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgYTIucHJvdG90eXBlID0gZjIucHJvdG90eXBlO1xuICB9IGVsc2UgYTIgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmtleXMobjIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuMiwgayk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGEyO1xufVxudmFyIHBpY29jb2xvcnNfYnJvd3NlciA9IHsgZXhwb3J0czoge30gfTtcbnZhciB4ID0gU3RyaW5nO1xudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyBpc0NvbG9yU3VwcG9ydGVkOiBmYWxzZSwgcmVzZXQ6IHgsIGJvbGQ6IHgsIGRpbTogeCwgaXRhbGljOiB4LCB1bmRlcmxpbmU6IHgsIGludmVyc2U6IHgsIGhpZGRlbjogeCwgc3RyaWtldGhyb3VnaDogeCwgYmxhY2s6IHgsIHJlZDogeCwgZ3JlZW46IHgsIHllbGxvdzogeCwgYmx1ZTogeCwgbWFnZW50YTogeCwgY3lhbjogeCwgd2hpdGU6IHgsIGdyYXk6IHgsIGJnQmxhY2s6IHgsIGJnUmVkOiB4LCBiZ0dyZWVuOiB4LCBiZ1llbGxvdzogeCwgYmdCbHVlOiB4LCBiZ01hZ2VudGE6IHgsIGJnQ3lhbjogeCwgYmdXaGl0ZTogeCB9O1xufTtcbnBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzID0gY3JlYXRlKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGU7XG52YXIgcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyA9IHBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzO1xuY29uc3QgX192aXRlQnJvd3NlckV4dGVybmFsID0ge307XG5jb25zdCBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmNvbnN0IHJlcXVpcmUkJDIgPSAvKiBAX19QVVJFX18gKi8gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxKTtcbmxldCBwaWNvID0gcGljb2NvbG9yc19icm93c2VyRXhwb3J0cztcbmxldCB0ZXJtaW5hbEhpZ2hsaWdodCQxID0gcmVxdWlyZSQkMjtcbmxldCBDc3NTeW50YXhFcnJvciQzID0gY2xhc3MgQ3NzU3ludGF4RXJyb3IyIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIHNvdXJjZSwgZmlsZSwgcGx1Z2luMjIpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNzc1N5bnRheEVycm9yXCI7XG4gICAgdGhpcy5yZWFzb24gPSBtZXNzYWdlO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIH1cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbjIyKSB7XG4gICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbHVtbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZS5saW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGxpbmUuY29sdW1uO1xuICAgICAgICB0aGlzLmVuZExpbmUgPSBjb2x1bW4ubGluZTtcbiAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBjb2x1bW4uY29sdW1uO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldE1lc3NhZ2UoKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENzc1N5bnRheEVycm9yMik7XG4gICAgfVxuICB9XG4gIHNldE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wbHVnaW4gPyB0aGlzLnBsdWdpbiArIFwiOiBcIiA6IFwiXCI7XG4gICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6IFwiPGNzcyBpbnB1dD5cIjtcbiAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOlwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbjtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlICs9IFwiOiBcIiArIHRoaXMucmVhc29uO1xuICB9XG4gIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuIFwiXCI7XG4gICAgbGV0IGNzcyA9IHRoaXMuc291cmNlO1xuICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHBpY28uaXNDb2xvclN1cHBvcnRlZDtcbiAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSkge1xuICAgICAgaWYgKGNvbG9yKSBjc3MgPSB0ZXJtaW5hbEhpZ2hsaWdodCQxKGNzcyk7XG4gICAgfVxuICAgIGxldCBsaW5lcyA9IGNzcy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApO1xuICAgIGxldCBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgIGxldCBtYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgICBsZXQgbWFyaywgYXNpZGU7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBsZXQgeyBib2xkLCBncmF5LCByZWQgfSA9IHBpY28uY3JlYXRlQ29sb3JzKHRydWUpO1xuICAgICAgbWFyayA9ICh0ZXh0KSA9PiBib2xkKHJlZCh0ZXh0KSk7XG4gICAgICBhc2lkZSA9ICh0ZXh0KSA9PiBncmF5KHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrID0gYXNpZGUgPSAoc3RyKSA9PiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoKGxpbmUsIGluZGV4MikgPT4ge1xuICAgICAgbGV0IG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4MjtcbiAgICAgIGxldCBndXR0ZXIgPSBcIiBcIiArIChcIiBcIiArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArIFwiIHwgXCI7XG4gICAgICBpZiAobnVtYmVyID09PSB0aGlzLmxpbmUpIHtcbiAgICAgICAgbGV0IHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSkgKyBsaW5lLnNsaWNlKDAsIHRoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIG1hcmsoXCI+XCIpICsgYXNpZGUoZ3V0dGVyKSArIGxpbmUgKyBcIlxcbiBcIiArIHNwYWNpbmcgKyBtYXJrKFwiXlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIiBcIiArIGFzaWRlKGd1dHRlcikgKyBsaW5lO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNvZGUgPSBcIlxcblxcblwiICsgY29kZSArIFwiXFxuXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICB9XG59O1xudmFyIGNzc1N5bnRheEVycm9yID0gQ3NzU3ludGF4RXJyb3IkMztcbkNzc1N5bnRheEVycm9yJDMuZGVmYXVsdCA9IENzc1N5bnRheEVycm9yJDM7XG52YXIgc3ltYm9scyA9IHt9O1xuc3ltYm9scy5pc0NsZWFuID0gU3ltYm9sKFwiaXNDbGVhblwiKTtcbnN5bWJvbHMubXkgPSBTeW1ib2woXCJteVwiKTtcbmNvbnN0IERFRkFVTFRfUkFXID0ge1xuICBhZnRlcjogXCJcXG5cIixcbiAgYmVmb3JlQ2xvc2U6IFwiXFxuXCIsXG4gIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gIGJlZm9yZURlY2w6IFwiXFxuXCIsXG4gIGJlZm9yZU9wZW46IFwiIFwiLFxuICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICBjb2xvbjogXCI6IFwiLFxuICBjb21tZW50TGVmdDogXCIgXCIsXG4gIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gIGVtcHR5Qm9keTogXCJcIixcbiAgaW5kZW50OiBcIiAgICBcIixcbiAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmxldCBTdHJpbmdpZmllciQyID0gY2xhc3MgU3RyaW5naWZpZXIyIHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gIH1cbiAgYXRydWxlKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICBsZXQgbmFtZSA9IFwiQFwiICsgbm9kZTIubmFtZTtcbiAgICBsZXQgcGFyYW1zID0gbm9kZTIucGFyYW1zID8gdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJwYXJhbXNcIikgOiBcIlwiO1xuICAgIGlmICh0eXBlb2Ygbm9kZTIucmF3cy5hZnRlck5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG5hbWUgKz0gbm9kZTIucmF3cy5hZnRlck5hbWU7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgIG5hbWUgKz0gXCIgXCI7XG4gICAgfVxuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgdGhpcy5ibG9jayhub2RlMiwgbmFtZSArIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSAobm9kZTIucmF3cy5iZXR3ZWVuIHx8IFwiXCIpICsgKHNlbWljb2xvbiA/IFwiO1wiIDogXCJcIik7XG4gICAgICB0aGlzLmJ1aWxkZXIobmFtZSArIHBhcmFtcyArIGVuZCwgbm9kZTIpO1xuICAgIH1cbiAgfVxuICBiZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ29tbWVudFwiKTtcbiAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNsb3NlXCIpO1xuICAgIH1cbiAgICBsZXQgYnVmID0gbm9kZTIucGFyZW50O1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgd2hpbGUgKGJ1ZiAmJiBidWYudHlwZSAhPT0gXCJyb290XCIpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgICBidWYgPSBidWYucGFyZW50O1xuICAgIH1cbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIGxldCBpbmRlbnQgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJpbmRlbnRcIik7XG4gICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IGRlcHRoOyBzdGVwKyspIHZhbHVlICs9IGluZGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGJsb2NrKG5vZGUyLCBzdGFydCkge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArIFwie1wiLCBub2RlMiwgXCJzdGFydFwiKTtcbiAgICBsZXQgYWZ0ZXI7XG4gICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIiwgXCJlbXB0eUJvZHlcIik7XG4gICAgfVxuICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKTtcbiAgICB0aGlzLmJ1aWxkZXIoXCJ9XCIsIG5vZGUyLCBcImVuZFwiKTtcbiAgfVxuICBib2R5KG5vZGUyKSB7XG4gICAgbGV0IGxhc3QgPSBub2RlMi5ub2Rlcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsYXN0ID4gMCkge1xuICAgICAgaWYgKG5vZGUyLm5vZGVzW2xhc3RdLnR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIGxhc3QgLT0gMTtcbiAgICB9XG4gICAgbGV0IHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUyLCBcInNlbWljb2xvblwiKTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZTIubm9kZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlMi5ub2Rlc1tpMl07XG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsIFwiYmVmb3JlXCIpO1xuICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSk7XG4gICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaTIgfHwgc2VtaWNvbG9uKTtcbiAgICB9XG4gIH1cbiAgY29tbWVudChub2RlMikge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yYXcobm9kZTIsIFwibGVmdFwiLCBcImNvbW1lbnRMZWZ0XCIpO1xuICAgIGxldCByaWdodCA9IHRoaXMucmF3KG5vZGUyLCBcInJpZ2h0XCIsIFwiY29tbWVudFJpZ2h0XCIpO1xuICAgIHRoaXMuYnVpbGRlcihcIi8qXCIgKyBsZWZ0ICsgbm9kZTIudGV4dCArIHJpZ2h0ICsgXCIqL1wiLCBub2RlMik7XG4gIH1cbiAgZGVjbChub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiY29sb25cIik7XG4gICAgbGV0IHN0cmluZyA9IG5vZGUyLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAobm9kZTIuaW1wb3J0YW50KSB7XG4gICAgICBzdHJpbmcgKz0gbm9kZTIucmF3cy5pbXBvcnRhbnQgfHwgXCIgIWltcG9ydGFudFwiO1xuICAgIH1cbiAgICBpZiAoc2VtaWNvbG9uKSBzdHJpbmcgKz0gXCI7XCI7XG4gICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZTIpO1xuICB9XG4gIGRvY3VtZW50KG5vZGUyKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgfVxuICByYXcobm9kZTIsIG93biwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICghZGV0ZWN0KSBkZXRlY3QgPSBvd247XG4gICAgaWYgKG93bikge1xuICAgICAgdmFsdWUgPSBub2RlMi5yYXdzW293bl07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBub2RlMi5wYXJlbnQ7XG4gICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICBsZXQgcm9vdDIgPSBub2RlMi5yb290KCk7XG4gICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICBpZiAodHlwZW9mIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiByb290Mi5yYXdDYWNoZVtkZXRlY3RdO1xuICAgIH1cbiAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1ldGhvZCA9IFwicmF3XCIgKyBjYXBpdGFsaXplKGRldGVjdCk7XG4gICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QyLCBub2RlMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3c1tvd25dO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICByb290Mi5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZUNsb3NlKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZUNvbW1lbnQocm9vdDIsIG5vZGUyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtDb21tZW50cygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVEZWNsKHJvb3QyLCBub2RlMikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrRGVjbHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlT3Blbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLnR5cGUgIT09IFwiZGVjbFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZVJ1bGUocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiAoaTIucGFyZW50ICE9PSByb290MiB8fCByb290Mi5maXJzdCAhPT0gaTIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdDb2xvbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrRGVjbHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmV0d2VlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0VtcHR5Qm9keShyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3SW5kZW50KHJvb3QyKSB7XG4gICAgaWYgKHJvb3QyLnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdDIucmF3cy5pbmRlbnQ7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBsZXQgcCA9IGkyLnBhcmVudDtcbiAgICAgIGlmIChwICYmIHAgIT09IHJvb3QyICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290Mikge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gaTIucmF3cy5iZWZvcmUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgdmFsdWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3U2VtaWNvbG9uKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoICYmIGkyLmxhc3QudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLnNlbWljb2xvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdWYWx1ZShub2RlMiwgcHJvcCkge1xuICAgIGxldCB2YWx1ZSA9IG5vZGUyW3Byb3BdO1xuICAgIGxldCByYXcgPSBub2RlMi5yYXdzW3Byb3BdO1xuICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJhdy5yYXc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByb290KG5vZGUyKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICBpZiAobm9kZTIucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3MuYWZ0ZXIpO1xuICB9XG4gIHJ1bGUobm9kZTIpIHtcbiAgICB0aGlzLmJsb2NrKG5vZGUyLCB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInNlbGVjdG9yXCIpKTtcbiAgICBpZiAobm9kZTIucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLm93blNlbWljb2xvbiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdpZnkobm9kZTIsIHNlbWljb2xvbikge1xuICAgIGlmICghdGhpc1tub2RlMi50eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlVua25vd24gQVNUIG5vZGUgdHlwZSBcIiArIG5vZGUyLnR5cGUgKyBcIi4gTWF5YmUgeW91IG5lZWQgdG8gY2hhbmdlIFBvc3RDU1Mgc3RyaW5naWZpZXIuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXNbbm9kZTIudHlwZV0obm9kZTIsIHNlbWljb2xvbik7XG4gIH1cbn07XG52YXIgc3RyaW5naWZpZXIgPSBTdHJpbmdpZmllciQyO1xuU3RyaW5naWZpZXIkMi5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMjtcbmxldCBTdHJpbmdpZmllciQxID0gc3RyaW5naWZpZXI7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNChub2RlMiwgYnVpbGRlcikge1xuICBsZXQgc3RyID0gbmV3IFN0cmluZ2lmaWVyJDEoYnVpbGRlcik7XG4gIHN0ci5zdHJpbmdpZnkobm9kZTIpO1xufVxudmFyIHN0cmluZ2lmeV8xID0gc3RyaW5naWZ5JDQ7XG5zdHJpbmdpZnkkNC5kZWZhdWx0ID0gc3RyaW5naWZ5JDQ7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDIsIG15OiBteSQyIH0gPSBzeW1ib2xzO1xubGV0IENzc1N5bnRheEVycm9yJDIgPSBjc3NTeW50YXhFcnJvcjtcbmxldCBTdHJpbmdpZmllcjIyID0gc3RyaW5naWZpZXI7XG5sZXQgc3RyaW5naWZ5JDMgPSBzdHJpbmdpZnlfMTtcbmZ1bmN0aW9uIGNsb25lTm9kZShvYmosIHBhcmVudCkge1xuICBsZXQgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuICBmb3IgKGxldCBpMiBpbiBvYmopIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpMiA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgIGxldCB2YWx1ZSA9IG9ialtpMl07XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKGkyID09PSBcInBhcmVudFwiICYmIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChwYXJlbnQpIGNsb25lZFtpMl0gPSBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZS5tYXAoKGopID0+IGNsb25lTm9kZShqLCBjbG9uZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlKHZhbHVlKTtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmxldCBOb2RlJDQgPSBjbGFzcyBOb2RlMyB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzID0ge30pIHtcbiAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICB0aGlzW2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICB0aGlzW215JDJdID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbm9kZTIgb2YgZGVmYXVsdHNbbmFtZV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUyLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyLmNsb25lKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFkZFRvRXJyb3IoZXJyb3IpIHtcbiAgICBlcnJvci5wb3N0Y3NzTm9kZSA9IHRoaXM7XG4gICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICBsZXQgczIgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZShcbiAgICAgICAgL1xcblxcc3s0fWF0IC8sXG4gICAgICAgIGAkJiR7czIuaW5wdXQuZnJvbX06JHtzMi5zdGFydC5saW5lfToke3MyLnN0YXJ0LmNvbHVtbn0kJmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBhZnRlcihhZGQpIHtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBhZGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzc2lnbihvdmVycmlkZXMgPSB7fSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWZvcmUoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5iZWZvcmU7XG4gICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlcjtcbiAgICBpZiAoIWtlZXBCZXR3ZWVuKSBkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47XG4gIH1cbiAgY2xvbmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gY2xvbmVOb2RlKHRoaXMpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgY2xvbmVBZnRlcihvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lQmVmb3JlKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGVycm9yKG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbGV0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5yYW5nZUJ5KG9wdHMpO1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB7IGNvbHVtbjogc3RhcnQuY29sdW1uLCBsaW5lOiBzdGFydC5saW5lIH0sXG4gICAgICAgIHsgY29sdW1uOiBlbmQuY29sdW1uLCBsaW5lOiBlbmQubGluZSB9LFxuICAgICAgICBvcHRzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENzc1N5bnRheEVycm9yJDIobWVzc2FnZSk7XG4gIH1cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgbWFya0RpcnR5KCkge1xuICAgIGlmICh0aGlzW2lzQ2xlYW4kMl0pIHtcbiAgICAgIHRoaXNbaXNDbGVhbiQyXSA9IGZhbHNlO1xuICAgICAgbGV0IG5leHQgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5leHQgPSBuZXh0LnBhcmVudCkge1xuICAgICAgICBuZXh0W2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gIH1cbiAgcG9zaXRpb25CeShvcHRzLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgIGxldCBwb3MgPSB0aGlzLnNvdXJjZS5zdGFydDtcbiAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHRzLndvcmQpIHtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgbGV0IGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKSBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIHBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgIGxldCBjb2x1bW4gPSB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW47XG4gICAgbGV0IGxpbmUgPSB0aGlzLnNvdXJjZS5zdGFydC5saW5lO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBpbmRleDI7IGkyKyspIHtcbiAgICAgIGlmIChzdHJpbmdbaTJdID09PSBcIlxcblwiKSB7XG4gICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgIGxpbmUgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUgfTtcbiAgfVxuICBwcmV2KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgLSAxXTtcbiAgfVxuICByYW5nZUJ5KG9wdHMpIHtcbiAgICBsZXQgc3RhcnQgPSB7XG4gICAgICBjb2x1bW46IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbixcbiAgICAgIGxpbmU6IHRoaXMuc291cmNlLnN0YXJ0LmxpbmVcbiAgICB9O1xuICAgIGxldCBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICB9IDoge1xuICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgbGluZTogc3RhcnQubGluZVxuICAgIH07XG4gICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgbGV0IGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIgKyBvcHRzLndvcmQubGVuZ3RoLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRzLnN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIGNvbHVtbjogb3B0cy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuZW5kKSB7XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICBjb2x1bW46IG9wdHMuZW5kLmNvbHVtbixcbiAgICAgICAgICBsaW5lOiBvcHRzLmVuZC5saW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmVuZEluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQubGluZSA8IHN0YXJ0LmxpbmUgfHwgZW5kLmxpbmUgPT09IHN0YXJ0LmxpbmUgJiYgZW5kLmNvbHVtbiA8PSBzdGFydC5jb2x1bW4pIHtcbiAgICAgIGVuZCA9IHsgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLCBsaW5lOiBzdGFydC5saW5lIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuZCwgc3RhcnQgfTtcbiAgfVxuICByYXcocHJvcCwgZGVmYXVsdFR5cGUpIHtcbiAgICBsZXQgc3RyID0gbmV3IFN0cmluZ2lmaWVyMjIoKTtcbiAgICByZXR1cm4gc3RyLnJhdyh0aGlzLCBwcm9wLCBkZWZhdWx0VHlwZSk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlcGxhY2VXaXRoKC4uLm5vZGVzKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBsZXQgYm9va21hcmsgPSB0aGlzO1xuICAgICAgbGV0IGZvdW5kU2VsZiA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUyID09PSB0aGlzKSB7XG4gICAgICAgICAgZm91bmRTZWxmID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZTIpO1xuICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRTZWxmKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvb3QoKSB7XG4gICAgbGV0IHJlc3VsdDIgPSB0aGlzO1xuICAgIHdoaWxlIChyZXN1bHQyLnBhcmVudCAmJiByZXN1bHQyLnBhcmVudC50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdG9KU09OKF8sIGlucHV0cykge1xuICAgIGxldCBmaXhlZCA9IHt9O1xuICAgIGxldCBlbWl0SW5wdXRzID0gaW5wdXRzID09IG51bGw7XG4gICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGlucHV0c05leHRJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcInBhcmVudFwiIHx8IG5hbWUgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS5tYXAoKGkyKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBpMi50b0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiBpMi50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS50b0pTT04pIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICBsZXQgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICBpZiAoaW5wdXRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpO1xuICAgICAgICAgIGlucHV0c05leHRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgIGVuZDogdmFsdWUuZW5kLFxuICAgICAgICAgIGlucHV0SWQsXG4gICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgZml4ZWQuaW5wdXRzID0gWy4uLmlucHV0cy5rZXlzKCldLm1hcCgoaW5wdXQyKSA9PiBpbnB1dDIudG9KU09OKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZml4ZWQ7XG4gIH1cbiAgdG9Qcm94eSgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3h5Q2FjaGU7XG4gIH1cbiAgdG9TdHJpbmcoc3RyaW5naWZpZXIyID0gc3RyaW5naWZ5JDMpIHtcbiAgICBpZiAoc3RyaW5naWZpZXIyLnN0cmluZ2lmeSkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZpZXIyLnN0cmluZ2lmeTtcbiAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgc3RyaW5naWZpZXIyKHRoaXMsIChpMikgPT4ge1xuICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm9kZTogdGhpcyB9O1xuICAgIGZvciAobGV0IGkyIGluIG9wdHMpIGRhdGFbaTJdID0gb3B0c1tpMl07XG4gICAgcmV0dXJuIHJlc3VsdDIud2Fybih0ZXh0LCBkYXRhKTtcbiAgfVxuICBnZXQgcHJveHlPZigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub2RlID0gTm9kZSQ0O1xuTm9kZSQ0LmRlZmF1bHQgPSBOb2RlJDQ7XG5sZXQgTm9kZSQzID0gbm9kZTtcbmxldCBEZWNsYXJhdGlvbiQ0ID0gY2xhc3MgRGVjbGFyYXRpb24yIGV4dGVuZHMgTm9kZSQzIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBpZiAoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKSB9O1xuICAgIH1cbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJkZWNsXCI7XG4gIH1cbiAgZ2V0IHZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aChcIi0tXCIpIHx8IHRoaXMucHJvcFswXSA9PT0gXCIkXCI7XG4gIH1cbn07XG52YXIgZGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbiQ0O1xuRGVjbGFyYXRpb24kNC5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNDtcbmxldCB1cmxBbHBoYWJldCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICBsZXQgaTIgPSBzaXplO1xuICAgIHdoaWxlIChpMi0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoIHwgMF07XG4gICAgfVxuICAgIHJldHVybiBpZDtcbiAgfTtcbn07XG5sZXQgbmFub2lkJDEgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9IFwiXCI7XG4gIGxldCBpMiA9IHNpemU7XG4gIHdoaWxlIChpMi0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcbnZhciBub25TZWN1cmUgPSB7IG5hbm9pZDogbmFub2lkJDEsIGN1c3RvbUFscGhhYmV0IH07XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lcjogU291cmNlTWFwQ29uc3VtZXIkMiwgU291cmNlTWFwR2VuZXJhdG9yOiBTb3VyY2VNYXBHZW5lcmF0b3IkMiB9ID0gcmVxdWlyZSQkMjtcbmxldCB7IGV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyB9ID0gcmVxdWlyZSQkMjtcbmxldCB7IGRpcm5hbWU6IGRpcm5hbWUkMSwgam9pbiB9ID0gcmVxdWlyZSQkMjtcbmZ1bmN0aW9uIGZyb21CYXNlNjQoc3RyKSB7XG4gIGlmIChCdWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpO1xuICB9XG59XG5sZXQgUHJldmlvdXNNYXAkMiA9IGNsYXNzIFByZXZpb3VzTWFwMiB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cykge1xuICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICB0aGlzLmxvYWRBbm5vdGF0aW9uKGNzcyk7XG4gICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgbGV0IHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB2b2lkIDA7XG4gICAgbGV0IHRleHQgPSB0aGlzLmxvYWRNYXAob3B0cy5mcm9tLCBwcmV2KTtcbiAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwRmlsZSkgdGhpcy5yb290ID0gZGlybmFtZSQxKHRoaXMubWFwRmlsZSk7XG4gICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgY29uc3VtZXIoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQyKHRoaXMudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnN1bWVyQ2FjaGU7XG4gIH1cbiAgZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICBsZXQgYmFzZUNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvO1xuICAgIGxldCBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICBsZXQgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsLztcbiAgICBsZXQgdXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbiwvO1xuICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICB9XG4gICAgaWYgKGJhc2VDaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgYmFzZVVyaS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm4gZnJvbUJhc2U2NCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgIH1cbiAgICBsZXQgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvblVSTChzb3VyY2VNYXBTdHJpbmcpIHtcbiAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nLnJlcGxhY2UoL15cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS8sIFwiXCIpLnRyaW0oKTtcbiAgfVxuICBpc01hcChtYXApIHtcbiAgICBpZiAodHlwZW9mIG1hcCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0eXBlb2YgbWFwLm1hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYXAuX21hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkobWFwLnNlY3Rpb25zKTtcbiAgfVxuICBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICBsZXQgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2dtKTtcbiAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgbGV0IHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKTtcbiAgICBsZXQgZW5kID0gY3NzLmluZGV4T2YoXCIqL1wiLCBzdGFydCk7XG4gICAgaWYgKHN0YXJ0ID4gLTEgJiYgZW5kID4gLTEpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICB9XG4gIH1cbiAgbG9hZEZpbGUocGF0aCkge1xuICAgIHRoaXMucm9vdCA9IGRpcm5hbWUkMShwYXRoKTtcbiAgICBpZiAoZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgIHJldHVybiByZWFkRmlsZVN5bmMocGF0aCwgXCJ1dGYtOFwiKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsZXQgcHJldlBhdGggPSBwcmV2KGZpbGUpO1xuICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICBsZXQgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aCk7XG4gICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiBcIiArIHByZXZQYXRoLnRvU3RyaW5nKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcENvbnN1bWVyJDIpIHtcbiAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcEdlbmVyYXRvciQyKSB7XG4gICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgcHJldmlvdXMgc291cmNlIG1hcCBmb3JtYXQ6IFwiICsgcHJldi50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFubm90YXRpb247XG4gICAgICBpZiAoZmlsZSkgbWFwID0gam9pbihkaXJuYW1lJDEoZmlsZSksIG1hcCk7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXApO1xuICAgIH1cbiAgfVxuICBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgc3RhcnQubGVuZ3RoKSA9PT0gc3RhcnQ7XG4gIH1cbiAgd2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudCAmJiB0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQubGVuZ3RoID4gMCk7XG4gIH1cbn07XG52YXIgcHJldmlvdXNNYXAgPSBQcmV2aW91c01hcCQyO1xuUHJldmlvdXNNYXAkMi5kZWZhdWx0ID0gUHJldmlvdXNNYXAkMjtcbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lciQxLCBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvciQxIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTDogcGF0aFRvRmlsZVVSTCQxIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgaXNBYnNvbHV0ZSwgcmVzb2x2ZTogcmVzb2x2ZSQxIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgbmFub2lkIH0gPSBub25TZWN1cmU7XG5sZXQgdGVybWluYWxIaWdobGlnaHQgPSByZXF1aXJlJCQyO1xubGV0IENzc1N5bnRheEVycm9yJDEgPSBjc3NTeW50YXhFcnJvcjtcbmxldCBQcmV2aW91c01hcCQxID0gcHJldmlvdXNNYXA7XG5sZXQgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxICYmIFNvdXJjZU1hcEdlbmVyYXRvciQxKTtcbmxldCBwYXRoQXZhaWxhYmxlJDEgPSBCb29sZWFuKHJlc29sdmUkMSAmJiBpc0Fic29sdXRlKTtcbmxldCBJbnB1dCQ0ID0gY2xhc3MgSW5wdXQyIHtcbiAgY29uc3RydWN0b3IoY3NzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoY3NzID09PSBudWxsIHx8IHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGNzcyA9PT0gXCJvYmplY3RcIiAmJiAhY3NzLnRvU3RyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3RDU1MgcmVjZWl2ZWQgJHtjc3N9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLmNzc1swXSA9PT0gXCJcXHVGRUZGXCIgfHwgdGhpcy5jc3NbMF0gPT09IFwi77++XCIpIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3Muc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRzLmZyb20pIHtcbiAgICAgIGlmICghcGF0aEF2YWlsYWJsZSQxIHx8IC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fCBpc0Fic29sdXRlKG9wdHMuZnJvbSkpIHtcbiAgICAgICAgdGhpcy5maWxlID0gb3B0cy5mcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxKG9wdHMuZnJvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoQXZhaWxhYmxlJDEgJiYgc291cmNlTWFwQXZhaWxhYmxlJDEpIHtcbiAgICAgIGxldCBtYXAgPSBuZXcgUHJldmlvdXNNYXAkMSh0aGlzLmNzcywgb3B0cyk7XG4gICAgICBpZiAobWFwLnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGxldCBmaWxlID0gbWFwLmNvbnN1bWVyKCkuZmlsZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZmlsZSkge1xuICAgICAgdGhpcy5pZCA9IFwiPGlucHV0IGNzcyBcIiArIG5hbm9pZCg2KSArIFwiPlwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gIH1cbiAgZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzID0ge30pIHtcbiAgICBsZXQgcmVzdWx0MiwgZW5kTGluZSwgZW5kQ29sdW1uO1xuICAgIGlmIChsaW5lICYmIHR5cGVvZiBsaW5lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBsZXQgc3RhcnQgPSBsaW5lO1xuICAgICAgbGV0IGVuZCA9IGNvbHVtbjtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICBjb2x1bW4gPSBwb3MuY29sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmU7XG4gICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICBlbmRMaW5lID0gcG9zLmxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IHBvcy5jb2w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghY29sdW1uKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICB9XG4gICAgbGV0IG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKTtcbiAgICBpZiAob3JpZ2luKSB7XG4gICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4ubGluZSA6IHsgY29sdW1uOiBvcmlnaW4uY29sdW1uLCBsaW5lOiBvcmlnaW4ubGluZSB9LFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmNvbHVtbiA6IHsgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLCBsaW5lOiBvcmlnaW4uZW5kTGluZSB9LFxuICAgICAgICBvcmlnaW4uc291cmNlLFxuICAgICAgICBvcmlnaW4uZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMShcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHsgY29sdW1uLCBsaW5lIH0sXG4gICAgICAgIGVuZExpbmUgPT09IHZvaWQgMCA/IGNvbHVtbiA6IHsgY29sdW1uOiBlbmRDb2x1bW4sIGxpbmU6IGVuZExpbmUgfSxcbiAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgIHRoaXMuZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VsdDIuaW5wdXQgPSB7IGNvbHVtbiwgZW5kQ29sdW1uLCBlbmRMaW5lLCBsaW5lLCBzb3VyY2U6IHRoaXMuY3NzIH07XG4gICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwkMSkge1xuICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLmZpbGUpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQyLmlucHV0LmZpbGUgPSB0aGlzLmZpbGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGZyb21PZmZzZXQob2Zmc2V0KSB7XG4gICAgbGV0IGxhc3RMaW5lLCBsaW5lVG9JbmRleDtcbiAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlXSkge1xuICAgICAgbGV0IGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoXCJcXG5cIik7XG4gICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgbGV0IHByZXZJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGwyID0gbGluZXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICAgIGxpbmVUb0luZGV4W2kyXSA9IHByZXZJbmRleDtcbiAgICAgICAgcHJldkluZGV4ICs9IGxpbmVzW2kyXS5sZW5ndGggKyAxO1xuICAgICAgfVxuICAgICAgdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdID0gbGluZVRvSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVUb0luZGV4ID0gdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdO1xuICAgIH1cbiAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdO1xuICAgIGxldCBtaW4gPSAwO1xuICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyO1xuICAgICAgbGV0IG1pZDtcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVUb0luZGV4W21pZF0pIHtcbiAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgbGluZTogbWluICsgMVxuICAgIH07XG4gIH1cbiAgbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZSQxKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8IFwiLlwiLCBmaWxlKTtcbiAgfVxuICBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbnN1bWVyID0gdGhpcy5tYXAuY29uc3VtZXIoKTtcbiAgICBsZXQgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBjb2x1bW4sIGxpbmUgfSk7XG4gICAgaWYgKCFmcm9tLnNvdXJjZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0bztcbiAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbjogZW5kQ29sdW1uLCBsaW5lOiBlbmRMaW5lIH0pO1xuICAgIH1cbiAgICBsZXQgZnJvbVVybDtcbiAgICBpZiAoaXNBYnNvbHV0ZShmcm9tLnNvdXJjZSkpIHtcbiAgICAgIGZyb21VcmwgPSBwYXRoVG9GaWxlVVJMJDEoZnJvbS5zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVXJsID0gbmV3IFVSTChcbiAgICAgICAgZnJvbS5zb3VyY2UsXG4gICAgICAgIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMJDEodGhpcy5tYXAubWFwRmlsZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCByZXN1bHQyID0ge1xuICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgfTtcbiAgICBpZiAoZnJvbVVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiKSB7XG4gICAgICBpZiAoZmlsZVVSTFRvUGF0aCkge1xuICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoKGZyb21VcmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWxlOiBwcm90b2NvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSkgcmVzdWx0Mi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBvZiBbXCJoYXNCT01cIiwgXCJjc3NcIiwgXCJmaWxlXCIsIFwiaWRcIl0pIHtcbiAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAganNvbltuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAganNvbi5tYXAgPSB7IC4uLnRoaXMubWFwIH07XG4gICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlIHx8IHRoaXMuaWQ7XG4gIH1cbn07XG52YXIgaW5wdXQgPSBJbnB1dCQ0O1xuSW5wdXQkNC5kZWZhdWx0ID0gSW5wdXQkNDtcbmlmICh0ZXJtaW5hbEhpZ2hsaWdodCAmJiB0ZXJtaW5hbEhpZ2hsaWdodC5yZWdpc3RlcklucHV0KSB7XG4gIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQoSW5wdXQkNCk7XG59XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgZGlybmFtZSwgcmVsYXRpdmUsIHJlc29sdmUsIHNlcCB9ID0gcmVxdWlyZSQkMjtcbmxldCB7IHBhdGhUb0ZpbGVVUkwgfSA9IHJlcXVpcmUkJDI7XG5sZXQgSW5wdXQkMyA9IGlucHV0O1xubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIgJiYgU291cmNlTWFwR2VuZXJhdG9yKTtcbmxldCBwYXRoQXZhaWxhYmxlID0gQm9vbGVhbihkaXJuYW1lICYmIHJlc29sdmUgJiYgcmVsYXRpdmUgJiYgc2VwKTtcbmxldCBNYXBHZW5lcmF0b3IkMiA9IGNsYXNzIE1hcEdlbmVyYXRvcjIge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdpZnkyLCByb290Miwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgIHRoaXMubWFwT3B0cyA9IG9wdHMubWFwIHx8IHt9O1xuICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jc3MgPSBjc3NTdHJpbmc7XG4gICAgdGhpcy5vcmlnaW5hbENTUyA9IGNzc1N0cmluZztcbiAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRBbm5vdGF0aW9uKCkge1xuICAgIGxldCBjb250ZW50O1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKHRoaXMub3B0cy50bywgdGhpcy5yb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgfVxuICAgIGxldCBlb2wgPSBcIlxcblwiO1xuICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICB0aGlzLmNzcyArPSBlb2wgKyBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY29udGVudCArIFwiICovXCI7XG4gIH1cbiAgYXBwbHlQcmV2TWFwcygpIHtcbiAgICBmb3IgKGxldCBwcmV2IG9mIHRoaXMucHJldmlvdXMoKSkge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgIGxldCByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lKHByZXYuZmlsZSk7XG4gICAgICBsZXQgbWFwO1xuICAgICAgaWYgKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKHByZXYudGV4dCk7XG4gICAgICAgIGlmIChtYXAuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgIH1cbiAgfVxuICBjbGVhckFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIGxldCBub2RlMjtcbiAgICAgIGZvciAobGV0IGkyID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZTIudGV4dC5pbmRleE9mKFwiIyBzb3VyY2VNYXBwaW5nVVJMPVwiKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbio/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGUoKSB7XG4gICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICBpZiAocGF0aEF2YWlsYWJsZSAmJiBzb3VyY2VNYXBBdmFpbGFibGUgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIChpMikgPT4ge1xuICAgICAgICByZXN1bHQyICs9IGkyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdDJdO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZU1hcCgpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpO1xuICAgICAgcHJldi5maWxlID0gdGhpcy5vdXRwdXRGaWxlKCk7XG4gICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYsIHtcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDogeyBjb2x1bW46IDAsIGxpbmU6IDEgfSxcbiAgICAgICAgb3JpZ2luYWw6IHsgY29sdW1uOiAwLCBsaW5lOiAxIH0sXG4gICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTb3VyY2VzQ29udGVudCgpKSB0aGlzLnNldFNvdXJjZXNDb250ZW50KCk7XG4gICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpO1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3NdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RoaXMuY3NzLCB0aGlzLm1hcF07XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgIHRoaXMuY3NzID0gXCJcIjtcbiAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIGxldCBsaW5lID0gMTtcbiAgICBsZXQgY29sdW1uID0gMTtcbiAgICBsZXQgbm9Tb3VyY2UgPSBcIjxubyBzb3VyY2U+XCI7XG4gICAgbGV0IG1hcHBpbmcgPSB7XG4gICAgICBnZW5lcmF0ZWQ6IHsgY29sdW1uOiAwLCBsaW5lOiAwIH0sXG4gICAgICBvcmlnaW5hbDogeyBjb2x1bW46IDAsIGxpbmU6IDAgfSxcbiAgICAgIHNvdXJjZTogXCJcIlxuICAgIH07XG4gICAgbGV0IGxpbmVzLCBsYXN0O1xuICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKHN0ciwgbm9kZTIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMuY3NzICs9IHN0cjtcbiAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcImVuZFwiKSB7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5zdGFydCkge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxO1xuICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwic3RhcnRcIikge1xuICAgICAgICBsZXQgcCA9IG5vZGUyLnBhcmVudCB8fCB7IHJhd3M6IHt9IH07XG4gICAgICAgIGxldCBjaGlsZGxlc3MgPSBub2RlMi50eXBlID09PSBcImRlY2xcIiB8fCBub2RlMi50eXBlID09PSBcImF0cnVsZVwiICYmICFub2RlMi5ub2RlcztcbiAgICAgICAgaWYgKCFjaGlsZGxlc3MgfHwgbm9kZTIgIT09IHAubGFzdCB8fCBwLnJhd3Muc2VtaWNvbG9uKSB7XG4gICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5lbmQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMjtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0Fubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZSgoaTIpID0+IGkyLmFubm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5pbmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lO1xuICAgIH1cbiAgICBsZXQgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoKGkyKSA9PiBpMi5pbmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc01hcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiAhIXRoaXMub3B0cy5tYXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBpc1NvdXJjZXNDb250ZW50KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKChpMikgPT4gaTIud2l0aENvbnRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG91dHB1dEZpbGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMudG8pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJ0by5jc3NcIjtcbiAgICB9XG4gIH1cbiAgcGF0aChmaWxlKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGU7XG4gICAgaWYgKGZpbGUuY2hhckNvZGVBdCgwKSA9PT0gNjApIHJldHVybiBmaWxlO1xuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZTtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZFBhdGhzLmdldChmaWxlKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSh0aGlzLm9wdHMudG8pIDogXCIuXCI7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZnJvbSA9IGRpcm5hbWUocmVzb2x2ZShmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IHJlbGF0aXZlKGZyb20sIGZpbGUpO1xuICAgIHRoaXMubWVtb2l6ZWRQYXRocy5zZXQoZmlsZSwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcHJldmlvdXMoKSB7XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290LndhbGsoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gbm9kZTIuc291cmNlLmlucHV0Lm1hcDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpbnB1dDIgPSBuZXcgSW5wdXQkMyh0aGlzLm9yaWdpbmFsQ1NTLCB0aGlzLm9wdHMpO1xuICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzO1xuICB9XG4gIHNldFNvdXJjZXNDb250ZW50KCkge1xuICAgIGxldCBhbHJlYWR5ID0ge307XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5yb290LndhbGsoKG5vZGUyKSA9PiB7XG4gICAgICAgIGlmIChub2RlMi5zb3VyY2UpIHtcbiAgICAgICAgICBsZXQgZnJvbSA9IG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tO1xuICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmcm9tVXJsID0gdGhpcy51c2VzRmlsZVVybHMgPyB0aGlzLnRvRmlsZVVybChmcm9tKSA6IHRoaXMudG9VcmwodGhpcy5wYXRoKGZyb20pKTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbVVybCwgbm9kZTIuc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICBsZXQgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgIH1cbiAgfVxuICBzb3VyY2VQYXRoKG5vZGUyKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVzZXNGaWxlVXJscykge1xuICAgICAgcmV0dXJuIHRoaXMudG9GaWxlVXJsKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKSk7XG4gICAgfVxuICB9XG4gIHRvQmFzZTY0KHN0cikge1xuICAgIGlmIChCdWZmZXIpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9XG4gIH1cbiAgdG9GaWxlVXJsKHBhdGgpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGlmIChwYXRoVG9GaWxlVVJMKSB7XG4gICAgICBsZXQgZmlsZVVSTCA9IHBhdGhUb0ZpbGVVUkwocGF0aCkudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5zZXQocGF0aCwgZmlsZVVSTCk7XG4gICAgICByZXR1cm4gZmlsZVVSTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImBtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0b1VybChwYXRoKSB7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGlmIChzZXAgPT09IFwiXFxcXFwiKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcbnZhciBtYXBHZW5lcmF0b3IgPSBNYXBHZW5lcmF0b3IkMjtcbmxldCBOb2RlJDIgPSBub2RlO1xubGV0IENvbW1lbnQkNCA9IGNsYXNzIENvbW1lbnQyIGV4dGVuZHMgTm9kZSQyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJjb21tZW50XCI7XG4gIH1cbn07XG52YXIgY29tbWVudCA9IENvbW1lbnQkNDtcbkNvbW1lbnQkNC5kZWZhdWx0ID0gQ29tbWVudCQ0O1xubGV0IHsgaXNDbGVhbjogaXNDbGVhbiQxLCBteTogbXkkMSB9ID0gc3ltYm9scztcbmxldCBEZWNsYXJhdGlvbiQzID0gZGVjbGFyYXRpb247XG5sZXQgQ29tbWVudCQzID0gY29tbWVudDtcbmxldCBOb2RlJDEgPSBub2RlO1xubGV0IHBhcnNlJDQsIFJ1bGUkNCwgQXRSdWxlJDQsIFJvb3QkNjtcbmZ1bmN0aW9uIGNsZWFuU291cmNlKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5tYXAoKGkyKSA9PiB7XG4gICAgaWYgKGkyLm5vZGVzKSBpMi5ub2RlcyA9IGNsZWFuU291cmNlKGkyLm5vZGVzKTtcbiAgICBkZWxldGUgaTIuc291cmNlO1xuICAgIHJldHVybiBpMjtcbiAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcChub2RlMikge1xuICBub2RlMltpc0NsZWFuJDFdID0gZmFsc2U7XG4gIGlmIChub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgZm9yIChsZXQgaTIgb2Ygbm9kZTIucHJveHlPZi5ub2Rlcykge1xuICAgICAgbWFya0RpcnR5VXAoaTIpO1xuICAgIH1cbiAgfVxufVxubGV0IENvbnRhaW5lciQ3ID0gY2xhc3MgQ29udGFpbmVyMiBleHRlbmRzIE5vZGUkMSB7XG4gIGFwcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlMik7XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgc3VwZXIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2YgdGhpcy5ub2Rlcykgbm9kZTIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICB9XG4gIH1cbiAgZWFjaChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpdGVyYXRvciA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICBsZXQgaW5kZXgyLCByZXN1bHQyO1xuICAgIHdoaWxlICh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXgyXSwgaW5kZXgyKTtcbiAgICAgIGlmIChyZXN1bHQyID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGV2ZXJ5KGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbik7XG4gIH1cbiAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge307XG4gICAgdGhpcy5sYXN0RWFjaCArPSAxO1xuICAgIGxldCBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2g7XG4gICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA9IDA7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9XG4gIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICB9IGVsc2UgaWYgKCFub2RlMltwcm9wXSkge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImVhY2hcIiB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiAmJiBwcm9wLnN0YXJ0c1dpdGgoXCJ3YWxrXCIpKSB7XG4gICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oXG4gICAgICAgICAgICAgIC4uLmFyZ3MubWFwKChpMikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChjaGlsZCwgaW5kZXgyKSA9PiBpMihjaGlsZC50b1Byb3h5KCksIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJldmVyeVwiIHx8IHByb3AgPT09IFwic29tZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKFxuICAgICAgICAgICAgICAoY2hpbGQsIC4uLm90aGVyKSA9PiBjYihjaGlsZC50b1Byb3h5KCksIC4uLm90aGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyLm5vZGVzLm1hcCgoaTIpID0+IGkyLnRvUHJveHkoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJmaXJzdFwiIHx8IHByb3AgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcInNlbGVjdG9yXCIpIHtcbiAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGluZGV4KGNoaWxkKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNoaWxkO1xuICAgIGlmIChjaGlsZC5wcm94eU9mKSBjaGlsZCA9IGNoaWxkLnByb3h5T2Y7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgfVxuICBpbnNlcnRBZnRlcihleGlzdCwgYWRkKSB7XG4gICAgbGV0IGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpO1xuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZTIpO1xuICAgIGxldCBpbmRleDI7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleDIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgbGV0IHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gXCJwcmVwZW5kXCIgOiBmYWxzZTtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSwgdHlwZSkucmV2ZXJzZSgpO1xuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlMik7XG4gICAgbGV0IGluZGV4MjtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICBpZiAoZXhpc3RJbmRleCA8PSBpbmRleDIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5vZGVzID0gY2xlYW5Tb3VyY2UocGFyc2UkNChub2Rlcykubm9kZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBub2RlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vZGVzLnZhbHVlID0gU3RyaW5nKG5vZGVzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gW25ldyBEZWNsYXJhdGlvbiQzKG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3Rvcikge1xuICAgICAgbm9kZXMgPSBbbmV3IFJ1bGUkNChub2RlcyldO1xuICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgbm9kZXMgPSBbbmV3IEF0UnVsZSQ0KG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy50ZXh0KSB7XG4gICAgICBub2RlcyA9IFtuZXcgQ29tbWVudCQzKG5vZGVzKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgfVxuICAgIGxldCBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoKGkyKSA9PiB7XG4gICAgICBpZiAoIWkyW215JDFdKSBDb250YWluZXIyLnJlYnVpbGQoaTIpO1xuICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgIGlmIChpMltpc0NsZWFuJDFdKSBtYXJrRGlydHlVcChpMik7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzYW1wbGUgJiYgdHlwZW9mIHNhbXBsZS5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaTIucGFyZW50ID0gdGhpcy5wcm94eU9mO1xuICAgICAgcmV0dXJuIGkyO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gIH1cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5maXJzdCwgXCJwcmVwZW5kXCIpLnJldmVyc2UoKTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlMik7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IHRoaXMuaW5kZXhlc1tpZF0gKyBub2Rlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaChjaGlsZCkge1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUFsbCgpIHtcbiAgICBmb3IgKGxldCBub2RlMiBvZiB0aGlzLnByb3h5T2Yubm9kZXMpIG5vZGUyLnBhcmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMgPSBbXTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXNbY2hpbGRdLnBhcmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICBsZXQgaW5kZXgyO1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIGlmIChpbmRleDIgPj0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy53YWxrRGVjbHMoKGRlY2wpID0+IHtcbiAgICAgIGlmIChvcHRzLnByb3BzICYmICFvcHRzLnByb3BzLmluY2x1ZGVzKGRlY2wucHJvcCkpIHJldHVybjtcbiAgICAgIGlmIChvcHRzLmZhc3QgJiYgIWRlY2wudmFsdWUuaW5jbHVkZXMob3B0cy5mYXN0KSkgcmV0dXJuO1xuICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZShwYXR0ZXJuLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzb21lKGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgfVxuICB3YWxrKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaCgoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0MjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlMik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0MiAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICByZXN1bHQyID0gY2hpbGQud2FsayhjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9KTtcbiAgfVxuICB3YWxrQXRSdWxlcyhuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrQ29tbWVudHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrRGVjbHMocHJvcCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IHByb3A7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIGNoaWxkLnByb3AgPT09IHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2Fsa1J1bGVzKHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIGNoaWxkLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZmlyc3QoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1swXTtcbiAgfVxuICBnZXQgbGFzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzW3RoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUGFyc2UgPSAoZGVwZW5kYW50KSA9PiB7XG4gIHBhcnNlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJSdWxlID0gKGRlcGVuZGFudCkgPT4ge1xuICBSdWxlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJBdFJ1bGUgPSAoZGVwZW5kYW50KSA9PiB7XG4gIEF0UnVsZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUm9vdCA9IChkZXBlbmRhbnQpID0+IHtcbiAgUm9vdCQ2ID0gZGVwZW5kYW50O1xufTtcbnZhciBjb250YWluZXIgPSBDb250YWluZXIkNztcbkNvbnRhaW5lciQ3LmRlZmF1bHQgPSBDb250YWluZXIkNztcbkNvbnRhaW5lciQ3LnJlYnVpbGQgPSAobm9kZTIpID0+IHtcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0LnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJ1bGUkNC5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMy5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSb290JDYucHJvdG90eXBlKTtcbiAgfVxuICBub2RlMltteSQxXSA9IHRydWU7XG4gIGlmIChub2RlMi5ub2Rlcykge1xuICAgIG5vZGUyLm5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBDb250YWluZXIkNy5yZWJ1aWxkKGNoaWxkKTtcbiAgICB9KTtcbiAgfVxufTtcbmxldCBDb250YWluZXIkNiA9IGNvbnRhaW5lcjtcbmxldCBMYXp5UmVzdWx0JDQsIFByb2Nlc3NvciQzO1xubGV0IERvY3VtZW50JDMgPSBjbGFzcyBEb2N1bWVudDIzIGV4dGVuZHMgQ29udGFpbmVyJDYge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKHsgdHlwZTogXCJkb2N1bWVudFwiLCAuLi5kZWZhdWx0cyB9KTtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG4gIH1cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdCQ0KG5ldyBQcm9jZXNzb3IkMygpLCB0aGlzLCBvcHRzKTtcbiAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgfVxufTtcbkRvY3VtZW50JDMucmVnaXN0ZXJMYXp5UmVzdWx0ID0gKGRlcGVuZGFudCkgPT4ge1xuICBMYXp5UmVzdWx0JDQgPSBkZXBlbmRhbnQ7XG59O1xuRG9jdW1lbnQkMy5yZWdpc3RlclByb2Nlc3NvciA9IChkZXBlbmRhbnQpID0+IHtcbiAgUHJvY2Vzc29yJDMgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGRvY3VtZW50JDEgPSBEb2N1bWVudCQzO1xuRG9jdW1lbnQkMy5kZWZhdWx0ID0gRG9jdW1lbnQkMztcbmxldCBwcmludGVkID0ge307XG52YXIgd2Fybk9uY2UkMiA9IGZ1bmN0aW9uIHdhcm5PbmNlMihtZXNzYWdlKSB7XG4gIGlmIChwcmludGVkW21lc3NhZ2VdKSByZXR1cm47XG4gIHByaW50ZWRbbWVzc2FnZV0gPSB0cnVlO1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59O1xubGV0IFdhcm5pbmckMiA9IGNsYXNzIFdhcm5pbmcyIHtcbiAgY29uc3RydWN0b3IodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gXCJ3YXJuaW5nXCI7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpO1xuICAgICAgdGhpcy5saW5lID0gcmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmU7XG4gICAgICB0aGlzLmVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgfVxuICAgIGZvciAobGV0IG9wdCBpbiBvcHRzKSB0aGlzW29wdF0gPSBvcHRzW29wdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgIHBsdWdpbjogdGhpcy5wbHVnaW4sXG4gICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGx1Z2luKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW4gKyBcIjogXCIgKyB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cbn07XG52YXIgd2FybmluZyA9IFdhcm5pbmckMjtcbldhcm5pbmckMi5kZWZhdWx0ID0gV2FybmluZyQyO1xubGV0IFdhcm5pbmckMSA9IHdhcm5pbmc7XG5sZXQgUmVzdWx0JDMgPSBjbGFzcyBSZXN1bHQyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpIHtcbiAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzO1xuICB9XG4gIHdhcm4odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBvcHRzLnBsdWdpbiA9IHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2FybmluZzIgPSBuZXcgV2FybmluZyQxKHRleHQsIG9wdHMpO1xuICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nMik7XG4gICAgcmV0dXJuIHdhcm5pbmcyO1xuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbHRlcigoaTIpID0+IGkyLnR5cGUgPT09IFwid2FybmluZ1wiKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbn07XG52YXIgcmVzdWx0ID0gUmVzdWx0JDM7XG5SZXN1bHQkMy5kZWZhdWx0ID0gUmVzdWx0JDM7XG5jb25zdCBTSU5HTEVfUVVPVEUgPSBcIidcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgRE9VQkxFX1FVT1RFID0gJ1wiJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgQkFDS1NMQVNIID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNMQVNIID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTUEFDRSA9IFwiIFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBGRUVEID0gXCJcXGZcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgVEFCID0gXCJcdFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDUiA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fU1FVQVJFID0gXCJbXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX1NRVUFSRSA9IFwiXVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUEVOX1BBUkVOVEhFU0VTID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENMT1NFX1BBUkVOVEhFU0VTID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fQ1VSTFkgPSBcIntcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfQ1VSTFkgPSBcIn1cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgU0VNSUNPTE9OID0gXCI7XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEFTVEVSSVNLID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENPTE9OID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEFUID0gXCJAXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFJFX0FUX0VORCA9IC9bXFx0XFxuXFxmXFxyIFwiIycoKS87W1xcXFxcXF17fV0vZztcbmNvbnN0IFJFX1dPUkRfRU5EID0gL1tcXHRcXG5cXGZcXHIgIVwiIycoKTo7QFtcXFxcXFxde31dfFxcLyg/PVxcKikvZztcbmNvbnN0IFJFX0JBRF9CUkFDS0VUID0gLy5bXFxyXFxuXCInKC9cXFxcXS87XG5jb25zdCBSRV9IRVhfRVNDQVBFID0gL1tcXGRhLWZdL2k7XG52YXIgdG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZXIyKGlucHV0Miwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjc3MgPSBpbnB1dDIuY3NzLnZhbHVlT2YoKTtcbiAgbGV0IGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzO1xuICBsZXQgY29kZSwgbmV4dCwgcXVvdGUsIGNvbnRlbnQsIGVzY2FwZTtcbiAgbGV0IGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbjIsIGN1cnJlbnRUb2tlbjtcbiAgbGV0IGxlbmd0aCA9IGNzcy5sZW5ndGg7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgYnVmZmVyID0gW107XG4gIGxldCByZXR1cm5lZCA9IFtdO1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICB0aHJvdyBpbnB1dDIuZXJyb3IoXCJVbmNsb3NlZCBcIiArIHdoYXQsIHBvcyk7XG4gIH1cbiAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBuZXh0VG9rZW4ob3B0cykge1xuICAgIGlmIChyZXR1cm5lZC5sZW5ndGgpIHJldHVybiByZXR1cm5lZC5wb3AoKTtcbiAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuO1xuICAgIGxldCBpZ25vcmVVbmNsb3NlZCA9IG9wdHMgPyBvcHRzLmlnbm9yZVVuY2xvc2VkIDogZmFsc2U7XG4gICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIE5FV0xJTkU6XG4gICAgICBjYXNlIFNQQUNFOlxuICAgICAgY2FzZSBUQUI6XG4gICAgICBjYXNlIENSOlxuICAgICAgY2FzZSBGRUVEOiB7XG4gICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICB9IHdoaWxlIChjb2RlID09PSBTUEFDRSB8fCBjb2RlID09PSBORVdMSU5FIHx8IGNvZGUgPT09IFRBQiB8fCBjb2RlID09PSBDUiB8fCBjb2RlID09PSBGRUVEKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW1wic3BhY2VcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCldO1xuICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIE9QRU5fU1FVQVJFOlxuICAgICAgY2FzZSBDTE9TRV9TUVVBUkU6XG4gICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICBjYXNlIENMT1NFX0NVUkxZOlxuICAgICAgY2FzZSBDT0xPTjpcbiAgICAgIGNhc2UgU0VNSUNPTE9OOlxuICAgICAgY2FzZSBDTE9TRV9QQVJFTlRIRVNFUzoge1xuICAgICAgICBsZXQgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbY29udHJvbENoYXIsIGNvbnRyb2xDaGFyLCBwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUzoge1xuICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6IFwiXCI7XG4gICAgICAgIG4yID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgIGlmIChwcmV2ID09PSBcInVybFwiICYmIG4yICE9PSBTSU5HTEVfUVVPVEUgJiYgbjIgIT09IERPVUJMRV9RVU9URSAmJiBuMiAhPT0gU1BBQ0UgJiYgbjIgIT09IE5FV0xJTkUgJiYgbjIgIT09IFRBQiAmJiBuMiAhPT0gRkVFRCAmJiBuMiAhPT0gQ1IpIHtcbiAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgY3VycmVudFRva2VuID0gW1wiYnJhY2tldHNcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBwb3MgKyAxKTtcbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCIoXCIsIFwiKFwiLCBwb3NdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJicmFja2V0c1wiLCBjb250ZW50LCBwb3MsIG5leHRdO1xuICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFNJTkdMRV9RVU9URTpcbiAgICAgIGNhc2UgRE9VQkxFX1FVT1RFOiB7XG4gICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFID8gXCInXCIgOiAnXCInO1xuICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW1wic3RyaW5nXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEFUOiB7XG4gICAgICAgIFJFX0FUX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICBSRV9BVF9FTkQudGVzdChjc3MpO1xuICAgICAgICBpZiAoUkVfQVRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gUkVfQVRfRU5ELmxhc3RJbmRleCAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRva2VuID0gW1wiYXQtd29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBCQUNLU0xBU0g6IHtcbiAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgICAgaWYgKGVzY2FwZSAmJiBjb2RlICE9PSBTTEFTSCAmJiBjb2RlICE9PSBTUEFDRSAmJiBjb2RlICE9PSBORVdMSU5FICYmIGNvZGUgIT09IFRBQiAmJiBjb2RlICE9PSBDUiAmJiBjb2RlICE9PSBGRUVEKSB7XG4gICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgIGlmIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgIHdoaWxlIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRva2VuID0gW1wid29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0ggJiYgY3NzLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgcG9zICsgMikgKyAxO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJjb21tZW50XCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgUkVfV09SRF9FTkQudGVzdChjc3MpO1xuICAgICAgICAgIGlmIChSRV9XT1JEX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCA9IFJFX1dPUkRfRU5ELmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcIndvcmRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zKys7XG4gICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgfVxuICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgcmV0dXJuZWQucHVzaCh0b2tlbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYWNrLFxuICAgIGVuZE9mRmlsZSxcbiAgICBuZXh0VG9rZW4sXG4gICAgcG9zaXRpb25cbiAgfTtcbn07XG5sZXQgQ29udGFpbmVyJDUgPSBjb250YWluZXI7XG5sZXQgQXRSdWxlJDMgPSBjbGFzcyBBdFJ1bGUyIGV4dGVuZHMgQ29udGFpbmVyJDUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICB9XG4gIGFwcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gIH1cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmQoLi4uY2hpbGRyZW4pO1xuICB9XG59O1xudmFyIGF0UnVsZSA9IEF0UnVsZSQzO1xuQXRSdWxlJDMuZGVmYXVsdCA9IEF0UnVsZSQzO1xuQ29udGFpbmVyJDUucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlJDMpO1xubGV0IENvbnRhaW5lciQ0ID0gY29udGFpbmVyO1xubGV0IExhenlSZXN1bHQkMywgUHJvY2Vzc29yJDI7XG5sZXQgUm9vdCQ1ID0gY2xhc3MgUm9vdDIgZXh0ZW5kcyBDb250YWluZXIkNCB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICB9XG4gIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgbGV0IG5vZGVzID0gc3VwZXIubm9ybWFsaXplKGNoaWxkKTtcbiAgICBpZiAoc2FtcGxlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHNhbXBsZS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQsIGlnbm9yZSkge1xuICAgIGxldCBpbmRleDIgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICBpZiAoIWlnbm9yZSAmJiBpbmRleDIgPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleDJdLnJhd3MuYmVmb3JlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRvUmVzdWx0KG9wdHMgPSB7fSkge1xuICAgIGxldCBsYXp5ID0gbmV3IExhenlSZXN1bHQkMyhuZXcgUHJvY2Vzc29yJDIoKSwgdGhpcywgb3B0cyk7XG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gIH1cbn07XG5Sb290JDUucmVnaXN0ZXJMYXp5UmVzdWx0ID0gKGRlcGVuZGFudCkgPT4ge1xuICBMYXp5UmVzdWx0JDMgPSBkZXBlbmRhbnQ7XG59O1xuUm9vdCQ1LnJlZ2lzdGVyUHJvY2Vzc29yID0gKGRlcGVuZGFudCkgPT4ge1xuICBQcm9jZXNzb3IkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgcm9vdCA9IFJvb3QkNTtcblJvb3QkNS5kZWZhdWx0ID0gUm9vdCQ1O1xuQ29udGFpbmVyJDQucmVnaXN0ZXJSb290KFJvb3QkNSk7XG5sZXQgbGlzdCQyID0ge1xuICBjb21tYShzdHJpbmcpIHtcbiAgICByZXR1cm4gbGlzdCQyLnNwbGl0KHN0cmluZywgW1wiLFwiXSwgdHJ1ZSk7XG4gIH0sXG4gIHNwYWNlKHN0cmluZykge1xuICAgIGxldCBzcGFjZXMgPSBbXCIgXCIsIFwiXFxuXCIsIFwiXHRcIl07XG4gICAgcmV0dXJuIGxpc3QkMi5zcGxpdChzdHJpbmcsIHNwYWNlcyk7XG4gIH0sXG4gIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgIGxldCBhcnJheSA9IFtdO1xuICAgIGxldCBjdXJyZW50ID0gXCJcIjtcbiAgICBsZXQgc3BsaXQgPSBmYWxzZTtcbiAgICBsZXQgZnVuYyA9IDA7XG4gICAgbGV0IGluUXVvdGUgPSBmYWxzZTtcbiAgICBsZXQgcHJldlF1b3RlID0gXCJcIjtcbiAgICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgbGV0dGVyIG9mIHN0cmluZykge1xuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3RlKSB7XG4gICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgcHJldlF1b3RlID0gbGV0dGVyO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKFwiKSB7XG4gICAgICAgIGZ1bmMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIilcIikge1xuICAgICAgICBpZiAoZnVuYyA+IDApIGZ1bmMgLT0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmNsdWRlcyhsZXR0ZXIpKSBzcGxpdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgc3BsaXQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCB8fCBjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG52YXIgbGlzdF8xID0gbGlzdCQyO1xubGlzdCQyLmRlZmF1bHQgPSBsaXN0JDI7XG5sZXQgQ29udGFpbmVyJDMgPSBjb250YWluZXI7XG5sZXQgbGlzdCQxID0gbGlzdF8xO1xubGV0IFJ1bGUkMyA9IGNsYXNzIFJ1bGUyIGV4dGVuZHMgQ29udGFpbmVyJDMge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgfVxuICBnZXQgc2VsZWN0b3JzKCkge1xuICAgIHJldHVybiBsaXN0JDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gIH1cbiAgc2V0IHNlbGVjdG9ycyh2YWx1ZXMpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKSA6IG51bGw7XG4gICAgbGV0IHNlcDIgPSBtYXRjaCA/IG1hdGNoWzBdIDogXCIsXCIgKyB0aGlzLnJhdyhcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgIHRoaXMuc2VsZWN0b3IgPSB2YWx1ZXMuam9pbihzZXAyKTtcbiAgfVxufTtcbnZhciBydWxlID0gUnVsZSQzO1xuUnVsZSQzLmRlZmF1bHQgPSBSdWxlJDM7XG5Db250YWluZXIkMy5yZWdpc3RlclJ1bGUoUnVsZSQzKTtcbmxldCBEZWNsYXJhdGlvbiQyID0gZGVjbGFyYXRpb247XG5sZXQgdG9rZW5pemVyMjIgPSB0b2tlbml6ZTtcbmxldCBDb21tZW50JDIgPSBjb21tZW50O1xubGV0IEF0UnVsZSQyID0gYXRSdWxlO1xubGV0IFJvb3QkNCA9IHJvb3Q7XG5sZXQgUnVsZSQyID0gcnVsZTtcbmNvbnN0IFNBRkVfQ09NTUVOVF9ORUlHSEJPUiA9IHtcbiAgZW1wdHk6IHRydWUsXG4gIHNwYWNlOiB0cnVlXG59O1xuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSB7XG4gIGZvciAobGV0IGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgIGxldCBwb3MgPSB0b2tlblszXSB8fCB0b2tlblsyXTtcbiAgICBpZiAocG9zKSByZXR1cm4gcG9zO1xuICB9XG59XG5sZXQgUGFyc2VyJDEgPSBjbGFzcyBQYXJzZXIyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQyKSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0MjtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0KCk7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgdGhpcy5yb290LnNvdXJjZSA9IHsgaW5wdXQ6IGlucHV0Miwgc3RhcnQ6IHsgY29sdW1uOiAxLCBsaW5lOiAxLCBvZmZzZXQ6IDAgfSB9O1xuICB9XG4gIGF0cnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBBdFJ1bGUkMigpO1xuICAgIG5vZGUyLm5hbWUgPSB0b2tlblsxXS5zbGljZSgxKTtcbiAgICBpZiAobm9kZTIubmFtZSA9PT0gXCJcIikge1xuICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbik7XG4gICAgfVxuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCBzaGlmdDtcbiAgICBsZXQgbGFzdCA9IGZhbHNlO1xuICAgIGxldCBvcGVuID0gZmFsc2U7XG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBwcmV2ID0gcGFyYW1zW3NoaWZ0XTtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIHByZXZbMF0gPT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICBwcmV2ID0gcGFyYW1zWy0tc2hpZnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKTtcbiAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHBhcmFtcyk7XG4gICAgICB0aGlzLnJhdyhub2RlMiwgXCJwYXJhbXNcIiwgcGFyYW1zKTtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSBcIlwiO1xuICAgICAgbm9kZTIucGFyYW1zID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9XG4gIH1cbiAgY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpO1xuICAgIGlmIChjb2xvbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBsZXQgZm91bmRlZCA9IDA7XG4gICAgbGV0IHRva2VuO1xuICAgIGZvciAobGV0IGogPSBjb2xvbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgIGZvdW5kZWQgKz0gMTtcbiAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJNaXNzZWQgc2VtaWNvbG9uXCIsXG4gICAgICB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXVxuICAgICk7XG4gIH1cbiAgY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGJyYWNrZXRzID0gMDtcbiAgICBsZXQgdG9rZW4sIHR5cGUsIHByZXY7XG4gICAgZm9yIChsZXQgW2kyLCBlbGVtZW50XSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICB0b2tlbiA9IGVsZW1lbnQ7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIpIHtcbiAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIilcIikge1xuICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09IFwid29yZFwiICYmIHByZXZbMV0gPT09IFwicHJvZ2lkXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXYgPSB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbW1lbnQodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgQ29tbWVudCQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgbGV0IHRleHQgPSB0b2tlblsxXS5zbGljZSgyLCAtMik7XG4gICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgIG5vZGUyLnRleHQgPSBcIlwiO1xuICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gdGV4dDtcbiAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pO1xuICAgICAgbm9kZTIudGV4dCA9IG1hdGNoWzJdO1xuICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gbWF0Y2hbMV07XG4gICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gbWF0Y2hbM107XG4gICAgfVxuICB9XG4gIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjIyKHRoaXMuaW5wdXQpO1xuICB9XG4gIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCBub2RlMiA9IG5ldyBEZWNsYXJhdGlvbiQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgIGxldCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFswXSA9PT0gXCI7XCIpIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgIHRva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24oXG4gICAgICBsYXN0WzNdIHx8IGxhc3RbMl0gfHwgZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKVxuICAgICk7XG4gICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICB3aGlsZSAodG9rZW5zWzBdWzBdICE9PSBcIndvcmRcIikge1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgbm9kZTIucHJvcCA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxldCB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUyLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgbGV0IHRva2VuO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgaWYgKHRva2VuWzBdID09PSBcIjpcIikge1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSBcIndvcmRcIiAmJiAvXFx3Ly50ZXN0KHRva2VuWzFdKSkge1xuICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW3Rva2VuXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZTIucHJvcFswXSA9PT0gXCJfXCIgfHwgbm9kZTIucHJvcFswXSA9PT0gXCIqXCIpIHtcbiAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IG5vZGUyLnByb3BbMF07XG4gICAgICBub2RlMi5wcm9wID0gbm9kZTIucHJvcC5zbGljZSgxKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0U3BhY2VzID0gW107XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIGZpcnN0U3BhY2VzLnB1c2godG9rZW5zLnNoaWZ0KCkpO1xuICAgIH1cbiAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgZm9yIChsZXQgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiIWltcG9ydGFudFwiKSB7XG4gICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nO1xuICAgICAgICBpZiAoc3RyaW5nICE9PSBcIiAhaW1wb3J0YW50XCIpIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICBsZXQgY2FjaGUgPSB0b2tlbnMuc2xpY2UoMCk7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBqID0gaTI7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwICYmIHR5cGUgIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGNhY2hlLnBvcCgpWzFdICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwKSB7XG4gICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cjtcbiAgICAgICAgICB0b2tlbnMgPSBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIgJiYgdG9rZW5bMF0gIT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGFzV29yZCA9IHRva2Vucy5zb21lKChpMikgPT4gaTJbMF0gIT09IFwic3BhY2VcIiAmJiBpMlswXSAhPT0gXCJjb21tZW50XCIpO1xuICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKChpMikgPT4gaTJbMV0pLmpvaW4oXCJcIik7XG4gICAgICBmaXJzdFNwYWNlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnJhdyhub2RlMiwgXCJ2YWx1ZVwiLCBmaXJzdFNwYWNlcy5jb25jYXQodG9rZW5zKSwgY3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChub2RlMi52YWx1ZS5pbmNsdWRlcyhcIjpcIikgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgfVxuICB9XG4gIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiRG91YmxlIGNvbG9uXCIsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aCB9XG4gICAgKTtcbiAgfVxuICBlbXB0eVJ1bGUodG9rZW4pIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgUnVsZSQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc2VsZWN0b3IgPSBcIlwiO1xuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gIH1cbiAgZW5kKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO1xuICAgIH1cbiAgfVxuICBlbmRGaWxlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB0aGlzLnVuY2xvc2VkQmxvY2soKTtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgIHRoaXMucm9vdC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnRva2VuaXplci5wb3NpdGlvbigpKTtcbiAgfVxuICBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcInJ1bGVcIiAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gSGVscGVyc1xuICBnZXRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfVxuICBpbml0KG5vZGUyLCBvZmZzZXQpIHtcbiAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgbm9kZTIuc291cmNlID0ge1xuICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICBzdGFydDogdGhpcy5nZXRQb3NpdGlvbihvZmZzZXQpXG4gICAgfTtcbiAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gIH1cbiAgb3RoZXIoc3RhcnQpIHtcbiAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBjb2xvbiA9IGZhbHNlO1xuICAgIGxldCBicmFja2V0ID0gbnVsbDtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY3VzdG9tUHJvcGVydHkgPSBzdGFydFsxXS5zdGFydHNXaXRoKFwiLS1cIik7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IHN0YXJ0O1xuICAgIHdoaWxlICh0b2tlbikge1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIjpcIikge1xuICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIGVuZCA9IHRydWU7XG4gICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgIH1cbiAgfVxuICBwYXJzZSgpIHtcbiAgICBsZXQgdG9rZW47XG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSBcInNwYWNlXCI6XG4gICAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgdGhpcy5jb21tZW50KHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF0LXdvcmRcIjpcbiAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMub3RoZXIodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZEZpbGUoKTtcbiAgfVxuICBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpIHtcbiAgfVxuICByYXcobm9kZTIsIHByb3AsIHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICBsZXQgdG9rZW4sIHR5cGU7XG4gICAgbGV0IGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICBsZXQgY2xlYW4gPSB0cnVlO1xuICAgIGxldCBuZXh0LCBwcmV2O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcInNwYWNlXCIgJiYgaTIgPT09IGxlbmd0aCAtIDEgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICBuZXh0ID0gdG9rZW5zW2kyICsgMV0gPyB0b2tlbnNbaTIgKyAxXVswXSA6IFwiZW1wdHlcIjtcbiAgICAgICAgaWYgKCFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbcHJldl0gJiYgIVNBRkVfQ09NTUVOVF9ORUlHSEJPUltuZXh0XSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2xlYW4pIHtcbiAgICAgIGxldCByYXcgPSB0b2tlbnMucmVkdWNlKChhbGwsIGkyKSA9PiBhbGwgKyBpMlsxXSwgXCJcIik7XG4gICAgICBub2RlMi5yYXdzW3Byb3BdID0geyByYXcsIHZhbHVlIH07XG4gICAgfVxuICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gIH1cbiAgcnVsZSh0b2tlbnMpIHtcbiAgICB0b2tlbnMucG9wKCk7XG4gICAgbGV0IG5vZGUyID0gbmV3IFJ1bGUkMigpO1xuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgIHRoaXMucmF3KG5vZGUyLCBcInNlbGVjdG9yXCIsIHRva2Vucyk7XG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gIH1cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlO1xuICAgIGxldCBzcGFjZXMgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIC8vIEVycm9yc1xuICBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgc3BhY2VzID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGU7XG4gICAgbGV0IHNwYWNlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgc3RyaW5nRnJvbSh0b2tlbnMsIGZyb20pIHtcbiAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgZm9yIChsZXQgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIHJlc3VsdDIgKz0gdG9rZW5zW2kyXVsxXTtcbiAgICB9XG4gICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgdW5jbG9zZWRCbG9jaygpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydDtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYmxvY2tcIiwgcG9zLmxpbmUsIHBvcy5jb2x1bW4pO1xuICB9XG4gIHVuY2xvc2VkQnJhY2tldChicmFja2V0KSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiVW5jbG9zZWQgYnJhY2tldFwiLFxuICAgICAgeyBvZmZzZXQ6IGJyYWNrZXRbMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiBicmFja2V0WzJdICsgMSB9XG4gICAgKTtcbiAgfVxuICB1bmV4cGVjdGVkQ2xvc2UodG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIH1cIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgMSB9XG4gICAgKTtcbiAgfVxuICB1bmtub3duV29yZCh0b2tlbnMpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmtub3duIHdvcmRcIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gKyB0b2tlbnNbMF1bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG4gIHVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiQXQtcnVsZSB3aXRob3V0IG5hbWVcIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG59O1xudmFyIHBhcnNlciA9IFBhcnNlciQxO1xubGV0IENvbnRhaW5lciQyID0gY29udGFpbmVyO1xubGV0IFBhcnNlcjIyID0gcGFyc2VyO1xubGV0IElucHV0JDIgPSBpbnB1dDtcbmZ1bmN0aW9uIHBhcnNlJDMoY3NzLCBvcHRzKSB7XG4gIGxldCBpbnB1dDIgPSBuZXcgSW5wdXQkMihjc3MsIG9wdHMpO1xuICBsZXQgcGFyc2VyMiA9IG5ldyBQYXJzZXIyMihpbnB1dDIpO1xuICB0cnkge1xuICAgIHBhcnNlcjIucGFyc2UoKTtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoZTIubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmIG9wdHMgJiYgb3B0cy5mcm9tKSB7XG4gICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNDU1Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2NzcyBwYXJzZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU2FzcyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zYXNzIHBhcnNlclwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgTGVzcyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1sZXNzIHBhcnNlclwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGUyO1xuICB9XG4gIHJldHVybiBwYXJzZXIyLnJvb3Q7XG59XG52YXIgcGFyc2VfMSA9IHBhcnNlJDM7XG5wYXJzZSQzLmRlZmF1bHQgPSBwYXJzZSQzO1xuQ29udGFpbmVyJDIucmVnaXN0ZXJQYXJzZShwYXJzZSQzKTtcbmxldCB7IGlzQ2xlYW4sIG15IH0gPSBzeW1ib2xzO1xubGV0IE1hcEdlbmVyYXRvciQxID0gbWFwR2VuZXJhdG9yO1xubGV0IHN0cmluZ2lmeSQyID0gc3RyaW5naWZ5XzE7XG5sZXQgQ29udGFpbmVyJDEgPSBjb250YWluZXI7XG5sZXQgRG9jdW1lbnQkMiA9IGRvY3VtZW50JDE7XG5sZXQgd2Fybk9uY2UkMSA9IHdhcm5PbmNlJDI7XG5sZXQgUmVzdWx0JDIgPSByZXN1bHQ7XG5sZXQgcGFyc2UkMiA9IHBhcnNlXzE7XG5sZXQgUm9vdCQzID0gcm9vdDtcbmNvbnN0IFRZUEVfVE9fQ0xBU1NfTkFNRSA9IHtcbiAgYXRydWxlOiBcIkF0UnVsZVwiLFxuICBjb21tZW50OiBcIkNvbW1lbnRcIixcbiAgZGVjbDogXCJEZWNsYXJhdGlvblwiLFxuICBkb2N1bWVudDogXCJEb2N1bWVudFwiLFxuICByb290OiBcIlJvb3RcIixcbiAgcnVsZTogXCJSdWxlXCJcbn07XG5jb25zdCBQTFVHSU5fUFJPUFMgPSB7XG4gIEF0UnVsZTogdHJ1ZSxcbiAgQXRSdWxlRXhpdDogdHJ1ZSxcbiAgQ29tbWVudDogdHJ1ZSxcbiAgQ29tbWVudEV4aXQ6IHRydWUsXG4gIERlY2xhcmF0aW9uOiB0cnVlLFxuICBEZWNsYXJhdGlvbkV4aXQ6IHRydWUsXG4gIERvY3VtZW50OiB0cnVlLFxuICBEb2N1bWVudEV4aXQ6IHRydWUsXG4gIE9uY2U6IHRydWUsXG4gIE9uY2VFeGl0OiB0cnVlLFxuICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICBwcmVwYXJlOiB0cnVlLFxuICBSb290OiB0cnVlLFxuICBSb290RXhpdDogdHJ1ZSxcbiAgUnVsZTogdHJ1ZSxcbiAgUnVsZUV4aXQ6IHRydWVcbn07XG5jb25zdCBOT1RfVklTSVRPUlMgPSB7XG4gIE9uY2U6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWVcbn07XG5jb25zdCBDSElMRFJFTiA9IDA7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRzKG5vZGUyKSB7XG4gIGxldCBrZXkgPSBmYWxzZTtcbiAgbGV0IHR5cGUgPSBUWVBFX1RPX0NMQVNTX05BTUVbbm9kZTIudHlwZV07XG4gIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgIGtleSA9IG5vZGUyLnByb3AudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAga2V5ID0gbm9kZTIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGlmIChrZXkgJiYgbm9kZTIuYXBwZW5kKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGUsXG4gICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICBDSElMRFJFTixcbiAgICAgIHR5cGUgKyBcIkV4aXRcIixcbiAgICAgIHR5cGUgKyBcIkV4aXQtXCIgKyBrZXlcbiAgICBdO1xuICB9IGVsc2UgaWYgKGtleSkge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArIFwiLVwiICsga2V5LCB0eXBlICsgXCJFeGl0XCIsIHR5cGUgKyBcIkV4aXQtXCIgKyBrZXldO1xuICB9IGVsc2UgaWYgKG5vZGUyLmFwcGVuZCkge1xuICAgIHJldHVybiBbdHlwZSwgQ0hJTERSRU4sIHR5cGUgKyBcIkV4aXRcIl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt0eXBlLCB0eXBlICsgXCJFeGl0XCJdO1xuICB9XG59XG5mdW5jdGlvbiB0b1N0YWNrKG5vZGUyKSB7XG4gIGxldCBldmVudHM7XG4gIGlmIChub2RlMi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICBldmVudHMgPSBbXCJEb2N1bWVudFwiLCBDSElMRFJFTiwgXCJEb2N1bWVudEV4aXRcIl07XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICBldmVudHMgPSBbXCJSb290XCIsIENISUxEUkVOLCBcIlJvb3RFeGl0XCJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGdldEV2ZW50cyhub2RlMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBldmVudEluZGV4OiAwLFxuICAgIGV2ZW50cyxcbiAgICBpdGVyYXRvcjogMCxcbiAgICBub2RlOiBub2RlMixcbiAgICB2aXNpdG9ySW5kZXg6IDAsXG4gICAgdmlzaXRvcnM6IFtdXG4gIH07XG59XG5mdW5jdGlvbiBjbGVhbk1hcmtzKG5vZGUyKSB7XG4gIG5vZGUyW2lzQ2xlYW5dID0gZmFsc2U7XG4gIGlmIChub2RlMi5ub2Rlcykgbm9kZTIubm9kZXMuZm9yRWFjaCgoaTIpID0+IGNsZWFuTWFya3MoaTIpKTtcbiAgcmV0dXJuIG5vZGUyO1xufVxubGV0IHBvc3Rjc3MkMiA9IHt9O1xubGV0IExhenlSZXN1bHQkMiA9IGNsYXNzIExhenlSZXN1bHQyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgbGV0IHJvb3QyO1xuICAgIGlmICh0eXBlb2YgY3NzID09PSBcIm9iamVjdFwiICYmIGNzcyAhPT0gbnVsbCAmJiAoY3NzLnR5cGUgPT09IFwicm9vdFwiIHx8IGNzcy50eXBlID09PSBcImRvY3VtZW50XCIpKSB7XG4gICAgICByb290MiA9IGNsZWFuTWFya3MoY3NzKTtcbiAgICB9IGVsc2UgaWYgKGNzcyBpbnN0YW5jZW9mIExhenlSZXN1bHQyIHx8IGNzcyBpbnN0YW5jZW9mIFJlc3VsdCQyKSB7XG4gICAgICByb290MiA9IGNsZWFuTWFya3MoY3NzLnJvb3QpO1xuICAgICAgaWYgKGNzcy5tYXApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0cy5tYXAgPSB7fTtcbiAgICAgICAgaWYgKCFvcHRzLm1hcC5pbmxpbmUpIG9wdHMubWFwLmlubGluZSA9IGZhbHNlO1xuICAgICAgICBvcHRzLm1hcC5wcmV2ID0gY3NzLm1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhcnNlcjIgPSBwYXJzZSQyO1xuICAgICAgaWYgKG9wdHMuc3ludGF4KSBwYXJzZXIyID0gb3B0cy5zeW50YXgucGFyc2U7XG4gICAgICBpZiAob3B0cy5wYXJzZXIpIHBhcnNlcjIgPSBvcHRzLnBhcnNlcjtcbiAgICAgIGlmIChwYXJzZXIyLnBhcnNlKSBwYXJzZXIyID0gcGFyc2VyMi5wYXJzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJvb3QyID0gcGFyc2VyMihjc3MsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAocm9vdDIgJiYgIXJvb3QyW215XSkge1xuICAgICAgICBDb250YWluZXIkMS5yZWJ1aWxkKHJvb3QyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDIocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgIHRoaXMuaGVscGVycyA9IHsgLi4ucG9zdGNzcyQyLCBwb3N0Y3NzOiBwb3N0Y3NzJDIsIHJlc3VsdDogdGhpcy5yZXN1bHQgfTtcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLm1hcCgocGx1Z2luMjIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIucHJlcGFyZSkge1xuICAgICAgICByZXR1cm4geyAuLi5wbHVnaW4yMiwgLi4ucGx1Z2luMjIucHJlcGFyZSh0aGlzLnJlc3VsdCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4yMjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdCk7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgIHRoaXMucHJvY2Vzc2luZyA9IHRoaXMucnVuQXN5bmMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZztcbiAgfVxuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgfVxuICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gIH1cbiAgZ2V0QXN5bmNFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgcHJvY2Vzcyhjc3MpLnRoZW4oY2IpIHRvIHdvcmsgd2l0aCBhc3luYyBwbHVnaW5zXCIpO1xuICB9XG4gIGhhbmRsZUVycm9yKGVycm9yLCBub2RlMikge1xuICAgIGxldCBwbHVnaW4yMiA9IHRoaXMucmVzdWx0Lmxhc3RQbHVnaW47XG4gICAgdHJ5IHtcbiAgICAgIGlmIChub2RlMikgbm9kZTIuYWRkVG9FcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmICFlcnJvci5wbHVnaW4pIHtcbiAgICAgICAgZXJyb3IucGx1Z2luID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgZXJyb3Iuc2V0TWVzc2FnZSgpO1xuICAgICAgfSBlbHNlIGlmIChwbHVnaW4yMi5wb3N0Y3NzVmVyc2lvbikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgbGV0IHBsdWdpbk5hbWUgPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgIGxldCBwbHVnaW5WZXIgPSBwbHVnaW4yMi5wb3N0Y3NzVmVyc2lvbjtcbiAgICAgICAgICBsZXQgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uO1xuICAgICAgICAgIGxldCBhMiA9IHBsdWdpblZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgbGV0IGIgPSBydW50aW1lVmVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICBpZiAoYTJbMF0gIT09IGJbMF0gfHwgcGFyc2VJbnQoYTJbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVW5rbm93biBlcnJvciBmcm9tIFBvc3RDU1MgcGx1Z2luLiBZb3VyIGN1cnJlbnQgUG9zdENTUyB2ZXJzaW9uIGlzIFwiICsgcnVudGltZVZlciArIFwiLCBidXQgXCIgKyBwbHVnaW5OYW1lICsgXCIgdXNlcyBcIiArIHBsdWdpblZlciArIFwiLiBQZXJoYXBzIHRoaXMgaXMgdGhlIHNvdXJjZSBvZiB0aGUgZXJyb3IgYmVsb3cuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBwcmVwYXJlVmlzaXRvcnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICBsZXQgYWRkID0gKHBsdWdpbjIyLCB0eXBlLCBjYikgPT4ge1xuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goW3BsdWdpbjIyLCBjYl0pO1xuICAgIH07XG4gICAgZm9yIChsZXQgcGx1Z2luMjIgb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAobGV0IGV2ZW50IGluIHBsdWdpbjIyKSB7XG4gICAgICAgICAgaWYgKCFQTFVHSU5fUFJPUFNbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGV2ZW50ICR7ZXZlbnR9IGluICR7cGx1Z2luMjIucG9zdGNzc1BsdWdpbn0uIFRyeSB0byB1cGRhdGUgUG9zdENTUyAoJHt0aGlzLnByb2Nlc3Nvci52ZXJzaW9ufSBub3cpLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghTk9UX1ZJU0lUT1JTW2V2ZW50XSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgZmlsdGVyIGluIHBsdWdpbjIyW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50LCBwbHVnaW4yMltldmVudF1bZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFkZChcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ICsgXCItXCIgKyBmaWx0ZXIudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50LCBwbHVnaW4yMltldmVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDA7XG4gIH1cbiAgYXN5bmMgcnVuQXN5bmMoKSB7XG4gICAgdGhpcy5wbHVnaW4gPSAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBsZXQgcGx1Z2luMjIgPSB0aGlzLnBsdWdpbnNbaTJdO1xuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXBhcmVWaXNpdG9ycygpO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICBsZXQgcm9vdDIgPSB0aGlzLnJlc3VsdC5yb290O1xuICAgICAgd2hpbGUgKCFyb290Mltpc0NsZWFuXSkge1xuICAgICAgICByb290Mltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgIGxldCBzdGFjayA9IFt0b1N0YWNrKHJvb3QyKV07XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnZpc2l0VGljayhzdGFjayk7XG4gICAgICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgIGxldCBub2RlMiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICBmb3IgKGxldCBbcGx1Z2luMjIsIHZpc2l0b3JdIG9mIHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgIGxldCByb290cyA9IHJvb3QyLm5vZGVzLm1hcChcbiAgICAgICAgICAgICAgICAoc3ViUm9vdCkgPT4gdmlzaXRvcihzdWJSb290LCB0aGlzLmhlbHBlcnMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF3YWl0IHZpc2l0b3Iocm9vdDIsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCk7XG4gIH1cbiAgcnVuT25Sb290KHBsdWdpbjIyKSB7XG4gICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLk9uY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgbGV0IHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAoXG4gICAgICAgICAgICAocm9vdDIpID0+IHBsdWdpbjIyLk9uY2Uocm9vdDIsIHRoaXMuaGVscGVycylcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc1Byb21pc2Uocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm9vdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbjIyKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHN0cmluZ2lmeSgpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICBpZiAodGhpcy5zdHJpbmdpZmllZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSB0cnVlO1xuICAgIHRoaXMuc3luYygpO1xuICAgIGxldCBvcHRzID0gdGhpcy5yZXN1bHQub3B0cztcbiAgICBsZXQgc3RyID0gc3RyaW5naWZ5JDI7XG4gICAgaWYgKG9wdHMuc3ludGF4KSBzdHIgPSBvcHRzLnN5bnRheC5zdHJpbmdpZnk7XG4gICAgaWYgKG9wdHMuc3RyaW5naWZpZXIpIHN0ciA9IG9wdHMuc3RyaW5naWZpZXI7XG4gICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnk7XG4gICAgbGV0IG1hcCA9IG5ldyBNYXBHZW5lcmF0b3IkMShzdHIsIHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0Lm9wdHMpO1xuICAgIGxldCBkYXRhID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXTtcbiAgICB0aGlzLnJlc3VsdC5tYXAgPSBkYXRhWzFdO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcGx1Z2luMjIgb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICB3aGlsZSAoIXJvb3QyW2lzQ2xlYW5dKSB7XG4gICAgICAgIHJvb3QyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YWxrU3luYyhyb290Mik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgIGZvciAobGV0IHN1YlJvb3Qgb2Ygcm9vdDIubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMub3B0cykpIHtcbiAgICAgICAgd2Fybk9uY2UkMShcbiAgICAgICAgICBcIldpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbiAgdmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMikge1xuICAgIGZvciAobGV0IFtwbHVnaW4yMiwgdmlzaXRvcl0gb2YgdmlzaXRvcnMpIHtcbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgIGxldCBwcm9taXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZTIsIHRoaXMuaGVscGVycyk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMi5wcm94eU9mKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZpc2l0VGljayhzdGFjaykge1xuICAgIGxldCB2aXNpdDIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgeyBub2RlOiBub2RlMiwgdmlzaXRvcnMgfSA9IHZpc2l0MjtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmlzaXRvcnMubGVuZ3RoID4gMCAmJiB2aXNpdDIudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSA9IHZpc2l0b3JzW3Zpc2l0Mi52aXNpdG9ySW5kZXhdO1xuICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCArPSAxO1xuICAgICAgaWYgKHZpc2l0Mi52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSBbXTtcbiAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmlzaXRvcihub2RlMi50b1Byb3h5KCksIHRoaXMuaGVscGVycyk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aXNpdDIuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgIGxldCBpdGVyYXRvciA9IHZpc2l0Mi5pdGVyYXRvcjtcbiAgICAgIGxldCBjaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCA9IG5vZGUyLm5vZGVzW25vZGUyLmluZGV4ZXNbaXRlcmF0b3JdXSkge1xuICAgICAgICBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB7XG4gICAgICAgICAgY2hpbGRbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayhjaGlsZCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmlzaXQyLml0ZXJhdG9yID0gMDtcbiAgICAgIGRlbGV0ZSBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICB9XG4gICAgbGV0IGV2ZW50cyA9IHZpc2l0Mi5ldmVudHM7XG4gICAgd2hpbGUgKHZpc2l0Mi5ldmVudEluZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzW3Zpc2l0Mi5ldmVudEluZGV4XTtcbiAgICAgIHZpc2l0Mi5ldmVudEluZGV4ICs9IDE7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgdmlzaXQyLml0ZXJhdG9yID0gbm9kZTIuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cbiAgd2Fsa1N5bmMobm9kZTIpIHtcbiAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgbGV0IGV2ZW50cyA9IGdldEV2ZW50cyhub2RlMik7XG4gICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgIG5vZGUyLmVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB0aGlzLndhbGtTeW5jKGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBpZiAodmlzaXRvcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyLnRvUHJveHkoKSkpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50O1xuICB9XG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY3NzO1xuICB9XG4gIGdldCBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXM7XG4gIH1cbiAgZ2V0IG9wdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gIH1cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICB9XG4gIGdldCByb290KCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290O1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJMYXp5UmVzdWx0XCI7XG4gIH1cbn07XG5MYXp5UmVzdWx0JDIucmVnaXN0ZXJQb3N0Y3NzID0gKGRlcGVuZGFudCkgPT4ge1xuICBwb3N0Y3NzJDIgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGxhenlSZXN1bHQgPSBMYXp5UmVzdWx0JDI7XG5MYXp5UmVzdWx0JDIuZGVmYXVsdCA9IExhenlSZXN1bHQkMjtcblJvb3QkMy5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyKTtcbkRvY3VtZW50JDIucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMik7XG5sZXQgTWFwR2VuZXJhdG9yMjIgPSBtYXBHZW5lcmF0b3I7XG5sZXQgc3RyaW5naWZ5JDEgPSBzdHJpbmdpZnlfMTtcbmxldCB3YXJuT25jZTIyID0gd2Fybk9uY2UkMjtcbmxldCBwYXJzZSQxID0gcGFyc2VfMTtcbmNvbnN0IFJlc3VsdCQxID0gcmVzdWx0O1xubGV0IE5vV29ya1Jlc3VsdCQxID0gY2xhc3MgTm9Xb3JrUmVzdWx0MiB7XG4gIGNvbnN0cnVjdG9yKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgIGNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgIHRoaXMuX2NzcyA9IGNzcztcbiAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgbGV0IHJvb3QyO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkkMTtcbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMSh0aGlzLl9wcm9jZXNzb3IsIHJvb3QyLCB0aGlzLl9vcHRzKTtcbiAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3M7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc3VsdCwgXCJyb290XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucm9vdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbWFwID0gbmV3IE1hcEdlbmVyYXRvcjIyKHN0ciwgcm9vdDIsIHRoaXMuX29wdHMsIGNzcyk7XG4gICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICBsZXQgW2dlbmVyYXRlZENTUywgZ2VuZXJhdGVkTWFwXSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgICAgaWYgKGdlbmVyYXRlZENTUykge1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1M7XG4gICAgICB9XG4gICAgICBpZiAoZ2VuZXJhdGVkTWFwKSB7XG4gICAgICAgIHRoaXMucmVzdWx0Lm1hcCA9IGdlbmVyYXRlZE1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXN1bHQuY3NzID0gbWFwLmNzcztcbiAgICB9XG4gIH1cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgfVxuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgfVxuICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gIH1cbiAgc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMuX29wdHMpKSB7XG4gICAgICAgIHdhcm5PbmNlMjIoXG4gICAgICAgICAgXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NzcztcbiAgfVxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IG9wdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gIH1cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICB9XG4gIGdldCByb290KCkge1xuICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9XG4gICAgbGV0IHJvb3QyO1xuICAgIGxldCBwYXJzZXIyID0gcGFyc2UkMTtcbiAgICB0cnkge1xuICAgICAgcm9vdDIgPSBwYXJzZXIyKHRoaXMuX2NzcywgdGhpcy5fb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSByb290MjtcbiAgICAgIHJldHVybiByb290MjtcbiAgICB9XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIk5vV29ya1Jlc3VsdFwiO1xuICB9XG59O1xudmFyIG5vV29ya1Jlc3VsdCA9IE5vV29ya1Jlc3VsdCQxO1xuTm9Xb3JrUmVzdWx0JDEuZGVmYXVsdCA9IE5vV29ya1Jlc3VsdCQxO1xubGV0IE5vV29ya1Jlc3VsdDIyID0gbm9Xb3JrUmVzdWx0O1xubGV0IExhenlSZXN1bHQkMSA9IGxhenlSZXN1bHQ7XG5sZXQgRG9jdW1lbnQkMSA9IGRvY3VtZW50JDE7XG5sZXQgUm9vdCQyID0gcm9vdDtcbmxldCBQcm9jZXNzb3IkMSA9IGNsYXNzIFByb2Nlc3NvcjIge1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zID0gW10pIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcIjguNC4zOFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpO1xuICB9XG4gIG5vcm1hbGl6ZShwbHVnaW5zKSB7XG4gICAgbGV0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpMiBvZiBwbHVnaW5zKSB7XG4gICAgICBpZiAoaTIucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICBpMiA9IGkyKCk7XG4gICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgaTIgPSBpMi5wb3N0Y3NzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KGkyLnBsdWdpbnMpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpMi5wbHVnaW5zKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIGkyLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIChpMi5wYXJzZSB8fCBpMi5zdHJpbmdpZnkpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlBvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSBvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCBpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaTIgKyBcIiBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpblwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cbiAgcHJvY2Vzcyhjc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5wbHVnaW5zLmxlbmd0aCAmJiAhb3B0cy5wYXJzZXIgJiYgIW9wdHMuc3RyaW5naWZpZXIgJiYgIW9wdHMuc3ludGF4KSB7XG4gICAgICByZXR1cm4gbmV3IE5vV29ya1Jlc3VsdDIyKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgTGF6eVJlc3VsdCQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgfVxuICB9XG4gIHVzZShwbHVnaW4yMikge1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW3BsdWdpbjIyXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIHByb2Nlc3NvciA9IFByb2Nlc3NvciQxO1xuUHJvY2Vzc29yJDEuZGVmYXVsdCA9IFByb2Nlc3NvciQxO1xuUm9vdCQyLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxKTtcbkRvY3VtZW50JDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEpO1xubGV0IERlY2xhcmF0aW9uJDEgPSBkZWNsYXJhdGlvbjtcbmxldCBQcmV2aW91c01hcDIyID0gcHJldmlvdXNNYXA7XG5sZXQgQ29tbWVudCQxID0gY29tbWVudDtcbmxldCBBdFJ1bGUkMSA9IGF0UnVsZTtcbmxldCBJbnB1dCQxID0gaW5wdXQ7XG5sZXQgUm9vdCQxID0gcm9vdDtcbmxldCBSdWxlJDEgPSBydWxlO1xuZnVuY3Rpb24gZnJvbUpTT04kMShqc29uLCBpbnB1dHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcCgobjIpID0+IGZyb21KU09OJDEobjIpKTtcbiAgbGV0IHsgaW5wdXRzOiBvd25JbnB1dHMsIC4uLmRlZmF1bHRzIH0gPSBqc29uO1xuICBpZiAob3duSW5wdXRzKSB7XG4gICAgaW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQyIG9mIG93bklucHV0cykge1xuICAgICAgbGV0IGlucHV0SHlkcmF0ZWQgPSB7IC4uLmlucHV0MiwgX19wcm90b19fOiBJbnB1dCQxLnByb3RvdHlwZSB9O1xuICAgICAgaWYgKGlucHV0SHlkcmF0ZWQubWFwKSB7XG4gICAgICAgIGlucHV0SHlkcmF0ZWQubWFwID0ge1xuICAgICAgICAgIC4uLmlucHV0SHlkcmF0ZWQubWFwLFxuICAgICAgICAgIF9fcHJvdG9fXzogUHJldmlvdXNNYXAyMi5wcm90b3R5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKGlucHV0SHlkcmF0ZWQpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICBkZWZhdWx0cy5ub2RlcyA9IGpzb24ubm9kZXMubWFwKChuMikgPT4gZnJvbUpTT04kMShuMiwgaW5wdXRzKSk7XG4gIH1cbiAgaWYgKGRlZmF1bHRzLnNvdXJjZSkge1xuICAgIGxldCB7IGlucHV0SWQsIC4uLnNvdXJjZSB9ID0gZGVmYXVsdHMuc291cmNlO1xuICAgIGRlZmF1bHRzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICBpZiAoaW5wdXRJZCAhPSBudWxsKSB7XG4gICAgICBkZWZhdWx0cy5zb3VyY2UuaW5wdXQgPSBpbnB1dHNbaW5wdXRJZF07XG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJvb3RcIikge1xuICAgIHJldHVybiBuZXcgUm9vdCQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImRlY2xcIikge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24kMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICByZXR1cm4gbmV3IENvbW1lbnQkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgIHJldHVybiBuZXcgQXRSdWxlJDEoZGVmYXVsdHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gIH1cbn1cbnZhciBmcm9tSlNPTl8xID0gZnJvbUpTT04kMTtcbmZyb21KU09OJDEuZGVmYXVsdCA9IGZyb21KU09OJDE7XG5sZXQgQ3NzU3ludGF4RXJyb3IyMiA9IGNzc1N5bnRheEVycm9yO1xubGV0IERlY2xhcmF0aW9uMjIgPSBkZWNsYXJhdGlvbjtcbmxldCBMYXp5UmVzdWx0MjIgPSBsYXp5UmVzdWx0O1xubGV0IENvbnRhaW5lcjIyID0gY29udGFpbmVyO1xubGV0IFByb2Nlc3NvcjIyID0gcHJvY2Vzc29yO1xubGV0IHN0cmluZ2lmeSA9IHN0cmluZ2lmeV8xO1xubGV0IGZyb21KU09OID0gZnJvbUpTT05fMTtcbmxldCBEb2N1bWVudDIyMiA9IGRvY3VtZW50JDE7XG5sZXQgV2FybmluZzIyID0gd2FybmluZztcbmxldCBDb21tZW50MjIgPSBjb21tZW50O1xubGV0IEF0UnVsZTIyID0gYXRSdWxlO1xubGV0IFJlc3VsdDIyID0gcmVzdWx0O1xubGV0IElucHV0MjIgPSBpbnB1dDtcbmxldCBwYXJzZSA9IHBhcnNlXzE7XG5sZXQgbGlzdCA9IGxpc3RfMTtcbmxldCBSdWxlMjIgPSBydWxlO1xubGV0IFJvb3QyMiA9IHJvb3Q7XG5sZXQgTm9kZTIyID0gbm9kZTtcbmZ1bmN0aW9uIHBvc3Rjc3MoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICB9XG4gIHJldHVybiBuZXcgUHJvY2Vzc29yMjIocGx1Z2lucyk7XG59XG5wb3N0Y3NzLnBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbjIobmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgbGV0IHdhcm5pbmdQcmludGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNyZWF0b3IoLi4uYXJncykge1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiAhd2FybmluZ1ByaW50ZWQpIHtcbiAgICAgIHdhcm5pbmdQcmludGVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgbmFtZSArIFwiOiBwb3N0Y3NzLnBsdWdpbiB3YXMgZGVwcmVjYXRlZC4gTWlncmF0aW9uIGd1aWRlOlxcbmh0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uXCJcbiAgICAgICk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTEFORyAmJiBwcm9jZXNzLmVudi5MQU5HLnN0YXJ0c1dpdGgoXCJjblwiKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgbmFtZSArIFwiOiDph4zpnaIgcG9zdGNzcy5wbHVnaW4g6KKr5byD55SoLiDov4Hnp7vmjIfljZc6XFxuaHR0cHM6Ly93d3cudzNjdGVjaC5jb20vdG9waWMvMjIyNlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0cmFuc2Zvcm1lciA9IGluaXRpYWxpemVyKC4uLmFyZ3MpO1xuICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NQbHVnaW4gPSBuYW1lO1xuICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcjIyKCkudmVyc2lvbjtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gIH1cbiAgbGV0IGNhY2hlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgXCJwb3N0Y3NzXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoIWNhY2hlKSBjYWNoZSA9IGNyZWF0b3IoKTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0pO1xuICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbihjc3MsIHByb2Nlc3NPcHRzLCBwbHVnaW5PcHRzKSB7XG4gICAgcmV0dXJuIHBvc3Rjc3MoW2NyZWF0b3IocGx1Z2luT3B0cyldKS5wcm9jZXNzKGNzcywgcHJvY2Vzc09wdHMpO1xuICB9O1xuICByZXR1cm4gY3JlYXRvcjtcbn07XG5wb3N0Y3NzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbnBvc3Rjc3MucGFyc2UgPSBwYXJzZTtcbnBvc3Rjc3MuZnJvbUpTT04gPSBmcm9tSlNPTjtcbnBvc3Rjc3MubGlzdCA9IGxpc3Q7XG5wb3N0Y3NzLmNvbW1lbnQgPSAoZGVmYXVsdHMpID0+IG5ldyBDb21tZW50MjIoZGVmYXVsdHMpO1xucG9zdGNzcy5hdFJ1bGUgPSAoZGVmYXVsdHMpID0+IG5ldyBBdFJ1bGUyMihkZWZhdWx0cyk7XG5wb3N0Y3NzLmRlY2wgPSAoZGVmYXVsdHMpID0+IG5ldyBEZWNsYXJhdGlvbjIyKGRlZmF1bHRzKTtcbnBvc3Rjc3MucnVsZSA9IChkZWZhdWx0cykgPT4gbmV3IFJ1bGUyMihkZWZhdWx0cyk7XG5wb3N0Y3NzLnJvb3QgPSAoZGVmYXVsdHMpID0+IG5ldyBSb290MjIoZGVmYXVsdHMpO1xucG9zdGNzcy5kb2N1bWVudCA9IChkZWZhdWx0cykgPT4gbmV3IERvY3VtZW50MjIyKGRlZmF1bHRzKTtcbnBvc3Rjc3MuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIyO1xucG9zdGNzcy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMjI7XG5wb3N0Y3NzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIyO1xucG9zdGNzcy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyMjtcbnBvc3Rjc3MuRG9jdW1lbnQgPSBEb2N1bWVudDIyMjtcbnBvc3Rjc3MuQ29tbWVudCA9IENvbW1lbnQyMjtcbnBvc3Rjc3MuV2FybmluZyA9IFdhcm5pbmcyMjtcbnBvc3Rjc3MuQXRSdWxlID0gQXRSdWxlMjI7XG5wb3N0Y3NzLlJlc3VsdCA9IFJlc3VsdDIyO1xucG9zdGNzcy5JbnB1dCA9IElucHV0MjI7XG5wb3N0Y3NzLlJ1bGUgPSBSdWxlMjI7XG5wb3N0Y3NzLlJvb3QgPSBSb290MjI7XG5wb3N0Y3NzLk5vZGUgPSBOb2RlMjI7XG5MYXp5UmVzdWx0MjIucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MpO1xudmFyIHBvc3Rjc3NfMSA9IHBvc3Rjc3M7XG5wb3N0Y3NzLmRlZmF1bHQgPSBwb3N0Y3NzO1xuY29uc3QgcG9zdGNzcyQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBvc3Rjc3NfMSk7XG5wb3N0Y3NzJDEuc3RyaW5naWZ5O1xucG9zdGNzcyQxLmZyb21KU09OO1xucG9zdGNzcyQxLnBsdWdpbjtcbnBvc3Rjc3MkMS5wYXJzZTtcbnBvc3Rjc3MkMS5saXN0O1xucG9zdGNzcyQxLmRvY3VtZW50O1xucG9zdGNzcyQxLmNvbW1lbnQ7XG5wb3N0Y3NzJDEuYXRSdWxlO1xucG9zdGNzcyQxLnJ1bGU7XG5wb3N0Y3NzJDEuZGVjbDtcbnBvc3Rjc3MkMS5yb290O1xucG9zdGNzcyQxLkNzc1N5bnRheEVycm9yO1xucG9zdGNzcyQxLkRlY2xhcmF0aW9uO1xucG9zdGNzcyQxLkNvbnRhaW5lcjtcbnBvc3Rjc3MkMS5Qcm9jZXNzb3I7XG5wb3N0Y3NzJDEuRG9jdW1lbnQ7XG5wb3N0Y3NzJDEuQ29tbWVudDtcbnBvc3Rjc3MkMS5XYXJuaW5nO1xucG9zdGNzcyQxLkF0UnVsZTtcbnBvc3Rjc3MkMS5SZXN1bHQ7XG5wb3N0Y3NzJDEuSW5wdXQ7XG5wb3N0Y3NzJDEuUnVsZTtcbnBvc3Rjc3MkMS5Sb290O1xucG9zdGNzcyQxLk5vZGU7XG5jbGFzcyBCYXNlUlJOb2RlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdHJ1Y3RvciguLi5fYXJncykge1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50RWxlbWVudFwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcInBhcmVudE5vZGVcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJvd25lckRvY3VtZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiZmlyc3RDaGlsZFwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcImxhc3RDaGlsZFwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcInByZXZpb3VzU2libGluZ1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5leHRTaWJsaW5nXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiRUxFTUVOVF9OT0RFXCIsIDEpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiVEVYVF9OT0RFXCIsIDMpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibm9kZVR5cGVcIik7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJub2RlTmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIlJSTm9kZVR5cGVcIik7XG4gIH1cbiAgZ2V0IGNoaWxkTm9kZXMoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlczIgPSBbXTtcbiAgICBsZXQgY2hpbGRJdGVyYXRvciA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRJdGVyYXRvcikge1xuICAgICAgY2hpbGROb2RlczIucHVzaChjaGlsZEl0ZXJhdG9yKTtcbiAgICAgIGNoaWxkSXRlcmF0b3IgPSBjaGlsZEl0ZXJhdG9yLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGROb2RlczI7XG4gIH1cbiAgY29udGFpbnMobm9kZTIpIHtcbiAgICBpZiAoIShub2RlMiBpbnN0YW5jZW9mIEJhc2VSUk5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSBpZiAobm9kZTIub3duZXJEb2N1bWVudCAhPT0gdGhpcy5vd25lckRvY3VtZW50KSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSBpZiAobm9kZTIgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgIHdoaWxlIChub2RlMi5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAobm9kZTIucGFyZW50Tm9kZSA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgICBub2RlMiA9IG5vZGUyLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGFwcGVuZENoaWxkKF9uZXdDaGlsZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSUkRvbUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZENoaWxkJyBvbiAnUlJOb2RlJzogVGhpcyBSUk5vZGUgdHlwZSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgbWV0aG9kLmBcbiAgICApO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaW5zZXJ0QmVmb3JlKF9uZXdDaGlsZCwgX3JlZkNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnaW5zZXJ0QmVmb3JlJyBvbiAnUlJOb2RlJzogVGhpcyBSUk5vZGUgdHlwZSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgbWV0aG9kLmBcbiAgICApO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVtb3ZlQ2hpbGQoX25vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdyZW1vdmVDaGlsZCcgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5gXG4gICAgKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJSUk5vZGVcIjtcbiAgfVxufVxuY29uc3QgdGVzdGFibGVBY2Nlc3NvcnMgPSB7XG4gIE5vZGU6IFtcImNoaWxkTm9kZXNcIiwgXCJwYXJlbnROb2RlXCIsIFwicGFyZW50RWxlbWVudFwiLCBcInRleHRDb250ZW50XCJdLFxuICBTaGFkb3dSb290OiBbXCJob3N0XCIsIFwic3R5bGVTaGVldHNcIl0sXG4gIEVsZW1lbnQ6IFtcInNoYWRvd1Jvb3RcIiwgXCJxdWVyeVNlbGVjdG9yXCIsIFwicXVlcnlTZWxlY3RvckFsbFwiXSxcbiAgTXV0YXRpb25PYnNlcnZlcjogW11cbn07XG5jb25zdCB0ZXN0YWJsZU1ldGhvZHMgPSB7XG4gIE5vZGU6IFtcImNvbnRhaW5zXCIsIFwiZ2V0Um9vdE5vZGVcIl0sXG4gIFNoYWRvd1Jvb3Q6IFtcImdldFNlbGVjdGlvblwiXSxcbiAgRWxlbWVudDogW10sXG4gIE11dGF0aW9uT2JzZXJ2ZXI6IFtcImNvbnN0cnVjdG9yXCJdXG59O1xuY29uc3QgdW50YWludGVkQmFzZVByb3RvdHlwZSA9IHt9O1xuY29uc3QgaXNBbmd1bGFyWm9uZVByZXNlbnQgPSAoKSA9PiB7XG4gIHJldHVybiAhIWdsb2JhbFRoaXMuWm9uZTtcbn07XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KSB7XG4gIGlmICh1bnRhaW50ZWRCYXNlUHJvdG90eXBlW2tleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XTtcbiAgY29uc3QgZGVmYXVsdE9iaiA9IGdsb2JhbFRoaXNba2V5XTtcbiAgY29uc3QgZGVmYXVsdFByb3RvdHlwZSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICBjb25zdCBhY2Nlc3Nvck5hbWVzID0ga2V5IGluIHRlc3RhYmxlQWNjZXNzb3JzID8gdGVzdGFibGVBY2Nlc3NvcnNba2V5XSA6IHZvaWQgMDtcbiAgY29uc3QgaXNVbnRhaW50ZWRBY2Nlc3NvcnMgPSBCb29sZWFuKFxuICAgIGFjY2Vzc29yTmFtZXMgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgYWNjZXNzb3JOYW1lcy5ldmVyeShcbiAgICAgIChhY2Nlc3NvcikgPT4ge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICAgICAgKF9iID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdFByb3RvdHlwZSwgYWNjZXNzb3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKVxuICApO1xuICBjb25zdCBtZXRob2ROYW1lcyA9IGtleSBpbiB0ZXN0YWJsZU1ldGhvZHMgPyB0ZXN0YWJsZU1ldGhvZHNba2V5XSA6IHZvaWQgMDtcbiAgY29uc3QgaXNVbnRhaW50ZWRNZXRob2RzID0gQm9vbGVhbihcbiAgICBtZXRob2ROYW1lcyAmJiBtZXRob2ROYW1lcy5ldmVyeShcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgICAgKG1ldGhvZCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiICYmICgoX2EyID0gZGVmYXVsdFByb3RvdHlwZVttZXRob2RdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGlmIChpc1VudGFpbnRlZEFjY2Vzc29ycyAmJiBpc1VudGFpbnRlZE1ldGhvZHMgJiYgIWlzQW5ndWxhclpvbmVQcmVzZW50KCkpIHtcbiAgICB1bnRhaW50ZWRCYXNlUHJvdG90eXBlW2tleV0gPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBpZnJhbWVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWVFbCk7XG4gICAgY29uc3Qgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICBpZiAoIXdpbikgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIGNvbnN0IHVudGFpbnRlZE9iamVjdCA9IHdpbltrZXldLnByb3RvdHlwZTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZUVsKTtcbiAgICBpZiAoIXVudGFpbnRlZE9iamVjdCkgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IHVudGFpbnRlZE9iamVjdDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gIH1cbn1cbmNvbnN0IHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZEFjY2Vzc29yKGtleSwgaW5zdGFuY2UsIGFjY2Vzc29yKSB7XG4gIHZhciBfYTI7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7a2V5fS4ke1N0cmluZyhhY2Nlc3Nvcil9YDtcbiAgaWYgKHVudGFpbnRlZEFjY2Vzc29yQ2FjaGVbY2FjaGVLZXldKVxuICAgIHJldHVybiB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XS5jYWxsKFxuICAgICAgaW5zdGFuY2VcbiAgICApO1xuICBjb25zdCB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KTtcbiAgY29uc3QgdW50YWludGVkQWNjZXNzb3IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICB1bnRhaW50ZWRQcm90b3R5cGUsXG4gICAgYWNjZXNzb3JcbiAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQ7XG4gIGlmICghdW50YWludGVkQWNjZXNzb3IpIHJldHVybiBpbnN0YW5jZVthY2Nlc3Nvcl07XG4gIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGVbY2FjaGVLZXldID0gdW50YWludGVkQWNjZXNzb3I7XG4gIHJldHVybiB1bnRhaW50ZWRBY2Nlc3Nvci5jYWxsKGluc3RhbmNlKTtcbn1cbmNvbnN0IHVudGFpbnRlZE1ldGhvZENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRNZXRob2Qoa2V5LCBpbnN0YW5jZSwgbWV0aG9kKSB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7a2V5fS4ke1N0cmluZyhtZXRob2QpfWA7XG4gIGlmICh1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XS5iaW5kKFxuICAgICAgaW5zdGFuY2VcbiAgICApO1xuICBjb25zdCB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KTtcbiAgY29uc3QgdW50YWludGVkTWV0aG9kID0gdW50YWludGVkUHJvdG90eXBlW21ldGhvZF07XG4gIGlmICh0eXBlb2YgdW50YWludGVkTWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBpbnN0YW5jZVttZXRob2RdO1xuICB1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRNZXRob2Q7XG4gIHJldHVybiB1bnRhaW50ZWRNZXRob2QuYmluZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjaGlsZE5vZGVzKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwiY2hpbGROb2Rlc1wiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnROb2RlXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50RWxlbWVudChuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInBhcmVudEVsZW1lbnRcIik7XG59XG5mdW5jdGlvbiB0ZXh0Q29udGVudChuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInRleHRDb250ZW50XCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnMobjIsIG90aGVyKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QoXCJOb2RlXCIsIG4yLCBcImNvbnRhaW5zXCIpKG90aGVyKTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QoXCJOb2RlXCIsIG4yLCBcImdldFJvb3ROb2RlXCIpKCk7XG59XG5mdW5jdGlvbiBob3N0KG4yKSB7XG4gIGlmICghbjIgfHwgIShcImhvc3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJTaGFkb3dSb290XCIsIG4yLCBcImhvc3RcIik7XG59XG5mdW5jdGlvbiBzdHlsZVNoZWV0cyhuMikge1xuICByZXR1cm4gbjIuc3R5bGVTaGVldHM7XG59XG5mdW5jdGlvbiBzaGFkb3dSb290KG4yKSB7XG4gIGlmICghbjIgfHwgIShcInNoYWRvd1Jvb3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInNoYWRvd1Jvb3RcIik7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yKG4yLCBzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKG4yLCBzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yQWxsXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyQ3RvcigpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZFByb3RvdHlwZShcIk11dGF0aW9uT2JzZXJ2ZXJcIikuY29uc3RydWN0b3I7XG59XG5jb25zdCBpbmRleCA9IHtcbiAgY2hpbGROb2RlcyxcbiAgcGFyZW50Tm9kZSxcbiAgcGFyZW50RWxlbWVudCxcbiAgdGV4dENvbnRlbnQsXG4gIGNvbnRhaW5zLFxuICBnZXRSb290Tm9kZSxcbiAgaG9zdCxcbiAgc3R5bGVTaGVldHMsXG4gIHNoYWRvd1Jvb3QsXG4gIHF1ZXJ5U2VsZWN0b3IsXG4gIHF1ZXJ5U2VsZWN0b3JBbGwsXG4gIG11dGF0aW9uT2JzZXJ2ZXI6IG11dGF0aW9uT2JzZXJ2ZXJDdG9yXG59O1xuZnVuY3Rpb24gb24odHlwZSwgZm4sIHRhcmdldCA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfTtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xufVxuY29uc3QgREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HID0gXCJQbGVhc2Ugc3RvcCBpbXBvcnQgbWlycm9yIGRpcmVjdGx5LiBJbnN0ZWFkIG9mIHRoYXQsXFxyXFxubm93IHlvdSBjYW4gdXNlIHJlcGxheWVyLmdldE1pcnJvcigpIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIG9mIGEgcmVwbGF5ZXIsXFxyXFxub3IgeW91IGNhbiB1c2UgcmVjb3JkLm1pcnJvciB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBkdXJpbmcgcmVjb3JkaW5nLlwiO1xubGV0IF9taXJyb3IgPSB7XG4gIG1hcDoge30sXG4gIGdldElkKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICByZXR1cm4gLTE7XG4gIH0sXG4gIGdldE5vZGUoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZW1vdmVOb2RlRnJvbU1hcCgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gIH0sXG4gIGhhcygpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICByZXNldCgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gIH1cbn07XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuUHJveHkgJiYgd2luZG93LlJlZmxlY3QpIHtcbiAgX21pcnJvciA9IG5ldyBQcm94eShfbWlycm9yLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChwcm9wID09PSBcIm1hcFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSwgcmVtYWluaW5nKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBkLCBpc1Jldm9rZWQsIHdpbiA9IHdpbmRvdykge1xuICBjb25zdCBvcmlnaW5hbCA9IHdpbi5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB0YXJnZXQsXG4gICAga2V5LFxuICAgIGlzUmV2b2tlZCA/IGQgOiB7XG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAob3JpZ2luYWwgJiYgb3JpZ2luYWwuc2V0KSB7XG4gICAgICAgICAgb3JpZ2luYWwuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApO1xuICByZXR1cm4gKCkgPT4gaG9va1NldHRlcih0YXJnZXQsIGtleSwgb3JpZ2luYWwgfHwge30sIHRydWUpO1xufVxuZnVuY3Rpb24gcGF0Y2goc291cmNlLCBuYW1lLCByZXBsYWNlbWVudCkge1xuICB0cnkge1xuICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xuICAgIGNvbnN0IHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkLCB7XG4gICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XG4gICAgfTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5sZXQgbm93VGltZXN0YW1wID0gRGF0ZS5ub3c7XG5pZiAoIS8qIEBfX1BVUkVfXyAqLyAvWzEtOV1bMC05XXsxMn0vLnRlc3QoRGF0ZS5ub3coKS50b1N0cmluZygpKSkge1xuICBub3dUaW1lc3RhbXAgPSAoKSA9PiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcbiAgdmFyIF9hMiwgX2IsIF9jLCBfZDtcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA6IHdpbi5wYWdlWE9mZnNldCAhPT0gdm9pZCAwID8gd2luLnBhZ2VYT2Zmc2V0IDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IChkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5ib2R5KSAmJiAoKF9hMiA9IGluZGV4LnBhcmVudEVsZW1lbnQoZG9jLmJvZHkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNjcm9sbExlZnQpIHx8ICgoX2IgPSBkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2Nyb2xsTGVmdCkgfHwgMCxcbiAgICB0b3A6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wIDogd2luLnBhZ2VZT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVlPZmZzZXQgOiAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2MgPSBpbmRleC5wYXJlbnRFbGVtZW50KGRvYy5ib2R5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnNjcm9sbFRvcCkgfHwgKChfZCA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfZC5zY3JvbGxUb3ApIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd0hlaWdodCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XG4gIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUyKSB7XG4gIGlmICghbm9kZTIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbCA9IG5vZGUyLm5vZGVUeXBlID09PSBub2RlMi5FTEVNRU5UX05PREUgPyBub2RlMiA6IGluZGV4LnBhcmVudEVsZW1lbnQobm9kZTIpO1xuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBpc0Jsb2NrZWQobm9kZTIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XG4gIGlmICghbm9kZTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZWwgPSBjbG9zZXN0RWxlbWVudE9mTm9kZShub2RlMik7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoXCIuXCIgKyBibG9ja0NsYXNzKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgYmxvY2tDbGFzcywgY2hlY2tBbmNlc3RvcnMpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcbiAgICBpZiAoZWwubWF0Y2hlcyhibG9ja1NlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoYmxvY2tTZWxlY3RvcikgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZChuMiwgbWlycm9yMikge1xuICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNJZ25vcmVkKG4yLCBtaXJyb3IyLCBzbGltRE9NT3B0aW9ucykge1xuICBpZiAobjIudGFnTmFtZSA9PT0gXCJUSVRMRVwiICYmIHNsaW1ET01PcHRpb25zLmhlYWRUaXRsZU11dGF0aW9ucykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSA9PT0gSUdOT1JFRF9OT0RFO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LCBtaXJyb3IyKSB7XG4gIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgaWYgKCFtaXJyb3IyLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKHRhcmdldCk7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSB0YXJnZXQuRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBpc0FuY2VzdG9yUmVtb3ZlZChwYXJlbnQsIG1pcnJvcjIpO1xufVxuZnVuY3Rpb24gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkge1xuICByZXR1cm4gQm9vbGVhbihldmVudC5jaGFuZ2VkVG91Y2hlcyk7XG59XG5mdW5jdGlvbiBwb2x5ZmlsbCQxKHdpbiA9IHdpbmRvdykge1xuICBpZiAoXCJOb2RlTGlzdFwiIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIH1cbiAgaWYgKFwiRE9NVG9rZW5MaXN0XCIgaW4gd2luICYmICF3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB9XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRJZnJhbWUobjIsIG1pcnJvcjIpIHtcbiAgcmV0dXJuIEJvb2xlYW4objIubm9kZU5hbWUgPT09IFwiSUZSQU1FXCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKSk7XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4yLCBtaXJyb3IyKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIG4yLm5vZGVOYW1lID09PSBcIkxJTktcIiAmJiBuMi5ub2RlVHlwZSA9PT0gbjIuRUxFTUVOVF9OT0RFICYmIG4yLmdldEF0dHJpYnV0ZSAmJiBuMi5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09IFwic3R5bGVzaGVldFwiICYmIG1pcnJvcjIuZ2V0TWV0YShuMilcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc1NoYWRvd1Jvb3QobjIpIHtcbiAgaWYgKCFuMikgcmV0dXJuIGZhbHNlO1xuICBpZiAobjIgaW5zdGFuY2VvZiBCYXNlUlJOb2RlICYmIFwic2hhZG93Um9vdFwiIGluIG4yKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4objIuc2hhZG93Um9vdCk7XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4oaW5kZXguc2hhZG93Um9vdChuMikpO1xufVxuY2xhc3MgU3R5bGVTaGVldE1pcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZFwiLCAxKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3R5bGVJRE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkU3R5bGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgZ2V0SWQoc3R5bGVzaGVldCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlSURNYXAuZ2V0KHN0eWxlc2hlZXQpID8/IC0xO1xuICB9XG4gIGhhcyhzdHlsZXNoZWV0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5oYXMoc3R5bGVzaGVldCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIElmIHRoZSBzdHlsZXNoZWV0IGlzIGluIHRoZSBtaXJyb3IsIHJldHVybnMgdGhlIGlkIG9mIHRoZSBzdHlsZXNoZWV0LiBJZiBub3QsIHJldHVybiB0aGUgbmV3IGFzc2lnbmVkIGlkLlxuICAgKi9cbiAgYWRkKHN0eWxlc2hlZXQsIGlkKSB7XG4gICAgaWYgKHRoaXMuaGFzKHN0eWxlc2hlZXQpKSByZXR1cm4gdGhpcy5nZXRJZChzdHlsZXNoZWV0KTtcbiAgICBsZXQgbmV3SWQ7XG4gICAgaWYgKGlkID09PSB2b2lkIDApIHtcbiAgICAgIG5ld0lkID0gdGhpcy5pZCsrO1xuICAgIH0gZWxzZSBuZXdJZCA9IGlkO1xuICAgIHRoaXMuc3R5bGVJRE1hcC5zZXQoc3R5bGVzaGVldCwgbmV3SWQpO1xuICAgIHRoaXMuaWRTdHlsZU1hcC5zZXQobmV3SWQsIHN0eWxlc2hlZXQpO1xuICAgIHJldHVybiBuZXdJZDtcbiAgfVxuICBnZXRTdHlsZShpZCkge1xuICAgIHJldHVybiB0aGlzLmlkU3R5bGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc3R5bGVJRE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuaWRTdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5pZCA9IDE7XG4gIH1cbiAgZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZCsrO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KG4yKSB7XG4gIHZhciBfYTI7XG4gIGxldCBzaGFkb3dIb3N0ID0gbnVsbDtcbiAgaWYgKFwiZ2V0Um9vdE5vZGVcIiBpbiBuMiAmJiAoKF9hMiA9IGluZGV4LmdldFJvb3ROb2RlKG4yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5ub2RlVHlwZSkgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBpbmRleC5ob3N0KGluZGV4LmdldFJvb3ROb2RlKG4yKSkpXG4gICAgc2hhZG93SG9zdCA9IGluZGV4Lmhvc3QoaW5kZXguZ2V0Um9vdE5vZGUobjIpKTtcbiAgcmV0dXJuIHNoYWRvd0hvc3Q7XG59XG5mdW5jdGlvbiBnZXRSb290U2hhZG93SG9zdChuMikge1xuICBsZXQgcm9vdFNoYWRvd0hvc3QgPSBuMjtcbiAgbGV0IHNoYWRvd0hvc3Q7XG4gIHdoaWxlIChzaGFkb3dIb3N0ID0gZ2V0U2hhZG93SG9zdChyb290U2hhZG93SG9zdCkpXG4gICAgcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xuICByZXR1cm4gcm9vdFNoYWRvd0hvc3Q7XG59XG5mdW5jdGlvbiBzaGFkb3dIb3N0SW5Eb20objIpIHtcbiAgY29uc3QgZG9jID0gbjIub3duZXJEb2N1bWVudDtcbiAgaWYgKCFkb2MpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc2hhZG93SG9zdCA9IGdldFJvb3RTaGFkb3dIb3N0KG4yKTtcbiAgcmV0dXJuIGluZGV4LmNvbnRhaW5zKGRvYywgc2hhZG93SG9zdCk7XG59XG5mdW5jdGlvbiBpbkRvbShuMikge1xuICBjb25zdCBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaW5kZXguY29udGFpbnMoZG9jLCBuMikgfHwgc2hhZG93SG9zdEluRG9tKG4yKTtcbn1cbnZhciBFdmVudFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFdmVudFR5cGUyKSA9PiB7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRnVsbFNuYXBzaG90XCJdID0gMl0gPSBcIkZ1bGxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkN1c3RvbVwiXSA9IDVdID0gXCJDdXN0b21cIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xuICByZXR1cm4gRXZlbnRUeXBlMjtcbn0pKEV2ZW50VHlwZSB8fCB7fSk7XG52YXIgSW5jcmVtZW50YWxTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KShJbmNyZW1lbnRhbFNvdXJjZSB8fCB7fSk7XG52YXIgTW91c2VJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChNb3VzZUludGVyYWN0aW9uczIpID0+IHtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlVXBcIl0gPSAwXSA9IFwiTW91c2VVcFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VEb3duXCJdID0gMV0gPSBcIk1vdXNlRG93blwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNvbnRleHRNZW51XCJdID0gM10gPSBcIkNvbnRleHRNZW51XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJEYmxDbGlja1wiXSA9IDRdID0gXCJEYmxDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkJsdXJcIl0gPSA2XSA9IFwiQmx1clwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hTdGFydFwiXSA9IDddID0gXCJUb3VjaFN0YXJ0XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaEVuZFwiXSA9IDldID0gXCJUb3VjaEVuZFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hDYW5jZWxcIl0gPSAxMF0gPSBcIlRvdWNoQ2FuY2VsXCI7XG4gIHJldHVybiBNb3VzZUludGVyYWN0aW9uczI7XG59KShNb3VzZUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgUG9pbnRlclR5cGVzID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlclR5cGVzMikgPT4ge1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJNb3VzZVwiXSA9IDBdID0gXCJNb3VzZVwiO1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJQZW5cIl0gPSAxXSA9IFwiUGVuXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlRvdWNoXCJdID0gMl0gPSBcIlRvdWNoXCI7XG4gIHJldHVybiBQb2ludGVyVHlwZXMyO1xufSkoUG9pbnRlclR5cGVzIHx8IHt9KTtcbnZhciBDYW52YXNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovICgoQ2FudmFzQ29udGV4dDIpID0+IHtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCIyRFwiXSA9IDBdID0gXCIyRFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0wyXCJdID0gMl0gPSBcIldlYkdMMlwiO1xuICByZXR1cm4gQ2FudmFzQ29udGV4dDI7XG59KShDYW52YXNDb250ZXh0IHx8IHt9KTtcbnZhciBNZWRpYUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1lZGlhSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGxheVwiXSA9IDBdID0gXCJQbGF5XCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQYXVzZVwiXSA9IDFdID0gXCJQYXVzZVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiU2Vla2VkXCJdID0gMl0gPSBcIlNlZWtlZFwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiVm9sdW1lQ2hhbmdlXCJdID0gM10gPSBcIlZvbHVtZUNoYW5nZVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUmF0ZUNoYW5nZVwiXSA9IDRdID0gXCJSYXRlQ2hhbmdlXCI7XG4gIHJldHVybiBNZWRpYUludGVyYWN0aW9uczI7XG59KShNZWRpYUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgTm9kZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlVHlwZTIpID0+IHtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICByZXR1cm4gTm9kZVR5cGUyO1xufSkoTm9kZVR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNOb2RlSW5MaW5rZWRMaXN0KG4yKSB7XG4gIHJldHVybiBcIl9fbG5cIiBpbiBuMjtcbn1cbmNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGVuZ3RoXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWFkXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YWlsXCIsIG51bGwpO1xuICB9XG4gIGdldChwb3NpdGlvbikge1xuICAgIGlmIChwb3NpdGlvbiA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpb24gb3V0c2lkZSBvZiBsaXN0IHJhbmdlXCIpO1xuICAgIH1cbiAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICBmb3IgKGxldCBpbmRleDIgPSAwOyBpbmRleDIgPCBwb3NpdGlvbjsgaW5kZXgyKyspIHtcbiAgICAgIGN1cnJlbnQgPSAoY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudC5uZXh0KSB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBhZGROb2RlKG4yKSB7XG4gICAgY29uc3Qgbm9kZTIgPSB7XG4gICAgICB2YWx1ZTogbjIsXG4gICAgICBwcmV2aW91czogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIG4yLl9fbG4gPSBub2RlMjtcbiAgICBpZiAobjIucHJldmlvdXNTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuMi5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dDtcbiAgICAgIG5vZGUyLm5leHQgPSBjdXJyZW50O1xuICAgICAgbm9kZTIucHJldmlvdXMgPSBuMi5wcmV2aW91c1NpYmxpbmcuX19sbjtcbiAgICAgIG4yLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQgPSBub2RlMjtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSBub2RlMjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG4yLm5leHRTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuMi5uZXh0U2libGluZykgJiYgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cykge1xuICAgICAgY29uc3QgY3VycmVudCA9IG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XG4gICAgICBub2RlMi5wcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICBub2RlMi5uZXh0ID0gbjIubmV4dFNpYmxpbmcuX19sbjtcbiAgICAgIG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXMgPSBub2RlMjtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQubmV4dCA9IG5vZGUyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgfVxuICAgICAgbm9kZTIubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgIHRoaXMuaGVhZCA9IG5vZGUyO1xuICAgIH1cbiAgICBpZiAobm9kZTIubmV4dCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy50YWlsID0gbm9kZTI7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoKys7XG4gIH1cbiAgcmVtb3ZlTm9kZShuMikge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBuMi5fX2xuO1xuICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xuICAgICAgdGhpcy5oZWFkID0gY3VycmVudC5uZXh0O1xuICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgaWYgKGN1cnJlbnQubmV4dCkge1xuICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWlsID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4yLl9fbG4pIHtcbiAgICAgIGRlbGV0ZSBuMi5fX2xuO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aC0tO1xuICB9XG59XG5jb25zdCBtb3ZlS2V5ID0gKGlkLCBwYXJlbnRJZCkgPT4gYCR7aWR9QCR7cGFyZW50SWR9YDtcbmNsYXNzIE11dGF0aW9uQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZyb3plblwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvY2tlZFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRleHRzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXR0cmlidXRlc1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF0dHJpYnV0ZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbW92ZXNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXBSZW1vdmVzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibW92ZWRNYXBcIiwge30pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZGRlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibW92ZWRTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRyb3BwZWRTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbW92ZXNTdWJUcmVlQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsb2NrQ2xhc3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsb2NrU2VsZWN0b3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tUZXh0Q2xhc3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tUZXh0U2VsZWN0b3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlubGluZVN0eWxlc2hlZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tJbnB1dE9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tUZXh0Rm5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tJbnB1dEZuXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJrZWVwSWZyYW1lU3JjRm5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY29yZENhbnZhc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5saW5lSW1hZ2VzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzbGltRE9NT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGF0YVVSTE9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvY1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZnJhbWVNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2hhZG93RG9tTWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FudmFzTWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuYXR0YWNoZWREb2NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NNdXRhdGlvbnNcIiwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgbXV0YXRpb25zLmZvckVhY2godGhpcy5wcm9jZXNzTXV0YXRpb24pO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVtaXRcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZHMgPSBbXTtcbiAgICAgIGNvbnN0IGFkZGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IGFkZExpc3QgPSBuZXcgRG91YmxlTGlua2VkTGlzdCgpO1xuICAgICAgY29uc3QgZ2V0TmV4dElkID0gKG4yKSA9PiB7XG4gICAgICAgIGxldCBucyA9IG4yO1xuICAgICAgICBsZXQgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xuICAgICAgICB3aGlsZSAobmV4dElkID09PSBJR05PUkVEX05PREUpIHtcbiAgICAgICAgICBucyA9IG5zICYmIG5zLm5leHRTaWJsaW5nO1xuICAgICAgICAgIG5leHRJZCA9IG5zICYmIHRoaXMubWlycm9yLmdldElkKG5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dElkO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHB1c2hBZGQgPSAobjIpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgICAgIGlmICghcGFyZW50IHx8ICFpbkRvbShuMikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNzc0NhcHR1cmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChuMi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRUYWcgPSBwYXJlbnQudGFnTmFtZTtcbiAgICAgICAgICBpZiAocGFyZW50VGFnID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudFRhZyA9PT0gXCJTVFlMRVwiICYmIHRoaXMuYWRkZWRTZXQuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgIGNzc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QocGFyZW50KSA/IHRoaXMubWlycm9yLmdldElkKGdldFNoYWRvd0hvc3QobjIpKSA6IHRoaXMubWlycm9yLmdldElkKHBhcmVudCk7XG4gICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChuMik7XG4gICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTEgfHwgbmV4dElkID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBhZGRMaXN0LmFkZE5vZGUobjIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuID0gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwge1xuICAgICAgICAgIGRvYzogdGhpcy5kb2MsXG4gICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgICBibG9ja0NsYXNzOiB0aGlzLmJsb2NrQ2xhc3MsXG4gICAgICAgICAgYmxvY2tTZWxlY3RvcjogdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IHRoaXMubWFza1RleHRDbGFzcyxcbiAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgc2tpcENoaWxkOiB0cnVlLFxuICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiB0cnVlLFxuICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IHRoaXMuaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgbWFza1RleHRGbjogdGhpcy5tYXNrVGV4dEZuLFxuICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuLFxuICAgICAgICAgIHNsaW1ET01PcHRpb25zOiB0aGlzLnNsaW1ET01PcHRpb25zLFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiB0aGlzLmRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgIHJlY29yZENhbnZhczogdGhpcy5yZWNvcmRDYW52YXMsXG4gICAgICAgICAgaW5saW5lSW1hZ2VzOiB0aGlzLmlubGluZUltYWdlcyxcbiAgICAgICAgICBvblNlcmlhbGl6ZTogKGN1cnJlbnROKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkSWZyYW1lKGN1cnJlbnROLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShjdXJyZW50Tik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChjdXJyZW50TiwgdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50TlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobjIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KGluZGV4LnNoYWRvd1Jvb3QobjIpLCB0aGlzLmRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbklmcmFtZUxvYWQ6IChpZnJhbWUsIGNoaWxkU24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiAobGluaywgY2hpbGRTbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rLCBjaGlsZFNuKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNzc0NhcHR1cmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc24pIHtcbiAgICAgICAgICBhZGRzLnB1c2goe1xuICAgICAgICAgICAgcGFyZW50SWQsXG4gICAgICAgICAgICBuZXh0SWQsXG4gICAgICAgICAgICBub2RlOiBzblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZGVkSWRzLmFkZChzbi5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aGlsZSAodGhpcy5tYXBSZW1vdmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1pcnJvci5yZW1vdmVOb2RlRnJvbU1hcCh0aGlzLm1hcFJlbW92ZXMuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG4yIG9mIHRoaXMubW92ZWRTZXQpIHtcbiAgICAgICAgaWYgKGlzUGFyZW50UmVtb3ZlZCh0aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUsIG4yLCB0aGlzLm1pcnJvcikgJiYgIXRoaXMubW92ZWRTZXQuaGFzKGluZGV4LnBhcmVudE5vZGUobjIpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuMiBvZiB0aGlzLmFkZGVkU2V0KSB7XG4gICAgICAgIGlmICghaXNBbmNlc3RvckluU2V0KHRoaXMuZHJvcHBlZFNldCwgbjIpICYmICFpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzU3ViVHJlZUNhY2hlLCBuMiwgdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KHRoaXMubW92ZWRTZXQsIG4yKSkge1xuICAgICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHdoaWxlIChhZGRMaXN0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgbm9kZTIgPSBudWxsO1xuICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLm1pcnJvci5nZXRJZChpbmRleC5wYXJlbnROb2RlKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChjYW5kaWRhdGUudmFsdWUpO1xuICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEgJiYgbmV4dElkICE9PSAtMSkge1xuICAgICAgICAgICAgbm9kZTIgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgICBsZXQgdGFpbE5vZGUgPSBhZGRMaXN0LnRhaWw7XG4gICAgICAgICAgd2hpbGUgKHRhaWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBfbm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5wcmV2aW91cztcbiAgICAgICAgICAgIGlmIChfbm9kZSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKGluZGV4LnBhcmVudE5vZGUoX25vZGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKF9ub2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKG5leHRJZCA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBub2RlMiA9IF9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaGFuZGxlZE5vZGUgPSBfbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKHVuaGFuZGxlZE5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd0hvc3QgPSBpbmRleC5ob3N0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZDIgPSB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dIb3N0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyID0gX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgICAgd2hpbGUgKGFkZExpc3QuaGVhZCkge1xuICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKGFkZExpc3QuaGVhZC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhbmRpZGF0ZSA9IG5vZGUyLnByZXZpb3VzO1xuICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUobm9kZTIudmFsdWUpO1xuICAgICAgICBwdXNoQWRkKG5vZGUyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHRleHRzOiB0aGlzLnRleHRzLm1hcCgodGV4dCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4yID0gdGV4dC5ub2RlO1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24ocGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm1pcnJvci5nZXRJZChuMiksXG4gICAgICAgICAgICB2YWx1ZTogdGV4dC52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcigodGV4dCkgPT4gIWFkZGVkSWRzLmhhcyh0ZXh0LmlkKSkuZmlsdGVyKCh0ZXh0KSA9PiB0aGlzLm1pcnJvci5oYXModGV4dC5pZCkpLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5zdHlsZURpZmYpO1xuICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuX3VuY2hhbmdlZFN0eWxlcyk7XG4gICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICgoZGlmZkFzU3RyICsgdW5jaGFuZ2VkQXNTdHIpLnNwbGl0KFwidmFyKFwiKS5sZW5ndGggPT09IGF0dHJpYnV0ZXMuc3R5bGUuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBhdHRyaWJ1dGUuc3R5bGVEaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQoYXR0cmlidXRlLm5vZGUpLFxuICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcigoYXR0cmlidXRlKSA9PiAhYWRkZWRJZHMuaGFzKGF0dHJpYnV0ZS5pZCkpLmZpbHRlcigoYXR0cmlidXRlKSA9PiB0aGlzLm1pcnJvci5oYXMoYXR0cmlidXRlLmlkKSksXG4gICAgICAgIHJlbW92ZXM6IHRoaXMucmVtb3ZlcyxcbiAgICAgICAgYWRkc1xuICAgICAgfTtcbiAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiYgIXBheWxvYWQuYXR0cmlidXRlcy5sZW5ndGggJiYgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiYgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0cyA9IFtdO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy5yZW1vdmVzID0gW107XG4gICAgICB0aGlzLmFkZGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kcm9wcGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB0aGlzLm1vdmVkTWFwID0ge307XG4gICAgICB0aGlzLm11dGF0aW9uQ2IocGF5bG9hZCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdlblRleHRBcmVhVmFsdWVNdXRhdGlvblwiLCAodGV4dGFyZWEpID0+IHtcbiAgICAgIGxldCBpdGVtID0gdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KHRleHRhcmVhKTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBpdGVtID0ge1xuICAgICAgICAgIG5vZGU6IHRleHRhcmVhLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgIHN0eWxlRGlmZjoge30sXG4gICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldCh0ZXh0YXJlYSwgaXRlbSk7XG4gICAgICB9XG4gICAgICBpdGVtLmF0dHJpYnV0ZXMudmFsdWUgPSBBcnJheS5mcm9tKFxuICAgICAgICBpbmRleC5jaGlsZE5vZGVzKHRleHRhcmVhKSxcbiAgICAgICAgKGNuKSA9PiBpbmRleC50ZXh0Q29udGVudChjbikgfHwgXCJcIlxuICAgICAgKS5qb2luKFwiXCIpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm9jZXNzTXV0YXRpb25cIiwgKG0pID0+IHtcbiAgICAgIGlmIChpc0lnbm9yZWQobS50YXJnZXQsIHRoaXMubWlycm9yLCB0aGlzLnNsaW1ET01PcHRpb25zKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG0udHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hhcmFjdGVyRGF0YVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRleC50ZXh0Q29udGVudChtLnRhcmdldCk7XG4gICAgICAgICAgaWYgKCFpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgJiYgdmFsdWUgIT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZWVkTWFza2luZ1RleHQoXG4gICAgICAgICAgICAgICAgbS50YXJnZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tBbmNlc3RvcnNcbiAgICAgICAgICAgICAgKSAmJiB2YWx1ZSA/IHRoaXMubWFza1RleHRGbiA/IHRoaXMubWFza1RleHRGbih2YWx1ZSwgY2xvc2VzdEVsZW1lbnRPZk5vZGUobS50YXJnZXQpKSA6IHZhbHVlLnJlcGxhY2UoL1tcXFNdL2csIFwiKlwiKSA6IHZhbHVlLFxuICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhdHRyaWJ1dGVzXCI6IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBtLnRhcmdldDtcbiAgICAgICAgICBsZXQgYXR0cmlidXRlTmFtZSA9IG0uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBtLnRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpO1xuICAgICAgICAgICAgdmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICB0YWdOYW1lOiB0YXJnZXQudGFnTmFtZSxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fCB2YWx1ZSA9PT0gbS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XG4gICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSBcIklGUkFNRVwiICYmIGF0dHJpYnV0ZU5hbWUgPT09IFwic3JjXCIgJiYgIXRoaXMua2VlcElmcmFtZVNyY0ZuKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcInJyX3NyY1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwLnNldChtLnRhcmdldCwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInR5cGVcIiAmJiB0YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIChtLm9sZFZhbHVlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtcnItaXMtcGFzc3dvcmRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YXJnZXQudGFnTmFtZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgdGhpcy5kb2MsXG4gICAgICAgICAgICAgIHRvTG93ZXJDYXNlKHRhcmdldC50YWdOYW1lKSxcbiAgICAgICAgICAgICAgdG9Mb3dlckNhc2UoYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMudW5hdHRhY2hlZERvYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgICAgdGhpcy51bmF0dGFjaGVkRG9jID0gdGhpcy5kb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG9sZCA9IHRoaXMudW5hdHRhY2hlZERvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvbGQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgbS5vbGRWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwbmFtZSBvZiBBcnJheS5mcm9tKHRhcmdldC5zdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmlvcml0eSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSB8fCBuZXdQcmlvcml0eSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3UHJpb3JpdHkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBbbmV3VmFsdWUsIG5ld1ByaW9yaXR5XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXRlbS5fdW5jaGFuZ2VkU3R5bGVzW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20ob2xkLnN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcIm9wZW5cIiAmJiB0YXJnZXQudGFnTmFtZSA9PT0gXCJESUFMT0dcIikge1xuICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoXCJkaWFsb2c6bW9kYWxcIikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbXCJycl9vcGVuX21vZGVcIl0gPSBcIm1vZGFsXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW1wicnJfb3Blbl9tb2RlXCJdID0gXCJub24tbW9kYWxcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiY2hpbGRMaXN0XCI6IHtcbiAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgdHJ1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKG0udGFyZ2V0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24obS50YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtLmFkZGVkTm9kZXMuZm9yRWFjaCgobjIpID0+IHRoaXMuZ2VuQWRkcyhuMiwgbS50YXJnZXQpKTtcbiAgICAgICAgICBtLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gdGhpcy5taXJyb3IuZ2V0SWQobjIpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QobS50YXJnZXQpID8gdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXguaG9zdChtLnRhcmdldCkpIDogdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fCBpc0lnbm9yZWQobjIsIHRoaXMubWlycm9yLCB0aGlzLnNsaW1ET01PcHRpb25zKSB8fCAhaXNTZXJpYWxpemVkKG4yLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4yKSkge1xuICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMuYWRkZWRTZXQsIG4yKTtcbiAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG0udGFyZ2V0KSAmJiBub2RlSWQgPT09IC0xKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1vdmVkU2V0LmhhcyhuMikgJiYgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KG5vZGVJZCwgcGFyZW50SWQpXSkge1xuICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMubW92ZWRTZXQsIG4yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3Zlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlzU2hhZG93OiBpc1NoYWRvd1Jvb3QobS50YXJnZXQpICYmIGlzTmF0aXZlU2hhZG93RG9tKG0udGFyZ2V0KSA/IHRydWUgOiB2b2lkIDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHByb2Nlc3NSZW1vdmVzKG4yLCB0aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXBSZW1vdmVzLnB1c2gobjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdlbkFkZHNcIiwgKG4yLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmluT3RoZXJCdWZmZXIobjIsIHRoaXMpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5hZGRlZFNldC5oYXMobjIpIHx8IHRoaXMubW92ZWRTZXQuaGFzKG4yKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMubWlycm9yLmhhc05vZGUobjIpKSB7XG4gICAgICAgIGlmIChpc0lnbm9yZWQobjIsIHRoaXMubWlycm9yLCB0aGlzLnNsaW1ET01PcHRpb25zKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVkU2V0LmFkZChuMik7XG4gICAgICAgIGxldCB0YXJnZXRJZCA9IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGhpcy5taXJyb3IuaGFzTm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgdGFyZ2V0SWQgPSB0aGlzLm1pcnJvci5nZXRJZCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRJZCAmJiB0YXJnZXRJZCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLm1vdmVkTWFwW21vdmVLZXkodGhpcy5taXJyb3IuZ2V0SWQobjIpLCB0YXJnZXRJZCldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRlZFNldC5hZGQobjIpO1xuICAgICAgICB0aGlzLmRyb3BwZWRTZXQuZGVsZXRlKG4yKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNCbG9ja2VkKG4yLCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpKSB7XG4gICAgICAgIGluZGV4LmNoaWxkTm9kZXMobjIpLmZvckVhY2goKGNoaWxkTikgPT4gdGhpcy5nZW5BZGRzKGNoaWxkTikpO1xuICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICBpbmRleC5jaGlsZE5vZGVzKGluZGV4LnNoYWRvd1Jvb3QobjIpKS5mb3JFYWNoKChjaGlsZE4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuYWRkKGNoaWxkTiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmdlbkFkZHMoY2hpbGROLCBuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICBbXG4gICAgICBcIm11dGF0aW9uQ2JcIixcbiAgICAgIFwiYmxvY2tDbGFzc1wiLFxuICAgICAgXCJibG9ja1NlbGVjdG9yXCIsXG4gICAgICBcIm1hc2tUZXh0Q2xhc3NcIixcbiAgICAgIFwibWFza1RleHRTZWxlY3RvclwiLFxuICAgICAgXCJpbmxpbmVTdHlsZXNoZWV0XCIsXG4gICAgICBcIm1hc2tJbnB1dE9wdGlvbnNcIixcbiAgICAgIFwibWFza1RleHRGblwiLFxuICAgICAgXCJtYXNrSW5wdXRGblwiLFxuICAgICAgXCJrZWVwSWZyYW1lU3JjRm5cIixcbiAgICAgIFwicmVjb3JkQ2FudmFzXCIsXG4gICAgICBcImlubGluZUltYWdlc1wiLFxuICAgICAgXCJzbGltRE9NT3B0aW9uc1wiLFxuICAgICAgXCJkYXRhVVJMT3B0aW9uc1wiLFxuICAgICAgXCJkb2NcIixcbiAgICAgIFwibWlycm9yXCIsXG4gICAgICBcImlmcmFtZU1hbmFnZXJcIixcbiAgICAgIFwic3R5bGVzaGVldE1hbmFnZXJcIixcbiAgICAgIFwic2hhZG93RG9tTWFuYWdlclwiLFxuICAgICAgXCJjYW52YXNNYW5hZ2VyXCIsXG4gICAgICBcInByb2Nlc3NlZE5vZGVNYW5hZ2VyXCJcbiAgICBdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH0pO1xuICB9XG4gIGZyZWV6ZSgpIHtcbiAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWV6ZSgpO1xuICB9XG4gIHVuZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVuZnJlZXplKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgaXNGcm96ZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvemVuO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuY2FudmFzTWFuYWdlci5sb2NrKCk7XG4gIH1cbiAgdW5sb2NrKCkge1xuICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVubG9jaygpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5yZXNldCgpO1xuICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwRGVsZXRlKGFkZHNTZXQsIG4yKSB7XG4gIGFkZHNTZXQuZGVsZXRlKG4yKTtcbiAgaW5kZXguY2hpbGROb2RlcyhuMikuZm9yRWFjaCgoY2hpbGROKSA9PiBkZWVwRGVsZXRlKGFkZHNTZXQsIGNoaWxkTikpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JlbW92ZXMobjIsIGNhY2hlKSB7XG4gIGNvbnN0IHF1ZXVlID0gW24yXTtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGNvbnN0IG5leHQgPSBxdWV1ZS5wb3AoKTtcbiAgICBpZiAoY2FjaGUuaGFzKG5leHQpKSBjb250aW51ZTtcbiAgICBjYWNoZS5hZGQobmV4dCk7XG4gICAgaW5kZXguY2hpbGROb2RlcyhuZXh0KS5mb3JFYWNoKChuMjIpID0+IHF1ZXVlLnB1c2gobjIyKSk7XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBtaXJyb3IyKSB7XG4gIGlmIChyZW1vdmVzLnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIpO1xufVxuZnVuY3Rpb24gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMiwgX21pcnJvcjIpIHtcbiAgY29uc3Qgbm9kZTIgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgaWYgKCFub2RlMikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gcmVtb3Zlcy5oYXMobm9kZTIpO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgaWYgKHNldC5zaXplID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpO1xufVxuZnVuY3Rpb24gX2lzQW5jZXN0b3JJblNldChzZXQsIG4yKSB7XG4gIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICBpZiAoIXBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc2V0LmhhcyhwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBwYXJlbnQpO1xufVxubGV0IGVycm9ySGFuZGxlcjtcbmZ1bmN0aW9uIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcbiAgZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKSB7XG4gIGVycm9ySGFuZGxlciA9IHZvaWQgMDtcbn1cbmNvbnN0IGNhbGxiYWNrV3JhcHBlciA9IChjYikgPT4ge1xuICBpZiAoIWVycm9ySGFuZGxlcikge1xuICAgIHJldHVybiBjYjtcbiAgfVxuICBjb25zdCBycndlYldyYXBwZWQgPSAoLi4ucmVzdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoLi4ucmVzdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvckhhbmRsZXIgJiYgZXJyb3JIYW5kbGVyKGVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBycndlYldyYXBwZWQ7XG59O1xuY29uc3QgbXV0YXRpb25CdWZmZXJzID0gW107XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICB0cnkge1xuICAgIGlmIChcImNvbXBvc2VkUGF0aFwiIGluIGV2ZW50KSB7XG4gICAgICBjb25zdCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInBhdGhcIiBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnBhdGhbMF07XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZXZlbnQgJiYgZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XG4gIGNvbnN0IG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XG4gIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcbiAgbXV0YXRpb25CdWZmZXIuaW5pdChvcHRpb25zKTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgKG11dGF0aW9uT2JzZXJ2ZXJDdG9yKCkpKFxuICAgIGNhbGxiYWNrV3JhcHBlcihtdXRhdGlvbkJ1ZmZlci5wcm9jZXNzTXV0YXRpb25zLmJpbmQobXV0YXRpb25CdWZmZXIpKVxuICApO1xuICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbCwge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIoe1xuICBtb3VzZW1vdmVDYixcbiAgc2FtcGxpbmcsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyXG59KSB7XG4gIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHRocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcbiAgY29uc3QgY2FsbGJhY2tUaHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2sgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA6IDUwMDtcbiAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICBsZXQgdGltZUJhc2VsaW5lO1xuICBjb25zdCB3cmFwcGVkQ2IgPSB0aHJvdHRsZShcbiAgICBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAoc291cmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsT2Zmc2V0ID0gRGF0ZS5ub3coKSAtIHRpbWVCYXNlbGluZTtcbiAgICAgICAgbW91c2Vtb3ZlQ2IoXG4gICAgICAgICAgcG9zaXRpb25zLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgcC50aW1lT2Zmc2V0IC09IHRvdGFsT2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc291cmNlXG4gICAgICAgICk7XG4gICAgICAgIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aW1lQmFzZWxpbmUgPSBudWxsO1xuICAgICAgfVxuICAgICksXG4gICAgY2FsbGJhY2tUaHJlc2hvbGRcbiAgKTtcbiAgY29uc3QgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUoXG4gICAgICBjYWxsYmFja1dyYXBwZXIoKGV2dCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xuICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZ0KSA/IGV2dC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2dDtcbiAgICAgICAgaWYgKCF0aW1lQmFzZWxpbmUpIHtcbiAgICAgICAgICB0aW1lQmFzZWxpbmUgPSBub3dUaW1lc3RhbXAoKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbnMucHVzaCh7XG4gICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICB5OiBjbGllbnRZLFxuICAgICAgICAgIGlkOiBtaXJyb3IyLmdldElkKHRhcmdldCksXG4gICAgICAgICAgdGltZU9mZnNldDogbm93VGltZXN0YW1wKCkgLSB0aW1lQmFzZWxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIHdyYXBwZWRDYihcbiAgICAgICAgICB0eXBlb2YgRHJhZ0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2dCBpbnN0YW5jZW9mIERyYWdFdmVudCA/IEluY3JlbWVudGFsU291cmNlLkRyYWcgOiBldnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ID8gSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlIDogSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIHtcbiAgICAgICAgdHJhaWxpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgKVxuICApO1xuICBjb25zdCBoYW5kbGVycyA9IFtcbiAgICBvbihcIm1vdXNlbW92ZVwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcbiAgICBvbihcInRvdWNobW92ZVwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcbiAgICBvbihcImRyYWdcIiwgdXBkYXRlUG9zaXRpb24sIGRvYylcbiAgXTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKHtcbiAgbW91c2VJbnRlcmFjdGlvbkNiLFxuICBkb2MsXG4gIG1pcnJvcjogbWlycm9yMixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgc2FtcGxpbmdcbn0pIHtcbiAgaWYgKHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHZvaWQgMCA/IHt9IDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgbGV0IGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gIGNvbnN0IGdldEhhbmRsZXIgPSAoZXZlbnRLZXkpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgIGxldCB0aGlzRXZlbnRLZXkgPSBldmVudEtleTtcbiAgICAgIGlmIChcInBvaW50ZXJUeXBlXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5wb2ludGVyVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJtb3VzZVwiOlxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuTW91c2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG91Y2hcIjpcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBlblwiOlxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuUGVuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2gpIHtcbiAgICAgICAgICBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hTdGFydFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwKSB7XG4gICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSBcIlRvdWNoRW5kXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuUGVuKSA7XG4gICAgICB9IGVsc2UgaWYgKGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50ZXJUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICBpZiAodGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJUb3VjaFwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlRvdWNoIHx8IHRoaXNFdmVudEtleS5zdGFydHNXaXRoKFwiTW91c2VcIikgJiYgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Nb3VzZSkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLkNsaWNrKSB7XG4gICAgICAgIHBvaW50ZXJUeXBlID0gY3VycmVudFBvaW50ZXJUeXBlO1xuICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZTIgPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgICBpZiAoIWUyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlMjtcbiAgICAgIGNhbGxiYWNrV3JhcHBlcihtb3VzZUludGVyYWN0aW9uQ2IpKHtcbiAgICAgICAgdHlwZTogTW91c2VJbnRlcmFjdGlvbnNbdGhpc0V2ZW50S2V5XSxcbiAgICAgICAgaWQsXG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFksXG4gICAgICAgIC4uLnBvaW50ZXJUeXBlICE9PSBudWxsICYmIHsgcG9pbnRlclR5cGUgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmtleXMoTW91c2VJbnRlcmFjdGlvbnMpLmZpbHRlcihcbiAgICAoa2V5KSA9PiBOdW1iZXIuaXNOYU4oTnVtYmVyKGtleSkpICYmICFrZXkuZW5kc1dpdGgoXCJfRGVwYXJ0ZWRcIikgJiYgZGlzYWJsZU1hcFtrZXldICE9PSBmYWxzZVxuICApLmZvckVhY2goKGV2ZW50S2V5KSA9PiB7XG4gICAgbGV0IGV2ZW50TmFtZSA9IHRvTG93ZXJDYXNlKGV2ZW50S2V5KTtcbiAgICBjb25zdCBoYW5kbGVyID0gZ2V0SGFuZGxlcihldmVudEtleSk7XG4gICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldKSB7XG4gICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duOlxuICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXA6XG4gICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnJlcGxhY2UoXG4gICAgICAgICAgICBcIm1vdXNlXCIsXG4gICAgICAgICAgICBcInBvaW50ZXJcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hTdGFydDpcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaEVuZDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGhhbmRsZXJzLnB1c2gob24oZXZlbnROYW1lLCBoYW5kbGVyLCBkb2MpKTtcbiAgfSk7XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNjcm9sbE9ic2VydmVyKHtcbiAgc2Nyb2xsQ2IsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBibG9ja0NsYXNzLFxuICBibG9ja1NlbGVjdG9yLFxuICBzYW1wbGluZ1xufSkge1xuICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICB0aHJvdHRsZShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3KSB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdFRvcCA9IGdldFdpbmRvd1Njcm9sbChkb2MuZGVmYXVsdFZpZXcpO1xuICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdFRvcC5sZWZ0LFxuICAgICAgICAgICAgeTogc2Nyb2xsTGVmdFRvcC50b3BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxDYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHg6IHRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgeTogdGFyZ2V0LnNjcm9sbFRvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHNhbXBsaW5nLnNjcm9sbCB8fCAxMDBcbiAgICApXG4gICk7XG4gIHJldHVybiBvbihcInNjcm9sbFwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKTtcbn1cbmZ1bmN0aW9uIGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKHsgdmlld3BvcnRSZXNpemVDYiB9LCB7IHdpbiB9KSB7XG4gIGxldCBsYXN0SCA9IC0xO1xuICBsZXQgbGFzdFcgPSAtMTtcbiAgY29uc3QgdXBkYXRlRGltZW5zaW9uID0gY2FsbGJhY2tXcmFwcGVyKFxuICAgIHRocm90dGxlKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0V2luZG93SGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0V2luZG93V2lkdGgoKTtcbiAgICAgICAgaWYgKGxhc3RIICE9PSBoZWlnaHQgfHwgbGFzdFcgIT09IHdpZHRoKSB7XG4gICAgICAgICAgdmlld3BvcnRSZXNpemVDYih7XG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyKHdpZHRoKSxcbiAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGhlaWdodClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0SCA9IGhlaWdodDtcbiAgICAgICAgICBsYXN0VyA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIDIwMFxuICAgIClcbiAgKTtcbiAgcmV0dXJuIG9uKFwicmVzaXplXCIsIHVwZGF0ZURpbWVuc2lvbiwgd2luKTtcbn1cbmNvbnN0IElOUFVUX1RBR1MgPSBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdO1xuY29uc3QgbGFzdElucHV0VmFsdWVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGluaXRJbnB1dE9ic2VydmVyKHtcbiAgaW5wdXRDYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIGlnbm9yZUNsYXNzLFxuICBpZ25vcmVTZWxlY3RvcixcbiAgbWFza0lucHV0T3B0aW9ucyxcbiAgbWFza0lucHV0Rm4sXG4gIHNhbXBsaW5nLFxuICB1c2VyVHJpZ2dlcmVkT25JbnB1dFxufSkge1xuICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IHVzZXJUcmlnZ2VyZWQgPSBldmVudC5pc1RydXN0ZWQ7XG4gICAgY29uc3QgdGFnTmFtZSA9IHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZTtcbiAgICBpZiAodGFyZ2V0ICYmIHRhZ05hbWUgPT09IFwiT1BUSU9OXCIpIHtcbiAgICAgIHRhcmdldCA9IGluZGV4LnBhcmVudEVsZW1lbnQodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXQgfHwgIXRhZ05hbWUgfHwgSU5QVVRfVEFHUy5pbmRleE9mKHRhZ05hbWUpIDwgMCB8fCBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHwgaWdub3JlU2VsZWN0b3IgJiYgdGFyZ2V0Lm1hdGNoZXMoaWdub3JlU2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0ZXh0ID0gdGFyZ2V0LnZhbHVlO1xuICAgIGxldCBpc0NoZWNrZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCkgfHwgXCJcIjtcbiAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgfSBlbHNlIGlmIChtYXNrSW5wdXRPcHRpb25zW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgbWFza0lucHV0T3B0aW9uc1t0eXBlXSkge1xuICAgICAgdGV4dCA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICB0YWdOYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgbWFza0lucHV0Rm5cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYldpdGhEZWR1cChcbiAgICAgIHRhcmdldCxcbiAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID8geyB0ZXh0LCBpc0NoZWNrZWQsIHVzZXJUcmlnZ2VyZWQgfSA6IHsgdGV4dCwgaXNDaGVja2VkIH1cbiAgICApO1xuICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubmFtZTtcbiAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiICYmIG5hbWUgJiYgaXNDaGVja2VkKSB7XG4gICAgICBkb2MucXVlcnlTZWxlY3RvckFsbChgaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCIke25hbWV9XCJdYCkuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0MiA9IGVsLnZhbHVlO1xuICAgICAgICAgIGNiV2l0aERlZHVwKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dCA/IHsgdGV4dDogdGV4dDIsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZDogZmFsc2UgfSA6IHsgdGV4dDogdGV4dDIsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNiV2l0aERlZHVwKHRhcmdldCwgdjIpIHtcbiAgICBjb25zdCBsYXN0SW5wdXRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlTWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghbGFzdElucHV0VmFsdWUgfHwgbGFzdElucHV0VmFsdWUudGV4dCAhPT0gdjIudGV4dCB8fCBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYyLmlzQ2hlY2tlZCkge1xuICAgICAgbGFzdElucHV0VmFsdWVNYXAuc2V0KHRhcmdldCwgdjIpO1xuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoe1xuICAgICAgICAuLi52MixcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudHMgPSBzYW1wbGluZy5pbnB1dCA9PT0gXCJsYXN0XCIgPyBbXCJjaGFuZ2VcIl0gOiBbXCJpbnB1dFwiLCBcImNoYW5nZVwiXTtcbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMubWFwKFxuICAgIChldmVudE5hbWUpID0+IG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYylcbiAgKTtcbiAgY29uc3QgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBjdXJyZW50V2luZG93Lk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSxcbiAgICBcInZhbHVlXCJcbiAgKTtcbiAgY29uc3QgaG9va1Byb3BlcnRpZXMgPSBbXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwiY2hlY2tlZFwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgLy8gU29tZSBVSSBsaWJyYXJ5IHVzZSBzZWxlY3RlZEluZGV4IHRvIHNldCBzZWxlY3QgdmFsdWVcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MT3B0aW9uRWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIl1cbiAgXTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvciAmJiBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSB7XG4gICAgaGFuZGxlcnMucHVzaChcbiAgICAgIC4uLmhvb2tQcm9wZXJ0aWVzLm1hcChcbiAgICAgICAgKHApID0+IGhvb2tTZXR0ZXIoXG4gICAgICAgICAgcFswXSxcbiAgICAgICAgICBwWzFdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlcikoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBpc1RydXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgLy8gdXNlclRyaWdnZXJlZCB0byBmYWxzZSBhcyB0aGlzIGNvdWxkIHdlbGwgYmUgcHJvZ3JhbW1hdGljXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgY3VycmVudFdpbmRvd1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZTIpIHtcbiAgY29uc3QgcG9zaXRpb25zID0gW107XG4gIGZ1bmN0aW9uIHJlY3Vyc2UoY2hpbGRSdWxlLCBwb3MpIHtcbiAgICBpZiAoaGFzTmVzdGVkQ1NTUnVsZShcIkNTU0dyb3VwaW5nUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0dyb3VwaW5nUnVsZSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTTWVkaWFSdWxlXCIpICYmIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NTdXBwb3J0c1J1bGVcIikgJiYgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NTdXBwb3J0c1J1bGUgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU0NvbmRpdGlvblJ1bGVcIikgJiYgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NDb25kaXRpb25SdWxlKSB7XG4gICAgICBjb25zdCBydWxlczIgPSBBcnJheS5mcm9tKFxuICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZS5jc3NSdWxlc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGluZGV4MiA9IHJ1bGVzMi5pbmRleE9mKGNoaWxkUnVsZSk7XG4gICAgICBwb3MudW5zaGlmdChpbmRleDIpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xuICAgICAgY29uc3QgaW5kZXgyID0gcnVsZXMyLmluZGV4T2YoY2hpbGRSdWxlKTtcbiAgICAgIHBvcy51bnNoaWZ0KGluZGV4Mik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgcmV0dXJuIHJlY3Vyc2UocnVsZTIsIHBvc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvcjIsIHN0eWxlTWlycm9yKSB7XG4gIGxldCBpZCwgc3R5bGVJZDtcbiAgaWYgKCFzaGVldCkgcmV0dXJuIHt9O1xuICBpZiAoc2hlZXQub3duZXJOb2RlKSBpZCA9IG1pcnJvcjIuZ2V0SWQoc2hlZXQub3duZXJOb2RlKTtcbiAgZWxzZSBzdHlsZUlkID0gc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICByZXR1cm4ge1xuICAgIHN0eWxlSWQsXG4gICAgaWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBzdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3I6IG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyIH0sIHsgd2luIH0pIHtcbiAgaWYgKCF3aW4uQ1NTU3R5bGVTaGVldCB8fCAhd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkoaW5zZXJ0UnVsZSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IFtydWxlMiwgaW5kZXgyXSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICBhZGRzOiBbeyBydWxlOiBydWxlMiwgaW5kZXg6IGluZGV4MiB9XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmFkZFJ1bGUgPSBmdW5jdGlvbihzZWxlY3Rvciwgc3R5bGVCbG9jaywgaW5kZXgyID0gdGhpcy5jc3NSdWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBydWxlMiA9IGAke3NlbGVjdG9yfSB7ICR7c3R5bGVCbG9ja30gfWA7XG4gICAgcmV0dXJuIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlLmFwcGx5KHRoaXMsIFtydWxlMiwgaW5kZXgyXSk7XG4gIH07XG4gIGNvbnN0IGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkoZGVsZXRlUnVsZSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IFtpbmRleDJdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICApO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgIHJlbW92ZXM6IFt7IGluZGV4OiBpbmRleDIgfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgfVxuICAgIClcbiAgfSk7XG4gIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZW1vdmVSdWxlID0gZnVuY3Rpb24oaW5kZXgyKSB7XG4gICAgcmV0dXJuIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlLmFwcGx5KHRoaXMsIFtpbmRleDJdKTtcbiAgfTtcbiAgbGV0IHJlcGxhY2U7XG4gIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSkge1xuICAgIHJlcGxhY2UgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZTtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IG5ldyBQcm94eShyZXBsYWNlLCB7XG4gICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3RleHRdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgcmVwbGFjZTogdGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuICBsZXQgcmVwbGFjZVN5bmM7XG4gIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMpIHtcbiAgICByZXBsYWNlU3luYyA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYztcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSBuZXcgUHJveHkocmVwbGFjZVN5bmMsIHtcbiAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICByZXBsYWNlU3luYzogdGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMgPSB7fTtcbiAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU0dyb3VwaW5nUnVsZVwiKSkge1xuICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NHcm91cGluZ1J1bGUgPSB3aW4uQ1NTR3JvdXBpbmdSdWxlO1xuICB9IGVsc2Uge1xuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikpIHtcbiAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NNZWRpYVJ1bGUgPSB3aW4uQ1NTTWVkaWFSdWxlO1xuICAgIH1cbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSkge1xuICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0NvbmRpdGlvblJ1bGUgPSB3aW4uQ1NTQ29uZGl0aW9uUnVsZTtcbiAgICB9XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSkge1xuICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU1N1cHBvcnRzUnVsZSA9IHdpbi5DU1NTdXBwb3J0c1J1bGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVubW9kaWZpZWRGdW5jdGlvbnMgPSB7fTtcbiAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKChbdHlwZUtleSwgdHlwZV0pID0+IHtcbiAgICB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldID0ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgaW5zZXJ0UnVsZTogdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGRlbGV0ZVJ1bGU6IHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGVcbiAgICB9O1xuICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkoXG4gICAgICB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGUsXG4gICAgICB7XG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3J1bGUyLCBpbmRleDJdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgICAgdGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LFxuICAgICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZTIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4uZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnKSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleDIgfHwgMFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDBcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShcbiAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZSxcbiAgICAgIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaW5kZXgyXSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgICAgIHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgICByZW1vdmVzOiBbXG4gICAgICAgICAgICAgICAgICB7IGluZGV4OiBbLi4uZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnKSwgaW5kZXgyXSB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gaW5zZXJ0UnVsZTtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGRlbGV0ZVJ1bGU7XG4gICAgcmVwbGFjZSAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlKTtcbiAgICByZXBsYWNlU3luYyAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gcmVwbGFjZVN5bmMpO1xuICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XG4gICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlO1xuICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7XG4gIG1pcnJvcjogbWlycm9yMixcbiAgc3R5bGVzaGVldE1hbmFnZXJcbn0sIGhvc3QyKSB7XG4gIHZhciBfYTIsIF9iLCBfYztcbiAgbGV0IGhvc3RJZCA9IG51bGw7XG4gIGlmIChob3N0Mi5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIikgaG9zdElkID0gbWlycm9yMi5nZXRJZChob3N0Mik7XG4gIGVsc2UgaG9zdElkID0gbWlycm9yMi5nZXRJZChpbmRleC5ob3N0KGhvc3QyKSk7XG4gIGNvbnN0IHBhdGNoVGFyZ2V0ID0gaG9zdDIubm9kZU5hbWUgPT09IFwiI2RvY3VtZW50XCIgPyAoX2EyID0gaG9zdDIuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuRG9jdW1lbnQgOiAoX2MgPSAoX2IgPSBob3N0Mi5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5TaGFkb3dSb290O1xuICBjb25zdCBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciA9IChwYXRjaFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlKSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgcGF0Y2hUYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGNoVGFyZ2V0LnByb3RvdHlwZSxcbiAgICBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiXG4gICkgOiB2b2lkIDA7XG4gIGlmIChob3N0SWQgPT09IG51bGwgfHwgaG9zdElkID09PSAtMSB8fCAhcGF0Y2hUYXJnZXQgfHwgIW9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QyLCBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiLCB7XG4gICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBnZXQoKSB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgcmV0dXJuIChfYTMgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldChzaGVldHMpIHtcbiAgICAgIHZhciBfYTM7XG4gICAgICBjb25zdCByZXN1bHQyID0gKF9hMyA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHRoaXMsIHNoZWV0cyk7XG4gICAgICBpZiAoaG9zdElkICE9PSBudWxsICYmIGhvc3RJZCAhPT0gLTEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QyLCBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiLCB7XG4gICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBnZXQ6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIHNldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcih7XG4gIHN0eWxlRGVjbGFyYXRpb25DYixcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxuICBzdHlsZXNoZWV0TWFuYWdlclxufSwgeyB3aW4gfSkge1xuICBjb25zdCBzZXRQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eTtcbiAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gbmV3IFByb3h5KHNldFByb3BlcnR5LCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHldID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgIHJldHVybiBzZXRQcm9wZXJ0eS5hcHBseSh0aGlzQXJnLCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAoX2EyID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnBhcmVudFN0eWxlU2hlZXQsXG4gICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICApO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgc2V0OiB7XG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgY29uc3QgcmVtb3ZlUHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHk7XG4gIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IG5ldyBQcm94eShyZW1vdmVQcm9wZXJ0eSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGNvbnN0IFtwcm9wZXJ0eV0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZVByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAoX2EyID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnBhcmVudFN0eWxlU2hlZXQsXG4gICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICApO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgcmVtb3ZlOiB7XG4gICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgfVxuICAgIClcbiAgfSk7XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIoe1xuICBtZWRpYUludGVyYWN0aW9uQ2IsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIG1pcnJvcjogbWlycm9yMixcbiAgc2FtcGxpbmcsXG4gIGRvY1xufSkge1xuICBjb25zdCBoYW5kbGVyID0gY2FsbGJhY2tXcmFwcGVyKFxuICAgICh0eXBlKSA9PiB0aHJvdHRsZShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN1cnJlbnRUaW1lLCB2b2x1bWUsIG11dGVkLCBwbGF5YmFja1JhdGUsIGxvb3AgfSA9IHRhcmdldDtcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGlkOiBtaXJyb3IyLmdldElkKHRhcmdldCksXG4gICAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgICAgdm9sdW1lLFxuICAgICAgICAgIG11dGVkLFxuICAgICAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgICAgICBsb29wXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBzYW1wbGluZy5tZWRpYSB8fCA1MDBcbiAgICApXG4gICk7XG4gIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgIG9uKFwicGxheVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBsYXkpLCBkb2MpLFxuICAgIG9uKFwicGF1c2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5QYXVzZSksIGRvYyksXG4gICAgb24oXCJzZWVrZWRcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5TZWVrZWQpLCBkb2MpLFxuICAgIG9uKFwidm9sdW1lY2hhbmdlXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuVm9sdW1lQ2hhbmdlKSwgZG9jKSxcbiAgICBvbihcInJhdGVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5SYXRlQ2hhbmdlKSwgZG9jKVxuICBdO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRGb250T2JzZXJ2ZXIoeyBmb250Q2IsIGRvYyB9KSB7XG4gIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCF3aW4pIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgY29uc3QgZm9udE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xuICB3aW4uRm9udEZhY2UgPSBmdW5jdGlvbiBGb250RmFjZTIoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xuICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XG4gICAgICBmYW1pbHksXG4gICAgICBidWZmZXI6IHR5cGVvZiBzb3VyY2UgIT09IFwic3RyaW5nXCIsXG4gICAgICBkZXNjcmlwdG9ycyxcbiAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgPyBzb3VyY2UgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKVxuICAgIH0pO1xuICAgIHJldHVybiBmb250RmFjZTtcbiAgfTtcbiAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICBkb2MuZm9udHMsXG4gICAgXCJhZGRcIixcbiAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRGYWNlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBmb250TWFwLmdldChmb250RmFjZSk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICBmb250Q2IocCk7XG4gICAgICAgICAgICAgIGZvbnRNYXAuZGVsZXRlKGZvbnRGYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZm9udEZhY2VdKTtcbiAgICAgIH07XG4gICAgfVxuICApO1xuICBoYW5kbGVycy5wdXNoKCgpID0+IHtcbiAgICB3aW4uRm9udEZhY2UgPSBvcmlnaW5hbEZvbnRGYWNlO1xuICB9KTtcbiAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNlbGVjdGlvbk9ic2VydmVyKHBhcmFtKSB7XG4gIGNvbnN0IHsgZG9jLCBtaXJyb3I6IG1pcnJvcjIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNlbGVjdGlvbkNiIH0gPSBwYXJhbTtcbiAgbGV0IGNvbGxhcHNlZCA9IHRydWU7XG4gIGNvbnN0IHVwZGF0ZVNlbGVjdGlvbiA9IGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jLmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IGNvbGxhcHNlZCAmJiAoc2VsZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpKSByZXR1cm47XG4gICAgY29sbGFwc2VkID0gc2VsZWN0aW9uLmlzQ29sbGFwc2VkIHx8IGZhbHNlO1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGNvdW50ID0gc2VsZWN0aW9uLnJhbmdlQ291bnQgfHwgMDtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgY291bnQ7IGkyKyspIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaTIpO1xuICAgICAgY29uc3QgeyBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0IH0gPSByYW5nZTtcbiAgICAgIGNvbnN0IGJsb2NrZWQgPSBpc0Jsb2NrZWQoc3RhcnRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpIHx8IGlzQmxvY2tlZChlbmRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xuICAgICAgaWYgKGJsb2NrZWQpIGNvbnRpbnVlO1xuICAgICAgcmFuZ2VzLnB1c2goe1xuICAgICAgICBzdGFydDogbWlycm9yMi5nZXRJZChzdGFydENvbnRhaW5lciksXG4gICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmQ6IG1pcnJvcjIuZ2V0SWQoZW5kQ29udGFpbmVyKSxcbiAgICAgICAgZW5kT2Zmc2V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VsZWN0aW9uQ2IoeyByYW5nZXMgfSk7XG4gIH0pO1xuICB1cGRhdGVTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIG9uKFwic2VsZWN0aW9uY2hhbmdlXCIsIHVwZGF0ZVNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiBpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyKHtcbiAgZG9jLFxuICBjdXN0b21FbGVtZW50Q2Jcbn0pIHtcbiAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIXdpbiB8fCAhd2luLmN1c3RvbUVsZW1lbnRzKSByZXR1cm4gKCkgPT4ge1xuICB9O1xuICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgIHdpbi5jdXN0b21FbGVtZW50cyxcbiAgICBcImRlZmluZVwiLFxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjdXN0b21FbGVtZW50Q2Ioe1xuICAgICAgICAgICAgZGVmaW5lOiB7XG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIGZhaWxlZCBmb3IgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnNdKTtcbiAgICAgIH07XG4gICAgfVxuICApO1xuICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XG59XG5mdW5jdGlvbiBtZXJnZUhvb2tzKG8yLCBob29rcykge1xuICBjb25zdCB7XG4gICAgbXV0YXRpb25DYixcbiAgICBtb3VzZW1vdmVDYixcbiAgICBtb3VzZUludGVyYWN0aW9uQ2IsXG4gICAgc2Nyb2xsQ2IsXG4gICAgdmlld3BvcnRSZXNpemVDYixcbiAgICBpbnB1dENiLFxuICAgIG1lZGlhSW50ZXJhY3Rpb25DYixcbiAgICBzdHlsZVNoZWV0UnVsZUNiLFxuICAgIHN0eWxlRGVjbGFyYXRpb25DYixcbiAgICBjYW52YXNNdXRhdGlvbkNiLFxuICAgIGZvbnRDYixcbiAgICBzZWxlY3Rpb25DYixcbiAgICBjdXN0b21FbGVtZW50Q2JcbiAgfSA9IG8yO1xuICBvMi5tdXRhdGlvbkNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MubXV0YXRpb24pIHtcbiAgICAgIGhvb2tzLm11dGF0aW9uKC4uLnApO1xuICAgIH1cbiAgICBtdXRhdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5tb3VzZW1vdmVDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLm1vdXNlbW92ZSkge1xuICAgICAgaG9va3MubW91c2Vtb3ZlKC4uLnApO1xuICAgIH1cbiAgICBtb3VzZW1vdmVDYiguLi5wKTtcbiAgfTtcbiAgbzIubW91c2VJbnRlcmFjdGlvbkNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MubW91c2VJbnRlcmFjdGlvbikge1xuICAgICAgaG9va3MubW91c2VJbnRlcmFjdGlvbiguLi5wKTtcbiAgICB9XG4gICAgbW91c2VJbnRlcmFjdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5zY3JvbGxDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLnNjcm9sbCkge1xuICAgICAgaG9va3Muc2Nyb2xsKC4uLnApO1xuICAgIH1cbiAgICBzY3JvbGxDYiguLi5wKTtcbiAgfTtcbiAgbzIudmlld3BvcnRSZXNpemVDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLnZpZXdwb3J0UmVzaXplKSB7XG4gICAgICBob29rcy52aWV3cG9ydFJlc2l6ZSguLi5wKTtcbiAgICB9XG4gICAgdmlld3BvcnRSZXNpemVDYiguLi5wKTtcbiAgfTtcbiAgbzIuaW5wdXRDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLmlucHV0KSB7XG4gICAgICBob29rcy5pbnB1dCguLi5wKTtcbiAgICB9XG4gICAgaW5wdXRDYiguLi5wKTtcbiAgfTtcbiAgbzIubWVkaWFJbnRlcmFjdGlvbkNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MubWVkaWFJbnRlYWN0aW9uKSB7XG4gICAgICBob29rcy5tZWRpYUludGVhY3Rpb24oLi4ucCk7XG4gICAgfVxuICAgIG1lZGlhSW50ZXJhY3Rpb25DYiguLi5wKTtcbiAgfTtcbiAgbzIuc3R5bGVTaGVldFJ1bGVDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLnN0eWxlU2hlZXRSdWxlKSB7XG4gICAgICBob29rcy5zdHlsZVNoZWV0UnVsZSguLi5wKTtcbiAgICB9XG4gICAgc3R5bGVTaGVldFJ1bGVDYiguLi5wKTtcbiAgfTtcbiAgbzIuc3R5bGVEZWNsYXJhdGlvbkNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Muc3R5bGVEZWNsYXJhdGlvbikge1xuICAgICAgaG9va3Muc3R5bGVEZWNsYXJhdGlvbiguLi5wKTtcbiAgICB9XG4gICAgc3R5bGVEZWNsYXJhdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5jYW52YXNNdXRhdGlvbkNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MuY2FudmFzTXV0YXRpb24pIHtcbiAgICAgIGhvb2tzLmNhbnZhc011dGF0aW9uKC4uLnApO1xuICAgIH1cbiAgICBjYW52YXNNdXRhdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5mb250Q2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5mb250KSB7XG4gICAgICBob29rcy5mb250KC4uLnApO1xuICAgIH1cbiAgICBmb250Q2IoLi4ucCk7XG4gIH07XG4gIG8yLnNlbGVjdGlvbkNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Muc2VsZWN0aW9uKSB7XG4gICAgICBob29rcy5zZWxlY3Rpb24oLi4ucCk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5jdXN0b21FbGVtZW50Q2IgPSAoLi4uYzIpID0+IHtcbiAgICBpZiAoaG9va3MuY3VzdG9tRWxlbWVudCkge1xuICAgICAgaG9va3MuY3VzdG9tRWxlbWVudCguLi5jMik7XG4gICAgfVxuICAgIGN1c3RvbUVsZW1lbnRDYiguLi5jMik7XG4gIH07XG59XG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8yLCBob29rcyA9IHt9KSB7XG4gIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBvMi5kb2MuZGVmYXVsdFZpZXc7XG4gIGlmICghY3VycmVudFdpbmRvdykge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBtZXJnZUhvb2tzKG8yLCBob29rcyk7XG4gIGxldCBtdXRhdGlvbk9ic2VydmVyO1xuICBpZiAobzIucmVjb3JkRE9NKSB7XG4gICAgbXV0YXRpb25PYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKG8yLCBvMi5kb2MpO1xuICB9XG4gIGNvbnN0IG1vdXNlbW92ZUhhbmRsZXIgPSBpbml0TW92ZU9ic2VydmVyKG8yKTtcbiAgY29uc3QgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgY29uc3Qgc2Nyb2xsSGFuZGxlciA9IGluaXRTY3JvbGxPYnNlcnZlcihvMik7XG4gIGNvbnN0IHZpZXdwb3J0UmVzaXplSGFuZGxlciA9IGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKG8yLCB7XG4gICAgd2luOiBjdXJyZW50V2luZG93XG4gIH0pO1xuICBjb25zdCBpbnB1dEhhbmRsZXIgPSBpbml0SW5wdXRPYnNlcnZlcihvMik7XG4gIGNvbnN0IG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyID0gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcihvMik7XG4gIGxldCBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gKCkgPT4ge1xuICB9O1xuICBsZXQgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gKCkgPT4ge1xuICB9O1xuICBsZXQgZm9udE9ic2VydmVyID0gKCkgPT4ge1xuICB9O1xuICBpZiAobzIucmVjb3JkRE9NKSB7XG4gICAgc3R5bGVTaGVldE9ic2VydmVyID0gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihvMiwgeyB3aW46IGN1cnJlbnRXaW5kb3cgfSk7XG4gICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9IGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKG8yLCBvMi5kb2MpO1xuICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9IGluaXRTdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIobzIsIHtcbiAgICAgIHdpbjogY3VycmVudFdpbmRvd1xuICAgIH0pO1xuICAgIGlmIChvMi5jb2xsZWN0Rm9udHMpIHtcbiAgICAgIGZvbnRPYnNlcnZlciA9IGluaXRGb250T2JzZXJ2ZXIobzIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxlY3Rpb25PYnNlcnZlciA9IGluaXRTZWxlY3Rpb25PYnNlcnZlcihvMik7XG4gIGNvbnN0IGN1c3RvbUVsZW1lbnRPYnNlcnZlciA9IGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIobzIpO1xuICBjb25zdCBwbHVnaW5IYW5kbGVycyA9IFtdO1xuICBmb3IgKGNvbnN0IHBsdWdpbjMgb2YgbzIucGx1Z2lucykge1xuICAgIHBsdWdpbkhhbmRsZXJzLnB1c2goXG4gICAgICBwbHVnaW4zLm9ic2VydmVyKHBsdWdpbjMuY2FsbGJhY2ssIGN1cnJlbnRXaW5kb3csIHBsdWdpbjMub3B0aW9ucylcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChiKSA9PiBiLnJlc2V0KCkpO1xuICAgIG11dGF0aW9uT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIG1vdXNlbW92ZUhhbmRsZXIoKTtcbiAgICBtb3VzZUludGVyYWN0aW9uSGFuZGxlcigpO1xuICAgIHNjcm9sbEhhbmRsZXIoKTtcbiAgICB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIoKTtcbiAgICBpbnB1dEhhbmRsZXIoKTtcbiAgICBtZWRpYUludGVyYWN0aW9uSGFuZGxlcigpO1xuICAgIHN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcbiAgICBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIoKTtcbiAgICBmb250T2JzZXJ2ZXIoKTtcbiAgICBzZWxlY3Rpb25PYnNlcnZlcigpO1xuICAgIGN1c3RvbUVsZW1lbnRPYnNlcnZlcigpO1xuICAgIHBsdWdpbkhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzTmVzdGVkQ1NTUnVsZShwcm9wKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgdHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBOb3RlOiBHZW5lcmFsbHksIHRoaXMgY2hlY2sgX3Nob3VsZG4ndF8gYmUgbmVjZXNzYXJ5XG4gICAgLy8gSG93ZXZlciwgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4ganNkb20pIHRoaXMgY2FuIHNvbWV0aW1lcyBmYWlsLCBzbyB3ZSBjaGVjayBmb3IgaXQgaGVyZVxuICAgIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiYgXCJpbnNlcnRSdWxlXCIgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImRlbGV0ZVJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlXG4gICk7XG59XG5jbGFzcyBDcm9zc09yaWdpbklmcmFtZU1pcnJvciB7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRlSWRGbikge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZnJhbWVJZFRvUmVtb3RlSWRNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZnJhbWVSZW1vdGVJZFRvSWRNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVJZEZuID0gZ2VuZXJhdGVJZEZuO1xuICB9XG4gIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcbiAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XG4gICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIGxldCBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gdGhpcy5nZW5lcmF0ZUlkRm4oKTtcbiAgICAgIGlkVG9SZW1vdGVJZE1hcC5zZXQocmVtb3RlSWQsIGlkKTtcbiAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGdldElkcyhpZnJhbWUsIHJlbW90ZUlkKSB7XG4gICAgY29uc3QgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIHJldHVybiByZW1vdGVJZC5tYXAoXG4gICAgICAoaWQpID0+IHRoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApXG4gICAgKTtcbiAgfVxuICBnZXRSZW1vdGVJZChpZnJhbWUsIGlkLCBtYXApIHtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSBtYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcIm51bWJlclwiKSByZXR1cm4gaWQ7XG4gICAgY29uc3QgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlbW90ZUlkKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHJlbW90ZUlkO1xuICB9XG4gIGdldFJlbW90ZUlkcyhpZnJhbWUsIGlkcykge1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiB0aGlzLmdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIHJlbW90ZUlkVG9JZE1hcCkpO1xuICB9XG4gIHJlc2V0KGlmcmFtZSkge1xuICAgIGlmICghaWZyYW1lKSB7XG4gICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gIH1cbiAgZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSkge1xuICAgIGxldCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5nZXQoaWZyYW1lKTtcbiAgICBpZiAoIWlkVG9SZW1vdGVJZE1hcCkge1xuICAgICAgaWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLnNldChpZnJhbWUsIGlkVG9SZW1vdGVJZE1hcCk7XG4gICAgfVxuICAgIHJldHVybiBpZFRvUmVtb3RlSWRNYXA7XG4gIH1cbiAgZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xuICAgIGxldCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcbiAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xuICAgICAgcmVtb3RlSWRUb0lkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XG4gIH1cbn1cbmNsYXNzIElmcmFtZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lTWlycm9yXCIsIG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5JZCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid3JhcHBlZEVtaXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvYWRMaXN0ZW5lclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3R5bGVzaGVldE1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY29yZENyb3NzT3JpZ2luSWZyYW1lc1wiKTtcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy53cmFwcGVkRW1pdCA9IG9wdGlvbnMud3JhcHBlZEVtaXQ7XG4gICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlciA9IG9wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgdGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBvcHRpb25zLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcztcbiAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IgPSBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IoXG4gICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yLmdlbmVyYXRlSWQuYmluZChcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG4gIGFkZElmcmFtZShpZnJhbWVFbCkge1xuICAgIHRoaXMuaWZyYW1lcy5zZXQoaWZyYW1lRWwsIHRydWUpO1xuICAgIGlmIChpZnJhbWVFbC5jb250ZW50V2luZG93KVxuICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcC5zZXQoaWZyYW1lRWwuY29udGVudFdpbmRvdywgaWZyYW1lRWwpO1xuICB9XG4gIGFkZExvYWRMaXN0ZW5lcihjYikge1xuICAgIHRoaXMubG9hZExpc3RlbmVyID0gY2I7XG4gIH1cbiAgYXR0YWNoSWZyYW1lKGlmcmFtZUVsLCBjaGlsZFNuKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgIGFkZHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXG4gICAgICAgICAgbmV4dElkOiBudWxsLFxuICAgICAgICAgIG5vZGU6IGNoaWxkU25cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgdGV4dHM6IFtdLFxuICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcylcbiAgICAgIChfYTIgPSBpZnJhbWVFbC5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibWVzc2FnZVwiLFxuICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKVxuICAgICAgKTtcbiAgICAoX2IgPSB0aGlzLmxvYWRMaXN0ZW5lcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgaWZyYW1lRWwpO1xuICAgIGlmIChpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQgJiYgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXG4gICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoXG4gICAgICAgIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsXG4gICAgICAgIHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudClcbiAgICAgICk7XG4gIH1cbiAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQgPSBtZXNzYWdlO1xuICAgIGlmIChjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLnR5cGUgIT09IFwicnJ3ZWJcIiB8fCAvLyBUbyBmaWx0ZXIgb3V0IHRoZSBycndlYiBtZXNzYWdlcyB3aGljaCBhcmUgZm9yd2FyZGVkIGJ5IHNvbWUgc2l0ZXMuXG4gICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQub3JpZ2luICE9PSBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLm9yaWdpbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpZnJhbWVTb3VyY2VXaW5kb3cgPSBtZXNzYWdlLnNvdXJjZTtcbiAgICBpZiAoIWlmcmFtZVNvdXJjZVdpbmRvdykgcmV0dXJuO1xuICAgIGNvbnN0IGlmcmFtZUVsID0gdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcC5nZXQobWVzc2FnZS5zb3VyY2UpO1xuICAgIGlmICghaWZyYW1lRWwpIHJldHVybjtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEV2ZW50ID0gdGhpcy50cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KFxuICAgICAgaWZyYW1lRWwsXG4gICAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmV2ZW50XG4gICAgKTtcbiAgICBpZiAodHJhbnNmb3JtZWRFdmVudClcbiAgICAgIHRoaXMud3JhcHBlZEVtaXQoXG4gICAgICAgIHRyYW5zZm9ybWVkRXZlbnQsXG4gICAgICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuaXNDaGVja291dFxuICAgICAgKTtcbiAgfVxuICB0cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBlMikge1xuICAgIHZhciBfYTI7XG4gICAgc3dpdGNoIChlMi50eXBlKSB7XG4gICAgICBjYXNlIEV2ZW50VHlwZS5GdWxsU25hcHNob3Q6IHtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGUyLmRhdGEubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICBjb25zdCByb290SWQgPSBlMi5kYXRhLm5vZGUuaWQ7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAuc2V0KGlmcmFtZUVsLCByb290SWQpO1xuICAgICAgICB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKGUyLmRhdGEubm9kZSwgcm9vdElkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IGUyLnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcbiAgICAgICAgICAgICAgICBuZXh0SWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbm9kZTogZTIuZGF0YS5ub2RlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZW1vdmVzOiBbXSxcbiAgICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIEV2ZW50VHlwZS5NZXRhOlxuICAgICAgY2FzZSBFdmVudFR5cGUuTG9hZDpcbiAgICAgIGNhc2UgRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQ6IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuUGx1Z2luOiB7XG4gICAgICAgIHJldHVybiBlMjtcbiAgICAgIH1cbiAgICAgIGNhc2UgRXZlbnRUeXBlLkN1c3RvbToge1xuICAgICAgICB0aGlzLnJlcGxhY2VJZHMoXG4gICAgICAgICAgZTIuZGF0YS5wYXlsb2FkLFxuICAgICAgICAgIGlmcmFtZUVsLFxuICAgICAgICAgIFtcImlkXCIsIFwicGFyZW50SWRcIiwgXCJwcmV2aW91c0lkXCIsIFwibmV4dElkXCJdXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlMjtcbiAgICAgIH1cbiAgICAgIGNhc2UgRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3Q6IHtcbiAgICAgICAgc3dpdGNoIChlMi5kYXRhLnNvdXJjZSkge1xuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb246IHtcbiAgICAgICAgICAgIGUyLmRhdGEuYWRkcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgXCJwYXJlbnRJZFwiLFxuICAgICAgICAgICAgICAgIFwibmV4dElkXCIsXG4gICAgICAgICAgICAgICAgXCJwcmV2aW91c0lkXCJcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKG4yLm5vZGUsIGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vdElkID0gdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5nZXQoaWZyYW1lRWwpO1xuICAgICAgICAgICAgICByb290SWQgJiYgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShuMi5ub2RlLCByb290SWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlMi5kYXRhLnJlbW92ZXMuZm9yRWFjaCgobjIpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1wicGFyZW50SWRcIiwgXCJpZFwiXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUyLmRhdGEuYXR0cmlidXRlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUyLmRhdGEudGV4dHMuZm9yRWFjaCgobjIpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRHJhZzpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZTpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZToge1xuICAgICAgICAgICAgZTIuZGF0YS5wb3NpdGlvbnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMocCwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlZpZXdwb3J0UmVzaXplOiB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbjpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb246XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGw6XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5DYW52YXNNdXRhdGlvbjpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLklucHV0OiB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZVNoZWV0UnVsZTpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcInN0eWxlSWRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkZvbnQ6IHtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb246IHtcbiAgICAgICAgICAgIGUyLmRhdGEucmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhyYW5nZSwgaWZyYW1lRWwsIFtcInN0YXJ0XCIsIFwiZW5kXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0OiB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXCJzdHlsZUlkc1wiXSk7XG4gICAgICAgICAgICAoX2EyID0gZTIuZGF0YS5zdHlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZm9yRWFjaCgoc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoc3R5bGUsIGlmcmFtZUVsLCBbXCJzdHlsZUlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVwbGFjZShpZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gXCJudW1iZXJcIikgY29udGludWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWRzKFxuICAgICAgICAgIGlmcmFtZUVsLFxuICAgICAgICAgIG9ialtrZXldXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZChpZnJhbWVFbCwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJlcGxhY2VJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XG4gIH1cbiAgcmVwbGFjZVN0eWxlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XG4gIH1cbiAgcmVwbGFjZUlkT25Ob2RlKG5vZGUyLCBpZnJhbWVFbCkge1xuICAgIHRoaXMucmVwbGFjZUlkcyhub2RlMiwgaWZyYW1lRWwsIFtcImlkXCIsIFwicm9vdElkXCJdKTtcbiAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZTIpIHtcbiAgICAgIG5vZGUyLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoY2hpbGQsIGlmcmFtZUVsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwYXRjaFJvb3RJZE9uTm9kZShub2RlMiwgcm9vdElkKSB7XG4gICAgaWYgKG5vZGUyLnR5cGUgIT09IE5vZGVUeXBlLkRvY3VtZW50ICYmICFub2RlMi5yb290SWQpIG5vZGUyLnJvb3RJZCA9IHJvb3RJZDtcbiAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZTIpIHtcbiAgICAgIG5vZGUyLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgU2hhZG93RG9tTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2hhZG93RG9tc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjcm9sbENiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJieXBhc3NPcHRpb25zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc3RvcmVIYW5kbGVyc1wiLCBbXSk7XG4gICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgIHRoaXMuc2Nyb2xsQ2IgPSBvcHRpb25zLnNjcm9sbENiO1xuICAgIHRoaXMuYnlwYXNzT3B0aW9ucyA9IG9wdGlvbnMuYnlwYXNzT3B0aW9ucztcbiAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMucGF0Y2hBdHRhY2hTaGFkb3coRWxlbWVudCwgZG9jdW1lbnQpO1xuICB9XG4gIGFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdDIsIGRvYykge1xuICAgIGlmICghaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdDIpKSByZXR1cm47XG4gICAgaWYgKHRoaXMuc2hhZG93RG9tcy5oYXMoc2hhZG93Um9vdDIpKSByZXR1cm47XG4gICAgdGhpcy5zaGFkb3dEb21zLmFkZChzaGFkb3dSb290Mik7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBpbml0TXV0YXRpb25PYnNlcnZlcihcbiAgICAgIHtcbiAgICAgICAgLi4udGhpcy5ieXBhc3NPcHRpb25zLFxuICAgICAgICBkb2MsXG4gICAgICAgIG11dGF0aW9uQ2I6IHRoaXMubXV0YXRpb25DYixcbiAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgc2hhZG93RG9tTWFuYWdlcjogdGhpc1xuICAgICAgfSxcbiAgICAgIHNoYWRvd1Jvb3QyXG4gICAgKTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKCgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChcbiAgICAgIGluaXRTY3JvbGxPYnNlcnZlcih7XG4gICAgICAgIC4uLnRoaXMuYnlwYXNzT3B0aW9ucyxcbiAgICAgICAgc2Nyb2xsQ2I6IHRoaXMuc2Nyb2xsQ2IsXG4gICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3ByYXZlZW5wdWdsaWEvMDgzMmRhNjg3ZWQ1YTVkN2EwOTA3MDQ2YzllZjE4MTNcbiAgICAgICAgLy8gc2Nyb2xsIGlzIG5vdCBhbGxvd2VkIHRvIHBhc3MgdGhlIGJvdW5kYXJ5LCBzbyB3ZSBuZWVkIHRvIGxpc3RlbiB0aGUgc2hhZG93IGRvY3VtZW50XG4gICAgICAgIGRvYzogc2hhZG93Um9vdDIsXG4gICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMgJiYgc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXG4gICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKFxuICAgICAgICAgIHNoYWRvd1Jvb3QyLmFkb3B0ZWRTdHlsZVNoZWV0cyxcbiAgICAgICAgICB0aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KHNoYWRvd1Jvb3QyKSlcbiAgICAgICAgKTtcbiAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICAgIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaGFkb3dSb290MlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBNb25rZXkgcGF0Y2ggJ2F0dGFjaFNoYWRvdycgb2YgYW4gSUZyYW1lRWxlbWVudCB0byBvYnNlcnZlIG5ld2x5IGFkZGVkIHNoYWRvdyBkb21zLlxuICAgKi9cbiAgb2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50KSB7XG4gICAgaWYgKCFpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgIWlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KSByZXR1cm47XG4gICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhcbiAgICAgIGlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdy5FbGVtZW50LFxuICAgICAgaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaCAnYXR0YWNoU2hhZG93JyB0byBvYnNlcnZlIG5ld2x5IGFkZGVkIHNoYWRvdyBkb21zLlxuICAgKi9cbiAgcGF0Y2hBdHRhY2hTaGFkb3coZWxlbWVudCwgZG9jKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXM7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChcbiAgICAgIHBhdGNoKFxuICAgICAgICBlbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgXCJhdHRhY2hTaGFkb3dcIixcbiAgICAgICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBzUm9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3RFbCA9IGluZGV4LnNoYWRvd1Jvb3QodGhpcyk7XG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdEVsICYmIGluRG9tKHRoaXMpKVxuICAgICAgICAgICAgICBtYW5hZ2VyLmFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdEVsLCBkb2MpO1xuICAgICAgICAgICAgcmV0dXJuIHNSb290O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcbiAgICB0aGlzLnNoYWRvd0RvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgfVxufVxudmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGFycy5sZW5ndGg7IGkkMSsrKSB7XG4gIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkkMSldID0gaSQxO1xufVxudmFyIGVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcbiAgZm9yIChpMiA9IDA7IGkyIDwgbGVuOyBpMiArPSAzKSB7XG4gICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTtcbiAgICBiYXNlNjQgKz0gY2hhcnNbKGJ5dGVzW2kyXSAmIDMpIDw8IDQgfCBieXRlc1tpMiArIDFdID4+IDRdO1xuICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaTIgKyAxXSAmIDE1KSA8PCAyIHwgYnl0ZXNbaTIgKyAyXSA+PiA2XTtcbiAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTtcbiAgfVxuICBpZiAobGVuICUgMyA9PT0gMikge1xuICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICB9XG4gIHJldHVybiBiYXNlNjQ7XG59O1xuY29uc3QgY2FudmFzVmFyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHZhcmlhYmxlTGlzdEZvciQxKGN0eCwgY3Rvcikge1xuICBsZXQgY29udGV4dE1hcCA9IGNhbnZhc1Zhck1hcC5nZXQoY3R4KTtcbiAgaWYgKCFjb250ZXh0TWFwKSB7XG4gICAgY29udGV4dE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY2FudmFzVmFyTWFwLnNldChjdHgsIGNvbnRleHRNYXApO1xuICB9XG4gIGlmICghY29udGV4dE1hcC5oYXMoY3RvcikpIHtcbiAgICBjb250ZXh0TWFwLnNldChjdG9yLCBbXSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRNYXAuZ2V0KGN0b3IpO1xufVxuY29uc3Qgc2F2ZVdlYkdMVmFyID0gKHZhbHVlLCB3aW4sIGN0eCkgPT4ge1xuICBpZiAoIXZhbHVlIHx8ICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICBjb25zdCBsaXN0MiA9IHZhcmlhYmxlTGlzdEZvciQxKGN0eCwgbmFtZSk7XG4gIGxldCBpbmRleDIgPSBsaXN0Mi5pbmRleE9mKHZhbHVlKTtcbiAgaWYgKGluZGV4MiA9PT0gLTEpIHtcbiAgICBpbmRleDIgPSBsaXN0Mi5sZW5ndGg7XG4gICAgbGlzdDIucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGluZGV4Mjtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVBcmcodmFsdWUsIHdpbiwgY3R4KSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoYXJnKSA9PiBzZXJpYWxpemVBcmcoYXJnLCB3aW4sIGN0eCkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50MTZBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBhcmdzOiBbT2JqZWN0LnZhbHVlcyh2YWx1ZSldXG4gICAgfTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBTaGFyZWRBcnJheUJ1ZmZlciBkaXNhYmxlZCBvbiBtb3N0IGJyb3dzZXJzIGR1ZSB0byBzcGVjdHJlLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2hhcmVkQXJyYXlCdWZmZXIvU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAvLyB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyIHx8XG4gICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICApIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgYmFzZTY0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcbiAgICAgICAgdmFsdWUuYnl0ZU9mZnNldCxcbiAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgXVxuICAgIH07XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgY29uc3QgeyBzcmMgfSA9IHZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgY29uc3QgbmFtZSA9IFwiSFRNTEltYWdlRWxlbWVudFwiO1xuICAgIGNvbnN0IHNyYyA9IHZhbHVlLnRvRGF0YVVSTCgpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgYXJnczogW3NlcmlhbGl6ZUFyZyh2YWx1ZS5kYXRhLCB3aW4sIGN0eCksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCBpbmRleDIgPSBzYXZlV2ViR0xWYXIodmFsdWUsIHdpbiwgY3R4KTtcbiAgICByZXR1cm4ge1xuICAgICAgcnJfdHlwZTogbmFtZSxcbiAgICAgIGluZGV4OiBpbmRleDJcbiAgICB9O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHNlcmlhbGl6ZUFyZ3MgPSAoYXJncywgd2luLCBjdHgpID0+IHtcbiAgcmV0dXJuIGFyZ3MubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XG59O1xuY29uc3QgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSAodmFsdWUsIHdpbikgPT4ge1xuICBjb25zdCB3ZWJHTENvbnN0cnVjdG9yTmFtZXMgPSBbXG4gICAgXCJXZWJHTEFjdGl2ZUluZm9cIixcbiAgICBcIldlYkdMQnVmZmVyXCIsXG4gICAgXCJXZWJHTEZyYW1lYnVmZmVyXCIsXG4gICAgXCJXZWJHTFByb2dyYW1cIixcbiAgICBcIldlYkdMUmVuZGVyYnVmZmVyXCIsXG4gICAgXCJXZWJHTFNoYWRlclwiLFxuICAgIFwiV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXRcIixcbiAgICBcIldlYkdMVGV4dHVyZVwiLFxuICAgIFwiV2ViR0xVbmlmb3JtTG9jYXRpb25cIixcbiAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RcIixcbiAgICAvLyBJbiBvbGQgQ2hyb21lIHZlcnNpb25zLCB2YWx1ZSB3b24ndCBiZSBhbiBpbnN0YW5jZW9mIFdlYkdMVmVydGV4QXJyYXlPYmplY3QuXG4gICAgXCJXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTXCJcbiAgXTtcbiAgY29uc3Qgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gd2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbHRlcihcbiAgICAobmFtZSkgPT4gdHlwZW9mIHdpbltuYW1lXSA9PT0gXCJmdW5jdGlvblwiXG4gICk7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKFxuICAgICAgKG5hbWUpID0+IHZhbHVlIGluc3RhbmNlb2Ygd2luW25hbWVdXG4gICAgKVxuICApO1xufTtcbmZ1bmN0aW9uIGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBjb25zdCBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXG4gICAgd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVcbiAgKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzMkQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtwcm9wXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICAgICAgd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKFxuICAgICAgICB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAge1xuICAgICAgICAgIHNldCh2Mikge1xuICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgYXJnczogW3YyXSxcbiAgICAgICAgICAgICAgc2V0dGVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKSB7XG4gIHJldHVybiBjb250ZXh0VHlwZSA9PT0gXCJleHBlcmltZW50YWwtd2ViZ2xcIiA/IFwid2ViZ2xcIiA6IGNvbnRleHRUeXBlO1xufVxuZnVuY3Rpb24gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHNldFByZXNlcnZlRHJhd2luZ0J1ZmZlclRvVHJ1ZSkge1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goXG4gICAgICB3aW4uSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLFxuICAgICAgXCJnZXRDb250ZXh0XCIsXG4gICAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIShcIl9fY29udGV4dFwiIGluIHRoaXMpKSB0aGlzLl9fY29udGV4dCA9IGN0eE5hbWU7XG4gICAgICAgICAgICBpZiAoc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlICYmIFtcIndlYmdsXCIsIFwid2ViZ2wyXCJdLmluY2x1ZGVzKGN0eE5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCB7XG4gICAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2NvbnRleHRUeXBlLCAuLi5hcmdzXSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgfSBjYXRjaCB7XG4gICAgY29uc29sZS5lcnJvcihcImZhaWxlZCB0byBwYXRjaCBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dFwiKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBwYXRjaEdMUHJvdG90eXBlKHByb3RvdHlwZSwgdHlwZSwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHdpbikge1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvdHlwZSk7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgIGlmIChcbiAgICAgIC8vcHJvcC5zdGFydHNXaXRoKCdnZXQnKSB8fCAgLy8gZS5nLiBnZXRQcm9ncmFtUGFyYW1ldGVyLCBidXQgdG9vIHJpc2t5XG4gICAgICBbXG4gICAgICAgIFwiaXNDb250ZXh0TG9zdFwiLFxuICAgICAgICBcImNhbnZhc1wiLFxuICAgICAgICBcImRyYXdpbmdCdWZmZXJXaWR0aFwiLFxuICAgICAgICBcImRyYXdpbmdCdWZmZXJIZWlnaHRcIlxuICAgICAgXS5pbmNsdWRlcyhwcm9wKVxuICAgICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvdHlwZVtwcm9wXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICAgICAgcHJvdG90eXBlLFxuICAgICAgICBwcm9wLFxuICAgICAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQyID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBzYXZlV2ViR0xWYXIocmVzdWx0Miwgd2luLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChcInRhZ05hbWVcIiBpbiB0aGlzLmNhbnZhcyAmJiAhaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICBjb25zdCByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIG11dGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnN0IGhvb2tIYW5kbGVyID0gaG9va1NldHRlcihwcm90b3R5cGUsIHByb3AsIHtcbiAgICAgICAgc2V0KHYyKSB7XG4gICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgIGFyZ3M6IFt2Ml0sXG4gICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXJzO1xufVxuZnVuY3Rpb24gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIGhhbmRsZXJzLnB1c2goXG4gICAgLi4ucGF0Y2hHTFByb3RvdHlwZShcbiAgICAgIHdpbi5XZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLFxuICAgICAgQ2FudmFzQ29udGV4dC5XZWJHTCxcbiAgICAgIGNiLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB3aW5cbiAgICApXG4gICk7XG4gIGlmICh0eXBlb2Ygd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgLi4ucGF0Y2hHTFByb3RvdHlwZShcbiAgICAgICAgd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLFxuICAgICAgICBDYW52YXNDb250ZXh0LldlYkdMMixcbiAgICAgICAgY2IsXG4gICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgIHdpblxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9O1xufVxuY29uc3QgZW5jb2RlZEpzID0gXCJLR1oxYm1OMGFXOXVLQ2tnZXdvZ0lDSjFjMlVnYzNSeWFXTjBJanNLSUNCMllYSWdZMmhoY25NZ1BTQWlRVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMVJWVmxkWVdWcGhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVqQXhNak0wTlRZM09Ea3JMeUk3Q2lBZ2RtRnlJR3h2YjJ0MWNDQTlJSFI1Y0dWdlppQlZhVzUwT0VGeWNtRjVJRDA5UFNBaWRXNWtaV1pwYm1Wa0lpQS9JRnRkSURvZ2JtVjNJRlZwYm5RNFFYSnlZWGtvTWpVMktUc0tJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdOb1lYSnpMbXhsYm1kMGFEc2dhU3NyS1NCN0NpQWdJQ0JzYjI5cmRYQmJZMmhoY25NdVkyaGhja052WkdWQmRDaHBLVjBnUFNCcE93b2dJSDBLSUNCMllYSWdaVzVqYjJSbElEMGdablZ1WTNScGIyNG9ZWEp5WVhsaWRXWm1aWElwSUhzS0lDQWdJSFpoY2lCaWVYUmxjeUE5SUc1bGR5QlZhVzUwT0VGeWNtRjVLR0Z5Y21GNVluVm1abVZ5S1N3Z2FUSXNJR3hsYmlBOUlHSjVkR1Z6TG14bGJtZDBhQ3dnWW1GelpUWTBJRDBnSWlJN0NpQWdJQ0JtYjNJZ0tHa3lJRDBnTURzZ2FUSWdQQ0JzWlc0N0lHa3lJQ3M5SURNcElIc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6VzJKNWRHVnpXMmt5WFNBK1BpQXlYVHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKeld5aGllWFJsYzF0cE1sMGdKaUF6S1NBOFBDQTBJSHdnWW5sMFpYTmJhVElnS3lBeFhTQStQaUEwWFRzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXeWhpZVhSbGMxdHBNaUFySURGZElDWWdNVFVwSUR3OElESWdmQ0JpZVhSbGMxdHBNaUFySURKZElENCtJRFpkT3dvZ0lDQWdJQ0JpWVhObE5qUWdLejBnWTJoaGNuTmJZbmwwWlhOYmFUSWdLeUF5WFNBbUlEWXpYVHNLSUNBZ0lIMEtJQ0FnSUdsbUlDaHNaVzRnSlNBeklEMDlQU0F5S1NCN0NpQWdJQ0FnSUdKaGMyVTJOQ0E5SUdKaGMyVTJOQzV6ZFdKemRISnBibWNvTUN3Z1ltRnpaVFkwTG14bGJtZDBhQ0F0SURFcElDc2dJajBpT3dvZ0lDQWdmU0JsYkhObElHbG1JQ2hzWlc0Z0pTQXpJRDA5UFNBeEtTQjdDaUFnSUNBZ0lHSmhjMlUyTkNBOUlHSmhjMlUyTkM1emRXSnpkSEpwYm1jb01Dd2dZbUZ6WlRZMExteGxibWQwYUNBdElESXBJQ3NnSWowOUlqc0tJQ0FnSUgwS0lDQWdJSEpsZEhWeWJpQmlZWE5sTmpRN0NpQWdmVHNLSUNCamIyNXpkQ0JzWVhOMFFteHZZazFoY0NBOUlDOHFJRUJmWDFCVlVrVmZYeUFxTHlCdVpYY2dUV0Z3S0NrN0NpQWdZMjl1YzNRZ2RISmhibk53WVhKbGJuUkNiRzlpVFdGd0lEMGdMeW9nUUY5ZlVGVlNSVjlmSUNvdklHNWxkeUJOWVhBb0tUc0tJQ0JoYzNsdVl5Qm1kVzVqZEdsdmJpQm5aWFJVY21GdWMzQmhjbVZ1ZEVKc2IySkdiM0lvZDJsa2RHZ3NJR2hsYVdkb2RDd2daR0YwWVZWU1RFOXdkR2x2Ym5NcElIc0tJQ0FnSUdOdmJuTjBJR2xrSUQwZ1lDUjdkMmxrZEdoOUxTUjdhR1ZwWjJoMGZXQTdDaUFnSUNCcFppQW9JazltWm5OamNtVmxia05oYm5aaGN5SWdhVzRnWjJ4dlltRnNWR2hwY3lrZ2V3b2dJQ0FnSUNCcFppQW9kSEpoYm5Od1lYSmxiblJDYkc5aVRXRndMbWhoY3locFpDa3BJSEpsZEhWeWJpQjBjbUZ1YzNCaGNtVnVkRUpzYjJKTllYQXVaMlYwS0dsa0tUc0tJQ0FnSUNBZ1kyOXVjM1FnYjJabWMyTnlaV1Z1SUQwZ2JtVjNJRTltWm5OamNtVmxia05oYm5aaGN5aDNhV1IwYUN3Z2FHVnBaMmgwS1RzS0lDQWdJQ0FnYjJabWMyTnlaV1Z1TG1kbGRFTnZiblJsZUhRb0lqSmtJaWs3Q2lBZ0lDQWdJR052Ym5OMElHSnNiMklnUFNCaGQyRnBkQ0J2Wm1aelkzSmxaVzR1WTI5dWRtVnlkRlJ2UW14dllpaGtZWFJoVlZKTVQzQjBhVzl1Y3lrN0NpQWdJQ0FnSUdOdmJuTjBJR0Z5Y21GNVFuVm1abVZ5SUQwZ1lYZGhhWFFnWW14dllpNWhjbkpoZVVKMVptWmxjaWdwT3dvZ0lDQWdJQ0JqYjI1emRDQmlZWE5sTmpRZ1BTQmxibU52WkdVb1lYSnlZWGxDZFdabVpYSXBPd29nSUNBZ0lDQjBjbUZ1YzNCaGNtVnVkRUpzYjJKTllYQXVjMlYwS0dsa0xDQmlZWE5sTmpRcE93b2dJQ0FnSUNCeVpYUjFjbTRnWW1GelpUWTBPd29nSUNBZ2ZTQmxiSE5sSUhzS0lDQWdJQ0FnY21WMGRYSnVJQ0lpT3dvZ0lDQWdmUW9nSUgwS0lDQmpiMjV6ZENCM2IzSnJaWElnUFNCelpXeG1Pd29nSUhkdmNtdGxjaTV2Ym0xbGMzTmhaMlVnUFNCaGMzbHVZeUJtZFc1amRHbHZiaWhsS1NCN0NpQWdJQ0JwWmlBb0lrOW1abk5qY21WbGJrTmhiblpoY3lJZ2FXNGdaMnh2WW1Gc1ZHaHBjeWtnZXdvZ0lDQWdJQ0JqYjI1emRDQjdJR2xrTENCaWFYUnRZWEFzSUhkcFpIUm9MQ0JvWldsbmFIUXNJR1JoZEdGVlVreFBjSFJwYjI1eklIMGdQU0JsTG1SaGRHRTdDaUFnSUNBZ0lHTnZibk4wSUhSeVlXNXpjR0Z5Wlc1MFFtRnpaVFkwSUQwZ1oyVjBWSEpoYm5Od1lYSmxiblJDYkc5aVJtOXlLQW9nSUNBZ0lDQWdJSGRwWkhSb0xBb2dJQ0FnSUNBZ0lHaGxhV2RvZEN3S0lDQWdJQ0FnSUNCa1lYUmhWVkpNVDNCMGFXOXVjd29nSUNBZ0lDQXBPd29nSUNBZ0lDQmpiMjV6ZENCdlptWnpZM0psWlc0Z1BTQnVaWGNnVDJabWMyTnlaV1Z1UTJGdWRtRnpLSGRwWkhSb0xDQm9aV2xuYUhRcE93b2dJQ0FnSUNCamIyNXpkQ0JqZEhnZ1BTQnZabVp6WTNKbFpXNHVaMlYwUTI5dWRHVjRkQ2dpTW1RaUtUc0tJQ0FnSUNBZ1kzUjRMbVJ5WVhkSmJXRm5aU2hpYVhSdFlYQXNJREFzSURBcE93b2dJQ0FnSUNCaWFYUnRZWEF1WTJ4dmMyVW9LVHNLSUNBZ0lDQWdZMjl1YzNRZ1lteHZZaUE5SUdGM1lXbDBJRzltWm5OamNtVmxiaTVqYjI1MlpYSjBWRzlDYkc5aUtHUmhkR0ZWVWt4UGNIUnBiMjV6S1RzS0lDQWdJQ0FnWTI5dWMzUWdkSGx3WlNBOUlHSnNiMkl1ZEhsd1pUc0tJQ0FnSUNBZ1kyOXVjM1FnWVhKeVlYbENkV1ptWlhJZ1BTQmhkMkZwZENCaWJHOWlMbUZ5Y21GNVFuVm1abVZ5S0NrN0NpQWdJQ0FnSUdOdmJuTjBJR0poYzJVMk5DQTlJR1Z1WTI5a1pTaGhjbkpoZVVKMVptWmxjaWs3Q2lBZ0lDQWdJR2xtSUNnaGJHRnpkRUpzYjJKTllYQXVhR0Z6S0dsa0tTQW1KaUJoZDJGcGRDQjBjbUZ1YzNCaGNtVnVkRUpoYzJVMk5DQTlQVDBnWW1GelpUWTBLU0I3Q2lBZ0lDQWdJQ0FnYkdGemRFSnNiMkpOWVhBdWMyVjBLR2xrTENCaVlYTmxOalFwT3dvZ0lDQWdJQ0FnSUhKbGRIVnliaUIzYjNKclpYSXVjRzl6ZEUxbGMzTmhaMlVvZXlCcFpDQjlLVHNLSUNBZ0lDQWdmUW9nSUNBZ0lDQnBaaUFvYkdGemRFSnNiMkpOWVhBdVoyVjBLR2xrS1NBOVBUMGdZbUZ6WlRZMEtTQnlaWFIxY200Z2QyOXlhMlZ5TG5CdmMzUk5aWE56WVdkbEtIc2dhV1FnZlNrN0NpQWdJQ0FnSUhkdmNtdGxjaTV3YjNOMFRXVnpjMkZuWlNoN0NpQWdJQ0FnSUNBZ2FXUXNDaUFnSUNBZ0lDQWdkSGx3WlN3S0lDQWdJQ0FnSUNCaVlYTmxOalFzQ2lBZ0lDQWdJQ0FnZDJsa2RHZ3NDaUFnSUNBZ0lDQWdhR1ZwWjJoMENpQWdJQ0FnSUgwcE93b2dJQ0FnSUNCc1lYTjBRbXh2WWsxaGNDNXpaWFFvYVdRc0lHSmhjMlUyTkNrN0NpQWdJQ0I5SUdWc2MyVWdld29nSUNBZ0lDQnlaWFIxY200Z2QyOXlhMlZ5TG5CdmMzUk5aWE56WVdkbEtIc2dhV1E2SUdVdVpHRjBZUzVwWkNCOUtUc0tJQ0FnSUgwS0lDQjlPd3A5S1NncE93b3ZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDFwYldGblpTMWlhWFJ0WVhBdFpHRjBZUzExY213dGQyOXlhMlZ5TFVsS2NFTTNaMTlpTG1wekxtMWhjQW89XCI7XG5jb25zdCBkZWNvZGVCYXNlNjQgPSAoYmFzZTY0KSA9PiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjQpLCAoYzIpID0+IGMyLmNoYXJDb2RlQXQoMCkpO1xuY29uc3QgYmxvYiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LkJsb2IgJiYgbmV3IEJsb2IoW2RlY29kZUJhc2U2NChlbmNvZGVkSnMpXSwgeyB0eXBlOiBcInRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04XCIgfSk7XG5mdW5jdGlvbiBXb3JrZXJXcmFwcGVyKG9wdGlvbnMpIHtcbiAgbGV0IG9ialVSTDtcbiAgdHJ5IHtcbiAgICBvYmpVUkwgPSBibG9iICYmICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBpZiAoIW9ialVSTCkgdGhyb3cgXCJcIjtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKG9ialVSTCwge1xuICAgICAgbmFtZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lXG4gICAgfSk7XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwob2JqVVJMKTtcbiAgICB9KTtcbiAgICByZXR1cm4gd29ya2VyO1xuICB9IGNhdGNoIChlMikge1xuICAgIHJldHVybiBuZXcgV29ya2VyKFxuICAgICAgXCJkYXRhOnRleHQvamF2YXNjcmlwdDtiYXNlNjQsXCIgKyBlbmNvZGVkSnMsXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZVxuICAgICAgfVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgb2JqVVJMICYmICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICB9XG59XG5jbGFzcyBDYW52YXNNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwZW5kaW5nQ2FudmFzTXV0YXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyYWZTdGFtcHNcIiwgeyBsYXRlc3RJZDogMCwgaW52b2tlSWQ6IG51bGwgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzZXRPYnNlcnZlcnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZyb3plblwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvY2tlZFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NNdXRhdGlvblwiLCAodGFyZ2V0LCBtdXRhdGlvbikgPT4ge1xuICAgICAgY29uc3QgbmV3RnJhbWUgPSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZCAmJiB0aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCAhPT0gdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQ7XG4gICAgICBpZiAobmV3RnJhbWUgfHwgIXRoaXMucmFmU3RhbXBzLmludm9rZUlkKVxuICAgICAgICB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZCA9IHRoaXMucmFmU3RhbXBzLmxhdGVzdElkO1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLnNldCh0YXJnZXQsIFtdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQodGFyZ2V0KS5wdXNoKG11dGF0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBzYW1wbGluZyA9IFwiYWxsXCIsXG4gICAgICB3aW4sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGRhdGFVUkxPcHRpb25zXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgaWYgKHJlY29yZENhbnZhcyAmJiBzYW1wbGluZyA9PT0gXCJhbGxcIilcbiAgICAgIHRoaXMuaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgICBpZiAocmVjb3JkQ2FudmFzICYmIHR5cGVvZiBzYW1wbGluZyA9PT0gXCJudW1iZXJcIilcbiAgICAgIHRoaXMuaW5pdENhbnZhc0ZQU09ic2VydmVyKHNhbXBsaW5nLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHtcbiAgICAgICAgZGF0YVVSTE9wdGlvbnNcbiAgICAgIH0pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgJiYgdGhpcy5yZXNldE9ic2VydmVycygpO1xuICB9XG4gIGZyZWV6ZSgpIHtcbiAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gIH1cbiAgdW5mcmVlemUoKSB7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgfVxuICBsb2NrKCkge1xuICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgfVxuICB1bmxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgfVxuICBpbml0Q2FudmFzRlBTT2JzZXJ2ZXIoZnBzLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKFxuICAgICAgd2luLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXJXcmFwcGVyKCk7XG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IChlMikgPT4ge1xuICAgICAgY29uc3QgeyBpZCB9ID0gZTIuZGF0YTtcbiAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcbiAgICAgIGlmICghKFwiYmFzZTY0XCIgaW4gZTIuZGF0YSkpIHJldHVybjtcbiAgICAgIGNvbnN0IHsgYmFzZTY0LCB0eXBlLCB3aWR0aCwgaGVpZ2h0IH0gPSBlMi5kYXRhO1xuICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgY29tbWFuZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJjbGVhclJlY3RcIixcbiAgICAgICAgICAgIC8vIHdpcGUgY2FudmFzXG4gICAgICAgICAgICBhcmdzOiBbMCwgMCwgd2lkdGgsIGhlaWdodF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImRyYXdJbWFnZVwiLFxuICAgICAgICAgICAgLy8gZHJhd3MgKHNlbWktdHJhbnNwYXJlbnQpIGltYWdlXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBycl90eXBlOiBcIkltYWdlQml0bWFwXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBycl90eXBlOiBcIkJsb2JcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW3sgcnJfdHlwZTogXCJBcnJheUJ1ZmZlclwiLCBiYXNlNjQgfV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGltZUJldHdlZW5TbmFwc2hvdHMgPSAxZTMgLyBmcHM7XG4gICAgbGV0IGxhc3RTbmFwc2hvdFRpbWUgPSAwO1xuICAgIGxldCByYWZJZDtcbiAgICBjb25zdCBnZXRDYW52YXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVkQ2FudmFzID0gW107XG4gICAgICB3aW4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKS5mb3JFYWNoKChjYW52YXMpID0+IHtcbiAgICAgICAgaWYgKCFpc0Jsb2NrZWQoY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXRjaGVkQ2FudmFzO1xuICAgIH07XG4gICAgY29uc3QgdGFrZUNhbnZhc1NuYXBzaG90cyA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgIGlmIChsYXN0U25hcHNob3RUaW1lICYmIHRpbWVzdGFtcCAtIGxhc3RTbmFwc2hvdFRpbWUgPCB0aW1lQmV0d2VlblNuYXBzaG90cykge1xuICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFzdFNuYXBzaG90VGltZSA9IHRpbWVzdGFtcDtcbiAgICAgIGdldENhbnZhcygpLmZvckVhY2goYXN5bmMgKGNhbnZhcykgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XG4gICAgICAgIGlmIChzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuZ2V0KGlkKSkgcmV0dXJuO1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApIHJldHVybjtcbiAgICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChbXCJ3ZWJnbFwiLCBcIndlYmdsMlwiXS5pbmNsdWRlcyhjYW52YXMuX19jb250ZXh0KSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChjYW52YXMuX19jb250ZXh0KTtcbiAgICAgICAgICBpZiAoKChfYTIgPSBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucHJlc2VydmVEcmF3aW5nQnVmZmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXIoY29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzKTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYml0bWFwLFxuICAgICAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBvcHRpb25zLmRhdGFVUkxPcHRpb25zXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbYml0bWFwXVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICB9O1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSAoKSA9PiB7XG4gICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICB9O1xuICB9XG4gIGluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICAgIHRoaXMuc3RhcnRSQUZUaW1lc3RhbXBpbmcoKTtcbiAgICB0aGlzLnN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpO1xuICAgIGNvbnN0IGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIoXG4gICAgICB3aW4sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBjb25zdCBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcihcbiAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uLmJpbmQodGhpcyksXG4gICAgICB3aW4sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvclxuICAgICk7XG4gICAgY29uc3QgY2FudmFzV2ViR0wxYW5kMlJlc2V0ID0gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihcbiAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uLmJpbmQodGhpcyksXG4gICAgICB3aW4sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvclxuICAgICk7XG4gICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcbiAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgY2FudmFzMkRSZXNldCgpO1xuICAgICAgY2FudmFzV2ViR0wxYW5kMlJlc2V0KCk7XG4gICAgfTtcbiAgfVxuICBzdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xuICB9XG4gIHN0YXJ0UkFGVGltZXN0YW1waW5nKCkge1xuICAgIGNvbnN0IHNldExhdGVzdFJBRlRpbWVzdGFtcCA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkID0gdGltZXN0YW1wO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XG4gICAgfTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgfVxuICBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmZvckVhY2goXG4gICAgICAoX3ZhbHVlcywgY2FudmFzKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcbiAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpKTtcbiAgfVxuICBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKSB7XG4gICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlc1dpdGhUeXBlID0gdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldChjYW52YXMpO1xuICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKSByZXR1cm47XG4gICAgY29uc3QgdmFsdWVzID0gdmFsdWVzV2l0aFR5cGUubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlOiB0eXBlMiwgLi4ucmVzdCB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9KTtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHZhbHVlc1dpdGhUeXBlWzBdO1xuICAgIHRoaXMubXV0YXRpb25DYih7IGlkLCB0eXBlLCBjb21tYW5kczogdmFsdWVzIH0pO1xuICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5kZWxldGUoY2FudmFzKTtcbiAgfVxufVxuY2xhc3MgU3R5bGVzaGVldE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRyYWNrZWRMaW5rRWxlbWVudHNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZG9wdGVkU3R5bGVTaGVldENiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZU1pcnJvclwiLCBuZXcgU3R5bGVTaGVldE1pcnJvcigpKTtcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiID0gb3B0aW9ucy5hZG9wdGVkU3R5bGVTaGVldENiO1xuICB9XG4gIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xuICAgIGlmIChcIl9jc3NUZXh0XCIgaW4gY2hpbGRTbi5hdHRyaWJ1dGVzKVxuICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgYWRkczogW10sXG4gICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICB0ZXh0czogW10sXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGNoaWxkU24uYXR0cmlidXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgdGhpcy50cmFja0xpbmtFbGVtZW50KGxpbmtFbCk7XG4gIH1cbiAgdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcbiAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKSByZXR1cm47XG4gICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xuICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xuICB9XG4gIGFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpIHtcbiAgICBpZiAoc2hlZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSA9IHtcbiAgICAgIGlkOiBob3N0SWQsXG4gICAgICBzdHlsZUlkczogW11cbiAgICB9O1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2hlZXQgb2Ygc2hlZXRzKSB7XG4gICAgICBsZXQgc3R5bGVJZDtcbiAgICAgIGlmICghdGhpcy5zdHlsZU1pcnJvci5oYXMoc2hlZXQpKSB7XG4gICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XG4gICAgICAgIHN0eWxlcy5wdXNoKHtcbiAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgIHJ1bGVzOiBBcnJheS5mcm9tKHNoZWV0LnJ1bGVzIHx8IENTU1J1bGUsIChyMiwgaW5kZXgyKSA9PiAoe1xuICAgICAgICAgICAgcnVsZTogc3RyaW5naWZ5UnVsZShyMiwgc2hlZXQuaHJlZiksXG4gICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcbiAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZUlkcy5wdXNoKHN0eWxlSWQpO1xuICAgIH1cbiAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZXMgPSBzdHlsZXM7XG4gICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiKGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZU1pcnJvci5yZXNldCgpO1xuICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICB9XG4gIC8vIFRPRE86IHRha2Ugc25hcHNob3Qgb24gc3R5bGVzaGVldCByZWxvYWQgYnkgYXBwbHlpbmcgZXZlbnQgbGlzdGVuZXJcbiAgdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChfbGlua0VsKSB7XG4gIH1cbn1cbmNsYXNzIFByb2Nlc3NlZE5vZGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5vZGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhY3RpdmVcIiwgZmFsc2UpO1xuICB9XG4gIGluT3RoZXJCdWZmZXIobm9kZTIsIHRoaXNCdWZmZXIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gdGhpcy5ub2RlTWFwLmdldChub2RlMik7XG4gICAgcmV0dXJuIGJ1ZmZlcnMgJiYgQXJyYXkuZnJvbShidWZmZXJzKS5zb21lKChidWZmZXIpID0+IGJ1ZmZlciAhPT0gdGhpc0J1ZmZlcik7XG4gIH1cbiAgYWRkKG5vZGUyLCBidWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUyLCAodGhpcy5ub2RlTWFwLmdldChub2RlMikgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkuYWRkKGJ1ZmZlcikpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cbmxldCB3cmFwcGVkRW1pdDtcbmxldCB0YWtlRnVsbFNuYXBzaG90JDE7XG5sZXQgY2FudmFzTWFuYWdlcjtcbmxldCByZWNvcmRpbmcgPSBmYWxzZTtcbnRyeSB7XG4gIGlmIChBcnJheS5mcm9tKFsxXSwgKHgyKSA9PiB4MiAqIDIpWzBdICE9PSAyKSB7XG4gICAgY29uc3QgY2xlYW5GcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbGVhbkZyYW1lKTtcbiAgICBBcnJheS5mcm9tID0gKChfYSA9IGNsZWFuRnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLkFycmF5LmZyb20pIHx8IEFycmF5LmZyb207XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjbGVhbkZyYW1lKTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIGNvbnNvbGUuZGVidWcoXCJVbmFibGUgdG8gb3ZlcnJpZGUgQXJyYXkuZnJvbVwiLCBlcnIpO1xufVxuY29uc3QgbWlycm9yID0gY3JlYXRlTWlycm9yJDIoKTtcbmZ1bmN0aW9uIHJlY29yZChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGVtaXQsXG4gICAgY2hlY2tvdXRFdmVyeU5tcyxcbiAgICBjaGVja291dEV2ZXJ5TnRoLFxuICAgIGJsb2NrQ2xhc3MgPSBcInJyLWJsb2NrXCIsXG4gICAgYmxvY2tTZWxlY3RvciA9IG51bGwsXG4gICAgaWdub3JlQ2xhc3MgPSBcInJyLWlnbm9yZVwiLFxuICAgIGlnbm9yZVNlbGVjdG9yID0gbnVsbCxcbiAgICBtYXNrVGV4dENsYXNzID0gXCJyci1tYXNrXCIsXG4gICAgbWFza1RleHRTZWxlY3RvciA9IG51bGwsXG4gICAgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsXG4gICAgbWFza0FsbElucHV0cyxcbiAgICBtYXNrSW5wdXRPcHRpb25zOiBfbWFza0lucHV0T3B0aW9ucyxcbiAgICBzbGltRE9NT3B0aW9uczogX3NsaW1ET01PcHRpb25zLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIG1hc2tUZXh0Rm4sXG4gICAgaG9va3MsXG4gICAgcGFja0ZuLFxuICAgIHNhbXBsaW5nID0ge30sXG4gICAgZGF0YVVSTE9wdGlvbnMgPSB7fSxcbiAgICBtb3VzZW1vdmVXYWl0LFxuICAgIHJlY29yZERPTSA9IHRydWUsXG4gICAgcmVjb3JkQ2FudmFzID0gZmFsc2UsXG4gICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gZmFsc2UsXG4gICAgcmVjb3JkQWZ0ZXIgPSBvcHRpb25zLnJlY29yZEFmdGVyID09PSBcIkRPTUNvbnRlbnRMb2FkZWRcIiA/IG9wdGlvbnMucmVjb3JkQWZ0ZXIgOiBcImxvYWRcIixcbiAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dCA9IGZhbHNlLFxuICAgIGNvbGxlY3RGb250cyA9IGZhbHNlLFxuICAgIGlubGluZUltYWdlcyA9IGZhbHNlLFxuICAgIHBsdWdpbnMsXG4gICAga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsXG4gICAgaWdub3JlQ1NTQXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKSxcbiAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlcjJcbiAgfSA9IG9wdGlvbnM7XG4gIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcjIpO1xuICBjb25zdCBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPyB3aW5kb3cucGFyZW50ID09PSB3aW5kb3cgOiB0cnVlO1xuICBsZXQgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQpIHtcbiAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaW5FbWl0dGluZ0ZyYW1lICYmICFlbWl0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAoIWluRW1pdHRpbmdGcmFtZSAmJiAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHZvaWQgMCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHZvaWQgMCkge1xuICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XG4gIH1cbiAgbWlycm9yLnJlc2V0KCk7XG4gIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgIGNvbG9yOiB0cnVlLFxuICAgIGRhdGU6IHRydWUsXG4gICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgIGVtYWlsOiB0cnVlLFxuICAgIG1vbnRoOiB0cnVlLFxuICAgIG51bWJlcjogdHJ1ZSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgICBzZWFyY2g6IHRydWUsXG4gICAgdGVsOiB0cnVlLFxuICAgIHRleHQ6IHRydWUsXG4gICAgdGltZTogdHJ1ZSxcbiAgICB1cmw6IHRydWUsXG4gICAgd2VlazogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBzZWxlY3Q6IHRydWUsXG4gICAgcGFzc3dvcmQ6IHRydWVcbiAgfSA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB2b2lkIDAgPyBfbWFza0lucHV0T3B0aW9ucyA6IHsgcGFzc3dvcmQ6IHRydWUgfTtcbiAgY29uc3Qgc2xpbURPTU9wdGlvbnMgPSBfc2xpbURPTU9wdGlvbnMgPT09IHRydWUgfHwgX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiID8ge1xuICAgIHNjcmlwdDogdHJ1ZSxcbiAgICBjb21tZW50OiB0cnVlLFxuICAgIGhlYWRGYXZpY29uOiB0cnVlLFxuICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxuICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxuICAgIGhlYWRNZXRhUm9ib3RzOiB0cnVlLFxuICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIG9mZiBmb3Igc2xpbURPTU9wdGlvbnMgPT09IHRydWUsXG4gICAgLy8gYXMgdGhleSBkZXN0cm95IHNvbWUgKGhpZGRlbikgaW5mbzpcbiAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IF9zbGltRE9NT3B0aW9ucyA9PT0gXCJhbGxcIixcbiAgICBoZWFkTWV0YURlc2NLZXl3b3JkczogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgIGhlYWRUaXRsZU11dGF0aW9uczogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiXG4gIH0gOiBfc2xpbURPTU9wdGlvbnMgPyBfc2xpbURPTU9wdGlvbnMgOiB7fTtcbiAgcG9seWZpbGwkMSgpO1xuICBsZXQgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50O1xuICBsZXQgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcbiAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSAoZTIpID0+IHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbjMgb2YgcGx1Z2lucyB8fCBbXSkge1xuICAgICAgaWYgKHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IpIHtcbiAgICAgICAgZTIgPSBwbHVnaW4zLmV2ZW50UHJvY2Vzc29yKGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tGbiAmJiAvLyBEaXNhYmxlIHBhY2tpbmcgZXZlbnRzIHdoaWNoIHdpbGwgYmUgZW1pdHRlZCB0byBwYXJlbnQgZnJhbWVzLlxuICAgICFwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgZTIgPSBwYWNrRm4oZTIpO1xuICAgIH1cbiAgICByZXR1cm4gZTI7XG4gIH07XG4gIHdyYXBwZWRFbWl0ID0gKHIyLCBpc0NoZWNrb3V0KSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBlMiA9IHIyO1xuICAgIGUyLnRpbWVzdGFtcCA9IG5vd1RpbWVzdGFtcCgpO1xuICAgIGlmICgoKF9hMiA9IG11dGF0aW9uQnVmZmVyc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pc0Zyb3plbigpKSAmJiBlMi50eXBlICE9PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90ICYmICEoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiYgZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uKSkge1xuICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVuZnJlZXplKCkpO1xuICAgIH1cbiAgICBpZiAoaW5FbWl0dGluZ0ZyYW1lKSB7XG4gICAgICBlbWl0ID09IG51bGwgPyB2b2lkIDAgOiBlbWl0KGV2ZW50UHJvY2Vzc29yKGUyKSwgaXNDaGVja291dCk7XG4gICAgfSBlbHNlIGlmIChwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogXCJycndlYlwiLFxuICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZTIpLFxuICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIGlzQ2hlY2tvdXRcbiAgICAgIH07XG4gICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFwiKlwiKTtcbiAgICB9XG4gICAgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QpIHtcbiAgICAgIGxhc3RGdWxsU25hcHNob3RFdmVudCA9IGUyO1xuICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90KSB7XG4gICAgICBpZiAoZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uICYmIGUyLmRhdGEuaXNBdHRhY2hJZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50Kys7XG4gICAgICBjb25zdCBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XG4gICAgICBjb25zdCBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJiBlMi50aW1lc3RhbXAgLSBsYXN0RnVsbFNuYXBzaG90RXZlbnQudGltZXN0YW1wID4gY2hlY2tvdXRFdmVyeU5tcztcbiAgICAgIGlmIChleGNlZWRDb3VudCB8fCBleGNlZWRUaW1lKSB7XG4gICAgICAgIHRha2VGdWxsU25hcHNob3QkMSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRNdXRhdGlvbkVtaXQgPSAobSkgPT4ge1xuICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICAgICAgICAuLi5tXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRTY3JvbGxFbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNjcm9sbCxcbiAgICAgIC4uLnBcbiAgICB9XG4gIH0pO1xuICBjb25zdCB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uLFxuICAgICAgLi4ucFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQgPSAoYTIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0LFxuICAgICAgLi4uYTJcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdHlsZXNoZWV0TWFuYWdlciA9IG5ldyBTdHlsZXNoZWV0TWFuYWdlcih7XG4gICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICBhZG9wdGVkU3R5bGVTaGVldENiOiB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0XG4gIH0pO1xuICBjb25zdCBpZnJhbWVNYW5hZ2VyID0gbmV3IElmcmFtZU1hbmFnZXIoe1xuICAgIG1pcnJvcixcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgIHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyxcbiAgICB3cmFwcGVkRW1pdFxuICB9KTtcbiAgZm9yIChjb25zdCBwbHVnaW4zIG9mIHBsdWdpbnMgfHwgW10pIHtcbiAgICBpZiAocGx1Z2luMy5nZXRNaXJyb3IpXG4gICAgICBwbHVnaW4zLmdldE1pcnJvcih7XG4gICAgICAgIG5vZGVNaXJyb3I6IG1pcnJvcixcbiAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsXG4gICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvclxuICAgICAgfSk7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc2VkTm9kZU1hbmFnZXIgPSBuZXcgUHJvY2Vzc2VkTm9kZU1hbmFnZXIoKTtcbiAgY2FudmFzTWFuYWdlciA9IG5ldyBDYW52YXNNYW5hZ2VyKHtcbiAgICByZWNvcmRDYW52YXMsXG4gICAgbXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICB3aW46IHdpbmRvdyxcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgbWlycm9yLFxuICAgIHNhbXBsaW5nOiBzYW1wbGluZy5jYW52YXMsXG4gICAgZGF0YVVSTE9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IHNoYWRvd0RvbU1hbmFnZXIgPSBuZXcgU2hhZG93RG9tTWFuYWdlcih7XG4gICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXG4gICAgYnlwYXNzT3B0aW9uczoge1xuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICBtYXNrVGV4dEZuLFxuICAgICAgbWFza0lucHV0Rm4sXG4gICAgICByZWNvcmRDYW52YXMsXG4gICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICBzYW1wbGluZyxcbiAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgaWZyYW1lTWFuYWdlcixcbiAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgY2FudmFzTWFuYWdlcixcbiAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyXG4gICAgfSxcbiAgICBtaXJyb3JcbiAgfSk7XG4gIHRha2VGdWxsU25hcHNob3QkMSA9IChpc0NoZWNrb3V0ID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIXJlY29yZERPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cmFwcGVkRW1pdChcbiAgICAgIHtcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1ldGEsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBocmVmOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICB3aWR0aDogZ2V0V2luZG93V2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQ6IGdldFdpbmRvd0hlaWdodCgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0NoZWNrb3V0XG4gICAgKTtcbiAgICBzdHlsZXNoZWV0TWFuYWdlci5yZXNldCgpO1xuICAgIHNoYWRvd0RvbU1hbmFnZXIuaW5pdCgpO1xuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5sb2NrKCkpO1xuICAgIGNvbnN0IG5vZGUyID0gc25hcHNob3QoZG9jdW1lbnQsIHtcbiAgICAgIG1pcnJvcixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgbWFza0FsbElucHV0czogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICBtYXNrSW5wdXRGbixcbiAgICAgIHNsaW1ET006IHNsaW1ET01PcHRpb25zLFxuICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICByZWNvcmRDYW52YXMsXG4gICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICBvblNlcmlhbGl6ZTogKG4yKSA9PiB7XG4gICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUobjIsIG1pcnJvcikpIHtcbiAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShuMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcikpIHtcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KG4yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3QoaW5kZXguc2hhZG93Um9vdChuMiksIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xuICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcbiAgICAgIH0sXG4gICAgICBvblN0eWxlc2hlZXRMb2FkOiAobGlua0VsLCBjaGlsZFNuKSA9PiB7XG4gICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbik7XG4gICAgICB9LFxuICAgICAga2VlcElmcmFtZVNyY0ZuXG4gICAgfSk7XG4gICAgaWYgKCFub2RlMikge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzbmFwc2hvdCB0aGUgZG9jdW1lbnRcIik7XG4gICAgfVxuICAgIHdyYXBwZWRFbWl0KFxuICAgICAge1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuRnVsbFNuYXBzaG90LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbm9kZTogbm9kZTIsXG4gICAgICAgICAgaW5pdGlhbE9mZnNldDogZ2V0V2luZG93U2Nyb2xsKHdpbmRvdylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzQ2hlY2tvdXRcbiAgICApO1xuICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi51bmxvY2soKSk7XG4gICAgaWYgKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcbiAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoXG4gICAgICAgIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyxcbiAgICAgICAgbWlycm9yLmdldElkKGRvY3VtZW50KVxuICAgICAgKTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICAgIGNvbnN0IG9ic2VydmUgPSAoZG9jKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihpbml0T2JzZXJ2ZXJzKShcbiAgICAgICAge1xuICAgICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgICAgbW91c2Vtb3ZlQ2I6IChwb3NpdGlvbnMsIHNvdXJjZSkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgcG9zaXRpb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiOiAoZCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgLi4uZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiAoZCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemUsXG4gICAgICAgICAgICAgIC4uLmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBpbnB1dENiOiAodjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLklucHV0LFxuICAgICAgICAgICAgICAuLi52MlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYjogKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgIC4uLnBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiOiAocjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlLFxuICAgICAgICAgICAgICAuLi5yMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYjogKHIyKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAuLi5yMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNhbnZhc011dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXG4gICAgICAgICAgZm9udENiOiAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuRm9udCxcbiAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNlbGVjdGlvbkNiOiAocCkgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIC4uLnBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21FbGVtZW50Q2I6IChjMikgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAuLi5jMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgaWdub3JlQ2xhc3MsXG4gICAgICAgICAgaWdub3JlU2VsZWN0b3IsXG4gICAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICBzYW1wbGluZyxcbiAgICAgICAgICByZWNvcmRET00sXG4gICAgICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgICAgIGlubGluZUltYWdlcyxcbiAgICAgICAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dCxcbiAgICAgICAgICBjb2xsZWN0Rm9udHMsXG4gICAgICAgICAgZG9jLFxuICAgICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgbWlycm9yLFxuICAgICAgICAgIGlmcmFtZU1hbmFnZXIsXG4gICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICAgICAgc2hhZG93RG9tTWFuYWdlcixcbiAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcbiAgICAgICAgICBjYW52YXNNYW5hZ2VyLFxuICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gICAgICAgICAgcGx1Z2luczogKChfYTIgPSBwbHVnaW5zID09IG51bGwgPyB2b2lkIDAgOiBwbHVnaW5zLmZpbHRlcigocCkgPT4gcC5vYnNlcnZlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubWFwKChwKSA9PiAoe1xuICAgICAgICAgICAgb2JzZXJ2ZXI6IHAub2JzZXJ2ZXIsXG4gICAgICAgICAgICBvcHRpb25zOiBwLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogKHBheWxvYWQpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlBsdWdpbixcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHBsdWdpbjogcC5uYW1lLFxuICAgICAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSkpIHx8IFtdXG4gICAgICAgIH0sXG4gICAgICAgIGhvb2tzXG4gICAgICApO1xuICAgIH07XG4gICAgaWZyYW1lTWFuYWdlci5hZGRMb2FkTGlzdGVuZXIoKGlmcmFtZUVsKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgICB0YWtlRnVsbFNuYXBzaG90JDEoKTtcbiAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShkb2N1bWVudCkpO1xuICAgICAgcmVjb3JkaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICBpbml0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goXG4gICAgICAgIG9uKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQsXG4gICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gXCJET01Db250ZW50TG9hZGVkXCIpIGluaXQoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgICBvbihcbiAgICAgICAgICBcImxvYWRcIixcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Mb2FkLFxuICAgICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09IFwibG9hZFwiKSBpbml0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aW5kb3dcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gICAgICBwcm9jZXNzZWROb2RlTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICByZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gIH1cbn1cbnJlY29yZC5hZGRDdXN0b21FdmVudCA9ICh0YWcsIHBheWxvYWQpID0+IHtcbiAgaWYgKCFyZWNvcmRpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbGVhc2UgYWRkIGN1c3RvbSBldmVudCBhZnRlciBzdGFydCByZWNvcmRpbmdcIik7XG4gIH1cbiAgd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5DdXN0b20sXG4gICAgZGF0YToge1xuICAgICAgdGFnLFxuICAgICAgcGF5bG9hZFxuICAgIH1cbiAgfSk7XG59O1xucmVjb3JkLmZyZWV6ZVBhZ2UgPSAoKSA9PiB7XG4gIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5mcmVlemUoKSk7XG59O1xucmVjb3JkLnRha2VGdWxsU25hcHNob3QgPSAoaXNDaGVja291dCkgPT4ge1xuICBpZiAoIXJlY29yZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBsZWFzZSB0YWtlIGZ1bGwgc25hcHNob3QgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nXCIpO1xuICB9XG4gIHRha2VGdWxsU25hcHNob3QkMShpc0NoZWNrb3V0KTtcbn07XG5yZWNvcmQubWlycm9yID0gbWlycm9yO1xudmFyIG47XG4hZnVuY3Rpb24odDIpIHtcbiAgdDJbdDIuTm90U3RhcnRlZCA9IDBdID0gXCJOb3RTdGFydGVkXCIsIHQyW3QyLlJ1bm5pbmcgPSAxXSA9IFwiUnVubmluZ1wiLCB0Mlt0Mi5TdG9wcGVkID0gMl0gPSBcIlN0b3BwZWRcIjtcbn0obiB8fCAobiA9IHt9KSk7XG5leHBvcnQge1xuICByZWNvcmRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvcmQuanMubWFwXG4iLCJ2YXIgRXZlbnRUeXBlID0gLyogQF9fUFVSRV9fICovICgoRXZlbnRUeXBlMikgPT4ge1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJEb21Db250ZW50TG9hZGVkXCJdID0gMF0gPSBcIkRvbUNvbnRlbnRMb2FkZWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTG9hZFwiXSA9IDFdID0gXCJMb2FkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkZ1bGxTbmFwc2hvdFwiXSA9IDJdID0gXCJGdWxsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiSW5jcmVtZW50YWxTbmFwc2hvdFwiXSA9IDNdID0gXCJJbmNyZW1lbnRhbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIk1ldGFcIl0gPSA0XSA9IFwiTWV0YVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJDdXN0b21cIl0gPSA1XSA9IFwiQ3VzdG9tXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIlBsdWdpblwiXSA9IDZdID0gXCJQbHVnaW5cIjtcbiAgcmV0dXJuIEV2ZW50VHlwZTI7XG59KShFdmVudFR5cGUgfHwge30pO1xudmFyIEluY3JlbWVudGFsU291cmNlID0gLyogQF9fUFVSRV9fICovICgoSW5jcmVtZW50YWxTb3VyY2UyKSA9PiB7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNdXRhdGlvblwiXSA9IDBdID0gXCJNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VNb3ZlXCJdID0gMV0gPSBcIk1vdXNlTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IDJdID0gXCJNb3VzZUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTY3JvbGxcIl0gPSAzXSA9IFwiU2Nyb2xsXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJWaWV3cG9ydFJlc2l6ZVwiXSA9IDRdID0gXCJWaWV3cG9ydFJlc2l6ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiSW5wdXRcIl0gPSA1XSA9IFwiSW5wdXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlRvdWNoTW92ZVwiXSA9IDZdID0gXCJUb3VjaE1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1lZGlhSW50ZXJhY3Rpb25cIl0gPSA3XSA9IFwiTWVkaWFJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVTaGVldFJ1bGVcIl0gPSA4XSA9IFwiU3R5bGVTaGVldFJ1bGVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkNhbnZhc011dGF0aW9uXCJdID0gOV0gPSBcIkNhbnZhc011dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJGb250XCJdID0gMTBdID0gXCJGb250XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJMb2dcIl0gPSAxMV0gPSBcIkxvZ1wiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRHJhZ1wiXSA9IDEyXSA9IFwiRHJhZ1wiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVEZWNsYXJhdGlvblwiXSA9IDEzXSA9IFwiU3R5bGVEZWNsYXJhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2VsZWN0aW9uXCJdID0gMTRdID0gXCJTZWxlY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkFkb3B0ZWRTdHlsZVNoZWV0XCJdID0gMTVdID0gXCJBZG9wdGVkU3R5bGVTaGVldFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ3VzdG9tRWxlbWVudFwiXSA9IDE2XSA9IFwiQ3VzdG9tRWxlbWVudFwiO1xuICByZXR1cm4gSW5jcmVtZW50YWxTb3VyY2UyO1xufSkoSW5jcmVtZW50YWxTb3VyY2UgfHwge30pO1xudmFyIE1vdXNlSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoTW91c2VJbnRlcmFjdGlvbnMyKSA9PiB7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZVVwXCJdID0gMF0gPSBcIk1vdXNlVXBcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlRG93blwiXSA9IDFdID0gXCJNb3VzZURvd25cIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNsaWNrXCJdID0gMl0gPSBcIkNsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDb250ZXh0TWVudVwiXSA9IDNdID0gXCJDb250ZXh0TWVudVwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRGJsQ2xpY2tcIl0gPSA0XSA9IFwiRGJsQ2xpY2tcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkZvY3VzXCJdID0gNV0gPSBcIkZvY3VzXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJCbHVyXCJdID0gNl0gPSBcIkJsdXJcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoU3RhcnRcIl0gPSA3XSA9IFwiVG91Y2hTdGFydFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hNb3ZlX0RlcGFydGVkXCJdID0gOF0gPSBcIlRvdWNoTW92ZV9EZXBhcnRlZFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hFbmRcIl0gPSA5XSA9IFwiVG91Y2hFbmRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoQ2FuY2VsXCJdID0gMTBdID0gXCJUb3VjaENhbmNlbFwiO1xuICByZXR1cm4gTW91c2VJbnRlcmFjdGlvbnMyO1xufSkoTW91c2VJbnRlcmFjdGlvbnMgfHwge30pO1xudmFyIFBvaW50ZXJUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFBvaW50ZXJUeXBlczIpID0+IHtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiTW91c2VcIl0gPSAwXSA9IFwiTW91c2VcIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiUGVuXCJdID0gMV0gPSBcIlBlblwiO1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJUb3VjaFwiXSA9IDJdID0gXCJUb3VjaFwiO1xuICByZXR1cm4gUG9pbnRlclR5cGVzMjtcbn0pKFBvaW50ZXJUeXBlcyB8fCB7fSk7XG52YXIgQ2FudmFzQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyAoKENhbnZhc0NvbnRleHQyKSA9PiB7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiMkRcIl0gPSAwXSA9IFwiMkRcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTFwiXSA9IDFdID0gXCJXZWJHTFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMMlwiXSA9IDJdID0gXCJXZWJHTDJcIjtcbiAgcmV0dXJuIENhbnZhc0NvbnRleHQyO1xufSkoQ2FudmFzQ29udGV4dCB8fCB7fSk7XG52YXIgTWVkaWFJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChNZWRpYUludGVyYWN0aW9uczIpID0+IHtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBsYXlcIl0gPSAwXSA9IFwiUGxheVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGF1c2VcIl0gPSAxXSA9IFwiUGF1c2VcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlNlZWtlZFwiXSA9IDJdID0gXCJTZWVrZWRcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlZvbHVtZUNoYW5nZVwiXSA9IDNdID0gXCJWb2x1bWVDaGFuZ2VcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlJhdGVDaGFuZ2VcIl0gPSA0XSA9IFwiUmF0ZUNoYW5nZVwiO1xuICByZXR1cm4gTWVkaWFJbnRlcmFjdGlvbnMyO1xufSkoTWVkaWFJbnRlcmFjdGlvbnMgfHwge30pO1xudmFyIFJlcGxheWVyRXZlbnRzID0gLyogQF9fUFVSRV9fICovICgoUmVwbGF5ZXJFdmVudHMyKSA9PiB7XG4gIFJlcGxheWVyRXZlbnRzMltcIlN0YXJ0XCJdID0gXCJzdGFydFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJQYXVzZVwiXSA9IFwicGF1c2VcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiUmVzdW1lXCJdID0gXCJyZXN1bWVcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiUmVzaXplXCJdID0gXCJyZXNpemVcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiRmluaXNoXCJdID0gXCJmaW5pc2hcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiRnVsbHNuYXBzaG90UmVidWlsZGVkXCJdID0gXCJmdWxsc25hcHNob3QtcmVidWlsZGVkXCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIkxvYWRTdHlsZXNoZWV0U3RhcnRcIl0gPSBcImxvYWQtc3R5bGVzaGVldC1zdGFydFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJMb2FkU3R5bGVzaGVldEVuZFwiXSA9IFwibG9hZC1zdHlsZXNoZWV0LWVuZFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJTa2lwU3RhcnRcIl0gPSBcInNraXAtc3RhcnRcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiU2tpcEVuZFwiXSA9IFwic2tpcC1lbmRcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IFwibW91c2UtaW50ZXJhY3Rpb25cIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiRXZlbnRDYXN0XCJdID0gXCJldmVudC1jYXN0XCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIkN1c3RvbUV2ZW50XCJdID0gXCJjdXN0b20tZXZlbnRcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiRmx1c2hcIl0gPSBcImZsdXNoXCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIlN0YXRlQ2hhbmdlXCJdID0gXCJzdGF0ZS1jaGFuZ2VcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiUGxheUJhY2tcIl0gPSBcInBsYXktYmFja1wiO1xuICBSZXBsYXllckV2ZW50czJbXCJEZXN0cm95XCJdID0gXCJkZXN0cm95XCI7XG4gIHJldHVybiBSZXBsYXllckV2ZW50czI7XG59KShSZXBsYXllckV2ZW50cyB8fCB7fSk7XG52YXIgTm9kZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlVHlwZTIpID0+IHtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICByZXR1cm4gTm9kZVR5cGUyO1xufSkoTm9kZVR5cGUgfHwge30pO1xuZXhwb3J0IHtcbiAgQ2FudmFzQ29udGV4dCxcbiAgRXZlbnRUeXBlLFxuICBJbmNyZW1lbnRhbFNvdXJjZSxcbiAgTWVkaWFJbnRlcmFjdGlvbnMsXG4gIE1vdXNlSW50ZXJhY3Rpb25zLFxuICBOb2RlVHlwZSxcbiAgUG9pbnRlclR5cGVzLFxuICBSZXBsYXllckV2ZW50c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcFxuIiwiLy8gQ29uc29sZS1wb2x5ZmlsbC4gTUlUIGxpY2Vuc2UuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2NvbnNvbGUtcG9seWZpbGxcbi8vIE1ha2UgaXQgc2FmZSB0byBkbyBjb25zb2xlLmxvZygpIGFsd2F5cy5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAoIWdsb2JhbC5jb25zb2xlKSB7XG4gICAgZ2xvYmFsLmNvbnNvbGUgPSB7fTtcbiAgfVxuICB2YXIgY29uID0gZ2xvYmFsLmNvbnNvbGU7XG4gIHZhciBwcm9wLCBtZXRob2Q7XG4gIHZhciBkdW1teSA9IGZ1bmN0aW9uKCkge307XG4gIHZhciBwcm9wZXJ0aWVzID0gWydtZW1vcnknXTtcbiAgdmFyIG1ldGhvZHMgPSAoJ2Fzc2VydCxjbGVhcixjb3VudCxkZWJ1ZyxkaXIsZGlyeG1sLGVycm9yLGV4Y2VwdGlvbixncm91cCwnICtcbiAgICAgJ2dyb3VwQ29sbGFwc2VkLGdyb3VwRW5kLGluZm8sbG9nLG1hcmtUaW1lbGluZSxwcm9maWxlLHByb2ZpbGVzLHByb2ZpbGVFbmQsJyArXG4gICAgICdzaG93LHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSx0aW1lbGluZUVuZCx0aW1lU3RhbXAsdHJhY2Usd2FybicpLnNwbGl0KCcsJyk7XG4gIHdoaWxlIChwcm9wID0gcHJvcGVydGllcy5wb3AoKSkgaWYgKCFjb25bcHJvcF0pIGNvbltwcm9wXSA9IHt9O1xuICB3aGlsZSAobWV0aG9kID0gbWV0aG9kcy5wb3AoKSkgaWYgKCFjb25bbWV0aG9kXSkgY29uW21ldGhvZF0gPSBkdW1teTtcbiAgLy8gVXNpbmcgYHRoaXNgIGZvciB3ZWIgd29ya2VycyAmIHN1cHBvcnRzIEJyb3dzZXJpZnkgLyBXZWJwYWNrLlxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzIDogd2luZG93KTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicsIFsnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LkVycm9yU3RhY2tQYXJzZXIgPSBmYWN0b3J5KHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQID0gLyhefEApXFxTKzpcXGQrLztcbiAgICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG4gICAgdmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCBleHRyYWN0IHRoZSBtb3N0IGluZm9ybWF0aW9uIGZyb20gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RhY2tGcmFtZXNcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZShlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5zdGFja3RyYWNlICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXJyb3JbJ29wZXJhI3NvdXJjZWxvYyddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTZXBhcmF0ZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBmcm9tIGEgc3RyaW5nIG9mIHRoZSBmb3JtOiAoVVJJOkxpbmU6Q29sdW1uKVxuICAgICAgICBleHRyYWN0TG9jYXRpb246IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJGV4dHJhY3RMb2NhdGlvbih1cmxMaWtlKSB7XG4gICAgICAgICAgICAvLyBGYWlsLWZhc3QgYnV0IHJldHVybiBsb2NhdGlvbnMgbGlrZSBcIihuYXRpdmUpXCJcbiAgICAgICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VybExpa2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnRXhwID0gLyguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC87XG4gICAgICAgICAgICB2YXIgcGFydHMgPSByZWdFeHAuZXhlYyh1cmxMaWtlLnJlcGxhY2UoL1soKV0vZywgJycpKTtcbiAgICAgICAgICAgIHJldHVybiBbcGFydHNbMV0sIHBhcnRzWzJdIHx8IHVuZGVmaW5lZCwgcGFydHNbM10gfHwgdW5kZWZpbmVkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignKGV2YWwgJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCAnZXZhbCcpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteKCldKil8KFxcKSwuKiQpL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCAnKCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSBhbmQgcHJlc2V2ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBcIigvZm9vL215IGJhci5qczoxMjo4NylcIiBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXQgaGFzIHNwYWNlcyBpbiBpdCwgYXMgdGhlIHN0cmluZyBpcyBzcGxpdCBvbiBcXHMrIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2FuaXRpemVkTGluZS5tYXRjaCgvIChcXCgoLispOihcXGQrKTooXFxkKylcXCkkKS8pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIGZyb20gdGhlIGxpbmUsIGlmIGl0IHdhcyBtYXRjaGVkXG4gICAgICAgICAgICAgICAgc2FuaXRpemVkTGluZSA9IGxvY2F0aW9uID8gc2FuaXRpemVkTGluZS5yZXBsYWNlKGxvY2F0aW9uWzBdLCAnJykgOiBzYW5pdGl6ZWRMaW5lO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGxvY2F0aW9uIHdhcyBtYXRjaGVkLCBwYXNzIGl0IHRvIGV4dHJhY3RMb2NhdGlvbigpIG90aGVyd2lzZSBwb3AgdGhlIGxhc3QgdG9rZW5cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxvY2F0aW9uID8gbG9jYXRpb25bMV0gOiB0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuam9pbignICcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWxpbmUubWF0Y2goU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsOlxcZCs6XFxkKy9nLCAnOiQxJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsICcnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgICAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSAodG9rZW5zLnNoaWZ0KCkgfHwgJycpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCAnJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgYXJnc1JhdztcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm1hdGNoKC9cXCgoW14pXSopXFwpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW14oXStcXCgoW14pXSopXFwpJC8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IChhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nKSA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGFyZ3NSYXcuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrZnJhbWUnLCBbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0ZyYW1lID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIF9pc051bWJlcihuKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXR0ZXIocCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYm9vbGVhblByb3BzID0gWydpc0NvbnN0cnVjdG9yJywgJ2lzRXZhbCcsICdpc05hdGl2ZScsICdpc1RvcGxldmVsJ107XG4gICAgdmFyIG51bWVyaWNQcm9wcyA9IFsnY29sdW1uTnVtYmVyJywgJ2xpbmVOdW1iZXInXTtcbiAgICB2YXIgc3RyaW5nUHJvcHMgPSBbJ2ZpbGVOYW1lJywgJ2Z1bmN0aW9uTmFtZScsICdzb3VyY2UnXTtcbiAgICB2YXIgYXJyYXlQcm9wcyA9IFsnYXJncyddO1xuICAgIHZhciBvYmplY3RQcm9wcyA9IFsnZXZhbE9yaWdpbiddO1xuXG4gICAgdmFyIHByb3BzID0gYm9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsIHN0cmluZ1Byb3BzLCBhcnJheVByb3BzLCBvYmplY3RQcm9wcyk7XG5cbiAgICBmdW5jdGlvbiBTdGFja0ZyYW1lKG9iaikge1xuICAgICAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2JqW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1snc2V0JyArIF9jYXBpdGFsaXplKHByb3BzW2ldKV0ob2JqW3Byb3BzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0QXJnczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBcmdzOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB2O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEV2YWxPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZhbE9yaWdpbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RXZhbE9yaWdpbjogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IG5ldyBTdGFja0ZyYW1lKHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmFsIE9yaWdpbiBtdXN0IGJlIGFuIE9iamVjdCBvciBTdGFja0ZyYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJc0V2YWwoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXSAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF06JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArICcgKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN0YWNrRnJhbWUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIFN0YWNrRnJhbWUkJGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciBhcmdzU3RhcnRJbmRleCA9IHN0ci5pbmRleE9mKCcoJyk7XG4gICAgICAgIHZhciBhcmdzRW5kSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJyknKTtcblxuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gc3RyLnN1YnN0cmluZygwLCBhcmdzU3RhcnRJbmRleCk7XG4gICAgICAgIHZhciBhcmdzID0gc3RyLnN1YnN0cmluZyhhcmdzU3RhcnRJbmRleCArIDEsIGFyZ3NFbmRJbmRleCkuc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uU3RyaW5nID0gc3RyLnN1YnN0cmluZyhhcmdzRW5kSW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobG9jYXRpb25TdHJpbmcuaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSAvQCguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC8uZXhlYyhsb2NhdGlvblN0cmluZywgJycpO1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHBhcnRzWzJdO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHBhcnRzWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogY29sdW1uTnVtYmVyIHx8IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IF9nZXR0ZXIoYm9vbGVhblByb3BzW2ldKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBCb29sZWFuKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoYm9vbGVhblByb3BzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bWVyaWNQcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gX2dldHRlcihudW1lcmljUHJvcHNbal0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwICsgJyBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBOdW1iZXIodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShudW1lcmljUHJvcHNbal0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3RyaW5nUHJvcHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gX2dldHRlcihzdHJpbmdQcm9wc1trXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBTdHJpbmcodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShzdHJpbmdQcm9wc1trXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0YWNrRnJhbWU7XG59KSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2FwaVV0aWxpdHknKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBob3N0bmFtZTogJ2FwaS5yb2xsYmFyLmNvbScsXG4gIHBhdGg6ICcvYXBpLzEvaXRlbS8nLFxuICBzZWFyY2g6IG51bGwsXG4gIHZlcnNpb246ICcxJyxcbiAgcHJvdG9jb2w6ICdodHRwczonLFxuICBwb3J0OiA0NDMsXG59O1xuXG52YXIgT1RMUERlZmF1bHRPcHRpb25zID0ge1xuICBob3N0bmFtZTogJ2FwaS5yb2xsYmFyLmNvbScsXG4gIHBhdGg6ICcvYXBpLzEvc2Vzc2lvbi8nLFxuICBzZWFyY2g6IG51bGwsXG4gIHZlcnNpb246ICcxJyxcbiAgcHJvdG9jb2w6ICdodHRwczonLFxuICBwb3J0OiA0NDMsXG59O1xuXG4vKipcbiAqIEFwaSBpcyBhbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgbWV0aG9kcyBvZiBjb21tdW5pY2F0aW5nIHdpdGhcbiAqIHRoZSBSb2xsYmFyIEFQSS4gIEl0IGlzIGEgc3RhbmRhcmQgaW50ZXJmYWNlIHdpdGggc29tZSBwYXJ0cyBpbXBsZW1lbnRlZFxuICogZGlmZmVyZW50bHkgZm9yIHNlcnZlciBvciBicm93c2VyIGNvbnRleHRzLiAgSXQgaXMgYW4gb2JqZWN0IHRoYXQgc2hvdWxkXG4gKiBiZSBpbnN0YW50aWF0ZWQgd2hlbiB1c2VkIHNvIGl0IGNhbiBjb250YWluIG5vbi1nbG9iYWwgb3B0aW9ucyB0aGF0IG1heVxuICogYmUgZGlmZmVyZW50IGZvciBhbm90aGVyIGluc3RhbmNlIG9mIFJvbGxiYXJBcGkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge1xuICogICAgYWNjZXNzVG9rZW46IHRoZSBhY2Nlc3NUb2tlbiB0byB1c2UgZm9yIHBvc3RpbmcgaXRlbXMgdG8gcm9sbGJhclxuICogICAgZW5kcG9pbnQ6IGFuIGFsdGVybmF0aXZlIGVuZHBvaW50IHRvIHNlbmQgZXJyb3JzIHRvXG4gKiAgICAgICAgbXVzdCBiZSBhIHZhbGlkLCBmdWxseSBxdWFsaWZpZWQgVVJMLlxuICogICAgICAgIFRoZSBkZWZhdWx0IGlzOiBodHRwczovL2FwaS5yb2xsYmFyLmNvbS9hcGkvMS9pdGVtXG4gKiAgICBwcm94eTogaWYgeW91IHdpc2ggdG8gcHJveHkgcmVxdWVzdHMgcHJvdmlkZSBhbiBvYmplY3RcbiAqICAgICAgICB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqICAgICAgICAgIGhvc3Qgb3IgaG9zdG5hbWUgKHJlcXVpcmVkKTogZm9vLmV4YW1wbGUuY29tXG4gKiAgICAgICAgICBwb3J0IChvcHRpb25hbCk6IDEyM1xuICogICAgICAgICAgcHJvdG9jb2wgKG9wdGlvbmFsKTogaHR0cHNcbiAqIH1cbiAqL1xuZnVuY3Rpb24gQXBpKG9wdGlvbnMsIHRyYW5zcG9ydCwgdXJsbGliLCB0cnVuY2F0aW9uKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLnVybCA9IHVybGxpYjtcbiAgdGhpcy50cnVuY2F0aW9uID0gdHJ1bmNhdGlvbjtcbiAgdGhpcy5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuYWNjZXNzVG9rZW47XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IF9nZXRUcmFuc3BvcnQob3B0aW9ucywgdXJsbGliKTtcbiAgdGhpcy5PVExQVHJhbnNwb3J0T3B0aW9ucyA9IF9nZXRPVExQVHJhbnNwb3J0KG9wdGlvbnMsIHVybGxpYik7XG59XG5cbi8qKlxuICogV3JhcHMgdHJhbnNwb3J0LnBvc3QgaW4gYSBQcm9taXNlIHRvIHN1cHBvcnQgYXN5bmMvYXdhaXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBBUEkgcmVxdWVzdFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW4gLSBUaGUgYWNjZXNzIHRva2VuIGZvciBhdXRoZW50aWNhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB0cmFuc3BvcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBheWxvYWQgLSBUaGUgZGF0YSBwYXlsb2FkIHRvIHNlbmRcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbkFwaS5wcm90b3R5cGUuX3Bvc3RQcm9taXNlID0gZnVuY3Rpb24oeyBhY2Nlc3NUb2tlbiwgdHJhbnNwb3J0T3B0aW9ucywgcGF5bG9hZCB9KSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNlbGYudHJhbnNwb3J0LnBvc3QoYWNjZXNzVG9rZW4sIHRyYW5zcG9ydE9wdGlvbnMsIHBheWxvYWQsIChlcnIsIHJlc3ApID0+XG4gICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzcClcbiAgICApO1xuICB9KTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuQXBpLnByb3RvdHlwZS5wb3N0SXRlbSA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgdHJhbnNwb3J0T3B0aW9ucyA9IGhlbHBlcnMudHJhbnNwb3J0T3B0aW9ucyhcbiAgICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMsXG4gICAgJ1BPU1QnLFxuICApO1xuICB2YXIgcGF5bG9hZCA9IGhlbHBlcnMuYnVpbGRQYXlsb2FkKGRhdGEpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZW5zdXJlIHRoZSBuZXR3b3JrIHJlcXVlc3QgaXMgc2NoZWR1bGVkIGFmdGVyIHRoZSBjdXJyZW50IHRpY2suXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYudHJhbnNwb3J0LnBvc3Qoc2VsZi5hY2Nlc3NUb2tlbiwgdHJhbnNwb3J0T3B0aW9ucywgcGF5bG9hZCwgY2FsbGJhY2spO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogUG9zdHMgc3BhbnMgdG8gdGhlIFJvbGxiYXIgQVBJIHVzaW5nIHRoZSBzZXNzaW9uIGVuZHBvaW50XG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGF5bG9hZCAtIFRoZSBzcGFucyB0byBzZW5kXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBBUEkgcmVzcG9uc2VcbiAqL1xuQXBpLnByb3RvdHlwZS5wb3N0U3BhbnMgPSBhc3luYyBmdW5jdGlvbiAocGF5bG9hZCkge1xuICBjb25zdCB0cmFuc3BvcnRPcHRpb25zID0gaGVscGVycy50cmFuc3BvcnRPcHRpb25zKFxuICAgIHRoaXMuT1RMUFRyYW5zcG9ydE9wdGlvbnMsXG4gICAgJ1BPU1QnLFxuICApO1xuXG4gIHJldHVybiBhd2FpdCB0aGlzLl9wb3N0UHJvbWlzZSh7XG4gICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgdHJhbnNwb3J0T3B0aW9ucyxcbiAgICBwYXlsb2FkXG4gIH0pO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5BcGkucHJvdG90eXBlLmJ1aWxkSnNvblBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgdmFyIHBheWxvYWQgPSBoZWxwZXJzLmJ1aWxkUGF5bG9hZChkYXRhKTtcblxuICB2YXIgc3RyaW5naWZ5UmVzdWx0O1xuICBpZiAodGhpcy50cnVuY2F0aW9uKSB7XG4gICAgc3RyaW5naWZ5UmVzdWx0ID0gdGhpcy50cnVuY2F0aW9uLnRydW5jYXRlKHBheWxvYWQpO1xuICB9IGVsc2Uge1xuICAgIHN0cmluZ2lmeVJlc3VsdCA9IF8uc3RyaW5naWZ5KHBheWxvYWQpO1xuICB9XG5cbiAgaWYgKHN0cmluZ2lmeVJlc3VsdC5lcnJvcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soc3RyaW5naWZ5UmVzdWx0LmVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5UmVzdWx0LnZhbHVlO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGpzb25QYXlsb2FkXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuQXBpLnByb3RvdHlwZS5wb3N0SnNvblBheWxvYWQgPSBmdW5jdGlvbiAoanNvblBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuc3BvcnRPcHRpb25zID0gaGVscGVycy50cmFuc3BvcnRPcHRpb25zKFxuICAgIHRoaXMudHJhbnNwb3J0T3B0aW9ucyxcbiAgICAnUE9TVCcsXG4gICk7XG4gIHRoaXMudHJhbnNwb3J0LnBvc3RKc29uUGF5bG9hZChcbiAgICB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgIHRyYW5zcG9ydE9wdGlvbnMsXG4gICAganNvblBheWxvYWQsXG4gICAgY2FsbGJhY2ssXG4gICk7XG59O1xuXG5BcGkucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBvbGRPcHRpb25zID0gdGhpcy5vbGRPcHRpb25zO1xuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9sZE9wdGlvbnMsIG9wdGlvbnMpO1xuICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMgPSBfZ2V0VHJhbnNwb3J0KHRoaXMub3B0aW9ucywgdGhpcy51cmwpO1xuICB0aGlzLk9UTFBUcmFuc3BvcnRPcHRpb25zID0gX2dldE9UTFBUcmFuc3BvcnQodGhpcy5vcHRpb25zLCB0aGlzLnVybCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0VHJhbnNwb3J0KG9wdGlvbnMsIHVybCkge1xuICByZXR1cm4gaGVscGVycy5nZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucywgdXJsKTtcbn1cblxuZnVuY3Rpb24gX2dldE9UTFBUcmFuc3BvcnQob3B0aW9ucywgdXJsKSB7XG4gIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgZW5kcG9pbnQ6IG9wdGlvbnMudHJhY2luZz8uZW5kcG9pbnR9O1xuICByZXR1cm4gaGVscGVycy5nZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyhvcHRpb25zLCBPVExQRGVmYXVsdE9wdGlvbnMsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBpO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuZnVuY3Rpb24gYnVpbGRQYXlsb2FkKGRhdGEpIHtcbiAgaWYgKCFfLmlzVHlwZShkYXRhLmNvbnRleHQsICdzdHJpbmcnKSkge1xuICAgIHZhciBjb250ZXh0UmVzdWx0ID0gXy5zdHJpbmdpZnkoZGF0YS5jb250ZXh0KTtcbiAgICBpZiAoY29udGV4dFJlc3VsdC5lcnJvcikge1xuICAgICAgZGF0YS5jb250ZXh0ID0gXCJFcnJvcjogY291bGQgbm90IHNlcmlhbGl6ZSAnY29udGV4dCdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5jb250ZXh0ID0gY29udGV4dFJlc3VsdC52YWx1ZSB8fCAnJztcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC5sZW5ndGggPiAyNTUpIHtcbiAgICAgIGRhdGEuY29udGV4dCA9IGRhdGEuY29udGV4dC5zdWJzdHIoMCwgMjU1KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cywgdXJsKSB7XG4gIHZhciBob3N0bmFtZSA9IGRlZmF1bHRzLmhvc3RuYW1lO1xuICB2YXIgcHJvdG9jb2wgPSBkZWZhdWx0cy5wcm90b2NvbDtcbiAgdmFyIHBvcnQgPSBkZWZhdWx0cy5wb3J0O1xuICB2YXIgcGF0aCA9IGRlZmF1bHRzLnBhdGg7XG4gIHZhciBzZWFyY2ggPSBkZWZhdWx0cy5zZWFyY2g7XG4gIHZhciB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICB2YXIgdHJhbnNwb3J0ID0gZGV0ZWN0VHJhbnNwb3J0KG9wdGlvbnMpO1xuXG4gIHZhciBwcm94eSA9IG9wdGlvbnMucHJveHk7XG4gIGlmIChvcHRpb25zLmVuZHBvaW50KSB7XG4gICAgdmFyIG9wdHMgPSB1cmwucGFyc2Uob3B0aW9ucy5lbmRwb2ludCk7XG4gICAgaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICAgIHByb3RvY29sID0gb3B0cy5wcm90b2NvbDtcbiAgICBwb3J0ID0gb3B0cy5wb3J0O1xuICAgIHBhdGggPSBvcHRzLnBhdGhuYW1lO1xuICAgIHNlYXJjaCA9IG9wdHMuc2VhcmNoO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBob3N0bmFtZTogaG9zdG5hbWUsXG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIHBvcnQ6IHBvcnQsXG4gICAgcGF0aDogcGF0aCxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBwcm94eTogcHJveHksXG4gICAgdHJhbnNwb3J0OiB0cmFuc3BvcnQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVjdFRyYW5zcG9ydChvcHRpb25zKSB7XG4gIHZhciBnV2luZG93ID1cbiAgICAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cpIHx8XG4gICAgKHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYpO1xuICB2YXIgdHJhbnNwb3J0ID0gb3B0aW9ucy5kZWZhdWx0VHJhbnNwb3J0IHx8ICd4aHInO1xuICBpZiAodHlwZW9mIGdXaW5kb3cuZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB0cmFuc3BvcnQgPSAneGhyJztcbiAgaWYgKHR5cGVvZiBnV2luZG93LlhNTEh0dHBSZXF1ZXN0ID09PSAndW5kZWZpbmVkJykgdHJhbnNwb3J0ID0gJ2ZldGNoJztcbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn1cblxuZnVuY3Rpb24gdHJhbnNwb3J0T3B0aW9ucyh0cmFuc3BvcnQsIG1ldGhvZCkge1xuICB2YXIgcHJvdG9jb2wgPSB0cmFuc3BvcnQucHJvdG9jb2wgfHwgJ2h0dHBzOic7XG4gIHZhciBwb3J0ID1cbiAgICB0cmFuc3BvcnQucG9ydCB8fFxuICAgIChwcm90b2NvbCA9PT0gJ2h0dHA6JyA/IDgwIDogcHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogdW5kZWZpbmVkKTtcbiAgdmFyIGhvc3RuYW1lID0gdHJhbnNwb3J0Lmhvc3RuYW1lO1xuICB2YXIgcGF0aCA9IHRyYW5zcG9ydC5wYXRoO1xuICB2YXIgdGltZW91dCA9IHRyYW5zcG9ydC50aW1lb3V0O1xuICB2YXIgdHJhbnNwb3J0QVBJID0gdHJhbnNwb3J0LnRyYW5zcG9ydDtcbiAgaWYgKHRyYW5zcG9ydC5zZWFyY2gpIHtcbiAgICBwYXRoID0gcGF0aCArIHRyYW5zcG9ydC5zZWFyY2g7XG4gIH1cbiAgaWYgKHRyYW5zcG9ydC5wcm94eSkge1xuICAgIHBhdGggPSBwcm90b2NvbCArICcvLycgKyBob3N0bmFtZSArIHBhdGg7XG4gICAgaG9zdG5hbWUgPSB0cmFuc3BvcnQucHJveHkuaG9zdCB8fCB0cmFuc3BvcnQucHJveHkuaG9zdG5hbWU7XG4gICAgcG9ydCA9IHRyYW5zcG9ydC5wcm94eS5wb3J0O1xuICAgIHByb3RvY29sID0gdHJhbnNwb3J0LnByb3h5LnByb3RvY29sIHx8IHByb3RvY29sO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcG9ydDogcG9ydCxcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydEFQSSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kUGF0aFRvUGF0aChiYXNlLCBwYXRoKSB7XG4gIHZhciBiYXNlVHJhaWxpbmdTbGFzaCA9IC9cXC8kLy50ZXN0KGJhc2UpO1xuICB2YXIgcGF0aEJlZ2lubmluZ1NsYXNoID0gL15cXC8vLnRlc3QocGF0aCk7XG5cbiAgaWYgKGJhc2VUcmFpbGluZ1NsYXNoICYmIHBhdGhCZWdpbm5pbmdTbGFzaCkge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygxKTtcbiAgfSBlbHNlIGlmICghYmFzZVRyYWlsaW5nU2xhc2ggJiYgIXBhdGhCZWdpbm5pbmdTbGFzaCkge1xuICAgIHBhdGggPSAnLycgKyBwYXRoO1xuICB9XG5cbiAgcmV0dXJuIGJhc2UgKyBwYXRoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRQYXlsb2FkOiBidWlsZFBheWxvYWQsXG4gIGdldFRyYW5zcG9ydEZyb21PcHRpb25zOiBnZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyxcbiAgdHJhbnNwb3J0T3B0aW9uczogdHJhbnNwb3J0T3B0aW9ucyxcbiAgYXBwZW5kUGF0aFRvUGF0aDogYXBwZW5kUGF0aFRvUGF0aCxcbn07XG4iLCJ2YXIgQ2xpZW50ID0gcmVxdWlyZSgnLi4vcm9sbGJhcicpO1xudmFyIF8gPSByZXF1aXJlKCcuLi91dGlsaXR5Jyk7XG52YXIgQVBJID0gcmVxdWlyZSgnLi4vYXBpJyk7XG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxTZXR1cCcpO1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcbnZhciB1cmxsaWIgPSByZXF1aXJlKCcuL3VybCcpO1xuXG52YXIgdHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtcycpO1xudmFyIHNoYXJlZFRyYW5zZm9ybXMgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zJyk7XG52YXIgcHJlZGljYXRlcyA9IHJlcXVpcmUoJy4vcHJlZGljYXRlcycpO1xudmFyIHNoYXJlZFByZWRpY2F0ZXMgPSByZXF1aXJlKCcuLi9wcmVkaWNhdGVzJyk7XG52YXIgZXJyb3JQYXJzZXIgPSByZXF1aXJlKCcuLi9lcnJvclBhcnNlcicpO1xuY29uc3QgcmVjb3JkZXJEZWZhdWx0cyA9IHJlcXVpcmUoJy4vcmVwbGF5L2RlZmF1bHRzJyk7XG5jb25zdCB0cmFjaW5nRGVmYXVsdHMgPSByZXF1aXJlKCcuLi90cmFjaW5nL2RlZmF1bHRzJyk7XG5jb25zdCBSZXBsYXlNYXAgPSByZXF1aXJlKCcuL3JlcGxheS9yZXBsYXlNYXAnKS5kZWZhdWx0O1xuXG5mdW5jdGlvbiBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkge1xuICB0aGlzLm9wdGlvbnMgPSBfLmhhbmRsZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIG51bGwsIGxvZ2dlcik7XG4gIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCBUZWxlbWV0ZXIgPSB0aGlzLmNvbXBvbmVudHMudGVsZW1ldGVyO1xuICBjb25zdCBJbnN0cnVtZW50ZXIgPSB0aGlzLmNvbXBvbmVudHMuaW5zdHJ1bWVudGVyO1xuICBjb25zdCBwb2x5ZmlsbEpTT04gPSB0aGlzLmNvbXBvbmVudHMucG9seWZpbGxKU09OO1xuICB0aGlzLndyYXBHbG9iYWxzID0gdGhpcy5jb21wb25lbnRzLndyYXBHbG9iYWxzO1xuICB0aGlzLnNjcnViID0gdGhpcy5jb21wb25lbnRzLnNjcnViO1xuICBjb25zdCB0cnVuY2F0aW9uID0gdGhpcy5jb21wb25lbnRzLnRydW5jYXRpb247XG4gIGNvbnN0IFRyYWNpbmcgPSB0aGlzLmNvbXBvbmVudHMudHJhY2luZztcbiAgY29uc3QgUmVjb3JkZXIgPSB0aGlzLmNvbXBvbmVudHMucmVjb3JkZXI7XG5cbiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydCh0cnVuY2F0aW9uKTtcbiAgY29uc3QgYXBpID0gbmV3IEFQSSh0aGlzLm9wdGlvbnMsIHRyYW5zcG9ydCwgdXJsbGliLCB0cnVuY2F0aW9uKTtcbiAgaWYgKFRyYWNpbmcpIHtcbiAgICB0aGlzLnRyYWNpbmcgPSBuZXcgVHJhY2luZyhfZ1dpbmRvdygpLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMudHJhY2luZy5pbml0U2Vzc2lvbigpO1xuICB9XG5cbiAgaWYgKFJlY29yZGVyICYmIF8uaXNCcm93c2VyKCkpIHtcbiAgICBjb25zdCByZWNvcmRlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVjb3JkZXI7XG4gICAgdGhpcy5yZWNvcmRlciA9IG5ldyBSZWNvcmRlcihyZWNvcmRlck9wdGlvbnMpO1xuICAgIHRoaXMucmVwbGF5TWFwID0gbmV3IFJlcGxheU1hcCh7XG4gICAgICByZWNvcmRlcjogdGhpcy5yZWNvcmRlcixcbiAgICAgIGFwaTogYXBpLFxuICAgICAgdHJhY2luZzogdGhpcy50cmFjaW5nXG4gICAgfSk7XG5cbiAgICBpZiAocmVjb3JkZXJPcHRpb25zLmVuYWJsZWQgJiYgcmVjb3JkZXJPcHRpb25zLmF1dG9TdGFydCkge1xuICAgICAgdGhpcy5yZWNvcmRlci5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChUZWxlbWV0ZXIpIHtcbiAgICB0aGlzLnRlbGVtZXRlciA9IG5ldyBUZWxlbWV0ZXIodGhpcy5vcHRpb25zLCB0aGlzLnRyYWNpbmcpO1xuICB9XG4gIHRoaXMuY2xpZW50ID1cbiAgICBjbGllbnQgfHwgbmV3IENsaWVudCh0aGlzLm9wdGlvbnMsIGFwaSwgbG9nZ2VyLCB0aGlzLnRlbGVtZXRlciwgdGhpcy50cmFjaW5nLCB0aGlzLnJlcGxheU1hcCwgJ2Jyb3dzZXInKTtcbiAgdmFyIGdXaW5kb3cgPSBfZ1dpbmRvdygpO1xuICB2YXIgZ0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xuICB0aGlzLmlzQ2hyb21lID0gZ1dpbmRvdy5jaHJvbWUgJiYgZ1dpbmRvdy5jaHJvbWUucnVudGltZTsgLy8gY2hlY2sgLnJ1bnRpbWUgdG8gYXZvaWQgRWRnZSBicm93c2Vyc1xuICB0aGlzLmFub255bW91c0Vycm9yc1BlbmRpbmcgPSAwO1xuICBhZGRUcmFuc2Zvcm1zVG9Ob3RpZmllcih0aGlzLmNsaWVudC5ub3RpZmllciwgdGhpcywgZ1dpbmRvdyk7XG4gIGFkZFByZWRpY2F0ZXNUb1F1ZXVlKHRoaXMuY2xpZW50LnF1ZXVlKTtcbiAgdGhpcy5zZXR1cFVuaGFuZGxlZENhcHR1cmUoKTtcbiAgaWYgKEluc3RydW1lbnRlcikge1xuICAgIHRoaXMuaW5zdHJ1bWVudGVyID0gbmV3IEluc3RydW1lbnRlcihcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMuY2xpZW50LnRlbGVtZXRlcixcbiAgICAgIHRoaXMsXG4gICAgICBnV2luZG93LFxuICAgICAgZ0RvY3VtZW50LFxuICAgICk7XG4gICAgdGhpcy5pbnN0cnVtZW50ZXIuaW5zdHJ1bWVudCgpO1xuICB9XG4gIF8uc2V0dXBKU09OKHBvbHlmaWxsSlNPTik7XG5cbiAgLy8gVXNlZCB3aXRoIHJvbGxiYXItcmVhY3QgZm9yIHJvbGxiYXItcmVhY3QtbmF0aXZlIGNvbXBhdGliaWxpdHkuXG4gIHRoaXMucm9sbGJhciA9IHRoaXM7XG59XG5cbnZhciBfaW5zdGFuY2UgPSBudWxsO1xuUm9sbGJhci5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsaWVudCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5nbG9iYWwob3B0aW9ucykuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG4gIF9pbnN0YW5jZSA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCk7XG4gIHJldHVybiBfaW5zdGFuY2U7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jb21wb25lbnRzID0ge307XG5cblJvbGxiYXIuc2V0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG4gIFJvbGxiYXIucHJvdG90eXBlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ1JvbGxiYXIgaXMgbm90IGluaXRpYWxpemVkJztcbiAgbG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICBpZiAobWF5YmVDYWxsYmFjaykge1xuICAgIG1heWJlQ2FsbGJhY2sobmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5Sb2xsYmFyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLmNsaWVudC5nbG9iYWwob3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblJvbGxiYXIuZ2xvYmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuZ2xvYmFsKG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBheWxvYWREYXRhKSB7XG4gIHZhciBvbGRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgcGF5bG9hZCA9IHt9O1xuICBpZiAocGF5bG9hZERhdGEpIHtcbiAgICBwYXlsb2FkID0geyBwYXlsb2FkOiBwYXlsb2FkRGF0YSB9O1xuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gXy5oYW5kbGVPcHRpb25zKG9sZE9wdGlvbnMsIG9wdGlvbnMsIHBheWxvYWQsIGxvZ2dlcik7XG4gIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMgPSBfLmhhbmRsZU9wdGlvbnMoXG4gICAgb2xkT3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMsXG4gICAgb3B0aW9ucyxcbiAgICBwYXlsb2FkLFxuICApO1xuXG4gIHRoaXMucmVjb3JkZXI/LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMpO1xuICB0aGlzLmNsaWVudC5jb25maWd1cmUodGhpcy5vcHRpb25zLCBwYXlsb2FkRGF0YSk7XG4gIHRoaXMuaW5zdHJ1bWVudGVyICYmIHRoaXMuaW5zdHJ1bWVudGVyLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMpO1xuICB0aGlzLnNldHVwVW5oYW5kbGVkQ2FwdHVyZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5Sb2xsYmFyLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXlsb2FkRGF0YSkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5jb25maWd1cmUob3B0aW9ucywgcGF5bG9hZERhdGEpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUubGFzdEVycm9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbGllbnQubGFzdEVycm9yO1xufTtcblJvbGxiYXIubGFzdEVycm9yID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5sYXN0RXJyb3IoKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKCk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC5sb2coaXRlbSk7XG4gIHJldHVybiB7IHV1aWQ6IHV1aWQgfTtcbn07XG5Sb2xsYmFyLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UubG9nLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQuZGVidWcoaXRlbSk7XG4gIHJldHVybiB7IHV1aWQ6IHV1aWQgfTtcbn07XG5Sb2xsYmFyLmRlYnVnID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5kZWJ1Zy5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heWJlQ2FsbGJhY2sgPSBfZ2V0Rmlyc3RGdW5jdGlvbihhcmd1bWVudHMpO1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQobWF5YmVDYWxsYmFjayk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQuaW5mbyhpdGVtKTtcbiAgcmV0dXJuIHsgdXVpZDogdXVpZCB9O1xufTtcblJvbGxiYXIuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuaW5mby5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heWJlQ2FsbGJhY2sgPSBfZ2V0Rmlyc3RGdW5jdGlvbihhcmd1bWVudHMpO1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQobWF5YmVDYWxsYmFjayk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQud2FybihpdGVtKTtcbiAgcmV0dXJuIHsgdXVpZDogdXVpZCB9O1xufTtcblJvbGxiYXIud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2Uud2Fybi5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heWJlQ2FsbGJhY2sgPSBfZ2V0Rmlyc3RGdW5jdGlvbihhcmd1bWVudHMpO1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQobWF5YmVDYWxsYmFjayk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQud2FybmluZyhpdGVtKTtcbiAgcmV0dXJuIHsgdXVpZDogdXVpZCB9O1xufTtcblJvbGxiYXIud2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2Uud2FybmluZy5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heWJlQ2FsbGJhY2sgPSBfZ2V0Rmlyc3RGdW5jdGlvbihhcmd1bWVudHMpO1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQobWF5YmVDYWxsYmFjayk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oYXJndW1lbnRzKTtcbiAgdmFyIHV1aWQgPSBpdGVtLnV1aWQ7XG4gIHRoaXMuY2xpZW50LmVycm9yKGl0ZW0pO1xuICByZXR1cm4geyB1dWlkOiB1dWlkIH07XG59O1xuUm9sbGJhci5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuZXJyb3IuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXliZUNhbGxiYWNrID0gX2dldEZpcnN0RnVuY3Rpb24oYXJndW1lbnRzKTtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jcml0aWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC5jcml0aWNhbChpdGVtKTtcbiAgcmV0dXJuIHsgdXVpZDogdXVpZCB9O1xufTtcblJvbGxiYXIuY3JpdGljYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmNyaXRpY2FsLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5idWlsZEpzb25QYXlsb2FkKGl0ZW0pO1xufTtcblJvbGxiYXIuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuYnVpbGRKc29uUGF5bG9hZC5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZCgpO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5zZW5kSnNvblBheWxvYWQgPSBmdW5jdGlvbiAoanNvblBheWxvYWQpIHtcbiAgcmV0dXJuIHRoaXMuY2xpZW50LnNlbmRKc29uUGF5bG9hZChqc29uUGF5bG9hZCk7XG59O1xuUm9sbGJhci5zZW5kSnNvblBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLnNlbmRKc29uUGF5bG9hZC5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZCgpO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5zZXR1cFVuaGFuZGxlZENhcHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnV2luZG93ID0gX2dXaW5kb3coKTtcblxuICBpZiAoIXRoaXMudW5oYW5kbGVkRXhjZXB0aW9uc0luaXRpYWxpemVkKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXB0dXJlVW5jYXVnaHQgfHwgdGhpcy5vcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucykge1xuICAgICAgZ2xvYmFscy5jYXB0dXJlVW5jYXVnaHRFeGNlcHRpb25zKGdXaW5kb3csIHRoaXMpO1xuICAgICAgaWYgKHRoaXMud3JhcEdsb2JhbHMgJiYgdGhpcy5vcHRpb25zLndyYXBHbG9iYWxFdmVudEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMud3JhcEdsb2JhbHMoZ1dpbmRvdywgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVuaGFuZGxlZEV4Y2VwdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zSW5pdGlhbGl6ZWQpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMuY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMgfHxcbiAgICAgIHRoaXMub3B0aW9ucy5oYW5kbGVVbmhhbmRsZWRSZWplY3Rpb25zXG4gICAgKSB7XG4gICAgICBnbG9iYWxzLmNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zKGdXaW5kb3csIHRoaXMpO1xuICAgICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24gPSBmdW5jdGlvbiAoXG4gIG1lc3NhZ2UsXG4gIHVybCxcbiAgbGluZW5vLFxuICBjb2xubyxcbiAgZXJyb3IsXG4gIGNvbnRleHQsXG4pIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuY2FwdHVyZVVuY2F1Z2h0ICYmICF0aGlzLm9wdGlvbnMuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2hyb21lIHdpbGwgYWx3YXlzIHNlbmQgNSsgYXJndW1lbnRzIGFuZCBlcnJvciB3aWxsIGJlIHZhbGlkIG9yIG51bGwsIG5vdCB1bmRlZmluZWQuXG4gIC8vIElmIGVycm9yIGlzIHVuZGVmaW5lZCwgd2UgaGF2ZSBhIGRpZmZlcmVudCBjYWxsZXIuXG4gIC8vIENocm9tZSBhbHNvIHNlbmRzIGVycm9ycyBmcm9tIHdlYiB3b3JrZXJzIHdpdGggbnVsbCBlcnJvciwgYnV0IGRvZXMgbm90IGludm9rZVxuICAvLyBwcmVwYXJlU3RhY2tUcmFjZSgpIGZvciB0aGVzZS4gVGVzdCBmb3IgZW1wdHkgdXJsIHRvIHNraXAgdGhlbS5cbiAgaWYgKFxuICAgIHRoaXMub3B0aW9ucy5pbnNwZWN0QW5vbnltb3VzRXJyb3JzICYmXG4gICAgdGhpcy5pc0Nocm9tZSAmJlxuICAgIGVycm9yID09PSBudWxsICYmXG4gICAgdXJsID09PSAnJ1xuICApIHtcbiAgICByZXR1cm4gJ2Fub255bW91cyc7XG4gIH1cblxuICB2YXIgaXRlbTtcbiAgdmFyIHN0YWNrSW5mbyA9IF8ubWFrZVVuaGFuZGxlZFN0YWNrSW5mbyhcbiAgICBtZXNzYWdlLFxuICAgIHVybCxcbiAgICBsaW5lbm8sXG4gICAgY29sbm8sXG4gICAgZXJyb3IsXG4gICAgJ29uZXJyb3InLFxuICAgICd1bmNhdWdodCBleGNlcHRpb24nLFxuICAgIGVycm9yUGFyc2VyLFxuICApO1xuICBpZiAoXy5pc0Vycm9yKGVycm9yKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKFttZXNzYWdlLCBlcnJvciwgY29udGV4dF0pO1xuICAgIGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mbyA9IHN0YWNrSW5mbztcbiAgfSBlbHNlIGlmIChfLmlzRXJyb3IodXJsKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKFttZXNzYWdlLCB1cmwsIGNvbnRleHRdKTtcbiAgICBpdGVtLl91bmhhbmRsZWRTdGFja0luZm8gPSBzdGFja0luZm87XG4gIH0gZWxzZSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIGNvbnRleHRdKTtcbiAgICBpdGVtLnN0YWNrSW5mbyA9IHN0YWNrSW5mbztcbiAgfVxuICBpdGVtLmxldmVsID0gdGhpcy5vcHRpb25zLnVuY2F1Z2h0RXJyb3JMZXZlbDtcbiAgaXRlbS5faXNVbmNhdWdodCA9IHRydWU7XG4gIHRoaXMuY2xpZW50LmxvZyhpdGVtKTtcbn07XG5cbi8qKlxuICogQ2hyb21lIG9ubHkuIE90aGVyIGJyb3dzZXJzIHdpbGwgaWdub3JlLlxuICpcbiAqIFVzZSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSB0byBleHRyYWN0IGluZm9ybWF0aW9uIGFib3V0IGVycm9ycyB0aGF0XG4gKiBkbyBub3QgaGF2ZSBhIHZhbGlkIGVycm9yIG9iamVjdCBpbiBvbmVycm9yKCkuXG4gKlxuICogSW4gdGVzdGVkIHZlcnNpb24gb2YgQ2hyb21lLCBvbmVycm9yIGlzIGNhbGxlZCBmaXJzdCBidXQgaGFzIG5vIHdheVxuICogdG8gY29tbXVuaWNhdGUgd2l0aCBwcmVwYXJlU3RhY2tUcmFjZS4gVXNlIGEgY291bnRlciB0byBsZXQgdGhpc1xuICogaGFuZGxlciBrbm93IHdoaWNoIGVycm9ycyB0byBzZW5kIHRvIFJvbGxiYXIuXG4gKlxuICogSW4gY29uZmlnIG9wdGlvbnMsIHNldCBpbnNwZWN0QW5vbnltb3VzRXJyb3JzIHRvIGVuYWJsZS5cbiAqL1xuUm9sbGJhci5wcm90b3R5cGUuaGFuZGxlQW5vbnltb3VzRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5pbnNwZWN0QW5vbnltb3VzRXJyb3JzIHx8ICF0aGlzLmlzQ2hyb21lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHIgPSB0aGlzO1xuICBmdW5jdGlvbiBwcmVwYXJlU3RhY2tUcmFjZShlcnJvciwgX3N0YWNrKSB7XG4gICAgaWYgKHIub3B0aW9ucy5pbnNwZWN0QW5vbnltb3VzRXJyb3JzKSB7XG4gICAgICBpZiAoci5hbm9ueW1vdXNFcnJvcnNQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkga25vd24gd2F5IHRvIGRldGVjdCB0aGF0IG9uZXJyb3Igc2F3IGFuIGFub255bW91cyBlcnJvci5cbiAgICAgICAgLy8gSXQgZGVwZW5kcyBvbiBvbmVycm9yIHJlbGlhYmx5IGJlaW5nIGNhbGxlZCBiZWZvcmUgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UsXG4gICAgICAgIC8vIHdoaWNoIHNvIGZhciBob2xkcyB0cnVlIG9uIHRlc3RlZCB2ZXJzaW9ucyBvZiBDaHJvbWUuIElmIHZlcnNpb25zIG9mIENocm9tZVxuICAgICAgICAvLyBhcmUgdGVzdGVkIHRoYXQgYmVoYXZlIGRpZmZlcmVudGx5LCB0aGlzIGxvZ2ljIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICByLmFub255bW91c0Vycm9yc1BlbmRpbmcgLT0gMTtcblxuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgLy8gTm90IGxpa2VseSB0byBnZXQgaGVyZSwgYnV0IGNhbGxpbmcgaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24gZnJvbSBoZXJlXG4gICAgICAgICAgLy8gd2l0aG91dCBhbiBlcnJvciBvYmplY3Qgd291bGQgdGhyb3cgb2ZmIHRoZSBhbm9ueW1vdXNFcnJvcnNQZW5kaW5nIGNvdW50ZXIsXG4gICAgICAgICAgLy8gc28gcmV0dXJuIG5vdy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyB0aGlzIHRvIGJlIHRyYWNrZWQgbGF0ZXIuXG4gICAgICAgIGVycm9yLl9pc0Fub255bW91cyA9IHRydWU7XG5cbiAgICAgICAgLy8gdXJsLCBsaW5lbm8sIGNvbG5vIHNob3VsZG4ndCBiZSBuZWVkZWQgZm9yIHRoZXNlIGVycm9ycy5cbiAgICAgICAgLy8gSWYgdGhhdCBjaGFuZ2VzLCB1cGRhdGUgdGhpcyBhY2NvcmRpbmdseSwgdXNpbmcgdGhlIHVudXNlZFxuICAgICAgICAvLyBfc3RhY2sgcGFyYW0gYXMgbmVlZGVkIChyYXRoZXIgdGhhbiBwYXJzZSBlcnJvci50b1N0cmluZygpKS5cbiAgICAgICAgci5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbihlcnJvci5tZXNzYWdlLCBudWxsLCBudWxsLCBudWxsLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV29ya2Fyb3VuZCB0byBlbnN1cmUgc3RhY2sgaXMgcHJlc2VydmVkIGZvciBub3JtYWwgZXJyb3JzLlxuICAgIHJldHVybiBlcnJvci5zdGFjaztcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2RvY3Mvc3RhY2stdHJhY2UtYXBpXG4gIHRyeSB7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub3B0aW9ucy5pbnNwZWN0QW5vbnltb3VzRXJyb3JzID0gZmFsc2U7XG4gICAgdGhpcy5lcnJvcignYW5vbnltb3VzIGVycm9yIGhhbmRsZXIgZmFpbGVkJywgZSk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChyZWFzb24sIHByb21pc2UpIHtcbiAgaWYgKFxuICAgICF0aGlzLm9wdGlvbnMuY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMgJiZcbiAgICAhdGhpcy5vcHRpb25zLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbnNcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPSAndW5oYW5kbGVkIHJlamVjdGlvbiB3YXMgbnVsbCBvciB1bmRlZmluZWQhJztcbiAgaWYgKHJlYXNvbikge1xuICAgIGlmIChyZWFzb24ubWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSA9IHJlYXNvbi5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVhc29uUmVzdWx0ID0gXy5zdHJpbmdpZnkocmVhc29uKTtcbiAgICAgIGlmIChyZWFzb25SZXN1bHQudmFsdWUpIHtcbiAgICAgICAgbWVzc2FnZSA9IHJlYXNvblJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGNvbnRleHQgPVxuICAgIChyZWFzb24gJiYgcmVhc29uLl9yb2xsYmFyQ29udGV4dCkgfHwgKHByb21pc2UgJiYgcHJvbWlzZS5fcm9sbGJhckNvbnRleHQpO1xuXG4gIHZhciBpdGVtO1xuICBpZiAoXy5pc0Vycm9yKHJlYXNvbikpIHtcbiAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShbbWVzc2FnZSwgcmVhc29uLCBjb250ZXh0XSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIHJlYXNvbiwgY29udGV4dF0pO1xuICAgIGl0ZW0uc3RhY2tJbmZvID0gXy5tYWtlVW5oYW5kbGVkU3RhY2tJbmZvKFxuICAgICAgbWVzc2FnZSxcbiAgICAgICcnLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBudWxsLFxuICAgICAgJ3VuaGFuZGxlZHJlamVjdGlvbicsXG4gICAgICAnJyxcbiAgICAgIGVycm9yUGFyc2VyLFxuICAgICk7XG4gIH1cbiAgaXRlbS5sZXZlbCA9IHRoaXMub3B0aW9ucy51bmNhdWdodEVycm9yTGV2ZWw7XG4gIGl0ZW0uX2lzVW5jYXVnaHQgPSB0cnVlO1xuICBpdGVtLl9vcmlnaW5hbEFyZ3MgPSBpdGVtLl9vcmlnaW5hbEFyZ3MgfHwgW107XG4gIGl0ZW0uX29yaWdpbmFsQXJncy5wdXNoKHByb21pc2UpO1xuICB0aGlzLmNsaWVudC5sb2coaXRlbSk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKGYsIGNvbnRleHQsIF9iZWZvcmUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3R4Rm47XG4gICAgaWYgKF8uaXNGdW5jdGlvbihjb250ZXh0KSkge1xuICAgICAgY3R4Rm4gPSBjb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgfHwge307XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGYpKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBpZiAoZi5faXNXcmFwKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBpZiAoIWYuX3JvbGxiYXJfd3JhcHBlZCkge1xuICAgICAgZi5fcm9sbGJhcl93cmFwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX2JlZm9yZSAmJiBfLmlzRnVuY3Rpb24oX2JlZm9yZSkpIHtcbiAgICAgICAgICBfYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgICB2YXIgZSA9IGV4YztcbiAgICAgICAgICBpZiAoZSAmJiB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IgIT09IGUpIHtcbiAgICAgICAgICAgIGlmIChfLmlzVHlwZShlLCAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgZSA9IG5ldyBTdHJpbmcoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLl9yb2xsYmFyQ29udGV4dCA9IGN0eEZuKCkgfHwge307XG4gICAgICAgICAgICBlLl9yb2xsYmFyQ29udGV4dC5fd3JhcHBlZFNvdXJjZSA9IGYudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgd2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZi5fcm9sbGJhcl93cmFwcGVkLl9pc1dyYXAgPSB0cnVlO1xuXG4gICAgICBpZiAoZi5oYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGYpIHtcbiAgICAgICAgICBpZiAoZi5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwcm9wICE9PSAnX3JvbGxiYXJfd3JhcHBlZCcpIHtcbiAgICAgICAgICAgIGYuX3JvbGxiYXJfd3JhcHBlZFtwcm9wXSA9IGZbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGYuX3JvbGxiYXJfd3JhcHBlZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFJldHVybiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaWYgdGhlIHdyYXAgZmFpbHMuXG4gICAgcmV0dXJuIGY7XG4gIH1cbn07XG5Sb2xsYmFyLndyYXAgPSBmdW5jdGlvbiAoZiwgY29udGV4dCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS53cmFwKGYsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuY2FwdHVyZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXZlbnQgPSBfLmNyZWF0ZVRlbGVtZXRyeUV2ZW50KGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzLmNsaWVudC5jYXB0dXJlRXZlbnQoZXZlbnQudHlwZSwgZXZlbnQubWV0YWRhdGEsIGV2ZW50LmxldmVsKTtcbn07XG5Sb2xsYmFyLmNhcHR1cmVFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuY2FwdHVyZUV2ZW50LmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBmb2xsb3dpbmcgdHdvIG1ldGhvZHMgYXJlIHVzZWQgaW50ZXJuYWxseSBhbmQgYXJlIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuUm9sbGJhci5wcm90b3R5cGUuY2FwdHVyZURvbUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoZSwgdHMpIHtcbiAgaWYgKCF0cykge1xuICAgIHRzID0gbmV3IERhdGUoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbGllbnQuY2FwdHVyZURvbUNvbnRlbnRMb2FkZWQodHMpO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuY2FwdHVyZUxvYWQgPSBmdW5jdGlvbiAoZSwgdHMpIHtcbiAgaWYgKCF0cykge1xuICAgIHRzID0gbmV3IERhdGUoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbGllbnQuY2FwdHVyZUxvYWQodHMpO1xufTtcblxuLyogSW50ZXJuYWwgKi9cblxuZnVuY3Rpb24gYWRkVHJhbnNmb3Jtc1RvTm90aWZpZXIobm90aWZpZXIsIHJvbGxiYXIsIGdXaW5kb3cpIHtcbiAgbm90aWZpZXJcbiAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuaGFuZGxlRG9tRXhjZXB0aW9uKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5oYW5kbGVJdGVtV2l0aEVycm9yKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5lbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXkpXG4gICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmFkZEJhc2VJbmZvKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRSZXF1ZXN0SW5mbyhnV2luZG93KSlcbiAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkQ2xpZW50SW5mbyhnV2luZG93KSlcbiAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkUGx1Z2luSW5mbyhnV2luZG93KSlcbiAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkQm9keSlcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkTWVzc2FnZVdpdGhFcnJvcilcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkVGVsZW1ldHJ5RGF0YSlcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkQ29uZmlnVG9QYXlsb2FkKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRTY3J1YmJlcihyb2xsYmFyLnNjcnViKSlcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkUGF5bG9hZE9wdGlvbnMpXG4gICAgLmFkZFRyYW5zZm9ybShzaGFyZWRUcmFuc2Zvcm1zLnVzZXJUcmFuc2Zvcm0obG9nZ2VyKSlcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkQ29uZmlndXJlZE9wdGlvbnMpXG4gICAgLmFkZFRyYW5zZm9ybShzaGFyZWRUcmFuc2Zvcm1zLmFkZERpYWdub3N0aWNLZXlzKVxuICAgIC5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5pdGVtVG9QYXlsb2FkKTtcbn1cblxuZnVuY3Rpb24gYWRkUHJlZGljYXRlc1RvUXVldWUocXVldWUpIHtcbiAgcXVldWVcbiAgICAuYWRkUHJlZGljYXRlKHNoYXJlZFByZWRpY2F0ZXMuY2hlY2tMZXZlbClcbiAgICAuYWRkUHJlZGljYXRlKHByZWRpY2F0ZXMuY2hlY2tJZ25vcmUpXG4gICAgLmFkZFByZWRpY2F0ZShzaGFyZWRQcmVkaWNhdGVzLnVzZXJDaGVja0lnbm9yZShsb2dnZXIpKVxuICAgIC5hZGRQcmVkaWNhdGUoc2hhcmVkUHJlZGljYXRlcy51cmxJc05vdEJsb2NrTGlzdGVkKGxvZ2dlcikpXG4gICAgLmFkZFByZWRpY2F0ZShzaGFyZWRQcmVkaWNhdGVzLnVybElzU2FmZUxpc3RlZChsb2dnZXIpKVxuICAgIC5hZGRQcmVkaWNhdGUoc2hhcmVkUHJlZGljYXRlcy5tZXNzYWdlSXNJZ25vcmVkKGxvZ2dlcikpO1xufVxuXG5Sb2xsYmFyLnByb3RvdHlwZS5sb2FkRnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgbG9nZ2VyLmluZm8oXG4gICAgJ1VuZXhwZWN0ZWQgUm9sbGJhci5sb2FkRnVsbCgpIGNhbGxlZCBvbiBhIE5vdGlmaWVyIGluc3RhbmNlLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBSb2xsYmFyIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcy4nLFxuICApO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuX2NyZWF0ZUl0ZW0gPSBmdW5jdGlvbiAoYXJncykge1xuICByZXR1cm4gXy5jcmVhdGVJdGVtKGFyZ3MsIGxvZ2dlciwgdGhpcyk7XG59O1xuXG5mdW5jdGlvbiBfZ2V0Rmlyc3RGdW5jdGlvbihhcmdzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihhcmdzW2ldKSkge1xuICAgICAgcmV0dXJuIGFyZ3NbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9nV2luZG93KCkge1xuICByZXR1cm4gKFxuICAgICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHxcbiAgICAodHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZilcbiAgKTtcbn1cblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBzY3J1YkZpZWxkcyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMvc2NydWJGaWVsZHMnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICB2ZXJzaW9uOiBkZWZhdWx0cy52ZXJzaW9uLFxuICBzY3J1YkZpZWxkczogc2NydWJGaWVsZHMuc2NydWJGaWVsZHMsXG4gIGxvZ0xldmVsOiBkZWZhdWx0cy5sb2dMZXZlbCxcbiAgcmVwb3J0TGV2ZWw6IGRlZmF1bHRzLnJlcG9ydExldmVsLFxuICB1bmNhdWdodEVycm9yTGV2ZWw6IGRlZmF1bHRzLnVuY2F1Z2h0RXJyb3JMZXZlbCxcbiAgZW5kcG9pbnQ6IGRlZmF1bHRzLmVuZHBvaW50LFxuICB2ZXJib3NlOiBmYWxzZSxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgdHJhbnNtaXQ6IHRydWUsXG4gIHNlbmRDb25maWc6IGZhbHNlLFxuICBpbmNsdWRlSXRlbXNJblRlbGVtZXRyeTogdHJ1ZSxcbiAgY2FwdHVyZUlwOiB0cnVlLFxuICBpbnNwZWN0QW5vbnltb3VzRXJyb3JzOiB0cnVlLFxuICBpZ25vcmVEdXBsaWNhdGVFcnJvcnM6IHRydWUsXG4gIHdyYXBHbG9iYWxFdmVudEhhbmRsZXJzOiBmYWxzZSxcbiAgcmVjb3JkZXI6IHJlY29yZGVyRGVmYXVsdHMsXG4gIHRyYWNpbmc6IHRyYWNpbmdEZWZhdWx0cyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm9sbGJhcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzY3J1YkZpZWxkczogW1xuICAgICdwdycsXG4gICAgJ3Bhc3MnLFxuICAgICdwYXNzd2QnLFxuICAgICdwYXNzd29yZCcsXG4gICAgJ3NlY3JldCcsXG4gICAgJ2NvbmZpcm1fcGFzc3dvcmQnLFxuICAgICdjb25maXJtUGFzc3dvcmQnLFxuICAgICdwYXNzd29yZF9jb25maXJtYXRpb24nLFxuICAgICdwYXNzd29yZENvbmZpcm1hdGlvbicsXG4gICAgJ2FjY2Vzc190b2tlbicsXG4gICAgJ2FjY2Vzc1Rva2VuJyxcbiAgICAnWC1Sb2xsYmFyLUFjY2Vzcy1Ub2tlbicsXG4gICAgJ3NlY3JldF9rZXknLFxuICAgICdzZWNyZXRLZXknLFxuICAgICdzZWNyZXRUb2tlbicsXG4gICAgJ2NjLW51bWJlcicsXG4gICAgJ2NhcmQgbnVtYmVyJyxcbiAgICAnY2FyZG51bWJlcicsXG4gICAgJ2NhcmRudW0nLFxuICAgICdjY251bScsXG4gICAgJ2NjbnVtYmVyJyxcbiAgICAnY2MgbnVtJyxcbiAgICAnY3JlZGl0Y2FyZG51bWJlcicsXG4gICAgJ2NyZWRpdCBjYXJkIG51bWJlcicsXG4gICAgJ25ld2NyZWRpdGNhcmRudW1iZXInLFxuICAgICduZXcgY3JlZGl0IGNhcmQnLFxuICAgICdjcmVkaXRjYXJkbm8nLFxuICAgICdjcmVkaXQgY2FyZCBubycsXG4gICAgJ2NhcmQjJyxcbiAgICAnY2FyZCAjJyxcbiAgICAnY2MtY3NjJyxcbiAgICAnY3ZjJyxcbiAgICAnY3ZjMicsXG4gICAgJ2N2djInLFxuICAgICdjY3YyJyxcbiAgICAnc2VjdXJpdHkgY29kZScsXG4gICAgJ2NhcmQgdmVyaWZpY2F0aW9uJyxcbiAgICAnbmFtZSBvbiBjcmVkaXQgY2FyZCcsXG4gICAgJ25hbWUgb24gY2FyZCcsXG4gICAgJ25hbWVvbmNhcmQnLFxuICAgICdjYXJkaG9sZGVyJyxcbiAgICAnY2FyZCBob2xkZXInLFxuICAgICduYW1lIGRlcyBrYXJ0ZW5pbmhhYmVycycsXG4gICAgJ2NjbmFtZScsXG4gICAgJ2NhcmQgdHlwZScsXG4gICAgJ2NhcmR0eXBlJyxcbiAgICAnY2MgdHlwZScsXG4gICAgJ2NjdHlwZScsXG4gICAgJ3BheW1lbnQgdHlwZScsXG4gICAgJ2V4cGlyYXRpb24gZGF0ZScsXG4gICAgJ2V4cGlyYXRpb25kYXRlJyxcbiAgICAnZXhwZGF0ZScsXG4gICAgJ2NjLWV4cCcsXG4gICAgJ2NjbW9udGgnLFxuICAgICdjY3llYXInLFxuICBdLFxufTtcbiIsIi8vIFRoaXMgZGV0ZWN0aW9uLmpzIG1vZHVsZSBpcyB1c2VkIHRvIGVuY2Fwc3VsYXRlIGFueSB1Z2x5IGJyb3dzZXIvZmVhdHVyZVxuLy8gZGV0ZWN0aW9uIHdlIG1heSBuZWVkIHRvIGRvLlxuXG4vLyBGaWd1cmUgb3V0IHdoaWNoIHZlcnNpb24gb2YgSUUgd2UncmUgdXNpbmcsIGlmIGFueS5cbi8vIFRoaXMgaXMgZ2xlYW5lZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTU3NDg0Mi9iZXN0LXdheS10by1jaGVjay1mb3ItaWUtbGVzcy10aGFuLTktaW4tamF2YXNjcmlwdC13aXRob3V0LWxpYnJhcnlcbi8vIFdpbGwgcmV0dXJuIGFuIGludGVnZXIgb24gSUUgKGkuZS4gOClcbi8vIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBvdGhlcndpc2VcbmZ1bmN0aW9uIGdldElFVmVyc2lvbigpIHtcbiAgdmFyIHVuZGVmO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZjtcbiAgfVxuXG4gIHZhciB2ID0gMyxcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2knKTtcblxuICB3aGlsZSAoXG4gICAgKChkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArICsrdiArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nKSwgYWxsWzBdKVxuICApO1xuXG4gIHJldHVybiB2ID4gNCA/IHYgOiB1bmRlZjtcbn1cblxudmFyIERldGVjdGlvbiA9IHtcbiAgaWVWZXJzaW9uOiBnZXRJRVZlcnNpb24sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERldGVjdGlvbjtcbiIsImZ1bmN0aW9uIGdldEVsZW1lbnRUeXBlKGUpIHtcbiAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBpc0Rlc2NyaWJlZEVsZW1lbnQoZWxlbWVudCwgdHlwZSwgc3VidHlwZXMpIHtcbiAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFzdWJ0eXBlcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsZW1lbnQgPSBnZXRFbGVtZW50VHlwZShlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdWJ0eXBlc1tpXSA9PT0gZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEZyb21FdmVudChldnQsIGRvYykge1xuICBpZiAoZXZ0LnRhcmdldCkge1xuICAgIHJldHVybiBldnQudGFyZ2V0O1xuICB9XG4gIGlmIChkb2MgJiYgZG9jLmVsZW1lbnRGcm9tUG9pbnQpIHtcbiAgICByZXR1cm4gZG9jLmVsZW1lbnRGcm9tUG9pbnQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB0cmVlVG9BcnJheShlbGVtKSB7XG4gIHZhciBNQVhfSEVJR0hUID0gNTtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgbmV4dERlc2NyaXB0aW9uO1xuICBmb3IgKHZhciBoZWlnaHQgPSAwOyBlbGVtICYmIGhlaWdodCA8IE1BWF9IRUlHSFQ7IGhlaWdodCsrKSB7XG4gICAgbmV4dERlc2NyaXB0aW9uID0gZGVzY3JpYmVFbGVtZW50KGVsZW0pO1xuICAgIGlmIChuZXh0RGVzY3JpcHRpb24udGFnTmFtZSA9PT0gJ2h0bWwnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3V0LnVuc2hpZnQobmV4dERlc2NyaXB0aW9uKTtcbiAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRBcnJheVRvU3RyaW5nKGEpIHtcbiAgdmFyIE1BWF9MRU5HVEggPSA4MDtcbiAgdmFyIHNlcGFyYXRvciA9ICcgPiAnLFxuICAgIHNlcGFyYXRvckxlbmd0aCA9IHNlcGFyYXRvci5sZW5ndGg7XG4gIHZhciBvdXQgPSBbXSxcbiAgICBsZW4gPSAwLFxuICAgIG5leHRTdHIsXG4gICAgdG90YWxMZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBuZXh0U3RyID0gZGVzY3JpcHRpb25Ub1N0cmluZyhhW2ldKTtcbiAgICB0b3RhbExlbmd0aCA9IGxlbiArIG91dC5sZW5ndGggKiBzZXBhcmF0b3JMZW5ndGggKyBuZXh0U3RyLmxlbmd0aDtcbiAgICBpZiAoaSA8IGEubGVuZ3RoIC0gMSAmJiB0b3RhbExlbmd0aCA+PSBNQVhfTEVOR1RIICsgMykge1xuICAgICAgb3V0LnVuc2hpZnQoJy4uLicpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG91dC51bnNoaWZ0KG5leHRTdHIpO1xuICAgIGxlbiArPSBuZXh0U3RyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gb3V0LmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpcHRpb25Ub1N0cmluZyhkZXNjKSB7XG4gIGlmICghZGVzYyB8fCAhZGVzYy50YWdOYW1lKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBvdXQgPSBbZGVzYy50YWdOYW1lXTtcbiAgaWYgKGRlc2MuaWQpIHtcbiAgICBvdXQucHVzaCgnIycgKyBkZXNjLmlkKTtcbiAgfVxuICBpZiAoZGVzYy5jbGFzc2VzKSB7XG4gICAgb3V0LnB1c2goJy4nICsgZGVzYy5jbGFzc2VzLmpvaW4oJy4nKSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXQucHVzaChcbiAgICAgICdbJyArIGRlc2MuYXR0cmlidXRlc1tpXS5rZXkgKyAnPVwiJyArIGRlc2MuYXR0cmlidXRlc1tpXS52YWx1ZSArICdcIl0nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gb3V0LmpvaW4oJycpO1xufVxuXG4vKipcbiAqIElucHV0OiBhIGRvbSBlbGVtZW50XG4gKiBPdXRwdXQ6IG51bGwgaWYgdGFnTmFtZSBpcyBmYWxzZXkgb3IgaW5wdXQgaXMgZmFsc2V5LCBlbHNlXG4gKiAge1xuICogICAgdGFnTmFtZTogU3RyaW5nLFxuICogICAgaWQ6IFN0cmluZyB8IHVuZGVmaW5lZCxcbiAqICAgIGNsYXNzZXM6IFtTdHJpbmddIHwgdW5kZWZpbmVkLFxuICogICAgYXR0cmlidXRlczogW1xuICogICAgICB7XG4gKiAgICAgICAga2V5OiBPbmVPZih0eXBlLCBuYW1lLCB0aXRsZSwgYWx0KSxcbiAqICAgICAgICB2YWx1ZTogU3RyaW5nXG4gKiAgICAgIH1cbiAqICAgIF1cbiAqICB9XG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudChlbGVtKSB7XG4gIGlmICghZWxlbSB8fCAhZWxlbS50YWdOYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG91dCA9IHt9LFxuICAgIGNsYXNzTmFtZSxcbiAgICBrZXksXG4gICAgYXR0cixcbiAgICBpO1xuICBvdXQudGFnTmFtZSA9IGVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoZWxlbS5pZCkge1xuICAgIG91dC5pZCA9IGVsZW0uaWQ7XG4gIH1cbiAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWU7XG4gIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBvdXQuY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuICB9XG4gIHZhciBhdHRyaWJ1dGVzID0gWyd0eXBlJywgJ25hbWUnLCAndGl0bGUnLCAnYWx0J107XG4gIG91dC5hdHRyaWJ1dGVzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gYXR0cmlidXRlc1tpXTtcbiAgICBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICBpZiAoYXR0cikge1xuICAgICAgb3V0LmF0dHJpYnV0ZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogYXR0ciB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc2NyaWJlRWxlbWVudDogZGVzY3JpYmVFbGVtZW50LFxuICBkZXNjcmlwdGlvblRvU3RyaW5nOiBkZXNjcmlwdGlvblRvU3RyaW5nLFxuICBlbGVtZW50QXJyYXlUb1N0cmluZzogZWxlbWVudEFycmF5VG9TdHJpbmcsXG4gIHRyZWVUb0FycmF5OiB0cmVlVG9BcnJheSxcbiAgZ2V0RWxlbWVudEZyb21FdmVudDogZ2V0RWxlbWVudEZyb21FdmVudCxcbiAgaXNEZXNjcmliZWRFbGVtZW50OiBpc0Rlc2NyaWJlZEVsZW1lbnQsXG4gIGdldEVsZW1lbnRUeXBlOiBnZXRFbGVtZW50VHlwZSxcbn07XG4iLCJmdW5jdGlvbiBjYXB0dXJlVW5jYXVnaHRFeGNlcHRpb25zKHdpbmRvdywgaGFuZGxlciwgc2hpbSkge1xuICBpZiAoIXdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2xkT25FcnJvcjtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIuX3JvbGxiYXJPbGRPbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb2xkT25FcnJvciA9IGhhbmRsZXIuX3JvbGxiYXJPbGRPbkVycm9yO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKSB7XG4gICAgb2xkT25FcnJvciA9IHdpbmRvdy5vbmVycm9yO1xuICAgIHdoaWxlIChvbGRPbkVycm9yLl9yb2xsYmFyT2xkT25FcnJvcikge1xuICAgICAgb2xkT25FcnJvciA9IG9sZE9uRXJyb3IuX3JvbGxiYXJPbGRPbkVycm9yO1xuICAgIH1cbiAgICBoYW5kbGVyLl9yb2xsYmFyT2xkT25FcnJvciA9IG9sZE9uRXJyb3I7XG4gIH1cblxuICBoYW5kbGVyLmhhbmRsZUFub255bW91c0Vycm9ycygpO1xuXG4gIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgX3JvbGxiYXJXaW5kb3dPbkVycm9yKHdpbmRvdywgaGFuZGxlciwgb2xkT25FcnJvciwgYXJncyk7XG4gIH07XG4gIGlmIChzaGltKSB7XG4gICAgZm4uX3JvbGxiYXJPbGRPbkVycm9yID0gb2xkT25FcnJvcjtcbiAgfVxuICB3aW5kb3cub25lcnJvciA9IGZuO1xufVxuXG5mdW5jdGlvbiBfcm9sbGJhcldpbmRvd09uRXJyb3Iod2luZG93LCByLCBvbGQsIGFyZ3MpIHtcbiAgaWYgKHdpbmRvdy5fcm9sbGJhcldyYXBwZWRFcnJvcikge1xuICAgIGlmICghYXJnc1s0XSkge1xuICAgICAgYXJnc1s0XSA9IHdpbmRvdy5fcm9sbGJhcldyYXBwZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKCFhcmdzWzVdKSB7XG4gICAgICBhcmdzWzVdID0gd2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yLl9yb2xsYmFyQ29udGV4dDtcbiAgICB9XG4gICAgd2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yID0gbnVsbDtcbiAgfVxuXG4gIHZhciByZXQgPSByLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uLmFwcGx5KHIsIGFyZ3MpO1xuXG4gIGlmIChvbGQpIHtcbiAgICBvbGQuYXBwbHkod2luZG93LCBhcmdzKTtcbiAgfVxuXG4gIC8vIExldCBvdGhlciBjaGFpbmVkIG9uZXJyb3IgaGFuZGxlcnMgYWJvdmUgcnVuIGJlZm9yZSBzZXR0aW5nIHRoaXMuXG4gIC8vIElmIGFuIGVycm9yIGlzIHRocm93biBhbmQgY2F1Z2h0IHdpdGhpbiBhIGNoYWluZWQgb25lcnJvciBoYW5kbGVyLFxuICAvLyBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSgpIHdpbGwgc2VlIHRoYXQgb25lIGJlZm9yZSB0aGUgb25lIHdlIHdhbnQuXG4gIGlmIChyZXQgPT09ICdhbm9ueW1vdXMnKSB7XG4gICAgci5hbm9ueW1vdXNFcnJvcnNQZW5kaW5nICs9IDE7IC8vIFNlZSBSb2xsYmFyLnByb3RvdHlwZS5oYW5kbGVBbm9ueW1vdXNFcnJvcnMoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zKHdpbmRvdywgaGFuZGxlciwgc2hpbSkge1xuICBpZiAoIXdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93Ll9yb2xsYmFyVVJIID09PSAnZnVuY3Rpb24nICYmXG4gICAgd2luZG93Ll9yb2xsYmFyVVJILmJlbG9uZ3NUb1NoaW1cbiAgKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHdpbmRvdy5fcm9sbGJhclVSSCk7XG4gIH1cblxuICB2YXIgcmVqZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgcmVhc29uLCBwcm9taXNlLCBkZXRhaWw7XG4gICAgdHJ5IHtcbiAgICAgIHJlYXNvbiA9IGV2dC5yZWFzb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcHJvbWlzZSA9IGV2dC5wcm9taXNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2UgPSAnW3VuaGFuZGxlZHJlamVjdGlvbl0gZXJyb3IgZ2V0dGluZyBgcHJvbWlzZWAgZnJvbSBldmVudCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkZXRhaWwgPSBldnQuZGV0YWlsO1xuICAgICAgaWYgKCFyZWFzb24gJiYgZGV0YWlsKSB7XG4gICAgICAgIHJlYXNvbiA9IGRldGFpbC5yZWFzb247XG4gICAgICAgIHByb21pc2UgPSBkZXRhaWwucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICB9XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHJlYXNvbiA9ICdbdW5oYW5kbGVkcmVqZWN0aW9uXSBlcnJvciBnZXR0aW5nIGByZWFzb25gIGZyb20gZXZlbnQnO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXIuaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uKSB7XG4gICAgICBoYW5kbGVyLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbihyZWFzb24sIHByb21pc2UpO1xuICAgIH1cbiAgfTtcbiAgcmVqZWN0aW9uSGFuZGxlci5iZWxvbmdzVG9TaGltID0gc2hpbTtcbiAgd2luZG93Ll9yb2xsYmFyVVJIID0gcmVqZWN0aW9uSGFuZGxlcjtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHJlamVjdGlvbkhhbmRsZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2FwdHVyZVVuY2F1Z2h0RXhjZXB0aW9uczogY2FwdHVyZVVuY2F1Z2h0RXhjZXB0aW9ucyxcbiAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zLFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbnJlcXVpcmUoJ2NvbnNvbGUtcG9seWZpbGwnKTtcbnZhciBkZXRlY3Rpb24gPSByZXF1aXJlKCcuL2RldGVjdGlvbicpO1xudmFyIF8gPSByZXF1aXJlKCcuLi91dGlsaXR5Jyk7XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcbiAgaWYgKGRldGVjdGlvbi5pZVZlcnNpb24oKSA8PSA4KSB7XG4gICAgY29uc29sZS5lcnJvcihfLmZvcm1hdEFyZ3NBc1N0cmluZyhhcmdzKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmZvKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcbiAgaWYgKGRldGVjdGlvbi5pZVZlcnNpb24oKSA8PSA4KSB7XG4gICAgY29uc29sZS5pbmZvKF8uZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcbiAgaWYgKGRldGVjdGlvbi5pZVZlcnNpb24oKSA8PSA4KSB7XG4gICAgY29uc29sZS5sb2coXy5mb3JtYXRBcmdzQXNTdHJpbmcoYXJncykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXJyb3I6IGVycm9yLFxuICBpbmZvOiBpbmZvLFxuICBsb2c6IGxvZyxcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWxpdHknKTtcblxuZnVuY3Rpb24gY2hlY2tJZ25vcmUoaXRlbSwgc2V0dGluZ3MpIHtcbiAgaWYgKF8uZ2V0KHNldHRpbmdzLCAncGx1Z2lucy5qcXVlcnkuaWdub3JlQWpheEVycm9ycycpKSB7XG4gICAgcmV0dXJuICFfLmdldChpdGVtLCAnYm9keS5tZXNzYWdlLmV4dHJhLmlzQWpheCcpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hlY2tJZ25vcmU6IGNoZWNrSWdub3JlLFxufTtcbiIsIi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgcnJ3ZWIgcmVjb3JkZXJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcnJ3ZWItaW8vcnJ3ZWIvYmxvYi9tYXN0ZXIvZ3VpZGUubWQjb3B0aW9ucyBmb3IgZGV0YWlsc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIGVuYWJsZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHJlY29yZGluZyBpcyBlbmFibGVkXG4gIGF1dG9TdGFydDogdHJ1ZSwgLy8gU3RhcnQgcmVjb3JkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBSb2xsYmFyIGluaXRpYWxpemVzXG4gIGRlYnVnOiB7XG4gICAgbG9nRW1pdHM6IGZhbHNlLCAvLyBXaGV0aGVyIHRvIGxvZyBlbWl0dGVkIGV2ZW50c1xuICB9LFxuXG4gIC8vIFJlY29yZGluZyBvcHRpb25zXG4gIGlubGluZVN0eWxlc2hlZXQ6IHRydWUsIC8vIFdoZXRoZXIgdG8gaW5saW5lIHN0eWxlc2hlZXRzIHRvIGltcHJvdmUgcmVwbGF5IGFjY3VyYWN5XG4gIGlubGluZUltYWdlczogZmFsc2UsIC8vIFdoZXRoZXIgdG8gcmVjb3JkIHRoZSBpbWFnZSBjb250ZW50XG4gIGNvbGxlY3RGb250czogdHJ1ZSwgLy8gV2hldGhlciB0byBjb2xsZWN0IGZvbnRzIGluIHRoZSB3ZWJzaXRlXG5cbiAgLy8gUHJpdmFjeSBvcHRpb25zXG4gIC8vIEZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgd2hpY2ggaW5wdXQgdHlwZXMgdG8gbWFza1xuICAvLyBCeSBkZWZhdWx0IG9ubHkgcGFzc3dvcmQgaW5wdXRzIGFyZSBtYXNrZWQgaWYgbWFza0lucHV0cyBpcyB0cnVlXG4gIG1hc2tJbnB1dE9wdGlvbnM6IHtcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICBlbWFpbDogZmFsc2UsXG4gICAgdGVsOiBmYWxzZSxcbiAgICB0ZXh0OiBmYWxzZSxcbiAgICBjb2xvcjogZmFsc2UsXG4gICAgZGF0ZTogZmFsc2UsXG4gICAgJ2RhdGV0aW1lLWxvY2FsJzogZmFsc2UsXG4gICAgbW9udGg6IGZhbHNlLFxuICAgIG51bWJlcjogZmFsc2UsXG4gICAgcmFuZ2U6IGZhbHNlLFxuICAgIHNlYXJjaDogZmFsc2UsXG4gICAgdGltZTogZmFsc2UsXG4gICAgdXJsOiBmYWxzZSxcbiAgICB3ZWVrOiBmYWxzZSxcbiAgfSxcblxuICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcGFydHMgb2YgdGhlIERPTVxuICAvLyBCeSBkZWZhdWx0IGFsbCByZW1vdmFibGUgZWxlbWVudHMgYXJlIHJlbW92ZWRcbiAgc2xpbURPTU9wdGlvbnM6IHtcbiAgICBzY3JpcHQ6IHRydWUsIC8vIFJlbW92ZSBzY3JpcHQgZWxlbWVudHNcbiAgICBjb21tZW50OiB0cnVlLCAvLyBSZW1vdmUgY29tbWVudHNcbiAgICBoZWFkRmF2aWNvbjogdHJ1ZSwgLy8gUmVtb3ZlIGZhdmljb25zIGluIHRoZSBoZWFkXG4gICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsIC8vIFJlbW92ZSB3aGl0ZXNwYWNlIGluIGhlYWRcbiAgICBoZWFkTWV0YURlc2NLZXl3b3JkczogdHJ1ZSwgLy8gUmVtb3ZlIG1ldGEgZGVzY3JpcHRpb24gYW5kIGtleXdvcmRzXG4gICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsIC8vIFJlbW92ZSBzb2NpYWwgbWVkaWEgbWV0YSB0YWdzXG4gICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsIC8vIFJlbW92ZSByb2JvdHMgbWV0YSBkaXJlY3RpdmVzXG4gICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsIC8vIFJlbW92ZSBodHRwLWVxdWl2IG1ldGEgZGlyZWN0aXZlc1xuICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSwgLy8gUmVtb3ZlIGF1dGhvcnNoaXAgbWV0YSBkaXJlY3RpdmVzXG4gICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsIC8vIFJlbW92ZSB2ZXJpZmljYXRpb24gbWV0YSBkaXJlY3RpdmVzXG4gIH0sXG5cbiAgLy8gQ3VzdG9tIGNhbGxiYWNrcyBmb3IgYWR2YW5jZWQgdXNlIGNhc2VzXG4gIC8vIFRoZXNlIGFyZSB1bmRlZmluZWQgYnkgZGVmYXVsdCBhbmQgY2FuIGJlIHNldCBwcm9ncmFtbWF0aWNhbGx5XG4gIC8vIG1hc2tJbnB1dEZuOiB1bmRlZmluZWQsICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIG1hc2sgaW5wdXQgdmFsdWVzXG4gIC8vIG1hc2tUZXh0Rm46IHVuZGVmaW5lZCwgICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIG1hc2sgdGV4dCBjb250ZW50XG4gIC8vIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLCAgICAgLy8gQ3VzdG9tIGVycm9yIGhhbmRsZXIgZm9yIHJlY29yZGluZyBlcnJvcnNcblxuICAvLyBQbHVnaW4gc3lzdGVtXG4gIC8vIHBsdWdpbnM6IFtdICAgICAgICAgICAgICAgICAgLy8gTGlzdCBvZiBwbHVnaW5zIHRvIHVzZSAobXVzdCBiZSBzZXQgcHJvZ3JhbW1hdGljYWxseSlcbn07XG4iLCJpbXBvcnQgeyByZWNvcmQgYXMgcnJ3ZWJSZWNvcmRGbiB9IGZyb20gJ0BycndlYi9yZWNvcmQnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSAnQHJyd2ViL3R5cGVzJztcblxuaW1wb3J0IGhydGltZSBmcm9tICcuLi8uLi90cmFjaW5nL2hydGltZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY29yZGVyIHtcbiAgI29wdGlvbnM7XG4gICNzdG9wRm4gPSBudWxsO1xuICAjcmVjb3JkRm47XG4gICNldmVudHMgPSB7XG4gICAgcHJldmlvdXM6IFtdLFxuICAgIGN1cnJlbnQ6IFtdLFxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJlY29yZGVyIGluc3RhbmNlIGZvciBjYXB0dXJpbmcgRE9NIGV2ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJlY29yZGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWNvcmRGbj1ycndlYlJlY29yZEZuXSAtIFRoZSByZWNvcmRpbmcgZnVuY3Rpb24gdG8gdXNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZWNvcmRGbiA9IHJyd2ViUmVjb3JkRm4pIHtcbiAgICBpZiAoIXJlY29yZEZuKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ3JlY29yZEZuJyB0byBiZSBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IEluaXRpYWxpemluZy4uLicpO1xuICAgIGNvbnNvbGUubG9nKCdvcHRpb25zJywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLiNvcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0aGlzLiNyZWNvcmRGbiA9IHJlY29yZEZuO1xuICB9XG5cbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9wRm4gIT09IG51bGw7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZ3VyZShuZXdPcHRpb25zKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZShuZXdPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcgJiYgbmV3T3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuXG4gICAgdGhpcy4jb3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgcmVjb3JkZWQgZXZlbnRzIGludG8gYSBmb3JtYXR0ZWQgcGF5bG9hZCByZWFkeSBmb3IgdHJhbnNwb3J0LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgcmVjb3JkZXIncyBzdG9yZWQgZXZlbnRzLCBjcmVhdGVzIGEgbmV3IHNwYW4gd2l0aCB0aGVcbiAgICogcHJvdmlkZWQgdHJhY2luZyBjb250ZXh0LCBhdHRhY2hlcyBhbGwgZXZlbnRzIHdpdGggdGhlaXIgdGltZXN0YW1wcyBhcyBzcGFuXG4gICAqIGV2ZW50cywgYW5kIHRoZW4gcmV0dXJucyBhIHBheWxvYWQgcmVhZHkgZm9yIHRyYW5zcG9ydCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhY2luZyAtIFRoZSB0cmFjaW5nIHN5c3RlbSBpbnN0YW5jZSB0byBjcmVhdGUgc3BhbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVW5pcXVlIGlkZW50aWZpZXIgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyByZXBsYXkgcmVjb3JkaW5nXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gQSBmb3JtYXR0ZWQgcGF5bG9hZCBjb250YWluaW5nIHNwYW5zIGRhdGEgaW4gT1RMUCBmb3JtYXQsIG9yIG51bGwgaWYgbm8gZXZlbnRzIGV4aXN0XG4gICAqL1xuICBkdW1wKHRyYWNpbmcsIHJlcGxheUlkLCBvY2N1cnJlbmNlVXVpZCkge1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuI2V2ZW50cy5wcmV2aW91cy5jb25jYXQodGhpcy4jZXZlbnRzLmN1cnJlbnQpO1xuXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFJlY29yZGVyLmR1bXA6IE1pbiAyIGV2ZW50cyByZXEuIEZvdW5kICR7ZXZlbnRzLmxlbmd0aH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBSZWNvcmRlci5kdW1wOiBEdW1waW5nICR7ZXZlbnRzLmxlbmd0aH0gZXZlbnRzYCk7XG5cbiAgICBjb25zdCByZWNvcmRpbmdTcGFuID0gdHJhY2luZy5zdGFydFNwYW4oJ3Jyd2ViLXJlcGxheS1yZWNvcmRpbmcnLCB7fSk7XG5cbiAgICByZWNvcmRpbmdTcGFuLnNldEF0dHJpYnV0ZSgncm9sbGJhci5yZXBsYXkuaWQnLCByZXBsYXlJZCk7XG5cbiAgICBpZiAob2NjdXJyZW5jZVV1aWQpIHtcbiAgICAgIHJlY29yZGluZ1NwYW4uc2V0QXR0cmlidXRlKCdyb2xsYmFyLm9jY3VycmVuY2UudXVpZCcsIG9jY3VycmVuY2VVdWlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBlYXJsaWVzdEV2ZW50ID0gZXZlbnRzLnJlZHVjZSgoZWFybGllc3RFdmVudCwgZXZlbnQpID0+XG4gICAgICBldmVudC50aW1lc3RhbXAgPCBlYXJsaWVzdEV2ZW50LnRpbWVzdGFtcCA/IGV2ZW50IDogZWFybGllc3RFdmVudCxcbiAgICApO1xuXG4gICAgcmVjb3JkaW5nU3Bhbi5zcGFuLnN0YXJ0VGltZSA9IGhydGltZS5mcm9tTWlsbGlzKGVhcmxpZXN0RXZlbnQudGltZXN0YW1wKTtcblxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICByZWNvcmRpbmdTcGFuLmFkZEV2ZW50KFxuICAgICAgICAncnJ3ZWItcmVwbGF5LWV2ZW50cycsXG4gICAgICAgIHtcbiAgICAgICAgICBldmVudFR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAganNvbjogSlNPTi5zdHJpbmdpZnkoZXZlbnQuZGF0YSksXG4gICAgICAgICAgJ3JvbGxiYXIucmVwbGF5LmlkJzogcmVwbGF5SWQsXG4gICAgICAgIH0sXG4gICAgICAgIGhydGltZS5mcm9tTWlsbGlzKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICApO1xuICAgIH1cblxuICAgIHJlY29yZGluZ1NwYW4uZW5kKCk7XG5cbiAgICByZXR1cm4gdHJhY2luZy5leHBvcnRlci50b1BheWxvYWQoKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLmlzUmVjb3JkaW5nIHx8IHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBBbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlcjogRGlzYWJsZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IFN0YXJ0aW5nLi4uJyk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB0aGlzLiNzdG9wRm4gPSB0aGlzLiNyZWNvcmRGbih7XG4gICAgICBlbWl0OiAoZXZlbnQsIGlzQ2hlY2tvdXQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zz8ubG9nRW1pdHMpIHtcbiAgICAgICAgICB0aGlzLl9sb2dFdmVudChldmVudCwgaXNDaGVja291dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDaGVja291dCAmJiBldmVudC50eXBlID09PSBFdmVudFR5cGUuTWV0YSkge1xuICAgICAgICAgIHRoaXMuI2V2ZW50cy5wcmV2aW91cyA9IHRoaXMuI2V2ZW50cy5jdXJyZW50O1xuICAgICAgICAgIHRoaXMuI2V2ZW50cy5jdXJyZW50ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNldmVudHMuY3VycmVudC5wdXNoKGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBjaGVja291dEV2ZXJ5Tm1zOiA1ICogNjAgKiAxMDAwLCAvLyA1IG1pbnV0ZXNcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlcjogU3RhcnRlZCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGlmICghdGhpcy5pc1JlY29yZGluZykge1xuICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBBbHJlYWR5IHN0b3BwZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IFN0b3BwaW5nLi4uJyk7XG5cbiAgICB0aGlzLiNzdG9wRm4oKTtcbiAgICB0aGlzLiNzdG9wRm4gPSBudWxsO1xuXG4gICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBTdG9wcGVkJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuI2V2ZW50cyA9IHtcbiAgICAgIHByZXZpb3VzOiBbXSxcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgIH07XG4gIH1cblxuICBfbG9nRXZlbnQoZXZlbnQsIGlzQ2hlY2tvdXQpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBSZWNvcmRlcjogJHtpc0NoZWNrb3V0ID8gJ2NoZWNrb3V0JyA6ICcnfSBldmVudFxcbmAsXG4gICAgICAoKGUpID0+IHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBlLFxuICAgICAgICAgIChfLCB2KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHYpKSByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICAgICAgICBzZWVuLmFkZCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgMixcbiAgICAgICAgKTtcbiAgICAgIH0pKGV2ZW50KSxcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgaWQgZnJvbSAnLi4vLi4vdHJhY2luZy9pZC5qcyc7XG5cbi8qKlxuICogUmVwbGF5TWFwIC0gTWFuYWdlcyB0aGUgbWFwcGluZyBiZXR3ZWVuIGVycm9yIG9jY3VycmVuY2VzIGFuZCB0aGVpciBhc3NvY2lhdGVkXG4gKiBzZXNzaW9uIHJlY29yZGluZ3MuIFRoaXMgY2xhc3MgaGFuZGxlcyB0aGUgY29vcmRpbmF0aW9uIGJldHdlZW4gd2hlbiByZWNvcmRpbmdzXG4gKiBhcmUgZHVtcGVkIGFuZCB3aGVuIHRoZXkgYXJlIGV2ZW50dWFsbHkgc2VudCB0byB0aGUgYmFja2VuZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVwbGF5TWFwIHtcbiAgI21hcDtcbiAgI3JlY29yZGVyO1xuICAjYXBpO1xuICAjdHJhY2luZztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSZXBsYXlNYXAgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gQ29uZmlndXJhdGlvbiBwcm9wc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMucmVjb3JkZXIgLSBUaGUgcmVjb3JkZXIgaW5zdGFuY2UgdGhhdCBkdW1wcyByZXBsYXkgZGF0YSBpbnRvIHNwYW5zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5hcGkgLSBUaGUgQVBJIGluc3RhbmNlIHVzZWQgdG8gc2VuZCByZXBsYXkgcGF5bG9hZHMgdG8gdGhlIGJhY2tlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzLnRyYWNpbmcgLSBUaGUgdHJhY2luZyBpbnN0YW5jZSB1c2VkIHRvIGNyZWF0ZSBzcGFucyBhbmQgbWFuYWdlIGNvbnRleHRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgcmVjb3JkZXIsIGFwaSwgdHJhY2luZyB9KSB7XG4gICAgaWYgKCFyZWNvcmRlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdyZWNvcmRlcicgdG8gYmUgcHJvdmlkZWRcIik7XG4gICAgfVxuXG4gICAgaWYgKCFhcGkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnYXBpJyB0byBiZSBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWNpbmcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAndHJhY2luZycgdG8gYmUgcHJvdmlkZWRcIik7XG4gICAgfVxuXG4gICAgdGhpcy4jbWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuI3JlY29yZGVyID0gcmVjb3JkZXI7XG4gICAgdGhpcy4jYXBpID0gYXBpO1xuICAgIHRoaXMuI3RyYWNpbmcgPSB0cmFjaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHJlcGxheSBieSBjb252ZXJ0aW5nIHJlY29yZGVyIGV2ZW50cyBpbnRvIGEgdHJhbnNwb3J0LXJlYWR5IHBheWxvYWQuXG4gICAqXG4gICAqIENhbGxzIHJlY29yZGVyLmR1bXAoKSB0byBjYXB0dXJlIGV2ZW50cyBhcyBzcGFucywgZm9ybWF0cyB0aGVtIGludG8gYSBwcm9wZXIgcGF5bG9hZCxcbiAgICogYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBtYXAgdXNpbmcgcmVwbGF5SWQgYXMgdGhlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIHVuaXF1ZSBJRCBmb3IgdGhpcyByZXBsYXlcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJvY2Vzc2VkIHJlcGxheUlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfcHJvY2Vzc1JlcGxheShyZXBsYXlJZCwgb2NjdXJyZW5jZVV1aWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuI3JlY29yZGVyLmR1bXAodGhpcy4jdHJhY2luZywgcmVwbGF5SWQsIG9jY3VycmVuY2VVdWlkKTtcblxuICAgICAgdGhpcy4jbWFwLnNldChyZXBsYXlJZCwgcGF5bG9hZCk7XG4gICAgfSBjYXRjaCAodHJhbnNmb3JtRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRyYW5zZm9ybWluZyBzcGFuczonLCB0cmFuc2Zvcm1FcnJvcik7XG5cbiAgICAgIHRoaXMuI21hcC5zZXQocmVwbGF5SWQsIG51bGwpOyAvLyBUT0RPKG1hdHV4KTogRXJyb3Igc3Bhbj9cbiAgICB9XG5cbiAgICByZXR1cm4gcmVwbGF5SWQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHJlcGxheSB0byB0aGUgbWFwIGFuZCByZXR1cm5zIGEgdW5pcXVlbHkgZ2VuZXJhdGVkIHJlcGxheSBJRC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyB0aGUgcmVwbGF5SWQgYW5kIGFzeW5jaHJvbm91c2x5IHByb2Nlc3Nlc1xuICAgKiB0aGUgcmVwbGF5IGRhdGEgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBwcm9jZXNzaW5nIGludm9sdmVzIGNvbnZlcnRpbmdcbiAgICogcmVjb3JkZXIgZXZlbnRzIGludG8gYSBwYXlsb2FkIGZvcm1hdCBhbmQgc3RvcmluZyBpdCBpbiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHJlcGxheVxuICAgKi9cbiAgYWRkKG9jY3VycmVuY2VVdWlkKSB7XG4gICAgY29uc3QgcmVwbGF5SWQgPSBpZC5nZW4oOCk7XG5cbiAgICB0aGlzLl9wcm9jZXNzUmVwbGF5KHJlcGxheUlkLCBvY2N1cnJlbmNlVXVpZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyByZXBsYXk6JywgZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcGxheUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSByZXBsYXkgcGF5bG9hZCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHJlcGxheUlkIHRvIHRoZSBiYWNrZW5kXG4gICAqIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogUmV0cmlldmVzIHRoZSBwYXlsb2FkIGZyb20gdGhlIG1hcCwgY2hlY2tzIGlmIGl0J3MgdmFsaWQsIHRoZW4gc2VuZHMgaXRcbiAgICogdG8gdGhlIEFQSSBlbmRwb2ludCBmb3IgcHJvY2Vzc2luZy4gVGhlIHBheWxvYWQgY2FuIGJlIGVpdGhlciBhIHNwYW5zIGFycmF5XG4gICAqIG9yIGEgZm9ybWF0dGVkIE9UTFAgcGF5bG9hZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYXlJZCAtIFRoZSBJRCBvZiB0aGUgcmVwbGF5IHRvIHNlbmRcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHBheWxvYWQgd2FzIGZvdW5kIGFuZCBzZW50LCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGFzeW5jIHNlbmQocmVwbGF5SWQpIHtcbiAgICBpZiAoIXJlcGxheUlkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JlcGxheU1hcC5zZW5kOiBObyByZXBsYXlJZCBwcm92aWRlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy4jbWFwLmhhcyhyZXBsYXlJZCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgUmVwbGF5TWFwLnNlbmQ6IE5vIHJlcGxheSBmb3VuZCBmb3IgcmVwbGF5SWQ6ICR7cmVwbGF5SWR9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuI21hcC5nZXQocmVwbGF5SWQpO1xuICAgIHRoaXMuI21hcC5kZWxldGUocmVwbGF5SWQpO1xuXG4gICAgLy8gQ2hlY2sgaWYgcGF5bG9hZCBpcyBlbXB0eSAoY291bGQgYmUgcmF3IHNwYW5zIGFycmF5IG9yIE9UTFAgcGF5bG9hZClcbiAgICBjb25zdCBpc0VtcHR5ID1cbiAgICAgICFwYXlsb2FkIHx8XG4gICAgICAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgIChwYXlsb2FkLnJlc291cmNlU3BhbnMgJiYgcGF5bG9hZC5yZXNvdXJjZVNwYW5zLmxlbmd0aCA9PT0gMCk7XG5cbiAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgUmVwbGF5TWFwLnNlbmQ6IE5vIHBheWxvYWQgZm91bmQgZm9yIHJlcGxheUlkOiAke3JlcGxheUlkfWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLiNhcGkucG9zdFNwYW5zKHBheWxvYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlbmRpbmcgcmVwbGF5OicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZHMgdGhlIHJlcGxheSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHJlcGxheSBJRCBieSByZW1vdmluZ1xuICAgKiBpdCBmcm9tIHRoZSBtYXAgd2l0aG91dCBzZW5kaW5nIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBUaGUgSUQgb2YgdGhlIHJlcGxheSB0byBkaXNjYXJkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGEgcmVwbGF5IHdhcyBmb3VuZCBhbmQgZGlzY2FyZGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGRpc2NhcmQocmVwbGF5SWQpIHtcbiAgICBpZiAoIXJlcGxheUlkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JlcGxheU1hcC5kaXNjYXJkOiBObyByZXBsYXlJZCBwcm92aWRlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy4jbWFwLmhhcyhyZXBsYXlJZCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFJlcGxheU1hcC5kaXNjYXJkOiBObyByZXBsYXkgZm91bmQgZm9yIHJlcGxheUlkOiAke3JlcGxheUlkfWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuI21hcC5kZWxldGUocmVwbGF5SWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc3BhbnMgZm9yIHRoZSBnaXZlbiByZXBsYXkgSURcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIElEIHRvIHJldHJpZXZlIHNwYW5zIGZvclxuICAgKiBAcmV0dXJucyB7QXJyYXl8bnVsbH0gVGhlIHNwYW5zIGFycmF5IG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAqL1xuICBnZXRTcGFucyhyZXBsYXlJZCkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuZ2V0KHJlcGxheUlkKSA/PyBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgc3BhbnMgZm9yIGEgZ2l2ZW4gcmVwbGF5IElEXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYXlJZCAtIFRoZSBJRCB0byBzZXQgc3BhbnMgZm9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNwYW5zIC0gVGhlIHNwYW5zIHRvIHNldFxuICAgKi9cbiAgc2V0U3BhbnMocmVwbGF5SWQsIHNwYW5zKSB7XG4gICAgdGhpcy4jbWFwLnNldChyZXBsYXlJZCwgc3BhbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIG1hcCAobnVtYmVyIG9mIHN0b3JlZCByZXBsYXlzKVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJlcGxheXMgY3VycmVudGx5IHN0b3JlZFxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgc3RvcmVkIHJlcGxheXMgd2l0aG91dCBzZW5kaW5nIHRoZW1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuI21hcC5jbGVhcigpO1xuICB9XG59XG4iLCJjb25zdCBSb2xsYmFyID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5jb25zdCB0ZWxlbWV0ZXIgPSByZXF1aXJlKCcuLi90ZWxlbWV0cnknKTtcbmNvbnN0IGluc3RydW1lbnRlciA9IHJlcXVpcmUoJy4vdGVsZW1ldHJ5Jyk7XG5jb25zdCBwb2x5ZmlsbEpTT04gPSByZXF1aXJlKCcuLi91dGlsaXR5L3BvbHlmaWxsSlNPTicpO1xuY29uc3Qgd3JhcEdsb2JhbHMgPSByZXF1aXJlKCcuL3dyYXBHbG9iYWxzJyk7XG5jb25zdCBzY3J1YiA9IHJlcXVpcmUoJy4uL3NjcnViJyk7XG5jb25zdCB0cnVuY2F0aW9uID0gcmVxdWlyZSgnLi4vdHJ1bmNhdGlvbicpO1xuY29uc3QgVHJhY2luZyA9IHJlcXVpcmUoJy4uL3RyYWNpbmcvdHJhY2luZycpO1xuY29uc3QgUmVjb3JkZXIgPSByZXF1aXJlKCcuL3JlcGxheS9yZWNvcmRlcicpO1xuXG5Sb2xsYmFyLnNldENvbXBvbmVudHMoe1xuICB0ZWxlbWV0ZXI6IHRlbGVtZXRlcixcbiAgaW5zdHJ1bWVudGVyOiBpbnN0cnVtZW50ZXIsXG4gIHBvbHlmaWxsSlNPTjogcG9seWZpbGxKU09OLFxuICB3cmFwR2xvYmFsczogd3JhcEdsb2JhbHMsXG4gIHNjcnViOiBzY3J1YixcbiAgdHJ1bmNhdGlvbjogdHJ1bmNhdGlvbixcbiAgdHJhY2luZzogVHJhY2luZy5kZWZhdWx0LFxuICByZWNvcmRlcjogUmVjb3JkZXIuZGVmYXVsdCxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvbGxiYXI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWxpdHknKTtcbnZhciBoZWFkZXJzID0gcmVxdWlyZSgnLi4vdXRpbGl0eS9oZWFkZXJzJyk7XG52YXIgcmVwbGFjZSA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvcmVwbGFjZScpO1xudmFyIHNjcnViID0gcmVxdWlyZSgnLi4vc2NydWInKTtcbnZhciB1cmxwYXJzZXIgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIGRvbVV0aWwgPSByZXF1aXJlKCcuL2RvbVV0aWxpdHknKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBuZXR3b3JrOiB0cnVlLFxuICBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzOiBmYWxzZSxcbiAgbmV0d29ya1Jlc3BvbnNlQm9keTogZmFsc2UsXG4gIG5ldHdvcmtSZXF1ZXN0SGVhZGVyczogZmFsc2UsXG4gIG5ldHdvcmtSZXF1ZXN0Qm9keTogZmFsc2UsXG4gIG5ldHdvcmtFcnJvck9uSHR0cDV4eDogZmFsc2UsXG4gIG5ldHdvcmtFcnJvck9uSHR0cDR4eDogZmFsc2UsXG4gIG5ldHdvcmtFcnJvck9uSHR0cDA6IGZhbHNlLFxuICBsb2c6IHRydWUsXG4gIGRvbTogdHJ1ZSxcbiAgbmF2aWdhdGlvbjogdHJ1ZSxcbiAgY29ubmVjdGl2aXR5OiB0cnVlLFxuICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IHRydWUsXG4gIGVycm9yT25Db250ZW50U2VjdXJpdHlQb2xpY3k6IGZhbHNlLFxufTtcblxuZnVuY3Rpb24gcmVzdG9yZShyZXBsYWNlbWVudHMsIHR5cGUpIHtcbiAgdmFyIGI7XG4gIHdoaWxlIChyZXBsYWNlbWVudHNbdHlwZV0ubGVuZ3RoKSB7XG4gICAgYiA9IHJlcGxhY2VtZW50c1t0eXBlXS5zaGlmdCgpO1xuICAgIGJbMF1bYlsxXV0gPSBiWzJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5hbWVGcm9tRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uYXR0cmlidXRlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBhdHRycyA9IGRlc2NyaXB0aW9uLmF0dHJpYnV0ZXM7XG4gIGZvciAodmFyIGEgPSAwOyBhIDwgYXR0cnMubGVuZ3RoOyArK2EpIHtcbiAgICBpZiAoYXR0cnNbYV0ua2V5ID09PSAnbmFtZScpIHtcbiAgICAgIHJldHVybiBhdHRyc1thXS52YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZVNjcnViYmVyKHNjcnViRmllbGRzKSB7XG4gIHZhciBwYXR0ZXJucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgcGF0dGVybnMucHVzaChuZXcgUmVnRXhwKHNjcnViRmllbGRzW2ldLCAnaScpKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lRnJvbURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHBhdHRlcm5zW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gSW5zdHJ1bWVudGVyKG9wdGlvbnMsIHRlbGVtZXRlciwgcm9sbGJhciwgX3dpbmRvdywgX2RvY3VtZW50KSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHZhciBhdXRvSW5zdHJ1bWVudCA9IG9wdGlvbnMuYXV0b0luc3RydW1lbnQ7XG4gIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlIHx8IGF1dG9JbnN0cnVtZW50ID09PSBmYWxzZSkge1xuICAgIHRoaXMuYXV0b0luc3RydW1lbnQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIV8uaXNUeXBlKGF1dG9JbnN0cnVtZW50LCAnb2JqZWN0JykpIHtcbiAgICAgIGF1dG9JbnN0cnVtZW50ID0gZGVmYXVsdHM7XG4gICAgfVxuICAgIHRoaXMuYXV0b0luc3RydW1lbnQgPSBfLm1lcmdlKGRlZmF1bHRzLCBhdXRvSW5zdHJ1bWVudCk7XG4gIH1cbiAgdGhpcy5zY3J1YlRlbGVtZXRyeUlucHV0cyA9ICEhb3B0aW9ucy5zY3J1YlRlbGVtZXRyeUlucHV0cztcbiAgdGhpcy50ZWxlbWV0cnlTY3J1YmJlciA9IG9wdGlvbnMudGVsZW1ldHJ5U2NydWJiZXI7XG4gIHRoaXMuZGVmYXVsdFZhbHVlU2NydWJiZXIgPSBkZWZhdWx0VmFsdWVTY3J1YmJlcihvcHRpb25zLnNjcnViRmllbGRzKTtcbiAgdGhpcy50ZWxlbWV0ZXIgPSB0ZWxlbWV0ZXI7XG4gIHRoaXMucm9sbGJhciA9IHJvbGxiYXI7XG4gIHRoaXMuZGlhZ25vc3RpYyA9IHJvbGxiYXIuY2xpZW50Lm5vdGlmaWVyLmRpYWdub3N0aWM7XG4gIHRoaXMuX3dpbmRvdyA9IF93aW5kb3cgfHwge307XG4gIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50IHx8IHt9O1xuICB0aGlzLnJlcGxhY2VtZW50cyA9IHtcbiAgICBuZXR3b3JrOiBbXSxcbiAgICBsb2c6IFtdLFxuICAgIG5hdmlnYXRpb246IFtdLFxuICAgIGNvbm5lY3Rpdml0eTogW10sXG4gIH07XG4gIHRoaXMuZXZlbnRSZW1vdmVycyA9IHtcbiAgICBkb206IFtdLFxuICAgIGNvbm5lY3Rpdml0eTogW10sXG4gICAgY29udGVudHNlY3VyaXR5cG9saWN5OiBbXSxcbiAgfTtcblxuICB0aGlzLl9sb2NhdGlvbiA9IHRoaXMuX3dpbmRvdy5sb2NhdGlvbjtcbiAgdGhpcy5fbGFzdEhyZWYgPSB0aGlzLl9sb2NhdGlvbiAmJiB0aGlzLl9sb2NhdGlvbi5ocmVmO1xufVxuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2UodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIGF1dG9JbnN0cnVtZW50ID0gb3B0aW9ucy5hdXRvSW5zdHJ1bWVudDtcbiAgdmFyIG9sZFNldHRpbmdzID0gXy5tZXJnZSh0aGlzLmF1dG9JbnN0cnVtZW50KTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UgfHwgYXV0b0luc3RydW1lbnQgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIGlmICghXy5pc1R5cGUoYXV0b0luc3RydW1lbnQsICdvYmplY3QnKSkge1xuICAgICAgYXV0b0luc3RydW1lbnQgPSBkZWZhdWx0cztcbiAgICB9XG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudCA9IF8ubWVyZ2UoZGVmYXVsdHMsIGF1dG9JbnN0cnVtZW50KTtcbiAgfVxuICB0aGlzLmluc3RydW1lbnQob2xkU2V0dGluZ3MpO1xuICBpZiAob3B0aW9ucy5zY3J1YlRlbGVtZXRyeUlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zY3J1YlRlbGVtZXRyeUlucHV0cyA9ICEhb3B0aW9ucy5zY3J1YlRlbGVtZXRyeUlucHV0cztcbiAgfVxuICBpZiAob3B0aW9ucy50ZWxlbWV0cnlTY3J1YmJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50ZWxlbWV0cnlTY3J1YmJlciA9IG9wdGlvbnMudGVsZW1ldHJ5U2NydWJiZXI7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmluc3RydW1lbnQgPSBmdW5jdGlvbiAob2xkU2V0dGluZ3MpIHtcbiAgaWYgKHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29yayAmJiAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLm5ldHdvcmspKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50TmV0d29yaygpO1xuICB9IGVsc2UgaWYgKFxuICAgICF0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmsgJiZcbiAgICBvbGRTZXR0aW5ncyAmJlxuICAgIG9sZFNldHRpbmdzLm5ldHdvcmtcbiAgKSB7XG4gICAgdGhpcy5kZWluc3RydW1lbnROZXR3b3JrKCk7XG4gIH1cblxuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5sb2cgJiYgIShvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5sb2cpKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50Q29uc29sZSgpO1xuICB9IGVsc2UgaWYgKCF0aGlzLmF1dG9JbnN0cnVtZW50LmxvZyAmJiBvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5sb2cpIHtcbiAgICB0aGlzLmRlaW5zdHJ1bWVudENvbnNvbGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLmF1dG9JbnN0cnVtZW50LmRvbSAmJiAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmRvbSkpIHtcbiAgICB0aGlzLmluc3RydW1lbnREb20oKTtcbiAgfSBlbHNlIGlmICghdGhpcy5hdXRvSW5zdHJ1bWVudC5kb20gJiYgb2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MuZG9tKSB7XG4gICAgdGhpcy5kZWluc3RydW1lbnREb20oKTtcbiAgfVxuXG4gIGlmIChcbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50Lm5hdmlnYXRpb24gJiZcbiAgICAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLm5hdmlnYXRpb24pXG4gICkge1xuICAgIHRoaXMuaW5zdHJ1bWVudE5hdmlnYXRpb24oKTtcbiAgfSBlbHNlIGlmIChcbiAgICAhdGhpcy5hdXRvSW5zdHJ1bWVudC5uYXZpZ2F0aW9uICYmXG4gICAgb2xkU2V0dGluZ3MgJiZcbiAgICBvbGRTZXR0aW5ncy5uYXZpZ2F0aW9uXG4gICkge1xuICAgIHRoaXMuZGVpbnN0cnVtZW50TmF2aWdhdGlvbigpO1xuICB9XG5cbiAgaWYgKFxuICAgIHRoaXMuYXV0b0luc3RydW1lbnQuY29ubmVjdGl2aXR5ICYmXG4gICAgIShvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5jb25uZWN0aXZpdHkpXG4gICkge1xuICAgIHRoaXMuaW5zdHJ1bWVudENvbm5lY3Rpdml0eSgpO1xuICB9IGVsc2UgaWYgKFxuICAgICF0aGlzLmF1dG9JbnN0cnVtZW50LmNvbm5lY3Rpdml0eSAmJlxuICAgIG9sZFNldHRpbmdzICYmXG4gICAgb2xkU2V0dGluZ3MuY29ubmVjdGl2aXR5XG4gICkge1xuICAgIHRoaXMuZGVpbnN0cnVtZW50Q29ubmVjdGl2aXR5KCk7XG4gIH1cblxuICBpZiAoXG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudC5jb250ZW50U2VjdXJpdHlQb2xpY3kgJiZcbiAgICAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmNvbnRlbnRTZWN1cml0eVBvbGljeSlcbiAgKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50Q29udGVudFNlY3VyaXR5UG9saWN5KCk7XG4gIH0gZWxzZSBpZiAoXG4gICAgIXRoaXMuYXV0b0luc3RydW1lbnQuY29udGVudFNlY3VyaXR5UG9saWN5ICYmXG4gICAgb2xkU2V0dGluZ3MgJiZcbiAgICBvbGRTZXR0aW5ncy5jb250ZW50U2VjdXJpdHlQb2xpY3lcbiAgKSB7XG4gICAgdGhpcy5kZWluc3RydW1lbnRDb250ZW50U2VjdXJpdHlQb2xpY3koKTtcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5kZWluc3RydW1lbnROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICByZXN0b3JlKHRoaXMucmVwbGFjZW1lbnRzLCAnbmV0d29yaycpO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pbnN0cnVtZW50TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHdyYXBQcm9wKHByb3AsIHhocikge1xuICAgIGlmIChwcm9wIGluIHhociAmJiBfLmlzRnVuY3Rpb24oeGhyW3Byb3BdKSkge1xuICAgICAgcmVwbGFjZSh4aHIsIHByb3AsIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJvbGxiYXIud3JhcChvcmlnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICgnWE1MSHR0cFJlcXVlc3QnIGluIHRoaXMuX3dpbmRvdykge1xuICAgIHZhciB4aHJwID0gdGhpcy5fd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZTtcbiAgICByZXBsYWNlKFxuICAgICAgeGhycCxcbiAgICAgICdvcGVuJyxcbiAgICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgICAgICAgICB2YXIgaXNVcmxPYmplY3QgPSBfaXNVcmxPYmplY3QodXJsKTtcbiAgICAgICAgICBpZiAoXy5pc1R5cGUodXJsLCAnc3RyaW5nJykgfHwgaXNVcmxPYmplY3QpIHtcbiAgICAgICAgICAgIHVybCA9IGlzVXJsT2JqZWN0ID8gdXJsLnRvU3RyaW5nKCkgOiB1cmw7XG4gICAgICAgICAgICBpZiAodGhpcy5fX3JvbGxiYXJfeGhyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci51cmwgPSB1cmw7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5zdGF0dXNfY29kZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5zdGFydF90aW1lX21zID0gXy5ub3coKTtcbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLmVuZF90aW1lX21zID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hociA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBzdGF0dXNfY29kZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydF90aW1lX21zOiBfLm5vdygpLFxuICAgICAgICAgICAgICAgIGVuZF90aW1lX21zOiBudWxsLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRzLFxuICAgICAgJ25ldHdvcmsnLFxuICAgICk7XG5cbiAgICByZXBsYWNlKFxuICAgICAgeGhycCxcbiAgICAgICdzZXRSZXF1ZXN0SGVhZGVyJyxcbiAgICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIElmIHhoci5vcGVuIGlzIGFzeW5jLCBfX3JvbGxiYXJfeGhyIG1heSBub3QgYmUgaW5pdGlhbGl6ZWQgeWV0LlxuICAgICAgICAgIGlmICghdGhpcy5fX3JvbGxiYXJfeGhyKSB7XG4gICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF8uaXNUeXBlKGhlYWRlciwgJ3N0cmluZycpICYmIF8uaXNUeXBlKHZhbHVlLCAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX19yb2xsYmFyX3hoci5yZXF1ZXN0X2hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIucmVxdWVzdF9oZWFkZXJzID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLnJlcXVlc3RfaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBjb250ZW50IHR5cGUgZXZlbiBpZiByZXF1ZXN0IGhlYWRlciB0ZWxlbWV0cnkgaXMgb2ZmLlxuICAgICAgICAgICAgaWYgKGhlYWRlci50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIucmVxdWVzdF9jb250ZW50X3R5cGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlcGxhY2VtZW50cyxcbiAgICAgICduZXR3b3JrJyxcbiAgICApO1xuXG4gICAgcmVwbGFjZShcbiAgICAgIHhocnAsXG4gICAgICAnc2VuZCcsXG4gICAgICBmdW5jdGlvbiAob3JpZykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgICAgdmFyIHhociA9IHRoaXM7XG5cbiAgICAgICAgICBmdW5jdGlvbiBvbnJlYWR5c3RhdGVjaGFuZ2VIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHhoci5fX3JvbGxiYXJfeGhyKSB7XG4gICAgICAgICAgICAgIGlmICh4aHIuX19yb2xsYmFyX3hoci5zdGF0dXNfY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnN0YXR1c19jb2RlID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVxdWVzdEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnJlcXVlc3QgPSBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX2V2ZW50ID0gc2VsZi5jYXB0dXJlTmV0d29yayhcbiAgICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLFxuICAgICAgICAgICAgICAgICAgJ3hocicsXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPCAyKSB7XG4gICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIuc3RhcnRfdGltZV9tcyA9IF8ubm93KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID4gMykge1xuICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLmVuZF90aW1lX21zID0gXy5ub3coKTtcblxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5yZXNwb25zZV9jb250ZW50X3R5cGUgPVxuICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyc0NvbmZpZyA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlSGVhZGVycztcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIsIGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzQ29uZmlnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSBhbGxIZWFkZXJzLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMsIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IGFycltpXS5zcGxpdCgnOiAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCc6ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlcnNDb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IGhlYWRlcnNDb25maWdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlcl0gPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogd2UgaWdub3JlIHRoZSBlcnJvcnMgaGVyZSB0aGF0IGNvdWxkIGNvbWUgZnJvbSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICogYnJvd3NlciBpc3N1ZXMgd2l0aCB0aGUgeGhyIG1ldGhvZHMgKi9cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgZXJyb3JzIGZyb20gcmVhZGluZyByZXNwb25zZVRleHQgKi9cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSB8fCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNKc29uQ29udGVudFR5cGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5yZXNwb25zZV9jb250ZW50X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gc2VsZi5zY3J1Ykpzb24oYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSA9PT0gMTIyMyA/IDIwNCA6IGNvZGU7XG4gICAgICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5zdGF0dXNfY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX2V2ZW50LmxldmVsID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50ZWxlbWV0ZXIubGV2ZWxGcm9tU3RhdHVzKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvck9uSHR0cFN0YXR1cyh4aHIuX19yb2xsYmFyX3hocik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgLyogaWdub3JlIHBvc3NpYmxlIGV4Y2VwdGlvbiBmcm9tIHhoci5zdGF0dXMgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cmFwUHJvcCgnb25sb2FkJywgeGhyKTtcbiAgICAgICAgICB3cmFwUHJvcCgnb25lcnJvcicsIHhocik7XG4gICAgICAgICAgd3JhcFByb3AoJ29ucHJvZ3Jlc3MnLCB4aHIpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4geGhyICYmXG4gICAgICAgICAgICBfLmlzRnVuY3Rpb24oeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlcGxhY2UoeGhyLCAnb25yZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucm9sbGJhci53cmFwKFxuICAgICAgICAgICAgICAgIG9yaWcsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4aHIuX19yb2xsYmFyX3hociAmJiBzZWxmLnRyYWNrSHR0cEVycm9ycygpKSB7XG4gICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRzLFxuICAgICAgJ25ldHdvcmsnLFxuICAgICk7XG4gIH1cblxuICBpZiAoJ2ZldGNoJyBpbiB0aGlzLl93aW5kb3cpIHtcbiAgICByZXBsYWNlKFxuICAgICAgdGhpcy5fd2luZG93LFxuICAgICAgJ2ZldGNoJyxcbiAgICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4sIHQpIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnB1dCA9IGFyZ3NbMF07XG4gICAgICAgICAgdmFyIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgdmFyIGlzVXJsT2JqZWN0ID0gX2lzVXJsT2JqZWN0KGlucHV0KTtcbiAgICAgICAgICBpZiAoXy5pc1R5cGUoaW5wdXQsICdzdHJpbmcnKSB8fCBpc1VybE9iamVjdCkge1xuICAgICAgICAgICAgdXJsID0gaXNVcmxPYmplY3QgPyBpbnB1dC50b1N0cmluZygpIDogaW5wdXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgdXJsID0gaW5wdXQudXJsO1xuICAgICAgICAgICAgaWYgKGlucHV0Lm1ldGhvZCkge1xuICAgICAgICAgICAgICBtZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcmdzWzFdICYmIGFyZ3NbMV0ubWV0aG9kKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBhcmdzWzFdLm1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIHN0YXR1c19jb2RlOiBudWxsLFxuICAgICAgICAgICAgc3RhcnRfdGltZV9tczogXy5ub3coKSxcbiAgICAgICAgICAgIGVuZF90aW1lX21zOiBudWxsLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGFyZ3NbMV0gJiYgYXJnc1sxXS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyBBcmd1bWVudCBtYXkgYmUgYSBIZWFkZXJzIG9iamVjdCwgb3IgcGxhaW4gb2JqZWN0LiBFbnN1cmUgaGVyZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBhcmUgd29ya2luZyB3aXRoIGEgSGVhZGVycyBvYmplY3Qgd2l0aCBjYXNlLWluc2Vuc2l0aXZlIGtleXMuXG4gICAgICAgICAgICB2YXIgcmVxSGVhZGVycyA9IGhlYWRlcnMoYXJnc1sxXS5oZWFkZXJzKTtcblxuICAgICAgICAgICAgbWV0YWRhdGEucmVxdWVzdF9jb250ZW50X3R5cGUgPSByZXFIZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgICBtZXRhZGF0YS5yZXF1ZXN0X2hlYWRlcnMgPSBzZWxmLmZldGNoSGVhZGVycyhcbiAgICAgICAgICAgICAgICByZXFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1JlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0Qm9keSkge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0gJiYgYXJnc1sxXS5ib2R5KSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnJlcXVlc3QgPSBhcmdzWzFdLmJvZHk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBhcmdzWzBdICYmXG4gICAgICAgICAgICAgICFfLmlzVHlwZShhcmdzWzBdLCAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgICAgYXJnc1swXS5ib2R5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEucmVxdWVzdCA9IGFyZ3NbMF0uYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jYXB0dXJlTmV0d29yayhtZXRhZGF0YSwgJ2ZldGNoJywgdW5kZWZpbmVkKTtcbiAgICAgICAgICBpZiAoc2VsZi50cmFja0h0dHBFcnJvcnMoKSkge1xuICAgICAgICAgICAgbWV0YWRhdGEuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCBvdXIgaGFuZGxlciBiZWZvcmUgcmV0dXJuaW5nIHRoZSBwcm9taXNlLiBUaGlzIGFsbG93cyByZXNwLmNsb25lKClcbiAgICAgICAgICAvLyB0byBleGVjdXRlIGJlZm9yZSBvdGhlciBoYW5kbGVycyB0b3VjaCB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkodGhpcywgYXJncykudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgbWV0YWRhdGEuZW5kX3RpbWVfbXMgPSBfLm5vdygpO1xuICAgICAgICAgICAgbWV0YWRhdGEuc3RhdHVzX2NvZGUgPSByZXNwLnN0YXR1cztcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlc3BvbnNlX2NvbnRlbnRfdHlwZSA9IHJlc3AuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgICAgICBoZWFkZXJzID0gc2VsZi5mZXRjaEhlYWRlcnMoXG4gICAgICAgICAgICAgICAgcmVzcC5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwLnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNwb25zZS50ZXh0KCkgaXMgbm90IGltcGxlbWVudGVkIG9uIHNvbWUgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIG11c3QgYmUgY2xvbmVkIHRvIHByZXZlbnQgcmVhZGluZyAoYW5kIGxvY2tpbmcpIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIG90aGVyIGhhbmRsZXJzIHRvdWNoIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICBib2R5ID0gcmVzcC5jbG9uZSgpLnRleHQoKTsgLy9yZXR1cm5zIGEgUHJvbWlzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZGVycyB8fCBib2R5KSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnJlc3BvbnNlID0ge307XG4gICAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0byBlbnN1cmUgYm9keSBpcyBhIFByb21pc2UsIHdoaWNoIGl0IHNob3VsZCBhbHdheXMgYmUuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIGJvZHkudGhlbihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNKc29uQ29udGVudFR5cGUobWV0YWRhdGEucmVzcG9uc2VfY29udGVudF90eXBlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5yZXNwb25zZS5ib2R5ID0gc2VsZi5zY3J1Ykpzb24odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2UuYm9keSA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YS5yZXNwb25zZS5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5yZXNwb25zZS5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5lcnJvck9uSHR0cFN0YXR1cyhtZXRhZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlcGxhY2VtZW50cyxcbiAgICAgICduZXR3b3JrJyxcbiAgICApO1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmNhcHR1cmVOZXR3b3JrID0gZnVuY3Rpb24gKFxuICBtZXRhZGF0YSxcbiAgc3VidHlwZSxcbiAgcm9sbGJhclVVSUQsXG4pIHtcbiAgaWYgKFxuICAgIG1ldGFkYXRhLnJlcXVlc3QgJiZcbiAgICB0aGlzLmlzSnNvbkNvbnRlbnRUeXBlKG1ldGFkYXRhLnJlcXVlc3RfY29udGVudF90eXBlKVxuICApIHtcbiAgICBtZXRhZGF0YS5yZXF1ZXN0ID0gdGhpcy5zY3J1Ykpzb24obWV0YWRhdGEucmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVOZXR3b3JrKG1ldGFkYXRhLCBzdWJ0eXBlLCByb2xsYmFyVVVJRCk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmlzSnNvbkNvbnRlbnRUeXBlID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XG4gIHJldHVybiBjb250ZW50VHlwZSAmJlxuICAgIF8uaXNUeXBlKGNvbnRlbnRUeXBlLCAnc3RyaW5nJykgJiZcbiAgICBjb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdqc29uJylcbiAgICA/IHRydWVcbiAgICA6IGZhbHNlO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5zY3J1Ykpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2NydWIoSlNPTi5wYXJzZShqc29uKSwgdGhpcy5vcHRpb25zLnNjcnViRmllbGRzKSk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmZldGNoSGVhZGVycyA9IGZ1bmN0aW9uIChpbkhlYWRlcnMsIGhlYWRlcnNDb25maWcpIHtcbiAgdmFyIG91dEhlYWRlcnMgPSB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaGVhZGVyc0NvbmZpZyA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbkhlYWRlcnMuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBIZWFkZXJzLmVudHJpZXMoKSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUVcbiAgICAgICAgdmFyIGFsbEhlYWRlcnMgPSBpbkhlYWRlcnMuZW50cmllcygpO1xuICAgICAgICB2YXIgY3VycmVudEhlYWRlciA9IGFsbEhlYWRlcnMubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWN1cnJlbnRIZWFkZXIuZG9uZSkge1xuICAgICAgICAgIG91dEhlYWRlcnNbY3VycmVudEhlYWRlci52YWx1ZVswXV0gPSBjdXJyZW50SGVhZGVyLnZhbHVlWzFdO1xuICAgICAgICAgIGN1cnJlbnRIZWFkZXIgPSBhbGxIZWFkZXJzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZGVyc0NvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaGVhZGVyID0gaGVhZGVyc0NvbmZpZ1tpXTtcbiAgICAgICAgb3V0SGVhZGVyc1toZWFkZXJdID0gaW5IZWFkZXJzLmdldChoZWFkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlnbm9yZSBwcm9iYWJsZSBJRSBlcnJvcnMgKi9cbiAgfVxuICByZXR1cm4gb3V0SGVhZGVycztcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUudHJhY2tIdHRwRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwNXh4IHx8XG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrRXJyb3JPbkh0dHA0eHggfHxcbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDBcbiAgKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuZXJyb3JPbkh0dHBTdGF0dXMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgdmFyIHN0YXR1cyA9IG1ldGFkYXRhLnN0YXR1c19jb2RlO1xuXG4gIGlmIChcbiAgICAoc3RhdHVzID49IDUwMCAmJiB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDV4eCkgfHxcbiAgICAoc3RhdHVzID49IDQwMCAmJiB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDR4eCkgfHxcbiAgICAoc3RhdHVzID09PSAwICYmIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwMClcbiAgKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdIVFRQIHJlcXVlc3QgZmFpbGVkIHdpdGggU3RhdHVzICcgKyBzdGF0dXMpO1xuICAgIGVycm9yLnN0YWNrID0gbWV0YWRhdGEuc3RhY2s7XG4gICAgdGhpcy5yb2xsYmFyLmVycm9yKGVycm9yLCB7IHNraXBGcmFtZXM6IDEgfSk7XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuZGVpbnN0cnVtZW50Q29uc29sZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2NvbnNvbGUnIGluIHRoaXMuX3dpbmRvdyAmJiB0aGlzLl93aW5kb3cuY29uc29sZS5sb2cpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBiO1xuICB3aGlsZSAodGhpcy5yZXBsYWNlbWVudHNbJ2xvZyddLmxlbmd0aCkge1xuICAgIGIgPSB0aGlzLnJlcGxhY2VtZW50c1snbG9nJ10uc2hpZnQoKTtcbiAgICB0aGlzLl93aW5kb3cuY29uc29sZVtiWzBdXSA9IGJbMV07XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudENvbnNvbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdjb25zb2xlJyBpbiB0aGlzLl93aW5kb3cgJiYgdGhpcy5fd2luZG93LmNvbnNvbGUubG9nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGMgPSB0aGlzLl93aW5kb3cuY29uc29sZTtcblxuICBmdW5jdGlvbiB3cmFwQ29uc29sZShtZXRob2QpIHtcbiAgICAndXNlIHN0cmljdCc7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcm9sbGJhci9yb2xsYmFyLmpzL3B1bGwvNzc4XG5cbiAgICB2YXIgb3JpZyA9IGNbbWV0aG9kXTtcbiAgICB2YXIgb3JpZ0NvbnNvbGUgPSBjO1xuICAgIHZhciBsZXZlbCA9IG1ldGhvZCA9PT0gJ3dhcm4nID8gJ3dhcm5pbmcnIDogbWV0aG9kO1xuICAgIGNbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHZhciBtZXNzYWdlID0gXy5mb3JtYXRBcmdzQXNTdHJpbmcoYXJncyk7XG4gICAgICBzZWxmLnRlbGVtZXRlci5jYXB0dXJlTG9nKG1lc3NhZ2UsIGxldmVsLCBudWxsLCBfLm5vdygpKTtcbiAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKG9yaWcsIG9yaWdDb25zb2xlLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYucmVwbGFjZW1lbnRzWydsb2cnXS5wdXNoKFttZXRob2QsIG9yaWddKTtcbiAgfVxuICB2YXIgbWV0aG9kcyA9IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ2xvZyddO1xuICB0cnkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB3cmFwQ29uc29sZShtZXRob2RzW2ldKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLmRpYWdub3N0aWMuaW5zdHJ1bWVudENvbnNvbGUgPSB7IGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5kZWluc3RydW1lbnREb20gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdhZGRFdmVudExpc3RlbmVyJyBpbiB0aGlzLl93aW5kb3cgfHwgJ2F0dGFjaEV2ZW50JyBpbiB0aGlzLl93aW5kb3cpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCdkb20nKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYXR0YWNoRXZlbnQnIGluIHRoaXMuX3dpbmRvdykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNsaWNrSGFuZGxlciA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgdmFyIGJsdXJIYW5kbGVyID0gdGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcyk7XG4gIHRoaXMuYWRkTGlzdGVuZXIoJ2RvbScsIHRoaXMuX3dpbmRvdywgJ2NsaWNrJywgJ29uY2xpY2snLCBjbGlja0hhbmRsZXIsIHRydWUpO1xuICB0aGlzLmFkZExpc3RlbmVyKFxuICAgICdkb20nLFxuICAgIHRoaXMuX3dpbmRvdyxcbiAgICAnYmx1cicsXG4gICAgJ29uZm9jdXNvdXQnLFxuICAgIGJsdXJIYW5kbGVyLFxuICAgIHRydWUsXG4gICk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2dCkge1xuICB0cnkge1xuICAgIHZhciBlID0gZG9tVXRpbC5nZXRFbGVtZW50RnJvbUV2ZW50KGV2dCwgdGhpcy5fZG9jdW1lbnQpO1xuICAgIHZhciBoYXNUYWcgPSBlICYmIGUudGFnTmFtZTtcbiAgICB2YXIgYW5jaG9yT3JCdXR0b24gPVxuICAgICAgZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2EnKSB8fFxuICAgICAgZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2J1dHRvbicpO1xuICAgIGlmIChcbiAgICAgIGhhc1RhZyAmJlxuICAgICAgKGFuY2hvck9yQnV0dG9uIHx8XG4gICAgICAgIGRvbVV0aWwuaXNEZXNjcmliZWRFbGVtZW50KGUsICdpbnB1dCcsIFsnYnV0dG9uJywgJ3N1Ym1pdCddKSlcbiAgICApIHtcbiAgICAgIHRoaXMuY2FwdHVyZURvbUV2ZW50KCdjbGljaycsIGUpO1xuICAgIH0gZWxzZSBpZiAoZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2lucHV0JywgWydjaGVja2JveCcsICdyYWRpbyddKSkge1xuICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2lucHV0JywgZSwgZS52YWx1ZSwgZS5jaGVja2VkKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGV4Yykge1xuICAgIC8vIFRPRE86IE5vdCBzdXJlIHdoYXQgdG8gZG8gaGVyZVxuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSBkb21VdGlsLmdldEVsZW1lbnRGcm9tRXZlbnQoZXZ0LCB0aGlzLl9kb2N1bWVudCk7XG4gICAgaWYgKGUgJiYgZS50YWdOYW1lKSB7XG4gICAgICBpZiAoZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ3RleHRhcmVhJykpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2lucHV0JywgZSwgZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnc2VsZWN0JykgJiZcbiAgICAgICAgZS5vcHRpb25zICYmXG4gICAgICAgIGUub3B0aW9ucy5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdElucHV0Q2hhbmdlZChlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGRvbVV0aWwuaXNEZXNjcmliZWRFbGVtZW50KGUsICdpbnB1dCcpICYmXG4gICAgICAgICFkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnaW5wdXQnLCBbXG4gICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgJ3N1Ym1pdCcsXG4gICAgICAgICAgJ2hpZGRlbicsXG4gICAgICAgICAgJ2NoZWNrYm94JyxcbiAgICAgICAgICAncmFkaW8nLFxuICAgICAgICBdKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZURvbUV2ZW50KCdpbnB1dCcsIGUsIGUudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXhjKSB7XG4gICAgLy8gVE9ETzogTm90IHN1cmUgd2hhdCB0byBkbyBoZXJlXG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlU2VsZWN0SW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgaWYgKGVsZW0ubXVsdGlwbGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0ub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVsZW0ub3B0aW9uc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmNhcHR1cmVEb21FdmVudCgnaW5wdXQnLCBlbGVtLCBlbGVtLm9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbGVtLnNlbGVjdGVkSW5kZXggPj0gMCAmJiBlbGVtLm9wdGlvbnNbZWxlbS5zZWxlY3RlZEluZGV4XSkge1xuICAgIHRoaXMuY2FwdHVyZURvbUV2ZW50KCdpbnB1dCcsIGVsZW0sIGVsZW0ub3B0aW9uc1tlbGVtLnNlbGVjdGVkSW5kZXhdLnZhbHVlKTtcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5jYXB0dXJlRG9tRXZlbnQgPSBmdW5jdGlvbiAoXG4gIHN1YnR5cGUsXG4gIGVsZW1lbnQsXG4gIHZhbHVlLFxuICBpc0NoZWNrZWQsXG4pIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnNjcnViVGVsZW1ldHJ5SW5wdXRzIHx8XG4gICAgICBkb21VdGlsLmdldEVsZW1lbnRUeXBlKGVsZW1lbnQpID09PSAncGFzc3dvcmQnXG4gICAgKSB7XG4gICAgICB2YWx1ZSA9ICdbc2NydWJiZWRdJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZG9tVXRpbC5kZXNjcmliZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy50ZWxlbWV0cnlTY3J1YmJlcikge1xuICAgICAgICBpZiAodGhpcy50ZWxlbWV0cnlTY3J1YmJlcihkZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICB2YWx1ZSA9ICdbc2NydWJiZWRdJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRWYWx1ZVNjcnViYmVyKGRlc2NyaXB0aW9uKSkge1xuICAgICAgICB2YWx1ZSA9ICdbc2NydWJiZWRdJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGVsZW1lbnRTdHJpbmcgPSBkb21VdGlsLmVsZW1lbnRBcnJheVRvU3RyaW5nKFxuICAgIGRvbVV0aWwudHJlZVRvQXJyYXkoZWxlbWVudCksXG4gICk7XG4gIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVEb20oc3VidHlwZSwgZWxlbWVudFN0cmluZywgdmFsdWUsIGlzQ2hlY2tlZCk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHJvbWUgPSB0aGlzLl93aW5kb3cuY2hyb21lO1xuICB2YXIgY2hyb21lUGFja2FnZWRBcHAgPSBjaHJvbWUgJiYgY2hyb21lLmFwcCAmJiBjaHJvbWUuYXBwLnJ1bnRpbWU7XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMTM5NDUvZmlsZXNcbiAgdmFyIGhhc1B1c2hTdGF0ZSA9XG4gICAgIWNocm9tZVBhY2thZ2VkQXBwICYmXG4gICAgdGhpcy5fd2luZG93Lmhpc3RvcnkgJiZcbiAgICB0aGlzLl93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG4gIGlmICghaGFzUHVzaFN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3RvcmUodGhpcy5yZXBsYWNlbWVudHMsICduYXZpZ2F0aW9uJyk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmluc3RydW1lbnROYXZpZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hyb21lID0gdGhpcy5fd2luZG93LmNocm9tZTtcbiAgdmFyIGNocm9tZVBhY2thZ2VkQXBwID0gY2hyb21lICYmIGNocm9tZS5hcHAgJiYgY2hyb21lLmFwcC5ydW50aW1lO1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9wdWxsLzEzOTQ1L2ZpbGVzXG4gIHZhciBoYXNQdXNoU3RhdGUgPVxuICAgICFjaHJvbWVQYWNrYWdlZEFwcCAmJlxuICAgIHRoaXMuX3dpbmRvdy5oaXN0b3J5ICYmXG4gICAgdGhpcy5fd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuICBpZiAoIWhhc1B1c2hTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcGxhY2UoXG4gICAgdGhpcy5fd2luZG93LFxuICAgICdvbnBvcHN0YXRlJyxcbiAgICBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzZWxmLl9sb2NhdGlvbi5ocmVmO1xuICAgICAgICBzZWxmLmhhbmRsZVVybENoYW5nZShzZWxmLl9sYXN0SHJlZiwgY3VycmVudCk7XG4gICAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdGhpcy5yZXBsYWNlbWVudHMsXG4gICAgJ25hdmlnYXRpb24nLFxuICApO1xuXG4gIHJlcGxhY2UoXG4gICAgdGhpcy5fd2luZG93Lmhpc3RvcnksXG4gICAgJ3B1c2hTdGF0ZScsXG4gICAgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHNlbGYuaGFuZGxlVXJsQ2hhbmdlKHNlbGYuX2xhc3RIcmVmLCB1cmwgKyAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICB0aGlzLnJlcGxhY2VtZW50cyxcbiAgICAnbmF2aWdhdGlvbicsXG4gICk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmhhbmRsZVVybENoYW5nZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB2YXIgcGFyc2VkSHJlZiA9IHVybHBhcnNlci5wYXJzZSh0aGlzLl9sb2NhdGlvbi5ocmVmKTtcbiAgdmFyIHBhcnNlZFRvID0gdXJscGFyc2VyLnBhcnNlKHRvKTtcbiAgdmFyIHBhcnNlZEZyb20gPSB1cmxwYXJzZXIucGFyc2UoZnJvbSk7XG4gIHRoaXMuX2xhc3RIcmVmID0gdG87XG4gIGlmIChcbiAgICBwYXJzZWRIcmVmLnByb3RvY29sID09PSBwYXJzZWRUby5wcm90b2NvbCAmJlxuICAgIHBhcnNlZEhyZWYuaG9zdCA9PT0gcGFyc2VkVG8uaG9zdFxuICApIHtcbiAgICB0byA9IHBhcnNlZFRvLnBhdGggKyAocGFyc2VkVG8uaGFzaCB8fCAnJyk7XG4gIH1cbiAgaWYgKFxuICAgIHBhcnNlZEhyZWYucHJvdG9jb2wgPT09IHBhcnNlZEZyb20ucHJvdG9jb2wgJiZcbiAgICBwYXJzZWRIcmVmLmhvc3QgPT09IHBhcnNlZEZyb20uaG9zdFxuICApIHtcbiAgICBmcm9tID0gcGFyc2VkRnJvbS5wYXRoICsgKHBhcnNlZEZyb20uaGFzaCB8fCAnJyk7XG4gIH1cbiAgdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZU5hdmlnYXRpb24oZnJvbSwgdG8sIF8ubm93KCkpO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5kZWluc3RydW1lbnRDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdhZGRFdmVudExpc3RlbmVyJyBpbiB0aGlzLl93aW5kb3cgfHwgJ2JvZHknIGluIHRoaXMuX2RvY3VtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGhpcy5fd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygnY29ubmVjdGl2aXR5Jyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZSh0aGlzLnJlcGxhY2VtZW50cywgJ2Nvbm5lY3Rpdml0eScpO1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmluc3RydW1lbnRDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghKCdhZGRFdmVudExpc3RlbmVyJyBpbiB0aGlzLl93aW5kb3cgfHwgJ2JvZHknIGluIHRoaXMuX2RvY3VtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGhpcy5fd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB0aGlzLmFkZExpc3RlbmVyKFxuICAgICAgJ2Nvbm5lY3Rpdml0eScsXG4gICAgICB0aGlzLl93aW5kb3csXG4gICAgICAnb25saW5lJyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSgnb25saW5lJyk7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICB0cnVlLFxuICAgICk7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcihcbiAgICAgICdjb25uZWN0aXZpdHknLFxuICAgICAgdGhpcy5fd2luZG93LFxuICAgICAgJ29mZmxpbmUnLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRlbGVtZXRlci5jYXB0dXJlQ29ubmVjdGl2aXR5Q2hhbmdlKCdvZmZsaW5lJyk7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICB0cnVlLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlcGxhY2UoXG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LFxuICAgICAgJ29ub25saW5lJyxcbiAgICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi50ZWxlbWV0ZXIuY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSgnb25saW5lJyk7XG4gICAgICAgICAgaWYgKG9yaWcpIHtcbiAgICAgICAgICAgIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdGhpcy5yZXBsYWNlbWVudHMsXG4gICAgICAnY29ubmVjdGl2aXR5JyxcbiAgICApO1xuICAgIHJlcGxhY2UoXG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LFxuICAgICAgJ29ub2ZmbGluZScsXG4gICAgICBmdW5jdGlvbiAob3JpZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudGVsZW1ldGVyLmNhcHR1cmVDb25uZWN0aXZpdHlDaGFuZ2UoJ29mZmxpbmUnKTtcbiAgICAgICAgICBpZiAob3JpZykge1xuICAgICAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlcGxhY2VtZW50cyxcbiAgICAgICdjb25uZWN0aXZpdHknLFxuICAgICk7XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlQ3NwRXZlbnQgPSBmdW5jdGlvbiAoY3NwRXZlbnQpIHtcbiAgdmFyIG1lc3NhZ2UgPVxuICAgICdTZWN1cml0eSBQb2xpY3kgVmlvbGF0aW9uOiAnICtcbiAgICAnYmxvY2tlZFVSSTogJyArXG4gICAgY3NwRXZlbnQuYmxvY2tlZFVSSSArXG4gICAgJywgJyArXG4gICAgJ3Zpb2xhdGVkRGlyZWN0aXZlOiAnICtcbiAgICBjc3BFdmVudC52aW9sYXRlZERpcmVjdGl2ZSArXG4gICAgJywgJyArXG4gICAgJ2VmZmVjdGl2ZURpcmVjdGl2ZTogJyArXG4gICAgY3NwRXZlbnQuZWZmZWN0aXZlRGlyZWN0aXZlICtcbiAgICAnLCAnO1xuXG4gIGlmIChjc3BFdmVudC5zb3VyY2VGaWxlKSB7XG4gICAgbWVzc2FnZSArPVxuICAgICAgJ2xvY2F0aW9uOiAnICtcbiAgICAgIGNzcEV2ZW50LnNvdXJjZUZpbGUgK1xuICAgICAgJywgJyArXG4gICAgICAnbGluZTogJyArXG4gICAgICBjc3BFdmVudC5saW5lTnVtYmVyICtcbiAgICAgICcsICcgK1xuICAgICAgJ2NvbDogJyArXG4gICAgICBjc3BFdmVudC5jb2x1bW5OdW1iZXIgK1xuICAgICAgJywgJztcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJ29yaWdpbmFsUG9saWN5OiAnICsgY3NwRXZlbnQub3JpZ2luYWxQb2xpY3k7XG5cbiAgdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZUxvZyhtZXNzYWdlLCAnZXJyb3InLCBudWxsLCBfLm5vdygpKTtcbiAgdGhpcy5oYW5kbGVDc3BFcnJvcihtZXNzYWdlKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlQ3NwRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5lcnJvck9uQ29udGVudFNlY3VyaXR5UG9saWN5KSB7XG4gICAgdGhpcy5yb2xsYmFyLmVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudENvbnRlbnRTZWN1cml0eVBvbGljeSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX2RvY3VtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCdjb250ZW50c2VjdXJpdHlwb2xpY3knKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudENvbnRlbnRTZWN1cml0eVBvbGljeSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX2RvY3VtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjc3BIYW5kbGVyID0gdGhpcy5oYW5kbGVDc3BFdmVudC5iaW5kKHRoaXMpO1xuICB0aGlzLmFkZExpc3RlbmVyKFxuICAgICdjb250ZW50c2VjdXJpdHlwb2xpY3knLFxuICAgIHRoaXMuX2RvY3VtZW50LFxuICAgICdzZWN1cml0eXBvbGljeXZpb2xhdGlvbicsXG4gICAgbnVsbCxcbiAgICBjc3BIYW5kbGVyLFxuICAgIGZhbHNlLFxuICApO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChcbiAgc2VjdGlvbixcbiAgb2JqLFxuICB0eXBlLFxuICBhbHRUeXBlLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuKSB7XG4gIGlmIChvYmouYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgIHRoaXMuZXZlbnRSZW1vdmVyc1tzZWN0aW9uXS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFsdFR5cGUpIHtcbiAgICBvYmouYXR0YWNoRXZlbnQoYWx0VHlwZSwgaGFuZGxlcik7XG4gICAgdGhpcy5ldmVudFJlbW92ZXJzW3NlY3Rpb25dLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmRldGFjaEV2ZW50KGFsdFR5cGUsIGhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gIHZhciByO1xuICB3aGlsZSAodGhpcy5ldmVudFJlbW92ZXJzW3NlY3Rpb25dLmxlbmd0aCkge1xuICAgIHIgPSB0aGlzLmV2ZW50UmVtb3ZlcnNbc2VjdGlvbl0uc2hpZnQoKTtcbiAgICByKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9pc1VybE9iamVjdChpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIFVSTCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBVUkw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5zdHJ1bWVudGVyO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsaXR5Jyk7XG52YXIgZXJyb3JQYXJzZXIgPSByZXF1aXJlKCcuLi9lcnJvclBhcnNlcicpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIGhhbmRsZURvbUV4Y2VwdGlvbihpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoaXRlbS5lcnIgJiYgZXJyb3JQYXJzZXIuU3RhY2soaXRlbS5lcnIpLm5hbWUgPT09ICdET01FeGNlcHRpb24nKSB7XG4gICAgdmFyIG9yaWdpbmFsRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICBvcmlnaW5hbEVycm9yLm5hbWUgPSBpdGVtLmVyci5uYW1lO1xuICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9IGl0ZW0uZXJyLm1lc3NhZ2U7XG4gICAgb3JpZ2luYWxFcnJvci5zdGFjayA9IGl0ZW0uZXJyLnN0YWNrO1xuICAgIG9yaWdpbmFsRXJyb3IubmVzdGVkID0gaXRlbS5lcnI7XG4gICAgaXRlbS5lcnIgPSBvcmlnaW5hbEVycm9yO1xuICB9XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGl0ZW0uZGF0YSA9IGl0ZW0uZGF0YSB8fCB7fTtcbiAgaWYgKGl0ZW0uZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGl0ZW0uc3RhY2tJbmZvID1cbiAgICAgICAgaXRlbS5lcnIuX3NhdmVkU3RhY2tUcmFjZSB8fFxuICAgICAgICBlcnJvclBhcnNlci5wYXJzZShpdGVtLmVyciwgaXRlbS5za2lwRnJhbWVzKTtcblxuICAgICAgaWYgKG9wdGlvbnMuYWRkRXJyb3JDb250ZXh0KSB7XG4gICAgICAgIGFkZEVycm9yQ29udGV4dChpdGVtKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIHBhcnNpbmcgdGhlIGVycm9yIG9iamVjdC4nLCBlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGl0ZW0ubWVzc2FnZSA9XG4gICAgICAgICAgaXRlbS5lcnIubWVzc2FnZSB8fFxuICAgICAgICAgIGl0ZW0uZXJyLmRlc2NyaXB0aW9uIHx8XG4gICAgICAgICAgaXRlbS5tZXNzYWdlIHx8XG4gICAgICAgICAgU3RyaW5nKGl0ZW0uZXJyKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGl0ZW0ubWVzc2FnZSA9IFN0cmluZyhpdGVtLmVycikgfHwgU3RyaW5nKGUyKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBpdGVtLmVycjtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9yQ29udGV4dChpdGVtKSB7XG4gIHZhciBjaGFpbiA9IFtdO1xuICB2YXIgZXJyID0gaXRlbS5lcnI7XG5cbiAgY2hhaW4ucHVzaChlcnIpO1xuXG4gIHdoaWxlIChlcnIubmVzdGVkIHx8IGVyci5jYXVzZSkge1xuICAgIGVyciA9IGVyci5uZXN0ZWQgfHwgZXJyLmNhdXNlO1xuICAgIGNoYWluLnB1c2goZXJyKTtcbiAgfVxuXG4gIF8uYWRkRXJyb3JDb250ZXh0KGl0ZW0sIGNoYWluKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlSXRlbUhhc1NvbWV0aGluZ1RvU2F5KGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghaXRlbS5tZXNzYWdlICYmICFpdGVtLnN0YWNrSW5mbyAmJiAhaXRlbS5jdXN0b20pIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIG1lc3NhZ2UsIHN0YWNrIGluZm8sIG9yIGN1c3RvbSBkYXRhJyksIG51bGwpO1xuICB9XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGRCYXNlSW5mbyhpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZW52aXJvbm1lbnQgPVxuICAgIChvcHRpb25zLnBheWxvYWQgJiYgb3B0aW9ucy5wYXlsb2FkLmVudmlyb25tZW50KSB8fCBvcHRpb25zLmVudmlyb25tZW50O1xuICBpdGVtLmRhdGEgPSBfLm1lcmdlKGl0ZW0uZGF0YSwge1xuICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICBsZXZlbDogaXRlbS5sZXZlbCxcbiAgICBlbmRwb2ludDogb3B0aW9ucy5lbmRwb2ludCxcbiAgICBwbGF0Zm9ybTogJ2Jyb3dzZXInLFxuICAgIGZyYW1ld29yazogJ2Jyb3dzZXItanMnLFxuICAgIGxhbmd1YWdlOiAnamF2YXNjcmlwdCcsXG4gICAgc2VydmVyOiB7fSxcbiAgICB1dWlkOiBpdGVtLnV1aWQsXG4gICAgbm90aWZpZXI6IHtcbiAgICAgIG5hbWU6ICdyb2xsYmFyLWJyb3dzZXItanMnLFxuICAgICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uLFxuICAgIH0sXG4gICAgY3VzdG9tOiBpdGVtLmN1c3RvbSxcbiAgfSk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGRSZXF1ZXN0SW5mbyh3aW5kb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IHt9O1xuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHJlcXVlc3RJbmZvLnVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgcmVxdWVzdEluZm8ucXVlcnlfc3RyaW5nID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3RlU3RyaW5nID0gJyRyZW1vdGVfaXAnO1xuICAgIGlmICghb3B0aW9ucy5jYXB0dXJlSXApIHtcbiAgICAgIHJlbW90ZVN0cmluZyA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNhcHR1cmVJcCAhPT0gdHJ1ZSkge1xuICAgICAgcmVtb3RlU3RyaW5nICs9ICdfYW5vbnltaXplJztcbiAgICB9XG4gICAgaWYgKHJlbW90ZVN0cmluZykgcmVxdWVzdEluZm8udXNlcl9pcCA9IHJlbW90ZVN0cmluZztcblxuICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0SW5mbykubGVuZ3RoID4gMCkge1xuICAgICAgXy5zZXQoaXRlbSwgJ2RhdGEucmVxdWVzdCcsIHJlcXVlc3RJbmZvKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkQ2xpZW50SW5mbyh3aW5kb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghd2luZG93KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgfVxuICAgIHZhciBuYXYgPSB3aW5kb3cubmF2aWdhdG9yIHx8IHt9O1xuICAgIHZhciBzY3IgPSB3aW5kb3cuc2NyZWVuIHx8IHt9O1xuICAgIF8uc2V0KGl0ZW0sICdkYXRhLmNsaWVudCcsIHtcbiAgICAgIHJ1bnRpbWVfbXM6IGl0ZW0udGltZXN0YW1wIC0gd2luZG93Ll9yb2xsYmFyU3RhcnRUaW1lLFxuICAgICAgdGltZXN0YW1wOiBNYXRoLnJvdW5kKGl0ZW0udGltZXN0YW1wIC8gMTAwMCksXG4gICAgICBqYXZhc2NyaXB0OiB7XG4gICAgICAgIGJyb3dzZXI6IG5hdi51c2VyQWdlbnQsXG4gICAgICAgIGxhbmd1YWdlOiBuYXYubGFuZ3VhZ2UsXG4gICAgICAgIGNvb2tpZV9lbmFibGVkOiBuYXYuY29va2llRW5hYmxlZCxcbiAgICAgICAgc2NyZWVuOiB7XG4gICAgICAgICAgd2lkdGg6IHNjci53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNjci5oZWlnaHQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRQbHVnaW5JbmZvKHdpbmRvdykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbnMgPSBbXTtcbiAgICB2YXIgbmF2UGx1Z2lucyA9IHdpbmRvdy5uYXZpZ2F0b3IucGx1Z2lucyB8fCBbXTtcbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmF2UGx1Z2lucy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGN1ciA9IG5hdlBsdWdpbnNbaV07XG4gICAgICBwbHVnaW5zLnB1c2goeyBuYW1lOiBjdXIubmFtZSwgZGVzY3JpcHRpb246IGN1ci5kZXNjcmlwdGlvbiB9KTtcbiAgICB9XG4gICAgXy5zZXQoaXRlbSwgJ2RhdGEuY2xpZW50LmphdmFzY3JpcHQucGx1Z2lucycsIHBsdWdpbnMpO1xuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRCb2R5KGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChpdGVtLnN0YWNrSW5mbykge1xuICAgIGlmIChpdGVtLnN0YWNrSW5mby50cmFjZUNoYWluKSB7XG4gICAgICBhZGRCb2R5VHJhY2VDaGFpbihpdGVtLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZEJvZHlUcmFjZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFkZEJvZHlNZXNzYWdlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRCb2R5TWVzc2FnZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9IGl0ZW0ubWVzc2FnZTtcbiAgdmFyIGN1c3RvbSA9IGl0ZW0uY3VzdG9tO1xuXG4gIGlmICghbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSAnSXRlbSBzZW50IHdpdGggbnVsbCBvciBtaXNzaW5nIGFyZ3VtZW50cy4nO1xuICB9XG4gIHZhciByZXN1bHQgPSB7XG4gICAgYm9keTogbWVzc2FnZSxcbiAgfTtcblxuICBpZiAoY3VzdG9tKSB7XG4gICAgcmVzdWx0LmV4dHJhID0gXy5tZXJnZShjdXN0b20pO1xuICB9XG5cbiAgXy5zZXQoaXRlbSwgJ2RhdGEuYm9keScsIHsgbWVzc2FnZTogcmVzdWx0IH0pO1xuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gc3RhY2tGcm9tSXRlbShpdGVtKSB7XG4gIC8vIFRyYW5zZm9ybSBhIFRyYWNlS2l0IHN0YWNrSW5mbyBvYmplY3QgaW50byBhIFJvbGxiYXIgdHJhY2VcbiAgdmFyIHN0YWNrID0gaXRlbS5zdGFja0luZm8uc3RhY2s7XG4gIGlmIChcbiAgICBzdGFjayAmJlxuICAgIHN0YWNrLmxlbmd0aCA9PT0gMCAmJlxuICAgIGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mbyAmJlxuICAgIGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mby5zdGFja1xuICApIHtcbiAgICBzdGFjayA9IGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mby5zdGFjaztcbiAgfVxuICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIGFkZEJvZHlUcmFjZUNoYWluKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFjZUNoYWluID0gaXRlbS5zdGFja0luZm8udHJhY2VDaGFpbjtcbiAgdmFyIHRyYWNlcyA9IFtdO1xuXG4gIHZhciB0cmFjZUNoYWluTGVuZ3RoID0gdHJhY2VDaGFpbi5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VDaGFpbkxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRyYWNlID0gYnVpbGRUcmFjZShpdGVtLCB0cmFjZUNoYWluW2ldLCBvcHRpb25zKTtcbiAgICB0cmFjZXMucHVzaCh0cmFjZSk7XG4gIH1cblxuICBfLnNldChpdGVtLCAnZGF0YS5ib2R5JywgeyB0cmFjZV9jaGFpbjogdHJhY2VzIH0pO1xuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gYWRkQm9keVRyYWNlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFjayA9IHN0YWNrRnJvbUl0ZW0oaXRlbSk7XG5cbiAgaWYgKHN0YWNrKSB7XG4gICAgdmFyIHRyYWNlID0gYnVpbGRUcmFjZShpdGVtLCBpdGVtLnN0YWNrSW5mbywgb3B0aW9ucyk7XG4gICAgXy5zZXQoaXRlbSwgJ2RhdGEuYm9keScsIHsgdHJhY2U6IHRyYWNlIH0pO1xuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGFja0luZm8gPSBpdGVtLnN0YWNrSW5mbztcbiAgICB2YXIgZ3Vlc3MgPSBlcnJvclBhcnNlci5ndWVzc0Vycm9yQ2xhc3Moc3RhY2tJbmZvLm1lc3NhZ2UpO1xuICAgIHZhciBjbGFzc05hbWUgPSBlcnJvckNsYXNzKHN0YWNrSW5mbywgZ3Vlc3NbMF0sIG9wdGlvbnMpO1xuICAgIHZhciBtZXNzYWdlID0gZ3Vlc3NbMV07XG5cbiAgICBpdGVtLm1lc3NhZ2UgPSBjbGFzc05hbWUgKyAnOiAnICsgbWVzc2FnZTtcbiAgICBhZGRCb2R5TWVzc2FnZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRUcmFjZShpdGVtLCBzdGFja0luZm8sIG9wdGlvbnMpIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0gaXRlbSAmJiBpdGVtLmRhdGEuZGVzY3JpcHRpb247XG4gIHZhciBjdXN0b20gPSBpdGVtICYmIGl0ZW0uY3VzdG9tO1xuICB2YXIgc3RhY2sgPSBzdGFja0Zyb21JdGVtKGl0ZW0pO1xuXG4gIHZhciBndWVzcyA9IGVycm9yUGFyc2VyLmd1ZXNzRXJyb3JDbGFzcyhzdGFja0luZm8ubWVzc2FnZSk7XG4gIHZhciBjbGFzc05hbWUgPSBlcnJvckNsYXNzKHN0YWNrSW5mbywgZ3Vlc3NbMF0sIG9wdGlvbnMpO1xuICB2YXIgbWVzc2FnZSA9IGd1ZXNzWzFdO1xuICB2YXIgdHJhY2UgPSB7XG4gICAgZXhjZXB0aW9uOiB7XG4gICAgICBjbGFzczogY2xhc3NOYW1lLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICB9LFxuICB9O1xuXG4gIGlmIChkZXNjcmlwdGlvbikge1xuICAgIHRyYWNlLmV4Y2VwdGlvbi5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9XG5cbiAgaWYgKHN0YWNrKSB7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdHJhY2UuZXhjZXB0aW9uLnN0YWNrID0gc3RhY2tJbmZvLnJhd1N0YWNrO1xuICAgICAgdHJhY2UuZXhjZXB0aW9uLnJhdyA9IFN0cmluZyhzdGFja0luZm8ucmF3RXhjZXB0aW9uKTtcbiAgICB9XG4gICAgdmFyIHN0YWNrRnJhbWU7XG4gICAgdmFyIGZyYW1lO1xuICAgIHZhciBjb2RlO1xuICAgIHZhciBwcmU7XG4gICAgdmFyIHBvc3Q7XG4gICAgdmFyIGNvbnRleHRMZW5ndGg7XG4gICAgdmFyIGksIG1pZDtcblxuICAgIHRyYWNlLmZyYW1lcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgc3RhY2tGcmFtZSA9IHN0YWNrW2ldO1xuICAgICAgZnJhbWUgPSB7XG4gICAgICAgIGZpbGVuYW1lOiBzdGFja0ZyYW1lLnVybCA/IF8uc2FuaXRpemVVcmwoc3RhY2tGcmFtZS51cmwpIDogJyh1bmtub3duKScsXG4gICAgICAgIGxpbmVubzogc3RhY2tGcmFtZS5saW5lIHx8IG51bGwsXG4gICAgICAgIG1ldGhvZDpcbiAgICAgICAgICAhc3RhY2tGcmFtZS5mdW5jIHx8IHN0YWNrRnJhbWUuZnVuYyA9PT0gJz8nXG4gICAgICAgICAgICA/ICdbYW5vbnltb3VzXSdcbiAgICAgICAgICAgIDogc3RhY2tGcmFtZS5mdW5jLFxuICAgICAgICBjb2xubzogc3RhY2tGcmFtZS5jb2x1bW4sXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMuc2VuZEZyYW1lVXJsKSB7XG4gICAgICAgIGZyYW1lLnVybCA9IHN0YWNrRnJhbWUudXJsO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBmcmFtZS5tZXRob2QgJiZcbiAgICAgICAgZnJhbWUubWV0aG9kLmVuZHNXaXRoICYmXG4gICAgICAgIGZyYW1lLm1ldGhvZC5lbmRzV2l0aCgnX3JvbGxiYXJfd3JhcHBlZCcpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvZGUgPSBwcmUgPSBwb3N0ID0gbnVsbDtcbiAgICAgIGNvbnRleHRMZW5ndGggPSBzdGFja0ZyYW1lLmNvbnRleHQgPyBzdGFja0ZyYW1lLmNvbnRleHQubGVuZ3RoIDogMDtcbiAgICAgIGlmIChjb250ZXh0TGVuZ3RoKSB7XG4gICAgICAgIG1pZCA9IE1hdGguZmxvb3IoY29udGV4dExlbmd0aCAvIDIpO1xuICAgICAgICBwcmUgPSBzdGFja0ZyYW1lLmNvbnRleHQuc2xpY2UoMCwgbWlkKTtcbiAgICAgICAgY29kZSA9IHN0YWNrRnJhbWUuY29udGV4dFttaWRdO1xuICAgICAgICBwb3N0ID0gc3RhY2tGcmFtZS5jb250ZXh0LnNsaWNlKG1pZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIGZyYW1lLmNvZGUgPSBjb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJlIHx8IHBvc3QpIHtcbiAgICAgICAgZnJhbWUuY29udGV4dCA9IHt9O1xuICAgICAgICBpZiAocHJlICYmIHByZS5sZW5ndGgpIHtcbiAgICAgICAgICBmcmFtZS5jb250ZXh0LnByZSA9IHByZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zdCAmJiBwb3N0Lmxlbmd0aCkge1xuICAgICAgICAgIGZyYW1lLmNvbnRleHQucG9zdCA9IHBvc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YWNrRnJhbWUuYXJncykge1xuICAgICAgICBmcmFtZS5hcmdzID0gc3RhY2tGcmFtZS5hcmdzO1xuICAgICAgfVxuXG4gICAgICB0cmFjZS5mcmFtZXMucHVzaChmcmFtZSk7XG4gICAgfVxuXG4gICAgLy8gTk9URShjb3J5KTogcmV2ZXJzZSB0aGUgZnJhbWVzIHNpbmNlIHJvbGxiYXIuY29tIGV4cGVjdHMgdGhlIG1vc3QgcmVjZW50IGNhbGwgbGFzdFxuICAgIHRyYWNlLmZyYW1lcy5yZXZlcnNlKCk7XG5cbiAgICBpZiAoY3VzdG9tKSB7XG4gICAgICB0cmFjZS5leHRyYSA9IF8ubWVyZ2UoY3VzdG9tKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJhY2U7XG59XG5cbmZ1bmN0aW9uIGVycm9yQ2xhc3Moc3RhY2tJbmZvLCBndWVzcywgb3B0aW9ucykge1xuICBpZiAoc3RhY2tJbmZvLm5hbWUpIHtcbiAgICByZXR1cm4gc3RhY2tJbmZvLm5hbWU7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ndWVzc0Vycm9yQ2xhc3MpIHtcbiAgICByZXR1cm4gZ3Vlc3M7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcodW5rbm93biknO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFNjcnViYmVyKHNjcnViRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmIChzY3J1YkZuKSB7XG4gICAgICB2YXIgc2NydWJGaWVsZHMgPSBvcHRpb25zLnNjcnViRmllbGRzIHx8IFtdO1xuICAgICAgdmFyIHNjcnViUGF0aHMgPSBvcHRpb25zLnNjcnViUGF0aHMgfHwgW107XG4gICAgICBpdGVtLmRhdGEgPSBzY3J1YkZuKGl0ZW0uZGF0YSwgc2NydWJGaWVsZHMsIHNjcnViUGF0aHMpO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhbmRsZURvbUV4Y2VwdGlvbjogaGFuZGxlRG9tRXhjZXB0aW9uLFxuICBoYW5kbGVJdGVtV2l0aEVycm9yOiBoYW5kbGVJdGVtV2l0aEVycm9yLFxuICBlbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXk6IGVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheSxcbiAgYWRkQmFzZUluZm86IGFkZEJhc2VJbmZvLFxuICBhZGRSZXF1ZXN0SW5mbzogYWRkUmVxdWVzdEluZm8sXG4gIGFkZENsaWVudEluZm86IGFkZENsaWVudEluZm8sXG4gIGFkZFBsdWdpbkluZm86IGFkZFBsdWdpbkluZm8sXG4gIGFkZEJvZHk6IGFkZEJvZHksXG4gIGFkZFNjcnViYmVyOiBhZGRTY3J1YmJlcixcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWxpdHknKTtcbnZhciBtYWtlRmV0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvZmV0Y2gnKTtcbnZhciBtYWtlWGhyUmVxdWVzdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hocicpO1xuXG4vKlxuICogYWNjZXNzVG9rZW4gbWF5IGJlIGVtYmVkZGVkIGluIHBheWxvYWQgYnV0IHRoYXQgc2hvdWxkIG5vdFxuICogICBiZSBhc3N1bWVkXG4gKlxuICogb3B0aW9uczoge1xuICogICBob3N0bmFtZVxuICogICBwcm90b2NvbFxuICogICBwYXRoXG4gKiAgIHBvcnRcbiAqICAgbWV0aG9kXG4gKiAgIHRyYW5zcG9ydCAoJ3hocicgfCAnZmV0Y2gnKVxuICogfVxuICpcbiAqICBwYXJhbXMgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5L3ZhbHVlIHBhaXJzLiBUaGVzZVxuICogICAgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcGF0aCBhcyAna2V5PXZhbHVlJmtleT12YWx1ZSdcbiAqXG4gKiBwYXlsb2FkIGlzIGFuIHVuc2VyaWFsaXplZCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gVHJhbnNwb3J0KHRydW5jYXRpb24pIHtcbiAgdGhpcy50cnVuY2F0aW9uID0gdHJ1bmNhdGlvbjtcbn1cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoXG4gIGFjY2Vzc1Rva2VuLFxuICBvcHRpb25zLFxuICBwYXJhbXMsXG4gIGNhbGxiYWNrLFxuICByZXF1ZXN0RmFjdG9yeSxcbikge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuICBfLmFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoKGFjY2Vzc1Rva2VuLCBvcHRpb25zLCBwYXJhbXMpO1xuXG4gIHZhciBtZXRob2QgPSAnR0VUJztcbiAgdmFyIHVybCA9IF8uZm9ybWF0VXJsKG9wdGlvbnMpO1xuICB0aGlzLl9tYWtlWm9uZVJlcXVlc3QoXG4gICAgYWNjZXNzVG9rZW4sXG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBudWxsLFxuICAgIGNhbGxiYWNrLFxuICAgIHJlcXVlc3RGYWN0b3J5LFxuICAgIG9wdGlvbnMudGltZW91dCxcbiAgICBvcHRpb25zLnRyYW5zcG9ydCxcbiAgKTtcbn07XG5cblRyYW5zcG9ydC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChcbiAgYWNjZXNzVG9rZW4sXG4gIG9wdGlvbnMsXG4gIHBheWxvYWQsXG4gIGNhbGxiYWNrLFxuICByZXF1ZXN0RmFjdG9yeSxcbikge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGlmICghcGF5bG9hZCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nhbm5vdCBzZW5kIGVtcHR5IHJlcXVlc3QnKSk7XG4gIH1cblxuICB2YXIgc3RyaW5naWZ5UmVzdWx0O1xuICBpZiAodGhpcy50cnVuY2F0aW9uKSB7XG4gICAgc3RyaW5naWZ5UmVzdWx0ID0gdGhpcy50cnVuY2F0aW9uLnRydW5jYXRlKHBheWxvYWQpO1xuICB9IGVsc2Uge1xuICAgIHN0cmluZ2lmeVJlc3VsdCA9IF8uc3RyaW5naWZ5KHBheWxvYWQpO1xuICB9XG4gIGlmIChzdHJpbmdpZnlSZXN1bHQuZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soc3RyaW5naWZ5UmVzdWx0LmVycm9yKTtcbiAgfVxuXG4gIHZhciB3cml0ZURhdGEgPSBzdHJpbmdpZnlSZXN1bHQudmFsdWU7XG4gIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gIHZhciB1cmwgPSBfLmZvcm1hdFVybChvcHRpb25zKTtcbiAgdGhpcy5fbWFrZVpvbmVSZXF1ZXN0KFxuICAgIGFjY2Vzc1Rva2VuLFxuICAgIHVybCxcbiAgICBtZXRob2QsXG4gICAgd3JpdGVEYXRhLFxuICAgIGNhbGxiYWNrLFxuICAgIHJlcXVlc3RGYWN0b3J5LFxuICAgIG9wdGlvbnMudGltZW91dCxcbiAgICBvcHRpb25zLnRyYW5zcG9ydCxcbiAgKTtcbn07XG5cblRyYW5zcG9ydC5wcm90b3R5cGUucG9zdEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKFxuICBhY2Nlc3NUb2tlbixcbiAgb3B0aW9ucyxcbiAganNvblBheWxvYWQsXG4gIGNhbGxiYWNrLFxuICByZXF1ZXN0RmFjdG9yeSxcbikge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gIHZhciB1cmwgPSBfLmZvcm1hdFVybChvcHRpb25zKTtcbiAgdGhpcy5fbWFrZVpvbmVSZXF1ZXN0KFxuICAgIGFjY2Vzc1Rva2VuLFxuICAgIHVybCxcbiAgICBtZXRob2QsXG4gICAganNvblBheWxvYWQsXG4gICAgY2FsbGJhY2ssXG4gICAgcmVxdWVzdEZhY3RvcnksXG4gICAgb3B0aW9ucy50aW1lb3V0LFxuICAgIG9wdGlvbnMudHJhbnNwb3J0LFxuICApO1xufTtcblxuLy8gV3JhcHMgYF9tYWtlUmVxdWVzdGAgaWYgem9uZS5qcyBpcyBiZWluZyB1c2VkLCBlbnN1cmluZyB0aGF0IFJvbGxiYXJcbi8vIEFQSSBjYWxscyBhcmUgbm90IGludGVyY2VwdGVkIGJ5IGFueSBjaGlsZCBmb3JrZWQgem9uZXMuXG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYE5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcmAgaW4gQW5ndWxhci5cblRyYW5zcG9ydC5wcm90b3R5cGUuX21ha2Vab25lUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdXaW5kb3cgPVxuICAgICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHxcbiAgICAodHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZik7XG4gIC8vIFdoZW5ldmVyIHpvbmUuanMgaXMgbG9hZGVkIGFuZCBgWm9uZWAgaXMgZXhwb3NlZCBnbG9iYWxseSwgYWNjZXNzXG4gIC8vIHRoZSByb290IHpvbmUgdG8gZW5zdXJlIHRoYXQgcmVxdWVzdHMgYXJlIGFsd2F5cyBtYWRlIHdpdGhpbiBpdC5cbiAgLy8gVGhpcyBhcHByb2FjaCBpcyBmcmFtZXdvcmstYWdub3N0aWMsIHJlZ2FyZGxlc3Mgb2Ygd2hpY2hcbiAgLy8gZnJhbWV3b3JrIHpvbmUuanMgaXMgdXNlZCB3aXRoLlxuICB2YXIgcm9vdFpvbmUgPSBnV2luZG93ICYmIGdXaW5kb3cuWm9uZSAmJiBnV2luZG93LlpvbmUucm9vdDtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGlmIChyb290Wm9uZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByb290Wm9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fbWFrZVJlcXVlc3QuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9tYWtlUmVxdWVzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9XG59O1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLl9tYWtlUmVxdWVzdCA9IGZ1bmN0aW9uIChcbiAgYWNjZXNzVG9rZW4sXG4gIHVybCxcbiAgbWV0aG9kLFxuICBkYXRhLFxuICBjYWxsYmFjayxcbiAgcmVxdWVzdEZhY3RvcnksXG4gIHRpbWVvdXQsXG4gIHRyYW5zcG9ydCxcbikge1xuICBpZiAodHlwZW9mIFJvbGxiYXJQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gX3Byb3h5UmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHJhbnNwb3J0ID09PSAnZmV0Y2gnKSB7XG4gICAgbWFrZUZldGNoUmVxdWVzdChhY2Nlc3NUb2tlbiwgdXJsLCBtZXRob2QsIGRhdGEsIGNhbGxiYWNrLCB0aW1lb3V0KTtcbiAgfSBlbHNlIHtcbiAgICBtYWtlWGhyUmVxdWVzdChcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgdXJsLFxuICAgICAgbWV0aG9kLFxuICAgICAgZGF0YSxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgcmVxdWVzdEZhY3RvcnksXG4gICAgICB0aW1lb3V0LFxuICAgICk7XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBSb2xsYmFyUHJveHkgKi9cbmZ1bmN0aW9uIF9wcm94eVJlcXVlc3QoanNvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJvbGxiYXJQcm94eSA9IG5ldyBSb2xsYmFyUHJveHkoKTtcbiAgcm9sbGJhclByb3h5LnNlbmRKc29uUGF5bG9hZChcbiAgICBqc29uLFxuICAgIGZ1bmN0aW9uIChfbXNnKSB7XG4gICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihlcnIpKTtcbiAgICB9LFxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcbiIsInZhciBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0eScpO1xuXG5mdW5jdGlvbiBtYWtlRmV0Y2hSZXF1ZXN0KGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgdmFyIGNvbnRyb2xsZXI7XG4gIHZhciB0aW1lb3V0SWQ7XG5cbiAgaWYgKF8uaXNGaW5pdGVOdW1iZXIodGltZW91dCkpIHtcbiAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdYLVJvbGxiYXItQWNjZXNzLVRva2VuJzogYWNjZXNzVG9rZW4sXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWwsXG4gICAgfSxcbiAgICBib2R5OiBkYXRhLFxuICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pXG4gICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VGZXRjaFJlcXVlc3Q7XG4iLCIvKmdsb2JhbCBYRG9tYWluUmVxdWVzdCovXG5cbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0eScpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuXG5mdW5jdGlvbiBtYWtlWGhyUmVxdWVzdChcbiAgYWNjZXNzVG9rZW4sXG4gIHVybCxcbiAgbWV0aG9kLFxuICBkYXRhLFxuICBjYWxsYmFjayxcbiAgcmVxdWVzdEZhY3RvcnksXG4gIHRpbWVvdXQsXG4pIHtcbiAgdmFyIHJlcXVlc3Q7XG4gIGlmIChyZXF1ZXN0RmFjdG9yeSkge1xuICAgIHJlcXVlc3QgPSByZXF1ZXN0RmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QgPSBfY3JlYXRlWE1MSFRUUE9iamVjdCgpO1xuICB9XG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEdpdmUgdXAsIG5vIHdheSB0byBzZW5kIHJlcXVlc3RzXG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm8gd2F5IHRvIHNlbmQgYSByZXF1ZXN0JykpO1xuICB9XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG9ucmVhZHlzdGF0ZWNoYW5nZSAmJiByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIG9ucmVhZHlzdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdmFyIHBhcnNlUmVzcG9uc2UgPSBfLmpzb25QYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBpZiAoX2lzU3VjY2VzcyhyZXF1ZXN0KSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwYXJzZVJlc3BvbnNlLmVycm9yLCBwYXJzZVJlc3BvbnNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfaXNOb3JtYWxGYWlsdXJlKHJlcXVlc3QpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgLy8gbGlrZWx5IGNhdXNlZCBieSB1c2luZyBhIHNlcnZlciBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICBwYXJzZVJlc3BvbnNlLnZhbHVlICYmIHBhcnNlUmVzcG9uc2UudmFsdWUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbGlkIGh0dHAgc3RhdHVzIGNvZGVzXG4gICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihTdHJpbmcocmVxdWVzdC5zdGF0dXMpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJRSB3aWxsIHJldHVybiBhIHN0YXR1cyAxMjAwMCsgb24gc29tZSBzb3J0IG9mIGNvbm5lY3Rpb24gZmFpbHVyZSxcbiAgICAgICAgICAgICAgLy8gc28gd2UgcmV0dXJuIGEgYmxhbmsgZXJyb3JcbiAgICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2FhMzgzNzcwJTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgICB2YXIgbXNnID1cbiAgICAgICAgICAgICAgICAnWEhSIHJlc3BvbnNlIGhhZCBubyBzdGF0dXMgY29kZSAobGlrZWx5IGNvbm5lY3Rpb24gZmFpbHVyZSknO1xuICAgICAgICAgICAgICBjYWxsYmFjayhfbmV3UmV0cmlhYmxlRXJyb3IobXNnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIC8vanF1ZXJ5IHNvdXJjZSBtZW50aW9ucyBmaXJlZm94IG1heSBlcnJvciBvdXQgd2hpbGUgYWNjZXNzaW5nIHRoZVxuICAgICAgICAgIC8vcmVxdWVzdCBtZW1iZXJzIGlmIHRoZXJlIGlzIGEgbmV0d29yayBlcnJvclxuICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9hOTM4ZDdiMTI4MmZjMGU1YzUyNTAyYzIyNWFlOGYwY2VmMjE5ZjBhL3NyYy9hamF4L3hoci5qcyNMMTExXG4gICAgICAgICAgdmFyIGV4YztcbiAgICAgICAgICBpZiAoZXggJiYgZXguc3RhY2spIHtcbiAgICAgICAgICAgIGV4YyA9IGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGMgPSBuZXcgRXJyb3IoZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhleGMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgaWYgKHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignWC1Sb2xsYmFyLUFjY2Vzcy1Ub2tlbicsIGFjY2Vzc1Rva2VuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNGaW5pdGVOdW1iZXIodGltZW91dCkpIHtcbiAgICAgICAgcmVxdWVzdC50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvbnJlYWR5c3RhdGVjaGFuZ2U7XG4gICAgICByZXF1ZXN0LnNlbmQoZGF0YSk7XG4gICAgfSBjYXRjaCAoZTEpIHtcbiAgICAgIC8vIFNlbmRpbmcgdXNpbmcgdGhlIG5vcm1hbCB4bWxodHRwcmVxdWVzdCBvYmplY3QgZGlkbid0IHdvcmssIHRyeSBYRG9tYWluUmVxdWVzdFxuICAgICAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQXNzdW1lIHdlIGFyZSBpbiBhIHJlYWxseSBvbGQgYnJvd3NlciB3aGljaCBoYXMgYSBidW5jaCBvZiBsaW1pdGF0aW9uczpcbiAgICAgICAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuXG4gICAgICAgIC8vIEV4dHJlbWUgcGFyYW5vaWE6IGlmIHdlIGhhdmUgWERvbWFpblJlcXVlc3QgdGhlbiB3ZSBoYXZlIGEgd2luZG93LCBidXQganVzdCBpbiBjYXNlXG4gICAgICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdObyB3aW5kb3cgYXZhaWxhYmxlIGR1cmluZyByZXF1ZXN0LCB1bmtub3duIGVudmlyb25tZW50JyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHBhZ2UgaXMgaHR0cCwgdHJ5IGFuZCBzZW5kIG92ZXIgaHR0cFxuICAgICAgICBpZiAoXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc3Vic3RyaW5nKDAsIDUpID09PSAnaHR0cDonICYmXG4gICAgICAgICAgdXJsLnN1YnN0cmluZygwLCA1KSA9PT0gJ2h0dHBzJ1xuICAgICAgICApIHtcbiAgICAgICAgICB1cmwgPSAnaHR0cCcgKyB1cmwuc3Vic3RyaW5nKDUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhkb21haW5yZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHhkb21haW5yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtc2cgPSAnUmVxdWVzdCB0aW1lZCBvdXQnO1xuICAgICAgICAgIHZhciBjb2RlID0gJ0VUSU1FRE9VVCc7XG4gICAgICAgICAgY2FsbGJhY2soX25ld1JldHJpYWJsZUVycm9yKG1zZywgY29kZSkpO1xuICAgICAgICB9O1xuICAgICAgICB4ZG9tYWlucmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRXJyb3IgZHVyaW5nIHJlcXVlc3QnKSk7XG4gICAgICAgIH07XG4gICAgICAgIHhkb21haW5yZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcGFyc2VSZXNwb25zZSA9IF8uanNvblBhcnNlKHhkb21haW5yZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgY2FsbGJhY2socGFyc2VSZXNwb25zZS5lcnJvciwgcGFyc2VSZXNwb25zZS52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHhkb21haW5yZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICB4ZG9tYWlucmVxdWVzdC5zZW5kKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIG1ldGhvZCB0byB0cmFuc3BvcnQgYSByZXF1ZXN0JykpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgICBjYWxsYmFjayhlMik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhNTEhUVFBPYmplY3QoKSB7XG4gIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0OmZhbHNlICovXG5cbiAgdmFyIGZhY3RvcmllcyA9IFtcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMy5YTUxIVFRQJyk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSxcbiAgXTtcbiAgdmFyIHhtbGh0dHA7XG4gIHZhciBpO1xuICB2YXIgbnVtRmFjdG9yaWVzID0gZmFjdG9yaWVzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IG51bUZhY3RvcmllczsgaSsrKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgICB0cnkge1xuICAgICAgeG1saHR0cCA9IGZhY3Rvcmllc1tpXSgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcGFzc1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG4gIH1cbiAgcmV0dXJuIHhtbGh0dHA7XG59XG5cbmZ1bmN0aW9uIF9pc1N1Y2Nlc3Mocikge1xuICByZXR1cm4gciAmJiByLnN0YXR1cyAmJiByLnN0YXR1cyA9PT0gMjAwO1xufVxuXG5mdW5jdGlvbiBfaXNOb3JtYWxGYWlsdXJlKHIpIHtcbiAgcmV0dXJuIHIgJiYgXy5pc1R5cGUoci5zdGF0dXMsICdudW1iZXInKSAmJiByLnN0YXR1cyA+PSA0MDAgJiYgci5zdGF0dXMgPCA2MDA7XG59XG5cbmZ1bmN0aW9uIF9uZXdSZXRyaWFibGVFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29kZSB8fCAnRU5PVEZPVU5EJztcbiAgcmV0dXJuIGVycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlWGhyUmVxdWVzdDtcbiIsIi8vIFNlZSBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL3VybC5odG1sXG5mdW5jdGlvbiBwYXJzZSh1cmwpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBwcm90b2NvbDogbnVsbCxcbiAgICBhdXRoOiBudWxsLFxuICAgIGhvc3Q6IG51bGwsXG4gICAgcGF0aDogbnVsbCxcbiAgICBoYXNoOiBudWxsLFxuICAgIGhyZWY6IHVybCxcbiAgICBob3N0bmFtZTogbnVsbCxcbiAgICBwb3J0OiBudWxsLFxuICAgIHBhdGhuYW1lOiBudWxsLFxuICAgIHNlYXJjaDogbnVsbCxcbiAgICBxdWVyeTogbnVsbCxcbiAgfTtcblxuICB2YXIgaSwgbGFzdDtcbiAgaSA9IHVybC5pbmRleE9mKCcvLycpO1xuICBpZiAoaSAhPT0gLTEpIHtcbiAgICByZXN1bHQucHJvdG9jb2wgPSB1cmwuc3Vic3RyaW5nKDAsIGkpO1xuICAgIGxhc3QgPSBpICsgMjtcbiAgfSBlbHNlIHtcbiAgICBsYXN0ID0gMDtcbiAgfVxuXG4gIGkgPSB1cmwuaW5kZXhPZignQCcsIGxhc3QpO1xuICBpZiAoaSAhPT0gLTEpIHtcbiAgICByZXN1bHQuYXV0aCA9IHVybC5zdWJzdHJpbmcobGFzdCwgaSk7XG4gICAgbGFzdCA9IGkgKyAxO1xuICB9XG5cbiAgaSA9IHVybC5pbmRleE9mKCcvJywgbGFzdCk7XG4gIGlmIChpID09PSAtMSkge1xuICAgIGkgPSB1cmwuaW5kZXhPZignPycsIGxhc3QpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgaSA9IHVybC5pbmRleE9mKCcjJywgbGFzdCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuICAgICAgICByZXN1bHQuaGFzaCA9IHVybC5zdWJzdHJpbmcoaSk7XG4gICAgICB9XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgICAgcmVzdWx0LnBvcnQgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgICAgaWYgKHJlc3VsdC5wb3J0KSB7XG4gICAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VJbnQocmVzdWx0LnBvcnQsIDEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5ob3N0ID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgICByZXN1bHQucG9ydCA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMV07XG4gICAgICBpZiAocmVzdWx0LnBvcnQpIHtcbiAgICAgICAgcmVzdWx0LnBvcnQgPSBwYXJzZUludChyZXN1bHQucG9ydCwgMTApO1xuICAgICAgfVxuICAgICAgbGFzdCA9IGk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5ob3N0ID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgIHJlc3VsdC5wb3J0ID0gcmVzdWx0Lmhvc3Quc3BsaXQoJzonKVsxXTtcbiAgICBpZiAocmVzdWx0LnBvcnQpIHtcbiAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VJbnQocmVzdWx0LnBvcnQsIDEwKTtcbiAgICB9XG4gICAgbGFzdCA9IGk7XG4gIH1cblxuICBpID0gdXJsLmluZGV4T2YoJyMnLCBsYXN0KTtcbiAgaWYgKGkgPT09IC0xKSB7XG4gICAgcmVzdWx0LnBhdGggPSB1cmwuc3Vic3RyaW5nKGxhc3QpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRoID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICByZXN1bHQuaGFzaCA9IHVybC5zdWJzdHJpbmcoaSk7XG4gIH1cblxuICBpZiAocmVzdWx0LnBhdGgpIHtcbiAgICB2YXIgcGF0aFBhcnRzID0gcmVzdWx0LnBhdGguc3BsaXQoJz8nKTtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBwYXRoUGFydHNbMF07XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcGF0aFBhcnRzWzFdO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZXN1bHQucXVlcnkgPyAnPycgKyByZXN1bHQucXVlcnkgOiBudWxsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogcGFyc2UsXG59O1xuIiwiZnVuY3Rpb24gd3JhcEdsb2JhbHMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYnVnc25hZy9idWdzbmFnLWpzXG4gIHZhciBnbG9iYWxzID1cbiAgICAnRXZlbnRUYXJnZXQsV2luZG93LE5vZGUsQXBwbGljYXRpb25DYWNoZSxBdWRpb1RyYWNrTGlzdCxDaGFubmVsTWVyZ2VyTm9kZSxDcnlwdG9PcGVyYXRpb24sRXZlbnRTb3VyY2UsRmlsZVJlYWRlcixIVE1MVW5rbm93bkVsZW1lbnQsSURCRGF0YWJhc2UsSURCUmVxdWVzdCxJREJUcmFuc2FjdGlvbixLZXlPcGVyYXRpb24sTWVkaWFDb250cm9sbGVyLE1lc3NhZ2VQb3J0LE1vZGFsV2luZG93LE5vdGlmaWNhdGlvbixTVkdFbGVtZW50SW5zdGFuY2UsU2NyZWVuLFRleHRUcmFjayxUZXh0VHJhY2tDdWUsVGV4dFRyYWNrTGlzdCxXZWJTb2NrZXQsV2ViU29ja2V0V29ya2VyLFdvcmtlcixYTUxIdHRwUmVxdWVzdCxYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LFhNTEh0dHBSZXF1ZXN0VXBsb2FkJy5zcGxpdChcbiAgICAgICcsJyxcbiAgICApO1xuICB2YXIgaSwgZ2xvYmFsO1xuICBmb3IgKGkgPSAwOyBpIDwgZ2xvYmFscy5sZW5ndGg7ICsraSkge1xuICAgIGdsb2JhbCA9IGdsb2JhbHNbaV07XG5cbiAgICBpZiAod2luZG93W2dsb2JhbF0gJiYgd2luZG93W2dsb2JhbF0ucHJvdG90eXBlKSB7XG4gICAgICBfZXh0ZW5kTGlzdGVuZXJQcm90b3R5cGUoaGFuZGxlciwgd2luZG93W2dsb2JhbF0ucHJvdG90eXBlLCBzaGltKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZExpc3RlbmVyUHJvdG90eXBlKGhhbmRsZXIsIHByb3RvdHlwZSwgc2hpbSkge1xuICBpZiAoXG4gICAgcHJvdG90eXBlLmhhc093blByb3BlcnR5ICYmXG4gICAgcHJvdG90eXBlLmhhc093blByb3BlcnR5KCdhZGRFdmVudExpc3RlbmVyJylcbiAgKSB7XG4gICAgdmFyIG9sZEFkZEV2ZW50TGlzdGVuZXIgPSBwcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB3aGlsZSAoXG4gICAgICBvbGRBZGRFdmVudExpc3RlbmVyLl9yb2xsYmFyT2xkQWRkICYmXG4gICAgICBvbGRBZGRFdmVudExpc3RlbmVyLmJlbG9uZ3NUb1NoaW1cbiAgICApIHtcbiAgICAgIG9sZEFkZEV2ZW50TGlzdGVuZXIgPSBvbGRBZGRFdmVudExpc3RlbmVyLl9yb2xsYmFyT2xkQWRkO1xuICAgIH1cbiAgICB2YXIgYWRkRm4gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrLCBidWJibGUpIHtcbiAgICAgIG9sZEFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgaGFuZGxlci53cmFwKGNhbGxiYWNrKSwgYnViYmxlKTtcbiAgICB9O1xuICAgIGFkZEZuLl9yb2xsYmFyT2xkQWRkID0gb2xkQWRkRXZlbnRMaXN0ZW5lcjtcbiAgICBhZGRGbi5iZWxvbmdzVG9TaGltID0gc2hpbTtcbiAgICBwcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEZuO1xuXG4gICAgdmFyIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICB3aGlsZSAoXG4gICAgICBvbGRSZW1vdmVFdmVudExpc3RlbmVyLl9yb2xsYmFyT2xkUmVtb3ZlICYmXG4gICAgICBvbGRSZW1vdmVFdmVudExpc3RlbmVyLmJlbG9uZ3NUb1NoaW1cbiAgICApIHtcbiAgICAgIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIgPSBvbGRSZW1vdmVFdmVudExpc3RlbmVyLl9yb2xsYmFyT2xkUmVtb3ZlO1xuICAgIH1cbiAgICB2YXIgcmVtb3ZlRm4gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrLCBidWJibGUpIHtcbiAgICAgIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIChjYWxsYmFjayAmJiBjYWxsYmFjay5fcm9sbGJhcl93cmFwcGVkKSB8fCBjYWxsYmFjayxcbiAgICAgICAgYnViYmxlLFxuICAgICAgKTtcbiAgICB9O1xuICAgIHJlbW92ZUZuLl9yb2xsYmFyT2xkUmVtb3ZlID0gb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICByZW1vdmVGbi5iZWxvbmdzVG9TaGltID0gc2hpbTtcbiAgICBwcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcEdsb2JhbHM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvbjogJzMuMC4wLWFscGhhLjAnLFxuICBlbmRwb2ludDogJ2FwaS5yb2xsYmFyLmNvbS9hcGkvMS9pdGVtLycsXG4gIGxvZ0xldmVsOiAnZGVidWcnLFxuICByZXBvcnRMZXZlbDogJ2RlYnVnJyxcbiAgdW5jYXVnaHRFcnJvckxldmVsOiAnZXJyb3InLFxuICBtYXhJdGVtczogMCxcbiAgaXRlbXNQZXJNaW46IDYwLFxufTtcbiIsInZhciBFcnJvclN0YWNrUGFyc2VyID0gcmVxdWlyZSgnZXJyb3Itc3RhY2stcGFyc2VyJyk7XG5cbnZhciBVTktOT1dOX0ZVTkNUSU9OID0gJz8nO1xudmFyIEVSUl9DTEFTU19SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXigoW2EtekEtWjAtOS1fJCBdKik6ICopPyhVbmNhdWdodCApPyhbYS16QS1aMC05LV8kIF0qKTogJyxcbik7XG5cbmZ1bmN0aW9uIGd1ZXNzRnVuY3Rpb25OYW1lKCkge1xuICByZXR1cm4gVU5LTk9XTl9GVU5DVElPTjtcbn1cblxuZnVuY3Rpb24gZ2F0aGVyQ29udGV4dCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIEZyYW1lKHN0YWNrRnJhbWUpIHtcbiAgdmFyIGRhdGEgPSB7fTtcblxuICBkYXRhLl9zdGFja0ZyYW1lID0gc3RhY2tGcmFtZTtcblxuICBkYXRhLnVybCA9IHN0YWNrRnJhbWUuZmlsZU5hbWU7XG4gIGRhdGEubGluZSA9IHN0YWNrRnJhbWUubGluZU51bWJlcjtcbiAgZGF0YS5mdW5jID0gc3RhY2tGcmFtZS5mdW5jdGlvbk5hbWU7XG4gIGRhdGEuY29sdW1uID0gc3RhY2tGcmFtZS5jb2x1bW5OdW1iZXI7XG4gIGRhdGEuYXJncyA9IHN0YWNrRnJhbWUuYXJncztcblxuICBkYXRhLmNvbnRleHQgPSBnYXRoZXJDb250ZXh0KCk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIFN0YWNrKGV4Y2VwdGlvbiwgc2tpcCkge1xuICBmdW5jdGlvbiBnZXRTdGFjaygpIHtcbiAgICB2YXIgcGFyc2VyU3RhY2sgPSBbXTtcblxuICAgIHNraXAgPSBza2lwIHx8IDA7XG5cbiAgICB0cnkge1xuICAgICAgcGFyc2VyU3RhY2sgPSBFcnJvclN0YWNrUGFyc2VyLnBhcnNlKGV4Y2VwdGlvbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcGFyc2VyU3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSBza2lwOyBpIDwgcGFyc2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YWNrLnB1c2gobmV3IEZyYW1lKHBhcnNlclN0YWNrW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFjazogZ2V0U3RhY2soKSxcbiAgICBtZXNzYWdlOiBleGNlcHRpb24ubWVzc2FnZSxcbiAgICBuYW1lOiBfbW9zdFNwZWNpZmljRXJyb3JOYW1lKGV4Y2VwdGlvbiksXG4gICAgcmF3U3RhY2s6IGV4Y2VwdGlvbi5zdGFjayxcbiAgICByYXdFeGNlcHRpb246IGV4Y2VwdGlvbixcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZSwgc2tpcCkge1xuICB2YXIgZXJyID0gZTtcblxuICBpZiAoZXJyLm5lc3RlZCB8fCBlcnIuY2F1c2UpIHtcbiAgICB2YXIgdHJhY2VDaGFpbiA9IFtdO1xuICAgIHdoaWxlIChlcnIpIHtcbiAgICAgIHRyYWNlQ2hhaW4ucHVzaChuZXcgU3RhY2soZXJyLCBza2lwKSk7XG4gICAgICBlcnIgPSBlcnIubmVzdGVkIHx8IGVyci5jYXVzZTtcblxuICAgICAgc2tpcCA9IDA7IC8vIE9ubHkgYXBwbHkgc2tpcCB2YWx1ZSB0byBwcmltYXJ5IGVycm9yXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHByaW1hcnkgZXJyb3Igd2l0aCBmdWxsIHRyYWNlIGNoYWluIGF0dGFjaGVkLlxuICAgIHRyYWNlQ2hhaW5bMF0udHJhY2VDaGFpbiA9IHRyYWNlQ2hhaW47XG4gICAgcmV0dXJuIHRyYWNlQ2hhaW5bMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBTdGFjayhlcnIsIHNraXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGd1ZXNzRXJyb3JDbGFzcyhlcnJNc2cpIHtcbiAgaWYgKCFlcnJNc2cgfHwgIWVyck1zZy5tYXRjaCkge1xuICAgIHJldHVybiBbJ1Vua25vd24gZXJyb3IuIFRoZXJlIHdhcyBubyBlcnJvciBtZXNzYWdlIHRvIGRpc3BsYXkuJywgJyddO1xuICB9XG4gIHZhciBlcnJDbGFzc01hdGNoID0gZXJyTXNnLm1hdGNoKEVSUl9DTEFTU19SRUdFWFApO1xuICB2YXIgZXJyQ2xhc3MgPSAnKHVua25vd24pJztcblxuICBpZiAoZXJyQ2xhc3NNYXRjaCkge1xuICAgIGVyckNsYXNzID0gZXJyQ2xhc3NNYXRjaFtlcnJDbGFzc01hdGNoLmxlbmd0aCAtIDFdO1xuICAgIGVyck1zZyA9IGVyck1zZy5yZXBsYWNlKFxuICAgICAgKGVyckNsYXNzTWF0Y2hbZXJyQ2xhc3NNYXRjaC5sZW5ndGggLSAyXSB8fCAnJykgKyBlcnJDbGFzcyArICc6JyxcbiAgICAgICcnLFxuICAgICk7XG4gICAgZXJyTXNnID0gZXJyTXNnLnJlcGxhY2UoLyheW1xcc10rfFtcXHNdKyQpL2csICcnKTtcbiAgfVxuICByZXR1cm4gW2VyckNsYXNzLCBlcnJNc2ddO1xufVxuXG4vLyAqIFByZWZlcnMgYW55IHZhbHVlIG92ZXIgYW4gZW1wdHkgc3RyaW5nXG4vLyAqIFByZWZlcnMgYW55IHZhbHVlIG92ZXIgJ0Vycm9yJyB3aGVyZSBwb3NzaWJsZVxuLy8gKiBQcmVmZXJzIG5hbWUgb3ZlciBjb25zdHJ1Y3Rvci5uYW1lIHdoZW4gYm90aCBhcmUgbW9yZSBzcGVjaWZpYyB0aGFuICdFcnJvcidcbmZ1bmN0aW9uIF9tb3N0U3BlY2lmaWNFcnJvck5hbWUoZXJyb3IpIHtcbiAgdmFyIG5hbWUgPSBlcnJvci5uYW1lICYmIGVycm9yLm5hbWUubGVuZ3RoICYmIGVycm9yLm5hbWU7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPVxuICAgIGVycm9yLmNvbnN0cnVjdG9yLm5hbWUgJiZcbiAgICBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lLmxlbmd0aCAmJlxuICAgIGVycm9yLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgaWYgKCFuYW1lIHx8ICFjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSB8fCBjb25zdHJ1Y3Rvck5hbWU7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ0Vycm9yJykge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWU7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBndWVzc0Z1bmN0aW9uTmFtZTogZ3Vlc3NGdW5jdGlvbk5hbWUsXG4gIGd1ZXNzRXJyb3JDbGFzczogZ3Vlc3NFcnJvckNsYXNzLFxuICBnYXRoZXJDb250ZXh0OiBnYXRoZXJDb250ZXh0LFxuICBwYXJzZTogcGFyc2UsXG4gIFN0YWNrOiBTdGFjayxcbiAgRnJhbWU6IEZyYW1lLFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd24uY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xuICB2YXIgaGFzSXNQcm90b3R5cGVPZiA9XG4gICAgb2JqLmNvbnN0cnVjdG9yICYmXG4gICAgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSAmJlxuICAgIGhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG4gIC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3RcbiAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duQ29uc3RydWN0b3IgJiYgIWhhc0lzUHJvdG90eXBlT2YpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcbiAgLy8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIC8qKi9cbiAgfVxuXG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG59O1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgdmFyIGksXG4gICAgc3JjLFxuICAgIGNvcHksXG4gICAgY2xvbmUsXG4gICAgbmFtZSxcbiAgICByZXN1bHQgPSB7fSxcbiAgICBjdXJyZW50ID0gbnVsbCxcbiAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGN1cnJlbnQgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChuYW1lIGluIGN1cnJlbnQpIHtcbiAgICAgIHNyYyA9IHJlc3VsdFtuYW1lXTtcbiAgICAgIGNvcHkgPSBjdXJyZW50W25hbWVdO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gY29weSkge1xuICAgICAgICBpZiAoY29weSAmJiBpc1BsYWluT2JqZWN0KGNvcHkpKSB7XG4gICAgICAgICAgY2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gbWVyZ2UoY2xvbmUsIGNvcHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb3B5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IGNvcHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG5cbi8qXG4gKiBOb3RpZmllciAtIHRoZSBpbnRlcm5hbCBvYmplY3QgcmVzcG9uc2libGUgZm9yIGRlbGVnYXRpbmcgYmV0d2VlbiB0aGUgY2xpZW50IGV4cG9zZWQgQVBJLCB0aGVcbiAqIGNoYWluIG9mIHRyYW5zZm9ybXMgbmVjZXNzYXJ5IHRvIHR1cm4gYW4gaXRlbSBpbnRvIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBzZW50IHRvIFJvbGxiYXIsIGFuZCB0aGVcbiAqIHF1ZXVlIHdoaWNoIGhhbmRsZXMgdGhlIGNvbW11bmNhdGlvbiB3aXRoIHRoZSBSb2xsYmFyIEFQSSBzZXJ2ZXJzLlxuICpcbiAqIEBwYXJhbSBxdWV1ZSAtIGFuIG9iamVjdCB0aGF0IGNvbmZvcm1zIHRvIHRoZSBpbnRlcmZhY2U6IGFkZEl0ZW0oaXRlbSwgY2FsbGJhY2spXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG9wdGlvbnMgdG8gYmUgc2V0IGZvciB0aGlzIG5vdGlmaWVyLCB0aGlzIHNob3VsZCBoYXZlXG4gKiBhbnkgZGVmYXVsdHMgYWxyZWFkeSBzZXQgYnkgdGhlIGNhbGxlclxuICovXG5mdW5jdGlvbiBOb3RpZmllcihxdWV1ZSwgb3B0aW9ucykge1xuICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLmRpYWdub3N0aWMgPSB7fTtcbn1cblxuLypcbiAqIGNvbmZpZ3VyZSAtIHVwZGF0ZXMgdGhlIG9wdGlvbnMgZm9yIHRoaXMgbm90aWZpZXIgd2l0aCB0aGUgcGFzc2VkIGluIG9iamVjdFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gYW4gb2JqZWN0IHdoaWNoIGdldHMgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgb3B0aW9ucyBzZXQgb24gdGhpcyBub3RpZmllclxuICogQHJldHVybnMgdGhpc1xuICovXG5Ob3RpZmllci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdGhpcy5xdWV1ZSAmJiB0aGlzLnF1ZXVlLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob2xkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIGFkZFRyYW5zZm9ybSAtIGFkZHMgYSB0cmFuc2Zvcm0gb250byB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBvZiB0cmFuc2Zvcm1zIGZvciB0aGlzIG5vdGlmaWVyXG4gKlxuICogQHBhcmFtIHRyYW5zZm9ybSAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhyZWUgYXJndW1lbnRzOlxuICogICAgKiBpdGVtOiBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIHRvIGV2ZW50dWFsbHkgYmUgc2VudCB0byBSb2xsYmFyXG4gKiAgICAqIG9wdGlvbnM6IFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBvcHRpb25zIGZvciB0aGlzIG5vdGlmaWVyXG4gKiAgICAqIGNhbGxiYWNrOiBmdW5jdGlvbihlcnI6IChOdWxsfEVycm9yKSwgaXRlbTogKE51bGx8T2JqZWN0KSkgdGhlIHRyYW5zZm9ybSBtdXN0IGNhbGwgdGhpc1xuICogICAgY2FsbGJhY2sgd2l0aCBhIG51bGwgdmFsdWUgZm9yIGVycm9yIGlmIGl0IHdhbnRzIHRoZSBwcm9jZXNzaW5nIGNoYWluIHRvIGNvbnRpbnVlLCBvdGhlcndpc2VcbiAqICAgIHdpdGggYW4gZXJyb3IgdG8gdGVybWluYXRlIHRoZSBwcm9jZXNzaW5nLiBUaGUgaXRlbSBzaG91bGQgYmUgdGhlIHVwZGF0ZWQgaXRlbSBhZnRlciB0aGlzXG4gKiAgICB0cmFuc2Zvcm0gaXMgZmluaXNoZWQgbW9kaWZ5aW5nIGl0LlxuICovXG5Ob3RpZmllci5wcm90b3R5cGUuYWRkVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICBpZiAoXy5pc0Z1bmN0aW9uKHRyYW5zZm9ybSkpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIGxvZyAtIHRoZSBpbnRlcm5hbCBsb2cgZnVuY3Rpb24gd2hpY2ggYXBwbGllcyB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm1zIGFuZCB0aGVuIHB1c2hlcyBvbnRvIHRoZVxuICogcXVldWUgdG8gYmUgc2VudCB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICogICAgbWVzc2FnZSBbU3RyaW5nXSAtIEFuIG9wdGlvbmFsIHN0cmluZyB0byBiZSBzZW50IHRvIHJvbGxiYXJcbiAqICAgIGVycm9yIFtFcnJvcl0gLSBBbiBvcHRpb25hbCBlcnJvclxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gb2YgdHlwZSBmdW5jdGlvbihlcnIsIHJlc3ApIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggZXhhY3RseSBvbmVcbiAqIG51bGwgYXJndW1lbnQgYW5kIG9uZSBub24tbnVsbCBhcmd1bWVudC4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uY2UsIGVpdGhlciBkdXJpbmcgdGhlXG4gKiB0cmFuc2Zvcm0gc3RhZ2UgaWYgYW4gZXJyb3Igb2NjdXJzIGluc2lkZSBhIHRyYW5zZm9ybSwgb3IgaW4gcmVzcG9uc2UgdG8gdGhlIGNvbW11bmljYXRpb24gd2l0aFxuICogdGhlIGJhY2tlbmQuIFRoZSBzZWNvbmQgYXJndW1lbnQgd2lsbCBiZSB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgYmFja2VuZCBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayB8fCAhXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gIH1cblxuICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignUm9sbGJhciBpcyBub3QgZW5hYmxlZCcpKTtcbiAgfVxuXG4gIHRoaXMucXVldWUuYWRkUGVuZGluZ0l0ZW0oaXRlbSk7XG4gIHZhciBvcmlnaW5hbEVycm9yID0gaXRlbS5lcnI7XG4gIHRoaXMuX2FwcGx5VHJhbnNmb3JtcyhcbiAgICBpdGVtLFxuICAgIGZ1bmN0aW9uIChlcnIsIGkpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmVQZW5kaW5nSXRlbShpdGVtKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnF1ZXVlLmFkZEl0ZW0oaSwgY2FsbGJhY2ssIG9yaWdpbmFsRXJyb3IsIGl0ZW0pO1xuICAgIH0uYmluZCh0aGlzKSxcbiAgKTtcbn07XG5cbi8qIEludGVybmFsICovXG5cbi8qXG4gKiBfYXBwbHlUcmFuc2Zvcm1zIC0gQXBwbGllcyB0aGUgdHJhbnNmb3JtcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIG5vdGlmaWVyIHNlcXVlbnRpYWxseS4gU2VlXG4gKiBgYWRkVHJhbnNmb3JtYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIEFuIGl0ZW0gdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gb2YgdHlwZSBmdW5jdGlvbihlcnIsIGl0ZW0pIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBub24tbnVsbFxuICogZXJyb3IgYW5kIGEgbnVsbCBpdGVtIGluIHRoZSBjYXNlIG9mIGEgdHJhbnNmb3JtIGZhaWx1cmUsIG9yIGEgbnVsbCBlcnJvciBhbmQgbm9uLW51bGwgaXRlbSBhZnRlclxuICogYWxsIHRyYW5zZm9ybXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5fYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuc2Zvcm1JbmRleCA9IC0xO1xuICB2YXIgdHJhbnNmb3Jtc0xlbmd0aCA9IHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7XG4gIHZhciB0cmFuc2Zvcm1zID0gdGhpcy50cmFuc2Zvcm1zO1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICB2YXIgY2IgPSBmdW5jdGlvbiAoZXJyLCBpKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1JbmRleCsrO1xuXG4gICAgaWYgKHRyYW5zZm9ybUluZGV4ID09PSB0cmFuc2Zvcm1zTGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1zW3RyYW5zZm9ybUluZGV4XShpLCBvcHRpb25zLCBjYik7XG4gIH07XG5cbiAgY2IobnVsbCwgaXRlbSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vdGlmaWVyO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuZnVuY3Rpb24gY2hlY2tMZXZlbChpdGVtLCBzZXR0aW5ncykge1xuICB2YXIgbGV2ZWwgPSBpdGVtLmxldmVsO1xuICB2YXIgbGV2ZWxWYWwgPSBfLkxFVkVMU1tsZXZlbF0gfHwgMDtcbiAgdmFyIHJlcG9ydExldmVsID0gc2V0dGluZ3MucmVwb3J0TGV2ZWw7XG4gIHZhciByZXBvcnRMZXZlbFZhbCA9IF8uTEVWRUxTW3JlcG9ydExldmVsXSB8fCAwO1xuXG4gIGlmIChsZXZlbFZhbCA8IHJlcG9ydExldmVsVmFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB1c2VyQ2hlY2tJZ25vcmUobG9nZ2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgaXNVbmNhdWdodCA9ICEhaXRlbS5faXNVbmNhdWdodDtcbiAgICBkZWxldGUgaXRlbS5faXNVbmNhdWdodDtcbiAgICB2YXIgYXJncyA9IGl0ZW0uX29yaWdpbmFsQXJncztcbiAgICBkZWxldGUgaXRlbS5fb3JpZ2luYWxBcmdzO1xuICAgIHRyeSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHNldHRpbmdzLm9uU2VuZENhbGxiYWNrKSkge1xuICAgICAgICBzZXR0aW5ncy5vblNlbmRDYWxsYmFjayhpc1VuY2F1Z2h0LCBhcmdzLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZXR0aW5ncy5vblNlbmRDYWxsYmFjayA9IG51bGw7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIGNhbGxpbmcgb25TZW5kQ2FsbGJhY2ssIHJlbW92aW5nJywgZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoXG4gICAgICAgIF8uaXNGdW5jdGlvbihzZXR0aW5ncy5jaGVja0lnbm9yZSkgJiZcbiAgICAgICAgc2V0dGluZ3MuY2hlY2tJZ25vcmUoaXNVbmNhdWdodCwgYXJncywgaXRlbSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2V0dGluZ3MuY2hlY2tJZ25vcmUgPSBudWxsO1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBjYWxsaW5nIGN1c3RvbSBjaGVja0lnbm9yZSgpLCByZW1vdmluZycsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXJsSXNOb3RCbG9ja0xpc3RlZChsb2dnZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBzZXR0aW5ncykge1xuICAgIHJldHVybiAhdXJsSXNPbkFMaXN0KGl0ZW0sIHNldHRpbmdzLCAnYmxvY2tsaXN0JywgbG9nZ2VyKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXJsSXNTYWZlTGlzdGVkKGxvZ2dlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHVybElzT25BTGlzdChpdGVtLCBzZXR0aW5ncywgJ3NhZmVsaXN0JywgbG9nZ2VyKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hGcmFtZXModHJhY2UsIGxpc3QsIGJsb2NrKSB7XG4gIGlmICghdHJhY2UpIHtcbiAgICByZXR1cm4gIWJsb2NrO1xuICB9XG5cbiAgdmFyIGZyYW1lcyA9IHRyYWNlLmZyYW1lcztcblxuICBpZiAoIWZyYW1lcyB8fCBmcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICFibG9jaztcbiAgfVxuXG4gIHZhciBmcmFtZSwgZmlsZW5hbWUsIHVybCwgdXJsUmVnZXg7XG4gIHZhciBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciBmcmFtZUxlbmd0aCA9IGZyYW1lcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVMZW5ndGg7IGkrKykge1xuICAgIGZyYW1lID0gZnJhbWVzW2ldO1xuICAgIGZpbGVuYW1lID0gZnJhbWUuZmlsZW5hbWU7XG5cbiAgICBpZiAoIV8uaXNUeXBlKGZpbGVuYW1lLCAnc3RyaW5nJykpIHtcbiAgICAgIHJldHVybiAhYmxvY2s7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaXN0TGVuZ3RoOyBqKyspIHtcbiAgICAgIHVybCA9IGxpc3Rbal07XG4gICAgICB1cmxSZWdleCA9IG5ldyBSZWdFeHAodXJsKTtcblxuICAgICAgaWYgKHVybFJlZ2V4LnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHVybElzT25BTGlzdChpdGVtLCBzZXR0aW5ncywgc2FmZU9yQmxvY2ssIGxvZ2dlcikge1xuICAvLyBzYWZlbGlzdCBpcyB0aGUgZGVmYXVsdFxuICB2YXIgYmxvY2sgPSBmYWxzZTtcbiAgaWYgKHNhZmVPckJsb2NrID09PSAnYmxvY2tsaXN0Jykge1xuICAgIGJsb2NrID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsaXN0LCB0cmFjZXM7XG4gIHRyeSB7XG4gICAgbGlzdCA9IGJsb2NrID8gc2V0dGluZ3MuaG9zdEJsb2NrTGlzdCA6IHNldHRpbmdzLmhvc3RTYWZlTGlzdDtcbiAgICB0cmFjZXMgPSBfLmdldChpdGVtLCAnYm9keS50cmFjZV9jaGFpbicpIHx8IFtfLmdldChpdGVtLCAnYm9keS50cmFjZScpXTtcblxuICAgIC8vIFRoZXNlIHR3byBjaGVja3MgYXJlIGltcG9ydGFudCB0byBjb21lIGZpcnN0IGFzIHRoZXkgYXJlIGRlZmF1bHRzXG4gICAgLy8gaW4gY2FzZSB0aGUgbGlzdCBpcyBtaXNzaW5nIG9yIHRoZSB0cmFjZSBpcyBtaXNzaW5nIG9yIG5vdCB3ZWxsLWZvcm1lZFxuICAgIGlmICghbGlzdCB8fCBsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICFibG9jaztcbiAgICB9XG4gICAgaWYgKHRyYWNlcy5sZW5ndGggPT09IDAgfHwgIXRyYWNlc1swXSkge1xuICAgICAgcmV0dXJuICFibG9jaztcbiAgICB9XG5cbiAgICB2YXIgdHJhY2VzTGVuZ3RoID0gdHJhY2VzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWF0Y2hGcmFtZXModHJhY2VzW2ldLCBsaXN0LCBibG9jaykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChcbiAgICBlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKSB7XG4gICAgaWYgKGJsb2NrKSB7XG4gICAgICBzZXR0aW5ncy5ob3N0QmxvY2tMaXN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dGluZ3MuaG9zdFNhZmVMaXN0ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxpc3ROYW1lID0gYmxvY2sgPyAnaG9zdEJsb2NrTGlzdCcgOiAnaG9zdFNhZmVMaXN0JztcbiAgICBsb2dnZXIuZXJyb3IoXG4gICAgICBcIkVycm9yIHdoaWxlIHJlYWRpbmcgeW91ciBjb25maWd1cmF0aW9uJ3MgXCIgK1xuICAgICAgICBsaXN0TmFtZSArXG4gICAgICAgICcgb3B0aW9uLiBSZW1vdmluZyBjdXN0b20gJyArXG4gICAgICAgIGxpc3ROYW1lICtcbiAgICAgICAgJy4nLFxuICAgICAgZSxcbiAgICApO1xuICAgIHJldHVybiAhYmxvY2s7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZXNzYWdlSXNJZ25vcmVkKGxvZ2dlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIHNldHRpbmdzKSB7XG4gICAgdmFyIGksIGosIGlnbm9yZWRNZXNzYWdlcywgbGVuLCBtZXNzYWdlSXNJZ25vcmVkLCBySWdub3JlZE1lc3NhZ2UsIG1lc3NhZ2VzO1xuXG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2VJc0lnbm9yZWQgPSBmYWxzZTtcbiAgICAgIGlnbm9yZWRNZXNzYWdlcyA9IHNldHRpbmdzLmlnbm9yZWRNZXNzYWdlcztcblxuICAgICAgaWYgKCFpZ25vcmVkTWVzc2FnZXMgfHwgaWdub3JlZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlc0Zyb21JdGVtKGl0ZW0pO1xuXG4gICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsZW4gPSBpZ25vcmVkTWVzc2FnZXMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJJZ25vcmVkTWVzc2FnZSA9IG5ldyBSZWdFeHAoaWdub3JlZE1lc3NhZ2VzW2ldLCAnZ2knKTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbWVzc2FnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBtZXNzYWdlSXNJZ25vcmVkID0gcklnbm9yZWRNZXNzYWdlLnRlc3QobWVzc2FnZXNbal0pO1xuXG4gICAgICAgICAgaWYgKG1lc3NhZ2VJc0lnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChcbiAgICAgIGVcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgKSB7XG4gICAgICBzZXR0aW5ncy5pZ25vcmVkTWVzc2FnZXMgPSBudWxsO1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICBcIkVycm9yIHdoaWxlIHJlYWRpbmcgeW91ciBjb25maWd1cmF0aW9uJ3MgaWdub3JlZE1lc3NhZ2VzIG9wdGlvbi4gUmVtb3ZpbmcgY3VzdG9tIGlnbm9yZWRNZXNzYWdlcy5cIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lc3NhZ2VzRnJvbUl0ZW0oaXRlbSkge1xuICB2YXIgYm9keSA9IGl0ZW0uYm9keTtcbiAgdmFyIG1lc3NhZ2VzID0gW107XG5cbiAgLy8gVGhlIHBheWxvYWQgc2NoZW1hIG9ubHkgYWxsb3dzIG9uZSBvZiB0cmFjZV9jaGFpbiwgbWVzc2FnZSwgb3IgdHJhY2UuXG4gIC8vIEhvd2V2ZXIsIGV4aXN0aW5nIHRlc3QgY2FzZXMgYXJlIGJhc2VkIG9uIGhhdmluZyBib3RoIHRyYWNlIGFuZCBtZXNzYWdlIHByZXNlbnQuXG4gIC8vIFNvIGhlcmUgd2UgcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gY29sbGVjdCBzdHJpbmdzIGZyb20gYW55IGNvbWJpbmF0aW9uIG9mIHRoZXNlIGtleXMuXG4gIGlmIChib2R5LnRyYWNlX2NoYWluKSB7XG4gICAgdmFyIHRyYWNlQ2hhaW4gPSBib2R5LnRyYWNlX2NoYWluO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VDaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNlID0gdHJhY2VDaGFpbltpXTtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXy5nZXQodHJhY2UsICdleGNlcHRpb24ubWVzc2FnZScpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGJvZHkudHJhY2UpIHtcbiAgICBtZXNzYWdlcy5wdXNoKF8uZ2V0KGJvZHksICd0cmFjZS5leGNlcHRpb24ubWVzc2FnZScpKTtcbiAgfVxuICBpZiAoYm9keS5tZXNzYWdlKSB7XG4gICAgbWVzc2FnZXMucHVzaChfLmdldChib2R5LCAnbWVzc2FnZS5ib2R5JykpO1xuICB9XG4gIHJldHVybiBtZXNzYWdlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrTGV2ZWw6IGNoZWNrTGV2ZWwsXG4gIHVzZXJDaGVja0lnbm9yZTogdXNlckNoZWNrSWdub3JlLFxuICB1cmxJc05vdEJsb2NrTGlzdGVkOiB1cmxJc05vdEJsb2NrTGlzdGVkLFxuICB1cmxJc1NhZmVMaXN0ZWQ6IHVybElzU2FmZUxpc3RlZCxcbiAgbWVzc2FnZUlzSWdub3JlZDogbWVzc2FnZUlzSWdub3JlZCxcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xuXG4vKlxuICogUXVldWUgLSBhbiBvYmplY3Qgd2hpY2ggaGFuZGxlcyB3aGljaCBoYW5kbGVzIGEgcXVldWUgb2YgaXRlbXMgdG8gYmUgc2VudCB0byBSb2xsYmFyLlxuICogICBUaGlzIG9iamVjdCBoYW5kbGVzIHJhdGUgbGltaXRpbmcgdmlhIGEgcGFzc2VkIGluIHJhdGUgbGltaXRlciwgcmV0cmllcyBiYXNlZCBvbiBjb25uZWN0aW9uXG4gKiAgIGVycm9ycywgYW5kIGZpbHRlcmluZyBvZiBpdGVtcyBiYXNlZCBvbiBhIHNldCBvZiBjb25maWd1cmFibGUgcHJlZGljYXRlcy4gVGhlIGNvbW11bmljYXRpb24gdG9cbiAqICAgdGhlIGJhY2tlbmQgaXMgcGVyZm9ybWVkIHZpYSBhIGdpdmVuIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJhdGVMaW1pdGVyIC0gQW4gb2JqZWN0IHdoaWNoIGNvbmZvcm1zIHRvIHRoZSBpbnRlcmZhY2VcbiAqICAgIHJhdGVMaW1pdGVyLnNob3VsZFNlbmQoaXRlbSkgLT4gYm9vbFxuICogQHBhcmFtIGFwaSAtIEFuIG9iamVjdCB3aGljaCBjb25mb3JtcyB0byB0aGUgaW50ZXJmYWNlXG4gKiAgICBhcGkucG9zdEl0ZW0ocGF5bG9hZCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkpXG4gKiBAcGFyYW0gbG9nZ2VyIC0gQW4gb2JqZWN0IHVzZWQgdG8gbG9nIHZlcmJvc2UgbWVzc2FnZXMgaWYgZGVzaXJlZFxuICogQHBhcmFtIG9wdGlvbnMgLSBzZWUgUXVldWUucHJvdG90eXBlLmNvbmZpZ3VyZVxuICogQHBhcmFtIHJlcGxheU1hcCAtIE9wdGlvbmFsIFJlcGxheU1hcCBmb3IgY29vcmRpbmF0aW5nIHNlc3Npb24gcmVwbGF5IHdpdGggZXJyb3Igb2NjdXJyZW5jZXNcbiAqL1xuZnVuY3Rpb24gUXVldWUocmF0ZUxpbWl0ZXIsIGFwaSwgbG9nZ2VyLCBvcHRpb25zLCByZXBsYXlNYXApIHtcbiAgdGhpcy5yYXRlTGltaXRlciA9IHJhdGVMaW1pdGVyO1xuICB0aGlzLmFwaSA9IGFwaTtcbiAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucmVwbGF5TWFwID0gcmVwbGF5TWFwO1xuICB0aGlzLnByZWRpY2F0ZXMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nSXRlbXMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBbXTtcbiAgdGhpcy5yZXRyeVF1ZXVlID0gW107XG4gIHRoaXMucmV0cnlIYW5kbGUgPSBudWxsO1xuICB0aGlzLndhaXRDYWxsYmFjayA9IG51bGw7XG4gIHRoaXMud2FpdEludGVydmFsSUQgPSBudWxsO1xufVxuXG4vKlxuICogY29uZmlndXJlIC0gdXBkYXRlcyB0aGUgb3B0aW9ucyB0aGlzIHF1ZXVlIHVzZXNcbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5RdWV1ZS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdGhpcy5hcGkgJiYgdGhpcy5hcGkuY29uZmlndXJlKG9wdGlvbnMpO1xuICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvbGRPcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKlxuICogYWRkUHJlZGljYXRlIC0gYWRkcyBhIHByZWRpY2F0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIHByZWRpY2F0ZXMgZm9yIHRoaXMgcXVldWVcbiAqXG4gKiBAcGFyYW0gcHJlZGljYXRlIC0gZnVuY3Rpb24oaXRlbSwgb3B0aW9ucykgLT4gKGJvb2x8e2VycjogRXJyb3J9KVxuICogIFJldHVybmluZyB0cnVlIG1lYW5zIHRoYXQgdGhpcyBwcmVkaWNhdGUgcGFzc2VzIGFuZCB0aGUgaXRlbSBpcyBva2F5IHRvIGdvIG9uIHRoZSBxdWV1ZVxuICogIFJldHVybmluZyBmYWxzZSBtZWFucyBkbyBub3QgYWRkIHRoZSBpdGVtIHRvIHRoZSBxdWV1ZSwgYnV0IGl0IGlzIG5vdCBhbiBlcnJvclxuICogIFJldHVybmluZyB7ZXJyOiBFcnJvcn0gbWVhbnMgZG8gbm90IGFkZCB0aGUgaXRlbSB0byB0aGUgcXVldWUsIGFuZCB0aGUgZ2l2ZW4gZXJyb3IgZXhwbGFpbnMgd2h5XG4gKiAgUmV0dXJuaW5nIHtlcnI6IHVuZGVmaW5lZH0gaXMgZXF1aXZhbGVudCB0byByZXR1cm5pbmcgdHJ1ZSBidXQgZG9uJ3QgZG8gdGhhdFxuICovXG5RdWV1ZS5wcm90b3R5cGUuYWRkUHJlZGljYXRlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICBpZiAoXy5pc0Z1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICB0aGlzLnByZWRpY2F0ZXMucHVzaChwcmVkaWNhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUXVldWUucHJvdG90eXBlLmFkZFBlbmRpbmdJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdGhpcy5wZW5kaW5nSXRlbXMucHVzaChpdGVtKTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5yZW1vdmVQZW5kaW5nSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZHggPSB0aGlzLnBlbmRpbmdJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHRoaXMucGVuZGluZ0l0ZW1zLnNwbGljZShpZHgsIDEpO1xuICB9XG59O1xuXG4vKlxuICogYWRkSXRlbSAtIFNlbmQgYW4gaXRlbSB0byB0aGUgUm9sbGJhciBBUEkgaWYgYWxsIG9mIHRoZSBwcmVkaWNhdGVzIGFyZSBzYXRpc2ZpZWRcbiAqXG4gKiBAcGFyYW0gaXRlbSAtIFRoZSBwYXlsb2FkIHRvIHNlbmQgdG8gdGhlIGJhY2tlbmRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVycm9yLCByZXBzb25zZSkgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJXG4gKiAgaW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzLCBvdGhlcndpc2UgcmVzcG9uc2Ugd2lsbCBiZSBudWxsIGFuZCBlcnJvciB3aWxsIGhhdmUgYSB2YWx1ZS4gSWYgYm90aFxuICogIGVycm9yIGFuZCByZXNwb25zZSBhcmUgbnVsbCB0aGVuIHRoZSBpdGVtIHdhcyBzdG9wcGVkIGJ5IGEgcHJlZGljYXRlIHdoaWNoIGRpZCBub3QgY29uc2lkZXIgdGhpc1xuICogIHRvIGJlIGFuIGVycm9yIGNvbmRpdGlvbiwgYnV0IG5vbmV0aGVsZXNzIGRpZCBub3Qgc2VuZCB0aGUgaXRlbSB0byB0aGUgQVBJLlxuICogIEBwYXJhbSBvcmlnaW5hbEVycm9yIC0gVGhlIG9yaWdpbmFsIGVycm9yIGJlZm9yZSBhbnkgdHJhbnNmb3JtYXRpb25zIHRoYXQgaXMgdG8gYmUgbG9nZ2VkIGlmIGFueVxuICovXG5RdWV1ZS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uIChcbiAgaXRlbSxcbiAgY2FsbGJhY2ssXG4gIG9yaWdpbmFsRXJyb3IsXG4gIG9yaWdpbmFsSXRlbSxcbikge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICB2YXIgcHJlZGljYXRlUmVzdWx0ID0gdGhpcy5fYXBwbHlQcmVkaWNhdGVzKGl0ZW0pO1xuICBpZiAocHJlZGljYXRlUmVzdWx0LnN0b3ApIHtcbiAgICB0aGlzLnJlbW92ZVBlbmRpbmdJdGVtKG9yaWdpbmFsSXRlbSk7XG4gICAgY2FsbGJhY2socHJlZGljYXRlUmVzdWx0LmVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX21heWJlTG9nKGl0ZW0sIG9yaWdpbmFsRXJyb3IpO1xuICB0aGlzLnJlbW92ZVBlbmRpbmdJdGVtKG9yaWdpbmFsSXRlbSk7XG4gIGlmICghdGhpcy5vcHRpb25zLnRyYW5zbWl0KSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdUcmFuc21pdCBkaXNhYmxlZCcpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5yZXBsYXlNYXAgJiYgaXRlbS5ib2R5KSB7XG4gICAgY29uc3QgcmVwbGF5SWQgPSB0aGlzLnJlcGxheU1hcC5hZGQoaXRlbS51dWlkKTtcbiAgICBpdGVtLnJlcGxheUlkID0gcmVwbGF5SWQ7XG4gIH1cblxuICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5wdXNoKGl0ZW0pO1xuICB0cnkge1xuICAgIHRoaXMuX21ha2VBcGlSZXF1ZXN0KFxuICAgICAgaXRlbSxcbiAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgICAgdGhpcy5fZGVxdWV1ZVBlbmRpbmdSZXF1ZXN0KGl0ZW0pO1xuXG4gICAgICAgIGlmICghZXJyICYmIHJlc3AgJiYgaXRlbS5yZXBsYXlJZCkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVJlcGxheVJlc3BvbnNlKGl0ZW0ucmVwbGF5SWQsIHJlc3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5fZGVxdWV1ZVBlbmRpbmdSZXF1ZXN0KGl0ZW0pO1xuICAgIGNhbGxiYWNrKGUpO1xuICB9XG59O1xuXG4vKlxuICogd2FpdCAtIFN0b3AgYW55IGZ1cnRoZXIgZXJyb3JzIGZyb20gYmVpbmcgYWRkZWQgdG8gdGhlIHF1ZXVlLCBhbmQgZ2V0IGNhbGxlZCBiYWNrIHdoZW4gYWxsIGl0ZW1zXG4gKiAgIGN1cnJlbnRseSBwcm9jZXNzaW5nIGhhdmUgZmluaXNoZWQgc2VuZGluZyB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbigpIGNhbGxlZCB3aGVuIGFsbCBwZW5kaW5nIGl0ZW1zIGhhdmUgYmVlbiBzZW50XG4gKi9cblF1ZXVlLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLndhaXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICBpZiAodGhpcy5fbWF5YmVDYWxsV2FpdCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLndhaXRJbnRlcnZhbElEKSB7XG4gICAgdGhpcy53YWl0SW50ZXJ2YWxJRCA9IGNsZWFySW50ZXJ2YWwodGhpcy53YWl0SW50ZXJ2YWxJRCk7XG4gIH1cbiAgdGhpcy53YWl0SW50ZXJ2YWxJRCA9IHNldEludGVydmFsKFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX21heWJlQ2FsbFdhaXQoKTtcbiAgICB9LmJpbmQodGhpcyksXG4gICAgNTAwLFxuICApO1xufTtcblxuLyogX2FwcGx5UHJlZGljYXRlcyAtIFNlcXVlbnRpYWxseSBhcHBsaWVzIHRoZSBwcmVkaWNhdGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBxdWV1ZSB0byB0aGVcbiAqICAgZ2l2ZW4gaXRlbSB3aXRoIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gQW4gaXRlbSBpbiB0aGUgcXVldWVcbiAqIEByZXR1cm5zIHtzdG9wOiBib29sLCBlcnI6IChFcnJvcnxudWxsKX0gLSBzdG9wIGJlaW5nIHRydWUgbWVhbnMgZG8gbm90IGFkZCBpdGVtIHRvIHRoZSBxdWV1ZSxcbiAqICAgdGhlIGVycm9yIHZhbHVlIHNob3VsZCBiZSBwYXNzZWQgdXAgdG8gYSBjYWxsYmFrIGlmIHdlIGFyZSBzdG9wcGluZy5cbiAqL1xuUXVldWUucHJvdG90eXBlLl9hcHBseVByZWRpY2F0ZXMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgcCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnByZWRpY2F0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwID0gdGhpcy5wcmVkaWNhdGVzW2ldKGl0ZW0sIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKCFwIHx8IHAuZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7IHN0b3A6IHRydWUsIGVycjogcC5lcnIgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgc3RvcDogZmFsc2UsIGVycjogbnVsbCB9O1xufTtcblxuLypcbiAqIF9tYWtlQXBpUmVxdWVzdCAtIFNlbmQgYW4gaXRlbSB0byBSb2xsYmFyLCBjYWxsYmFjayB3aGVuIGRvbmUsIGlmIHRoZXJlIGlzIGFuIGVycm9yIG1ha2UgYW5cbiAqICAgZWZmb3J0IHRvIHJldHJ5IGlmIHdlIGFyZSBjb25maWd1cmVkIHRvIGRvIHNvLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gYW4gaXRlbSByZWFkeSB0byBzZW5kIHRvIHRoZSBiYWNrZW5kXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKVxuICovXG5RdWV1ZS5wcm90b3R5cGUuX21ha2VBcGlSZXF1ZXN0ID0gZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gIHZhciByYXRlTGltaXRSZXNwb25zZSA9IHRoaXMucmF0ZUxpbWl0ZXIuc2hvdWxkU2VuZChpdGVtKTtcbiAgaWYgKHJhdGVMaW1pdFJlc3BvbnNlLnNob3VsZFNlbmQpIHtcbiAgICB0aGlzLmFwaS5wb3N0SXRlbShcbiAgICAgIGl0ZW0sXG4gICAgICBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzLl9tYXliZVJldHJ5KGVyciwgaXRlbSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICApO1xuICB9IGVsc2UgaWYgKHJhdGVMaW1pdFJlc3BvbnNlLmVycm9yKSB7XG4gICAgY2FsbGJhY2socmF0ZUxpbWl0UmVzcG9uc2UuZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXBpLnBvc3RJdGVtKHJhdGVMaW1pdFJlc3BvbnNlLnBheWxvYWQsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLy8gVGhlc2UgYXJlIGVycm9ycyBiYXNpY2FsbHkgbWVhbiB0aGVyZSBpcyBubyBpbnRlcm5ldCBjb25uZWN0aW9uXG52YXIgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRU5PVEZPVU5EJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUNPTk5SRUZVU0VEJyxcbiAgJ0VIT1NUVU5SRUFDSCcsXG4gICdFUElQRScsXG4gICdFQUlfQUdBSU4nLFxuXTtcblxuLypcbiAqIF9tYXliZVJldHJ5IC0gR2l2ZW4gdGhlIGVycm9yIHJldHVybmVkIGJ5IHRoZSBBUEksIGRlY2lkZSBpZiB3ZSBzaG91bGQgcmV0cnkgb3IganVzdCBjYWxsYmFja1xuICogICB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyIC0gYW4gZXJyb3IgcmV0dXJuZWQgYnkgdGhlIEFQSSB0cmFuc3BvcnRcbiAqIEBwYXJhbSBpdGVtIC0gdGhlIGl0ZW0gdGhhdCB3YXMgdHJ5aW5nIHRvIGJlIHNlbnQgd2hlbiB0aGlzIGVycm9yIG9jY3VyZWRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fbWF5YmVSZXRyeSA9IGZ1bmN0aW9uIChlcnIsIGl0ZW0sIGNhbGxiYWNrKSB7XG4gIHZhciBzaG91bGRSZXRyeSA9IGZhbHNlO1xuICBpZiAodGhpcy5vcHRpb25zLnJldHJ5SW50ZXJ2YWwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gUkVUUklBQkxFX0VSUk9SUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGVyci5jb2RlID09PSBSRVRSSUFCTEVfRVJST1JTW2ldKSB7XG4gICAgICAgIHNob3VsZFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRSZXRyeSAmJiBfLmlzRmluaXRlTnVtYmVyKHRoaXMub3B0aW9ucy5tYXhSZXRyaWVzKSkge1xuICAgICAgaXRlbS5yZXRyaWVzID0gaXRlbS5yZXRyaWVzID8gaXRlbS5yZXRyaWVzICsgMSA6IDE7XG4gICAgICBpZiAoaXRlbS5yZXRyaWVzID4gdGhpcy5vcHRpb25zLm1heFJldHJpZXMpIHtcbiAgICAgICAgc2hvdWxkUmV0cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgdGhpcy5fcmV0cnlBcGlSZXF1ZXN0KGl0ZW0sIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG59O1xuXG4vKlxuICogX3JldHJ5QXBpUmVxdWVzdCAtIEFkZCBhbiBpdGVtIGFuZCBhIGNhbGxiYWNrIHRvIGEgcXVldWUgYW5kIHBvc3NpYmx5IHN0YXJ0IGEgdGltZXIgdG8gcHJvY2Vzc1xuICogICB0aGF0IHF1ZXVlIGJhc2VkIG9uIHRoZSByZXRyeUludGVydmFsIGluIHRoZSBvcHRpb25zIGZvciB0aGlzIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gYW4gaXRlbSB0aGF0IGZhaWxlZCB0byBzZW5kIGR1ZSB0byBhbiBlcnJvciB3ZSBkZWVtIHJldHJpYWJsZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gZnVuY3Rpb24oZXJyLCByZXNwb25zZSlcbiAqL1xuUXVldWUucHJvdG90eXBlLl9yZXRyeUFwaVJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgdGhpcy5yZXRyeVF1ZXVlLnB1c2goeyBpdGVtOiBpdGVtLCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG5cbiAgaWYgKCF0aGlzLnJldHJ5SGFuZGxlKSB7XG4gICAgdGhpcy5yZXRyeUhhbmRsZSA9IHNldEludGVydmFsKFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yZXRyeVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciByZXRyeU9iamVjdCA9IHRoaXMucmV0cnlRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuX21ha2VBcGlSZXF1ZXN0KHJldHJ5T2JqZWN0Lml0ZW0sIHJldHJ5T2JqZWN0LmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5vcHRpb25zLnJldHJ5SW50ZXJ2YWwsXG4gICAgKTtcbiAgfVxufTtcblxuLypcbiAqIF9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QgLSBSZW1vdmVzIHRoZSBpdGVtIGZyb20gdGhlIHBlbmRpbmcgcmVxdWVzdCBxdWV1ZSwgdGhpcyBxdWV1ZSBpcyB1c2VkIHRvXG4gKiAgIGVuYWJsZSB0byBmdW5jdGlvbmFsaXR5IG9mIHByb3ZpZGluZyBhIGNhbGxiYWNrIHRoYXQgY2xpZW50cyBjYW4gcGFzcyB0byBgd2FpdGAgdG8gYmUgbm90aWZpZWRcbiAqICAgd2hlbiB0aGUgcGVuZGluZyByZXF1ZXN0IHF1ZXVlIGhhcyBiZWVuIGVtcHRpZWQuIFRoaXMgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgQVBJIGZpbmlzaGVzXG4gKiAgIHByb2Nlc3NpbmcgdGhpcyBpdGVtLiBJZiBhIGB3YWl0YCBjYWxsYmFjayBpcyBjb25maWd1cmVkLCBpdCBpcyBjYWxsZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIHByZXZpb3VzbHkgYWRkZWQgdG8gdGhlIHBlbmRpbmcgcmVxdWVzdCBxdWV1ZVxuICovXG5RdWV1ZS5wcm90b3R5cGUuX2RlcXVldWVQZW5kaW5nUmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZHggPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX21heWJlQ2FsbFdhaXQoKTtcbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLl9tYXliZUxvZyA9IGZ1bmN0aW9uIChkYXRhLCBvcmlnaW5hbEVycm9yKSB7XG4gIGlmICh0aGlzLmxvZ2dlciAmJiB0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgIHZhciBtZXNzYWdlID0gb3JpZ2luYWxFcnJvcjtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBfLmdldChkYXRhLCAnYm9keS50cmFjZS5leGNlcHRpb24ubWVzc2FnZScpO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IF8uZ2V0KGRhdGEsICdib2R5LnRyYWNlX2NoYWluLjAuZXhjZXB0aW9uLm1lc3NhZ2UnKTtcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBfLmdldChkYXRhLCAnYm9keS5tZXNzYWdlLmJvZHknKTtcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLl9tYXliZUNhbGxXYWl0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoXG4gICAgXy5pc0Z1bmN0aW9uKHRoaXMud2FpdENhbGxiYWNrKSAmJlxuICAgIHRoaXMucGVuZGluZ0l0ZW1zLmxlbmd0aCA9PT0gMCAmJlxuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICBpZiAodGhpcy53YWl0SW50ZXJ2YWxJRCkge1xuICAgICAgdGhpcy53YWl0SW50ZXJ2YWxJRCA9IGNsZWFySW50ZXJ2YWwodGhpcy53YWl0SW50ZXJ2YWxJRCk7XG4gICAgfVxuICAgIHRoaXMud2FpdENhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBBUEkgcmVzcG9uc2UgZm9yIGFuIGl0ZW0gd2l0aCBhIHJlcGxheSBJRC5cbiAqIEJhc2VkIG9uIHRoZSBzdWNjZXNzIG9yIGZhaWx1cmUgc3RhdHVzIG9mIHRoZSByZXNwb25zZSxcbiAqIGl0IGVpdGhlciBzZW5kcyBvciBkaXNjYXJkcyB0aGUgYXNzb2NpYXRlZCBzZXNzaW9uIHJlcGxheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBUaGUgSUQgb2YgdGhlIHJlcGxheSB0byBoYW5kbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIFRoZSBBUEkgcmVzcG9uc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHJlcGxheSB3YXMgc2VudCBzdWNjZXNzZnVsbHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UgaWYgcmVwbGF5IHdhcyBkaXNjYXJkZWQgb3IgYW4gZXJyb3Igb2NjdXJyZWRcbiAqIEBwcml2YXRlXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5faGFuZGxlUmVwbGF5UmVzcG9uc2UgPSBhc3luYyBmdW5jdGlvbiAocmVwbGF5SWQsIHJlc3BvbnNlKSB7XG4gIGlmICghdGhpcy5yZXBsYXlNYXApIHtcbiAgICBjb25zb2xlLndhcm4oJ1F1ZXVlLl9oYW5kbGVSZXBsYXlSZXNwb25zZTogUmVwbGF5TWFwIG5vdCBhdmFpbGFibGUnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXJlcGxheUlkKSB7XG4gICAgY29uc29sZS53YXJuKCdRdWV1ZS5faGFuZGxlUmVwbGF5UmVzcG9uc2U6IE5vIHJlcGxheUlkIHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBTdWNjZXNzIGNvbmRpdGlvbiBtaWdodCBuZWVkIGFkanVzdG1lbnQgYmFzZWQgb24gQVBJIHJlc3BvbnNlIHN0cnVjdHVyZVxuICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5lcnIgPT09IDApIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVwbGF5TWFwLnNlbmQocmVwbGF5SWQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXBsYXlNYXAuZGlzY2FyZChyZXBsYXlJZCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhhbmRsaW5nIHJlcGxheSByZXNwb25zZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuLypcbiAqIFJhdGVMaW1pdGVyIC0gYW4gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBmb3IgY291bnRpbmcgaXRlbXMgc2VudCB0byBSb2xsYmFyXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgc2FtZSBvcHRpb25zIHRoYXQgYXJlIGFjY2VwdGVkIGJ5IGNvbmZpZ3VyZUdsb2JhbCBvZmZlcmVkIGFzIGEgY29udmVuaWVuY2VcbiAqL1xuZnVuY3Rpb24gUmF0ZUxpbWl0ZXIob3B0aW9ucykge1xuICB0aGlzLnN0YXJ0VGltZSA9IF8ubm93KCk7XG4gIHRoaXMuY291bnRlciA9IDA7XG4gIHRoaXMucGVyTWluQ291bnRlciA9IDA7XG4gIHRoaXMucGxhdGZvcm0gPSBudWxsO1xuICB0aGlzLnBsYXRmb3JtT3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZUdsb2JhbChvcHRpb25zKTtcbn1cblxuUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3MgPSB7XG4gIHN0YXJ0VGltZTogXy5ub3coKSxcbiAgbWF4SXRlbXM6IHVuZGVmaW5lZCxcbiAgaXRlbXNQZXJNaW51dGU6IHVuZGVmaW5lZCxcbn07XG5cbi8qXG4gKiBjb25maWd1cmVHbG9iYWwgLSBzZXQgdGhlIGdsb2JhbCByYXRlIGxpbWl0ZXIgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT25seSB0aGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgcmVjb2duaXplZDpcbiAqICAgIHN0YXJ0VGltZTogYSB0aW1lc3RhbXAgb2YgdGhlIGZvcm0gcmV0dXJuZWQgYnkgKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuICogICAgbWF4SXRlbXM6IHRoZSBtYXhpbXVtIGl0ZW1zXG4gKiAgICBpdGVtc1Blck1pbnV0ZTogdGhlIG1heCBudW1iZXIgb2YgaXRlbXMgdG8gc2VuZCBpbiBhIGdpdmVuIG1pbnV0ZVxuICovXG5SYXRlTGltaXRlci5wcm90b3R5cGUuY29uZmlndXJlR2xvYmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5zdGFydFRpbWUgPSBvcHRpb25zLnN0YXJ0VGltZTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3MubWF4SXRlbXMgPSBvcHRpb25zLm1heEl0ZW1zO1xuICB9XG4gIGlmIChvcHRpb25zLml0ZW1zUGVyTWludXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5pdGVtc1Blck1pbnV0ZSA9IG9wdGlvbnMuaXRlbXNQZXJNaW51dGU7XG4gIH1cbn07XG5cbi8qXG4gKiBzaG91bGRTZW5kIC0gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBzZW5kIGEgZ2l2ZW4gaXRlbSBiYXNlZCBvbiByYXRlIGxpbWl0IHNldHRpbmdzXG4gKlxuICogQHBhcmFtIGl0ZW0gLSB0aGUgaXRlbSB3ZSBhcmUgYWJvdXQgdG8gc2VuZFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKiAgZXJyb3I6IChFcnJvcnxudWxsKVxuICogIHNob3VsZFNlbmQ6IGJvb2xcbiAqICBwYXlsb2FkOiAoT2JqZWN0fG51bGwpXG4gKiAgSWYgc2hvdWxkU2VuZCBpcyBmYWxzZSwgdGhlIGl0ZW0gcGFzc2VkIGFzIGEgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgc2VudCB0byBSb2xsYmFyLCBhbmRcbiAqICBleGFjdGx5IG9uZSBvZiBlcnJvciBvciBwYXlsb2FkIHdpbGwgYmUgbm9uLW51bGwuIElmIGVycm9yIGlzIG5vbi1udWxsLCB0aGUgcmV0dXJuZWQgRXJyb3Igd2lsbFxuICogIGRlc2NyaWJlIHRoZSBzaXR1YXRpb24sIGJ1dCBpdCBtZWFucyB0aGF0IHdlIHdlcmUgYWxyZWFkeSBvdmVyIGEgcmF0ZSBsaW1pdCAoZWl0aGVyIGdsb2JhbGx5IG9yXG4gKiAgcGVyIG1pbnV0ZSkgd2hlbiB0aGlzIGl0ZW0gd2FzIGNoZWNrZWQuIElmIGVycm9yIGlzIG51bGwsIGFuZCB0aGVyZWZvcmUgcGF5bG9hZCBpcyBub24tbnVsbCwgaXRcbiAqICBtZWFucyB0aGlzIGl0ZW0gcHV0IHVzIG92ZXIgdGhlIGdsb2JhbCByYXRlIGxpbWl0IGFuZCB0aGUgcGF5bG9hZCBzaG91bGQgYmUgc2VudCB0byBSb2xsYmFyIGluXG4gKiAgcGxhY2Ugb2YgdGhlIHBhc3NlZCBpbiBpdGVtLlxuICovXG5SYXRlTGltaXRlci5wcm90b3R5cGUuc2hvdWxkU2VuZCA9IGZ1bmN0aW9uIChpdGVtLCBub3cpIHtcbiAgbm93ID0gbm93IHx8IF8ubm93KCk7XG4gIHZhciBlbGFwc2VkVGltZSA9IG5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuICBpZiAoZWxhcHNlZFRpbWUgPCAwIHx8IGVsYXBzZWRUaW1lID49IDYwMDAwKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBub3c7XG4gICAgdGhpcy5wZXJNaW5Db3VudGVyID0gMDtcbiAgfVxuXG4gIHZhciBnbG9iYWxSYXRlTGltaXQgPSBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5tYXhJdGVtcztcbiAgdmFyIGdsb2JhbFJhdGVMaW1pdFBlck1pbiA9IFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzLml0ZW1zUGVyTWludXRlO1xuXG4gIGlmIChjaGVja1JhdGUoaXRlbSwgZ2xvYmFsUmF0ZUxpbWl0LCB0aGlzLmNvdW50ZXIpKSB7XG4gICAgcmV0dXJuIHNob3VsZFNlbmRWYWx1ZShcbiAgICAgIHRoaXMucGxhdGZvcm0sXG4gICAgICB0aGlzLnBsYXRmb3JtT3B0aW9ucyxcbiAgICAgIGdsb2JhbFJhdGVMaW1pdCArICcgbWF4IGl0ZW1zIHJlYWNoZWQnLFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgfSBlbHNlIGlmIChjaGVja1JhdGUoaXRlbSwgZ2xvYmFsUmF0ZUxpbWl0UGVyTWluLCB0aGlzLnBlck1pbkNvdW50ZXIpKSB7XG4gICAgcmV0dXJuIHNob3VsZFNlbmRWYWx1ZShcbiAgICAgIHRoaXMucGxhdGZvcm0sXG4gICAgICB0aGlzLnBsYXRmb3JtT3B0aW9ucyxcbiAgICAgIGdsb2JhbFJhdGVMaW1pdFBlck1pbiArICcgaXRlbXMgcGVyIG1pbnV0ZSByZWFjaGVkJyxcbiAgICAgIGZhbHNlLFxuICAgICk7XG4gIH1cbiAgdGhpcy5jb3VudGVyKys7XG4gIHRoaXMucGVyTWluQ291bnRlcisrO1xuXG4gIHZhciBzaG91bGRTZW5kID0gIWNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXQsIHRoaXMuY291bnRlcik7XG4gIHZhciBwZXJNaW51dGUgPSBzaG91bGRTZW5kO1xuICBzaG91bGRTZW5kID1cbiAgICBzaG91bGRTZW5kICYmICFjaGVja1JhdGUoaXRlbSwgZ2xvYmFsUmF0ZUxpbWl0UGVyTWluLCB0aGlzLnBlck1pbkNvdW50ZXIpO1xuICByZXR1cm4gc2hvdWxkU2VuZFZhbHVlKFxuICAgIHRoaXMucGxhdGZvcm0sXG4gICAgdGhpcy5wbGF0Zm9ybU9wdGlvbnMsXG4gICAgbnVsbCxcbiAgICBzaG91bGRTZW5kLFxuICAgIGdsb2JhbFJhdGVMaW1pdCxcbiAgICBnbG9iYWxSYXRlTGltaXRQZXJNaW4sXG4gICAgcGVyTWludXRlLFxuICApO1xufTtcblxuUmF0ZUxpbWl0ZXIucHJvdG90eXBlLnNldFBsYXRmb3JtT3B0aW9ucyA9IGZ1bmN0aW9uIChwbGF0Zm9ybSwgb3B0aW9ucykge1xuICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gIHRoaXMucGxhdGZvcm1PcHRpb25zID0gb3B0aW9ucztcbn07XG5cbi8qIEhlbHBlcnMgKi9cblxuZnVuY3Rpb24gY2hlY2tSYXRlKGl0ZW0sIGxpbWl0LCBjb3VudGVyKSB7XG4gIHJldHVybiAhaXRlbS5pZ25vcmVSYXRlTGltaXQgJiYgbGltaXQgPj0gMSAmJiBjb3VudGVyID4gbGltaXQ7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFNlbmRWYWx1ZShcbiAgcGxhdGZvcm0sXG4gIG9wdGlvbnMsXG4gIGVycm9yLFxuICBzaG91bGRTZW5kLFxuICBnbG9iYWxSYXRlTGltaXQsXG4gIGxpbWl0UGVyTWluLFxuICBwZXJNaW51dGUsXG4pIHtcbiAgdmFyIHBheWxvYWQgPSBudWxsO1xuICBpZiAoZXJyb3IpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgaWYgKCFlcnJvciAmJiAhc2hvdWxkU2VuZCkge1xuICAgIHBheWxvYWQgPSByYXRlTGltaXRQYXlsb2FkKFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBvcHRpb25zLFxuICAgICAgZ2xvYmFsUmF0ZUxpbWl0LFxuICAgICAgbGltaXRQZXJNaW4sXG4gICAgICBwZXJNaW51dGUsXG4gICAgKTtcbiAgfVxuICByZXR1cm4geyBlcnJvcjogZXJyb3IsIHNob3VsZFNlbmQ6IHNob3VsZFNlbmQsIHBheWxvYWQ6IHBheWxvYWQgfTtcbn1cblxuZnVuY3Rpb24gcmF0ZUxpbWl0UGF5bG9hZChcbiAgcGxhdGZvcm0sXG4gIG9wdGlvbnMsXG4gIGdsb2JhbFJhdGVMaW1pdCxcbiAgbGltaXRQZXJNaW4sXG4gIHBlck1pbnV0ZSxcbikge1xuICB2YXIgZW52aXJvbm1lbnQgPVxuICAgIG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgKG9wdGlvbnMucGF5bG9hZCAmJiBvcHRpb25zLnBheWxvYWQuZW52aXJvbm1lbnQpO1xuICB2YXIgbXNnO1xuICBpZiAocGVyTWludXRlKSB7XG4gICAgbXNnID0gJ2l0ZW0gcGVyIG1pbnV0ZSBsaW1pdCByZWFjaGVkLCBpZ25vcmluZyBlcnJvcnMgdW50aWwgdGltZW91dCc7XG4gIH0gZWxzZSB7XG4gICAgbXNnID0gJ21heEl0ZW1zIGhhcyBiZWVuIGhpdCwgaWdub3JpbmcgZXJyb3JzIHVudGlsIHJlc2V0Lic7XG4gIH1cbiAgdmFyIGl0ZW0gPSB7XG4gICAgYm9keToge1xuICAgICAgbWVzc2FnZToge1xuICAgICAgICBib2R5OiBtc2csXG4gICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgbWF4SXRlbXM6IGdsb2JhbFJhdGVMaW1pdCxcbiAgICAgICAgICBpdGVtc1Blck1pbnV0ZTogbGltaXRQZXJNaW4sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgbGFuZ3VhZ2U6ICdqYXZhc2NyaXB0JyxcbiAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgbm90aWZpZXI6IHtcbiAgICAgIHZlcnNpb246XG4gICAgICAgIChvcHRpb25zLm5vdGlmaWVyICYmIG9wdGlvbnMubm90aWZpZXIudmVyc2lvbikgfHwgb3B0aW9ucy52ZXJzaW9uLFxuICAgIH0sXG4gIH07XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgaXRlbS5wbGF0Zm9ybSA9ICdicm93c2VyJztcbiAgICBpdGVtLmZyYW1ld29yayA9ICdicm93c2VyLWpzJztcbiAgICBpdGVtLm5vdGlmaWVyLm5hbWUgPSAncm9sbGJhci1icm93c2VyLWpzJztcbiAgfSBlbHNlIGlmIChwbGF0Zm9ybSA9PT0gJ3NlcnZlcicpIHtcbiAgICBpdGVtLmZyYW1ld29yayA9IG9wdGlvbnMuZnJhbWV3b3JrIHx8ICdub2RlLWpzJztcbiAgICBpdGVtLm5vdGlmaWVyLm5hbWUgPSBvcHRpb25zLm5vdGlmaWVyLm5hbWU7XG4gIH0gZWxzZSBpZiAocGxhdGZvcm0gPT09ICdyZWFjdC1uYXRpdmUnKSB7XG4gICAgaXRlbS5mcmFtZXdvcmsgPSBvcHRpb25zLmZyYW1ld29yayB8fCAncmVhY3QtbmF0aXZlJztcbiAgICBpdGVtLm5vdGlmaWVyLm5hbWUgPSBvcHRpb25zLm5vdGlmaWVyLm5hbWU7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmF0ZUxpbWl0ZXI7XG4iLCJjb25zdCBSYXRlTGltaXRlciA9IHJlcXVpcmUoJy4vcmF0ZUxpbWl0ZXInKTtcbmNvbnN0IFF1ZXVlID0gcmVxdWlyZSgnLi9xdWV1ZScpO1xuY29uc3QgTm90aWZpZXIgPSByZXF1aXJlKCcuL25vdGlmaWVyJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG5cbi8qXG4gKiBSb2xsYmFyIC0gdGhlIGludGVyZmFjZSB0byBSb2xsYmFyXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBhcGlcbiAqIEBwYXJhbSBsb2dnZXJcbiAqL1xuZnVuY3Rpb24gUm9sbGJhcihvcHRpb25zLCBhcGksIGxvZ2dlciwgdGVsZW1ldGVyLCB0cmFjaW5nLCByZXBsYXlNYXAsIHBsYXRmb3JtKSB7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob3B0aW9ucyk7XG4gIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICBSb2xsYmFyLnJhdGVMaW1pdGVyLmNvbmZpZ3VyZUdsb2JhbCh0aGlzLm9wdGlvbnMpO1xuICBSb2xsYmFyLnJhdGVMaW1pdGVyLnNldFBsYXRmb3JtT3B0aW9ucyhwbGF0Zm9ybSwgdGhpcy5vcHRpb25zKTtcbiAgdGhpcy5hcGkgPSBhcGk7XG4gIHRoaXMucXVldWUgPSBuZXcgUXVldWUoUm9sbGJhci5yYXRlTGltaXRlciwgYXBpLCBsb2dnZXIsIHRoaXMub3B0aW9ucywgcmVwbGF5TWFwKTtcblxuICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuXG4gIC8vIExlZ2FjeSBPcGVuVHJhY2luZyBzdXBwb3J0XG4gIC8vIFRoaXMgbXVzdCBoYXBwZW4gYmVmb3JlIHRoZSBOb3RpZmllciBpcyBjcmVhdGVkXG4gIHZhciB0cmFjZXIgPSB0aGlzLm9wdGlvbnMudHJhY2VyIHx8IG51bGw7XG4gIGlmICh2YWxpZGF0ZVRyYWNlcih0cmFjZXIpKSB7XG4gICAgdGhpcy50cmFjZXIgPSB0cmFjZXI7XG4gICAgLy8gc2V0IHRvIGEgc3RyaW5nIGZvciBhcGkgcmVzcG9uc2Ugc2VyaWFsaXphdGlvblxuICAgIHRoaXMub3B0aW9ucy50cmFjZXIgPSAnb3BlbnRyYWNpbmctdHJhY2VyLWVuYWJsZWQnO1xuICAgIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMudHJhY2VyID0gJ29wZW50cmFjaW5nLXRyYWNlci1lbmFibGVkJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYWNlciA9IG51bGw7XG4gIH1cblxuICB0aGlzLm5vdGlmaWVyID0gbmV3IE5vdGlmaWVyKHRoaXMucXVldWUsIHRoaXMub3B0aW9ucyk7XG4gIHRoaXMudGVsZW1ldGVyID0gdGVsZW1ldGVyO1xuICBzZXRTdGFja1RyYWNlTGltaXQob3B0aW9ucyk7XG4gIHRoaXMubGFzdEVycm9yID0gbnVsbDtcbiAgdGhpcy5sYXN0RXJyb3JIYXNoID0gJ25vbmUnO1xufVxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG1heEl0ZW1zOiAwLFxuICBpdGVtc1Blck1pbnV0ZTogNjAsXG59O1xuXG5Sb2xsYmFyLnJhdGVMaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyKGRlZmF1bHRPcHRpb25zKTtcblxuUm9sbGJhci5wcm90b3R5cGUuZ2xvYmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgUm9sbGJhci5yYXRlTGltaXRlci5jb25maWd1cmVHbG9iYWwob3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBheWxvYWREYXRhKSB7XG4gIHZhciBvbGRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgcGF5bG9hZCA9IHt9O1xuICBpZiAocGF5bG9hZERhdGEpIHtcbiAgICBwYXlsb2FkID0geyBwYXlsb2FkOiBwYXlsb2FkRGF0YSB9O1xuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvbGRPcHRpb25zLCBvcHRpb25zLCBwYXlsb2FkKTtcblxuICAvLyBMZWdhY3kgT3BlblRyYWNpbmcgc3VwcG9ydFxuICAvLyBUaGlzIG11c3QgaGFwcGVuIGJlZm9yZSB0aGUgTm90aWZpZXIgaXMgY29uZmlndXJlZFxuICB2YXIgdHJhY2VyID0gdGhpcy5vcHRpb25zLnRyYWNlciB8fCBudWxsO1xuICBpZiAodmFsaWRhdGVUcmFjZXIodHJhY2VyKSkge1xuICAgIHRoaXMudHJhY2VyID0gdHJhY2VyO1xuICAgIC8vIHNldCB0byBhIHN0cmluZyBmb3IgYXBpIHJlc3BvbnNlIHNlcmlhbGl6YXRpb25cbiAgICB0aGlzLm9wdGlvbnMudHJhY2VyID0gJ29wZW50cmFjaW5nLXRyYWNlci1lbmFibGVkJztcbiAgICB0aGlzLm9wdGlvbnMuX2NvbmZpZ3VyZWRPcHRpb25zLnRyYWNlciA9ICdvcGVudHJhY2luZy10cmFjZXItZW5hYmxlZCc7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50cmFjZXIgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5ub3RpZmllciAmJiB0aGlzLm5vdGlmaWVyLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMpO1xuICB0aGlzLnRlbGVtZXRlciAmJiB0aGlzLnRlbGVtZXRlci5jb25maWd1cmUodGhpcy5vcHRpb25zKTtcbiAgc2V0U3RhY2tUcmFjZUxpbWl0KG9wdGlvbnMpO1xuICB0aGlzLmdsb2JhbCh0aGlzLm9wdGlvbnMpO1xuXG4gIGlmICh2YWxpZGF0ZVRyYWNlcihvcHRpb25zLnRyYWNlcikpIHtcbiAgICB0aGlzLnRyYWNlciA9IG9wdGlvbnMudHJhY2VyO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9kZWZhdWx0TG9nTGV2ZWwoKTtcbiAgcmV0dXJuIHRoaXMuX2xvZyhsZXZlbCwgaXRlbSk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHRoaXMuX2xvZygnZGVidWcnLCBpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ2luZm8nLCBpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ3dhcm5pbmcnLCBpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ3dhcm5pbmcnLCBpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdGhpcy5fbG9nKCdlcnJvcicsIGl0ZW0pO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuY3JpdGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ2NyaXRpY2FsJywgaXRlbSk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMucXVldWUud2FpdChjYWxsYmFjayk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgbWV0YWRhdGEsIGxldmVsKSB7XG4gIHJldHVybiB0aGlzLnRlbGVtZXRlciAmJiB0aGlzLnRlbGVtZXRlci5jYXB0dXJlRXZlbnQodHlwZSwgbWV0YWRhdGEsIGxldmVsKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmNhcHR1cmVEb21Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKHRzKSB7XG4gIHJldHVybiB0aGlzLnRlbGVtZXRlciAmJiB0aGlzLnRlbGVtZXRlci5jYXB0dXJlRG9tQ29udGVudExvYWRlZCh0cyk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlTG9hZCA9IGZ1bmN0aW9uICh0cykge1xuICByZXR1cm4gdGhpcy50ZWxlbWV0ZXIgJiYgdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZUxvYWQodHMpO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHJldHVybiB0aGlzLmFwaS5idWlsZEpzb25QYXlsb2FkKGl0ZW0pO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuc2VuZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKGpzb25QYXlsb2FkKSB7XG4gIHRoaXMuYXBpLnBvc3RKc29uUGF5bG9hZChqc29uUGF5bG9hZCk7XG59O1xuXG4vKiBJbnRlcm5hbCAqL1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKGRlZmF1bHRMZXZlbCwgaXRlbSkge1xuICB2YXIgY2FsbGJhY2s7XG4gIGlmIChpdGVtLmNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBpdGVtLmNhbGxiYWNrO1xuICAgIGRlbGV0ZSBpdGVtLmNhbGxiYWNrO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlRHVwbGljYXRlRXJyb3JzICYmIHRoaXMuX3NhbWVBc0xhc3RFcnJvcihpdGVtKSkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdpZ25vcmVkIGlkZW50aWNhbCBpdGVtJyk7XG4gICAgICBlcnJvci5pdGVtID0gaXRlbTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgdGhpcy5fYWRkVHJhY2luZ0F0dHJpYnV0ZXMoaXRlbSk7XG5cbiAgICAvLyBMZWdhY3kgT3BlblRyYWNpbmcgc3VwcG9ydFxuICAgIHRoaXMuX2FkZFRyYWNpbmdJbmZvKGl0ZW0pO1xuXG4gICAgaXRlbS5sZXZlbCA9IGl0ZW0ubGV2ZWwgfHwgZGVmYXVsdExldmVsO1xuXG5cbiAgICBjb25zdCB0ZWxlbWV0ZXIgPSB0aGlzLnRlbGVtZXRlcjtcbiAgICBpZiAodGVsZW1ldGVyKSB7XG4gICAgICB0ZWxlbWV0ZXIuX2NhcHR1cmVSb2xsYmFySXRlbShpdGVtKTtcbiAgICAgIGl0ZW0udGVsZW1ldHJ5RXZlbnRzID0gdGVsZW1ldGVyLmNvcHlFdmVudHMoKSB8fCBbXTtcblxuICAgICAgaWYgKHRlbGVtZXRlci50ZWxlbWV0cnlTcGFuKSB7XG4gICAgICAgIHRlbGVtZXRlci50ZWxlbWV0cnlTcGFuLmVuZCgpO1xuICAgICAgICB0ZWxlbWV0ZXIudGVsZW1ldHJ5U3BhbiA9IHRlbGVtZXRlci50cmFjaW5nLnN0YXJ0U3Bhbigncm9sbGJhci10ZWxlbWV0cnknLCB7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZmllci5sb2coaXRlbSwgY2FsbGJhY2spO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLl9hZGRUcmFjaW5nQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIGNvbnN0IHNwYW4gPSB0aGlzLnRyYWNpbmc/LmdldFNwYW4oKTtcbiAgaWYgKCFzcGFuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXG4gICAge2tleTogJ3Nlc3Npb25faWQnLCB2YWx1ZTogdGhpcy50cmFjaW5nLnNlc3Npb25JZH0sXG4gICAge2tleTogJ3NwYW5faWQnLCB2YWx1ZTogc3Bhbi5zcGFuSWR9LFxuICAgIHtrZXk6ICd0cmFjZV9pZCcsIHZhbHVlOiBzcGFuLnRyYWNlSWR9LFxuICBdO1xuICBfLmFkZEl0ZW1BdHRyaWJ1dGVzKGl0ZW0sIGF0dHJpYnV0ZXMpO1xuXG4gIHNwYW4uYWRkRXZlbnQoXG4gICAgJ3JvbGxiYXIub2NjdXJyZW5jZScsXG4gICAgW3trZXk6ICdyb2xsYmFyLm9jY3VycmVuY2UudXVpZCcsIHZhbHVlOiBpdGVtLnV1aWR9XSxcbiAgKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLl9kZWZhdWx0TG9nTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMubG9nTGV2ZWwgfHwgJ2RlYnVnJztcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLl9zYW1lQXNMYXN0RXJyb3IgPSBmdW5jdGlvbiAoaXRlbSkge1xuICBpZiAoIWl0ZW0uX2lzVW5jYXVnaHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGl0ZW1IYXNoID0gZ2VuZXJhdGVJdGVtSGFzaChpdGVtKTtcbiAgaWYgKHRoaXMubGFzdEVycm9ySGFzaCA9PT0gaXRlbUhhc2gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0aGlzLmxhc3RFcnJvciA9IGl0ZW0uZXJyO1xuICB0aGlzLmxhc3RFcnJvckhhc2ggPSBpdGVtSGFzaDtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuX2FkZFRyYWNpbmdJbmZvID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgLy8gVHJhY2VyIHZhbGlkYXRpb24gb2NjdXJzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAvLyBvciBpbiB0aGUgUm9sbGJhci5wcm90b3R5cGUuY29uZmlndXJlIG1ldGhvZHNcbiAgaWYgKHRoaXMudHJhY2VyKSB7XG4gICAgLy8gYWRkIHJvbGxiYXIgb2NjdXJyZW5jZSB1dWlkIHRvIHNwYW5cbiAgICB2YXIgc3BhbiA9IHRoaXMudHJhY2VyLnNjb3BlKCkuYWN0aXZlKCk7XG5cbiAgICBpZiAodmFsaWRhdGVTcGFuKHNwYW4pKSB7XG4gICAgICBzcGFuLnNldFRhZygncm9sbGJhci5lcnJvcl91dWlkJywgaXRlbS51dWlkKTtcbiAgICAgIHNwYW4uc2V0VGFnKCdyb2xsYmFyLmhhc19lcnJvcicsIHRydWUpO1xuICAgICAgc3Bhbi5zZXRUYWcoJ2Vycm9yJywgdHJ1ZSk7XG4gICAgICBzcGFuLnNldFRhZyhcbiAgICAgICAgJ3JvbGxiYXIuaXRlbV91cmwnLFxuICAgICAgICBgaHR0cHM6Ly9yb2xsYmFyLmNvbS9pdGVtL3V1aWQvP3V1aWQ9JHtpdGVtLnV1aWR9YCxcbiAgICAgICk7XG4gICAgICBzcGFuLnNldFRhZyhcbiAgICAgICAgJ3JvbGxiYXIub2NjdXJyZW5jZV91cmwnLFxuICAgICAgICBgaHR0cHM6Ly9yb2xsYmFyLmNvbS9vY2N1cnJlbmNlL3V1aWQvP3V1aWQ9JHtpdGVtLnV1aWR9YCxcbiAgICAgICk7XG5cbiAgICAgIC8vIGFkZCBzcGFuIElEICYgdHJhY2UgSUQgdG8gb2NjdXJyZW5jZVxuICAgICAgdmFyIG9wZW50cmFjaW5nU3BhbklkID0gc3Bhbi5jb250ZXh0KCkudG9TcGFuSWQoKTtcbiAgICAgIHZhciBvcGVudHJhY2luZ1RyYWNlSWQgPSBzcGFuLmNvbnRleHQoKS50b1RyYWNlSWQoKTtcblxuICAgICAgaWYgKGl0ZW0uY3VzdG9tKSB7XG4gICAgICAgIGl0ZW0uY3VzdG9tLm9wZW50cmFjaW5nX3NwYW5faWQgPSBvcGVudHJhY2luZ1NwYW5JZDtcbiAgICAgICAgaXRlbS5jdXN0b20ub3BlbnRyYWNpbmdfdHJhY2VfaWQgPSBvcGVudHJhY2luZ1RyYWNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLmN1c3RvbSA9IHtcbiAgICAgICAgICBvcGVudHJhY2luZ19zcGFuX2lkOiBvcGVudHJhY2luZ1NwYW5JZCxcbiAgICAgICAgICBvcGVudHJhY2luZ190cmFjZV9pZDogb3BlbnRyYWNpbmdUcmFjZUlkLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVJdGVtSGFzaChpdGVtKSB7XG4gIHZhciBtZXNzYWdlID0gaXRlbS5tZXNzYWdlIHx8ICcnO1xuICB2YXIgc3RhY2sgPSAoaXRlbS5lcnIgfHwge30pLnN0YWNrIHx8IFN0cmluZyhpdGVtLmVycik7XG4gIHJldHVybiBtZXNzYWdlICsgJzo6JyArIHN0YWNrO1xufVxuXG4vLyBOb2RlLmpzLCBDaHJvbWUsIFNhZmFyaSwgYW5kIHNvbWUgb3RoZXIgYnJvd3NlcnMgc3VwcG9ydCB0aGlzIHByb3BlcnR5XG4vLyB3aGljaCBnbG9iYWxseSBzZXRzIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzIHJldHVybmVkIGluIGFuIEVycm9yIG9iamVjdC5cbi8vIElmIGEgYnJvd3NlciBjYW4ndCB1c2UgaXQsIG5vIGhhcm0gZG9uZS5cbmZ1bmN0aW9uIHNldFN0YWNrVHJhY2VMaW1pdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0YWNrVHJhY2VMaW1pdCkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IG9wdGlvbnMuc3RhY2tUcmFjZUxpbWl0O1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIFRyYWNlciBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIENsaWVudFxuICogaXMgdmFsaWQgZm9yIG91ciBPcGVudHJhY2luZyB1c2UgY2FzZS5cbiAqIEBwYXJhbSB7b3BlbnRyYWNlci5UcmFjZXJ9IHRyYWNlclxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYWNlcih0cmFjZXIpIHtcbiAgaWYgKCF0cmFjZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXRyYWNlci5zY29wZSB8fCB0eXBlb2YgdHJhY2VyLnNjb3BlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHNjb3BlID0gdHJhY2VyLnNjb3BlKCk7XG5cbiAgaWYgKCFzY29wZSB8fCAhc2NvcGUuYWN0aXZlIHx8IHR5cGVvZiBzY29wZS5hY3RpdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgU3BhbiBvYmplY3QgcHJvdmlkZWRcbiAqIEBwYXJhbSB7b3BlbnRyYWNlci5TcGFufSBzcGFuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3BhbihzcGFuKSB7XG4gIGlmICghc3BhbiB8fCAhc3Bhbi5jb250ZXh0IHx8IHR5cGVvZiBzcGFuLmNvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3BhbkNvbnRleHQgPSBzcGFuLmNvbnRleHQoKTtcblxuICBpZiAoXG4gICAgIXNwYW5Db250ZXh0IHx8XG4gICAgIXNwYW5Db250ZXh0LnRvU3BhbklkIHx8XG4gICAgIXNwYW5Db250ZXh0LnRvVHJhY2VJZCB8fFxuICAgIHR5cGVvZiBzcGFuQ29udGV4dC50b1NwYW5JZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBzcGFuQ29udGV4dC50b1RyYWNlSWQgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm9sbGJhcjtcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG52YXIgdHJhdmVyc2UgPSByZXF1aXJlKCcuL3V0aWxpdHkvdHJhdmVyc2UnKTtcblxuZnVuY3Rpb24gc2NydWIoZGF0YSwgc2NydWJGaWVsZHMsIHNjcnViUGF0aHMpIHtcbiAgc2NydWJGaWVsZHMgPSBzY3J1YkZpZWxkcyB8fCBbXTtcblxuICBpZiAoc2NydWJQYXRocykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NydWJQYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgc2NydWJQYXRoKGRhdGEsIHNjcnViUGF0aHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJhbVJlcyA9IF9nZXRTY3J1YkZpZWxkUmVnZXhzKHNjcnViRmllbGRzKTtcbiAgdmFyIHF1ZXJ5UmVzID0gX2dldFNjcnViUXVlcnlQYXJhbVJlZ2V4cyhzY3J1YkZpZWxkcyk7XG5cbiAgZnVuY3Rpb24gcmVkYWN0UXVlcnlQYXJhbShkdW1teTAsIHBhcmFtUGFydCkge1xuICAgIHJldHVybiBwYXJhbVBhcnQgKyBfLnJlZGFjdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyYW1TY3J1YmJlcih2KSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKF8uaXNUeXBlKHYsICdzdHJpbmcnKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHF1ZXJ5UmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHYgPSB2LnJlcGxhY2UocXVlcnlSZXNbaV0sIHJlZGFjdFF1ZXJ5UGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbFNjcnViYmVyKGssIHYpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1SZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChwYXJhbVJlc1tpXS50ZXN0KGspKSB7XG4gICAgICAgIHYgPSBfLnJlZGFjdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBmdW5jdGlvbiBzY3J1YmJlcihrLCB2LCBzZWVuKSB7XG4gICAgdmFyIHRtcFYgPSB2YWxTY3J1YmJlcihrLCB2KTtcbiAgICBpZiAodG1wViA9PT0gdikge1xuICAgICAgaWYgKF8uaXNUeXBlKHYsICdvYmplY3QnKSB8fCBfLmlzVHlwZSh2LCAnYXJyYXknKSkge1xuICAgICAgICByZXR1cm4gdHJhdmVyc2Uodiwgc2NydWJiZXIsIHNlZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtU2NydWJiZXIodG1wVik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0bXBWO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZShkYXRhLCBzY3J1YmJlcik7XG59XG5cbmZ1bmN0aW9uIHNjcnViUGF0aChvYmosIHBhdGgpIHtcbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBsYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xuICB0cnkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxhc3Q7ICsraSkge1xuICAgICAgaWYgKGkgPCBsYXN0KSB7XG4gICAgICAgIG9iaiA9IG9ialtrZXlzW2ldXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXlzW2ldXSA9IF8ucmVkYWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTWlzc2luZyBrZXkgaXMgT0s7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFNjcnViRmllbGRSZWdleHMoc2NydWJGaWVsZHMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgcGF0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgcGF0ID0gJ15cXFxcWz8oJTVbYkJdKT8nICsgc2NydWJGaWVsZHNbaV0gKyAnXFxcXFs/KCU1W2JCXSk/XFxcXF0/KCU1W2REXSk/JCc7XG4gICAgcmV0LnB1c2gobmV3IFJlZ0V4cChwYXQsICdpJykpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIF9nZXRTY3J1YlF1ZXJ5UGFyYW1SZWdleHMoc2NydWJGaWVsZHMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgcGF0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgcGF0ID0gJ1xcXFxbPyglNVtiQl0pPycgKyBzY3J1YkZpZWxkc1tpXSArICdcXFxcWz8oJTVbYkJdKT9cXFxcXT8oJTVbZERdKT8nO1xuICAgIHJldC5wdXNoKG5ldyBSZWdFeHAoJygnICsgcGF0ICsgJz0pKFteJlxcXFxuXSspJywgJ2lnbScpKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNjcnViO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuY29uc3QgTUFYX0VWRU5UUyA9IDEwMDtcblxuLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgd2hpbGUgc29sdmluZyBjb21tb25qcyAtPiBlc20gaXNzdWVzIGluIE5vZGUgMTggLSAyMC5cbmZ1bmN0aW9uIGZyb21NaWxsaXMobWlsbGlzKSB7XG4gIHJldHVybiBbTWF0aC50cnVuYyhtaWxsaXMgLyAxMDAwKSwgTWF0aC5yb3VuZCgobWlsbGlzICUgMTAwMCkgKiAxZTYpXTtcbn1cblxuZnVuY3Rpb24gVGVsZW1ldGVyKG9wdGlvbnMsIHRyYWNpbmcpIHtcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9wdGlvbnMpO1xuICB2YXIgbWF4VGVsZW1ldHJ5RXZlbnRzID0gdGhpcy5vcHRpb25zLm1heFRlbGVtZXRyeUV2ZW50cyB8fCBNQVhfRVZFTlRTO1xuICB0aGlzLm1heFF1ZXVlU2l6ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heFRlbGVtZXRyeUV2ZW50cywgTUFYX0VWRU5UUykpO1xuICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuICB0aGlzLnRlbGVtZXRyeVNwYW4gPSB0aGlzLnRyYWNpbmc/LnN0YXJ0U3Bhbigncm9sbGJhci10ZWxlbWV0cnknLCB7fSk7XG59XG5cblRlbGVtZXRlci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob2xkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHZhciBtYXhUZWxlbWV0cnlFdmVudHMgPSB0aGlzLm9wdGlvbnMubWF4VGVsZW1ldHJ5RXZlbnRzIHx8IE1BWF9FVkVOVFM7XG4gIHZhciBuZXdNYXhFdmVudHMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhUZWxlbWV0cnlFdmVudHMsIE1BWF9FVkVOVFMpKTtcbiAgdmFyIGRlbGV0ZUNvdW50ID0gMDtcbiAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gbmV3TWF4RXZlbnRzKSB7XG4gICAgZGVsZXRlQ291bnQgPSB0aGlzLnF1ZXVlLmxlbmd0aCAtIG5ld01heEV2ZW50cztcbiAgfVxuICB0aGlzLm1heFF1ZXVlU2l6ZSA9IG5ld01heEV2ZW50cztcbiAgdGhpcy5xdWV1ZS5zcGxpY2UoMCwgZGVsZXRlQ291bnQpO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jb3B5RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXZlbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5xdWV1ZSwgMCk7XG4gIGlmIChfLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeSkpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGkgPSBldmVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeShldmVudHNbaV0pKSB7XG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJUZWxlbWV0cnkgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24gKFxuICB0eXBlLFxuICBtZXRhZGF0YSxcbiAgbGV2ZWwsXG4gIHJvbGxiYXJVVUlELFxuICB0aW1lc3RhbXAsXG4pIHtcbiAgdmFyIGUgPSB7XG4gICAgbGV2ZWw6IGdldExldmVsKHR5cGUsIGxldmVsKSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVzdGFtcF9tczogdGltZXN0YW1wIHx8IF8ubm93KCksXG4gICAgYm9keTogbWV0YWRhdGEsXG4gICAgc291cmNlOiAnY2xpZW50JyxcbiAgfTtcbiAgaWYgKHJvbGxiYXJVVUlEKSB7XG4gICAgZS51dWlkID0gcm9sbGJhclVVSUQ7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChcbiAgICAgIF8uaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuZmlsdGVyVGVsZW1ldHJ5KSAmJlxuICAgICAgdGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeShlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXhjKSB7XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeSA9IG51bGw7XG4gIH1cblxuICB0aGlzLnB1c2goZSk7XG4gIHJldHVybiBlO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlRXZlbnQgPSBmdW5jdGlvbiAoXG4gIHR5cGUsXG4gIG1ldGFkYXRhLFxuICBsZXZlbCxcbiAgcm9sbGJhclVVSUQsXG4pIHtcbiAgcmV0dXJuIHRoaXMuY2FwdHVyZSh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwsIHJvbGxiYXJVVUlEKTtcbn07XG5cblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZUVycm9yID0gZnVuY3Rpb24gKFxuICBlcnIsXG4gIGxldmVsLFxuICByb2xsYmFyVVVJRCxcbiAgdGltZXN0YW1wLFxuKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCBTdHJpbmcoZXJyKTtcbiAgdmFyIG1ldGFkYXRhID0ge21lc3NhZ2V9O1xuICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgbWV0YWRhdGEuc3RhY2sgPSBlcnIuc3RhY2s7XG4gIH1cbiAgdGhpcy50ZWxlbWV0cnlTcGFuPy5hZGRFdmVudChcbiAgICAncm9sbGJhci1vY2N1cnJlbmNlLWV2ZW50JyxcbiAgICB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbGV2ZWwsXG4gICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgdXVpZDogcm9sbGJhclVVSUQsXG4gICAgICAnb2NjdXJyZW5jZS50eXBlJzogJ2Vycm9yJywgLy8gZGVwcmVjYXRlZFxuICAgICAgJ29jY3VycmVuY2UudXVpZCc6IHJvbGxiYXJVVUlELCAvLyBkZXByZWNhdGVkXG4gICAgfSxcblxuICAgIGZyb21NaWxsaXModGltZXN0YW1wKSxcbiAgKTtcblxuICByZXR1cm4gdGhpcy5jYXB0dXJlKCdlcnJvcicsIG1ldGFkYXRhLCBsZXZlbCwgcm9sbGJhclVVSUQsIHRpbWVzdGFtcCk7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVMb2cgPSBmdW5jdGlvbiAoXG4gIG1lc3NhZ2UsXG4gIGxldmVsLFxuICByb2xsYmFyVVVJRCxcbiAgdGltZXN0YW1wLFxuKSB7XG4gIC8vIElmIHRoZSB1dWlkIGlzIHByZXNlbnQsIHRoaXMgaXMgYSBtZXNzYWdlIG9jY3VycmVuY2UuXG4gIGlmIChyb2xsYmFyVVVJRCkge1xuICAgIHRoaXMudGVsZW1ldHJ5U3Bhbj8uYWRkRXZlbnQoXG4gICAgICAncm9sbGJhci1vY2N1cnJlbmNlLWV2ZW50JyxcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIHR5cGU6ICdtZXNzYWdlJyxcbiAgICAgICAgdXVpZDogcm9sbGJhclVVSUQsXG4gICAgICAgICdvY2N1cnJlbmNlLnR5cGUnOiAnbWVzc2FnZScsIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgJ29jY3VycmVuY2UudXVpZCc6IHJvbGxiYXJVVUlELCAvLyBkZXByZWNhdGVkXG4gICAgICB9LFxuICAgICAgZnJvbU1pbGxpcyh0aW1lc3RhbXApLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50ZWxlbWV0cnlTcGFuPy5hZGRFdmVudChcbiAgICAgICdsb2ctZXZlbnQnLFxuICAgICAge21lc3NhZ2UsIGxldmVsfSxcbiAgICAgIGZyb21NaWxsaXModGltZXN0YW1wKSxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2FwdHVyZShcbiAgICAnbG9nJyxcbiAgICB7bWVzc2FnZX0sXG4gICAgbGV2ZWwsXG4gICAgcm9sbGJhclVVSUQsXG4gICAgdGltZXN0YW1wLFxuICApO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlTmV0d29yayA9IGZ1bmN0aW9uIChcbiAgbWV0YWRhdGEsXG4gIHN1YnR5cGUsXG4gIHJvbGxiYXJVVUlELFxuICByZXF1ZXN0RGF0YSxcbikge1xuICBzdWJ0eXBlID0gc3VidHlwZSB8fCAneGhyJztcbiAgbWV0YWRhdGEuc3VidHlwZSA9IG1ldGFkYXRhLnN1YnR5cGUgfHwgc3VidHlwZTtcbiAgaWYgKHJlcXVlc3REYXRhKSB7XG4gICAgbWV0YWRhdGEucmVxdWVzdCA9IHJlcXVlc3REYXRhO1xuICB9XG4gIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxGcm9tU3RhdHVzKG1ldGFkYXRhLnN0YXR1c19jb2RlKTtcbiAgcmV0dXJuIHRoaXMuY2FwdHVyZSgnbmV0d29yaycsIG1ldGFkYXRhLCBsZXZlbCwgcm9sbGJhclVVSUQpO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5sZXZlbEZyb21TdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSkge1xuICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDQwMCkge1xuICAgIHJldHVybiAnaW5mbyc7XG4gIH1cbiAgaWYgKHN0YXR1c0NvZGUgPT09IDAgfHwgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuICByZXR1cm4gJ2luZm8nO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlRG9tID0gZnVuY3Rpb24gKFxuICBzdWJ0eXBlLFxuICBlbGVtZW50LFxuICB2YWx1ZSxcbiAgY2hlY2tlZCxcbiAgcm9sbGJhclVVSUQsXG4pIHtcbiAgdmFyIG1ldGFkYXRhID0ge1xuICAgIHN1YnR5cGU6IHN1YnR5cGUsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgfTtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtZXRhZGF0YS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGlmIChjaGVja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICBtZXRhZGF0YS5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5jYXB0dXJlKCdkb20nLCBtZXRhZGF0YSwgJ2luZm8nLCByb2xsYmFyVVVJRCk7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKGZyb20sIHRvLCByb2xsYmFyVVVJRCwgdGltZXN0YW1wKSB7XG4gIHRoaXMudGVsZW1ldHJ5U3Bhbj8uYWRkRXZlbnQoXG4gICAgJ3Nlc3Npb24tbmF2aWdhdGlvbi1ldmVudCcsXG4gICAgeydwcmV2aW91cy51cmwuZnVsbCc6IGZyb20sICd1cmwuZnVsbCc6IHRvfSxcbiAgICBmcm9tTWlsbGlzKHRpbWVzdGFtcCksXG4gICk7XG5cbiAgcmV0dXJuIHRoaXMuY2FwdHVyZShcbiAgICAnbmF2aWdhdGlvbicsXG4gICAge2Zyb20sIHRvfSxcbiAgICAnaW5mbycsXG4gICAgcm9sbGJhclVVSUQsXG4gICAgdGltZXN0YW1wLFxuICApO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlRG9tQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uICh0cykge1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKFxuICAgICduYXZpZ2F0aW9uJyxcbiAgICB7IHN1YnR5cGU6ICdET01Db250ZW50TG9hZGVkJyB9LFxuICAgICdpbmZvJyxcbiAgICB1bmRlZmluZWQsXG4gICAgdHMgJiYgdHMuZ2V0VGltZSgpLFxuICApO1xuICAvKipcbiAgICogSWYgd2UgZGVjaWRlIHRvIG1ha2UgdGhpcyBhIGRvbSBldmVudCBpbnN0ZWFkLCB0aGVuIHVzZSB0aGUgbGluZSBiZWxvdzpcbiAgcmV0dXJuIHRoaXMuY2FwdHVyZSgnZG9tJywge3N1YnR5cGU6ICdET01Db250ZW50TG9hZGVkJ30sICdpbmZvJywgdW5kZWZpbmVkLCB0cyAmJiB0cy5nZXRUaW1lKCkpO1xuICAqL1xufTtcblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZUxvYWQgPSBmdW5jdGlvbiAodHMpIHtcbiAgcmV0dXJuIHRoaXMuY2FwdHVyZShcbiAgICAnbmF2aWdhdGlvbicsXG4gICAgeyBzdWJ0eXBlOiAnbG9hZCcgfSxcbiAgICAnaW5mbycsXG4gICAgdW5kZWZpbmVkLFxuICAgIHRzICYmIHRzLmdldFRpbWUoKSxcbiAgKTtcbiAgLyoqXG4gICAqIElmIHdlIGRlY2lkZSB0byBtYWtlIHRoaXMgYSBkb20gZXZlbnQgaW5zdGVhZCwgdGhlbiB1c2UgdGhlIGxpbmUgYmVsb3c6XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ2RvbScsIHtzdWJ0eXBlOiAnbG9hZCd9LCAnaW5mbycsIHVuZGVmaW5lZCwgdHMgJiYgdHMuZ2V0VGltZSgpKTtcbiAgKi9cbn07XG5cblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSA9IGZ1bmN0aW9uICh0eXBlLCByb2xsYmFyVVVJRCkge1xuICByZXR1cm4gdGhpcy5jYXB0dXJlTmV0d29yayh7IGNoYW5nZTogdHlwZSB9LCAnY29ubmVjdGl2aXR5Jywgcm9sbGJhclVVSUQpO1xufTtcblxuLy8gT25seSBpbnRlbmRlZCB0byBiZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIG5vdGlmaWVyXG5UZWxlbWV0ZXIucHJvdG90eXBlLl9jYXB0dXJlUm9sbGJhckl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlSXRlbXNJblRlbGVtZXRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXRlbS5lcnIpIHtcbiAgICByZXR1cm4gdGhpcy5jYXB0dXJlRXJyb3IoaXRlbS5lcnIsIGl0ZW0ubGV2ZWwsIGl0ZW0udXVpZCwgaXRlbS50aW1lc3RhbXApO1xuICB9XG4gIGlmIChpdGVtLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5jYXB0dXJlTG9nKGl0ZW0ubWVzc2FnZSwgaXRlbS5sZXZlbCwgaXRlbS51dWlkLCBpdGVtLnRpbWVzdGFtcCk7XG4gIH1cbiAgaWYgKGl0ZW0uY3VzdG9tKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwdHVyZShcbiAgICAgICdsb2cnLFxuICAgICAgaXRlbS5jdXN0b20sXG4gICAgICBpdGVtLmxldmVsLFxuICAgICAgaXRlbS51dWlkLFxuICAgICAgaXRlbS50aW1lc3RhbXAsXG4gICAgKTtcbiAgfVxufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGUpIHtcbiAgdGhpcy5xdWV1ZS5wdXNoKGUpO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiB0aGlzLm1heFF1ZXVlU2l6ZSkge1xuICAgIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0TGV2ZWwodHlwZSwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsKSB7XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG4gIHZhciBkZWZhdWx0TGV2ZWwgPSB7XG4gICAgZXJyb3I6ICdlcnJvcicsXG4gICAgbWFudWFsOiAnaW5mbycsXG4gIH07XG4gIHJldHVybiBkZWZhdWx0TGV2ZWxbdHlwZV0gfHwgJ2luZm8nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVtZXRlcjtcbiIsImV4cG9ydCBjbGFzcyBDb250ZXh0IHtcbiAgY29uc3RydWN0b3IocGFyZW50Q29udGV4dCkge1xuICAgIHRoaXMuX2N1cnJlbnRDb250ZXh0ID0gcGFyZW50Q29udGV4dCA/IG5ldyBNYXAocGFyZW50Q29udGV4dCkgOiBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXRWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHQuZ2V0KGtleSk7XG4gIH1cblxuICBzZXRWYWx1ZSAoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQ29udGV4dCh0aGlzLl9jdXJyZW50Q29udGV4dCk7XG4gICAgY29udGV4dC5fY3VycmVudENvbnRleHQuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZGVsZXRlVmFsdWUoa2V5KSB7XG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBDb250ZXh0KHNlbGYuX2N1cnJlbnRDb250ZXh0KTtcbiAgICBjb250ZXh0Ll9jdXJyZW50Q29udGV4dC5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUk9PVF9DT05URVhUID0gbmV3IENvbnRleHQoKTtcblxuIiwiaW1wb3J0IHsgUk9PVF9DT05URVhUIH0gZnJvbSAnLi9jb250ZXh0LmpzJztcblxuZXhwb3J0IGNsYXNzIENvbnRleHRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IFJPT1RfQ09OVEVYVDtcbiAgfVxuXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgfVxuXG4gIGVudGVyQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgcHJldmlvdXNDb250ZXh0ID0gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dCB8fCBST09UX0NPTlRFWFQ7XG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuXG4gIGV4aXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGV4dDtcbiAgfVxuXG4gIHdpdGgoY29udGV4dCwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwcmV2aW91c0NvbnRleHQgPSB0aGlzLmVudGVyQ29udGV4dChjb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhpc0FyZywgLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRLZXkoa2V5KSB7XG4gIC8vIFVzZSBTeW1ib2wgZm9yIE9wZW5UZWxlbWV0cnkgY29tcGF0aWJpbGl0eS5cbiAgcmV0dXJuIFN5bWJvbC5mb3Ioa2V5KTtcbn1cblxuIiwiLyoqXG4gKiBEZWZhdWx0IHRyYWNpbmcgb3B0aW9uc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICBlbmRwb2ludDogJ2FwaS5yb2xsYmFyLmNvbS9hcGkvMS9zZXNzaW9uLycsXG59XG4iLCJpbXBvcnQgaHJ0aW1lIGZyb20gJy4vaHJ0aW1lJztcblxuLyoqXG4gKiBTcGFuRXhwb3J0ZXIgaXMgcmVzcG9uc2libGUgZm9yIGV4cG9ydGluZyBSZWFkYWJsZVNwYW4gb2JqZWN0c1xuICogYW5kIHRyYW5zZm9ybWluZyB0aGVtIGludG8gdGhlIE9UTFAtY29tcGF0aWJsZSBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGFuRXhwb3J0ZXIge1xuICAvKipcbiAgICogRXhwb3J0IHNwYW5zIHRvIHRoZSBzcGFuIGV4cG9ydCBxdWV1ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzcGFucyAtIEFycmF5IG9mIFJlYWRhYmxlU3BhbiBvYmplY3RzIHRvIGV4cG9ydFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBfcmVzdWx0Q2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayAobm90IHVzZWQpXG4gICAqL1xuICBleHBvcnQoc3BhbnMsIF9yZXN1bHRDYWxsYmFjaykge1xuICAgIGNvbnNvbGUubG9nKHNwYW5zKTsgLy8gY29uc29sZSBleHBvcnRlciwgVE9ETzogbWFrZSBvcHRpb25hbFxuICAgIHNwYW5FeHBvcnRRdWV1ZS5wdXNoKC4uLnNwYW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIFJlYWRhYmxlU3BhbiBvYmplY3RzIGludG8gdGhlIE9UTFAgZm9ybWF0IHBheWxvYWRcbiAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBSb2xsYmFyIEFQSS4gVGhpcyBmb2xsb3dzIHRoZSBPcGVuVGVsZW1ldHJ5IHByb3RvY29sXG4gICAqIHNwZWNpZmljYXRpb24gZm9yIHRyYWNlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gT1RMUCBmb3JtYXQgcGF5bG9hZCBmb3IgQVBJIHRyYW5zbWlzc2lvblxuICAgKi9cbiAgdG9QYXlsb2FkKCkge1xuICAgIGNvbnN0IHNwYW5zID0gc3BhbkV4cG9ydFF1ZXVlLnNsaWNlKCk7XG4gICAgc3BhbkV4cG9ydFF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXNwYW5zIHx8ICFzcGFucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IHJlc291cmNlU3BhbnM6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb3VyY2UgPSAoc3BhbnNbMF0gJiYgc3BhbnNbMF0ucmVzb3VyY2UpIHx8IHt9O1xuXG4gICAgY29uc3Qgc2NvcGVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpIHtcbiAgICAgIGNvbnN0IHNjb3BlS2V5ID0gc3Bhbi5pbnN0cnVtZW50YXRpb25TY29wZVxuICAgICAgICA/IGAke3NwYW4uaW5zdHJ1bWVudGF0aW9uU2NvcGUubmFtZX06JHtzcGFuLmluc3RydW1lbnRhdGlvblNjb3BlLnZlcnNpb259YFxuICAgICAgICA6ICdkZWZhdWx0OjEuMC4wJztcblxuICAgICAgaWYgKCFzY29wZU1hcC5oYXMoc2NvcGVLZXkpKSB7XG4gICAgICAgIHNjb3BlTWFwLnNldChzY29wZUtleSwge1xuICAgICAgICAgIHNjb3BlOiBzcGFuLmluc3RydW1lbnRhdGlvblNjb3BlIHx8IHtcbiAgICAgICAgICAgIG5hbWU6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNwYW5zOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlTWFwLmdldChzY29wZUtleSkuc3BhbnMucHVzaCh0aGlzLl90cmFuc2Zvcm1TcGFuKHNwYW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzb3VyY2VTcGFuczogW1xuICAgICAgICB7XG4gICAgICAgICAgcmVzb3VyY2U6IHRoaXMuX3RyYW5zZm9ybVJlc291cmNlKHJlc291cmNlKSxcbiAgICAgICAgICBzY29wZVNwYW5zOiBBcnJheS5mcm9tKHNjb3BlTWFwLnZhbHVlcygpKS5tYXAoKHNjb3BlRGF0YSkgPT4gKHtcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLl90cmFuc2Zvcm1JbnN0cnVtZW50YXRpb25TY29wZShzY29wZURhdGEuc2NvcGUpLFxuICAgICAgICAgICAgc3BhbnM6IHNjb3BlRGF0YS5zcGFucyxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIFJlYWRhYmxlU3BhbiBpbnRvIHRoZSBPVExQIFNwYW4gZm9ybWF0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGFuIC0gUmVhZGFibGVTcGFuIG9iamVjdCB0byB0cmFuc2Zvcm1cbiAgICogQHJldHVybnMge09iamVjdH0gT1RMUCBTcGFuIGZvcm1hdFxuICAgKi9cbiAgX3RyYW5zZm9ybVNwYW4oc3Bhbikge1xuICAgIGNvbnN0IHRyYW5zZm9ybUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMgfHwge30pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlOiB0aGlzLl90cmFuc2Zvcm1BbnlWYWx1ZSh2YWx1ZSksXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybUV2ZW50cyA9IChldmVudHMpID0+IHtcbiAgICAgIHJldHVybiAoZXZlbnRzIHx8IFtdKS5tYXAoKGV2ZW50KSA9PiAoe1xuICAgICAgICB0aW1lVW5peE5hbm86IGhydGltZS50b05hbm9zKGV2ZW50LnRpbWUpLFxuICAgICAgICBuYW1lOiBldmVudC5uYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cmFuc2Zvcm1BdHRyaWJ1dGVzKGV2ZW50LmF0dHJpYnV0ZXMpLFxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2VJZDogc3Bhbi5zcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiBzcGFuLnNwYW5Db250ZXh0LnNwYW5JZCxcbiAgICAgIHBhcmVudFNwYW5JZDogc3Bhbi5wYXJlbnRTcGFuSWQgfHwgJycsXG4gICAgICBuYW1lOiBzcGFuLm5hbWUsXG4gICAgICBraW5kOiBzcGFuLmtpbmQgfHwgMSwgLy8gSU5URVJOQUwgYnkgZGVmYXVsdFxuICAgICAgc3RhcnRUaW1lVW5peE5hbm86IGhydGltZS50b05hbm9zKHNwYW4uc3RhcnRUaW1lKSxcbiAgICAgIGVuZFRpbWVVbml4TmFubzogaHJ0aW1lLnRvTmFub3Moc3Bhbi5lbmRUaW1lKSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRyYW5zZm9ybUF0dHJpYnV0ZXMoc3Bhbi5hdHRyaWJ1dGVzKSxcbiAgICAgIGV2ZW50czogdHJhbnNmb3JtRXZlbnRzKHNwYW4uZXZlbnRzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSByZXNvdXJjZSBvYmplY3QgaW50byBPVExQIFJlc291cmNlIGZvcm1hdFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzb3VyY2UgLSBSZXNvdXJjZSBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPVExQIFJlc291cmNlIGZvcm1hdFxuICAgKi9cbiAgX3RyYW5zZm9ybVJlc291cmNlKHJlc291cmNlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc291cmNlLmF0dHJpYnV0ZXMgfHwge307XG4gICAgY29uc3Qga2V5VmFsdWVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykubWFwKChba2V5LCB2YWx1ZV0pID0+ICh7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZTogdGhpcy5fdHJhbnNmb3JtQW55VmFsdWUodmFsdWUpLFxuICAgIH0pKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhdHRyaWJ1dGVzOiBrZXlWYWx1ZXMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGFuIGluc3RydW1lbnRhdGlvbiBzY29wZSBpbnRvIE9UTFAgSW5zdHJ1bWVudGF0aW9uU2NvcGUgZm9ybWF0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSAtIEluc3RydW1lbnRhdGlvbiBzY29wZSBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPVExQIEluc3RydW1lbnRhdGlvblNjb3BlIGZvcm1hdFxuICAgKi9cbiAgX3RyYW5zZm9ybUluc3RydW1lbnRhdGlvblNjb3BlKHNjb3BlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHNjb3BlLm5hbWUgfHwgJycsXG4gICAgICB2ZXJzaW9uOiBzY29wZS52ZXJzaW9uIHx8ICcnLFxuICAgICAgYXR0cmlidXRlczogKHNjb3BlLmF0dHJpYnV0ZXMgfHwgW10pLm1hcCgoYXR0cikgPT4gKHtcbiAgICAgICAga2V5OiBhdHRyLmtleSxcbiAgICAgICAgdmFsdWU6IHRoaXMuX3RyYW5zZm9ybUFueVZhbHVlKGF0dHIudmFsdWUpLFxuICAgICAgfSkpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBhbiBPVExQIEFueVZhbHVlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFZhbHVlIHRvIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPVExQIEFueVZhbHVlIGZvcm1hdFxuICAgKi9cbiAgX3RyYW5zZm9ybUFueVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiAnJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiB2YWx1ZSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBpbnRWYWx1ZTogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IHZhbHVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB7IGJvb2xWYWx1ZTogdmFsdWUgfTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcnJheVZhbHVlOiB7XG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX3RyYW5zZm9ybUFueVZhbHVlKHYpKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga3ZsaXN0VmFsdWU6IHtcbiAgICAgICAgICB2YWx1ZXM6IE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gKHtcbiAgICAgICAgICAgIGtleTogayxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl90cmFuc2Zvcm1BbnlWYWx1ZSh2KSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiBTdHJpbmcodmFsdWUpIH07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwYW5FeHBvcnRRdWV1ZSA9IFtdO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGhydGltZVxuICpcbiAqIEBkZXNjcmlwdGlvbiBNZXRob2RzIGZvciBoYW5kbGluZyBPcGVuVGVsZW1ldHJ5IGhydGltZS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gYW4gT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyAtIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyXX0gQW4gYXJyYXkgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgc2Vjb25kc1xuICogICBhbmQgdGhlIHNlY29uZCBpcyBuYW5vc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gZnJvbU1pbGxpcyhtaWxsaXMpIHtcbiAgcmV0dXJuIFtNYXRoLnRydW5jKG1pbGxpcyAvIDEwMDApLCBNYXRoLnJvdW5kKChtaWxsaXMgJSAxMDAwKSAqIDFlNildO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGUgYmFjayB0byBhIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGhydGltZSAtIFRoZSBocnRpbWUgdHVwbGUgW3NlY29uZHMsIG5hbm9zZWNvbmRzXS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHRvTWlsbGlzKGhydGltZSkge1xuICByZXR1cm4gaHJ0aW1lWzBdICogMWUzICsgTWF0aC5yb3VuZChocnRpbWVbMV0gLyAxZTYpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGUgYmFjayB0byBhIGR1cmF0aW9uIGluIG5hbm9zZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gaHJ0aW1lIC0gVGhlIGhydGltZSB0dXBsZSBbc2Vjb25kcywgbmFub3NlY29uZHNdLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIGR1cmF0aW9uIGluIG5hbm9zZWNvbmRzLlxuICovXG5mdW5jdGlvbiB0b05hbm9zKGhydGltZSkge1xuICByZXR1cm4gaHJ0aW1lWzBdICogMWU5ICsgaHJ0aW1lWzFdO1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIE9wZW5UZWxlbWV0cnkgaHJ0aW1lIHR1cGxlcy5cbiAqXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGEgLSBUaGUgZmlyc3QgaHJ0aW1lIHR1cGxlIFtzLCBuc10uXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGIgLSBUaGUgc2Vjb25kIGhydGltZSB0dXBsZSBbcywgbnNdLlxuICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFN1bW1lZCBocnRpbWUgdHVwbGUsIG5vcm1hbGl6ZWQuXG4gKlxuICovXG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICByZXR1cm4gW2FbMF0gKyBiWzBdICsgTWF0aC50cnVuYygoYVsxXSArIGJbMV0pIC8gMWU5KSwgKGFbMV0gKyBiWzFdKSAlIDFlOV07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGhpZ2gtcmVzb2x1dGlvbiB0aW1lIGFzIGFuIE9wZW5UZWxlbWV0cnkgaHJ0aW1lIHR1cGxlLlxuICpcbiAqIFVzZXMgdGhlIFBlcmZvcm1hbmNlIEFQSSAodGltZU9yaWdpbiArIG5vdygpKS5cbiAqXG4gKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyXX0gVGhlIGN1cnJlbnQgaHJ0aW1lIHR1cGxlIFtzLCBuc10uXG4gKi9cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGFkZChmcm9tTWlsbGlzKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4pLCBmcm9tTWlsbGlzKHBlcmZvcm1hbmNlLm5vdygpKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIE9wZW5UZWxlbWV0cnkgaHJ0aW1lIHR1cGxlLlxuICpcbiAqIEFuIGhydGltZSB0dXBsZSBpcyBhbiBBcnJheSBvZiBleGFjdGx5IHR3byBudW1iZXJzOlxuICogICBbc2Vjb25kcywgbmFub3NlY29uZHNdXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSDigJMgYW55dGhpbmcgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhIFtudW1iZXIsIG51bWJlcl0gYXJyYXkgb2YgbGVuZ3RoIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogaXNIclRpbWUoWyAxLCA1MDAgXSk7ICAgICAgICAgLy8gdHJ1ZVxuICogaXNIclRpbWUoWyAwLCAxZTkgXSk7ICAgICAgICAgLy8gdHJ1ZVxuICogaXNIclRpbWUoWyAnMScsIDUwMCBdKTsgICAgICAgLy8gZmFsc2VcbiAqIGlzSHJUaW1lKHsgMDogMSwgMTogNTAwIH0pOyAgIC8vIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzSHJUaW1lKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICB2YWx1ZS5sZW5ndGggPT09IDIgJiZcbiAgICB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIHZhbHVlWzFdID09PSAnbnVtYmVyJ1xuICApO1xufVxuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGhhbmRsaW5nIGhydGltZS4gT3BlblRlbGVtZXRyeSB1c2VzIHRoZSBbc2Vjb25kcywgbmFub3NlY29uZHNdXG4gKiBmb3JtYXQgZm9yIGhydGltZSBpbiB0aGUgYFJlYWRhYmxlU3BhbmAgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgaHJ0aW1lIGZyb20gJ0B0cmFjaW5nL2hydGltZS5qcyc7XG4gKlxuICogaHJ0aW1lLmZyb21NaWxsaXMoMTAwMCk7XG4gKiBocnRpbWUudG9NaWxsaXMoWzAsIDEwMDBdKTtcbiAqIGhydGltZS5hZGQoWzAsIDBdLCBbMCwgMTAwMF0pO1xuICogaHJ0aW1lLm5vdygpO1xuICogaHJ0aW1lLmlzSHJUaW1lKFswLCAxMDAwXSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHsgZnJvbU1pbGxpcywgdG9NaWxsaXMsIHRvTmFub3MsIGFkZCwgbm93LCBpc0hyVGltZSB9O1xuIiwiLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSBoZXhhZGVjaW1hbCBJRCBvZiBzcGVjaWZpZWQgYnl0ZSBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZXMgLSBOdW1iZXIgb2YgYnl0ZXMgZm9yIHRoZSBJRCAoZGVmYXVsdDogMTYpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBnZW4oYnl0ZXMgPSAxNikge1xuICBsZXQgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnl0ZXMpO1xuICBsZXQgcmFuZEhleCA9IEFycmF5LmZyb20ocmFuZG9tQnl0ZXMsIChieXRlKSA9PlxuICAgIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksXG4gICkuam9pbignJyk7XG4gIHJldHVybiByYW5kSGV4O1xufVxuXG4vKipcbiAqIFRyYWNpbmcgaWQgZ2VuZXJhdGlvbiB1dGlsc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgaWQgZnJvbSAnLi9pZC5qcyc7XG4gKlxuICogY29uc3Qgc3BhbklkID0gaWQuZ2VuKDgpOyAvLyA9PiBcImExYjJjM2Q0ZTVmNi4uLlwiXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHsgZ2VuIH07XG4iLCJpbXBvcnQgaWQgZnJvbSAnLi9pZC5qcyc7XG5cbmNvbnN0IFNFU1NJT05fS0VZID0gJ1JvbGxiYXJTZXNzaW9uJztcblxuZXhwb3J0IGNsYXNzIFNlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcih0cmFjaW5nLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuICAgIHRoaXMud2luZG93ID0gdHJhY2luZy53aW5kb3c7XG4gICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNlc3Npb24oKSB8fCB0aGlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgfVxuXG4gIGdldFNlc3Npb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRTZXNzaW9uID0gdGhpcy53aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTRVNTSU9OX0tFWSk7XG5cbiAgICAgIGlmICghc2VyaWFsaXplZFNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Vzc2lvbiA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZFNlc3Npb24pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY3JlYXRlU2Vzc2lvbigpIHtcbiAgICB0aGlzLnNlc3Npb24gPSB7XG4gICAgICBpZDogaWQuZ2VuKCksXG4gICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLnNldFNlc3Npb24odGhpcy5zZXNzaW9uKTtcbiAgfVxuXG4gIHNldFNlc3Npb24oc2Vzc2lvbikge1xuICAgIGNvbnN0IHNlc3Npb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShzZXNzaW9uKTtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLndpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNFU1NJT05fS0VZLCBzZXNzaW9uU3RyaW5nKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4iLCJpbXBvcnQgaHJ0aW1lIGZyb20gJy4vaHJ0aW1lLmpzJztcblxuZXhwb3J0IGNsYXNzIFNwYW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0UmVhZGFibGVTcGFuKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zcGFuUHJvY2Vzc29yID0gb3B0aW9ucy5zcGFuUHJvY2Vzc29yO1xuICAgIHRoaXMuc3BhblByb2Nlc3Nvci5vblN0YXJ0KHRoaXMsIG9wdGlvbnMuY29udGV4dCk7XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbml0UmVhZGFibGVTcGFuKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNwYW4gPSB7XG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBzcGFuQ29udGV4dDogb3B0aW9ucy5zcGFuQ29udGV4dCxcbiAgICAgIHBhcmVudFNwYW5JZDogb3B0aW9ucy5wYXJlbnRTcGFuSWQsXG4gICAgICBzdGFydFRpbWU6IG9wdGlvbnMuc3RhcnRUaW1lIHx8IGhydGltZS5ub3coKSxcbiAgICAgIGVuZFRpbWU6IFswLCAwXSxcbiAgICAgIHN0YXR1czogeyBjb2RlOiAwLCBtZXNzYWdlOiAnJyB9LFxuICAgICAgYXR0cmlidXRlczogeyAnc2Vzc2lvbi5pZCc6IG9wdGlvbnMuc2Vzc2lvbi5pZCB9LFxuICAgICAgbGlua3M6IFtdLFxuICAgICAgZXZlbnRzOiBbXSxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgZW5kZWQ6IGZhbHNlLFxuICAgICAgcmVzb3VyY2U6IG9wdGlvbnMucmVzb3VyY2UsXG4gICAgICBpbnN0cnVtZW50YXRpb25TY29wZTogb3B0aW9ucy5zY29wZSxcbiAgICAgIGRyb3BwZWRBdHRyaWJ1dGVzQ291bnQ6IDAsXG4gICAgICBkcm9wcGVkRXZlbnRzQ291bnQ6IDAsXG4gICAgICBkcm9wcGVkTGlua3NDb3VudDogMCxcbiAgICB9O1xuICB9XG5cbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5zcGFuQ29udGV4dDtcbiAgfVxuXG4gIGdldCBzcGFuSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5zcGFuQ29udGV4dC5zcGFuSWQ7XG4gIH1cblxuICBnZXQgdHJhY2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLnNwYW5Db250ZXh0LnRyYWNlSWQ7XG4gIH1cblxuICBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHRoaXMuZW5kZWQpIHJldHVybiB0aGlzO1xuICAgIGlmIChrZXkubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgIHRoaXMuc3Bhbi5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShrLCB2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRFdmVudChuYW1lLCBhdHRyaWJ1dGVzID0ge30sIHRpbWUpIHtcbiAgICBpZiAodGhpcy5zcGFuLmVuZGVkKSByZXR1cm4gdGhpcztcblxuICAgIHRoaXMuc3Bhbi5ldmVudHMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHRpbWU6IHRpbWUgfHwgaHJ0aW1lLm5vdygpLFxuICAgICAgZHJvcHBlZEF0dHJpYnV0ZXNDb3VudDogMCxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhbi5lbmRlZCA9PT0gZmFsc2U7XG4gIH1cblxuICBlbmQoYXR0cmlidXRlcywgdGltZSkge1xuICAgIGlmIChhdHRyaWJ1dGVzKSB0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgdGhpcy5zcGFuLmVuZFRpbWUgPSB0aW1lIHx8IGhydGltZS5ub3coKTtcbiAgICB0aGlzLnNwYW4uZW5kZWQgPSB0cnVlO1xuICAgIHRoaXMuc3BhblByb2Nlc3Nvci5vbkVuZCh0aGlzKTtcbiAgfVxuXG4gIGV4cG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgU3BhblByb2Nlc3NvciB7XG4gIGNvbnN0cnVjdG9yKGV4cG9ydGVyKSB7XG4gICAgdGhpcy5leHBvcnRlciA9IGV4cG9ydGVyO1xuICAgIHRoaXMucGVuZGluZ1NwYW5zID0gbmV3IE1hcCgpXG4gIH1cblxuICBvblN0YXJ0KHNwYW4sIF9wYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy5wZW5kaW5nU3BhbnMuc2V0KHNwYW4uc3Bhbi5zcGFuQ29udGV4dC5zcGFuSWQsIHNwYW4pO1xuICB9XG5cbiAgb25FbmQoc3Bhbikge1xuICAgIHRoaXMuZXhwb3J0ZXIuZXhwb3J0KFtzcGFuLmV4cG9ydCgpXSlcbiAgICB0aGlzLnBlbmRpbmdTcGFucy5kZWxldGUoc3Bhbi5zcGFuLnNwYW5Db250ZXh0LnNwYW5JZCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNwYW4gfSBmcm9tICcuL3NwYW4uanMnO1xuaW1wb3J0IGlkIGZyb20gJy4vaWQuanMnO1xuXG5leHBvcnQgY2xhc3MgVHJhY2VyIHtcbiAgY29uc3RydWN0b3IodHJhY2luZywgc3BhblByb2Nlc3Nvcikge1xuICAgIHRoaXMuc3BhblByb2Nlc3NvciA9IHNwYW5Qcm9jZXNzb3I7XG4gICAgdGhpcy50cmFjaW5nID0gdHJhY2luZztcbiAgfVxuXG4gIHN0YXJ0U3BhbihcbiAgICBuYW1lLFxuICAgIG9wdGlvbnMgPSB7fSxcbiAgICBjb250ZXh0ID0gdGhpcy50cmFjaW5nLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpXG4gICkge1xuICAgIGNvbnN0IHBhcmVudFNwYW4gPSB0aGlzLnRyYWNpbmcuZ2V0U3Bhbihjb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnRTcGFuQ29udGV4dCA9IHBhcmVudFNwYW4/LnNwYW5Db250ZXh0KCk7XG4gICAgY29uc3Qgc3BhbklkID0gaWQuZ2VuKDgpO1xuICAgIGxldCB0cmFjZUlkO1xuICAgIGxldCB0cmFjZUZsYWdzID0gMDtcbiAgICBsZXQgdHJhY2VTdGF0ZSA9IG51bGw7XG4gICAgbGV0IHBhcmVudFNwYW5JZDtcbiAgICBpZiAocGFyZW50U3BhbkNvbnRleHQpIHtcbiAgICAgIHRyYWNlSWQgPSBwYXJlbnRTcGFuQ29udGV4dC50cmFjZUlkO1xuICAgICAgdHJhY2VTdGF0ZSA9IHBhcmVudFNwYW5Db250ZXh0LnRyYWNlU3RhdGU7XG4gICAgICBwYXJlbnRTcGFuSWQgPSBwYXJlbnRTcGFuQ29udGV4dC5zcGFuSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNlSWQgPSBpZC5nZW4oMTYpO1xuICAgIH1cblxuICAgIGNvbnN0IGtpbmQgPSAwO1xuICAgIGNvbnN0IHNwYW5Db250ZXh0ID0geyB0cmFjZUlkLCBzcGFuSWQsIHRyYWNlRmxhZ3MsIHRyYWNlU3RhdGUgfTtcblxuICAgIGNvbnN0IHNwYW4gPSBuZXcgU3Bhbih7XG4gICAgICByZXNvdXJjZTogdGhpcy50cmFjaW5nLnJlc291cmNlLFxuICAgICAgc2NvcGU6IHRoaXMudHJhY2luZy5zY29wZSxcbiAgICAgIHNlc3Npb246IHRoaXMudHJhY2luZy5zZXNzaW9uLnNlc3Npb24sXG4gICAgICBjb250ZXh0LFxuICAgICAgc3BhbkNvbnRleHQsXG4gICAgICBuYW1lLFxuICAgICAga2luZCxcbiAgICAgIHBhcmVudFNwYW5JZCxcbiAgICAgIHNwYW5Qcm9jZXNzb3I6IHRoaXMuc3BhblByb2Nlc3NvcixcbiAgICB9KTtcbiAgICByZXR1cm4gc3BhbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29udGV4dE1hbmFnZXIsIGNyZWF0ZUNvbnRleHRLZXkgfSBmcm9tICcuL2NvbnRleHRNYW5hZ2VyLmpzJztcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb24uanMnO1xuaW1wb3J0IHsgU3BhbkV4cG9ydGVyIH0gZnJvbSAnLi9leHBvcnRlci5qcyc7XG5pbXBvcnQgeyBTcGFuUHJvY2Vzc29yIH0gZnJvbSAnLi9zcGFuUHJvY2Vzc29yLmpzJztcbmltcG9ydCB7IFRyYWNlciB9IGZyb20gJy4vdHJhY2VyLmpzJztcblxuY29uc3QgU1BBTl9LRVkgPSBjcmVhdGVDb250ZXh0S2V5KCdSb2xsYmFyIENvbnRleHQgS2V5IFNQQU4nKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2luZyB7XG4gIGNvbnN0cnVjdG9yKGdXaW5kb3csIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMud2luZG93ID0gZ1dpbmRvdztcblxuICAgIHRoaXMuc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY3JlYXRlVHJhY2VyKCk7XG4gIH1cblxuICBpbml0U2Vzc2lvbigpIHtcbiAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICB0aGlzLnNlc3Npb24uaW5pdCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzZXNzaW9uSWQoKSB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zZXNzaW9uLmlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCByZXNvdXJjZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi4odGhpcy5vcHRpb25zLnJlc291cmNlIHx8IHt9KSxcbiAgICAgICAgJ3JvbGxiYXIuZW52aXJvbm1lbnQnOlxuICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXlsb2FkPy5lbnZpcm9ubWVudCA/PyB0aGlzLm9wdGlvbnMuZW52aXJvbm1lbnQsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBnZXQgc2NvcGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdyb2xsYmFyLWJyb3dzZXItanMnLFxuICAgICAgdmVyc2lvbjogdGhpcy5vcHRpb25zLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVRyYWNlcigpIHtcbiAgICB0aGlzLmNvbnRleHRNYW5hZ2VyID0gbmV3IENvbnRleHRNYW5hZ2VyKCk7XG4gICAgdGhpcy5leHBvcnRlciA9IG5ldyBTcGFuRXhwb3J0ZXIoKTtcbiAgICB0aGlzLnNwYW5Qcm9jZXNzb3IgPSBuZXcgU3BhblByb2Nlc3Nvcih0aGlzLmV4cG9ydGVyKTtcbiAgICB0aGlzLnRyYWNlciA9IG5ldyBUcmFjZXIodGhpcywgdGhpcy5zcGFuUHJvY2Vzc29yKTtcbiAgfVxuXG4gIGdldFRyYWNlcigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjZXI7XG4gIH1cblxuICBnZXRTcGFuKGNvbnRleHQgPSB0aGlzLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0VmFsdWUoU1BBTl9LRVkpO1xuICB9XG5cbiAgc2V0U3Bhbihjb250ZXh0ID0gdGhpcy5jb250ZXh0TWFuYWdlci5hY3RpdmUoKSwgc3Bhbikge1xuICAgIHJldHVybiBjb250ZXh0LnNldFZhbHVlKFNQQU5fS0VZLCBzcGFuKTtcbiAgfVxuXG4gIHN0YXJ0U3BhbihuYW1lLCBvcHRpb25zID0ge30sIGNvbnRleHQgPSB0aGlzLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgfVxuXG4gIHdpdGgoY29udGV4dCwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0TWFuYWdlci53aXRoKGNvbnRleHQsIGZuLCB0aGlzQXJnLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHdpdGhTcGFuKG5hbWUsIG9wdGlvbnMsIGZuLCB0aGlzQXJnKSB7XG4gICAgY29uc3Qgc3BhbiA9IHRoaXMuc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLndpdGgoXG4gICAgICB0aGlzLnNldFNwYW4odGhpcy5jb250ZXh0TWFuYWdlci5hY3RpdmUoKSwgc3BhbiksXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICBzcGFuLFxuICAgICk7XG4gIH1cbn1cbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG5cbmZ1bmN0aW9uIGl0ZW1Ub1BheWxvYWQoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGRhdGEgPSBpdGVtLmRhdGE7XG5cbiAgaWYgKGl0ZW0uX2lzVW5jYXVnaHQpIHtcbiAgICBkYXRhLl9pc1VuY2F1Z2h0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXRlbS5fb3JpZ2luYWxBcmdzKSB7XG4gICAgZGF0YS5fb3JpZ2luYWxBcmdzID0gaXRlbS5fb3JpZ2luYWxBcmdzO1xuICB9XG4gIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBhZGRQYXlsb2FkT3B0aW9ucyhpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGF5bG9hZE9wdGlvbnMgPSBvcHRpb25zLnBheWxvYWQgfHwge307XG4gIGlmIChwYXlsb2FkT3B0aW9ucy5ib2R5KSB7XG4gICAgZGVsZXRlIHBheWxvYWRPcHRpb25zLmJvZHk7XG4gIH1cblxuICBpdGVtLmRhdGEgPSBfLm1lcmdlKGl0ZW0uZGF0YSwgcGF5bG9hZE9wdGlvbnMpO1xuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gYWRkVGVsZW1ldHJ5RGF0YShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoaXRlbS50ZWxlbWV0cnlFdmVudHMpIHtcbiAgICBfLnNldChpdGVtLCAnZGF0YS5ib2R5LnRlbGVtZXRyeScsIGl0ZW0udGVsZW1ldHJ5RXZlbnRzKTtcbiAgfVxuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gYWRkTWVzc2FnZVdpdGhFcnJvcihpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIWl0ZW0ubWVzc2FnZSkge1xuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdHJhY2VQYXRoID0gJ2RhdGEuYm9keS50cmFjZV9jaGFpbi4wJztcbiAgdmFyIHRyYWNlID0gXy5nZXQoaXRlbSwgdHJhY2VQYXRoKTtcbiAgaWYgKCF0cmFjZSkge1xuICAgIHRyYWNlUGF0aCA9ICdkYXRhLmJvZHkudHJhY2UnO1xuICAgIHRyYWNlID0gXy5nZXQoaXRlbSwgdHJhY2VQYXRoKTtcbiAgfVxuICBpZiAodHJhY2UpIHtcbiAgICBpZiAoISh0cmFjZS5leGNlcHRpb24gJiYgdHJhY2UuZXhjZXB0aW9uLmRlc2NyaXB0aW9uKSkge1xuICAgICAgXy5zZXQoaXRlbSwgdHJhY2VQYXRoICsgJy5leGNlcHRpb24uZGVzY3JpcHRpb24nLCBpdGVtLm1lc3NhZ2UpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBleHRyYSA9IF8uZ2V0KGl0ZW0sIHRyYWNlUGF0aCArICcuZXh0cmEnKSB8fCB7fTtcbiAgICB2YXIgbmV3RXh0cmEgPSBfLm1lcmdlKGV4dHJhLCB7IG1lc3NhZ2U6IGl0ZW0ubWVzc2FnZSB9KTtcbiAgICBfLnNldChpdGVtLCB0cmFjZVBhdGggKyAnLmV4dHJhJywgbmV3RXh0cmEpO1xuICB9XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiB1c2VyVHJhbnNmb3JtKGxvZ2dlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5ld0l0ZW0gPSBfLm1lcmdlKGl0ZW0pO1xuICAgIHZhciByZXNwb25zZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucy50cmFuc2Zvcm0pKSB7XG4gICAgICAgIHJlc3BvbnNlID0gb3B0aW9ucy50cmFuc2Zvcm0obmV3SXRlbS5kYXRhLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcHRpb25zLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICdFcnJvciB3aGlsZSBjYWxsaW5nIGN1c3RvbSB0cmFuc2Zvcm0oKSBmdW5jdGlvbi4gUmVtb3ZpbmcgY3VzdG9tIHRyYW5zZm9ybSgpLicsXG4gICAgICAgIGUsXG4gICAgICApO1xuICAgICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChfLmlzUHJvbWlzZShyZXNwb25zZSkpIHtcbiAgICAgIHJlc3BvbnNlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uIChwcm9taXNlZEl0ZW0pIHtcbiAgICAgICAgICBpZiAocHJvbWlzZWRJdGVtKSB7XG4gICAgICAgICAgICBuZXdJdGVtLmRhdGEgPSBwcm9taXNlZEl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG5ld0l0ZW0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgaXRlbSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBuZXdJdGVtKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZpZ1RvUGF5bG9hZChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuc2VuZENvbmZpZykge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgfVxuICB2YXIgY29uZmlnS2V5ID0gJ19yb2xsYmFyQ29uZmlnJztcbiAgdmFyIGN1c3RvbSA9IF8uZ2V0KGl0ZW0sICdkYXRhLmN1c3RvbScpIHx8IHt9O1xuICBjdXN0b21bY29uZmlnS2V5XSA9IG9wdGlvbnM7XG4gIGl0ZW0uZGF0YS5jdXN0b20gPSBjdXN0b207XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGRGdW5jdGlvbk9wdGlvbihvcHRpb25zLCBuYW1lKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9uc1tuYW1lXSkpIHtcbiAgICBvcHRpb25zW25hbWVdID0gb3B0aW9uc1tuYW1lXS50b1N0cmluZygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZpZ3VyZWRPcHRpb25zKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb25maWd1cmVkT3B0aW9ucyA9IG9wdGlvbnMuX2NvbmZpZ3VyZWRPcHRpb25zO1xuXG4gIC8vIFRoZXNlIG11c3QgYmUgc3RyaW5naWZpZWQgb3IgdGhleSdsbCBnZXQgZHJvcHBlZCBkdXJpbmcgc2VyaWFsaXphdGlvbi5cbiAgYWRkRnVuY3Rpb25PcHRpb24oY29uZmlndXJlZE9wdGlvbnMsICd0cmFuc2Zvcm0nKTtcbiAgYWRkRnVuY3Rpb25PcHRpb24oY29uZmlndXJlZE9wdGlvbnMsICdjaGVja0lnbm9yZScpO1xuICBhZGRGdW5jdGlvbk9wdGlvbihjb25maWd1cmVkT3B0aW9ucywgJ29uU2VuZENhbGxiYWNrJyk7XG5cbiAgZGVsZXRlIGNvbmZpZ3VyZWRPcHRpb25zLmFjY2Vzc1Rva2VuO1xuICBpdGVtLmRhdGEubm90aWZpZXIuY29uZmlndXJlZF9vcHRpb25zID0gY29uZmlndXJlZE9wdGlvbnM7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGREaWFnbm9zdGljS2V5cyhpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZGlhZ25vc3RpYyA9IF8ubWVyZ2UoXG4gICAgaXRlbS5ub3RpZmllci5jbGllbnQubm90aWZpZXIuZGlhZ25vc3RpYyxcbiAgICBpdGVtLmRpYWdub3N0aWMsXG4gICk7XG5cbiAgaWYgKF8uZ2V0KGl0ZW0sICdlcnIuX2lzQW5vbnltb3VzJykpIHtcbiAgICBkaWFnbm9zdGljLmlzX2Fub255bW91cyA9IHRydWU7XG4gIH1cblxuICBpZiAoaXRlbS5faXNVbmNhdWdodCkge1xuICAgIGRpYWdub3N0aWMuaXNfdW5jYXVnaHQgPSBpdGVtLl9pc1VuY2F1Z2h0O1xuICB9XG5cbiAgaWYgKGl0ZW0uZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRpYWdub3N0aWMucmF3X2Vycm9yID0ge1xuICAgICAgICBtZXNzYWdlOiBpdGVtLmVyci5tZXNzYWdlLFxuICAgICAgICBuYW1lOiBpdGVtLmVyci5uYW1lLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9uYW1lOiBpdGVtLmVyci5jb25zdHJ1Y3RvciAmJiBpdGVtLmVyci5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBmaWxlbmFtZTogaXRlbS5lcnIuZmlsZU5hbWUsXG4gICAgICAgIGxpbmU6IGl0ZW0uZXJyLmxpbmVOdW1iZXIsXG4gICAgICAgIGNvbHVtbjogaXRlbS5lcnIuY29sdW1uTnVtYmVyLFxuICAgICAgICBzdGFjazogaXRlbS5lcnIuc3RhY2ssXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRpYWdub3N0aWMucmF3X2Vycm9yID0geyBmYWlsZWQ6IFN0cmluZyhlKSB9O1xuICAgIH1cbiAgfVxuXG4gIGl0ZW0uZGF0YS5ub3RpZmllci5kaWFnbm9zdGljID0gXy5tZXJnZShcbiAgICBpdGVtLmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYyxcbiAgICBkaWFnbm9zdGljLFxuICApO1xuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGl0ZW1Ub1BheWxvYWQ6IGl0ZW1Ub1BheWxvYWQsXG4gIGFkZFBheWxvYWRPcHRpb25zOiBhZGRQYXlsb2FkT3B0aW9ucyxcbiAgYWRkVGVsZW1ldHJ5RGF0YTogYWRkVGVsZW1ldHJ5RGF0YSxcbiAgYWRkTWVzc2FnZVdpdGhFcnJvcjogYWRkTWVzc2FnZVdpdGhFcnJvcixcbiAgdXNlclRyYW5zZm9ybTogdXNlclRyYW5zZm9ybSxcbiAgYWRkQ29uZmlnVG9QYXlsb2FkOiBhZGRDb25maWdUb1BheWxvYWQsXG4gIGFkZENvbmZpZ3VyZWRPcHRpb25zOiBhZGRDb25maWd1cmVkT3B0aW9ucyxcbiAgYWRkRGlhZ25vc3RpY0tleXM6IGFkZERpYWdub3N0aWNLZXlzLFxufTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG52YXIgdHJhdmVyc2UgPSByZXF1aXJlKCcuL3V0aWxpdHkvdHJhdmVyc2UnKTtcblxuZnVuY3Rpb24gcmF3KHBheWxvYWQsIGpzb25CYWNrdXApIHtcbiAgcmV0dXJuIFtwYXlsb2FkLCBfLnN0cmluZ2lmeShwYXlsb2FkLCBqc29uQmFja3VwKV07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEZyYW1lcyhmcmFtZXMsIHJhbmdlKSB7XG4gIHZhciBsZW4gPSBmcmFtZXMubGVuZ3RoO1xuICBpZiAobGVuID4gcmFuZ2UgKiAyKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5zbGljZSgwLCByYW5nZSkuY29uY2F0KGZyYW1lcy5zbGljZShsZW4gLSByYW5nZSkpO1xuICB9XG4gIHJldHVybiBmcmFtZXM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlRnJhbWVzKHBheWxvYWQsIGpzb25CYWNrdXAsIHJhbmdlKSB7XG4gIHJhbmdlID0gdHlwZW9mIHJhbmdlID09PSAndW5kZWZpbmVkJyA/IDMwIDogcmFuZ2U7XG4gIHZhciBib2R5ID0gcGF5bG9hZC5kYXRhLmJvZHk7XG4gIHZhciBmcmFtZXM7XG4gIGlmIChib2R5LnRyYWNlX2NoYWluKSB7XG4gICAgdmFyIGNoYWluID0gYm9keS50cmFjZV9jaGFpbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFtZXMgPSBjaGFpbltpXS5mcmFtZXM7XG4gICAgICBmcmFtZXMgPSBzZWxlY3RGcmFtZXMoZnJhbWVzLCByYW5nZSk7XG4gICAgICBjaGFpbltpXS5mcmFtZXMgPSBmcmFtZXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJvZHkudHJhY2UpIHtcbiAgICBmcmFtZXMgPSBib2R5LnRyYWNlLmZyYW1lcztcbiAgICBmcmFtZXMgPSBzZWxlY3RGcmFtZXMoZnJhbWVzLCByYW5nZSk7XG4gICAgYm9keS50cmFjZS5mcmFtZXMgPSBmcmFtZXM7XG4gIH1cbiAgcmV0dXJuIFtwYXlsb2FkLCBfLnN0cmluZ2lmeShwYXlsb2FkLCBqc29uQmFja3VwKV07XG59XG5cbmZ1bmN0aW9uIG1heWJlVHJ1bmNhdGVWYWx1ZShsZW4sIHZhbCkge1xuICBpZiAoIXZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHZhbC5sZW5ndGggPiBsZW4pIHtcbiAgICByZXR1cm4gdmFsLnNsaWNlKDAsIGxlbiAtIDMpLmNvbmNhdCgnLi4uJyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGVTdHJpbmdzKGxlbiwgcGF5bG9hZCwganNvbkJhY2t1cCkge1xuICBmdW5jdGlvbiB0cnVuY2F0b3Ioaywgdiwgc2Vlbikge1xuICAgIHN3aXRjaCAoXy50eXBlTmFtZSh2KSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIG1heWJlVHJ1bmNhdGVWYWx1ZShsZW4sIHYpO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHYsIHRydW5jYXRvciwgc2Vlbik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gIH1cbiAgcGF5bG9hZCA9IHRyYXZlcnNlKHBheWxvYWQsIHRydW5jYXRvcik7XG4gIHJldHVybiBbcGF5bG9hZCwgXy5zdHJpbmdpZnkocGF5bG9hZCwganNvbkJhY2t1cCldO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRyYWNlRGF0YSh0cmFjZURhdGEpIHtcbiAgaWYgKHRyYWNlRGF0YS5leGNlcHRpb24pIHtcbiAgICBkZWxldGUgdHJhY2VEYXRhLmV4Y2VwdGlvbi5kZXNjcmlwdGlvbjtcbiAgICB0cmFjZURhdGEuZXhjZXB0aW9uLm1lc3NhZ2UgPSBtYXliZVRydW5jYXRlVmFsdWUoXG4gICAgICAyNTUsXG4gICAgICB0cmFjZURhdGEuZXhjZXB0aW9uLm1lc3NhZ2UsXG4gICAgKTtcbiAgfVxuICB0cmFjZURhdGEuZnJhbWVzID0gc2VsZWN0RnJhbWVzKHRyYWNlRGF0YS5mcmFtZXMsIDEpO1xuICByZXR1cm4gdHJhY2VEYXRhO1xufVxuXG5mdW5jdGlvbiBtaW5Cb2R5KHBheWxvYWQsIGpzb25CYWNrdXApIHtcbiAgdmFyIGJvZHkgPSBwYXlsb2FkLmRhdGEuYm9keTtcbiAgaWYgKGJvZHkudHJhY2VfY2hhaW4pIHtcbiAgICB2YXIgY2hhaW4gPSBib2R5LnRyYWNlX2NoYWluO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYWluW2ldID0gdHJ1bmNhdGVUcmFjZURhdGEoY2hhaW5baV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib2R5LnRyYWNlKSB7XG4gICAgYm9keS50cmFjZSA9IHRydW5jYXRlVHJhY2VEYXRhKGJvZHkudHJhY2UpO1xuICB9XG4gIHJldHVybiBbcGF5bG9hZCwgXy5zdHJpbmdpZnkocGF5bG9hZCwganNvbkJhY2t1cCldO1xufVxuXG5mdW5jdGlvbiBuZWVkc1RydW5jYXRpb24ocGF5bG9hZCwgbWF4U2l6ZSkge1xuICByZXR1cm4gXy5tYXhCeXRlU2l6ZShwYXlsb2FkKSA+IG1heFNpemU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHBheWxvYWQsIGpzb25CYWNrdXAsIG1heFNpemUpIHtcbiAgbWF4U2l6ZSA9IHR5cGVvZiBtYXhTaXplID09PSAndW5kZWZpbmVkJyA/IDUxMiAqIDEwMjQgOiBtYXhTaXplO1xuICB2YXIgc3RyYXRlZ2llcyA9IFtcbiAgICByYXcsXG4gICAgdHJ1bmNhdGVGcmFtZXMsXG4gICAgdHJ1bmNhdGVTdHJpbmdzLmJpbmQobnVsbCwgMTAyNCksXG4gICAgdHJ1bmNhdGVTdHJpbmdzLmJpbmQobnVsbCwgNTEyKSxcbiAgICB0cnVuY2F0ZVN0cmluZ3MuYmluZChudWxsLCAyNTYpLFxuICAgIG1pbkJvZHksXG4gIF07XG4gIHZhciBzdHJhdGVneSwgcmVzdWx0cywgcmVzdWx0O1xuXG4gIHdoaWxlICgoc3RyYXRlZ3kgPSBzdHJhdGVnaWVzLnNoaWZ0KCkpKSB7XG4gICAgcmVzdWx0cyA9IHN0cmF0ZWd5KHBheWxvYWQsIGpzb25CYWNrdXApO1xuICAgIHBheWxvYWQgPSByZXN1bHRzWzBdO1xuICAgIHJlc3VsdCA9IHJlc3VsdHNbMV07XG4gICAgaWYgKHJlc3VsdC5lcnJvciB8fCAhbmVlZHNUcnVuY2F0aW9uKHJlc3VsdC52YWx1ZSwgbWF4U2l6ZSkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG5cbiAgLyogZm9yIHRlc3RpbmcgKi9cbiAgcmF3OiByYXcsXG4gIHRydW5jYXRlRnJhbWVzOiB0cnVuY2F0ZUZyYW1lcyxcbiAgdHJ1bmNhdGVTdHJpbmdzOiB0cnVuY2F0ZVN0cmluZ3MsXG4gIG1heWJlVHJ1bmNhdGVWYWx1ZTogbWF5YmVUcnVuY2F0ZVZhbHVlLFxufTtcbiIsInZhciBtZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UnKTtcblxudmFyIFJvbGxiYXJKU09OID0ge307XG5mdW5jdGlvbiBzZXR1cEpTT04ocG9seWZpbGxKU09OKSB7XG4gIGlmIChpc0Z1bmN0aW9uKFJvbGxiYXJKU09OLnN0cmluZ2lmeSkgJiYgaXNGdW5jdGlvbihSb2xsYmFySlNPTi5wYXJzZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNEZWZpbmVkKEpTT04pKSB7XG4gICAgLy8gSWYgcG9seWZpbGwgaXMgcHJvdmlkZWQsIHByZWZlciBpdCBvdmVyIGV4aXN0aW5nIG5vbi1uYXRpdmUgc2hpbXMuXG4gICAgaWYgKHBvbHlmaWxsSlNPTikge1xuICAgICAgaWYgKGlzTmF0aXZlRnVuY3Rpb24oSlNPTi5zdHJpbmdpZnkpKSB7XG4gICAgICAgIFJvbGxiYXJKU09OLnN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgICAgfVxuICAgICAgaWYgKGlzTmF0aXZlRnVuY3Rpb24oSlNPTi5wYXJzZSkpIHtcbiAgICAgICAgUm9sbGJhckpTT04ucGFyc2UgPSBKU09OLnBhcnNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbHNlIGFjY2VwdCBhbnkgaW50ZXJmYWNlIHRoYXQgaXMgcHJlc2VudC5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKEpTT04uc3RyaW5naWZ5KSkge1xuICAgICAgICBSb2xsYmFySlNPTi5zdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Z1bmN0aW9uKEpTT04ucGFyc2UpKSB7XG4gICAgICAgIFJvbGxiYXJKU09OLnBhcnNlID0gSlNPTi5wYXJzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0Z1bmN0aW9uKFJvbGxiYXJKU09OLnN0cmluZ2lmeSkgfHwgIWlzRnVuY3Rpb24oUm9sbGJhckpTT04ucGFyc2UpKSB7XG4gICAgcG9seWZpbGxKU09OICYmIHBvbHlmaWxsSlNPTihSb2xsYmFySlNPTik7XG4gIH1cbn1cblxuLypcbiAqIGlzVHlwZSAtIEdpdmVuIGEgSmF2YXNjcmlwdCB2YWx1ZSBhbmQgYSBzdHJpbmcsIHJldHVybnMgdHJ1ZSBpZiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgbWF0Y2hlcyB0aGVcbiAqIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geCAtIGFueSB2YWx1ZVxuICogQHBhcmFtIHQgLSBhIGxvd2VyY2FzZSBzdHJpbmcgY29udGFpbmluZyBvbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlIG5hbWVzOlxuICogICAgLSB1bmRlZmluZWRcbiAqICAgIC0gbnVsbFxuICogICAgLSBlcnJvclxuICogICAgLSBudW1iZXJcbiAqICAgIC0gYm9vbGVhblxuICogICAgLSBzdHJpbmdcbiAqICAgIC0gc3ltYm9sXG4gKiAgICAtIGZ1bmN0aW9uXG4gKiAgICAtIG9iamVjdFxuICogICAgLSBhcnJheVxuICogQHJldHVybnMgdHJ1ZSBpZiB4IGlzIG9mIHR5cGUgdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZSh4LCB0KSB7XG4gIHJldHVybiB0ID09PSB0eXBlTmFtZSh4KTtcbn1cblxuLypcbiAqIHR5cGVOYW1lIC0gR2l2ZW4gYSBKYXZhc2NyaXB0IHZhbHVlLCByZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYXMgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gdHlwZU5hbWUoeCkge1xuICB2YXIgbmFtZSA9IHR5cGVvZiB4O1xuICBpZiAobmFtZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAoIXgpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh4IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuICByZXR1cm4ge30udG9TdHJpbmdcbiAgICAuY2FsbCh4KVxuICAgIC5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXVxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKiBpc0Z1bmN0aW9uIC0gYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGYgLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgZiBpcyBhIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmKSB7XG4gIHJldHVybiBpc1R5cGUoZiwgJ2Z1bmN0aW9uJyk7XG59XG5cbi8qIGlzTmF0aXZlRnVuY3Rpb24gLSBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIGEgbmF0aXZlIEpTIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGYgLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgZiBpcyBhIG5hdGl2ZSBKUyBmdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRnVuY3Rpb24oZikge1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuICB2YXIgZnVuY01hdGNoU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgLmNhbGwoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSlcbiAgICAucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKTtcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY01hdGNoU3RyaW5nICsgJyQnKTtcbiAgcmV0dXJuIGlzT2JqZWN0KGYpICYmIHJlSXNOYXRpdmUudGVzdChmKTtcbn1cblxuLyogaXNPYmplY3QgLSBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpcyB2YWx1ZSBpcyBhbiBvYmplY3QgZnVuY3Rpb24gaXMgYW4gb2JqZWN0KVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyogaXNTdHJpbmcgLSBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIGlzRmluaXRlTnVtYmVyIC0gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSBuIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZmluaXRlIG51bWJlclxuICovXG5mdW5jdGlvbiBpc0Zpbml0ZU51bWJlcihuKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobik7XG59XG5cbi8qXG4gKiBpc0RlZmluZWQgLSBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0gdSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB1IGlzIGFueXRoaW5nIG90aGVyIHRoYW4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGlzRGVmaW5lZCh1KSB7XG4gIHJldHVybiAhaXNUeXBlKHUsICd1bmRlZmluZWQnKTtcbn1cblxuLypcbiAqIGlzSXRlcmFibGUgLSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBjYW4gYmUgaXRlcmF0ZWQsIGVzc2VudGlhbGx5XG4gKiB3aGV0aGVyIGl0IGlzIGFuIG9iamVjdCBvciBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gaSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBpIGlzIGFuIG9iamVjdCBvciBhbiBhcnJheSBhcyBkZXRlcm1pbmVkIGJ5IGB0eXBlTmFtZWBcbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZShpKSB7XG4gIHZhciB0eXBlID0gdHlwZU5hbWUoaSk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnYXJyYXknO1xufVxuXG4vKlxuICogaXNFcnJvciAtIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIG9mIGFuIGVycm9yIHR5cGVcbiAqXG4gKiBAcGFyYW0gZSAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBlIGlzIGFuIGVycm9yXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAvLyBEZXRlY3QgYm90aCBFcnJvciBhbmQgRmlyZWZveCBFeGNlcHRpb24gdHlwZVxuICByZXR1cm4gaXNUeXBlKGUsICdlcnJvcicpIHx8IGlzVHlwZShlLCAnZXhjZXB0aW9uJyk7XG59XG5cbi8qIGlzUHJvbWlzZSAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgYSBwcm9taXNlXG4gKlxuICogQHBhcmFtIHAgLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgZiBpcyBhIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHApICYmIGlzVHlwZShwLnRoZW4sICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIGlzQnJvd3NlciAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIHRoZSBjb2RlIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY29kZSBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gcmVkYWN0KCkge1xuICByZXR1cm4gJyoqKioqKioqJztcbn1cblxuLy8gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84ODA5NDcyLzExMzgxOTFcbmZ1bmN0aW9uIHV1aWQ0KCkge1xuICB2YXIgZCA9IG5vdygpO1xuICB2YXIgdXVpZCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoXG4gICAgL1t4eV0vZyxcbiAgICBmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgICAgcmV0dXJuIChjID09PSAneCcgPyByIDogKHIgJiAweDcpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSxcbiAgKTtcbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBMRVZFTFMgPSB7XG4gIGRlYnVnOiAwLFxuICBpbmZvOiAxLFxuICB3YXJuaW5nOiAyLFxuICBlcnJvcjogMyxcbiAgY3JpdGljYWw6IDQsXG59O1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgdmFyIGJhc2VVcmxQYXJ0cyA9IHBhcnNlVXJpKHVybCk7XG4gIGlmICghYmFzZVVybFBhcnRzKSB7XG4gICAgcmV0dXJuICcodW5rbm93biknO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGEgdHJhaWxpbmcgIyBpZiB0aGVyZSBpcyBubyBhbmNob3JcbiAgaWYgKGJhc2VVcmxQYXJ0cy5hbmNob3IgPT09ICcnKSB7XG4gICAgYmFzZVVybFBhcnRzLnNvdXJjZSA9IGJhc2VVcmxQYXJ0cy5zb3VyY2UucmVwbGFjZSgnIycsICcnKTtcbiAgfVxuXG4gIHVybCA9IGJhc2VVcmxQYXJ0cy5zb3VyY2UucmVwbGFjZSgnPycgKyBiYXNlVXJsUGFydHMucXVlcnksICcnKTtcbiAgcmV0dXJuIHVybDtcbn1cblxudmFyIHBhcnNlVXJpT3B0aW9ucyA9IHtcbiAgc3RyaWN0TW9kZTogZmFsc2UsXG4gIGtleTogW1xuICAgICdzb3VyY2UnLFxuICAgICdwcm90b2NvbCcsXG4gICAgJ2F1dGhvcml0eScsXG4gICAgJ3VzZXJJbmZvJyxcbiAgICAndXNlcicsXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAnaG9zdCcsXG4gICAgJ3BvcnQnLFxuICAgICdyZWxhdGl2ZScsXG4gICAgJ3BhdGgnLFxuICAgICdkaXJlY3RvcnknLFxuICAgICdmaWxlJyxcbiAgICAncXVlcnknLFxuICAgICdhbmNob3InLFxuICBdLFxuICBxOiB7XG4gICAgbmFtZTogJ3F1ZXJ5S2V5JyxcbiAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZyxcbiAgfSxcbiAgcGFyc2VyOiB7XG4gICAgc3RyaWN0OlxuICAgICAgL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxcbiAgICBsb29zZTpcbiAgICAgIC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHBhcnNlVXJpKHN0cikge1xuICBpZiAoIWlzVHlwZShzdHIsICdzdHJpbmcnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgbyA9IHBhcnNlVXJpT3B0aW9ucztcbiAgdmFyIG0gPSBvLnBhcnNlcltvLnN0cmljdE1vZGUgPyAnc3RyaWN0JyA6ICdsb29zZSddLmV4ZWMoc3RyKTtcbiAgdmFyIHVyaSA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gby5rZXkubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgdXJpW28ua2V5W2ldXSA9IG1baV0gfHwgJyc7XG4gIH1cblxuICB1cmlbby5xLm5hbWVdID0ge307XG4gIHVyaVtvLmtleVsxMl1dLnJlcGxhY2Uoby5xLnBhcnNlciwgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICBpZiAoJDEpIHtcbiAgICAgIHVyaVtvLnEubmFtZV1bJDFdID0gJDI7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBhZGRQYXJhbXNBbmRBY2Nlc3NUb2tlblRvUGF0aChhY2Nlc3NUb2tlbiwgb3B0aW9ucywgcGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLmFjY2Vzc190b2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB2YXIgcGFyYW1zQXJyYXkgPSBbXTtcbiAgdmFyIGs7XG4gIGZvciAoayBpbiBwYXJhbXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgaykpIHtcbiAgICAgIHBhcmFtc0FycmF5LnB1c2goW2ssIHBhcmFtc1trXV0uam9pbignPScpKTtcbiAgICB9XG4gIH1cbiAgdmFyIHF1ZXJ5ID0gJz8nICsgcGFyYW1zQXJyYXkuc29ydCgpLmpvaW4oJyYnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8ICcnO1xuICB2YXIgcXMgPSBvcHRpb25zLnBhdGguaW5kZXhPZignPycpO1xuICB2YXIgaCA9IG9wdGlvbnMucGF0aC5pbmRleE9mKCcjJyk7XG4gIHZhciBwO1xuICBpZiAocXMgIT09IC0xICYmIChoID09PSAtMSB8fCBoID4gcXMpKSB7XG4gICAgcCA9IG9wdGlvbnMucGF0aDtcbiAgICBvcHRpb25zLnBhdGggPSBwLnN1YnN0cmluZygwLCBxcykgKyBxdWVyeSArICcmJyArIHAuc3Vic3RyaW5nKHFzICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGggIT09IC0xKSB7XG4gICAgICBwID0gb3B0aW9ucy5wYXRoO1xuICAgICAgb3B0aW9ucy5wYXRoID0gcC5zdWJzdHJpbmcoMCwgaCkgKyBxdWVyeSArIHAuc3Vic3RyaW5nKGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnBhdGggKyBxdWVyeTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0VXJsKHUsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wgfHwgdS5wcm90b2NvbDtcbiAgaWYgKCFwcm90b2NvbCAmJiB1LnBvcnQpIHtcbiAgICBpZiAodS5wb3J0ID09PSA4MCkge1xuICAgICAgcHJvdG9jb2wgPSAnaHR0cDonO1xuICAgIH0gZWxzZSBpZiAodS5wb3J0ID09PSA0NDMpIHtcbiAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgfVxuICB9XG4gIHByb3RvY29sID0gcHJvdG9jb2wgfHwgJ2h0dHBzOic7XG5cbiAgaWYgKCF1Lmhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgJy8vJyArIHUuaG9zdG5hbWU7XG4gIGlmICh1LnBvcnQpIHtcbiAgICByZXN1bHQgPSByZXN1bHQgKyAnOicgKyB1LnBvcnQ7XG4gIH1cbiAgaWYgKHUucGF0aCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIHUucGF0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBiYWNrdXApIHtcbiAgdmFyIHZhbHVlLCBlcnJvcjtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IFJvbGxiYXJKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGNhdGNoIChqc29uRXJyb3IpIHtcbiAgICBpZiAoYmFja3VwICYmIGlzRnVuY3Rpb24oYmFja3VwKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBiYWNrdXAob2JqKTtcbiAgICAgIH0gY2F0Y2ggKGJhY2t1cEVycm9yKSB7XG4gICAgICAgIGVycm9yID0gYmFja3VwRXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yID0ganNvbkVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBlcnJvcjogZXJyb3IsIHZhbHVlOiB2YWx1ZSB9O1xufVxuXG5mdW5jdGlvbiBtYXhCeXRlU2l6ZShzdHJpbmcpIHtcbiAgLy8gVGhlIHRyYW5zcG9ydCB3aWxsIHVzZSB1dGYtOCwgc28gYXNzdW1lIHV0Zi04IGVuY29kaW5nLlxuICAvL1xuICAvLyBUaGlzIG1pbmltYWwgaW1wbGVtZW50YXRpb24gd2lsbCBhY2N1cmF0ZWx5IGNvdW50IGJ5dGVzIGZvciBhbGwgVUNTLTIgYW5kXG4gIC8vIHNpbmdsZSBjb2RlIHBvaW50IFVURi0xNi4gSWYgcHJlc2VudGVkIHdpdGggbXVsdGkgY29kZSBwb2ludCBVVEYtMTYsXG4gIC8vIHdoaWNoIHNob3VsZCBiZSByYXJlLCBpdCB3aWxsIHNhZmVseSBvdmVyY291bnQsIG5vdCB1bmRlcmNvdW50LlxuICAvL1xuICAvLyBXaGlsZSByb2J1c3QgdXRmLTggZW5jb2RlcnMgZXhpc3QsIHRoaXMgaXMgZmFyIHNtYWxsZXIgYW5kIGZhciBtb3JlIHBlcmZvcm1hbnQuXG4gIC8vIEZvciBxdWlja2x5IGNvdW50aW5nIHBheWxvYWQgc2l6ZSBmb3IgdHJ1bmNhdGlvbiwgc21hbGxlciBpcyBiZXR0ZXIuXG5cbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIC8vIHVwIHRvIDcgYml0c1xuICAgICAgY291bnQgPSBjb3VudCArIDE7XG4gICAgfSBlbHNlIGlmIChjb2RlIDwgMjA0OCkge1xuICAgICAgLy8gdXAgdG8gMTEgYml0c1xuICAgICAgY291bnQgPSBjb3VudCArIDI7XG4gICAgfSBlbHNlIGlmIChjb2RlIDwgNjU1MzYpIHtcbiAgICAgIC8vIHVwIHRvIDE2IGJpdHNcbiAgICAgIGNvdW50ID0gY291bnQgKyAzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24ganNvblBhcnNlKHMpIHtcbiAgdmFyIHZhbHVlLCBlcnJvcjtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IFJvbGxiYXJKU09OLnBhcnNlKHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiB7IGVycm9yOiBlcnJvciwgdmFsdWU6IHZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VVbmhhbmRsZWRTdGFja0luZm8oXG4gIG1lc3NhZ2UsXG4gIHVybCxcbiAgbGluZW5vLFxuICBjb2xubyxcbiAgZXJyb3IsXG4gIG1vZGUsXG4gIGJhY2t1cE1lc3NhZ2UsXG4gIGVycm9yUGFyc2VyLFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IHtcbiAgICB1cmw6IHVybCB8fCAnJyxcbiAgICBsaW5lOiBsaW5lbm8sXG4gICAgY29sdW1uOiBjb2xubyxcbiAgfTtcbiAgbG9jYXRpb24uZnVuYyA9IGVycm9yUGFyc2VyLmd1ZXNzRnVuY3Rpb25OYW1lKGxvY2F0aW9uLnVybCwgbG9jYXRpb24ubGluZSk7XG4gIGxvY2F0aW9uLmNvbnRleHQgPSBlcnJvclBhcnNlci5nYXRoZXJDb250ZXh0KGxvY2F0aW9uLnVybCwgbG9jYXRpb24ubGluZSk7XG4gIHZhciBocmVmID1cbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgZG9jdW1lbnQgJiZcbiAgICBkb2N1bWVudC5sb2NhdGlvbiAmJlxuICAgIGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gIHZhciB1c2VyYWdlbnQgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93ICYmXG4gICAgd2luZG93Lm5hdmlnYXRvciAmJlxuICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4ge1xuICAgIG1vZGU6IG1vZGUsXG4gICAgbWVzc2FnZTogZXJyb3IgPyBTdHJpbmcoZXJyb3IpIDogbWVzc2FnZSB8fCBiYWNrdXBNZXNzYWdlLFxuICAgIHVybDogaHJlZixcbiAgICBzdGFjazogW2xvY2F0aW9uXSxcbiAgICB1c2VyYWdlbnQ6IHVzZXJhZ2VudCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gd3JhcENhbGxiYWNrKGxvZ2dlciwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuICAgIHRyeSB7XG4gICAgICBmKGVyciwgcmVzcCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9uQ2lyY3VsYXJDbG9uZShvYmopIHtcbiAgdmFyIHNlZW4gPSBbb2JqXTtcblxuICBmdW5jdGlvbiBjbG9uZShvYmosIHNlZW4pIHtcbiAgICB2YXIgdmFsdWUsXG4gICAgICBuYW1lLFxuICAgICAgbmV3U2VlbixcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIChpc1R5cGUodmFsdWUsICdvYmplY3QnKSB8fCBpc1R5cGUodmFsdWUsICdhcnJheScpKSkge1xuICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gJ1JlbW92ZWQgY2lyY3VsYXIgcmVmZXJlbmNlOiAnICsgdHlwZU5hbWUodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTZWVuID0gc2Vlbi5zbGljZSgpO1xuICAgICAgICAgICAgbmV3U2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IGNsb25lKHZhbHVlLCBuZXdTZWVuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSAnRmFpbGVkIGNsb25pbmcgY3VzdG9tIGRhdGE6ICcgKyBlLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGNsb25lKG9iaiwgc2Vlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZW0oYXJncywgbG9nZ2VyLCBub3RpZmllciwgcmVxdWVzdEtleXMsIGxhbWJkYUNvbnRleHQpIHtcbiAgdmFyIG1lc3NhZ2UsIGVyciwgY3VzdG9tLCBjYWxsYmFjaywgcmVxdWVzdDtcbiAgdmFyIGFyZztcbiAgdmFyIGV4dHJhQXJncyA9IFtdO1xuICB2YXIgZGlhZ25vc3RpYyA9IHt9O1xuICB2YXIgYXJnVHlwZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgYXJnID0gYXJnc1tpXTtcblxuICAgIHZhciB0eXAgPSB0eXBlTmFtZShhcmcpO1xuICAgIGFyZ1R5cGVzLnB1c2godHlwKTtcbiAgICBzd2l0Y2ggKHR5cCkge1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBtZXNzYWdlID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IChtZXNzYWdlID0gYXJnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGNhbGxiYWNrID0gd3JhcENhbGxiYWNrKGxvZ2dlciwgYXJnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgZXh0cmFBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICBjYXNlICdkb21leGNlcHRpb24nOlxuICAgICAgY2FzZSAnZXhjZXB0aW9uJzogLy8gRmlyZWZveCBFeGNlcHRpb24gdHlwZVxuICAgICAgICBlcnIgPyBleHRyYUFyZ3MucHVzaChhcmcpIDogKGVyciA9IGFyZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFyZyBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICAgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnICYmIGFyZyBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXJyID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IChlcnIgPSBhcmcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0S2V5cyAmJiB0eXAgPT09ICdvYmplY3QnICYmICFyZXF1ZXN0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHJlcXVlc3RLZXlzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICBpZiAoYXJnW3JlcXVlc3RLZXlzW2pdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBhcmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1c3RvbSA/IGV4dHJhQXJncy5wdXNoKGFyZykgOiAoY3VzdG9tID0gYXJnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXJnIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgICAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICBlcnIgPyBleHRyYUFyZ3MucHVzaChhcmcpIDogKGVyciA9IGFyZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFBcmdzLnB1c2goYXJnKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBjdXN0b20gaXMgYW4gYXJyYXkgdGhpcyB0dXJucyBpdCBpbnRvIGFuIG9iamVjdCB3aXRoIGludGVnZXIga2V5c1xuICBpZiAoY3VzdG9tKSBjdXN0b20gPSBub25DaXJjdWxhckNsb25lKGN1c3RvbSk7XG5cbiAgaWYgKGV4dHJhQXJncy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCFjdXN0b20pIGN1c3RvbSA9IG5vbkNpcmN1bGFyQ2xvbmUoe30pO1xuICAgIGN1c3RvbS5leHRyYUFyZ3MgPSBub25DaXJjdWxhckNsb25lKGV4dHJhQXJncyk7XG4gIH1cblxuICB2YXIgaXRlbSA9IHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGVycjogZXJyLFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIHRpbWVzdGFtcDogbm93KCksXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIG5vdGlmaWVyOiBub3RpZmllcixcbiAgICBkaWFnbm9zdGljOiBkaWFnbm9zdGljLFxuICAgIHV1aWQ6IHV1aWQ0KCksXG4gIH07XG5cbiAgaXRlbS5kYXRhID0gaXRlbS5kYXRhIHx8IHt9O1xuXG4gIHNldEN1c3RvbUl0ZW1LZXlzKGl0ZW0sIGN1c3RvbSk7XG5cbiAgaWYgKHJlcXVlc3RLZXlzICYmIHJlcXVlc3QpIHtcbiAgICBpdGVtLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB9XG4gIGlmIChsYW1iZGFDb250ZXh0KSB7XG4gICAgaXRlbS5sYW1iZGFDb250ZXh0ID0gbGFtYmRhQ29udGV4dDtcbiAgfVxuICBpdGVtLl9vcmlnaW5hbEFyZ3MgPSBhcmdzO1xuICBpdGVtLmRpYWdub3N0aWMub3JpZ2luYWxfYXJnX3R5cGVzID0gYXJnVHlwZXM7XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBzZXRDdXN0b21JdGVtS2V5cyhpdGVtLCBjdXN0b20pIHtcbiAgaWYgKGN1c3RvbSAmJiBjdXN0b20ubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGl0ZW0ubGV2ZWwgPSBjdXN0b20ubGV2ZWw7XG4gICAgZGVsZXRlIGN1c3RvbS5sZXZlbDtcbiAgfVxuICBpZiAoY3VzdG9tICYmIGN1c3RvbS5za2lwRnJhbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpdGVtLnNraXBGcmFtZXMgPSBjdXN0b20uc2tpcEZyYW1lcztcbiAgICBkZWxldGUgY3VzdG9tLnNraXBGcmFtZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JDb250ZXh0KGl0ZW0sIGVycm9ycykge1xuICB2YXIgY3VzdG9tID0gaXRlbS5kYXRhLmN1c3RvbSB8fCB7fTtcbiAgdmFyIGNvbnRleHRBZGRlZCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChlcnJvcnNbaV0uaGFzT3duUHJvcGVydHkoJ3JvbGxiYXJDb250ZXh0JykpIHtcbiAgICAgICAgY3VzdG9tID0gbWVyZ2UoY3VzdG9tLCBub25DaXJjdWxhckNsb25lKGVycm9yc1tpXS5yb2xsYmFyQ29udGV4dCkpO1xuICAgICAgICBjb250ZXh0QWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF2b2lkIGFkZGluZyBhbiBlbXB0eSBvYmplY3QgdG8gdGhlIGRhdGEuXG4gICAgaWYgKGNvbnRleHRBZGRlZCkge1xuICAgICAgaXRlbS5kYXRhLmN1c3RvbSA9IGN1c3RvbTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpdGVtLmRpYWdub3N0aWMuZXJyb3JfY29udGV4dCA9ICdGYWlsZWQ6ICcgKyBlLm1lc3NhZ2U7XG4gIH1cbn1cblxudmFyIFRFTEVNRVRSWV9UWVBFUyA9IFtcbiAgJ2xvZycsXG4gICduZXR3b3JrJyxcbiAgJ2RvbScsXG4gICduYXZpZ2F0aW9uJyxcbiAgJ2Vycm9yJyxcbiAgJ21hbnVhbCcsXG5dO1xudmFyIFRFTEVNRVRSWV9MRVZFTFMgPSBbJ2NyaXRpY2FsJywgJ2Vycm9yJywgJ3dhcm5pbmcnLCAnaW5mbycsICdkZWJ1ZyddO1xuXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgYXJyLmxlbmd0aDsgKytrKSB7XG4gICAgaWYgKGFycltrXSA9PT0gdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRlbGVtZXRyeUV2ZW50KGFyZ3MpIHtcbiAgdmFyIHR5cGUsIG1ldGFkYXRhLCBsZXZlbDtcbiAgdmFyIGFyZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgYXJnID0gYXJnc1tpXTtcblxuICAgIHZhciB0eXAgPSB0eXBlTmFtZShhcmcpO1xuICAgIHN3aXRjaCAodHlwKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpZiAoIXR5cGUgJiYgYXJyYXlJbmNsdWRlcyhURUxFTUVUUllfVFlQRVMsIGFyZykpIHtcbiAgICAgICAgICB0eXBlID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKCFsZXZlbCAmJiBhcnJheUluY2x1ZGVzKFRFTEVNRVRSWV9MRVZFTFMsIGFyZykpIHtcbiAgICAgICAgICBsZXZlbCA9IGFyZztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIG1ldGFkYXRhID0gYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgZXZlbnQgPSB7XG4gICAgdHlwZTogdHlwZSB8fCAnbWFudWFsJyxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGEgfHwge30sXG4gICAgbGV2ZWw6IGxldmVsLFxuICB9O1xuXG4gIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gYWRkSXRlbUF0dHJpYnV0ZXMoaXRlbSwgYXR0cmlidXRlcykge1xuICBpdGVtLmRhdGEuYXR0cmlidXRlcyA9IGl0ZW0uZGF0YS5hdHRyaWJ1dGVzIHx8IFtdO1xuICBpZiAoYXR0cmlidXRlcykge1xuICAgIGl0ZW0uZGF0YS5hdHRyaWJ1dGVzLnB1c2goLi4uYXR0cmlidXRlcyk7XG4gIH1cbn1cblxuLypcbiAqIGdldCAtIGdpdmVuIGFuIG9iai9hcnJheSBhbmQgYSBrZXlwYXRoLCByZXR1cm4gdGhlIHZhbHVlIGF0IHRoYXQga2V5cGF0aCBvclxuICogICAgICAgdW5kZWZpbmVkIGlmIG5vdCBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9yIGFycmF5XG4gKiBAcGFyYW0gcGF0aCAtIGEgc3RyaW5nIG9mIGtleXMgc2VwYXJhdGVkIGJ5ICcuJyBzdWNoIGFzICdwbHVnaW4uanF1ZXJ5LjAubWVzc2FnZSdcbiAqICAgIHdoaWNoIHdvdWxkIGNvcnJlc3BvbmQgdG8gNDIgaW4gYHtwbHVnaW46IHtqcXVlcnk6IFt7bWVzc2FnZTogNDJ9XX19YFxuICovXG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIHJlc3VsdCA9IG9iajtcbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0W2tleXNbaV1dO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZXQob2JqLCBwYXRoLCB2YWx1ZSkge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuIDwgMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobGVuID09PSAxKSB7XG4gICAgb2JqW2tleXNbMF1dID0gdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIHRlbXAgPSBvYmpba2V5c1swXV0gfHwge307XG4gICAgdmFyIHJlcGxhY2VtZW50ID0gdGVtcDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgICAgdGVtcFtrZXlzW2ldXSA9IHRlbXBba2V5c1tpXV0gfHwge307XG4gICAgICB0ZW1wID0gdGVtcFtrZXlzW2ldXTtcbiAgICB9XG4gICAgdGVtcFtrZXlzW2xlbiAtIDFdXSA9IHZhbHVlO1xuICAgIG9ialtrZXlzWzBdXSA9IHJlcGxhY2VtZW50O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3NBc1N0cmluZyhhcmdzKSB7XG4gIHZhciBpLCBsZW4sIGFyZztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJnID0gYXJnc1tpXTtcbiAgICBzd2l0Y2ggKHR5cGVOYW1lKGFyZykpIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGFyZyA9IHN0cmluZ2lmeShhcmcpO1xuICAgICAgICBhcmcgPSBhcmcuZXJyb3IgfHwgYXJnLnZhbHVlO1xuICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDUwMCkge1xuICAgICAgICAgIGFyZyA9IGFyZy5zdWJzdHIoMCwgNDk3KSArICcuLi4nO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIGFyZyA9ICdudWxsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBhcmcgPSAndW5kZWZpbmVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICBhcmcgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGFyZyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgaWYgKERhdGUubm93KSB7XG4gICAgcmV0dXJuICtEYXRlLm5vdygpO1xuICB9XG4gIHJldHVybiArbmV3IERhdGUoKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVySXAocmVxdWVzdERhdGEsIGNhcHR1cmVJcCkge1xuICBpZiAoIXJlcXVlc3REYXRhIHx8ICFyZXF1ZXN0RGF0YVsndXNlcl9pcCddIHx8IGNhcHR1cmVJcCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3SXAgPSByZXF1ZXN0RGF0YVsndXNlcl9pcCddO1xuICBpZiAoIWNhcHR1cmVJcCkge1xuICAgIG5ld0lwID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHBhcnRzO1xuICAgICAgaWYgKG5ld0lwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgcGFydHMgPSBuZXdJcC5zcGxpdCgnLicpO1xuICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgcGFydHMucHVzaCgnMCcpO1xuICAgICAgICBuZXdJcCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3SXAuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgICAgICBwYXJ0cyA9IG5ld0lwLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFyIGJlZ2lubmluZyA9IHBhcnRzLnNsaWNlKDAsIDMpO1xuICAgICAgICAgIHZhciBzbGFzaElkeCA9IGJlZ2lubmluZ1syXS5pbmRleE9mKCcvJyk7XG4gICAgICAgICAgaWYgKHNsYXNoSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgYmVnaW5uaW5nWzJdID0gYmVnaW5uaW5nWzJdLnN1YnN0cmluZygwLCBzbGFzaElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0ZXJtaW5hbCA9ICcwMDAwOjAwMDA6MDAwMDowMDAwOjAwMDAnO1xuICAgICAgICAgIG5ld0lwID0gYmVnaW5uaW5nLmNvbmNhdCh0ZXJtaW5hbCkuam9pbignOicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdJcCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3SXAgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXF1ZXN0RGF0YVsndXNlcl9pcCddID0gbmV3SXA7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU9wdGlvbnMoY3VycmVudCwgaW5wdXQsIHBheWxvYWQsIGxvZ2dlcikge1xuICB2YXIgcmVzdWx0ID0gbWVyZ2UoY3VycmVudCwgaW5wdXQsIHBheWxvYWQpO1xuICByZXN1bHQgPSB1cGRhdGVEZXByZWNhdGVkT3B0aW9ucyhyZXN1bHQsIGxvZ2dlcik7XG4gIGlmICghaW5wdXQgfHwgaW5wdXQub3ZlcndyaXRlU2NydWJGaWVsZHMpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpbnB1dC5zY3J1YkZpZWxkcykge1xuICAgIHJlc3VsdC5zY3J1YkZpZWxkcyA9IChjdXJyZW50LnNjcnViRmllbGRzIHx8IFtdKS5jb25jYXQoaW5wdXQuc2NydWJGaWVsZHMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlcHJlY2F0ZWRPcHRpb25zKG9wdGlvbnMsIGxvZ2dlcikge1xuICBpZiAob3B0aW9ucy5ob3N0V2hpdGVMaXN0ICYmICFvcHRpb25zLmhvc3RTYWZlTGlzdCkge1xuICAgIG9wdGlvbnMuaG9zdFNhZmVMaXN0ID0gb3B0aW9ucy5ob3N0V2hpdGVMaXN0O1xuICAgIG9wdGlvbnMuaG9zdFdoaXRlTGlzdCA9IHVuZGVmaW5lZDtcbiAgICBsb2dnZXIgJiYgbG9nZ2VyLmxvZygnaG9zdFdoaXRlTGlzdCBpcyBkZXByZWNhdGVkLiBVc2UgaG9zdFNhZmVMaXN0LicpO1xuICB9XG4gIGlmIChvcHRpb25zLmhvc3RCbGFja0xpc3QgJiYgIW9wdGlvbnMuaG9zdEJsb2NrTGlzdCkge1xuICAgIG9wdGlvbnMuaG9zdEJsb2NrTGlzdCA9IG9wdGlvbnMuaG9zdEJsYWNrTGlzdDtcbiAgICBvcHRpb25zLmhvc3RCbGFja0xpc3QgPSB1bmRlZmluZWQ7XG4gICAgbG9nZ2VyICYmIGxvZ2dlci5sb2coJ2hvc3RCbGFja0xpc3QgaXMgZGVwcmVjYXRlZC4gVXNlIGhvc3RCbG9ja0xpc3QuJyk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRQYXJhbXNBbmRBY2Nlc3NUb2tlblRvUGF0aDogYWRkUGFyYW1zQW5kQWNjZXNzVG9rZW5Ub1BhdGgsXG4gIGNyZWF0ZUl0ZW06IGNyZWF0ZUl0ZW0sXG4gIGFkZEVycm9yQ29udGV4dDogYWRkRXJyb3JDb250ZXh0LFxuICBjcmVhdGVUZWxlbWV0cnlFdmVudDogY3JlYXRlVGVsZW1ldHJ5RXZlbnQsXG4gIGFkZEl0ZW1BdHRyaWJ1dGVzOiBhZGRJdGVtQXR0cmlidXRlcyxcbiAgZmlsdGVySXA6IGZpbHRlcklwLFxuICBmb3JtYXRBcmdzQXNTdHJpbmc6IGZvcm1hdEFyZ3NBc1N0cmluZyxcbiAgZm9ybWF0VXJsOiBmb3JtYXRVcmwsXG4gIGdldDogZ2V0LFxuICBoYW5kbGVPcHRpb25zOiBoYW5kbGVPcHRpb25zLFxuICBpc0Vycm9yOiBpc0Vycm9yLFxuICBpc0Zpbml0ZU51bWJlcjogaXNGaW5pdGVOdW1iZXIsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzSXRlcmFibGU6IGlzSXRlcmFibGUsXG4gIGlzTmF0aXZlRnVuY3Rpb246IGlzTmF0aXZlRnVuY3Rpb24sXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc1R5cGU6IGlzVHlwZSxcbiAgaXNQcm9taXNlOiBpc1Byb21pc2UsXG4gIGlzQnJvd3NlcjogaXNCcm93c2VyLFxuICBqc29uUGFyc2U6IGpzb25QYXJzZSxcbiAgTEVWRUxTOiBMRVZFTFMsXG4gIG1ha2VVbmhhbmRsZWRTdGFja0luZm86IG1ha2VVbmhhbmRsZWRTdGFja0luZm8sXG4gIG1lcmdlOiBtZXJnZSxcbiAgbm93OiBub3csXG4gIHJlZGFjdDogcmVkYWN0LFxuICBSb2xsYmFySlNPTjogUm9sbGJhckpTT04sXG4gIHNhbml0aXplVXJsOiBzYW5pdGl6ZVVybCxcbiAgc2V0OiBzZXQsXG4gIHNldHVwSlNPTjogc2V0dXBKU09OLFxuICBzdHJpbmdpZnk6IHN0cmluZ2lmeSxcbiAgbWF4Qnl0ZVNpemU6IG1heEJ5dGVTaXplLFxuICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gIHV1aWQ0OiB1dWlkNCxcbn07XG4iLCIvKlxuICogaGVhZGVycyAtIERldGVjdCB3aGVuIGZldGNoIEhlYWRlcnMgYXJlIHVuZGVmaW5lZCBhbmQgdXNlIGEgcGFydGlhbCBwb2x5ZmlsbC5cbiAqXG4gKiBBIGZ1bGwgcG9seWZpbGwgaXMgbm90IHVzZWQgaW4gb3JkZXIgdG8ga2VlcCBwYWNrYWdlIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGUuXG4gKiBTaW5jZSB0aGlzIGlzIG9ubHkgdXNlZCBpbnRlcm5hbGx5IGFuZCBpcyBub3QgYWRkZWQgdG8gdGhlIHdpbmRvdyBvYmplY3QsXG4gKiB0aGUgZnVsbCBpbnRlcmZhY2UgZG9lc24ndCBuZWVkIHRvIGJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIG1vZGlmaWVkIGZyb20gd2hhdHdnLWZldGNoOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaFxuICovXG5mdW5jdGlvbiBoZWFkZXJzKGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiBIZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgRmV0Y2hIZWFkZXJzKGhlYWRlcnMpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgIHJldHVybiB7IGRvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBGZXRjaEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9O1xuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgRmV0Y2hIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxufVxuXG5GZXRjaEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbn07XG5cbkZldGNoSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbDtcbn07XG5cbkZldGNoSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpO1xufTtcblxuRmV0Y2hIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuRmV0Y2hIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoZWFkZXJzO1xuIiwidmFyIHBvbHlmaWxsSlNPTiA9IHJlcXVpcmUoJy4uLy4uL3ZlbmRvci9KU09OLWpzL2pzb24zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGxKU09OO1xuIiwiZnVuY3Rpb24gcmVwbGFjZShvYmosIG5hbWUsIHJlcGxhY2VtZW50LCByZXBsYWNlbWVudHMsIHR5cGUpIHtcbiAgdmFyIG9yaWcgPSBvYmpbbmFtZV07XG4gIG9ialtuYW1lXSA9IHJlcGxhY2VtZW50KG9yaWcpO1xuICBpZiAocmVwbGFjZW1lbnRzKSB7XG4gICAgcmVwbGFjZW1lbnRzW3R5cGVdLnB1c2goW29iaiwgbmFtZSwgb3JpZ10pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGFjZTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbGl0eScpO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZShvYmosIGZ1bmMsIHNlZW4pIHtcbiAgdmFyIGssIHYsIGk7XG4gIHZhciBpc09iaiA9IF8uaXNUeXBlKG9iaiwgJ29iamVjdCcpO1xuICB2YXIgaXNBcnJheSA9IF8uaXNUeXBlKG9iaiwgJ2FycmF5Jyk7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciBzZWVuSW5kZXg7XG5cbiAgLy8gQmVzdCBtaWdodCBiZSB0byB1c2UgTWFwIGhlcmUgd2l0aCBgb2JqYCBhcyB0aGUga2V5cywgYnV0IHdlIHdhbnQgdG8gc3VwcG9ydCBJRSA8IDExLlxuICBzZWVuID0gc2VlbiB8fCB7IG9iajogW10sIG1hcHBlZDogW10gfTtcblxuICBpZiAoaXNPYmopIHtcbiAgICBzZWVuSW5kZXggPSBzZWVuLm9iai5pbmRleE9mKG9iaik7XG5cbiAgICBpZiAoaXNPYmogJiYgc2VlbkluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gUHJlZmVyIHRoZSBtYXBwZWQgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgIHJldHVybiBzZWVuLm1hcHBlZFtzZWVuSW5kZXhdIHx8IHNlZW4ub2JqW3NlZW5JbmRleF07XG4gICAgfVxuXG4gICAgc2Vlbi5vYmoucHVzaChvYmopO1xuICAgIHNlZW5JbmRleCA9IHNlZW4ub2JqLmxlbmd0aCAtIDE7XG4gIH1cblxuICBpZiAoaXNPYmopIHtcbiAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAga2V5cy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSBpc09iaiA/IHt9IDogW107XG4gIHZhciBzYW1lID0gdHJ1ZTtcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBrID0ga2V5c1tpXTtcbiAgICB2ID0gb2JqW2tdO1xuICAgIHJlc3VsdFtrXSA9IGZ1bmMoaywgdiwgc2Vlbik7XG4gICAgc2FtZSA9IHNhbWUgJiYgcmVzdWx0W2tdID09PSBvYmpba107XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXNhbWUpIHtcbiAgICBzZWVuLm1hcHBlZFtzZWVuSW5kZXhdID0gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuICFzYW1lID8gcmVzdWx0IDogb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlO1xuIiwiLy8gIGpzb24zLmpzXG4vLyAgMjAxNy0wMi0yMVxuLy8gIFB1YmxpYyBEb21haW4uXG4vLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuLy8gIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcbi8vICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuLy8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuLy8gIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4vLyAgTk9UIENPTlRST0wuXG5cbi8vICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbi8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cbi8vICBJZiBhIHByb2plY3QgbWlnaHQgcnVuIG9uIElFOCBvciBlYXJsaWVyLCB0aGVuIHRoaXMgZmlsZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4vLyAgVGhpcyBmaWxlIGRvZXMgbm90aGluZyBvbiBFUzUgc3lzdGVtcy5cblxuLy8gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuLy8gICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuLy8gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbi8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuLy8gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzIFwiXFx0XCIgb3IgXCImbmJzcDtcIiksXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG4vLyAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuLy8gICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbi8vICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbi8vICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuLy8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4vLyAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWUuXG5cbi8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuLy8gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuIDwgMTApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA6IG47XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArIFwiVFwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArIFwiWlwiO1xuLy8gICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuLy8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4vLyAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuLy8gICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4vLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4vLyAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuLy8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuLy8gICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4vLyAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3Jcbi8vICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4vLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcbi8vICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuXG4vLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuLy8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuLy8gICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbi8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbi8vICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4vLyAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlXG4vLyAgICAgICAgICAgICAgICAgID8gXCJEYXRlKFwiICsgdGhpc1trZXldICsgXCIpXCJcbi8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG4vLyAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cbi8vICAgICAgICAgIFRoaXMgaGFzIGJlZW4gbW9kaWZpZWQgdG8gdXNlIEpTT04tanMvanNvbl9wYXJzZV9zdGF0ZS5qcyBhcyB0aGVcbi8vICAgICAgICAgIHBhcnNlciBpbnN0ZWFkIG9mIHRoZSBvbmUgYnVpbHQgYXJvdW5kIGV2YWwgZm91bmQgaW4gSlNPTi1qcy9qc29uMi5qc1xuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4vLyAgICAgICAgICB0cmFuc2Zvcm0gdGhlIHJlc3VsdHMuIEl0IHJlY2VpdmVzIGVhY2ggb2YgdGhlIGtleXMgYW5kIHZhbHVlcyxcbi8vICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4vLyAgICAgICAgICBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4vLyAgICAgICAgICBJZiBpdCByZXR1cm5zIHVuZGVmaW5lZCB0aGVuIHRoZSBtZW1iZXIgaXMgZGVsZXRlZC5cblxuLy8gICAgICAgICAgRXhhbXBsZTpcblxuLy8gICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbi8vICAgICAgICAgIC8vIGJlIGNvbnZlcnRlZCB0byBEYXRlIG9iamVjdHMuXG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbi8vICAgICAgICAgICAgICB2YXIgYTtcbi8vICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4vLyAgICAgICAgICAgICAgICAgIGEgPVxuLy8gICAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pVChcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0oPzpcXC5cXGQqKT8pWiQvLmV4ZWModmFsdWUpO1xuLy8gICAgICAgICAgICAgICAgICBpZiAoYSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKCthWzFdLCArYVsyXSAtIDEsICthWzNdLCArYVs0XSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICArYVs1XSwgK2FbNl0pKTtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSgnW1wiRGF0ZSgwOS8wOS8yMDAxKVwiXScsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGQ7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgNSkgPT09IFwiRGF0ZShcIiAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTEpID09PSBcIilcIikge1xuLy8gICAgICAgICAgICAgICAgICBkID0gbmV3IERhdGUodmFsdWUuc2xpY2UoNSwgLTEpKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuLy8gICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuXG4vLyAgVGhpcyBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi4gWW91IGFyZSBmcmVlIHRvIGNvcHksIG1vZGlmeSwgb3Jcbi8vICByZWRpc3RyaWJ1dGUuXG5cbi8qanNsaW50XG4gIGZvciwgdGhpc1xuICAqL1xuXG4vKnByb3BlcnR5XG4gIEpTT04sIGFwcGx5LCBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gIGdldFVUQ01pbnV0ZXMsIGdldFVUQ01vbnRoLCBnZXRVVENTZWNvbmRzLCBoYXNPd25Qcm9wZXJ0eSwgam9pbixcbiAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG4gIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiAgKi9cblxudmFyIHNldHVwQ3VzdG9tSlNPTiA9IGZ1bmN0aW9uKEpTT04pIHtcblxuICB2YXIgcnhfb25lID0gL15bXFxdLDp7fVxcc10qJC87XG4gIHZhciByeF90d28gPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xuICB2YXIgcnhfdGhyZWUgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG4gIHZhciByeF9mb3VyID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xuICB2YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbiAgdmFyIHJ4X2Rhbmdlcm91cyA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuXG4gIGZ1bmN0aW9uIGYobikge1xuICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgcmV0dXJuIG4gPCAxMFxuICAgICAgPyBcIjBcIiArIG5cbiAgICAgIDogbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRoaXNfdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICByZXR1cm4gaXNGaW5pdGUodGhpcy52YWx1ZU9mKCkpXG4gICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSArIFwiVFwiICtcbiAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICtcbiAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgKyBcIlpcIlxuICAgICAgICA6IG51bGw7XG4gICAgfTtcblxuICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgIFN0cmluZy5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgfVxuXG4gIHZhciBnYXA7XG4gIHZhciBpbmRlbnQ7XG4gIHZhciBtZXRhO1xuICB2YXIgcmVwO1xuXG5cbiAgZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG5cbiAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbiAgICAvLyBzZXF1ZW5jZXMuXG5cbiAgICByeF9lc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgPyBcIlxcXCJcIiArIHN0cmluZy5yZXBsYWNlKHJ4X2VzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICA/IGNcbiAgICAgICAgICA6IFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgIH0pICsgXCJcXFwiXCJcbiAgICA6IFwiXFxcIlwiICsgc3RyaW5nICsgXCJcXFwiXCI7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXG4gICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgdmFyIGs7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgIHZhciB2OyAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgIHZhciBsZW5ndGg7XG4gICAgdmFyIG1pbmQgPSBnYXA7XG4gICAgdmFyIHBhcnRpYWw7XG4gICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcblxuICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpXG4gICAgICAgICAgPyBTdHJpbmcodmFsdWUpXG4gICAgICAgICAgOiBcIm51bGxcIjtcblxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGNhc2UgXCJudWxsXCI6XG5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlIFwibnVsbFwiLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgXCJvYmplY3RcIiwgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuICAgICAgICAvLyBudWxsLlxuXG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG5cbiAgICAgICAgLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsXG4gICAgICAgIC8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4gICAgICAgIC8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXG4gICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgIC8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCBcIm51bGxcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuICAgICAgICAgIC8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IFwiW11cIlxuICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgID8gXCJbXFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIl1cIlxuICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgPyBcIjogXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCI6XCJcbiAgICAgICAgICAgICAgICAgICAgICApICsgdik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMFxuICAgICAgICAgID8gXCJ7fVwiXG4gICAgICAgICAgOiBnYXBcbiAgICAgICAgICA/IFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCJcbiAgICAgICAgICA6IFwie1wiICsgcGFydGlhbC5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBzdHJpbmdpZnkgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgXCJcXGJcIjogXCJcXFxcYlwiLFxuICAgICAgXCJcXHRcIjogXCJcXFxcdFwiLFxuICAgICAgXCJcXG5cIjogXCJcXFxcblwiLFxuICAgICAgXCJcXGZcIjogXCJcXFxcZlwiLFxuICAgICAgXCJcXHJcIjogXCJcXFxcclwiLFxuICAgICAgXCJcXFwiXCI6IFwiXFxcXFxcXCJcIixcbiAgICAgIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCJcbiAgICB9O1xuICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuICAgICAgLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuICAgICAgLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4gICAgICAvLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuICAgICAgLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuICAgICAgLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgIHZhciBpO1xuICAgICAgZ2FwID0gXCJcIjtcbiAgICAgIGluZGVudCA9IFwiXCI7XG5cbiAgICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAgIC8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICAgICAgcmVwID0gcmVwbGFjZXI7XG4gICAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04uc3RyaW5naWZ5XCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mIFwiXCIuXG4gICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICByZXR1cm4gc3RyKFwiXCIsIHtcIlwiOiB2YWx1ZX0pO1xuICAgIH07XG4gIH1cblxuXG4gIC8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgaWYgKHR5cGVvZiBKU09OLnBhcnNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBKU09OLnBhcnNlID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgSlNPTiBwYXJzZSBmdW5jdGlvbiB0aGF0IHVzZXMgYSBzdGF0ZSBtYWNoaW5lIHJhdGhlclxuICAgICAgLy8gdGhhbiB0aGUgZGFuZ2Vyb3VzIGV2YWwgZnVuY3Rpb24gdG8gcGFyc2UgYSBKU09OIHRleHQuXG5cbiAgICAgIHZhciBzdGF0ZTsgICAgICAvLyBUaGUgc3RhdGUgb2YgdGhlIHBhcnNlciwgb25lIG9mXG4gICAgICAvLyAnZ28nICAgICAgICAgVGhlIHN0YXJ0aW5nIHN0YXRlXG4gICAgICAvLyAnb2snICAgICAgICAgVGhlIGZpbmFsLCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIC8vICdmaXJzdG9rZXknICBSZWFkeSBmb3IgdGhlIGZpcnN0IGtleSBvZiB0aGUgb2JqZWN0IG9yXG4gICAgICAvLyAgICAgICAgICAgICAgdGhlIGNsb3Npbmcgb2YgYW4gZW1wdHkgb2JqZWN0XG4gICAgICAvLyAnb2tleScgICAgICAgUmVhZHkgZm9yIHRoZSBuZXh0IGtleSBvZiB0aGUgb2JqZWN0XG4gICAgICAvLyAnY29sb24nICAgICAgUmVhZHkgZm9yIHRoZSBjb2xvblxuICAgICAgLy8gJ292YWx1ZScgICAgIFJlYWR5IGZvciB0aGUgdmFsdWUgaGFsZiBvZiBhIGtleS92YWx1ZSBwYWlyXG4gICAgICAvLyAnb2NvbW1hJyAgICAgUmVhZHkgZm9yIGEgY29tbWEgb3IgY2xvc2luZyB9XG4gICAgICAvLyAnZmlyc3RhdmFsdWUnIFJlYWR5IGZvciB0aGUgZmlyc3QgdmFsdWUgb2YgYW4gYXJyYXkgb3JcbiAgICAgIC8vICAgICAgICAgICAgICBhbiBlbXB0eSBhcnJheVxuICAgICAgLy8gJ2F2YWx1ZScgICAgIFJlYWR5IGZvciB0aGUgbmV4dCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgICAgLy8gJ2Fjb21tYScgICAgIFJlYWR5IGZvciBhIGNvbW1hIG9yIGNsb3NpbmcgXVxuICAgICAgdmFyIHN0YWNrOyAgICAgIC8vIFRoZSBzdGFjaywgZm9yIGNvbnRyb2xsaW5nIG5lc3RpbmcuXG4gICAgICB2YXIgY29udGFpbmVyOyAgLy8gVGhlIGN1cnJlbnQgY29udGFpbmVyIG9iamVjdCBvciBhcnJheVxuICAgICAgdmFyIGtleTsgICAgICAgIC8vIFRoZSBjdXJyZW50IGtleVxuICAgICAgdmFyIHZhbHVlOyAgICAgIC8vIFRoZSBjdXJyZW50IHZhbHVlXG4gICAgICB2YXIgZXNjYXBlcyA9IHsgLy8gRXNjYXBlbWVudCB0cmFuc2xhdGlvbiB0YWJsZVxuICAgICAgICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gICAgICAgIFwiXFxcIlwiOiBcIlxcXCJcIixcbiAgICAgICAgXCIvXCI6IFwiL1wiLFxuICAgICAgICBcInRcIjogXCJcXHRcIixcbiAgICAgICAgXCJuXCI6IFwiXFxuXCIsXG4gICAgICAgIFwiclwiOiBcIlxcclwiLFxuICAgICAgICBcImZcIjogXCJcXGZcIixcbiAgICAgICAgXCJiXCI6IFwiXFxiXCJcbiAgICAgIH07XG4gICAgICB2YXIgc3RyaW5nID0geyAgIC8vIFRoZSBhY3Rpb25zIGZvciBzdHJpbmcgdG9rZW5zXG4gICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcIm9rXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcnN0b2tleTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGtleSA9IHZhbHVlO1xuICAgICAgICAgIHN0YXRlID0gXCJjb2xvblwiO1xuICAgICAgICB9LFxuICAgICAgICBva2V5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAga2V5ID0gdmFsdWU7XG4gICAgICAgICAgc3RhdGUgPSBcImNvbG9uXCI7XG4gICAgICAgIH0sXG4gICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJvY29tbWFcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBudW1iZXIgPSB7ICAgLy8gVGhlIGFjdGlvbnMgZm9yIG51bWJlciB0b2tlbnNcbiAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgfSxcbiAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuICAgICAgICB9LFxuICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgfSxcbiAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGFjdGlvbiA9IHtcblxuICAgICAgICAvLyBUaGUgYWN0aW9uIHRhYmxlIGRlc2NyaWJlcyB0aGUgYmVoYXZpb3Igb2YgdGhlIG1hY2hpbmUuIEl0IGNvbnRhaW5zIGFuXG4gICAgICAgIC8vIG9iamVjdCBmb3IgZWFjaCB0b2tlbi4gRWFjaCBvYmplY3QgY29udGFpbnMgYSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlblxuICAgICAgICAvLyBhIHRva2VuIGlzIG1hdGNoZWQgaW4gYSBzdGF0ZS4gQW4gb2JqZWN0IHdpbGwgbGFjayBhIG1ldGhvZCBmb3IgaWxsZWdhbFxuICAgICAgICAvLyBzdGF0ZXMuXG5cbiAgICAgICAgXCJ7XCI6IHtcbiAgICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7c3RhdGU6IFwib2tcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0ge307XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJvY29tbWFcIiwga2V5OiBrZXl9KTtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHt9O1xuICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0b2tleVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0ge307XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0ge307XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIn1cIjoge1xuICAgICAgICAgIGZpcnN0b2tleTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBwb3AuY29udGFpbmVyO1xuICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcbiAgICAgICAgICAgIHN0YXRlID0gcG9wLnN0YXRlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb2NvbW1hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9wID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb250YWluZXJba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBwb3AuY29udGFpbmVyO1xuICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcbiAgICAgICAgICAgIHN0YXRlID0gcG9wLnN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJbXCI6IHtcbiAgICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7c3RhdGU6IFwib2tcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3RhdmFsdWVcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcIm9jb21tYVwiLCBrZXk6IGtleX0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3RhdmFsdWVcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtjb250YWluZXI6IGNvbnRhaW5lciwgc3RhdGU6IFwiYWNvbW1hXCJ9KTtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IFtdO1xuICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0YXZhbHVlXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3RhdmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiXVwiOiB7XG4gICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3AgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udGFpbmVyO1xuICAgICAgICAgICAgY29udGFpbmVyID0gcG9wLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGtleSA9IHBvcC5rZXk7XG4gICAgICAgICAgICBzdGF0ZSA9IHBvcC5zdGF0ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjb21tYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY29udGFpbmVyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBwb3AuY29udGFpbmVyO1xuICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcbiAgICAgICAgICAgIHN0YXRlID0gcG9wLnN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCI6XCI6IHtcbiAgICAgICAgICBjb2xvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lciwga2V5KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJEdXBsaWNhdGUga2V5ICdcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gXCJvdmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLFwiOiB7XG4gICAgICAgICAgb2NvbW1hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXJba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9rZXlcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjb21tYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgc3RhdGUgPSBcImF2YWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9rXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJvY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZmFsc2VcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9rXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2NvbW1hXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibnVsbFwiOiB7XG4gICAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlID0gXCJva1wiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2NvbW1hXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBkZWJhY2tzbGFzaGlmeSh0ZXh0KSB7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFuZCByZXBsYWNlIGFueSBiYWNrc2xhc2ggZXNjYXBlbWVudC5cblxuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXFxcKD86dSguezR9KXwoW151XSkpL2csIGZ1bmN0aW9uIChpZ25vcmUsIGIsIGMpIHtcbiAgICAgICAgICByZXR1cm4gYlxuICAgICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGIsIDE2KSlcbiAgICAgICAgICAgIDogZXNjYXBlc1tjXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG5cbiAgICAgICAgLy8gQSByZWd1bGFyIGV4cHJlc3Npb24gaXMgdXNlZCB0byBleHRyYWN0IHRva2VucyBmcm9tIHRoZSBKU09OIHRleHQuXG4gICAgICAgIC8vIFRoZSBleHRyYWN0aW9uIHByb2Nlc3MgaXMgY2F1dGlvdXMuXG5cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHR4ID0gL15bXFx1MDAyMFxcdFxcblxccl0qKD86KFssOlxcW1xcXXt9XXx0cnVlfGZhbHNlfG51bGwpfCgtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPyl8XCIoKD86W15cXHJcXG5cXHRcXFxcXFxcIl18XFxcXCg/OltcIlxcXFxcXC90cm5mYl18dVswLTlhLWZBLUZdezR9KSkqKVwiKS87XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzdGFydGluZyBzdGF0ZS5cblxuICAgICAgICBzdGF0ZSA9IFwiZ29cIjtcblxuICAgICAgICAvLyBUaGUgc3RhY2sgcmVjb3JkcyB0aGUgY29udGFpbmVyLCBrZXksIGFuZCBzdGF0ZSBmb3IgZWFjaCBvYmplY3Qgb3IgYXJyYXlcbiAgICAgICAgLy8gdGhhdCBjb250YWlucyBhbm90aGVyIG9iamVjdCBvciBhcnJheSB3aGlsZSBwcm9jZXNzaW5nIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuXG4gICAgICAgIHN0YWNrID0gW107XG5cbiAgICAgICAgLy8gSWYgYW55IGVycm9yIG9jY3Vycywgd2Ugd2lsbCBjYXRjaCBpdCBhbmQgdWx0aW1hdGVseSB0aHJvdyBhIHN5bnRheCBlcnJvci5cblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgLy8gRm9yIGVhY2ggdG9rZW4uLi5cblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0eC5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVzdWx0IGlzIHRoZSByZXN1bHQgYXJyYXkgZnJvbSBtYXRjaGluZyB0aGUgdG9rZW5pemluZyByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAvLyAgcmVzdWx0WzBdIGNvbnRhaW5zIGV2ZXJ5dGhpbmcgdGhhdCBtYXRjaGVkLCBpbmNsdWRpbmcgYW55IGluaXRpYWwgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIC8vICByZXN1bHRbMV0gY29udGFpbnMgYW55IHB1bmN0dWF0aW9uIHRoYXQgd2FzIG1hdGNoZWQsIG9yIHRydWUsIGZhbHNlLCBvciBudWxsLlxuICAgICAgICAgICAgLy8gIHJlc3VsdFsyXSBjb250YWlucyBhIG1hdGNoZWQgbnVtYmVyLCBzdGlsbCBpbiBzdHJpbmcgZm9ybS5cbiAgICAgICAgICAgIC8vICByZXN1bHRbM10gY29udGFpbnMgYSBtYXRjaGVkIHN0cmluZywgd2l0aG91dCBxdW90ZXMgYnV0IHdpdGggZXNjYXBlbWVudC5cblxuICAgICAgICAgICAgaWYgKHJlc3VsdFsxXSkge1xuXG4gICAgICAgICAgICAgIC8vIFRva2VuOiBFeGVjdXRlIHRoZSBhY3Rpb24gZm9yIHRoaXMgc3RhdGUgYW5kIHRva2VuLlxuXG4gICAgICAgICAgICAgIGFjdGlvbltyZXN1bHRbMV1dW3N0YXRlXSgpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFsyXSkge1xuXG4gICAgICAgICAgICAgIC8vIE51bWJlciB0b2tlbjogQ29udmVydCB0aGUgbnVtYmVyIHN0cmluZyBpbnRvIGEgbnVtYmVyIHZhbHVlIGFuZCBleGVjdXRlXG4gICAgICAgICAgICAgIC8vIHRoZSBhY3Rpb24gZm9yIHRoaXMgc3RhdGUgYW5kIG51bWJlci5cblxuICAgICAgICAgICAgICB2YWx1ZSA9ICtyZXN1bHRbMl07XG4gICAgICAgICAgICAgIG51bWJlcltzdGF0ZV0oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgLy8gU3RyaW5nIHRva2VuOiBSZXBsYWNlIHRoZSBlc2NhcGVtZW50IHNlcXVlbmNlcyBhbmQgZXhlY3V0ZSB0aGUgYWN0aW9uIGZvclxuICAgICAgICAgICAgICAvLyB0aGlzIHN0YXRlIGFuZCBzdHJpbmcuXG5cbiAgICAgICAgICAgICAgdmFsdWUgPSBkZWJhY2tzbGFzaGlmeShyZXN1bHRbM10pO1xuICAgICAgICAgICAgICBzdHJpbmdbc3RhdGVdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdG9rZW4gZnJvbSB0aGUgc3RyaW5nLiBUaGUgbG9vcCB3aWxsIGNvbnRpbnVlIGFzIGxvbmcgYXMgdGhlcmVcbiAgICAgICAgICAgIC8vIGFyZSB0b2tlbnMuIFRoaXMgaXMgYSBzbG93IHByb2Nlc3MsIGJ1dCBpdCBhbGxvd3MgdGhlIHVzZSBvZiBeIG1hdGNoaW5nLFxuICAgICAgICAgICAgLy8gd2hpY2ggYXNzdXJlcyB0aGF0IG5vIGlsbGVnYWwgdG9rZW5zIHNsaXAgdGhyb3VnaC5cblxuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnNsaWNlKHJlc3VsdFswXS5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIGZpbmQgYSBzdGF0ZS90b2tlbiBjb21iaW5hdGlvbiB0aGF0IGlzIGlsbGVnYWwsIHRoZW4gdGhlIGFjdGlvbiB3aWxsXG4gICAgICAgICAgLy8gY2F1c2UgYW4gZXJyb3IuIFdlIGhhbmRsZSB0aGUgZXJyb3IgYnkgc2ltcGx5IGNoYW5naW5nIHRoZSBzdGF0ZS5cblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc3RhdGUgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHBhcnNpbmcgaXMgZmluaXNoZWQuIElmIHdlIGFyZSBub3QgaW4gdGhlIGZpbmFsIFwib2tcIiBzdGF0ZSwgb3IgaWYgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyBzb3VyY2UgY29udGFpbnMgYW55dGhpbmcgZXhjZXB0IHdoaXRlc3BhY2UsIHRoZW4gd2UgZGlkIG5vdCBoYXZlXG4gICAgICAgIC8vYSB3ZWxsLWZvcm1lZCBKU09OIHRleHQuXG5cbiAgICAgICAgaWYgKHN0YXRlICE9PSBcIm9rXCIgfHwgKC9bXlxcdTAwMjBcXHRcXG5cXHJdLy50ZXN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgdGhyb3cgKHN0YXRlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpXG4gICAgICAgICAgICA/IHN0YXRlXG4gICAgICAgICAgICA6IG5ldyBTeW50YXhFcnJvcihcIkpTT05cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4gICAgICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gdmFsdWUgaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIHRoYXQgdmFsdWUuXG5cbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcmV2aXZlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICB2YXIgdmFsID0gaG9sZGVyW2tleV07XG4gICAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGspKSB7XG4gICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWwsIGspO1xuICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxba10gPSB2O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbFtrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbCk7XG4gICAgICAgICAgfSh7XCJcIjogdmFsdWV9LCBcIlwiKSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSgpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwQ3VzdG9tSlNPTjtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLyogZ2xvYmFscyBleHBlY3QgKi9cbi8qIGdsb2JhbHMgZGVzY3JpYmUgKi9cbi8qIGdsb2JhbHMgaXQgKi9cbi8qIGdsb2JhbHMgc2lub24gKi9cblxudmFyIFJvbGxiYXIgPSByZXF1aXJlKCcuLi9zcmMvYnJvd3Nlci9yb2xsYmFyJyk7XG52YXIgdCA9IHJlcXVpcmUoJy4uL3NyYy9icm93c2VyL3RyYW5zZm9ybXMnKTtcblxuZnVuY3Rpb24gVGVzdENsaWVudEdlbigpIHtcbiAgdmFyIFRlc3RDbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub3RpZmllciA9IHtcbiAgICAgIGFkZFRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmllcjtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICB9O1xuICAgIHRoaXMucXVldWUgPSB7XG4gICAgICBhZGRQcmVkaWNhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFRlc3RDbGllbnQ7XG59XG5cbmZ1bmN0aW9uIGl0ZW1Gcm9tQXJncyhhcmdzKSB7XG4gIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgdmFyIHJvbGxiYXIgPSBuZXcgUm9sbGJhcih7IGF1dG9JbnN0cnVtZW50OiBmYWxzZSB9LCBjbGllbnQpO1xuICB2YXIgaXRlbSA9IHJvbGxiYXIuX2NyZWF0ZUl0ZW0oYXJncyk7XG4gIGl0ZW0ubGV2ZWwgPSAnZGVidWcnO1xuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gY2hyb21lTWFqb3JWZXJzaW9uKCkge1xuICByZXR1cm4gcGFyc2VJbnQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFswLTldKylcXC4vKVsxXSk7XG59XG5cbmRlc2NyaWJlKCdoYW5kbGVEb21FeGNlcHRpb24nLCBmdW5jdGlvbiAoKSB7XG4gIGl0KCdzaG91bGQgZG8gbm90aGluZyBpZiBub3QgYSBET01FeGNlcHRpb24nLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Rlc3QnKTtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJywgZXJyXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHQuaGFuZGxlRG9tRXhjZXB0aW9uKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaXRlbS5lcnIpLnRvLmVxbChpdGVtLmVycik7XG4gICAgICBleHBlY3QoaXRlbS5lcnIubmVzdGVkKS50by5ub3QuYmUub2soKTtcbiAgICAgIGRvbmUoZSk7XG4gICAgfSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGNyZWF0ZSBuZXN0ZWQgZXhjZXB0aW9uIGZvciBET01FeGNlcHRpb24nLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBlcnIgPSBuZXcgRE9NRXhjZXB0aW9uKCdkb20gZXJyb3InKTtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJywgZXJyXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHQuaGFuZGxlRG9tRXhjZXB0aW9uKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaXRlbS5lcnIubmVzdGVkLmNvbnN0cnVjdG9yLm5hbWUpLnRvLmVxbCgnRE9NRXhjZXB0aW9uJyk7XG4gICAgICBleHBlY3QoaXRlbS5lcnIuY29uc3RydWN0b3IubmFtZSkudG8uZXFsKCdFcnJvcicpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbmRlc2NyaWJlKCdoYW5kbGVJdGVtV2l0aEVycm9yJywgZnVuY3Rpb24gKCkge1xuICBpdCgnc2hvdWxkIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgbm8gZXJyJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJ107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB0LmhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGV4cGVjdChpKS50by5lcWwoaXRlbSk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBzZXQgc3RhY2sgaW5mbyBmcm9tIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgc2F2ZWQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ2JvcmsnKTtcbiAgICB2YXIgbXlUcmFjZSA9IHsgdHJhY2U6IHsgZnJhbWVzOiBbMSwgMiwgM10gfSB9O1xuICAgIGVyci5fc2F2ZWRTdGFja1RyYWNlID0gbXlUcmFjZTtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJywgZXJyXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHQuaGFuZGxlSXRlbVdpdGhFcnJvcihpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkuc3RhY2tJbmZvKS50by5lcWwobXlUcmFjZSk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBzZXQgc3RhY2sgaW5mbyBmcm9tIGVycm9yJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgZXJyO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvcmsnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJywgZXJyXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHQuaGFuZGxlSXRlbVdpdGhFcnJvcihpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkubWVzc2FnZSkudG8uZXFsKCdhIG1lc3NhZ2UnKTtcbiAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgIGRvbmUoZSk7XG4gICAgfSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGhhbmRsZSBiYWQgZXJyb3JzIGFuZCBzdGlsbCBzZXQgc3RhY2tJbmZvJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgZXJyID0geyBkZXNjcmlwdGlvbjogJ2JvcmsnIH07XG4gICAgdmFyIGFyZ3MgPSBbJ2EgbWVzc2FnZScsICdmdXp6J107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgaXRlbS5lcnIgPSBlcnI7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB0LmhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgIGV4cGVjdChpLm1lc3NhZ2UpLnRvLmVxbCgnYSBtZXNzYWdlJyk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCB1c2UgbW9zdCBzcGVjaWZpYyBlcnJvciBuYW1lJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdib3JrJyk7XG4gICAgdmFyIGFyZ3MgPSBbJ2EgbWVzc2FnZScsIGVycl07XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIHZhciBuYW1lcyA9IFtcbiAgICAgIHsgbmFtZTogJ1R5cGVFcnJvcicsIGNvbnN0cnVjdG9yOiAnRXZhbEVycm9yJywgcmVzdWx0OiAnVHlwZUVycm9yJyB9LFxuICAgICAgeyBuYW1lOiAnVHlwZUVycm9yJywgY29uc3RydWN0b3I6ICdFcnJvcicsIHJlc3VsdDogJ1R5cGVFcnJvcicgfSxcbiAgICAgIHsgbmFtZTogJ0Vycm9yJywgY29uc3RydWN0b3I6ICdUeXBlRXJyb3InLCByZXN1bHQ6ICdUeXBlRXJyb3InIH0sXG4gICAgICB7IG5hbWU6ICdFcnJvcicsIGNvbnN0cnVjdG9yOiAnJywgcmVzdWx0OiAnRXJyb3InIH0sXG4gICAgICB7IG5hbWU6ICcnLCBjb25zdHJ1Y3RvcjogJ0Vycm9yJywgcmVzdWx0OiAnRXJyb3InIH0sXG4gICAgICB7IG5hbWU6ICcnLCBjb25zdHJ1Y3RvcjogJycsIHJlc3VsdDogJycgfSxcbiAgICBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgZXJyLm5hbWUgPSBuYW1lc1tpXS5uYW1lO1xuICAgICAgZXJyLmNvbnN0cnVjdG9yID0geyBuYW1lOiBuYW1lc1tpXS5jb25zdHJ1Y3RvciB9O1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICB2YXIgcmVzdWx0ID0gbmFtZXNbaV0ucmVzdWx0O1xuXG4gICAgICB0LmhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgZXhwZWN0KGkuc3RhY2tJbmZvLm5hbWUpLnRvLmVxbChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRvbmUoKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2Vuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheScsIGZ1bmN0aW9uICgpIHtcbiAgaXQoJ3Nob3VsZCBlcnJvciBpZiBpdGVtIGhhcyBub3RoaW5nJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdC5lbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXkoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGV4cGVjdChlKS50by5iZS5vaygpO1xuICAgICAgZG9uZShpKTtcbiAgICB9KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgZG8gbm90aGluZyBpZiBpdGVtIGhhcyBhIG1lc3NhZ2UnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgaXRlbS5tZXNzYWdlID0gJ2JvcmsnO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdC5lbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXkoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGV4cGVjdChpKS50by5iZS5vaygpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgZG8gbm90aGluZyBpZiBpdGVtIGhhcyBzdGFja0luZm8nLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgaXRlbS5kYXRhID0gaXRlbS5kYXRhIHx8IHt9O1xuICAgIGl0ZW0uc3RhY2tJbmZvID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB0LmVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheShpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkpLnRvLmJlLm9rKCk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBkbyBub3RoaW5nIGlmIGl0ZW0gaGFzIGN1c3RvbSBkYXRhJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgIGl0ZW0uY3VzdG9tID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB0LmVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheShpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkpLnRvLmJlLm9rKCk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnYWRkQmFzZUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIGl0KCdzaG91bGQgYWRkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgZGF0YScsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGFyZ3MgPSBbJ2EgbWVzc2FnZSddO1xuICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgIGl0ZW0ubGV2ZWwgPSAnY3JpdGljYWwnO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdC5hZGRCYXNlSW5mbyhpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkuZGF0YS5sZXZlbCkudG8uZXFsKCdjcml0aWNhbCcpO1xuICAgICAgZXhwZWN0KGkuZGF0YS5wbGF0Zm9ybSkudG8uZXFsKCdicm93c2VyJyk7XG4gICAgICBleHBlY3QoaS5kYXRhLmZyYW1ld29yaykudG8uZXFsKCdicm93c2VyLWpzJyk7XG4gICAgICBleHBlY3QoaS5kYXRhLmxhbmd1YWdlKS50by5lcWwoJ2phdmFzY3JpcHQnKTtcbiAgICAgIGV4cGVjdChpLmRhdGEubm90aWZpZXIubmFtZSkudG8uZXFsKCdyb2xsYmFyLWJyb3dzZXItanMnKTtcbiAgICAgIGRvbmUoZSk7XG4gICAgfSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIHB1bGwgZGF0YSBmcm9tIG9wdGlvbnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGVudmlyb25tZW50OiAnZGV2JyxcbiAgICAgIGVuZHBvaW50OiAnYXBpLnJvbGxiYXIuY29tJyxcbiAgICAgIHZlcnNpb246ICc0MicsXG4gICAgfTtcbiAgICB0LmFkZEJhc2VJbmZvKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaS5kYXRhLmVudmlyb25tZW50KS50by5lcWwoJ2RldicpO1xuICAgICAgZXhwZWN0KGkuZGF0YS5lbmRwb2ludCkudG8uZXFsKCdhcGkucm9sbGJhci5jb20nKTtcbiAgICAgIGV4cGVjdChpLmRhdGEubm90aWZpZXIudmVyc2lvbikudG8uZXFsKCc0MicpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgcHVsbCBlbnZpcm9ubWVudCBmcm9tIHBheWxvYWQgb3B0aW9ucycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGFyZ3MgPSBbJ2EgbWVzc2FnZSddO1xuICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcGF5bG9hZDogeyBlbnZpcm9ubWVudDogJ2RldicgfSxcbiAgICB9O1xuICAgIHQuYWRkQmFzZUluZm8oaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGV4cGVjdChpLmRhdGEuZW52aXJvbm1lbnQpLnRvLmVxbCgnZGV2Jyk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnYWRkUmVxdWVzdEluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIGl0KCdzaG91bGQgdXNlIHdpbmRvdyBpbmZvIHRvIHNldCByZXF1ZXN0IHByb3BlcnRpZXMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICB2YXIgb3B0aW9ucyA9IHsgY2FwdHVyZUlwOiAnYW5vbnltaXplJyB9O1xuICAgIHQuYWRkUmVxdWVzdEluZm8od2luZG93KShpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkuZGF0YS5yZXF1ZXN0KS50by5iZS5vaygpO1xuICAgICAgZXhwZWN0KGkuZGF0YS5yZXF1ZXN0LnVzZXJfaXApLnRvLmVxbCgnJHJlbW90ZV9pcF9hbm9ueW1pemUnKTtcbiAgICAgIGRvbmUoZSk7XG4gICAgfSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGRvIG5vdGhpbmcgd2l0aG91dCB3aW5kb3cnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnXTtcbiAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICBpdGVtLmRhdGEgPSB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciB3ID0gbnVsbDtcbiAgICB0LmFkZFJlcXVlc3RJbmZvKHcpKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaS5kYXRhLnJlcXVlc3QpLnRvLm5vdC5iZS5vaygpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaG9ub3IgY2FwdHVyZUlwIHdpdGhvdXQgd2luZG93JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJ107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgaXRlbS5kYXRhID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSB7IGNhcHR1cmVJcDogdHJ1ZSB9O1xuICAgIHZhciB3ID0gbnVsbDtcbiAgICB0LmFkZFJlcXVlc3RJbmZvKHcpKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaS5kYXRhLnJlcXVlc3QudXJsKS50by5ub3QuYmUub2soKTtcbiAgICAgIGV4cGVjdChpLmRhdGEucmVxdWVzdC5xdWVyeV9zdHJpbmcpLnRvLm5vdC5iZS5vaygpO1xuICAgICAgZXhwZWN0KGkuZGF0YS5yZXF1ZXN0LnVzZXJfaXApLnRvLmVxbCgnJHJlbW90ZV9pcCcpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2FkZENsaWVudEluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIGl0KCdzaG91bGQgZG8gbm90aGluZyB3aXRob3V0IGEgd2luZG93JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJ107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgaXRlbS5kYXRhID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgdyA9IG51bGw7XG4gICAgdC5hZGRDbGllbnRJbmZvKHcpKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaS5kYXRhLmNsaWVudCkudG8ubm90LmJlLm9rKCk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCB1c2Ugd2luZG93IGluZm8gdG8gc2V0IGNsaWVudCBwcm9wZXJ0aWVzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJ107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB0LmFkZENsaWVudEluZm8od2luZG93KShpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkuZGF0YS5jbGllbnQpLnRvLmJlLm9rKCk7XG4gICAgICBleHBlY3QoaS5kYXRhLmNsaWVudC5qYXZhc2NyaXB0KS50by5iZS5vaygpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2FkZFBsdWdpbkluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIGl0KCdzaG91bGQgZG8gbm90aGluZyB3aXRob3V0IGEgd2luZG93JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJ107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgdyA9IG51bGw7XG4gICAgdC5hZGRQbHVnaW5JbmZvKHcpKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGkuZGF0YSAmJlxuICAgICAgICAgIGkuZGF0YS5jbGllbnQgJiZcbiAgICAgICAgICBpLmRhdGEuY2xpZW50LmphdmFzY3JpcHQgJiZcbiAgICAgICAgICBpLmRhdGEuY2xpZW50LmphdmFzY3JpcHQucGx1Z2lucyxcbiAgICAgICkudG8ubm90LmJlLm9rKCk7XG4gICAgICBkb25lKGUpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBhZGQgcGx1Z2luIGRhdGEgZnJvbSB0aGUgd2luZG93JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgYXJncyA9IFsnYSBtZXNzYWdlJ107XG4gICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgdyA9IHsgbmF2aWdhdG9yOiB7IHBsdWdpbnM6IFtdIH0gfTtcbiAgICB3Lm5hdmlnYXRvci5wbHVnaW5zLnB1c2goeyBuYW1lOiAncGx1Z2luIDEnLCBkZXNjcmlwdGlvbjogJzEnIH0pO1xuICAgIHcubmF2aWdhdG9yLnBsdWdpbnMucHVzaCh7IG5hbWU6ICdwbHVnaW4gMicsIGRlc2NyaXB0aW9uOiAnMicgfSk7XG4gICAgdC5hZGRQbHVnaW5JbmZvKHcpKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBleHBlY3QoaS5kYXRhLmNsaWVudC5qYXZhc2NyaXB0LnBsdWdpbnMpLnRvLmJlLm9rKCk7XG4gICAgICBleHBlY3QoaS5kYXRhLmNsaWVudC5qYXZhc2NyaXB0LnBsdWdpbnMubGVuZ3RoKS50by5lcWwoMik7XG4gICAgICBleHBlY3QoaS5kYXRhLmNsaWVudC5qYXZhc2NyaXB0LnBsdWdpbnNbMF0ubmFtZSkudG8uZXFsKCdwbHVnaW4gMScpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2FkZEJvZHknLCBmdW5jdGlvbiAoKSB7XG4gIGRlc2NyaWJlKCd3aXRoIHN0YWNrSW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3RhY2tJbmZvIHRvIGFkZCBhIHRyYWNlIHRvIHRoZSBib2R5JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBlcnI7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvcmsnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCBlcnIsIHsgY3VzdG9tOiAnc3R1ZmYnIH1dO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICBpdGVtLmRlc2NyaXB0aW9uID0gJ2JvcmtlZCc7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgdC5oYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgICAgdC5hZGRCb2R5KGksIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlKS50by5iZS5vaygpO1xuICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBhZGQgYSBtZXNzYWdlIHdpdGggYSBiYWQgc3RhY2tJbmZvJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnXTtcbiAgICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgICAgaXRlbS5kZXNjcmlwdGlvbiA9ICdib3JrZWQnO1xuICAgICAgaXRlbS5kYXRhID0gaXRlbS5kYXRhIHx8IHt9O1xuICAgICAgaXRlbS5zdGFja0luZm8gPSB7IG5hbWU6ICdib3JrJyB9O1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIHQuYWRkQm9keShpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkudHJhY2UpLnRvLm5vdC5iZS5vaygpO1xuICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkubWVzc2FnZS5ib2R5KS50by5iZS5vaygpO1xuICAgICAgICBkb25lKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBkZXNjcmliZSgnd2l0aG91dCBzdGFja0luZm8nLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoJ3Nob3VsZCBhZGQgYSBtZXNzYWdlIGFzIHRoZSBib2R5JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCB7IGN1c3RvbTogJ3N0dWZmJyB9XTtcbiAgICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIHQuYWRkQm9keShpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkubWVzc2FnZS5ib2R5KS50by5iZS5vaygpO1xuICAgICAgICBkb25lKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBzZW5kIG1lc3NhZ2Ugd2hlbiBzZW50IHdpdGhvdXQgYSBtZXNzYWdlJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBhcmdzID0gW3sgY3VzdG9tOiAnc3R1ZmYnIH1dO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgdC5hZGRCb2R5KGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLmRhdGEuYm9keS5tZXNzYWdlLmJvZHkpLnRvLmVxbChcbiAgICAgICAgICAnSXRlbSBzZW50IHdpdGggbnVsbCBvciBtaXNzaW5nIGFyZ3VtZW50cy4nLFxuICAgICAgICApO1xuICAgICAgICBkb25lKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBkZXNjcmliZSgnd2l0aG91dCBzdGFja0luZm8ubmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpdCgnc2hvdWxkIHNldCBlcnJvciBjbGFzcyB1bmtub3duJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBlcnI7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvcmsnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCBlcnIsIHsgY3VzdG9tOiAnc3R1ZmYnIH1dO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICBpdGVtLmRlc2NyaXB0aW9uID0gJ2JvcmtlZCc7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgdC5oYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgICAgaS5zdGFja0luZm8ubmFtZSA9IG51bGw7IC8vIGZvcmNlIGFsdGVybmF0ZSBwYXRoIHRvIGRldGVybWluZSBlcnJvciBjbGFzcy5cbiAgICAgICAgdC5hZGRCb2R5KGksIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5jbGFzcykudG8uZXFsKCcodW5rbm93biknKTtcbiAgICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgnYm9yaycpO1xuICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ3doZW4gY29uZmlnLmd1ZXNzRXJyb3JDbGFzcyBpcyBzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCgnc2hvdWxkIGd1ZXNzIGVycm9yIGNsYXNzICcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHdWVzc2VkRXJyb3I6IGJvcmsnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBbZXJyLCB7IGN1c3RvbTogJ3N0dWZmJyB9XTtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICAgIGl0ZW0uZGVzY3JpcHRpb24gPSAnYm9ya2VkJztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGd1ZXNzRXJyb3JDbGFzczogdHJ1ZSB9O1xuICAgICAgICB0LmhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICBleHBlY3QoaS5zdGFja0luZm8pLnRvLmJlLm9rKCk7XG4gICAgICAgICAgaS5zdGFja0luZm8ubmFtZSA9IG51bGw7IC8vIGZvcmNlIGFsdGVybmF0ZSBwYXRoIHRvIGRldGVybWluZSBlcnJvciBjbGFzcy5cbiAgICAgICAgICB0LmFkZEJvZHkoaSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIGV4cGVjdChpLmRhdGEuYm9keS50cmFjZS5leGNlcHRpb24uY2xhc3MpLnRvLmVxbCgnR3Vlc3NlZEVycm9yJyk7XG4gICAgICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgnYm9yaycpO1xuICAgICAgICAgICAgZG9uZShlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdzaG91bGQgc2V0IGVycm9yIGNsYXNzIHVua25vd24nLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICB2YXIgZXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYm9yaycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IFtlcnIsIHsgY3VzdG9tOiAnc3R1ZmYnIH1dO1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1Gcm9tQXJncyhhcmdzKTtcbiAgICAgICAgaXRlbS5kZXNjcmlwdGlvbiA9ICdib3JrZWQnO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHsgZ3Vlc3NFcnJvckNsYXNzOiB0cnVlIH07XG4gICAgICAgIHQuaGFuZGxlSXRlbVdpdGhFcnJvcihpdGVtLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgICAgICBpLnN0YWNrSW5mby5uYW1lID0gbnVsbDsgLy8gZm9yY2UgYWx0ZXJuYXRlIHBhdGggdG8gZGV0ZXJtaW5lIGVycm9yIGNsYXNzLlxuICAgICAgICAgIHQuYWRkQm9keShpLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5jbGFzcykudG8uZXFsKCcodW5rbm93biknKTtcbiAgICAgICAgICAgIGV4cGVjdChpLmRhdGEuYm9keS50cmFjZS5leGNlcHRpb24ubWVzc2FnZSkudG8uZXFsKCdib3JrJyk7XG4gICAgICAgICAgICBkb25lKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgZGVzY3JpYmUoJ3dpdGggbmVzdGVkIGVycm9yJywgZnVuY3Rpb24gKCkge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIHRyYWNlX2NoYWluJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBuZXN0ZWRFcnIgPSBuZXcgRXJyb3IoJ25lc3RlZCBlcnJvcicpO1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigndGVzdCBlcnJvcicpO1xuICAgICAgZXJyLm5lc3RlZCA9IG5lc3RlZEVycjtcbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCBlcnJdO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgdC5oYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgIH0pO1xuICAgICAgdC5hZGRCb2R5KGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLmRhdGEuYm9keS50cmFjZV9jaGFpbi5sZW5ndGgpLnRvLmVxbCgyKTtcbiAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlX2NoYWluWzBdLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoXG4gICAgICAgICAgJ3Rlc3QgZXJyb3InLFxuICAgICAgICApO1xuICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkudHJhY2VfY2hhaW5bMV0uZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbChcbiAgICAgICAgICAnbmVzdGVkIGVycm9yJyxcbiAgICAgICAgKTtcbiAgICAgICAgZG9uZShlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGFkZCBlcnJvciBjb250ZXh0IGFzIGN1c3RvbSBkYXRhJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBuZXN0ZWRFcnIgPSBuZXcgRXJyb3IoJ25lc3RlZCBlcnJvcicpO1xuICAgICAgbmVzdGVkRXJyLnJvbGxiYXJDb250ZXh0ID0geyBlcnIxOiAnbmVzdGVkIGNvbnRleHQnIH07XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCd0ZXN0IGVycm9yJyk7XG4gICAgICBlcnIucm9sbGJhckNvbnRleHQgPSB7IGVycjI6ICdlcnJvciBjb250ZXh0JyB9O1xuICAgICAgZXJyLm5lc3RlZCA9IG5lc3RlZEVycjtcbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCBlcnJdO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHsgYWRkRXJyb3JDb250ZXh0OiB0cnVlIH07XG4gICAgICB0LmhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgZXhwZWN0KGkuc3RhY2tJbmZvKS50by5iZS5vaygpO1xuICAgICAgfSk7XG4gICAgICB0LmFkZEJvZHkoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlX2NoYWluLmxlbmd0aCkudG8uZXFsKDIpO1xuICAgICAgICBleHBlY3QoaS5kYXRhLmN1c3RvbS5lcnIxKS50by5lcWwoJ25lc3RlZCBjb250ZXh0Jyk7XG4gICAgICAgIGV4cGVjdChpLmRhdGEuY3VzdG9tLmVycjIpLnRvLmVxbCgnZXJyb3IgY29udGV4dCcpO1xuICAgICAgICBkb25lKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBkZXNjcmliZSgnd2l0aCBlcnJvciBjYXVzZScsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBFcnJvciBjYXVzZSB3YXMgaW50cm9kdWNlZCBpbiBDaHJvbWUgOTMuXG4gICAgaWYgKGNocm9tZU1ham9yVmVyc2lvbigpIDwgOTMpIHJldHVybjtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIHRyYWNlX2NoYWluJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBjYXVzZUVyciA9IG5ldyBFcnJvcignY2F1c2UgZXJyb3InKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Rlc3QgZXJyb3InLCB7IGNhdXNlOiBjYXVzZUVyciB9KTtcbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCBlcnJdO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgdC5oYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLnN0YWNrSW5mbykudG8uYmUub2soKTtcbiAgICAgIH0pO1xuICAgICAgdC5hZGRCb2R5KGl0ZW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgIGV4cGVjdChpLmRhdGEuYm9keS50cmFjZV9jaGFpbi5sZW5ndGgpLnRvLmVxbCgyKTtcbiAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlX2NoYWluWzBdLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoXG4gICAgICAgICAgJ3Rlc3QgZXJyb3InLFxuICAgICAgICApO1xuICAgICAgICBleHBlY3QoaS5kYXRhLmJvZHkudHJhY2VfY2hhaW5bMV0uZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbChcbiAgICAgICAgICAnY2F1c2UgZXJyb3InLFxuICAgICAgICApO1xuICAgICAgICBkb25lKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYWRkIGVycm9yIGNvbnRleHQgYXMgY3VzdG9tIGRhdGEnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgdmFyIGNhdXNlRXJyID0gbmV3IEVycm9yKCdjYXVzZSBlcnJvcicpO1xuICAgICAgY2F1c2VFcnIucm9sbGJhckNvbnRleHQgPSB7IGVycjE6ICdjYXVzZSBjb250ZXh0JyB9O1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigndGVzdCBlcnJvcicsIHsgY2F1c2U6IGNhdXNlRXJyIH0pO1xuICAgICAgZXJyLnJvbGxiYXJDb250ZXh0ID0geyBlcnIyOiAnZXJyb3IgY29udGV4dCcgfTtcbiAgICAgIHZhciBhcmdzID0gWydhIG1lc3NhZ2UnLCBlcnJdO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtRnJvbUFyZ3MoYXJncyk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHsgYWRkRXJyb3JDb250ZXh0OiB0cnVlIH07XG4gICAgICB0LmhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgZXhwZWN0KGkuc3RhY2tJbmZvKS50by5iZS5vaygpO1xuICAgICAgfSk7XG4gICAgICB0LmFkZEJvZHkoaXRlbSwgb3B0aW9ucywgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgZXhwZWN0KGkuZGF0YS5ib2R5LnRyYWNlX2NoYWluLmxlbmd0aCkudG8uZXFsKDIpO1xuICAgICAgICBleHBlY3QoaS5kYXRhLmN1c3RvbS5lcnIxKS50by5lcWwoJ2NhdXNlIGNvbnRleHQnKTtcbiAgICAgICAgZXhwZWN0KGkuZGF0YS5jdXN0b20uZXJyMikudG8uZXFsKCdlcnJvciBjb250ZXh0Jyk7XG4gICAgICAgIGRvbmUoZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ3NjcnViUGF5bG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgaXQoJ29ubHkgc2NydWJzIHBheWxvYWQgZGF0YScsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGFyZ3MgPSBbXG4gICAgICAnYSBtZXNzYWdlJyxcbiAgICAgIHsgc2Nvb2J5OiAnZG9vJywgb2theTogJ2Zpeno9YnV6eiZmdXp6PWJheicsIHVzZXI6IHsgaWQ6IDQyIH0gfSxcbiAgICBdO1xuICAgIHZhciBpdGVtID0gaXRlbUZyb21BcmdzKGFyZ3MpO1xuICAgIHZhciBhY2Nlc3NUb2tlbiA9ICdhYmMxMjMnO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgZW5kcG9pbnQ6ICdhcGkucm9sbGJhci5jb20vJyxcbiAgICAgIHNjcnViRmllbGRzOiBbJ2FjY2Vzc190b2tlbicsICdhY2Nlc3NUb2tlbicsICdzY29vYnknLCAnZml6eicsICd1c2VyJ10sXG4gICAgfTtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICBkYXRhOiBpdGVtLFxuICAgIH07XG4gICAgZXhwZWN0KHBheWxvYWQuYWNjZXNzX3Rva2VuKS50by5lcWwoYWNjZXNzVG9rZW4pO1xuICAgIGV4cGVjdChwYXlsb2FkLmRhdGEuY3VzdG9tLnNjb29ieSkudG8uZXFsKCdkb28nKTtcbiAgICBleHBlY3QocGF5bG9hZC5kYXRhLmN1c3RvbS5va2F5KS50by5lcWwoJ2Zpeno9YnV6eiZmdXp6PWJheicpO1xuICAgIGV4cGVjdChwYXlsb2FkLmRhdGEuY3VzdG9tLnVzZXIuaWQpLnRvLmVxbCg0Mik7XG5cbiAgICB2YXIgc2NydWIgPSByZXF1aXJlKCcuLi9zcmMvc2NydWInKTtcbiAgICB0LmFkZFNjcnViYmVyKHNjcnViKShwYXlsb2FkLCBvcHRpb25zLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgZXhwZWN0KGkuYWNjZXNzX3Rva2VuKS50by5lcWwoYWNjZXNzVG9rZW4pO1xuICAgICAgZXhwZWN0KGkuZGF0YS5jdXN0b20uc2Nvb2J5KS50by5ub3QuZXFsKCdkb28nKTtcbiAgICAgIGV4cGVjdChwYXlsb2FkLmRhdGEuY3VzdG9tLm9rYXkpLnRvLm5vdC5lcWwoJ2Zpeno9YnV6eiZmdXp6PWJheicpO1xuICAgICAgZXhwZWN0KHBheWxvYWQuZGF0YS5jdXN0b20ub2theSkudG8ubWF0Y2goL2Zpeno9XFwqKyZmdXp6PWJhei8pO1xuICAgICAgZXhwZWN0KHBheWxvYWQuZGF0YS5jdXN0b20udXNlci5pZCkudG8ubm90LmJlLm9rKCk7XG4gICAgICBleHBlY3QocGF5bG9hZC5kYXRhLmN1c3RvbS51c2VyKS50by5tYXRjaCgvXFwqKy8pO1xuICAgICAgZXhwZWN0KGkuZGF0YS5tZXNzYWdlKS50by5lcWwoJ2EgbWVzc2FnZScpO1xuICAgICAgZG9uZShlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJfcmVnZW5lcmF0b3JSdW50aW1lIiwiZSIsInQiLCJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwibiIsImhhc093blByb3BlcnR5IiwibyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJpIiwiU3ltYm9sIiwiYSIsIml0ZXJhdG9yIiwiYyIsImFzeW5jSXRlcmF0b3IiLCJ1IiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ3cmFwIiwiR2VuZXJhdG9yIiwiY3JlYXRlIiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsInR5cGUiLCJhcmciLCJjYWxsIiwiaCIsImwiLCJmIiwicyIsInkiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwicCIsImQiLCJnZXRQcm90b3R5cGVPZiIsInYiLCJ2YWx1ZXMiLCJnIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiZm9yRWFjaCIsIl9pbnZva2UiLCJBc3luY0l0ZXJhdG9yIiwiaW52b2tlIiwiX3R5cGVvZiIsInJlc29sdmUiLCJfX2F3YWl0IiwidGhlbiIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiRXJyb3IiLCJkb25lIiwibWV0aG9kIiwiZGVsZWdhdGUiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJUeXBlRXJyb3IiLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsImlzTmFOIiwibGVuZ3RoIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJrZXlzIiwicmV2ZXJzZSIsInBvcCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJydmFsIiwiaGFuZGxlIiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJkZWxlZ2F0ZVlpZWxkIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9uZXh0IiwiX3Rocm93IiwiXyIsInJlcXVpcmUiLCJoZWxwZXJzIiwiZGVmYXVsdE9wdGlvbnMiLCJob3N0bmFtZSIsInBhdGgiLCJzZWFyY2giLCJ2ZXJzaW9uIiwicHJvdG9jb2wiLCJwb3J0IiwiT1RMUERlZmF1bHRPcHRpb25zIiwiQXBpIiwib3B0aW9ucyIsInRyYW5zcG9ydCIsInVybGxpYiIsInRydW5jYXRpb24iLCJ1cmwiLCJhY2Nlc3NUb2tlbiIsInRyYW5zcG9ydE9wdGlvbnMiLCJfZ2V0VHJhbnNwb3J0IiwiT1RMUFRyYW5zcG9ydE9wdGlvbnMiLCJfZ2V0T1RMUFRyYW5zcG9ydCIsIl9wb3N0UHJvbWlzZSIsIl9yZWYiLCJwYXlsb2FkIiwic2VsZiIsInJlamVjdCIsInBvc3QiLCJlcnIiLCJyZXNwIiwicG9zdEl0ZW0iLCJkYXRhIiwiY2FsbGJhY2siLCJidWlsZFBheWxvYWQiLCJzZXRUaW1lb3V0IiwicG9zdFNwYW5zIiwiX3JlZjIiLCJfY2FsbGVlIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsIl94IiwiYnVpbGRKc29uUGF5bG9hZCIsInN0cmluZ2lmeVJlc3VsdCIsInRydW5jYXRlIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJwb3N0SnNvblBheWxvYWQiLCJqc29uUGF5bG9hZCIsImNvbmZpZ3VyZSIsIm9sZE9wdGlvbnMiLCJtZXJnZSIsInVuZGVmaW5lZCIsImdldFRyYW5zcG9ydEZyb21PcHRpb25zIiwiX29wdGlvbnMkdHJhY2luZyIsIl9vYmplY3RTcHJlYWQiLCJlbmRwb2ludCIsInRyYWNpbmciLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNUeXBlIiwiY29udGV4dCIsImNvbnRleHRSZXN1bHQiLCJzdWJzdHIiLCJkZWZhdWx0cyIsInRpbWVvdXQiLCJkZXRlY3RUcmFuc3BvcnQiLCJwcm94eSIsIm9wdHMiLCJwYXJzZSIsInBhdGhuYW1lIiwiZ1dpbmRvdyIsIndpbmRvdyIsImRlZmF1bHRUcmFuc3BvcnQiLCJmZXRjaCIsIlhNTEh0dHBSZXF1ZXN0IiwidHJhbnNwb3J0QVBJIiwiaG9zdCIsImFwcGVuZFBhdGhUb1BhdGgiLCJiYXNlIiwiYmFzZVRyYWlsaW5nU2xhc2giLCJ0ZXN0IiwicGF0aEJlZ2lubmluZ1NsYXNoIiwic3Vic3RyaW5nIiwiQ2xpZW50IiwiQVBJIiwibG9nZ2VyIiwiZ2xvYmFscyIsIlRyYW5zcG9ydCIsInRyYW5zZm9ybXMiLCJzaGFyZWRUcmFuc2Zvcm1zIiwicHJlZGljYXRlcyIsInNoYXJlZFByZWRpY2F0ZXMiLCJlcnJvclBhcnNlciIsInJlY29yZGVyRGVmYXVsdHMiLCJ0cmFjaW5nRGVmYXVsdHMiLCJSZXBsYXlNYXAiLCJSb2xsYmFyIiwiY2xpZW50IiwiaGFuZGxlT3B0aW9ucyIsIl9jb25maWd1cmVkT3B0aW9ucyIsIlRlbGVtZXRlciIsImNvbXBvbmVudHMiLCJ0ZWxlbWV0ZXIiLCJJbnN0cnVtZW50ZXIiLCJpbnN0cnVtZW50ZXIiLCJwb2x5ZmlsbEpTT04iLCJ3cmFwR2xvYmFscyIsInNjcnViIiwiVHJhY2luZyIsIlJlY29yZGVyIiwicmVjb3JkZXIiLCJhcGkiLCJfZ1dpbmRvdyIsImluaXRTZXNzaW9uIiwiaXNCcm93c2VyIiwicmVjb3JkZXJPcHRpb25zIiwicmVwbGF5TWFwIiwiZW5hYmxlZCIsImF1dG9TdGFydCIsInN0YXJ0IiwiZ0RvY3VtZW50IiwiZG9jdW1lbnQiLCJpc0Nocm9tZSIsImNocm9tZSIsInJ1bnRpbWUiLCJhbm9ueW1vdXNFcnJvcnNQZW5kaW5nIiwiYWRkVHJhbnNmb3Jtc1RvTm90aWZpZXIiLCJub3RpZmllciIsImFkZFByZWRpY2F0ZXNUb1F1ZXVlIiwicXVldWUiLCJzZXR1cFVuaGFuZGxlZENhcHR1cmUiLCJpbnN0cnVtZW50Iiwic2V0dXBKU09OIiwicm9sbGJhciIsIl9pbnN0YW5jZSIsImluaXQiLCJnbG9iYWwiLCJzZXRDb21wb25lbnRzIiwiaGFuZGxlVW5pbml0aWFsaXplZCIsIm1heWJlQ2FsbGJhY2siLCJtZXNzYWdlIiwicGF5bG9hZERhdGEiLCJfdGhpcyRyZWNvcmRlciIsImxhc3RFcnJvciIsImxvZyIsIml0ZW0iLCJfY3JlYXRlSXRlbSIsInV1aWQiLCJfZ2V0Rmlyc3RGdW5jdGlvbiIsImRlYnVnIiwiaW5mbyIsIndhcm4iLCJ3YXJuaW5nIiwiY3JpdGljYWwiLCJzZW5kSnNvblBheWxvYWQiLCJ1bmhhbmRsZWRFeGNlcHRpb25zSW5pdGlhbGl6ZWQiLCJjYXB0dXJlVW5jYXVnaHQiLCJoYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnMiLCJjYXB0dXJlVW5jYXVnaHRFeGNlcHRpb25zIiwid3JhcEdsb2JhbEV2ZW50SGFuZGxlcnMiLCJ1bmhhbmRsZWRSZWplY3Rpb25zSW5pdGlhbGl6ZWQiLCJjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucyIsImhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbnMiLCJoYW5kbGVVbmNhdWdodEV4Y2VwdGlvbiIsImxpbmVubyIsImNvbG5vIiwiaW5zcGVjdEFub255bW91c0Vycm9ycyIsInN0YWNrSW5mbyIsIm1ha2VVbmhhbmRsZWRTdGFja0luZm8iLCJpc0Vycm9yIiwiX3VuaGFuZGxlZFN0YWNrSW5mbyIsImxldmVsIiwidW5jYXVnaHRFcnJvckxldmVsIiwiX2lzVW5jYXVnaHQiLCJoYW5kbGVBbm9ueW1vdXNFcnJvcnMiLCJwcmVwYXJlU3RhY2tUcmFjZSIsIl9zdGFjayIsIl9pc0Fub255bW91cyIsInN0YWNrIiwiaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uIiwicmVhc29uIiwicHJvbWlzZSIsInJlYXNvblJlc3VsdCIsIl9yb2xsYmFyQ29udGV4dCIsIl9vcmlnaW5hbEFyZ3MiLCJfYmVmb3JlIiwiY3R4Rm4iLCJpc0Z1bmN0aW9uIiwiX2lzV3JhcCIsIl9yb2xsYmFyX3dyYXBwZWQiLCJleGMiLCJfcm9sbGJhcldyYXBwZWRFcnJvciIsIlN0cmluZyIsIl93cmFwcGVkU291cmNlIiwidG9TdHJpbmciLCJwcm9wIiwiY2FwdHVyZUV2ZW50IiwiZXZlbnQiLCJjcmVhdGVUZWxlbWV0cnlFdmVudCIsIm1ldGFkYXRhIiwiY2FwdHVyZURvbUNvbnRlbnRMb2FkZWQiLCJ0cyIsIkRhdGUiLCJjYXB0dXJlTG9hZCIsImFkZFRyYW5zZm9ybSIsImhhbmRsZURvbUV4Y2VwdGlvbiIsImhhbmRsZUl0ZW1XaXRoRXJyb3IiLCJlbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXkiLCJhZGRCYXNlSW5mbyIsImFkZFJlcXVlc3RJbmZvIiwiYWRkQ2xpZW50SW5mbyIsImFkZFBsdWdpbkluZm8iLCJhZGRCb2R5IiwiYWRkTWVzc2FnZVdpdGhFcnJvciIsImFkZFRlbGVtZXRyeURhdGEiLCJhZGRDb25maWdUb1BheWxvYWQiLCJhZGRTY3J1YmJlciIsImFkZFBheWxvYWRPcHRpb25zIiwidXNlclRyYW5zZm9ybSIsImFkZENvbmZpZ3VyZWRPcHRpb25zIiwiYWRkRGlhZ25vc3RpY0tleXMiLCJpdGVtVG9QYXlsb2FkIiwiYWRkUHJlZGljYXRlIiwiY2hlY2tMZXZlbCIsImNoZWNrSWdub3JlIiwidXNlckNoZWNrSWdub3JlIiwidXJsSXNOb3RCbG9ja0xpc3RlZCIsInVybElzU2FmZUxpc3RlZCIsIm1lc3NhZ2VJc0lnbm9yZWQiLCJsb2FkRnVsbCIsImFyZ3MiLCJjcmVhdGVJdGVtIiwibGVuIiwic2NydWJGaWVsZHMiLCJsb2dMZXZlbCIsInJlcG9ydExldmVsIiwidmVyYm9zZSIsInRyYW5zbWl0Iiwic2VuZENvbmZpZyIsImluY2x1ZGVJdGVtc0luVGVsZW1ldHJ5IiwiY2FwdHVyZUlwIiwiaWdub3JlRHVwbGljYXRlRXJyb3JzIiwiZ2V0SUVWZXJzaW9uIiwidW5kZWYiLCJkaXYiLCJjcmVhdGVFbGVtZW50IiwiYWxsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbm5lckhUTUwiLCJEZXRlY3Rpb24iLCJpZVZlcnNpb24iLCJnZXRFbGVtZW50VHlwZSIsImdldEF0dHJpYnV0ZSIsInRvTG93ZXJDYXNlIiwiaXNEZXNjcmliZWRFbGVtZW50IiwiZWxlbWVudCIsInN1YnR5cGVzIiwidGFnTmFtZSIsImdldEVsZW1lbnRGcm9tRXZlbnQiLCJldnQiLCJkb2MiLCJ0YXJnZXQiLCJlbGVtZW50RnJvbVBvaW50IiwiY2xpZW50WCIsImNsaWVudFkiLCJ0cmVlVG9BcnJheSIsImVsZW0iLCJNQVhfSEVJR0hUIiwib3V0IiwibmV4dERlc2NyaXB0aW9uIiwiaGVpZ2h0IiwiZGVzY3JpYmVFbGVtZW50IiwidW5zaGlmdCIsInBhcmVudE5vZGUiLCJlbGVtZW50QXJyYXlUb1N0cmluZyIsIk1BWF9MRU5HVEgiLCJzZXBhcmF0b3IiLCJzZXBhcmF0b3JMZW5ndGgiLCJuZXh0U3RyIiwidG90YWxMZW5ndGgiLCJkZXNjcmlwdGlvblRvU3RyaW5nIiwiam9pbiIsImRlc2MiLCJpZCIsImNsYXNzZXMiLCJhdHRyaWJ1dGVzIiwia2V5IiwiY2xhc3NOYW1lIiwiYXR0ciIsInNwbGl0IiwiaGFuZGxlciIsInNoaW0iLCJvbGRPbkVycm9yIiwiX3JvbGxiYXJPbGRPbkVycm9yIiwib25lcnJvciIsImZuIiwiQXJyYXkiLCJfcm9sbGJhcldpbmRvd09uRXJyb3IiLCJvbGQiLCJyZXQiLCJfcm9sbGJhclVSSCIsImJlbG9uZ3NUb1NoaW0iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVqZWN0aW9uSGFuZGxlciIsImRldGFpbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXRlY3Rpb24iLCJjb25zb2xlIiwiZm9ybWF0QXJnc0FzU3RyaW5nIiwic2V0dGluZ3MiLCJnZXQiLCJsb2dFbWl0cyIsImlubGluZVN0eWxlc2hlZXQiLCJpbmxpbmVJbWFnZXMiLCJjb2xsZWN0Rm9udHMiLCJtYXNrSW5wdXRPcHRpb25zIiwicGFzc3dvcmQiLCJlbWFpbCIsInRlbCIsInRleHQiLCJjb2xvciIsImRhdGUiLCJtb250aCIsIm51bWJlciIsInJhbmdlIiwidGltZSIsIndlZWsiLCJzbGltRE9NT3B0aW9ucyIsInNjcmlwdCIsImNvbW1lbnQiLCJoZWFkRmF2aWNvbiIsImhlYWRXaGl0ZXNwYWNlIiwiaGVhZE1ldGFEZXNjS2V5d29yZHMiLCJoZWFkTWV0YVNvY2lhbCIsImhlYWRNZXRhUm9ib3RzIiwiaGVhZE1ldGFIdHRwRXF1aXYiLCJoZWFkTWV0YUF1dGhvcnNoaXAiLCJoZWFkTWV0YVZlcmlmaWNhdGlvbiIsInJlY29yZCIsInJyd2ViUmVjb3JkRm4iLCJFdmVudFR5cGUiLCJocnRpbWUiLCJfb3B0aW9ucyIsIldlYWtNYXAiLCJfc3RvcEZuIiwiX3JlY29yZEZuIiwiX2V2ZW50cyIsInJlY29yZEZuIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMiLCJwcmV2aW91cyIsImN1cnJlbnQiLCJfY2xhc3NQcml2YXRlRmllbGRTZXQiLCJfY3JlYXRlQ2xhc3MiLCJfY2xhc3NQcml2YXRlRmllbGRHZXQiLCJzZXQiLCJuZXdPcHRpb25zIiwiaXNSZWNvcmRpbmciLCJkdW1wIiwicmVwbGF5SWQiLCJvY2N1cnJlbmNlVXVpZCIsImV2ZW50cyIsImNvbmNhdCIsInJlY29yZGluZ1NwYW4iLCJzdGFydFNwYW4iLCJzZXRBdHRyaWJ1dGUiLCJlYXJsaWVzdEV2ZW50IiwicmVkdWNlIiwidGltZXN0YW1wIiwic3BhbiIsInN0YXJ0VGltZSIsImZyb21NaWxsaXMiLCJfaXRlcmF0b3IiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIl9zdGVwIiwiYWRkRXZlbnQiLCJldmVudFR5cGUiLCJqc29uIiwiSlNPTiIsImVuZCIsImV4cG9ydGVyIiwidG9QYXlsb2FkIiwiX3RoaXMiLCJjbGVhciIsImVtaXQiLCJpc0NoZWNrb3V0IiwiX3RoaXMkb3B0aW9ucyRkZWJ1ZyIsIl9sb2dFdmVudCIsIk1ldGEiLCJjaGVja291dEV2ZXJ5Tm1zIiwic2VlbiIsIldlYWtTZXQiLCJoYXMiLCJhZGQiLCJkZWZhdWx0IiwiX2RlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiTnVtYmVyIiwiX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24iLCJfYXNzZXJ0Q2xhc3NCcmFuZCIsIl9tYXAiLCJfcmVjb3JkZXIiLCJfYXBpIiwiX3RyYWNpbmciLCJNYXAiLCJfcHJvY2Vzc1JlcGxheTIiLCJ0cmFuc2Zvcm1FcnJvciIsIl9wcm9jZXNzUmVwbGF5IiwiX3gyIiwiZ2VuIiwiX3NlbmQiLCJfY2FsbGVlMiIsImlzRW1wdHkiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJpc0FycmF5IiwicmVzb3VyY2VTcGFucyIsInQwIiwic2VuZCIsIl94MyIsImRpc2NhcmQiLCJnZXRTcGFucyIsIl9jbGFzc1ByaXZhdGVGaWVsZEdldDIiLCJzZXRTcGFucyIsInNwYW5zIiwic2l6ZSIsImhlYWRlcnMiLCJyZXBsYWNlIiwidXJscGFyc2VyIiwiZG9tVXRpbCIsIm5ldHdvcmsiLCJuZXR3b3JrUmVzcG9uc2VIZWFkZXJzIiwibmV0d29ya1Jlc3BvbnNlQm9keSIsIm5ldHdvcmtSZXF1ZXN0SGVhZGVycyIsIm5ldHdvcmtSZXF1ZXN0Qm9keSIsIm5ldHdvcmtFcnJvck9uSHR0cDV4eCIsIm5ldHdvcmtFcnJvck9uSHR0cDR4eCIsIm5ldHdvcmtFcnJvck9uSHR0cDAiLCJkb20iLCJuYXZpZ2F0aW9uIiwiY29ubmVjdGl2aXR5IiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiZXJyb3JPbkNvbnRlbnRTZWN1cml0eVBvbGljeSIsInJlc3RvcmUiLCJyZXBsYWNlbWVudHMiLCJiIiwic2hpZnQiLCJuYW1lRnJvbURlc2NyaXB0aW9uIiwiZGVzY3JpcHRpb24iLCJhdHRycyIsImRlZmF1bHRWYWx1ZVNjcnViYmVyIiwicGF0dGVybnMiLCJSZWdFeHAiLCJfd2luZG93IiwiX2RvY3VtZW50IiwiYXV0b0luc3RydW1lbnQiLCJzY3J1YlRlbGVtZXRyeUlucHV0cyIsInRlbGVtZXRyeVNjcnViYmVyIiwiZGlhZ25vc3RpYyIsImV2ZW50UmVtb3ZlcnMiLCJjb250ZW50c2VjdXJpdHlwb2xpY3kiLCJfbG9jYXRpb24iLCJsb2NhdGlvbiIsIl9sYXN0SHJlZiIsImhyZWYiLCJvbGRTZXR0aW5ncyIsImluc3RydW1lbnROZXR3b3JrIiwiZGVpbnN0cnVtZW50TmV0d29yayIsImluc3RydW1lbnRDb25zb2xlIiwiZGVpbnN0cnVtZW50Q29uc29sZSIsImluc3RydW1lbnREb20iLCJkZWluc3RydW1lbnREb20iLCJpbnN0cnVtZW50TmF2aWdhdGlvbiIsImRlaW5zdHJ1bWVudE5hdmlnYXRpb24iLCJpbnN0cnVtZW50Q29ubmVjdGl2aXR5IiwiZGVpbnN0cnVtZW50Q29ubmVjdGl2aXR5IiwiaW5zdHJ1bWVudENvbnRlbnRTZWN1cml0eVBvbGljeSIsImRlaW5zdHJ1bWVudENvbnRlbnRTZWN1cml0eVBvbGljeSIsIndyYXBQcm9wIiwieGhyIiwib3JpZyIsInhocnAiLCJpc1VybE9iamVjdCIsIl9pc1VybE9iamVjdCIsIl9fcm9sbGJhcl94aHIiLCJzdGF0dXNfY29kZSIsInN0YXJ0X3RpbWVfbXMiLCJub3ciLCJlbmRfdGltZV9tcyIsImhlYWRlciIsInJlcXVlc3RfaGVhZGVycyIsInJlcXVlc3RfY29udGVudF90eXBlIiwib25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlciIsInJlcXVlc3QiLCJfX3JvbGxiYXJfZXZlbnQiLCJjYXB0dXJlTmV0d29yayIsInJlYWR5U3RhdGUiLCJyZXNwb25zZV9jb250ZW50X3R5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsImhlYWRlcnNDb25maWciLCJhbGxIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiYXJyIiwidHJpbSIsInBhcnRzIiwiYm9keSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlIiwiaXNKc29uQ29udGVudFR5cGUiLCJzY3J1Ykpzb24iLCJjb2RlIiwic3RhdHVzIiwibGV2ZWxGcm9tU3RhdHVzIiwiZXJyb3JPbkh0dHBTdGF0dXMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJ0cmFja0h0dHBFcnJvcnMiLCJpbnB1dCIsInJlcUhlYWRlcnMiLCJmZXRjaEhlYWRlcnMiLCJjbG9uZSIsInN1YnR5cGUiLCJyb2xsYmFyVVVJRCIsImNvbnRlbnRUeXBlIiwiaW5jbHVkZXMiLCJpbkhlYWRlcnMiLCJvdXRIZWFkZXJzIiwiZW50cmllcyIsImN1cnJlbnRIZWFkZXIiLCJza2lwRnJhbWVzIiwid3JhcENvbnNvbGUiLCJvcmlnQ29uc29sZSIsImNhcHR1cmVMb2ciLCJGdW5jdGlvbiIsIm1ldGhvZHMiLCJyZW1vdmVMaXN0ZW5lcnMiLCJjbGlja0hhbmRsZXIiLCJoYW5kbGVDbGljayIsImJpbmQiLCJibHVySGFuZGxlciIsImhhbmRsZUJsdXIiLCJhZGRMaXN0ZW5lciIsImhhc1RhZyIsImFuY2hvck9yQnV0dG9uIiwiY2FwdHVyZURvbUV2ZW50IiwiY2hlY2tlZCIsImhhbmRsZVNlbGVjdElucHV0Q2hhbmdlZCIsIm11bHRpcGxlIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwiaXNDaGVja2VkIiwiZWxlbWVudFN0cmluZyIsImNhcHR1cmVEb20iLCJjaHJvbWVQYWNrYWdlZEFwcCIsImFwcCIsImhhc1B1c2hTdGF0ZSIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJoYW5kbGVVcmxDaGFuZ2UiLCJmcm9tIiwidG8iLCJwYXJzZWRIcmVmIiwicGFyc2VkVG8iLCJwYXJzZWRGcm9tIiwiaGFzaCIsImNhcHR1cmVOYXZpZ2F0aW9uIiwiY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSIsImhhbmRsZUNzcEV2ZW50IiwiY3NwRXZlbnQiLCJibG9ja2VkVVJJIiwidmlvbGF0ZWREaXJlY3RpdmUiLCJlZmZlY3RpdmVEaXJlY3RpdmUiLCJzb3VyY2VGaWxlIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsIm9yaWdpbmFsUG9saWN5IiwiaGFuZGxlQ3NwRXJyb3IiLCJjc3BIYW5kbGVyIiwic2VjdGlvbiIsIm9iaiIsImFsdFR5cGUiLCJjYXB0dXJlIiwiYXR0YWNoRXZlbnQiLCJkZXRhY2hFdmVudCIsIlVSTCIsIlN0YWNrIiwib3JpZ2luYWxFcnJvciIsIm5lc3RlZCIsIl9zYXZlZFN0YWNrVHJhY2UiLCJhZGRFcnJvckNvbnRleHQiLCJlMiIsImNoYWluIiwiY2F1c2UiLCJjdXN0b20iLCJlbnZpcm9ubWVudCIsInBsYXRmb3JtIiwiZnJhbWV3b3JrIiwibGFuZ3VhZ2UiLCJzZXJ2ZXIiLCJyZXF1ZXN0SW5mbyIsInF1ZXJ5X3N0cmluZyIsInJlbW90ZVN0cmluZyIsInVzZXJfaXAiLCJuYXYiLCJuYXZpZ2F0b3IiLCJzY3IiLCJzY3JlZW4iLCJydW50aW1lX21zIiwiX3JvbGxiYXJTdGFydFRpbWUiLCJNYXRoIiwicm91bmQiLCJqYXZhc2NyaXB0IiwiYnJvd3NlciIsInVzZXJBZ2VudCIsImNvb2tpZV9lbmFibGVkIiwiY29va2llRW5hYmxlZCIsIndpZHRoIiwicGx1Z2lucyIsIm5hdlBsdWdpbnMiLCJjdXIiLCJ0cmFjZUNoYWluIiwiYWRkQm9keVRyYWNlQ2hhaW4iLCJhZGRCb2R5VHJhY2UiLCJhZGRCb2R5TWVzc2FnZSIsInJlc3VsdCIsImV4dHJhIiwic3RhY2tGcm9tSXRlbSIsInRyYWNlcyIsInRyYWNlQ2hhaW5MZW5ndGgiLCJ0cmFjZSIsImJ1aWxkVHJhY2UiLCJ0cmFjZV9jaGFpbiIsImd1ZXNzIiwiZ3Vlc3NFcnJvckNsYXNzIiwiZXJyb3JDbGFzcyIsImV4Y2VwdGlvbiIsInJhd1N0YWNrIiwicmF3IiwicmF3RXhjZXB0aW9uIiwic3RhY2tGcmFtZSIsImZyYW1lIiwicHJlIiwiY29udGV4dExlbmd0aCIsIm1pZCIsImZyYW1lcyIsImZpbGVuYW1lIiwic2FuaXRpemVVcmwiLCJsaW5lIiwiZnVuYyIsImNvbHVtbiIsInNlbmRGcmFtZVVybCIsImVuZHNXaXRoIiwiZmxvb3IiLCJzY3J1YkZuIiwic2NydWJQYXRocyIsIm1ha2VGZXRjaFJlcXVlc3QiLCJtYWtlWGhyUmVxdWVzdCIsInBhcmFtcyIsInJlcXVlc3RGYWN0b3J5IiwiYWRkUGFyYW1zQW5kQWNjZXNzVG9rZW5Ub1BhdGgiLCJmb3JtYXRVcmwiLCJfbWFrZVpvbmVSZXF1ZXN0Iiwid3JpdGVEYXRhIiwicm9vdFpvbmUiLCJab25lIiwicm9vdCIsInJ1biIsIl9tYWtlUmVxdWVzdCIsIlJvbGxiYXJQcm94eSIsIl9wcm94eVJlcXVlc3QiLCJyb2xsYmFyUHJveHkiLCJfbXNnIiwiY29udHJvbGxlciIsInRpbWVvdXRJZCIsImlzRmluaXRlTnVtYmVyIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnQiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJfY3JlYXRlWE1MSFRUUE9iamVjdCIsInBhcnNlUmVzcG9uc2UiLCJqc29uUGFyc2UiLCJfaXNTdWNjZXNzIiwiX2lzTm9ybWFsRmFpbHVyZSIsIm1zZyIsIl9uZXdSZXRyaWFibGVFcnJvciIsImV4Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJlMSIsIlhEb21haW5SZXF1ZXN0IiwieGRvbWFpbnJlcXVlc3QiLCJvbnByb2dyZXNzIiwib250aW1lb3V0Iiwib25sb2FkIiwiZmFjdG9yaWVzIiwiQWN0aXZlWE9iamVjdCIsInhtbGh0dHAiLCJudW1GYWN0b3JpZXMiLCJhdXRoIiwicXVlcnkiLCJsYXN0IiwiaW5kZXhPZiIsInBhcnNlSW50IiwicGF0aFBhcnRzIiwiX2V4dGVuZExpc3RlbmVyUHJvdG90eXBlIiwib2xkQWRkRXZlbnRMaXN0ZW5lciIsIl9yb2xsYmFyT2xkQWRkIiwiYWRkRm4iLCJidWJibGUiLCJvbGRSZW1vdmVFdmVudExpc3RlbmVyIiwiX3JvbGxiYXJPbGRSZW1vdmUiLCJyZW1vdmVGbiIsIm1heEl0ZW1zIiwiaXRlbXNQZXJNaW4iLCJFcnJvclN0YWNrUGFyc2VyIiwiVU5LTk9XTl9GVU5DVElPTiIsIkVSUl9DTEFTU19SRUdFWFAiLCJndWVzc0Z1bmN0aW9uTmFtZSIsImdhdGhlckNvbnRleHQiLCJGcmFtZSIsIl9zdGFja0ZyYW1lIiwiZmlsZU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJza2lwIiwiZ2V0U3RhY2siLCJwYXJzZXJTdGFjayIsIl9tb3N0U3BlY2lmaWNFcnJvck5hbWUiLCJlcnJNc2ciLCJtYXRjaCIsImVyckNsYXNzTWF0Y2giLCJlcnJDbGFzcyIsImNvbnN0cnVjdG9yTmFtZSIsImhhc093biIsInRvU3RyIiwiaXNQbGFpbk9iamVjdCIsImhhc093bkNvbnN0cnVjdG9yIiwiaGFzSXNQcm90b3R5cGVPZiIsInNyYyIsImNvcHkiLCJOb3RpZmllciIsInRyYW5zZm9ybSIsImFkZFBlbmRpbmdJdGVtIiwiX2FwcGx5VHJhbnNmb3JtcyIsInJlbW92ZVBlbmRpbmdJdGVtIiwiYWRkSXRlbSIsInRyYW5zZm9ybUluZGV4IiwidHJhbnNmb3Jtc0xlbmd0aCIsImNiIiwibGV2ZWxWYWwiLCJMRVZFTFMiLCJyZXBvcnRMZXZlbFZhbCIsImlzVW5jYXVnaHQiLCJvblNlbmRDYWxsYmFjayIsInVybElzT25BTGlzdCIsIm1hdGNoRnJhbWVzIiwibGlzdCIsImJsb2NrIiwidXJsUmVnZXgiLCJsaXN0TGVuZ3RoIiwiZnJhbWVMZW5ndGgiLCJqIiwic2FmZU9yQmxvY2siLCJob3N0QmxvY2tMaXN0IiwiaG9zdFNhZmVMaXN0IiwidHJhY2VzTGVuZ3RoIiwibGlzdE5hbWUiLCJpZ25vcmVkTWVzc2FnZXMiLCJySWdub3JlZE1lc3NhZ2UiLCJtZXNzYWdlcyIsIm1lc3NhZ2VzRnJvbUl0ZW0iLCJRdWV1ZSIsInJhdGVMaW1pdGVyIiwicGVuZGluZ0l0ZW1zIiwicGVuZGluZ1JlcXVlc3RzIiwicmV0cnlRdWV1ZSIsInJldHJ5SGFuZGxlIiwid2FpdENhbGxiYWNrIiwid2FpdEludGVydmFsSUQiLCJwcmVkaWNhdGUiLCJpZHgiLCJzcGxpY2UiLCJvcmlnaW5hbEl0ZW0iLCJwcmVkaWNhdGVSZXN1bHQiLCJfYXBwbHlQcmVkaWNhdGVzIiwiX21heWJlTG9nIiwiX21ha2VBcGlSZXF1ZXN0IiwiX2RlcXVldWVQZW5kaW5nUmVxdWVzdCIsIl9oYW5kbGVSZXBsYXlSZXNwb25zZSIsIndhaXQiLCJfbWF5YmVDYWxsV2FpdCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInJhdGVMaW1pdFJlc3BvbnNlIiwic2hvdWxkU2VuZCIsIl9tYXliZVJldHJ5IiwiUkVUUklBQkxFX0VSUk9SUyIsInNob3VsZFJldHJ5IiwicmV0cnlJbnRlcnZhbCIsIm1heFJldHJpZXMiLCJyZXRyaWVzIiwiX3JldHJ5QXBpUmVxdWVzdCIsInJldHJ5T2JqZWN0IiwiUmF0ZUxpbWl0ZXIiLCJjb3VudGVyIiwicGVyTWluQ291bnRlciIsInBsYXRmb3JtT3B0aW9ucyIsImNvbmZpZ3VyZUdsb2JhbCIsImdsb2JhbFNldHRpbmdzIiwiaXRlbXNQZXJNaW51dGUiLCJlbGFwc2VkVGltZSIsImdsb2JhbFJhdGVMaW1pdCIsImdsb2JhbFJhdGVMaW1pdFBlck1pbiIsImNoZWNrUmF0ZSIsInNob3VsZFNlbmRWYWx1ZSIsInBlck1pbnV0ZSIsInNldFBsYXRmb3JtT3B0aW9ucyIsImxpbWl0IiwiaWdub3JlUmF0ZUxpbWl0IiwibGltaXRQZXJNaW4iLCJyYXRlTGltaXRQYXlsb2FkIiwidHJhY2VyIiwidmFsaWRhdGVUcmFjZXIiLCJzZXRTdGFja1RyYWNlTGltaXQiLCJsYXN0RXJyb3JIYXNoIiwiX2RlZmF1bHRMb2dMZXZlbCIsIl9sb2ciLCJkZWZhdWx0TGV2ZWwiLCJfc2FtZUFzTGFzdEVycm9yIiwiX2FkZFRyYWNpbmdBdHRyaWJ1dGVzIiwiX2FkZFRyYWNpbmdJbmZvIiwiX2NhcHR1cmVSb2xsYmFySXRlbSIsInRlbGVtZXRyeUV2ZW50cyIsImNvcHlFdmVudHMiLCJ0ZWxlbWV0cnlTcGFuIiwiX3RoaXMkdHJhY2luZyIsImdldFNwYW4iLCJzZXNzaW9uSWQiLCJzcGFuSWQiLCJ0cmFjZUlkIiwiYWRkSXRlbUF0dHJpYnV0ZXMiLCJpdGVtSGFzaCIsImdlbmVyYXRlSXRlbUhhc2giLCJzY29wZSIsImFjdGl2ZSIsInZhbGlkYXRlU3BhbiIsInNldFRhZyIsIm9wZW50cmFjaW5nU3BhbklkIiwidG9TcGFuSWQiLCJvcGVudHJhY2luZ1RyYWNlSWQiLCJ0b1RyYWNlSWQiLCJvcGVudHJhY2luZ19zcGFuX2lkIiwib3BlbnRyYWNpbmdfdHJhY2VfaWQiLCJzdGFja1RyYWNlTGltaXQiLCJzcGFuQ29udGV4dCIsInRyYXZlcnNlIiwic2NydWJQYXRoIiwicGFyYW1SZXMiLCJfZ2V0U2NydWJGaWVsZFJlZ2V4cyIsInF1ZXJ5UmVzIiwiX2dldFNjcnViUXVlcnlQYXJhbVJlZ2V4cyIsInJlZGFjdFF1ZXJ5UGFyYW0iLCJkdW1teTAiLCJwYXJhbVBhcnQiLCJyZWRhY3QiLCJwYXJhbVNjcnViYmVyIiwidmFsU2NydWJiZXIiLCJrIiwic2NydWJiZXIiLCJ0bXBWIiwicGF0IiwiTUFYX0VWRU5UUyIsIm1pbGxpcyIsInRydW5jIiwibWF4VGVsZW1ldHJ5RXZlbnRzIiwibWF4UXVldWVTaXplIiwibWF4IiwibWluIiwibmV3TWF4RXZlbnRzIiwiZGVsZXRlQ291bnQiLCJmaWx0ZXJUZWxlbWV0cnkiLCJnZXRMZXZlbCIsInRpbWVzdGFtcF9tcyIsInNvdXJjZSIsImNhcHR1cmVFcnJvciIsIl90aGlzJHRlbGVtZXRyeVNwYW4iLCJfdGhpcyR0ZWxlbWV0cnlTcGFuMiIsIl90aGlzJHRlbGVtZXRyeVNwYW4zIiwicmVxdWVzdERhdGEiLCJzdGF0dXNDb2RlIiwiX3RoaXMkdGVsZW1ldHJ5U3BhbjQiLCJnZXRUaW1lIiwiY2hhbmdlIiwibWFudWFsIiwicGFyZW50Q29udGV4dCIsIl9jdXJyZW50Q29udGV4dCIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJkZWxldGVWYWx1ZSIsIlJPT1RfQ09OVEVYVCIsIkNvbnRleHRNYW5hZ2VyIiwiY3VycmVudENvbnRleHQiLCJlbnRlckNvbnRleHQiLCJwcmV2aW91c0NvbnRleHQiLCJleGl0Q29udGV4dCIsIndpdGgiLCJ0aGlzQXJnIiwiX2xlbiIsIl9rZXkiLCJjcmVhdGVDb250ZXh0S2V5IiwiU3BhbkV4cG9ydGVyIiwiZXhwb3J0IiwiX3Jlc3VsdENhbGxiYWNrIiwic3BhbkV4cG9ydFF1ZXVlIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwicmVzb3VyY2UiLCJzY29wZU1hcCIsInNjb3BlS2V5IiwiaW5zdHJ1bWVudGF0aW9uU2NvcGUiLCJfdHJhbnNmb3JtU3BhbiIsIl90cmFuc2Zvcm1SZXNvdXJjZSIsInNjb3BlU3BhbnMiLCJtYXAiLCJzY29wZURhdGEiLCJfdHJhbnNmb3JtSW5zdHJ1bWVudGF0aW9uU2NvcGUiLCJfdGhpczIiLCJ0cmFuc2Zvcm1BdHRyaWJ1dGVzIiwiX3NsaWNlZFRvQXJyYXkiLCJfdHJhbnNmb3JtQW55VmFsdWUiLCJ0cmFuc2Zvcm1FdmVudHMiLCJ0aW1lVW5peE5hbm8iLCJ0b05hbm9zIiwicGFyZW50U3BhbklkIiwia2luZCIsInN0YXJ0VGltZVVuaXhOYW5vIiwiZW5kVGltZVVuaXhOYW5vIiwiZW5kVGltZSIsIl90aGlzMyIsImtleVZhbHVlcyIsIl9yZWYzIiwiX3JlZjQiLCJfdGhpczQiLCJfdGhpczUiLCJzdHJpbmdWYWx1ZSIsImlzSW50ZWdlciIsImludFZhbHVlIiwiZG91YmxlVmFsdWUiLCJib29sVmFsdWUiLCJhcnJheVZhbHVlIiwia3ZsaXN0VmFsdWUiLCJfcmVmNSIsIl9yZWY2IiwidG9NaWxsaXMiLCJwZXJmb3JtYW5jZSIsInRpbWVPcmlnaW4iLCJpc0hyVGltZSIsImJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJVaW50OEFycmF5IiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZEhleCIsImJ5dGUiLCJwYWRTdGFydCIsIlNFU1NJT05fS0VZIiwiU2Vzc2lvbiIsInNlc3Npb24iLCJnZXRTZXNzaW9uIiwiY3JlYXRlU2Vzc2lvbiIsInNlcmlhbGl6ZWRTZXNzaW9uIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiX3VudXNlZCIsImNyZWF0ZWRBdCIsInNldFNlc3Npb24iLCJzZXNzaW9uU3RyaW5nIiwic2V0SXRlbSIsIl91bnVzZWQyIiwiU3BhbiIsImluaXRSZWFkYWJsZVNwYW4iLCJzcGFuUHJvY2Vzc29yIiwib25TdGFydCIsInNldEF0dHJpYnV0ZXMiLCJsaW5rcyIsImR1cmF0aW9uIiwiZW5kZWQiLCJkcm9wcGVkQXR0cmlidXRlc0NvdW50IiwiZHJvcHBlZEV2ZW50c0NvdW50IiwiZHJvcHBlZExpbmtzQ291bnQiLCJfaSIsIl9PYmplY3QkZW50cmllcyIsIl9PYmplY3QkZW50cmllcyRfaSIsIm9uRW5kIiwiU3BhblByb2Nlc3NvciIsInBlbmRpbmdTcGFucyIsIl9wYXJlbnRDb250ZXh0IiwiVHJhY2VyIiwiY29udGV4dE1hbmFnZXIiLCJwYXJlbnRTcGFuIiwicGFyZW50U3BhbkNvbnRleHQiLCJ0cmFjZUZsYWdzIiwidHJhY2VTdGF0ZSIsIlNQQU5fS0VZIiwiY3JlYXRlVHJhY2VyIiwiX3RoaXMkb3B0aW9ucyRwYXlsb2FkIiwiX3RoaXMkb3B0aW9ucyRwYXlsb2FkMiIsImdldFRyYWNlciIsInNldFNwYW4iLCJfdGhpcyRjb250ZXh0TWFuYWdlciIsIndpdGhTcGFuIiwicGF5bG9hZE9wdGlvbnMiLCJ0cmFjZVBhdGgiLCJuZXdFeHRyYSIsIm5ld0l0ZW0iLCJpc1Byb21pc2UiLCJwcm9taXNlZEl0ZW0iLCJjb25maWdLZXkiLCJhZGRGdW5jdGlvbk9wdGlvbiIsImNvbmZpZ3VyZWRPcHRpb25zIiwiY29uZmlndXJlZF9vcHRpb25zIiwiaXNfYW5vbnltb3VzIiwiaXNfdW5jYXVnaHQiLCJyYXdfZXJyb3IiLCJjb25zdHJ1Y3Rvcl9uYW1lIiwiZmFpbGVkIiwianNvbkJhY2t1cCIsInNlbGVjdEZyYW1lcyIsInRydW5jYXRlRnJhbWVzIiwibWF5YmVUcnVuY2F0ZVZhbHVlIiwidmFsIiwidHJ1bmNhdGVTdHJpbmdzIiwidHJ1bmNhdG9yIiwidHlwZU5hbWUiLCJ0cnVuY2F0ZVRyYWNlRGF0YSIsInRyYWNlRGF0YSIsIm1pbkJvZHkiLCJuZWVkc1RydW5jYXRpb24iLCJtYXhTaXplIiwibWF4Qnl0ZVNpemUiLCJzdHJhdGVnaWVzIiwic3RyYXRlZ3kiLCJyZXN1bHRzIiwiUm9sbGJhckpTT04iLCJpc0RlZmluZWQiLCJpc05hdGl2ZUZ1bmN0aW9uIiwieCIsInJlUmVnRXhwQ2hhciIsImZ1bmNNYXRjaFN0cmluZyIsInJlSXNOYXRpdmUiLCJpc09iamVjdCIsImlzU3RyaW5nIiwiaXNGaW5pdGUiLCJpc0l0ZXJhYmxlIiwidXVpZDQiLCJyYW5kb20iLCJiYXNlVXJsUGFydHMiLCJwYXJzZVVyaSIsImFuY2hvciIsInBhcnNlVXJpT3B0aW9ucyIsInN0cmljdE1vZGUiLCJxIiwicGFyc2VyIiwic3RyaWN0IiwibG9vc2UiLCJzdHIiLCJtIiwiZXhlYyIsInVyaSIsIiQwIiwiJDEiLCIkMiIsImFjY2Vzc190b2tlbiIsInBhcmFtc0FycmF5Iiwic29ydCIsInFzIiwiYmFja3VwIiwianNvbkVycm9yIiwiYmFja3VwRXJyb3IiLCJzdHJpbmciLCJjb3VudCIsImNoYXJDb2RlQXQiLCJtb2RlIiwiYmFja3VwTWVzc2FnZSIsInVzZXJhZ2VudCIsIndyYXBDYWxsYmFjayIsIm5vbkNpcmN1bGFyQ2xvbmUiLCJuZXdTZWVuIiwicmVxdWVzdEtleXMiLCJsYW1iZGFDb250ZXh0IiwiZXh0cmFBcmdzIiwiYXJnVHlwZXMiLCJ0eXAiLCJET01FeGNlcHRpb24iLCJzZXRDdXN0b21JdGVtS2V5cyIsIm9yaWdpbmFsX2FyZ190eXBlcyIsImVycm9ycyIsImNvbnRleHRBZGRlZCIsInJvbGxiYXJDb250ZXh0IiwiZXJyb3JfY29udGV4dCIsIlRFTEVNRVRSWV9UWVBFUyIsIlRFTEVNRVRSWV9MRVZFTFMiLCJhcnJheUluY2x1ZGVzIiwiX2l0ZW0kZGF0YSRhdHRyaWJ1dGVzIiwidGVtcCIsInJlcGxhY2VtZW50IiwiZmlsdGVySXAiLCJuZXdJcCIsImJlZ2lubmluZyIsInNsYXNoSWR4IiwidGVybWluYWwiLCJ1cGRhdGVEZXByZWNhdGVkT3B0aW9ucyIsIm92ZXJ3cml0ZVNjcnViRmllbGRzIiwiaG9zdFdoaXRlTGlzdCIsImhvc3RCbGFja0xpc3QiLCJIZWFkZXJzIiwiRmV0Y2hIZWFkZXJzIiwibm9ybWFsaXplTmFtZSIsIm5vcm1hbGl6ZVZhbHVlIiwiaXRlcmF0b3JGb3IiLCJpdGVtcyIsImFwcGVuZCIsImdldE93blByb3BlcnR5TmFtZXMiLCJvbGRWYWx1ZSIsImlzT2JqIiwic2VlbkluZGV4IiwibWFwcGVkIiwic2FtZSJdLCJzb3VyY2VSb290IjoiIn0=