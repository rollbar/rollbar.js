(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@rrweb/record/dist/record.js":
/*!***************************************************!*\
  !*** ./node_modules/@rrweb/record/dist/record.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   record: () => (/* binding */ record)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var NodeType$3 = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType$3 || {});
const testableAccessors$1 = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
};
const testableMethods$1 = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
};
const untaintedBasePrototype$1 = {};
const isAngularZonePresent$1 = () => {
  return !!globalThis.Zone;
};
function getUntaintedPrototype$1(key) {
  if (untaintedBasePrototype$1[key])
    return untaintedBasePrototype$1[key];
  const defaultObj = globalThis[key];
  const defaultPrototype = defaultObj.prototype;
  const accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;
  const isUntaintedAccessors = Boolean(
    accessorNames && // @ts-expect-error 2345
    accessorNames.every(
      (accessor) => {
        var _a2, _b;
        return Boolean(
          (_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes("[native code]")
        );
      }
    )
  );
  const methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;
  const isUntaintedMethods = Boolean(
    methodNames && methodNames.every(
      // @ts-expect-error 2345
      (method) => {
        var _a2;
        return typeof defaultPrototype[method] === "function" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes("[native code]"));
      }
    )
  );
  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {
    untaintedBasePrototype$1[key] = defaultObj.prototype;
    return defaultObj.prototype;
  }
  try {
    const iframeEl = document.createElement("iframe");
    document.body.appendChild(iframeEl);
    const win = iframeEl.contentWindow;
    if (!win) return defaultObj.prototype;
    const untaintedObject = win[key].prototype;
    document.body.removeChild(iframeEl);
    if (!untaintedObject) return defaultPrototype;
    return untaintedBasePrototype$1[key] = untaintedObject;
  } catch {
    return defaultPrototype;
  }
}
const untaintedAccessorCache$1 = {};
function getUntaintedAccessor$1(key, instance, accessor) {
  var _a2;
  const cacheKey = `${key}.${String(accessor)}`;
  if (untaintedAccessorCache$1[cacheKey])
    return untaintedAccessorCache$1[cacheKey].call(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype$1(key);
  const untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(
    untaintedPrototype,
    accessor
  )) == null ? void 0 : _a2.get;
  if (!untaintedAccessor) return instance[accessor];
  untaintedAccessorCache$1[cacheKey] = untaintedAccessor;
  return untaintedAccessor.call(instance);
}
const untaintedMethodCache$1 = {};
function getUntaintedMethod$1(key, instance, method) {
  const cacheKey = `${key}.${String(method)}`;
  if (untaintedMethodCache$1[cacheKey])
    return untaintedMethodCache$1[cacheKey].bind(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype$1(key);
  const untaintedMethod = untaintedPrototype[method];
  if (typeof untaintedMethod !== "function") return instance[method];
  untaintedMethodCache$1[cacheKey] = untaintedMethod;
  return untaintedMethod.bind(instance);
}
function childNodes$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "childNodes");
}
function parentNode$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "parentNode");
}
function parentElement$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "parentElement");
}
function textContent$1(n2) {
  return getUntaintedAccessor$1("Node", n2, "textContent");
}
function contains$1(n2, other) {
  return getUntaintedMethod$1("Node", n2, "contains")(other);
}
function getRootNode$1(n2) {
  return getUntaintedMethod$1("Node", n2, "getRootNode")();
}
function host$1(n2) {
  if (!n2 || !("host" in n2)) return null;
  return getUntaintedAccessor$1("ShadowRoot", n2, "host");
}
function styleSheets$1(n2) {
  return n2.styleSheets;
}
function shadowRoot$1(n2) {
  if (!n2 || !("shadowRoot" in n2)) return null;
  return getUntaintedAccessor$1("Element", n2, "shadowRoot");
}
function querySelector$1(n2, selectors) {
  return getUntaintedAccessor$1("Element", n2, "querySelector")(selectors);
}
function querySelectorAll$1(n2, selectors) {
  return getUntaintedAccessor$1("Element", n2, "querySelectorAll")(selectors);
}
function mutationObserverCtor$1() {
  return getUntaintedPrototype$1("MutationObserver").constructor;
}
const index$1 = {
  childNodes: childNodes$1,
  parentNode: parentNode$1,
  parentElement: parentElement$1,
  textContent: textContent$1,
  contains: contains$1,
  getRootNode: getRootNode$1,
  host: host$1,
  styleSheets: styleSheets$1,
  shadowRoot: shadowRoot$1,
  querySelector: querySelector$1,
  querySelectorAll: querySelectorAll$1,
  mutationObserver: mutationObserverCtor$1
};
function isElement(n2) {
  return n2.nodeType === n2.ELEMENT_NODE;
}
function isShadowRoot(n2) {
  const hostEl = (
    // anchor and textarea elements also have a `host` property
    // but only shadow roots have a `mode` property
    n2 && "host" in n2 && "mode" in n2 && index$1.host(n2) || null
  );
  return Boolean(
    hostEl && "shadowRoot" in hostEl && index$1.shadowRoot(hostEl) === n2
  );
}
function isNativeShadowDom(shadowRoot2) {
  return Object.prototype.toString.call(shadowRoot2) === "[object ShadowRoot]";
}
function fixBrowserCompatibilityIssuesInCSS(cssText) {
  if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {
    cssText = cssText.replace(
      /\sbackground-clip:\s*text;/g,
      " -webkit-background-clip: text; background-clip: text;"
    );
  }
  return cssText;
}
function escapeImportStatement(rule2) {
  const { cssText } = rule2;
  if (cssText.split('"').length < 3) return cssText;
  const statement = ["@import", `url(${JSON.stringify(rule2.href)})`];
  if (rule2.layerName === "") {
    statement.push(`layer`);
  } else if (rule2.layerName) {
    statement.push(`layer(${rule2.layerName})`);
  }
  if (rule2.supportsText) {
    statement.push(`supports(${rule2.supportsText})`);
  }
  if (rule2.media.length) {
    statement.push(rule2.media.mediaText);
  }
  return statement.join(" ") + ";";
}
function stringifyStylesheet(s2) {
  try {
    const rules2 = s2.rules || s2.cssRules;
    if (!rules2) {
      return null;
    }
    let sheetHref = s2.href;
    if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {
      sheetHref = s2.ownerNode.ownerDocument.location.href;
    }
    const stringifiedRules = Array.from(
      rules2,
      (rule2) => stringifyRule(rule2, sheetHref)
    ).join("");
    return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);
  } catch (error) {
    return null;
  }
}
function stringifyRule(rule2, sheetHref) {
  if (isCSSImportRule(rule2)) {
    let importStringified;
    try {
      importStringified = // for same-origin stylesheets,
      // we can access the imported stylesheet rules directly
      stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement
      escapeImportStatement(rule2);
    } catch (error) {
      importStringified = rule2.cssText;
    }
    if (rule2.styleSheet.href) {
      return absolutifyURLs(importStringified, rule2.styleSheet.href);
    }
    return importStringified;
  } else {
    let ruleStringified = rule2.cssText;
    if (isCSSStyleRule(rule2) && rule2.selectorText.includes(":")) {
      ruleStringified = fixSafariColons(ruleStringified);
    }
    if (sheetHref) {
      return absolutifyURLs(ruleStringified, sheetHref);
    }
    return ruleStringified;
  }
}
function fixSafariColons(cssStringified) {
  const regex = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return cssStringified.replace(regex, "$1\\$2");
}
function isCSSImportRule(rule2) {
  return "styleSheet" in rule2;
}
function isCSSStyleRule(rule2) {
  return "selectorText" in rule2;
}
class Mirror {
  constructor() {
    __publicField$1(this, "idNodeMap", /* @__PURE__ */ new Map());
    __publicField$1(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());
  }
  getId(n2) {
    var _a2;
    if (!n2) return -1;
    const id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;
    return id ?? -1;
  }
  getNode(id) {
    return this.idNodeMap.get(id) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(n2) {
    return this.nodeMetaMap.get(n2) || null;
  }
  // removes the node from idNodeMap
  // doesn't remove the node from nodeMetaMap
  removeNodeFromMap(n2) {
    const id = this.getId(n2);
    this.idNodeMap.delete(id);
    if (n2.childNodes) {
      n2.childNodes.forEach(
        (childNode) => this.removeNodeFromMap(childNode)
      );
    }
  }
  has(id) {
    return this.idNodeMap.has(id);
  }
  hasNode(node2) {
    return this.nodeMetaMap.has(node2);
  }
  add(n2, meta) {
    const id = meta.id;
    this.idNodeMap.set(id, n2);
    this.nodeMetaMap.set(n2, meta);
  }
  replace(id, n2) {
    const oldNode = this.getNode(id);
    if (oldNode) {
      const meta = this.nodeMetaMap.get(oldNode);
      if (meta) this.nodeMetaMap.set(n2, meta);
    }
    this.idNodeMap.set(id, n2);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map();
    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function createMirror$2() {
  return new Mirror();
}
function maskInputValue({
  element,
  maskInputOptions,
  tagName,
  type,
  value,
  maskInputFn
}) {
  let text = value || "";
  const actualType = type && toLowerCase(type);
  if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {
    if (maskInputFn) {
      text = maskInputFn(text, element);
    } else {
      text = "*".repeat(text.length);
    }
  }
  return text;
}
function toLowerCase(str) {
  return str.toLowerCase();
}
const ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";
function is2DCanvasBlank(canvas) {
  const ctx = canvas.getContext("2d");
  if (!ctx) return true;
  const chunkSize = 50;
  for (let x2 = 0; x2 < canvas.width; x2 += chunkSize) {
    for (let y = 0; y < canvas.height; y += chunkSize) {
      const getImageData = ctx.getImageData;
      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;
      const pixelBuffer = new Uint32Array(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        originalGetImageData.call(
          ctx,
          x2,
          y,
          Math.min(chunkSize, canvas.width - x2),
          Math.min(chunkSize, canvas.height - y)
        ).data.buffer
      );
      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;
    }
  }
  return true;
}
function getInputType(element) {
  const type = element.type;
  return element.hasAttribute("data-rr-is-password") ? "password" : type ? (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    toLowerCase(type)
  ) : null;
}
function extractFileExtension(path, baseURL) {
  let url;
  try {
    url = new URL(path, baseURL ?? window.location.href);
  } catch (err) {
    return null;
  }
  const regex = /\.([0-9a-z]+)(?:$)/i;
  const match = url.pathname.match(regex);
  return (match == null ? void 0 : match[1]) ?? null;
}
function extractOrigin(url) {
  let origin = "";
  if (url.indexOf("//") > -1) {
    origin = url.split("/").slice(0, 3).join("/");
  } else {
    origin = url.split("/")[0];
  }
  origin = origin.split("?")[0];
  return origin;
}
const URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
const URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i;
const URL_WWW_MATCH = /^www\..*/i;
const DATA_URI = /^(data:)([^,]*),(.*)/i;
function absolutifyURLs(cssText, href) {
  return (cssText || "").replace(
    URL_IN_CSS_REF,
    (origin, quote1, path1, quote2, path2, path3) => {
      const filePath = path1 || path2 || path3;
      const maybeQuote = quote1 || quote2 || "";
      if (!filePath) {
        return origin;
      }
      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (DATA_URI.test(filePath)) {
        return `url(${maybeQuote}${filePath}${maybeQuote})`;
      }
      if (filePath[0] === "/") {
        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;
      }
      const stack = href.split("/");
      const parts = filePath.split("/");
      stack.pop();
      for (const part of parts) {
        if (part === ".") {
          continue;
        } else if (part === "..") {
          stack.pop();
        } else {
          stack.push(part);
        }
      }
      return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;
    }
  );
}
function normalizeCssString(cssText) {
  return cssText.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "");
}
function splitCssText(cssText, style) {
  const childNodes2 = Array.from(style.childNodes);
  const splits = [];
  if (childNodes2.length > 1 && cssText && typeof cssText === "string") {
    const cssTextNorm = normalizeCssString(cssText);
    for (let i2 = 1; i2 < childNodes2.length; i2++) {
      if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === "string") {
        const textContentNorm = normalizeCssString(childNodes2[i2].textContent);
        for (let j = 3; j < textContentNorm.length; j++) {
          const bit = textContentNorm.substring(0, j);
          if (cssTextNorm.split(bit).length === 2) {
            const splitNorm = cssTextNorm.indexOf(bit);
            for (let k = splitNorm; k < cssText.length; k++) {
              if (normalizeCssString(cssText.substring(0, k)).length === splitNorm) {
                splits.push(cssText.substring(0, k));
                cssText = cssText.substring(k);
                break;
              }
            }
            break;
          }
        }
      }
    }
  }
  splits.push(cssText);
  return splits;
}
function markCssSplits(cssText, style) {
  return splitCssText(cssText, style).join("/* rr_split */");
}
let _id = 1;
const tagNameRegex = new RegExp("[^a-z0-9-_:]");
const IGNORED_NODE = -2;
function genId() {
  return _id++;
}
function getValidTagName$1(element) {
  if (element instanceof HTMLFormElement) {
    return "form";
  }
  const processedTagName = toLowerCase(element.tagName);
  if (tagNameRegex.test(processedTagName)) {
    return "div";
  }
  return processedTagName;
}
let canvasService;
let canvasCtx;
const SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
const SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
function getAbsoluteSrcsetString(doc, attributeValue) {
  if (attributeValue.trim() === "") {
    return attributeValue;
  }
  let pos = 0;
  function collectCharacters(regEx) {
    let chars2;
    const match = regEx.exec(attributeValue.substring(pos));
    if (match) {
      chars2 = match[0];
      pos += chars2.length;
      return chars2;
    }
    return "";
  }
  const output = [];
  while (true) {
    collectCharacters(SRCSET_COMMAS_OR_SPACES);
    if (pos >= attributeValue.length) {
      break;
    }
    let url = collectCharacters(SRCSET_NOT_SPACES);
    if (url.slice(-1) === ",") {
      url = absoluteToDoc(doc, url.substring(0, url.length - 1));
      output.push(url);
    } else {
      let descriptorsStr = "";
      url = absoluteToDoc(doc, url);
      let inParens = false;
      while (true) {
        const c2 = attributeValue.charAt(pos);
        if (c2 === "") {
          output.push((url + descriptorsStr).trim());
          break;
        } else if (!inParens) {
          if (c2 === ",") {
            pos += 1;
            output.push((url + descriptorsStr).trim());
            break;
          } else if (c2 === "(") {
            inParens = true;
          }
        } else {
          if (c2 === ")") {
            inParens = false;
          }
        }
        descriptorsStr += c2;
        pos += 1;
      }
    }
  }
  return output.join(", ");
}
const cachedDocument = /* @__PURE__ */ new WeakMap();
function absoluteToDoc(doc, attributeValue) {
  if (!attributeValue || attributeValue.trim() === "") {
    return attributeValue;
  }
  return getHref(doc, attributeValue);
}
function isSVGElement(el) {
  return Boolean(el.tagName === "svg" || el.ownerSVGElement);
}
function getHref(doc, customHref) {
  let a2 = cachedDocument.get(doc);
  if (!a2) {
    a2 = doc.createElement("a");
    cachedDocument.set(doc, a2);
  }
  if (!customHref) {
    customHref = "";
  } else if (customHref.startsWith("blob:") || customHref.startsWith("data:")) {
    return customHref;
  }
  a2.setAttribute("href", customHref);
  return a2.href;
}
function transformAttribute(doc, tagName, name, value) {
  if (!value) {
    return value;
  }
  if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {
    return absoluteToDoc(doc, value);
  } else if (name === "xlink:href" && value[0] !== "#") {
    return absoluteToDoc(doc, value);
  } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {
    return absoluteToDoc(doc, value);
  } else if (name === "srcset") {
    return getAbsoluteSrcsetString(doc, value);
  } else if (name === "style") {
    return absolutifyURLs(value, getHref(doc));
  } else if (tagName === "object" && name === "data") {
    return absoluteToDoc(doc, value);
  }
  return value;
}
function ignoreAttribute(tagName, name, _value) {
  return (tagName === "video" || tagName === "audio") && name === "autoplay";
}
function _isBlockedElement(element, blockClass, blockSelector) {
  try {
    if (typeof blockClass === "string") {
      if (element.classList.contains(blockClass)) {
        return true;
      }
    } else {
      for (let eIndex = element.classList.length; eIndex--; ) {
        const className = element.classList[eIndex];
        if (blockClass.test(className)) {
          return true;
        }
      }
    }
    if (blockSelector) {
      return element.matches(blockSelector);
    }
  } catch (e2) {
  }
  return false;
}
function classMatchesRegex(node2, regex, checkAncestors) {
  if (!node2) return false;
  if (node2.nodeType !== node2.ELEMENT_NODE) {
    if (!checkAncestors) return false;
    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);
  }
  for (let eIndex = node2.classList.length; eIndex--; ) {
    const className = node2.classList[eIndex];
    if (regex.test(className)) {
      return true;
    }
  }
  if (!checkAncestors) return false;
  return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);
}
function needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {
  let el;
  if (isElement(node2)) {
    el = node2;
    if (!index$1.childNodes(el).length) {
      return false;
    }
  } else if (index$1.parentElement(node2) === null) {
    return false;
  } else {
    el = index$1.parentElement(node2);
  }
  try {
    if (typeof maskTextClass === "string") {
      if (checkAncestors) {
        if (el.closest(`.${maskTextClass}`)) return true;
      } else {
        if (el.classList.contains(maskTextClass)) return true;
      }
    } else {
      if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;
    }
    if (maskTextSelector) {
      if (checkAncestors) {
        if (el.closest(maskTextSelector)) return true;
      } else {
        if (el.matches(maskTextSelector)) return true;
      }
    }
  } catch (e2) {
  }
  return false;
}
function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
  const win = iframeEl.contentWindow;
  if (!win) {
    return;
  }
  let fired = false;
  let readyState;
  try {
    readyState = win.document.readyState;
  } catch (error) {
    return;
  }
  if (readyState !== "complete") {
    const timer = setTimeout(() => {
      if (!fired) {
        listener();
        fired = true;
      }
    }, iframeLoadTimeout);
    iframeEl.addEventListener("load", () => {
      clearTimeout(timer);
      fired = true;
      listener();
    });
    return;
  }
  const blankUrl = "about:blank";
  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {
    setTimeout(listener, 0);
    return iframeEl.addEventListener("load", listener);
  }
  iframeEl.addEventListener("load", listener);
}
function onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {
  let fired = false;
  let styleSheetLoaded;
  try {
    styleSheetLoaded = link.sheet;
  } catch (error) {
    return;
  }
  if (styleSheetLoaded) return;
  const timer = setTimeout(() => {
    if (!fired) {
      listener();
      fired = true;
    }
  }, styleSheetLoadTimeout);
  link.addEventListener("load", () => {
    clearTimeout(timer);
    fired = true;
    listener();
  });
}
function serializeNode(n2, options) {
  const {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions = {},
    maskTextFn,
    maskInputFn,
    dataURLOptions = {},
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement = false,
    cssCaptured = false
  } = options;
  const rootId = getRootId(doc, mirror2);
  switch (n2.nodeType) {
    case n2.DOCUMENT_NODE:
      if (n2.compatMode !== "CSS1Compat") {
        return {
          type: NodeType$3.Document,
          childNodes: [],
          compatMode: n2.compatMode
          // probably "BackCompat"
        };
      } else {
        return {
          type: NodeType$3.Document,
          childNodes: []
        };
      }
    case n2.DOCUMENT_TYPE_NODE:
      return {
        type: NodeType$3.DocumentType,
        name: n2.name,
        publicId: n2.publicId,
        systemId: n2.systemId,
        rootId
      };
    case n2.ELEMENT_NODE:
      return serializeElementNode(n2, {
        doc,
        blockClass,
        blockSelector,
        inlineStylesheet,
        maskInputOptions,
        maskInputFn,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        keepIframeSrcFn,
        newlyAddedElement,
        rootId
      });
    case n2.TEXT_NODE:
      return serializeTextNode(n2, {
        doc,
        needsMask,
        maskTextFn,
        rootId,
        cssCaptured
      });
    case n2.CDATA_SECTION_NODE:
      return {
        type: NodeType$3.CDATA,
        textContent: "",
        rootId
      };
    case n2.COMMENT_NODE:
      return {
        type: NodeType$3.Comment,
        textContent: index$1.textContent(n2) || "",
        rootId
      };
    default:
      return false;
  }
}
function getRootId(doc, mirror2) {
  if (!mirror2.hasNode(doc)) return void 0;
  const docId = mirror2.getId(doc);
  return docId === 1 ? void 0 : docId;
}
function serializeTextNode(n2, options) {
  const { needsMask, maskTextFn, rootId, cssCaptured } = options;
  const parent = index$1.parentNode(n2);
  const parentTagName = parent && parent.tagName;
  let textContent2 = "";
  const isStyle = parentTagName === "STYLE" ? true : void 0;
  const isScript = parentTagName === "SCRIPT" ? true : void 0;
  if (isScript) {
    textContent2 = "SCRIPT_PLACEHOLDER";
  } else if (!cssCaptured) {
    textContent2 = index$1.textContent(n2);
    if (isStyle && textContent2) {
      textContent2 = absolutifyURLs(textContent2, getHref(options.doc));
    }
  }
  if (!isStyle && !isScript && textContent2 && needsMask) {
    textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\S]/g, "*");
  }
  return {
    type: NodeType$3.Text,
    textContent: textContent2 || "",
    rootId
  };
}
function serializeElementNode(n2, options) {
  const {
    doc,
    blockClass,
    blockSelector,
    inlineStylesheet,
    maskInputOptions = {},
    maskInputFn,
    dataURLOptions = {},
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement = false,
    rootId
  } = options;
  const needBlock = _isBlockedElement(n2, blockClass, blockSelector);
  const tagName = getValidTagName$1(n2);
  let attributes = {};
  const len = n2.attributes.length;
  for (let i2 = 0; i2 < len; i2++) {
    const attr = n2.attributes[i2];
    if (!ignoreAttribute(tagName, attr.name, attr.value)) {
      attributes[attr.name] = transformAttribute(
        doc,
        tagName,
        toLowerCase(attr.name),
        attr.value
      );
    }
  }
  if (tagName === "link" && inlineStylesheet) {
    const stylesheet = Array.from(doc.styleSheets).find((s2) => {
      return s2.href === n2.href;
    });
    let cssText = null;
    if (stylesheet) {
      cssText = stringifyStylesheet(stylesheet);
    }
    if (cssText) {
      delete attributes.rel;
      delete attributes.href;
      attributes._cssText = cssText;
    }
  }
  if (tagName === "style" && n2.sheet) {
    let cssText = stringifyStylesheet(
      n2.sheet
    );
    if (cssText) {
      if (n2.childNodes.length > 1) {
        cssText = markCssSplits(cssText, n2);
      }
      attributes._cssText = cssText;
    }
  }
  if (tagName === "input" || tagName === "textarea" || tagName === "select") {
    const value = n2.value;
    const checked = n2.checked;
    if (attributes.type !== "radio" && attributes.type !== "checkbox" && attributes.type !== "submit" && attributes.type !== "button" && value) {
      attributes.value = maskInputValue({
        element: n2,
        type: getInputType(n2),
        tagName,
        value,
        maskInputOptions,
        maskInputFn
      });
    } else if (checked) {
      attributes.checked = checked;
    }
  }
  if (tagName === "option") {
    if (n2.selected && !maskInputOptions["select"]) {
      attributes.selected = true;
    } else {
      delete attributes.selected;
    }
  }
  if (tagName === "dialog" && n2.open) {
    attributes.rr_open_mode = n2.matches("dialog:modal") ? "modal" : "non-modal";
  }
  if (tagName === "canvas" && recordCanvas) {
    if (n2.__context === "2d") {
      if (!is2DCanvasBlank(n2)) {
        attributes.rr_dataURL = n2.toDataURL(
          dataURLOptions.type,
          dataURLOptions.quality
        );
      }
    } else if (!("__context" in n2)) {
      const canvasDataURL = n2.toDataURL(
        dataURLOptions.type,
        dataURLOptions.quality
      );
      const blankCanvas = doc.createElement("canvas");
      blankCanvas.width = n2.width;
      blankCanvas.height = n2.height;
      const blankCanvasDataURL = blankCanvas.toDataURL(
        dataURLOptions.type,
        dataURLOptions.quality
      );
      if (canvasDataURL !== blankCanvasDataURL) {
        attributes.rr_dataURL = canvasDataURL;
      }
    }
  }
  if (tagName === "img" && inlineImages) {
    if (!canvasService) {
      canvasService = doc.createElement("canvas");
      canvasCtx = canvasService.getContext("2d");
    }
    const image = n2;
    const imageSrc = image.currentSrc || image.getAttribute("src") || "<unknown-src>";
    const priorCrossOrigin = image.crossOrigin;
    const recordInlineImage = () => {
      image.removeEventListener("load", recordInlineImage);
      try {
        canvasService.width = image.naturalWidth;
        canvasService.height = image.naturalHeight;
        canvasCtx.drawImage(image, 0, 0);
        attributes.rr_dataURL = canvasService.toDataURL(
          dataURLOptions.type,
          dataURLOptions.quality
        );
      } catch (err) {
        if (image.crossOrigin !== "anonymous") {
          image.crossOrigin = "anonymous";
          if (image.complete && image.naturalWidth !== 0)
            recordInlineImage();
          else image.addEventListener("load", recordInlineImage);
          return;
        } else {
          console.warn(
            `Cannot inline img src=${imageSrc}! Error: ${err}`
          );
        }
      }
      if (image.crossOrigin === "anonymous") {
        priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute("crossorigin");
      }
    };
    if (image.complete && image.naturalWidth !== 0) recordInlineImage();
    else image.addEventListener("load", recordInlineImage);
  }
  if (tagName === "audio" || tagName === "video") {
    const mediaAttributes = attributes;
    mediaAttributes.rr_mediaState = n2.paused ? "paused" : "played";
    mediaAttributes.rr_mediaCurrentTime = n2.currentTime;
    mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;
    mediaAttributes.rr_mediaMuted = n2.muted;
    mediaAttributes.rr_mediaLoop = n2.loop;
    mediaAttributes.rr_mediaVolume = n2.volume;
  }
  if (!newlyAddedElement) {
    if (n2.scrollLeft) {
      attributes.rr_scrollLeft = n2.scrollLeft;
    }
    if (n2.scrollTop) {
      attributes.rr_scrollTop = n2.scrollTop;
    }
  }
  if (needBlock) {
    const { width, height } = n2.getBoundingClientRect();
    attributes = {
      class: attributes.class,
      rr_width: `${width}px`,
      rr_height: `${height}px`
    };
  }
  if (tagName === "iframe" && !keepIframeSrcFn(attributes.src)) {
    if (!n2.contentDocument) {
      attributes.rr_src = attributes.src;
    }
    delete attributes.src;
  }
  let isCustomElement;
  try {
    if (customElements.get(tagName)) isCustomElement = true;
  } catch (e2) {
  }
  return {
    type: NodeType$3.Element,
    tagName,
    attributes,
    childNodes: [],
    isSVG: isSVGElement(n2) || void 0,
    needBlock,
    rootId,
    isCustom: isCustomElement
  };
}
function lowerIfExists(maybeAttr) {
  if (maybeAttr === void 0 || maybeAttr === null) {
    return "";
  } else {
    return maybeAttr.toLowerCase();
  }
}
function slimDOMExcluded(sn, slimDOMOptions) {
  if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {
    return true;
  } else if (sn.type === NodeType$3.Element) {
    if (slimDOMOptions.script && // script tag
    (sn.tagName === "script" || // (module)preload link
    sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") && sn.attributes.as === "script" || // prefetch link
    sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && extractFileExtension(sn.attributes.href) === "js")) {
      return true;
    } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(
      /^msapplication-tile(image|color)$/
    ) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {
      return true;
    } else if (sn.tagName === "meta") {
      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
        return true;
      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)
      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {
        return true;
      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {
        return true;
      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {
        return true;
      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {
        return true;
      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {
        return true;
      }
    }
  }
  return false;
}
function serializeNodeWithId(n2, options) {
  const {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild = false,
    inlineStylesheet = true,
    maskInputOptions = {},
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions = {},
    inlineImages = false,
    recordCanvas = false,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout = 5e3,
    onStylesheetLoad,
    stylesheetLoadTimeout = 5e3,
    keepIframeSrcFn = () => false,
    newlyAddedElement = false,
    cssCaptured = false
  } = options;
  let { needsMask } = options;
  let { preserveWhiteSpace = true } = options;
  if (!needsMask) {
    const checkAncestors = needsMask === void 0;
    needsMask = needMaskingText(
      n2,
      maskTextClass,
      maskTextSelector,
      checkAncestors
    );
  }
  const _serializedNode = serializeNode(n2, {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement,
    cssCaptured
  });
  if (!_serializedNode) {
    console.warn(n2, "not serialized");
    return null;
  }
  let id;
  if (mirror2.hasNode(n2)) {
    id = mirror2.getId(n2);
  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\s+|\s+$/gm, "").length) {
    id = IGNORED_NODE;
  } else {
    id = genId();
  }
  const serializedNode = Object.assign(_serializedNode, { id });
  mirror2.add(n2, serializedNode);
  if (id === IGNORED_NODE) {
    return null;
  }
  if (onSerialize) {
    onSerialize(n2);
  }
  let recordChild = !skipChild;
  if (serializedNode.type === NodeType$3.Element) {
    recordChild = recordChild && !serializedNode.needBlock;
    delete serializedNode.needBlock;
    const shadowRootEl = index$1.shadowRoot(n2);
    if (shadowRootEl && isNativeShadowDom(shadowRootEl))
      serializedNode.isShadowHost = true;
  }
  if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {
    if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === "head") {
      preserveWhiteSpace = false;
    }
    const bypassOptions = {
      doc,
      mirror: mirror2,
      blockClass,
      blockSelector,
      needsMask,
      maskTextClass,
      maskTextSelector,
      skipChild,
      inlineStylesheet,
      maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOMOptions,
      dataURLOptions,
      inlineImages,
      recordCanvas,
      preserveWhiteSpace,
      onSerialize,
      onIframeLoad,
      iframeLoadTimeout,
      onStylesheetLoad,
      stylesheetLoadTimeout,
      keepIframeSrcFn,
      cssCaptured: false
    };
    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "textarea" && serializedNode.attributes.value !== void 0) ;
    else {
      if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === "string") {
        bypassOptions.cssCaptured = true;
      }
      for (const childN of Array.from(index$1.childNodes(n2))) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
    let shadowRootEl = null;
    if (isElement(n2) && (shadowRootEl = index$1.shadowRoot(n2))) {
      for (const childN of Array.from(index$1.childNodes(shadowRootEl))) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          isNativeShadowDom(shadowRootEl) && (serializedChildNode.isShadow = true);
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
  }
  const parent = index$1.parentNode(n2);
  if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {
    serializedNode.isShadow = true;
  }
  if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "iframe") {
    onceIframeLoaded(
      n2,
      () => {
        const iframeDoc = n2.contentDocument;
        if (iframeDoc && onIframeLoad) {
          const serializedIframeNode = serializeNodeWithId(iframeDoc, {
            doc: iframeDoc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            needsMask,
            maskTextClass,
            maskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedIframeNode) {
            onIframeLoad(
              n2,
              serializedIframeNode
            );
          }
        }
      },
      iframeLoadTimeout
    );
  }
  if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === "link" && typeof serializedNode.attributes.rel === "string" && (serializedNode.attributes.rel === "stylesheet" || serializedNode.attributes.rel === "preload" && typeof serializedNode.attributes.href === "string" && extractFileExtension(serializedNode.attributes.href) === "css")) {
    onceStylesheetLoaded(
      n2,
      () => {
        if (onStylesheetLoad) {
          const serializedLinkNode = serializeNodeWithId(n2, {
            doc,
            mirror: mirror2,
            blockClass,
            blockSelector,
            needsMask,
            maskTextClass,
            maskTextSelector,
            skipChild: false,
            inlineStylesheet,
            maskInputOptions,
            maskTextFn,
            maskInputFn,
            slimDOMOptions,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            preserveWhiteSpace,
            onSerialize,
            onIframeLoad,
            iframeLoadTimeout,
            onStylesheetLoad,
            stylesheetLoadTimeout,
            keepIframeSrcFn
          });
          if (serializedLinkNode) {
            onStylesheetLoad(
              n2,
              serializedLinkNode
            );
          }
        }
      },
      stylesheetLoadTimeout
    );
  }
  return serializedNode;
}
function snapshot(n2, options) {
  const {
    mirror: mirror2 = new Mirror(),
    blockClass = "rr-block",
    blockSelector = null,
    maskTextClass = "rr-mask",
    maskTextSelector = null,
    inlineStylesheet = true,
    inlineImages = false,
    recordCanvas = false,
    maskAllInputs = false,
    maskTextFn,
    maskInputFn,
    slimDOM = false,
    dataURLOptions,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn = () => false
  } = options || {};
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : maskAllInputs === false ? {
    password: true
  } : maskAllInputs;
  const slimDOMOptions = slimDOM === true || slimDOM === "all" ? (
    // if true: set of sensible options that should not throw away any information
    {
      script: true,
      comment: true,
      headFavicon: true,
      headWhitespace: true,
      headMetaDescKeywords: slimDOM === "all",
      // destructive
      headMetaSocial: true,
      headMetaRobots: true,
      headMetaHttpEquiv: true,
      headMetaAuthorship: true,
      headMetaVerification: true
    }
  ) : slimDOM === false ? {} : slimDOM;
  return serializeNodeWithId(n2, {
    doc: n2,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild: false,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn,
    newlyAddedElement: false
  });
}
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace$1(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var picocolors_browser$1 = { exports: {} };
var x$1 = String;
var create$1 = function() {
  return { isColorSupported: false, reset: x$1, bold: x$1, dim: x$1, italic: x$1, underline: x$1, inverse: x$1, hidden: x$1, strikethrough: x$1, black: x$1, red: x$1, green: x$1, yellow: x$1, blue: x$1, magenta: x$1, cyan: x$1, white: x$1, gray: x$1, bgBlack: x$1, bgRed: x$1, bgGreen: x$1, bgYellow: x$1, bgBlue: x$1, bgMagenta: x$1, bgCyan: x$1, bgWhite: x$1 };
};
picocolors_browser$1.exports = create$1();
picocolors_browser$1.exports.createColors = create$1;
var picocolors_browserExports$1 = picocolors_browser$1.exports;
const __viteBrowserExternal$2 = {};
const __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal$2
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);
let pico$1 = picocolors_browserExports$1;
let terminalHighlight$1$1 = require$$2$1;
let CssSyntaxError$3$1 = class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin22) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin22) {
      this.plugin = plugin22;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css = this.source;
    if (color == null) color = pico$1.isColorSupported;
    if (terminalHighlight$1$1) {
      if (color) css = terminalHighlight$1$1(css);
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold, gray, red } = pico$1.createColors(true);
      mark = (text) => bold(red(text));
      aside = (text) => gray(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index2) => {
      let number = start + 1 + index2;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join("\n");
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = "\n\n" + code + "\n";
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError$1 = CssSyntaxError$3$1;
CssSyntaxError$3$1.default = CssSyntaxError$3$1;
var symbols$1 = {};
symbols$1.isClean = Symbol("isClean");
symbols$1.my = Symbol("my");
const DEFAULT_RAW$1 = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize$1(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2$1 = class Stringifier {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node2, semicolon) {
    let name = "@" + node2.name;
    let params = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name += node2.raws.afterName;
    } else if (params) {
      name += " ";
    }
    if (node2.nodes) {
      this.block(node2, name + params);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name + params + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last = node2.nodes.length - 1;
    while (last > 0) {
      if (node2.nodes[last].type !== "comment") break;
      last -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW$1[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize$1(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW$1[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier$1 = Stringifier$2$1;
Stringifier$2$1.default = Stringifier$2$1;
let Stringifier$1$1 = stringifier$1;
function stringify$4$1(node2, builder) {
  let str = new Stringifier$1$1(builder);
  str.stringify(node2);
}
var stringify_1$1 = stringify$4$1;
stringify$4$1.default = stringify$4$1;
let { isClean: isClean$2$1, my: my$2$1 } = symbols$1;
let CssSyntaxError$2$1 = cssSyntaxError$1;
let Stringifier2$1 = stringifier$1;
let stringify$3$1 = stringify_1$1;
function cloneNode$1(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode$1(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode$1(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
let Node$4$1 = class Node2 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2$1] = false;
    this[my$2$1] = true;
    for (let name in defaults) {
      if (name === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s2 = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode$1(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2$1(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2$1]) {
      this[isClean$2$1] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2$1] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
    }
    return pos;
  }
  positionInside(index2, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i2 = 0; i2 < index2; i2++) {
      if (string[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) {
        start = this.positionInside(index2, stringRepresentation);
        end = this.positionInside(index2 + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier2$1();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        continue;
      }
      if (name === "parent" || name === "proxyCache") continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3$1) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node$1 = Node$4$1;
Node$4$1.default = Node$4$1;
let Node$3$1 = node$1;
let Declaration$4$1 = class Declaration extends Node$3$1 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration$1 = Declaration$4$1;
Declaration$4$1.default = Declaration$4$1;
let urlAlphabet$1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet$1 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1$1 = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet$1[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure$1 = { nanoid: nanoid$1$1, customAlphabet: customAlphabet$1 };
let { SourceMapConsumer: SourceMapConsumer$2$1, SourceMapGenerator: SourceMapGenerator$2$1 } = require$$2$1;
let { existsSync: existsSync$1, readFileSync: readFileSync$1 } = require$$2$1;
let { dirname: dirname$1$1, join: join$1 } = require$$2$1;
function fromBase64$1(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2$1 = class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1$1(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2$1(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64$1(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map) {
    if (typeof map !== "object") return false;
    return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments) return;
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname$1$1(path);
    if (existsSync$1(path)) {
      this.mapFile = path;
      return readFileSync$1(path, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer$2$1) {
        return SourceMapGenerator$2$1.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2$1) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join$1(dirname$1$1(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap$1 = PreviousMap$2$1;
PreviousMap$2$1.default = PreviousMap$2$1;
let { SourceMapConsumer: SourceMapConsumer$1$1, SourceMapGenerator: SourceMapGenerator$1$1 } = require$$2$1;
let { fileURLToPath: fileURLToPath$1, pathToFileURL: pathToFileURL$1$1 } = require$$2$1;
let { isAbsolute: isAbsolute$1, resolve: resolve$1$1 } = require$$2$1;
let { nanoid: nanoid$2 } = nonSecure$1;
let terminalHighlight$2 = require$$2$1;
let CssSyntaxError$1$1 = cssSyntaxError$1;
let PreviousMap$1$1 = previousMap$1;
let fromOffsetCache$1 = Symbol("fromOffsetCache");
let sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);
let pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);
let Input$4$1 = class Input {
  constructor(css, opts = {}) {
    if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1$1 || /^\w+:\/\//.test(opts.from) || isAbsolute$1(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1$1(opts.from);
      }
    }
    if (pathAvailable$1$1 && sourceMapAvailable$1$1) {
      let map = new PreviousMap$1$1(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid$2(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result2, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1$1) {
        result2.input.url = pathToFileURL$1$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache$1]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache$1] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache$1];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({ column, line });
    if (!from.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute$1(from.source)) {
      fromUrl = pathToFileURL$1$1(from.source);
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath$1) {
        result2.file = fileURLToPath$1(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name of ["hasBOM", "css", "file", "id"]) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input$1 = Input$4$1;
Input$4$1.default = Input$4$1;
if (terminalHighlight$2 && terminalHighlight$2.registerInput) {
  terminalHighlight$2.registerInput(Input$4$1);
}
let { SourceMapConsumer: SourceMapConsumer$3, SourceMapGenerator: SourceMapGenerator$3 } = require$$2$1;
let { dirname: dirname$2, relative: relative$1, resolve: resolve$2, sep: sep$1 } = require$$2$1;
let { pathToFileURL: pathToFileURL$2 } = require$$2$1;
let Input$3$1 = input$1;
let sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);
let pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);
let MapGenerator$2$1 = class MapGenerator {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname$2(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer$3(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator$3.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator$3({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator$3({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf("\n");
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname$2(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from = dirname$2(resolve$2(from, this.mapOpts.annotation));
    }
    let path = relative$1(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map = node2.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input2 = new Input$3$1(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from = node2.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL$2) {
      let fileURL = pathToFileURL$2(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep$1 === "\\") {
      path = path.replace(/\\/g, "/");
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
};
var mapGenerator$1 = MapGenerator$2$1;
let Node$2$1 = node$1;
let Comment$4$1 = class Comment extends Node$2$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment$1 = Comment$4$1;
Comment$4$1.default = Comment$4$1;
let { isClean: isClean$1$1, my: my$1$1 } = symbols$1;
let Declaration$3$1 = declaration$1;
let Comment$3$1 = comment$1;
let Node$1$1 = node$1;
let parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;
function cleanSource$1(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markDirtyUp$1(node2) {
  node2[isClean$1$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markDirtyUp$1(i2);
    }
  }
}
let Container$7$1 = class Container extends Node$1$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index2, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index2 = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index2], index2);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index2) => i2(child.toProxy(), index2);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex < index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex <= index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource$1(parse$4$1(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3$1(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4$1(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4$1(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3$1(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1$1]) Container.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1$1]) markDirtyUp$1(i2);
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (index2 >= child) {
        this.indexes[id] = index2 - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7$1.registerParse = (dependant) => {
  parse$4$1 = dependant;
};
Container$7$1.registerRule = (dependant) => {
  Rule$4$1 = dependant;
};
Container$7$1.registerAtRule = (dependant) => {
  AtRule$4$1 = dependant;
};
Container$7$1.registerRoot = (dependant) => {
  Root$6$1 = dependant;
};
var container$1 = Container$7$1;
Container$7$1.default = Container$7$1;
Container$7$1.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4$1.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4$1.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3$1.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3$1.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6$1.prototype);
  }
  node2[my$1$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7$1.rebuild(child);
    });
  }
};
let Container$6$1 = container$1;
let LazyResult$4$1, Processor$3$1;
let Document$3$1 = class Document2 extends Container$6$1 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);
    return lazy.stringify();
  }
};
Document$3$1.registerLazyResult = (dependant) => {
  LazyResult$4$1 = dependant;
};
Document$3$1.registerProcessor = (dependant) => {
  Processor$3$1 = dependant;
};
var document$1$1 = Document$3$1;
Document$3$1.default = Document$3$1;
let printed$1 = {};
var warnOnce$2$1 = function warnOnce(message) {
  if (printed$1[message]) return;
  printed$1[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Warning$2$1 = class Warning {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning$1 = Warning$2$1;
Warning$2$1.default = Warning$2$1;
let Warning$1$1 = warning$1;
let Result$3$1 = class Result {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result$1 = Result$3$1;
Result$3$1.default = Result$3$1;
const SINGLE_QUOTE$1 = "'".charCodeAt(0);
const DOUBLE_QUOTE$1 = '"'.charCodeAt(0);
const BACKSLASH$1 = "\\".charCodeAt(0);
const SLASH$1 = "/".charCodeAt(0);
const NEWLINE$1 = "\n".charCodeAt(0);
const SPACE$1 = " ".charCodeAt(0);
const FEED$1 = "\f".charCodeAt(0);
const TAB$1 = "	".charCodeAt(0);
const CR$1 = "\r".charCodeAt(0);
const OPEN_SQUARE$1 = "[".charCodeAt(0);
const CLOSE_SQUARE$1 = "]".charCodeAt(0);
const OPEN_PARENTHESES$1 = "(".charCodeAt(0);
const CLOSE_PARENTHESES$1 = ")".charCodeAt(0);
const OPEN_CURLY$1 = "{".charCodeAt(0);
const CLOSE_CURLY$1 = "}".charCodeAt(0);
const SEMICOLON$1 = ";".charCodeAt(0);
const ASTERISK$1 = "*".charCodeAt(0);
const COLON$1 = ":".charCodeAt(0);
const AT$1 = "@".charCodeAt(0);
const RE_AT_END$1 = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END$1 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET$1 = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE$1 = /[\da-f]/i;
var tokenize$1 = function tokenizer(input2, options = {}) {
  let css = input2.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, next, quote, content, escape;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE$1:
      case SPACE$1:
      case TAB$1:
      case CR$1:
      case FEED$1: {
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);
        currentToken = ["space", css.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE$1:
      case CLOSE_SQUARE$1:
      case OPEN_CURLY$1:
      case CLOSE_CURLY$1:
      case COLON$1:
      case SEMICOLON$1:
      case CLOSE_PARENTHESES$1: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES$1: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH$1) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css.indexOf(")", pos + 1);
          content = css.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET$1.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE$1:
      case DOUBLE_QUOTE$1: {
        quote = code === SINGLE_QUOTE$1 ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === BACKSLASH$1) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT$1: {
        RE_AT_END$1.lastIndex = pos + 1;
        RE_AT_END$1.test(css);
        if (RE_AT_END$1.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END$1.lastIndex - 2;
        }
        currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH$1: {
        next = pos;
        escape = true;
        while (css.charCodeAt(next + 1) === BACKSLASH$1) {
          next += 1;
          escape = !escape;
        }
        code = css.charCodeAt(next + 1);
        if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {
          next += 1;
          if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE$1.test(css.charAt(next + 1))) {
              next += 1;
            }
            if (css.charCodeAt(next + 1) === SPACE$1) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {
          next = css.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END$1.lastIndex = pos + 1;
          RE_WORD_END$1.test(css);
          if (RE_WORD_END$1.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END$1.lastIndex - 2;
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let Container$5$1 = container$1;
let AtRule$3$1 = class AtRule extends Container$5$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule$1 = AtRule$3$1;
AtRule$3$1.default = AtRule$3$1;
Container$5$1.registerAtRule(AtRule$3$1);
let Container$4$1 = container$1;
let LazyResult$3$1, Processor$2$1;
let Root$5$1 = class Root extends Container$4$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index2 = this.index(child);
    if (!ignore && index2 === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index2].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);
    return lazy.stringify();
  }
};
Root$5$1.registerLazyResult = (dependant) => {
  LazyResult$3$1 = dependant;
};
Root$5$1.registerProcessor = (dependant) => {
  Processor$2$1 = dependant;
};
var root$1 = Root$5$1;
Root$5$1.default = Root$5$1;
Container$4$1.registerRoot(Root$5$1);
let list$2$1 = {
  comma(string) {
    return list$2$1.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2$1.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === "\\") {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1$1 = list$2$1;
list$2$1.default = list$2$1;
let Container$3$1 = container$1;
let list$1$1 = list_1$1;
let Rule$3$1 = class Rule extends Container$3$1 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule$1 = Rule$3$1;
Rule$3$1.default = Rule$3$1;
Container$3$1.registerRule(Rule$3$1);
let Declaration$2$1 = declaration$1;
let tokenizer2$1 = tokenize$1;
let Comment$2$1 = comment$1;
let AtRule$2$1 = atRule$1;
let Root$4$1 = root$1;
let Rule$2$1 = rule$1;
const SAFE_COMMENT_NEIGHBOR$1 = {
  empty: true,
  space: true
};
function findLastWithPosition$1(tokens) {
  for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
    let token = tokens[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1$1 = class Parser {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4$1();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$2$1();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node2, "params", params);
      if (last) {
        token = params[params.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens) {
    let brackets = 0;
    let token, type, prev;
    for (let [i2, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$2$1();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node2.text = "";
      node2.raws.left = text;
      node2.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer2$1(this.input);
  }
  decl(tokens, customProperty) {
    let node2 = new Declaration$2$1();
    this.init(node2, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node2.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition$1(tokens)
    );
    node2.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1) this.unknownWord(tokens);
      node2.raws.before += tokens.shift()[1];
    }
    node2.source.start = this.getPosition(tokens[0][2]);
    node2.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens, i2);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node2.important = true;
          node2.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$2$1();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length; i2 += 1) {
      token = tokens[i2];
      type = token[0];
      if (type === "space" && i2 === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
        next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node2 = new Rule$2$1();
    this.init(node2, tokens[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node2, "selector", tokens);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result2 = "";
    for (let i2 = from; i2 < tokens.length; i2++) {
      result2 += tokens[i2][1];
    }
    tokens.splice(from, tokens.length - from);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser$1 = Parser$1$1;
let Container$2$1 = container$1;
let Parser2$1 = parser$1;
let Input$2$1 = input$1;
function parse$3$1(css, opts) {
  let input2 = new Input$2$1(css, opts);
  let parser2 = new Parser2$1(input2);
  try {
    parser2.parse();
  } catch (e2) {
    if (true) {
      if (e2.name === "CssSyntaxError" && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
        } else if (/\.sass/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
        } else if (/\.less$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
        }
      }
    }
    throw e2;
  }
  return parser2.root;
}
var parse_1$1 = parse$3$1;
parse$3$1.default = parse$3$1;
Container$2$1.registerParse(parse$3$1);
let { isClean: isClean$3, my: my$3 } = symbols$1;
let MapGenerator$1$1 = mapGenerator$1;
let stringify$2$1 = stringify_1$1;
let Container$1$1 = container$1;
let Document$2$1 = document$1$1;
let warnOnce$1$1 = warnOnce$2$1;
let Result$2$1 = result$1;
let parse$2$1 = parse_1$1;
let Root$3$1 = root$1;
const TYPE_TO_CLASS_NAME$1 = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS$1 = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS$1 = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN$1 = 0;
function isPromise$1(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents$1(node2) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME$1[node2.type];
  if (node2.type === "decl") {
    key = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key = node2.name.toLowerCase();
  }
  if (key && node2.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN$1,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node2.append) {
    return [type, CHILDREN$1, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack$1(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN$1, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN$1, "RootExit"];
  } else {
    events = getEvents$1(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks$1(node2) {
  node2[isClean$3] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks$1(i2));
  return node2;
}
let postcss$2$1 = {};
let LazyResult$2$1 = class LazyResult {
  constructor(processor2, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
      root2 = cleanMarks$1(css);
    } else if (css instanceof LazyResult || css instanceof Result$2$1) {
      root2 = cleanMarks$1(css.root);
      if (css.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser2 = parse$2$1;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my$3]) {
        Container$1$1.rebuild(root2);
      }
    }
    this.result = new Result$2$1(processor2, root2, opts);
    this.helpers = { ...postcss$2$1, postcss: postcss$2$1, result: this.result };
    this.plugins = this.processor.plugins.map((plugin22) => {
      if (typeof plugin22 === "object" && plugin22.prepare) {
        return { ...plugin22, ...plugin22.prepare(this.result) };
      } else {
        return plugin22;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin22 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin22.postcssPlugin;
        error.setMessage();
      } else if (plugin22.postcssVersion) {
        if (true) {
          let pluginName = plugin22.postcssPlugin;
          let pluginVer = plugin22.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a2 = pluginVer.split(".");
          let b = runtimeVer.split(".");
          if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {
            console.error(
              "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
            );
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin22, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin22, cb]);
    };
    for (let plugin22 of this.plugins) {
      if (typeof plugin22 === "object") {
        for (let event in plugin22) {
          if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin22.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS$1[event]) {
            if (typeof plugin22[event] === "object") {
              for (let filter in plugin22[event]) {
                if (filter === "*") {
                  add(plugin22, event, plugin22[event][filter]);
                } else {
                  add(
                    plugin22,
                    event + "-" + filter.toLowerCase(),
                    plugin22[event][filter]
                  );
                }
              }
            } else if (typeof plugin22[event] === "function") {
              add(plugin22, event, plugin22[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin22 = this.plugins[i2];
      let promise = this.runOnRoot(plugin22);
      if (isPromise$1(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean$3]) {
        root2[isClean$3] = true;
        let stack = [toStack$1(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise$1(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e2, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin22, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin22;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin22) {
    this.result.lastPlugin = plugin22;
    try {
      if (typeof plugin22 === "object" && plugin22.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin22.Once(root2, this.helpers)
          );
          if (isPromise$1(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin22.Once(this.result.root, this.helpers);
      } else if (typeof plugin22 === "function") {
        return plugin22(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2$1;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator$1$1(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin22 of this.plugins) {
      let promise = this.runOnRoot(plugin22);
      if (isPromise$1(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean$3]) {
        root2[isClean$3] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this.opts)) {
        warnOnce$1$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin22, visitor] of visitors) {
      this.result.lastPlugin = plugin22;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise$1(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit2 = stack[stack.length - 1];
    let { node: node2, visitors } = visit2;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
      let [plugin22, visitor] = visitors[visit2.visitorIndex];
      visit2.visitorIndex += 1;
      if (visit2.visitorIndex === visitors.length) {
        visit2.visitors = [];
        visit2.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin22;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2);
      }
    }
    if (visit2.iterator !== 0) {
      let iterator = visit2.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean$3]) {
          child[isClean$3] = true;
          stack.push(toStack$1(child));
          return;
        }
      }
      visit2.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit2.events;
    while (visit2.eventIndex < events.length) {
      let event = events[visit2.eventIndex];
      visit2.eventIndex += 1;
      if (event === CHILDREN$1) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean$3] = true;
          visit2.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit2.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean$3] = true;
    let events = getEvents$1(node2);
    for (let event of events) {
      if (event === CHILDREN$1) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean$3]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2$1.registerPostcss = (dependant) => {
  postcss$2$1 = dependant;
};
var lazyResult$1 = LazyResult$2$1;
LazyResult$2$1.default = LazyResult$2$1;
Root$3$1.registerLazyResult(LazyResult$2$1);
Document$2$1.registerLazyResult(LazyResult$2$1);
let MapGenerator2$1 = mapGenerator$1;
let stringify$1$1 = stringify_1$1;
let warnOnce2$1 = warnOnce$2$1;
let parse$1$1 = parse_1$1;
const Result$1$1 = result$1;
let NoWorkResult$1$1 = class NoWorkResult {
  constructor(processor2, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1$1;
    this.result = new Result$1$1(this._processor, root2, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator2$1(str, root2, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this._opts)) {
        warnOnce2$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult$1 = NoWorkResult$1$1;
NoWorkResult$1$1.default = NoWorkResult$1$1;
let NoWorkResult2$1 = noWorkResult$1;
let LazyResult$1$1 = lazyResult$1;
let Document$1$1 = document$1$1;
let Root$2$1 = root$1;
let Processor$1$1 = class Processor {
  constructor(plugins = []) {
    this.version = "8.4.38";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (true) {
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
        }
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult2$1(this, css, opts);
    } else {
      return new LazyResult$1$1(this, css, opts);
    }
  }
  use(plugin22) {
    this.plugins = this.plugins.concat(this.normalize([plugin22]));
    return this;
  }
};
var processor$1 = Processor$1$1;
Processor$1$1.default = Processor$1$1;
Root$2$1.registerProcessor(Processor$1$1);
Document$1$1.registerProcessor(Processor$1$1);
let Declaration$1$1 = declaration$1;
let PreviousMap2$1 = previousMap$1;
let Comment$1$1 = comment$1;
let AtRule$1$1 = atRule$1;
let Input$1$1 = input$1;
let Root$1$1 = root$1;
let Rule$1$1 = rule$1;
function fromJSON$1$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n2) => fromJSON$1$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap2$1.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$1$1(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1$1 = fromJSON$1$1;
fromJSON$1$1.default = fromJSON$1$1;
let CssSyntaxError2$1 = cssSyntaxError$1;
let Declaration2$1 = declaration$1;
let LazyResult2$1 = lazyResult$1;
let Container2$1 = container$1;
let Processor2$1 = processor$1;
let stringify$5 = stringify_1$1;
let fromJSON$2 = fromJSON_1$1;
let Document22 = document$1$1;
let Warning2$1 = warning$1;
let Comment2$1 = comment$1;
let AtRule2$1 = atRule$1;
let Result2$1 = result$1;
let Input2$1 = input$1;
let parse$5 = parse_1$1;
let list$3 = list_1$1;
let Rule2$1 = rule$1;
let Root2$1 = root$1;
let Node2$1 = node$1;
function postcss$3(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor2$1(plugins);
}
postcss$3.plugin = function plugin(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name + ":  postcss.plugin . :\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor2$1().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function(css, processOpts, pluginOpts) {
    return postcss$3([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss$3.stringify = stringify$5;
postcss$3.parse = parse$5;
postcss$3.fromJSON = fromJSON$2;
postcss$3.list = list$3;
postcss$3.comment = (defaults) => new Comment2$1(defaults);
postcss$3.atRule = (defaults) => new AtRule2$1(defaults);
postcss$3.decl = (defaults) => new Declaration2$1(defaults);
postcss$3.rule = (defaults) => new Rule2$1(defaults);
postcss$3.root = (defaults) => new Root2$1(defaults);
postcss$3.document = (defaults) => new Document22(defaults);
postcss$3.CssSyntaxError = CssSyntaxError2$1;
postcss$3.Declaration = Declaration2$1;
postcss$3.Container = Container2$1;
postcss$3.Processor = Processor2$1;
postcss$3.Document = Document22;
postcss$3.Comment = Comment2$1;
postcss$3.Warning = Warning2$1;
postcss$3.AtRule = AtRule2$1;
postcss$3.Result = Result2$1;
postcss$3.Input = Input2$1;
postcss$3.Rule = Rule2$1;
postcss$3.Root = Root2$1;
postcss$3.Node = Node2$1;
LazyResult2$1.registerPostcss(postcss$3);
var postcss_1$1 = postcss$3;
postcss$3.default = postcss$3;
const postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);
postcss$1$1.stringify;
postcss$1$1.fromJSON;
postcss$1$1.plugin;
postcss$1$1.parse;
postcss$1$1.list;
postcss$1$1.document;
postcss$1$1.comment;
postcss$1$1.atRule;
postcss$1$1.rule;
postcss$1$1.decl;
postcss$1$1.root;
postcss$1$1.CssSyntaxError;
postcss$1$1.Declaration;
postcss$1$1.Container;
postcss$1$1.Processor;
postcss$1$1.Document;
postcss$1$1.Comment;
postcss$1$1.Warning;
postcss$1$1.AtRule;
postcss$1$1.Result;
postcss$1$1.Input;
postcss$1$1.Rule;
postcss$1$1.Root;
postcss$1$1.Node;
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var picocolors_browser = { exports: {} };
var x = String;
var create = function() {
  return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
};
picocolors_browser.exports = create();
picocolors_browser.exports.createColors = create;
var picocolors_browserExports = picocolors_browser.exports;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
let pico = picocolors_browserExports;
let terminalHighlight$1 = require$$2;
let CssSyntaxError$3 = class CssSyntaxError2 extends Error {
  constructor(message, line, column, source, file, plugin22) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin22) {
      this.plugin = plugin22;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError2);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css = this.source;
    if (color == null) color = pico.isColorSupported;
    if (terminalHighlight$1) {
      if (color) css = terminalHighlight$1(css);
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    let mark, aside;
    if (color) {
      let { bold, gray, red } = pico.createColors(true);
      mark = (text) => bold(red(text));
      aside = (text) => gray(text);
    } else {
      mark = aside = (str) => str;
    }
    return lines.slice(start, end).map((line, index2) => {
      let number = start + 1 + index2;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + line;
    }).join("\n");
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = "\n\n" + code + "\n";
    }
    return this.name + ": " + this.message + code;
  }
};
var cssSyntaxError = CssSyntaxError$3;
CssSyntaxError$3.default = CssSyntaxError$3;
var symbols = {};
symbols.isClean = Symbol("isClean");
symbols.my = Symbol("my");
const DEFAULT_RAW = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2 = class Stringifier2 {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node2, semicolon) {
    let name = "@" + node2.name;
    let params = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name += node2.raws.afterName;
    } else if (params) {
      name += " ";
    }
    if (node2.nodes) {
      this.block(node2, name + params);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name + params + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last = node2.nodes.length - 1;
    while (last > 0) {
      if (node2.nodes[last].type !== "comment") break;
      last -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier = Stringifier$2;
Stringifier$2.default = Stringifier$2;
let Stringifier$1 = stringifier;
function stringify$4(node2, builder) {
  let str = new Stringifier$1(builder);
  str.stringify(node2);
}
var stringify_1 = stringify$4;
stringify$4.default = stringify$4;
let { isClean: isClean$2, my: my$2 } = symbols;
let CssSyntaxError$2 = cssSyntaxError;
let Stringifier22 = stringifier;
let stringify$3 = stringify_1;
function cloneNode(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
let Node$4 = class Node3 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2] = false;
    this[my$2] = true;
    for (let name in defaults) {
      if (name === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s2 = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  markDirty() {
    if (this[isClean$2]) {
      this[isClean$2] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 + 1];
  }
  positionBy(opts, stringRepresentation) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index, stringRepresentation);
    } else if (opts.word) {
      stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);
    }
    return pos;
  }
  positionInside(index2, stringRepresentation) {
    let string = stringRepresentation || this.toString();
    let column = this.source.start.column;
    let line = this.source.start.line;
    for (let i2 = 0; i2 < index2; i2++) {
      if (string[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index2 = this.parent.index(this);
    return this.parent.nodes[index2 - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.toString();
      let index2 = stringRepresentation.indexOf(opts.word);
      if (index2 !== -1) {
        start = this.positionInside(index2, stringRepresentation);
        end = this.positionInside(index2 + opts.word.length, stringRepresentation);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier22();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        continue;
      }
      if (name === "parent" || name === "proxyCache") continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
};
var node = Node$4;
Node$4.default = Node$4;
let Node$3 = node;
let Declaration$4 = class Declaration2 extends Node$3 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration = Declaration$4;
Declaration$4.default = Declaration$4;
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1 = (size = 21) => {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure = { nanoid: nanoid$1, customAlphabet };
let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require$$2;
let { existsSync, readFileSync } = require$$2;
let { dirname: dirname$1, join } = require$$2;
function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2 = class PreviousMap2 {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length));
    }
    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map) {
    if (typeof map !== "object") return false;
    return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!comments) return;
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname$1(path);
    if (existsSync(path)) {
      this.mapFile = path;
      return readFileSync(path, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer$2) {
        return SourceMapGenerator$2.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join(dirname$1(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap = PreviousMap$2;
PreviousMap$2.default = PreviousMap$2;
let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require$$2;
let { fileURLToPath, pathToFileURL: pathToFileURL$1 } = require$$2;
let { isAbsolute, resolve: resolve$1 } = require$$2;
let { nanoid } = nonSecure;
let terminalHighlight = require$$2;
let CssSyntaxError$1 = cssSyntaxError;
let PreviousMap$1 = previousMap;
let fromOffsetCache = Symbol("fromOffsetCache");
let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
let pathAvailable$1 = Boolean(resolve$1 && isAbsolute);
let Input$4 = class Input2 {
  constructor(css, opts = {}) {
    if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1(opts.from);
      }
    }
    if (pathAvailable$1 && sourceMapAvailable$1) {
      let map = new PreviousMap$1(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let result2, endLine, endColumn;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1) {
        result2.input.url = pathToFileURL$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({ column, line });
    if (!from.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL$1(from.source);
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath) {
        result2.file = fileURLToPath(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name of ["hasBOM", "css", "file", "id"]) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input = Input$4;
Input$4.default = Input$4;
if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input$4);
}
let { SourceMapConsumer, SourceMapGenerator } = require$$2;
let { dirname, relative, resolve, sep } = require$$2;
let { pathToFileURL } = require$$2;
let Input$3 = input;
let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
let pathAvailable = Boolean(dirname && resolve && relative && sep);
let MapGenerator$2 = class MapGenerator2 {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let lines, last;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf("\n");
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from = dirname(resolve(from, this.mapOpts.annotation));
    }
    let path = relative(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map = node2.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input2 = new Input$3(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from = node2.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep === "\\") {
      path = path.replace(/\\/g, "/");
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
};
var mapGenerator = MapGenerator$2;
let Node$2 = node;
let Comment$4 = class Comment2 extends Node$2 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment = Comment$4;
Comment$4.default = Comment$4;
let { isClean: isClean$1, my: my$1 } = symbols;
let Declaration$3 = declaration;
let Comment$3 = comment;
let Node$1 = node;
let parse$4, Rule$4, AtRule$4, Root$6;
function cleanSource(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markDirtyUp(node2) {
  node2[isClean$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markDirtyUp(i2);
    }
  }
}
let Container$7 = class Container2 extends Node$1 {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index2, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index2 = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index2], index2);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index2) => i2(child.toProxy(), index2);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex < index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (existIndex <= index2) {
        this.indexes[id] = index2 + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource(parse$4(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3(nodes)];
    } else if (nodes.selector) {
      nodes = [new Rule$4(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1]) Container2.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1]) markDirtyUp(i2);
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index2;
    for (let id in this.indexes) {
      index2 = this.indexes[id];
      if (index2 >= child) {
        this.indexes[id] = index2 - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e2) {
        throw child.addToError(e2);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7.registerParse = (dependant) => {
  parse$4 = dependant;
};
Container$7.registerRule = (dependant) => {
  Rule$4 = dependant;
};
Container$7.registerAtRule = (dependant) => {
  AtRule$4 = dependant;
};
Container$7.registerRoot = (dependant) => {
  Root$6 = dependant;
};
var container = Container$7;
Container$7.default = Container$7;
Container$7.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6.prototype);
  }
  node2[my$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7.rebuild(child);
    });
  }
};
let Container$6 = container;
let LazyResult$4, Processor$3;
let Document$3 = class Document23 extends Container$6 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4(new Processor$3(), this, opts);
    return lazy.stringify();
  }
};
Document$3.registerLazyResult = (dependant) => {
  LazyResult$4 = dependant;
};
Document$3.registerProcessor = (dependant) => {
  Processor$3 = dependant;
};
var document$1 = Document$3;
Document$3.default = Document$3;
let printed = {};
var warnOnce$2 = function warnOnce2(message) {
  if (printed[message]) return;
  printed[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Warning$2 = class Warning2 {
  constructor(text, opts = {}) {
    this.type = "warning";
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning = Warning$2;
Warning$2.default = Warning$2;
let Warning$1 = warning;
let Result$3 = class Result2 {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1(text, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result = Result$3;
Result$3.default = Result$3;
const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = "\\".charCodeAt(0);
const SLASH = "/".charCodeAt(0);
const NEWLINE = "\n".charCodeAt(0);
const SPACE = " ".charCodeAt(0);
const FEED = "\f".charCodeAt(0);
const TAB = "	".charCodeAt(0);
const CR = "\r".charCodeAt(0);
const OPEN_SQUARE = "[".charCodeAt(0);
const CLOSE_SQUARE = "]".charCodeAt(0);
const OPEN_PARENTHESES = "(".charCodeAt(0);
const CLOSE_PARENTHESES = ")".charCodeAt(0);
const OPEN_CURLY = "{".charCodeAt(0);
const CLOSE_CURLY = "}".charCodeAt(0);
const SEMICOLON = ";".charCodeAt(0);
const ASTERISK = "*".charCodeAt(0);
const COLON = ":".charCodeAt(0);
const AT = "@".charCodeAt(0);
const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE = /[\da-f]/i;
var tokenize = function tokenizer2(input2, options = {}) {
  let css = input2.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, next, quote, content, escape;
  let escaped, escapePos, prev, n2, currentToken;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos;
        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
        currentToken = ["space", css.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n2 = css.charCodeAt(pos + 1);
        if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css.indexOf(")", pos + 1);
          content = css.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT: {
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css);
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }
        currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH: {
        next = pos;
        escape = true;
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape = !escape;
        }
        code = css.charCodeAt(next + 1);
        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1;
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css);
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let Container$5 = container;
let AtRule$3 = class AtRule2 extends Container$5 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
};
var atRule = AtRule$3;
AtRule$3.default = AtRule$3;
Container$5.registerAtRule(AtRule$3);
let Container$4 = container;
let LazyResult$3, Processor$2;
let Root$5 = class Root2 extends Container$4 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index2 = this.index(child);
    if (!ignore && index2 === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index2].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3(new Processor$2(), this, opts);
    return lazy.stringify();
  }
};
Root$5.registerLazyResult = (dependant) => {
  LazyResult$3 = dependant;
};
Root$5.registerProcessor = (dependant) => {
  Processor$2 = dependant;
};
var root = Root$5;
Root$5.default = Root$5;
Container$4.registerRoot(Root$5);
let list$2 = {
  comma(string) {
    return list$2.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === "\\") {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1 = list$2;
list$2.default = list$2;
let Container$3 = container;
let list$1 = list_1;
let Rule$3 = class Rule2 extends Container$3 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule = Rule$3;
Rule$3.default = Rule$3;
Container$3.registerRule(Rule$3);
let Declaration$2 = declaration;
let tokenizer22 = tokenize;
let Comment$2 = comment;
let AtRule$2 = atRule;
let Root$4 = root;
let Rule$2 = rule;
const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};
function findLastWithPosition(tokens) {
  for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
    let token = tokens[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1 = class Parser2 {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$4();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$2();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === "space") {
              prev = params[--shift];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node2, "params", params);
      if (last) {
        token = params[params.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens) {
    let brackets = 0;
    let token, type, prev;
    for (let [i2, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$2();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node2.text = "";
      node2.raws.left = text;
      node2.raws.right = "";
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer22(this.input);
  }
  decl(tokens, customProperty) {
    let node2 = new Declaration$2();
    this.init(node2, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ";") {
      this.semicolon = true;
      tokens.pop();
    }
    node2.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    );
    node2.source.end.offset++;
    while (tokens[0][0] !== "word") {
      if (tokens.length === 1) this.unknownWord(tokens);
      node2.raws.before += tokens.shift()[1];
    }
    node2.source.start = this.getPosition(tokens[0][2]);
    node2.prop = "";
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens, i2);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache = tokens.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().indexOf("!") === 0 && type !== "space") {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().indexOf("!") === 0) {
          node2.important = true;
          node2.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$2();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length; i2 += 1) {
      token = tokens[i2];
      type = token[0];
      if (type === "space" && i2 === length - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
        next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node2 = new Rule$2();
    this.init(node2, tokens[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node2, "selector", tokens);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = "";
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = "";
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result2 = "";
    for (let i2 = from; i2 < tokens.length; i2++) {
      result2 += tokens[i2][1];
    }
    tokens.splice(from, tokens.length - from);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser = Parser$1;
let Container$2 = container;
let Parser22 = parser;
let Input$2 = input;
function parse$3(css, opts) {
  let input2 = new Input$2(css, opts);
  let parser2 = new Parser22(input2);
  try {
    parser2.parse();
  } catch (e2) {
    if (true) {
      if (e2.name === "CssSyntaxError" && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
        } else if (/\.sass/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
        } else if (/\.less$/i.test(opts.from)) {
          e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
        }
      }
    }
    throw e2;
  }
  return parser2.root;
}
var parse_1 = parse$3;
parse$3.default = parse$3;
Container$2.registerParse(parse$3);
let { isClean, my } = symbols;
let MapGenerator$1 = mapGenerator;
let stringify$2 = stringify_1;
let Container$1 = container;
let Document$2 = document$1;
let warnOnce$1 = warnOnce$2;
let Result$2 = result;
let parse$2 = parse_1;
let Root$3 = root;
const TYPE_TO_CLASS_NAME = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN = 0;
function isPromise(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents(node2) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME[node2.type];
  if (node2.type === "decl") {
    key = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key = node2.name.toLowerCase();
  }
  if (key && node2.append) {
    return [
      type,
      type + "-" + key,
      CHILDREN,
      type + "Exit",
      type + "Exit-" + key
    ];
  } else if (key) {
    return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
  } else if (node2.append) {
    return [type, CHILDREN, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN, "RootExit"];
  } else {
    events = getEvents(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks(node2) {
  node2[isClean] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks(i2));
  return node2;
}
let postcss$2 = {};
let LazyResult$2 = class LazyResult2 {
  constructor(processor2, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
      root2 = cleanMarks(css);
    } else if (css instanceof LazyResult2 || css instanceof Result$2) {
      root2 = cleanMarks(css.root);
      if (css.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser2 = parse$2;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my]) {
        Container$1.rebuild(root2);
      }
    }
    this.result = new Result$2(processor2, root2, opts);
    this.helpers = { ...postcss$2, postcss: postcss$2, result: this.result };
    this.plugins = this.processor.plugins.map((plugin22) => {
      if (typeof plugin22 === "object" && plugin22.prepare) {
        return { ...plugin22, ...plugin22.prepare(this.result) };
      } else {
        return plugin22;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin22 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin22.postcssPlugin;
        error.setMessage();
      } else if (plugin22.postcssVersion) {
        if (true) {
          let pluginName = plugin22.postcssPlugin;
          let pluginVer = plugin22.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a2 = pluginVer.split(".");
          let b = runtimeVer.split(".");
          if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {
            console.error(
              "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
            );
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin22, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin22, cb]);
    };
    for (let plugin22 of this.plugins) {
      if (typeof plugin22 === "object") {
        for (let event in plugin22) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin22.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin22[event] === "object") {
              for (let filter in plugin22[event]) {
                if (filter === "*") {
                  add(plugin22, event, plugin22[event][filter]);
                } else {
                  add(
                    plugin22,
                    event + "-" + filter.toLowerCase(),
                    plugin22[event][filter]
                  );
                }
              }
            } else if (typeof plugin22[event] === "function") {
              add(plugin22, event, plugin22[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin22 = this.plugins[i2];
      let promise = this.runOnRoot(plugin22);
      if (isPromise(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        let stack = [toStack(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (e2) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e2, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin22, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin22;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e2) {
            throw this.handleError(e2);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin22) {
    this.result.lastPlugin = plugin22;
    try {
      if (typeof plugin22 === "object" && plugin22.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin22.Once(root2, this.helpers)
          );
          if (isPromise(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin22.Once(this.result.root, this.helpers);
      } else if (typeof plugin22 === "function") {
        return plugin22(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator$1(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin22 of this.plugins) {
      let promise = this.runOnRoot(plugin22);
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this.opts)) {
        warnOnce$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin22, visitor] of visitors) {
      this.result.lastPlugin = plugin22;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit2 = stack[stack.length - 1];
    let { node: node2, visitors } = visit2;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
      let [plugin22, visitor] = visitors[visit2.visitorIndex];
      visit2.visitorIndex += 1;
      if (visit2.visitorIndex === visitors.length) {
        visit2.visitors = [];
        visit2.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin22;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e2) {
        throw this.handleError(e2, node2);
      }
    }
    if (visit2.iterator !== 0) {
      let iterator = visit2.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean]) {
          child[isClean] = true;
          stack.push(toStack(child));
          return;
        }
      }
      visit2.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit2.events;
    while (visit2.eventIndex < events.length) {
      let event = events[visit2.eventIndex];
      visit2.eventIndex += 1;
      if (event === CHILDREN) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean] = true;
          visit2.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit2.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean] = true;
    let events = getEvents(node2);
    for (let event of events) {
      if (event === CHILDREN) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2.registerPostcss = (dependant) => {
  postcss$2 = dependant;
};
var lazyResult = LazyResult$2;
LazyResult$2.default = LazyResult$2;
Root$3.registerLazyResult(LazyResult$2);
Document$2.registerLazyResult(LazyResult$2);
let MapGenerator22 = mapGenerator;
let stringify$1 = stringify_1;
let warnOnce22 = warnOnce$2;
let parse$1 = parse_1;
const Result$1 = result;
let NoWorkResult$1 = class NoWorkResult2 {
  constructor(processor2, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1;
    this.result = new Result$1(this._processor, root2, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator22(str, root2, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!("from" in this._opts)) {
        warnOnce22(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult = NoWorkResult$1;
NoWorkResult$1.default = NoWorkResult$1;
let NoWorkResult22 = noWorkResult;
let LazyResult$1 = lazyResult;
let Document$1 = document$1;
let Root$2 = root;
let Processor$1 = class Processor2 {
  constructor(plugins = []) {
    this.version = "8.4.38";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (true) {
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
        }
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult22(this, css, opts);
    } else {
      return new LazyResult$1(this, css, opts);
    }
  }
  use(plugin22) {
    this.plugins = this.plugins.concat(this.normalize([plugin22]));
    return this;
  }
};
var processor = Processor$1;
Processor$1.default = Processor$1;
Root$2.registerProcessor(Processor$1);
Document$1.registerProcessor(Processor$1);
let Declaration$1 = declaration;
let PreviousMap22 = previousMap;
let Comment$1 = comment;
let AtRule$1 = atRule;
let Input$1 = input;
let Root$1 = root;
let Rule$1 = rule;
function fromJSON$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n2) => fromJSON$1(n2));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$1.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap22.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n2) => fromJSON$1(n2, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$1(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$1(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$1(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$1(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$1(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1 = fromJSON$1;
fromJSON$1.default = fromJSON$1;
let CssSyntaxError22 = cssSyntaxError;
let Declaration22 = declaration;
let LazyResult22 = lazyResult;
let Container22 = container;
let Processor22 = processor;
let stringify = stringify_1;
let fromJSON = fromJSON_1;
let Document222 = document$1;
let Warning22 = warning;
let Comment22 = comment;
let AtRule22 = atRule;
let Result22 = result;
let Input22 = input;
let parse = parse_1;
let list = list_1;
let Rule22 = rule;
let Root22 = root;
let Node22 = node;
function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor22(plugins);
}
postcss.plugin = function plugin2(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name + ":  postcss.plugin . :\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor22().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function(css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss.stringify = stringify;
postcss.parse = parse;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = (defaults) => new Comment22(defaults);
postcss.atRule = (defaults) => new AtRule22(defaults);
postcss.decl = (defaults) => new Declaration22(defaults);
postcss.rule = (defaults) => new Rule22(defaults);
postcss.root = (defaults) => new Root22(defaults);
postcss.document = (defaults) => new Document222(defaults);
postcss.CssSyntaxError = CssSyntaxError22;
postcss.Declaration = Declaration22;
postcss.Container = Container22;
postcss.Processor = Processor22;
postcss.Document = Document222;
postcss.Comment = Comment22;
postcss.Warning = Warning22;
postcss.AtRule = AtRule22;
postcss.Result = Result22;
postcss.Input = Input22;
postcss.Rule = Rule22;
postcss.Root = Root22;
postcss.Node = Node22;
LazyResult22.registerPostcss(postcss);
var postcss_1 = postcss;
postcss.default = postcss;
const postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);
postcss$1.stringify;
postcss$1.fromJSON;
postcss$1.plugin;
postcss$1.parse;
postcss$1.list;
postcss$1.document;
postcss$1.comment;
postcss$1.atRule;
postcss$1.rule;
postcss$1.decl;
postcss$1.root;
postcss$1.CssSyntaxError;
postcss$1.Declaration;
postcss$1.Container;
postcss$1.Processor;
postcss$1.Document;
postcss$1.Comment;
postcss$1.Warning;
postcss$1.AtRule;
postcss$1.Result;
postcss$1.Input;
postcss$1.Rule;
postcss$1.Root;
postcss$1.Node;
class BaseRRNode {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  constructor(..._args) {
    __publicField2(this, "parentElement", null);
    __publicField2(this, "parentNode", null);
    __publicField2(this, "ownerDocument");
    __publicField2(this, "firstChild", null);
    __publicField2(this, "lastChild", null);
    __publicField2(this, "previousSibling", null);
    __publicField2(this, "nextSibling", null);
    __publicField2(this, "ELEMENT_NODE", 1);
    __publicField2(this, "TEXT_NODE", 3);
    __publicField2(this, "nodeType");
    __publicField2(this, "nodeName");
    __publicField2(this, "RRNodeType");
  }
  get childNodes() {
    const childNodes2 = [];
    let childIterator = this.firstChild;
    while (childIterator) {
      childNodes2.push(childIterator);
      childIterator = childIterator.nextSibling;
    }
    return childNodes2;
  }
  contains(node2) {
    if (!(node2 instanceof BaseRRNode)) return false;
    else if (node2.ownerDocument !== this.ownerDocument) return false;
    else if (node2 === this) return true;
    while (node2.parentNode) {
      if (node2.parentNode === this) return true;
      node2 = node2.parentNode;
    }
    return false;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  appendChild(_newChild) {
    throw new Error(
      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  insertBefore(_newChild, _refChild) {
    throw new Error(
      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeChild(_node) {
    throw new Error(
      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`
    );
  }
  toString() {
    return "RRNode";
  }
}
const testableAccessors = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
};
const testableMethods = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
};
const untaintedBasePrototype = {};
const isAngularZonePresent = () => {
  return !!globalThis.Zone;
};
function getUntaintedPrototype(key) {
  if (untaintedBasePrototype[key])
    return untaintedBasePrototype[key];
  const defaultObj = globalThis[key];
  const defaultPrototype = defaultObj.prototype;
  const accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;
  const isUntaintedAccessors = Boolean(
    accessorNames && // @ts-expect-error 2345
    accessorNames.every(
      (accessor) => {
        var _a2, _b;
        return Boolean(
          (_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes("[native code]")
        );
      }
    )
  );
  const methodNames = key in testableMethods ? testableMethods[key] : void 0;
  const isUntaintedMethods = Boolean(
    methodNames && methodNames.every(
      // @ts-expect-error 2345
      (method) => {
        var _a2;
        return typeof defaultPrototype[method] === "function" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes("[native code]"));
      }
    )
  );
  if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {
    untaintedBasePrototype[key] = defaultObj.prototype;
    return defaultObj.prototype;
  }
  try {
    const iframeEl = document.createElement("iframe");
    document.body.appendChild(iframeEl);
    const win = iframeEl.contentWindow;
    if (!win) return defaultObj.prototype;
    const untaintedObject = win[key].prototype;
    document.body.removeChild(iframeEl);
    if (!untaintedObject) return defaultPrototype;
    return untaintedBasePrototype[key] = untaintedObject;
  } catch {
    return defaultPrototype;
  }
}
const untaintedAccessorCache = {};
function getUntaintedAccessor(key, instance, accessor) {
  var _a2;
  const cacheKey = `${key}.${String(accessor)}`;
  if (untaintedAccessorCache[cacheKey])
    return untaintedAccessorCache[cacheKey].call(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype(key);
  const untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(
    untaintedPrototype,
    accessor
  )) == null ? void 0 : _a2.get;
  if (!untaintedAccessor) return instance[accessor];
  untaintedAccessorCache[cacheKey] = untaintedAccessor;
  return untaintedAccessor.call(instance);
}
const untaintedMethodCache = {};
function getUntaintedMethod(key, instance, method) {
  const cacheKey = `${key}.${String(method)}`;
  if (untaintedMethodCache[cacheKey])
    return untaintedMethodCache[cacheKey].bind(
      instance
    );
  const untaintedPrototype = getUntaintedPrototype(key);
  const untaintedMethod = untaintedPrototype[method];
  if (typeof untaintedMethod !== "function") return instance[method];
  untaintedMethodCache[cacheKey] = untaintedMethod;
  return untaintedMethod.bind(instance);
}
function childNodes(n2) {
  return getUntaintedAccessor("Node", n2, "childNodes");
}
function parentNode(n2) {
  return getUntaintedAccessor("Node", n2, "parentNode");
}
function parentElement(n2) {
  return getUntaintedAccessor("Node", n2, "parentElement");
}
function textContent(n2) {
  return getUntaintedAccessor("Node", n2, "textContent");
}
function contains(n2, other) {
  return getUntaintedMethod("Node", n2, "contains")(other);
}
function getRootNode(n2) {
  return getUntaintedMethod("Node", n2, "getRootNode")();
}
function host(n2) {
  if (!n2 || !("host" in n2)) return null;
  return getUntaintedAccessor("ShadowRoot", n2, "host");
}
function styleSheets(n2) {
  return n2.styleSheets;
}
function shadowRoot(n2) {
  if (!n2 || !("shadowRoot" in n2)) return null;
  return getUntaintedAccessor("Element", n2, "shadowRoot");
}
function querySelector(n2, selectors) {
  return getUntaintedAccessor("Element", n2, "querySelector")(selectors);
}
function querySelectorAll(n2, selectors) {
  return getUntaintedAccessor("Element", n2, "querySelectorAll")(selectors);
}
function mutationObserverCtor() {
  return getUntaintedPrototype("MutationObserver").constructor;
}
const index = {
  childNodes,
  parentNode,
  parentElement,
  textContent,
  contains,
  getRootNode,
  host,
  styleSheets,
  shadowRoot,
  querySelector,
  querySelectorAll,
  mutationObserver: mutationObserverCtor
};
function on(type, fn, target = document) {
  const options = { capture: true, passive: true };
  target.addEventListener(type, fn, options);
  return () => target.removeEventListener(type, fn, options);
}
const DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
let _mirror = {
  map: {},
  getId() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return -1;
  },
  getNode() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return null;
  },
  removeNodeFromMap() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  },
  has() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return false;
  },
  reset() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  }
};
if (typeof window !== "undefined" && window.Proxy && window.Reflect) {
  _mirror = new Proxy(_mirror, {
    get(target, prop, receiver) {
      if (prop === "map") {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function throttle(func, wait, options = {}) {
  let timeout = null;
  let previous = 0;
  return function(...args) {
    const now = Date.now();
    if (!previous && options.leading === false) {
      previous = now;
    }
    const remaining = wait - (now - previous);
    const context = this;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      func.apply(context, args);
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(() => {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}
function hookSetter(target, key, d, isRevoked, win = window) {
  const original = win.Object.getOwnPropertyDescriptor(target, key);
  win.Object.defineProperty(
    target,
    key,
    isRevoked ? d : {
      set(value) {
        setTimeout(() => {
          d.set.call(this, value);
        }, 0);
        if (original && original.set) {
          original.set.call(this, value);
        }
      }
    }
  );
  return () => hookSetter(target, key, original || {}, true);
}
function patch(source, name, replacement) {
  try {
    if (!(name in source)) {
      return () => {
      };
    }
    const original = source[name];
    const wrapped = replacement(original);
    if (typeof wrapped === "function") {
      wrapped.prototype = wrapped.prototype || {};
      Object.defineProperties(wrapped, {
        __rrweb_original__: {
          enumerable: false,
          value: original
        }
      });
    }
    source[name] = wrapped;
    return () => {
      source[name] = original;
    };
  } catch {
    return () => {
    };
  }
}
let nowTimestamp = Date.now;
if (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {
  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();
}
function getWindowScroll(win) {
  var _a2, _b, _c, _d;
  const doc = win.document;
  return {
    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,
    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0
  };
}
function getWindowHeight() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function getWindowWidth() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function closestElementOfNode(node2) {
  if (!node2) {
    return null;
  }
  const el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);
  return el;
}
function isBlocked(node2, blockClass, blockSelector, checkAncestors) {
  if (!node2) {
    return false;
  }
  const el = closestElementOfNode(node2);
  if (!el) {
    return false;
  }
  try {
    if (typeof blockClass === "string") {
      if (el.classList.contains(blockClass)) return true;
      if (checkAncestors && el.closest("." + blockClass) !== null) return true;
    } else {
      if (classMatchesRegex(el, blockClass, checkAncestors)) return true;
    }
  } catch (e2) {
  }
  if (blockSelector) {
    if (el.matches(blockSelector)) return true;
    if (checkAncestors && el.closest(blockSelector) !== null) return true;
  }
  return false;
}
function isSerialized(n2, mirror2) {
  return mirror2.getId(n2) !== -1;
}
function isIgnored(n2, mirror2, slimDOMOptions) {
  if (n2.tagName === "TITLE" && slimDOMOptions.headTitleMutations) {
    return true;
  }
  return mirror2.getId(n2) === IGNORED_NODE;
}
function isAncestorRemoved(target, mirror2) {
  if (isShadowRoot(target)) {
    return false;
  }
  const id = mirror2.getId(target);
  if (!mirror2.has(id)) {
    return true;
  }
  const parent = index.parentNode(target);
  if (parent && parent.nodeType === target.DOCUMENT_NODE) {
    return false;
  }
  if (!parent) {
    return true;
  }
  return isAncestorRemoved(parent, mirror2);
}
function legacy_isTouchEvent(event) {
  return Boolean(event.changedTouches);
}
function polyfill$1(win = window) {
  if ("NodeList" in win && !win.NodeList.prototype.forEach) {
    win.NodeList.prototype.forEach = Array.prototype.forEach;
  }
  if ("DOMTokenList" in win && !win.DOMTokenList.prototype.forEach) {
    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;
  }
}
function isSerializedIframe(n2, mirror2) {
  return Boolean(n2.nodeName === "IFRAME" && mirror2.getMeta(n2));
}
function isSerializedStylesheet(n2, mirror2) {
  return Boolean(
    n2.nodeName === "LINK" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute("rel") === "stylesheet" && mirror2.getMeta(n2)
  );
}
function hasShadowRoot(n2) {
  if (!n2) return false;
  if (n2 instanceof BaseRRNode && "shadowRoot" in n2) {
    return Boolean(n2.shadowRoot);
  }
  return Boolean(index.shadowRoot(n2));
}
class StyleSheetMirror {
  constructor() {
    __publicField(this, "id", 1);
    __publicField(this, "styleIDMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "idStyleMap", /* @__PURE__ */ new Map());
  }
  getId(stylesheet) {
    return this.styleIDMap.get(stylesheet) ?? -1;
  }
  has(stylesheet) {
    return this.styleIDMap.has(stylesheet);
  }
  /**
   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.
   */
  add(stylesheet, id) {
    if (this.has(stylesheet)) return this.getId(stylesheet);
    let newId;
    if (id === void 0) {
      newId = this.id++;
    } else newId = id;
    this.styleIDMap.set(stylesheet, newId);
    this.idStyleMap.set(newId, stylesheet);
    return newId;
  }
  getStyle(id) {
    return this.idStyleMap.get(id) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap();
    this.idStyleMap = /* @__PURE__ */ new Map();
    this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function getShadowHost(n2) {
  var _a2;
  let shadowHost = null;
  if ("getRootNode" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2)))
    shadowHost = index.host(index.getRootNode(n2));
  return shadowHost;
}
function getRootShadowHost(n2) {
  let rootShadowHost = n2;
  let shadowHost;
  while (shadowHost = getShadowHost(rootShadowHost))
    rootShadowHost = shadowHost;
  return rootShadowHost;
}
function shadowHostInDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc) return false;
  const shadowHost = getRootShadowHost(n2);
  return index.contains(doc, shadowHost);
}
function inDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc) return false;
  return index.contains(doc, n2) || shadowHostInDom(n2);
}
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType || {});
var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource || {});
var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(MouseInteractions || {});
var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(PointerTypes || {});
var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(CanvasContext || {});
var MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
  return MediaInteractions2;
})(MediaInteractions || {});
var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType || {});
function isNodeInLinkedList(n2) {
  return "__ln" in n2;
}
class DoubleLinkedList {
  constructor() {
    __publicField(this, "length", 0);
    __publicField(this, "head", null);
    __publicField(this, "tail", null);
  }
  get(position) {
    if (position >= this.length) {
      throw new Error("Position outside of list range");
    }
    let current = this.head;
    for (let index2 = 0; index2 < position; index2++) {
      current = (current == null ? void 0 : current.next) || null;
    }
    return current;
  }
  addNode(n2) {
    const node2 = {
      value: n2,
      previous: null,
      next: null
    };
    n2.__ln = node2;
    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {
      const current = n2.previousSibling.__ln.next;
      node2.next = current;
      node2.previous = n2.previousSibling.__ln;
      n2.previousSibling.__ln.next = node2;
      if (current) {
        current.previous = node2;
      }
    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {
      const current = n2.nextSibling.__ln.previous;
      node2.previous = current;
      node2.next = n2.nextSibling.__ln;
      n2.nextSibling.__ln.previous = node2;
      if (current) {
        current.next = node2;
      }
    } else {
      if (this.head) {
        this.head.previous = node2;
      }
      node2.next = this.head;
      this.head = node2;
    }
    if (node2.next === null) {
      this.tail = node2;
    }
    this.length++;
  }
  removeNode(n2) {
    const current = n2.__ln;
    if (!this.head) {
      return;
    }
    if (!current.previous) {
      this.head = current.next;
      if (this.head) {
        this.head.previous = null;
      } else {
        this.tail = null;
      }
    } else {
      current.previous.next = current.next;
      if (current.next) {
        current.next.previous = current.previous;
      } else {
        this.tail = current.previous;
      }
    }
    if (n2.__ln) {
      delete n2.__ln;
    }
    this.length--;
  }
}
const moveKey = (id, parentId) => `${id}@${parentId}`;
class MutationBuffer {
  constructor() {
    __publicField(this, "frozen", false);
    __publicField(this, "locked", false);
    __publicField(this, "texts", []);
    __publicField(this, "attributes", []);
    __publicField(this, "attributeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "removes", []);
    __publicField(this, "mapRemoves", []);
    __publicField(this, "movedMap", {});
    __publicField(this, "addedSet", /* @__PURE__ */ new Set());
    __publicField(this, "movedSet", /* @__PURE__ */ new Set());
    __publicField(this, "droppedSet", /* @__PURE__ */ new Set());
    __publicField(this, "removesSubTreeCache", /* @__PURE__ */ new Set());
    __publicField(this, "mutationCb");
    __publicField(this, "blockClass");
    __publicField(this, "blockSelector");
    __publicField(this, "maskTextClass");
    __publicField(this, "maskTextSelector");
    __publicField(this, "inlineStylesheet");
    __publicField(this, "maskInputOptions");
    __publicField(this, "maskTextFn");
    __publicField(this, "maskInputFn");
    __publicField(this, "keepIframeSrcFn");
    __publicField(this, "recordCanvas");
    __publicField(this, "inlineImages");
    __publicField(this, "slimDOMOptions");
    __publicField(this, "dataURLOptions");
    __publicField(this, "doc");
    __publicField(this, "mirror");
    __publicField(this, "iframeManager");
    __publicField(this, "stylesheetManager");
    __publicField(this, "shadowDomManager");
    __publicField(this, "canvasManager");
    __publicField(this, "processedNodeManager");
    __publicField(this, "unattachedDoc");
    __publicField(this, "processMutations", (mutations) => {
      mutations.forEach(this.processMutation);
      this.emit();
    });
    __publicField(this, "emit", () => {
      if (this.frozen || this.locked) {
        return;
      }
      const adds = [];
      const addedIds = /* @__PURE__ */ new Set();
      const addList = new DoubleLinkedList();
      const getNextId = (n2) => {
        let ns = n2;
        let nextId = IGNORED_NODE;
        while (nextId === IGNORED_NODE) {
          ns = ns && ns.nextSibling;
          nextId = ns && this.mirror.getId(ns);
        }
        return nextId;
      };
      const pushAdd = (n2) => {
        const parent = index.parentNode(n2);
        if (!parent || !inDom(n2)) {
          return;
        }
        let cssCaptured = false;
        if (n2.nodeType === Node.TEXT_NODE) {
          const parentTag = parent.tagName;
          if (parentTag === "TEXTAREA") {
            return;
          } else if (parentTag === "STYLE" && this.addedSet.has(parent)) {
            cssCaptured = true;
          }
        }
        const parentId = isShadowRoot(parent) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(parent);
        const nextId = getNextId(n2);
        if (parentId === -1 || nextId === -1) {
          return addList.addNode(n2);
        }
        const sn = serializeNodeWithId(n2, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: true,
          newlyAddedElement: true,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          onSerialize: (currentN) => {
            if (isSerializedIframe(currentN, this.mirror)) {
              this.iframeManager.addIframe(currentN);
            }
            if (isSerializedStylesheet(currentN, this.mirror)) {
              this.stylesheetManager.trackLinkElement(
                currentN
              );
            }
            if (hasShadowRoot(n2)) {
              this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), this.doc);
            }
          },
          onIframeLoad: (iframe, childSn) => {
            this.iframeManager.attachIframe(iframe, childSn);
            this.shadowDomManager.observeAttachShadow(iframe);
          },
          onStylesheetLoad: (link, childSn) => {
            this.stylesheetManager.attachLinkElement(link, childSn);
          },
          cssCaptured
        });
        if (sn) {
          adds.push({
            parentId,
            nextId,
            node: sn
          });
          addedIds.add(sn.id);
        }
      };
      while (this.mapRemoves.length) {
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      }
      for (const n2 of this.movedSet) {
        if (isParentRemoved(this.removesSubTreeCache, n2, this.mirror) && !this.movedSet.has(index.parentNode(n2))) {
          continue;
        }
        pushAdd(n2);
      }
      for (const n2 of this.addedSet) {
        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removesSubTreeCache, n2, this.mirror)) {
          pushAdd(n2);
        } else if (isAncestorInSet(this.movedSet, n2)) {
          pushAdd(n2);
        } else {
          this.droppedSet.add(n2);
        }
      }
      let candidate = null;
      while (addList.length) {
        let node2 = null;
        if (candidate) {
          const parentId = this.mirror.getId(index.parentNode(candidate.value));
          const nextId = getNextId(candidate.value);
          if (parentId !== -1 && nextId !== -1) {
            node2 = candidate;
          }
        }
        if (!node2) {
          let tailNode = addList.tail;
          while (tailNode) {
            const _node = tailNode;
            tailNode = tailNode.previous;
            if (_node) {
              const parentId = this.mirror.getId(index.parentNode(_node.value));
              const nextId = getNextId(_node.value);
              if (nextId === -1) continue;
              else if (parentId !== -1) {
                node2 = _node;
                break;
              } else {
                const unhandledNode = _node.value;
                const parent = index.parentNode(unhandledNode);
                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const shadowHost = index.host(parent);
                  const parentId2 = this.mirror.getId(shadowHost);
                  if (parentId2 !== -1) {
                    node2 = _node;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!node2) {
          while (addList.head) {
            addList.removeNode(addList.head.value);
          }
          break;
        }
        candidate = node2.previous;
        addList.removeNode(node2.value);
        pushAdd(node2.value);
      }
      const payload = {
        texts: this.texts.map((text) => {
          const n2 = text.node;
          const parent = index.parentNode(n2);
          if (parent && parent.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(parent);
          }
          return {
            id: this.mirror.getId(n2),
            value: text.value
          };
        }).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),
        attributes: this.attributes.map((attribute) => {
          const { attributes } = attribute;
          if (typeof attributes.style === "string") {
            const diffAsStr = JSON.stringify(attribute.styleDiff);
            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);
            if (diffAsStr.length < attributes.style.length) {
              if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {
                attributes.style = attribute.styleDiff;
              }
            }
          }
          return {
            id: this.mirror.getId(attribute.node),
            attributes
          };
        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),
        removes: this.removes,
        adds
      };
      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
        return;
      }
      this.texts = [];
      this.attributes = [];
      this.attributeMap = /* @__PURE__ */ new WeakMap();
      this.removes = [];
      this.addedSet = /* @__PURE__ */ new Set();
      this.movedSet = /* @__PURE__ */ new Set();
      this.droppedSet = /* @__PURE__ */ new Set();
      this.removesSubTreeCache = /* @__PURE__ */ new Set();
      this.movedMap = {};
      this.mutationCb(payload);
    });
    __publicField(this, "genTextAreaValueMutation", (textarea) => {
      let item = this.attributeMap.get(textarea);
      if (!item) {
        item = {
          node: textarea,
          attributes: {},
          styleDiff: {},
          _unchangedStyles: {}
        };
        this.attributes.push(item);
        this.attributeMap.set(textarea, item);
      }
      item.attributes.value = Array.from(
        index.childNodes(textarea),
        (cn) => index.textContent(cn) || ""
      ).join("");
    });
    __publicField(this, "processMutation", (m) => {
      if (isIgnored(m.target, this.mirror, this.slimDOMOptions)) {
        return;
      }
      switch (m.type) {
        case "characterData": {
          const value = index.textContent(m.target);
          if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {
            this.texts.push({
              value: needMaskingText(
                m.target,
                this.maskTextClass,
                this.maskTextSelector,
                true
                // checkAncestors
              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\S]/g, "*") : value,
              node: m.target
            });
          }
          break;
        }
        case "attributes": {
          const target = m.target;
          let attributeName = m.attributeName;
          let value = m.target.getAttribute(attributeName);
          if (attributeName === "value") {
            const type = getInputType(target);
            value = maskInputValue({
              element: target,
              maskInputOptions: this.maskInputOptions,
              tagName: target.tagName,
              type,
              value,
              maskInputFn: this.maskInputFn
            });
          }
          if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {
            return;
          }
          let item = this.attributeMap.get(m.target);
          if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {
            if (!target.contentDocument) {
              attributeName = "rr_src";
            } else {
              return;
            }
          }
          if (!item) {
            item = {
              node: m.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            };
            this.attributes.push(item);
            this.attributeMap.set(m.target, item);
          }
          if (attributeName === "type" && target.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
            target.setAttribute("data-rr-is-password", "true");
          }
          if (!ignoreAttribute(target.tagName, attributeName)) {
            item.attributes[attributeName] = transformAttribute(
              this.doc,
              toLowerCase(target.tagName),
              toLowerCase(attributeName),
              value
            );
            if (attributeName === "style") {
              if (!this.unattachedDoc) {
                try {
                  this.unattachedDoc = document.implementation.createHTMLDocument();
                } catch (e2) {
                  this.unattachedDoc = this.doc;
                }
              }
              const old = this.unattachedDoc.createElement("span");
              if (m.oldValue) {
                old.setAttribute("style", m.oldValue);
              }
              for (const pname of Array.from(target.style)) {
                const newValue = target.style.getPropertyValue(pname);
                const newPriority = target.style.getPropertyPriority(pname);
                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {
                  if (newPriority === "") {
                    item.styleDiff[pname] = newValue;
                  } else {
                    item.styleDiff[pname] = [newValue, newPriority];
                  }
                } else {
                  item._unchangedStyles[pname] = [newValue, newPriority];
                }
              }
              for (const pname of Array.from(old.style)) {
                if (target.style.getPropertyValue(pname) === "") {
                  item.styleDiff[pname] = false;
                }
              }
            } else if (attributeName === "open" && target.tagName === "DIALOG") {
              if (target.matches("dialog:modal")) {
                item.attributes["rr_open_mode"] = "modal";
              } else {
                item.attributes["rr_open_mode"] = "non-modal";
              }
            }
          }
          break;
        }
        case "childList": {
          if (isBlocked(m.target, this.blockClass, this.blockSelector, true))
            return;
          if (m.target.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(m.target);
            return;
          }
          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));
          m.removedNodes.forEach((n2) => {
            const nodeId = this.mirror.getId(n2);
            const parentId = isShadowRoot(m.target) ? this.mirror.getId(index.host(m.target)) : this.mirror.getId(m.target);
            if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n2, this.mirror, this.slimDOMOptions) || !isSerialized(n2, this.mirror)) {
              return;
            }
            if (this.addedSet.has(n2)) {
              deepDelete(this.addedSet, n2);
              this.droppedSet.add(n2);
            } else if (this.addedSet.has(m.target) && nodeId === -1) ;
            else if (isAncestorRemoved(m.target, this.mirror)) ;
            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {
              deepDelete(this.movedSet, n2);
            } else {
              this.removes.push({
                parentId,
                id: nodeId,
                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0
              });
              processRemoves(n2, this.removesSubTreeCache);
            }
            this.mapRemoves.push(n2);
          });
          break;
        }
      }
    });
    __publicField(this, "genAdds", (n2, target) => {
      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;
      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;
      if (this.mirror.hasNode(n2)) {
        if (isIgnored(n2, this.mirror, this.slimDOMOptions)) {
          return;
        }
        this.movedSet.add(n2);
        let targetId = null;
        if (target && this.mirror.hasNode(target)) {
          targetId = this.mirror.getId(target);
        }
        if (targetId && targetId !== -1) {
          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;
        }
      } else {
        this.addedSet.add(n2);
        this.droppedSet.delete(n2);
      }
      if (!isBlocked(n2, this.blockClass, this.blockSelector, false)) {
        index.childNodes(n2).forEach((childN) => this.genAdds(childN));
        if (hasShadowRoot(n2)) {
          index.childNodes(index.shadowRoot(n2)).forEach((childN) => {
            this.processedNodeManager.add(childN, this);
            this.genAdds(childN, n2);
          });
        }
      }
    });
  }
  init(options) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((key) => {
      this[key] = options[key];
    });
  }
  freeze() {
    this.frozen = true;
    this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = false;
    this.canvasManager.unfreeze();
    this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = true;
    this.canvasManager.lock();
  }
  unlock() {
    this.locked = false;
    this.canvasManager.unlock();
    this.emit();
  }
  reset() {
    this.shadowDomManager.reset();
    this.canvasManager.reset();
  }
}
function deepDelete(addsSet, n2) {
  addsSet.delete(n2);
  index.childNodes(n2).forEach((childN) => deepDelete(addsSet, childN));
}
function processRemoves(n2, cache) {
  const queue = [n2];
  while (queue.length) {
    const next = queue.pop();
    if (cache.has(next)) continue;
    cache.add(next);
    index.childNodes(next).forEach((n22) => queue.push(n22));
  }
  return;
}
function isParentRemoved(removes, n2, mirror2) {
  if (removes.size === 0) return false;
  return _isParentRemoved(removes, n2);
}
function _isParentRemoved(removes, n2, _mirror2) {
  const node2 = index.parentNode(n2);
  if (!node2) return false;
  return removes.has(node2);
}
function isAncestorInSet(set, n2) {
  if (set.size === 0) return false;
  return _isAncestorInSet(set, n2);
}
function _isAncestorInSet(set, n2) {
  const parent = index.parentNode(n2);
  if (!parent) {
    return false;
  }
  if (set.has(parent)) {
    return true;
  }
  return _isAncestorInSet(set, parent);
}
let errorHandler;
function registerErrorHandler(handler) {
  errorHandler = handler;
}
function unregisterErrorHandler() {
  errorHandler = void 0;
}
const callbackWrapper = (cb) => {
  if (!errorHandler) {
    return cb;
  }
  const rrwebWrapped = (...rest) => {
    try {
      return cb(...rest);
    } catch (error) {
      if (errorHandler && errorHandler(error) === true) {
        return;
      }
      throw error;
    }
  };
  return rrwebWrapped;
};
const mutationBuffers = [];
function getEventTarget(event) {
  try {
    if ("composedPath" in event) {
      const path = event.composedPath();
      if (path.length) {
        return path[0];
      }
    } else if ("path" in event && event.path.length) {
      return event.path[0];
    }
  } catch {
  }
  return event && event.target;
}
function initMutationObserver(options, rootEl) {
  const mutationBuffer = new MutationBuffer();
  mutationBuffers.push(mutationBuffer);
  mutationBuffer.init(options);
  const observer = new (mutationObserverCtor())(
    callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer))
  );
  observer.observe(rootEl, {
    attributes: true,
    attributeOldValue: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  });
  return observer;
}
function initMoveObserver({
  mousemoveCb,
  sampling,
  doc,
  mirror: mirror2
}) {
  if (sampling.mousemove === false) {
    return () => {
    };
  }
  const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;
  const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;
  let positions = [];
  let timeBaseline;
  const wrappedCb = throttle(
    callbackWrapper(
      (source) => {
        const totalOffset = Date.now() - timeBaseline;
        mousemoveCb(
          positions.map((p) => {
            p.timeOffset -= totalOffset;
            return p;
          }),
          source
        );
        positions = [];
        timeBaseline = null;
      }
    ),
    callbackThreshold
  );
  const updatePosition = callbackWrapper(
    throttle(
      callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;
        if (!timeBaseline) {
          timeBaseline = nowTimestamp();
        }
        positions.push({
          x: clientX,
          y: clientY,
          id: mirror2.getId(target),
          timeOffset: nowTimestamp() - timeBaseline
        });
        wrappedCb(
          typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove
        );
      }),
      threshold,
      {
        trailing: false
      }
    )
  );
  const handlers = [
    on("mousemove", updatePosition, doc),
    on("touchmove", updatePosition, doc),
    on("drag", updatePosition, doc)
  ];
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initMouseInteractionObserver({
  mouseInteractionCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  sampling
}) {
  if (sampling.mouseInteraction === false) {
    return () => {
    };
  }
  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;
  const handlers = [];
  let currentPointerType = null;
  const getHandler = (eventKey) => {
    return (event) => {
      const target = getEventTarget(event);
      if (isBlocked(target, blockClass, blockSelector, true)) {
        return;
      }
      let pointerType = null;
      let thisEventKey = eventKey;
      if ("pointerType" in event) {
        switch (event.pointerType) {
          case "mouse":
            pointerType = PointerTypes.Mouse;
            break;
          case "touch":
            pointerType = PointerTypes.Touch;
            break;
          case "pen":
            pointerType = PointerTypes.Pen;
            break;
        }
        if (pointerType === PointerTypes.Touch) {
          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {
            thisEventKey = "TouchStart";
          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {
            thisEventKey = "TouchEnd";
          }
        } else if (pointerType === PointerTypes.Pen) ;
      } else if (legacy_isTouchEvent(event)) {
        pointerType = PointerTypes.Touch;
      }
      if (pointerType !== null) {
        currentPointerType = pointerType;
        if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {
          pointerType = null;
        }
      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {
        pointerType = currentPointerType;
        currentPointerType = null;
      }
      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;
      if (!e2) {
        return;
      }
      const id = mirror2.getId(target);
      const { clientX, clientY } = e2;
      callbackWrapper(mouseInteractionCb)({
        type: MouseInteractions[thisEventKey],
        id,
        x: clientX,
        y: clientY,
        ...pointerType !== null && { pointerType }
      });
    };
  };
  Object.keys(MouseInteractions).filter(
    (key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false
  ).forEach((eventKey) => {
    let eventName = toLowerCase(eventKey);
    const handler = getHandler(eventKey);
    if (window.PointerEvent) {
      switch (MouseInteractions[eventKey]) {
        case MouseInteractions.MouseDown:
        case MouseInteractions.MouseUp:
          eventName = eventName.replace(
            "mouse",
            "pointer"
          );
          break;
        case MouseInteractions.TouchStart:
        case MouseInteractions.TouchEnd:
          return;
      }
    }
    handlers.push(on(eventName, handler, doc));
  });
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initScrollObserver({
  scrollCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  sampling
}) {
  const updatePosition = callbackWrapper(
    throttle(
      callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const id = mirror2.getId(target);
        if (target === doc && doc.defaultView) {
          const scrollLeftTop = getWindowScroll(doc.defaultView);
          scrollCb({
            id,
            x: scrollLeftTop.left,
            y: scrollLeftTop.top
          });
        } else {
          scrollCb({
            id,
            x: target.scrollLeft,
            y: target.scrollTop
          });
        }
      }),
      sampling.scroll || 100
    )
  );
  return on("scroll", updatePosition, doc);
}
function initViewportResizeObserver({ viewportResizeCb }, { win }) {
  let lastH = -1;
  let lastW = -1;
  const updateDimension = callbackWrapper(
    throttle(
      callbackWrapper(() => {
        const height = getWindowHeight();
        const width = getWindowWidth();
        if (lastH !== height || lastW !== width) {
          viewportResizeCb({
            width: Number(width),
            height: Number(height)
          });
          lastH = height;
          lastW = width;
        }
      }),
      200
    )
  );
  return on("resize", updateDimension, win);
}
const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
const lastInputValueMap = /* @__PURE__ */ new WeakMap();
function initInputObserver({
  inputCb,
  doc,
  mirror: mirror2,
  blockClass,
  blockSelector,
  ignoreClass,
  ignoreSelector,
  maskInputOptions,
  maskInputFn,
  sampling,
  userTriggeredOnInput
}) {
  function eventHandler(event) {
    let target = getEventTarget(event);
    const userTriggered = event.isTrusted;
    const tagName = target && target.tagName;
    if (target && tagName === "OPTION") {
      target = index.parentElement(target);
    }
    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {
      return;
    }
    if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {
      return;
    }
    let text = target.value;
    let isChecked = false;
    const type = getInputType(target) || "";
    if (type === "radio" || type === "checkbox") {
      isChecked = target.checked;
    } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {
      text = maskInputValue({
        element: target,
        maskInputOptions,
        tagName,
        type,
        value: text,
        maskInputFn
      });
    }
    cbWithDedup(
      target,
      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }
    );
    const name = target.name;
    if (type === "radio" && name && isChecked) {
      doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el) => {
        if (el !== target) {
          const text2 = el.value;
          cbWithDedup(
            el,
            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }
          );
        }
      });
    }
  }
  function cbWithDedup(target, v2) {
    const lastInputValue = lastInputValueMap.get(target);
    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {
      lastInputValueMap.set(target, v2);
      const id = mirror2.getId(target);
      callbackWrapper(inputCb)({
        ...v2,
        id
      });
    }
  }
  const events = sampling.input === "last" ? ["change"] : ["input", "change"];
  const handlers = events.map(
    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)
  );
  const currentWindow = doc.defaultView;
  if (!currentWindow) {
    return () => {
      handlers.forEach((h) => h());
    };
  }
  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(
    currentWindow.HTMLInputElement.prototype,
    "value"
  );
  const hookProperties = [
    [currentWindow.HTMLInputElement.prototype, "value"],
    [currentWindow.HTMLInputElement.prototype, "checked"],
    [currentWindow.HTMLSelectElement.prototype, "value"],
    [currentWindow.HTMLTextAreaElement.prototype, "value"],
    // Some UI library use selectedIndex to set select value
    [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],
    [currentWindow.HTMLOptionElement.prototype, "selected"]
  ];
  if (propertyDescriptor && propertyDescriptor.set) {
    handlers.push(
      ...hookProperties.map(
        (p) => hookSetter(
          p[0],
          p[1],
          {
            set() {
              callbackWrapper(eventHandler)({
                target: this,
                isTrusted: false
                // userTriggered to false as this could well be programmatic
              });
            }
          },
          false,
          currentWindow
        )
      )
    );
  }
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function getNestedCSSRulePositions(rule2) {
  const positions = [];
  function recurse(childRule, pos) {
    if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {
      const rules2 = Array.from(
        childRule.parentRule.cssRules
      );
      const index2 = rules2.indexOf(childRule);
      pos.unshift(index2);
    } else if (childRule.parentStyleSheet) {
      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);
      const index2 = rules2.indexOf(childRule);
      pos.unshift(index2);
    }
    return pos;
  }
  return recurse(rule2, positions);
}
function getIdAndStyleId(sheet, mirror2, styleMirror) {
  let id, styleId;
  if (!sheet) return {};
  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);
  else styleId = styleMirror.getId(sheet);
  return {
    styleId,
    id
  };
}
function initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {
  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {
    return () => {
    };
  }
  const insertRule = win.CSSStyleSheet.prototype.insertRule;
  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        const [rule2, index2] = argumentsList;
        const { id, styleId } = getIdAndStyleId(
          thisArg,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id,
            styleId,
            adds: [{ rule: rule2, index: index2 }]
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2 = this.cssRules.length) {
    const rule2 = `${selector} { ${styleBlock} }`;
    return win.CSSStyleSheet.prototype.insertRule.apply(this, [rule2, index2]);
  };
  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;
  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        const [index2] = argumentsList;
        const { id, styleId } = getIdAndStyleId(
          thisArg,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id,
            styleId,
            removes: [{ index: index2 }]
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  win.CSSStyleSheet.prototype.removeRule = function(index2) {
    return win.CSSStyleSheet.prototype.deleteRule.apply(this, [index2]);
  };
  let replace;
  if (win.CSSStyleSheet.prototype.replace) {
    replace = win.CSSStyleSheet.prototype.replace;
    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {
      apply: callbackWrapper(
        (target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id, styleId } = getIdAndStyleId(
            thisArg,
            mirror2,
            stylesheetManager.styleMirror
          );
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              replace: text
            });
          }
          return target.apply(thisArg, argumentsList);
        }
      )
    });
  }
  let replaceSync;
  if (win.CSSStyleSheet.prototype.replaceSync) {
    replaceSync = win.CSSStyleSheet.prototype.replaceSync;
    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {
      apply: callbackWrapper(
        (target, thisArg, argumentsList) => {
          const [text] = argumentsList;
          const { id, styleId } = getIdAndStyleId(
            thisArg,
            mirror2,
            stylesheetManager.styleMirror
          );
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              replaceSync: text
            });
          }
          return target.apply(thisArg, argumentsList);
        }
      )
    });
  }
  const supportedNestedCSSRuleTypes = {};
  if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;
  } else {
    if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;
    }
  }
  const unmodifiedFunctions = {};
  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
    unmodifiedFunctions[typeKey] = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      insertRule: type.prototype.insertRule,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      deleteRule: type.prototype.deleteRule
    };
    type.prototype.insertRule = new Proxy(
      unmodifiedFunctions[typeKey].insertRule,
      {
        apply: callbackWrapper(
          (target, thisArg, argumentsList) => {
            const [rule2, index2] = argumentsList;
            const { id, styleId } = getIdAndStyleId(
              thisArg.parentStyleSheet,
              mirror2,
              stylesheetManager.styleMirror
            );
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                adds: [
                  {
                    rule: rule2,
                    index: [
                      ...getNestedCSSRulePositions(thisArg),
                      index2 || 0
                      // defaults to 0
                    ]
                  }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          }
        )
      }
    );
    type.prototype.deleteRule = new Proxy(
      unmodifiedFunctions[typeKey].deleteRule,
      {
        apply: callbackWrapper(
          (target, thisArg, argumentsList) => {
            const [index2] = argumentsList;
            const { id, styleId } = getIdAndStyleId(
              thisArg.parentStyleSheet,
              mirror2,
              stylesheetManager.styleMirror
            );
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                removes: [
                  { index: [...getNestedCSSRulePositions(thisArg), index2] }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          }
        )
      }
    );
  });
  return callbackWrapper(() => {
    win.CSSStyleSheet.prototype.insertRule = insertRule;
    win.CSSStyleSheet.prototype.deleteRule = deleteRule;
    replace && (win.CSSStyleSheet.prototype.replace = replace);
    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);
    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;
      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;
    });
  });
}
function initAdoptedStyleSheetObserver({
  mirror: mirror2,
  stylesheetManager
}, host2) {
  var _a2, _b, _c;
  let hostId = null;
  if (host2.nodeName === "#document") hostId = mirror2.getId(host2);
  else hostId = mirror2.getId(index.host(host2));
  const patchTarget = host2.nodeName === "#document" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;
  const originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(
    patchTarget == null ? void 0 : patchTarget.prototype,
    "adoptedStyleSheets"
  ) : void 0;
  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)
    return () => {
    };
  Object.defineProperty(host2, "adoptedStyleSheets", {
    configurable: originalPropertyDescriptor.configurable,
    enumerable: originalPropertyDescriptor.enumerable,
    get() {
      var _a3;
      return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);
    },
    set(sheets) {
      var _a3;
      const result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);
      if (hostId !== null && hostId !== -1) {
        try {
          stylesheetManager.adoptStyleSheets(sheets, hostId);
        } catch (e2) {
        }
      }
      return result2;
    }
  });
  return callbackWrapper(() => {
    Object.defineProperty(host2, "adoptedStyleSheets", {
      configurable: originalPropertyDescriptor.configurable,
      enumerable: originalPropertyDescriptor.enumerable,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      get: originalPropertyDescriptor.get,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      set: originalPropertyDescriptor.set
    });
  });
}
function initStyleDeclarationObserver({
  styleDeclarationCb,
  mirror: mirror2,
  ignoreCSSAttributes,
  stylesheetManager
}, { win }) {
  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;
  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        var _a2;
        const [property, value, priority] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return setProperty.apply(thisArg, [property, value, priority]);
        }
        const { id, styleId } = getIdAndStyleId(
          (_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id,
            styleId,
            set: {
              property,
              value,
              priority
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;
  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {
    apply: callbackWrapper(
      (target, thisArg, argumentsList) => {
        var _a2;
        const [property] = argumentsList;
        if (ignoreCSSAttributes.has(property)) {
          return removeProperty.apply(thisArg, [property]);
        }
        const { id, styleId } = getIdAndStyleId(
          (_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet,
          mirror2,
          stylesheetManager.styleMirror
        );
        if (id && id !== -1 || styleId && styleId !== -1) {
          styleDeclarationCb({
            id,
            styleId,
            remove: {
              property
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            index: getNestedCSSRulePositions(thisArg.parentRule)
          });
        }
        return target.apply(thisArg, argumentsList);
      }
    )
  });
  return callbackWrapper(() => {
    win.CSSStyleDeclaration.prototype.setProperty = setProperty;
    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;
  });
}
function initMediaInteractionObserver({
  mediaInteractionCb,
  blockClass,
  blockSelector,
  mirror: mirror2,
  sampling,
  doc
}) {
  const handler = callbackWrapper(
    (type) => throttle(
      callbackWrapper((event) => {
        const target = getEventTarget(event);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const { currentTime, volume, muted, playbackRate, loop } = target;
        mediaInteractionCb({
          type,
          id: mirror2.getId(target),
          currentTime,
          volume,
          muted,
          playbackRate,
          loop
        });
      }),
      sampling.media || 500
    )
  );
  const handlers = [
    on("play", handler(MediaInteractions.Play), doc),
    on("pause", handler(MediaInteractions.Pause), doc),
    on("seeked", handler(MediaInteractions.Seeked), doc),
    on("volumechange", handler(MediaInteractions.VolumeChange), doc),
    on("ratechange", handler(MediaInteractions.RateChange), doc)
  ];
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initFontObserver({ fontCb, doc }) {
  const win = doc.defaultView;
  if (!win) {
    return () => {
    };
  }
  const handlers = [];
  const fontMap = /* @__PURE__ */ new WeakMap();
  const originalFontFace = win.FontFace;
  win.FontFace = function FontFace2(family, source, descriptors) {
    const fontFace = new originalFontFace(family, source, descriptors);
    fontMap.set(fontFace, {
      family,
      buffer: typeof source !== "string",
      descriptors,
      fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))
    });
    return fontFace;
  };
  const restoreHandler = patch(
    doc.fonts,
    "add",
    function(original) {
      return function(fontFace) {
        setTimeout(
          callbackWrapper(() => {
            const p = fontMap.get(fontFace);
            if (p) {
              fontCb(p);
              fontMap.delete(fontFace);
            }
          }),
          0
        );
        return original.apply(this, [fontFace]);
      };
    }
  );
  handlers.push(() => {
    win.FontFace = originalFontFace;
  });
  handlers.push(restoreHandler);
  return callbackWrapper(() => {
    handlers.forEach((h) => h());
  });
}
function initSelectionObserver(param) {
  const { doc, mirror: mirror2, blockClass, blockSelector, selectionCb } = param;
  let collapsed = true;
  const updateSelection = callbackWrapper(() => {
    const selection = doc.getSelection();
    if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;
    collapsed = selection.isCollapsed || false;
    const ranges = [];
    const count = selection.rangeCount || 0;
    for (let i2 = 0; i2 < count; i2++) {
      const range = selection.getRangeAt(i2);
      const { startContainer, startOffset, endContainer, endOffset } = range;
      const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);
      if (blocked) continue;
      ranges.push({
        start: mirror2.getId(startContainer),
        startOffset,
        end: mirror2.getId(endContainer),
        endOffset
      });
    }
    selectionCb({ ranges });
  });
  updateSelection();
  return on("selectionchange", updateSelection);
}
function initCustomElementObserver({
  doc,
  customElementCb
}) {
  const win = doc.defaultView;
  if (!win || !win.customElements) return () => {
  };
  const restoreHandler = patch(
    win.customElements,
    "define",
    function(original) {
      return function(name, constructor, options) {
        try {
          customElementCb({
            define: {
              name
            }
          });
        } catch (e2) {
          console.warn(`Custom element callback failed for ${name}`);
        }
        return original.apply(this, [name, constructor, options]);
      };
    }
  );
  return restoreHandler;
}
function mergeHooks(o2, hooks) {
  const {
    mutationCb,
    mousemoveCb,
    mouseInteractionCb,
    scrollCb,
    viewportResizeCb,
    inputCb,
    mediaInteractionCb,
    styleSheetRuleCb,
    styleDeclarationCb,
    canvasMutationCb,
    fontCb,
    selectionCb,
    customElementCb
  } = o2;
  o2.mutationCb = (...p) => {
    if (hooks.mutation) {
      hooks.mutation(...p);
    }
    mutationCb(...p);
  };
  o2.mousemoveCb = (...p) => {
    if (hooks.mousemove) {
      hooks.mousemove(...p);
    }
    mousemoveCb(...p);
  };
  o2.mouseInteractionCb = (...p) => {
    if (hooks.mouseInteraction) {
      hooks.mouseInteraction(...p);
    }
    mouseInteractionCb(...p);
  };
  o2.scrollCb = (...p) => {
    if (hooks.scroll) {
      hooks.scroll(...p);
    }
    scrollCb(...p);
  };
  o2.viewportResizeCb = (...p) => {
    if (hooks.viewportResize) {
      hooks.viewportResize(...p);
    }
    viewportResizeCb(...p);
  };
  o2.inputCb = (...p) => {
    if (hooks.input) {
      hooks.input(...p);
    }
    inputCb(...p);
  };
  o2.mediaInteractionCb = (...p) => {
    if (hooks.mediaInteaction) {
      hooks.mediaInteaction(...p);
    }
    mediaInteractionCb(...p);
  };
  o2.styleSheetRuleCb = (...p) => {
    if (hooks.styleSheetRule) {
      hooks.styleSheetRule(...p);
    }
    styleSheetRuleCb(...p);
  };
  o2.styleDeclarationCb = (...p) => {
    if (hooks.styleDeclaration) {
      hooks.styleDeclaration(...p);
    }
    styleDeclarationCb(...p);
  };
  o2.canvasMutationCb = (...p) => {
    if (hooks.canvasMutation) {
      hooks.canvasMutation(...p);
    }
    canvasMutationCb(...p);
  };
  o2.fontCb = (...p) => {
    if (hooks.font) {
      hooks.font(...p);
    }
    fontCb(...p);
  };
  o2.selectionCb = (...p) => {
    if (hooks.selection) {
      hooks.selection(...p);
    }
    selectionCb(...p);
  };
  o2.customElementCb = (...c2) => {
    if (hooks.customElement) {
      hooks.customElement(...c2);
    }
    customElementCb(...c2);
  };
}
function initObservers(o2, hooks = {}) {
  const currentWindow = o2.doc.defaultView;
  if (!currentWindow) {
    return () => {
    };
  }
  mergeHooks(o2, hooks);
  let mutationObserver;
  if (o2.recordDOM) {
    mutationObserver = initMutationObserver(o2, o2.doc);
  }
  const mousemoveHandler = initMoveObserver(o2);
  const mouseInteractionHandler = initMouseInteractionObserver(o2);
  const scrollHandler = initScrollObserver(o2);
  const viewportResizeHandler = initViewportResizeObserver(o2, {
    win: currentWindow
  });
  const inputHandler = initInputObserver(o2);
  const mediaInteractionHandler = initMediaInteractionObserver(o2);
  let styleSheetObserver = () => {
  };
  let adoptedStyleSheetObserver = () => {
  };
  let styleDeclarationObserver = () => {
  };
  let fontObserver = () => {
  };
  if (o2.recordDOM) {
    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });
    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);
    styleDeclarationObserver = initStyleDeclarationObserver(o2, {
      win: currentWindow
    });
    if (o2.collectFonts) {
      fontObserver = initFontObserver(o2);
    }
  }
  const selectionObserver = initSelectionObserver(o2);
  const customElementObserver = initCustomElementObserver(o2);
  const pluginHandlers = [];
  for (const plugin3 of o2.plugins) {
    pluginHandlers.push(
      plugin3.observer(plugin3.callback, currentWindow, plugin3.options)
    );
  }
  return callbackWrapper(() => {
    mutationBuffers.forEach((b) => b.reset());
    mutationObserver == null ? void 0 : mutationObserver.disconnect();
    mousemoveHandler();
    mouseInteractionHandler();
    scrollHandler();
    viewportResizeHandler();
    inputHandler();
    mediaInteractionHandler();
    styleSheetObserver();
    adoptedStyleSheetObserver();
    styleDeclarationObserver();
    fontObserver();
    selectionObserver();
    customElementObserver();
    pluginHandlers.forEach((h) => h());
  });
}
function hasNestedCSSRule(prop) {
  return typeof window[prop] !== "undefined";
}
function canMonkeyPatchNestedCSSRule(prop) {
  return Boolean(
    typeof window[prop] !== "undefined" && // Note: Generally, this check _shouldn't_ be necessary
    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here
    window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype
  );
}
class CrossOriginIframeMirror {
  constructor(generateIdFn) {
    __publicField(this, "iframeIdToRemoteIdMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "iframeRemoteIdToIdMap", /* @__PURE__ */ new WeakMap());
    this.generateIdFn = generateIdFn;
  }
  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {
    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);
    let id = idToRemoteIdMap.get(remoteId);
    if (!id) {
      id = this.generateIdFn();
      idToRemoteIdMap.set(remoteId, id);
      remoteIdToIdMap.set(id, remoteId);
    }
    return id;
  }
  getIds(iframe, remoteId) {
    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return remoteId.map(
      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)
    );
  }
  getRemoteId(iframe, id, map) {
    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);
    if (typeof id !== "number") return id;
    const remoteId = remoteIdToIdMap.get(id);
    if (!remoteId) return -1;
    return remoteId;
  }
  getRemoteIds(iframe, ids) {
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));
  }
  reset(iframe) {
    if (!iframe) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(iframe);
    this.iframeRemoteIdToIdMap.delete(iframe);
  }
  getIdToRemoteIdMap(iframe) {
    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);
    if (!idToRemoteIdMap) {
      idToRemoteIdMap = /* @__PURE__ */ new Map();
      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);
    }
    return idToRemoteIdMap;
  }
  getRemoteIdToIdMap(iframe) {
    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);
    if (!remoteIdToIdMap) {
      remoteIdToIdMap = /* @__PURE__ */ new Map();
      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);
    }
    return remoteIdToIdMap;
  }
}
class IframeManager {
  constructor(options) {
    __publicField(this, "iframes", /* @__PURE__ */ new WeakMap());
    __publicField(this, "crossOriginIframeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "crossOriginIframeMirror", new CrossOriginIframeMirror(genId));
    __publicField(this, "crossOriginIframeStyleMirror");
    __publicField(this, "crossOriginIframeRootIdMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "mirror");
    __publicField(this, "mutationCb");
    __publicField(this, "wrappedEmit");
    __publicField(this, "loadListener");
    __publicField(this, "stylesheetManager");
    __publicField(this, "recordCrossOriginIframes");
    this.mutationCb = options.mutationCb;
    this.wrappedEmit = options.wrappedEmit;
    this.stylesheetManager = options.stylesheetManager;
    this.recordCrossOriginIframes = options.recordCrossOriginIframes;
    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(
      this.stylesheetManager.styleMirror.generateId.bind(
        this.stylesheetManager.styleMirror
      )
    );
    this.mirror = options.mirror;
    if (this.recordCrossOriginIframes) {
      window.addEventListener("message", this.handleMessage.bind(this));
    }
  }
  addIframe(iframeEl) {
    this.iframes.set(iframeEl, true);
    if (iframeEl.contentWindow)
      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);
  }
  addLoadListener(cb) {
    this.loadListener = cb;
  }
  attachIframe(iframeEl, childSn) {
    var _a2, _b;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(iframeEl),
          nextId: null,
          node: childSn
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: true
    });
    if (this.recordCrossOriginIframes)
      (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(
        "message",
        this.handleMessage.bind(this)
      );
    (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);
    if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)
      this.stylesheetManager.adoptStyleSheets(
        iframeEl.contentDocument.adoptedStyleSheets,
        this.mirror.getId(iframeEl.contentDocument)
      );
  }
  handleMessage(message) {
    const crossOriginMessageEvent = message;
    if (crossOriginMessageEvent.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.
    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)
      return;
    const iframeSourceWindow = message.source;
    if (!iframeSourceWindow) return;
    const iframeEl = this.crossOriginIframeMap.get(message.source);
    if (!iframeEl) return;
    const transformedEvent = this.transformCrossOriginEvent(
      iframeEl,
      crossOriginMessageEvent.data.event
    );
    if (transformedEvent)
      this.wrappedEmit(
        transformedEvent,
        crossOriginMessageEvent.data.isCheckout
      );
  }
  transformCrossOriginEvent(iframeEl, e2) {
    var _a2;
    switch (e2.type) {
      case EventType.FullSnapshot: {
        this.crossOriginIframeMirror.reset(iframeEl);
        this.crossOriginIframeStyleMirror.reset(iframeEl);
        this.replaceIdOnNode(e2.data.node, iframeEl);
        const rootId = e2.data.node.id;
        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);
        this.patchRootIdOnNode(e2.data.node, rootId);
        return {
          timestamp: e2.timestamp,
          type: EventType.IncrementalSnapshot,
          data: {
            source: IncrementalSource.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(iframeEl),
                nextId: null,
                node: e2.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: true
          }
        };
      }
      case EventType.Meta:
      case EventType.Load:
      case EventType.DomContentLoaded: {
        return false;
      }
      case EventType.Plugin: {
        return e2;
      }
      case EventType.Custom: {
        this.replaceIds(
          e2.data.payload,
          iframeEl,
          ["id", "parentId", "previousId", "nextId"]
        );
        return e2;
      }
      case EventType.IncrementalSnapshot: {
        switch (e2.data.source) {
          case IncrementalSource.Mutation: {
            e2.data.adds.forEach((n2) => {
              this.replaceIds(n2, iframeEl, [
                "parentId",
                "nextId",
                "previousId"
              ]);
              this.replaceIdOnNode(n2.node, iframeEl);
              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);
              rootId && this.patchRootIdOnNode(n2.node, rootId);
            });
            e2.data.removes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["parentId", "id"]);
            });
            e2.data.attributes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            e2.data.texts.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource.Drag:
          case IncrementalSource.TouchMove:
          case IncrementalSource.MouseMove: {
            e2.data.positions.forEach((p) => {
              this.replaceIds(p, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource.ViewportResize: {
            return false;
          }
          case IncrementalSource.MediaInteraction:
          case IncrementalSource.MouseInteraction:
          case IncrementalSource.Scroll:
          case IncrementalSource.CanvasMutation:
          case IncrementalSource.Input: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            return e2;
          }
          case IncrementalSource.StyleSheetRule:
          case IncrementalSource.StyleDeclaration: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleId"]);
            return e2;
          }
          case IncrementalSource.Font: {
            return e2;
          }
          case IncrementalSource.Selection: {
            e2.data.ranges.forEach((range) => {
              this.replaceIds(range, iframeEl, ["start", "end"]);
            });
            return e2;
          }
          case IncrementalSource.AdoptedStyleSheet: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleIds"]);
            (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach((style) => {
              this.replaceStyleIds(style, iframeEl, ["styleId"]);
            });
            return e2;
          }
        }
      }
    }
    return false;
  }
  replace(iframeMirror, obj, iframeEl, keys) {
    for (const key of keys) {
      if (!Array.isArray(obj[key]) && typeof obj[key] !== "number") continue;
      if (Array.isArray(obj[key])) {
        obj[key] = iframeMirror.getIds(
          iframeEl,
          obj[key]
        );
      } else {
        obj[key] = iframeMirror.getId(iframeEl, obj[key]);
      }
    }
    return obj;
  }
  replaceIds(obj, iframeEl, keys) {
    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);
  }
  replaceStyleIds(obj, iframeEl, keys) {
    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);
  }
  replaceIdOnNode(node2, iframeEl) {
    this.replaceIds(node2, iframeEl, ["id", "rootId"]);
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.replaceIdOnNode(child, iframeEl);
      });
    }
  }
  patchRootIdOnNode(node2, rootId) {
    if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.patchRootIdOnNode(child, rootId);
      });
    }
  }
}
class ShadowDomManager {
  constructor(options) {
    __publicField(this, "shadowDoms", /* @__PURE__ */ new WeakSet());
    __publicField(this, "mutationCb");
    __publicField(this, "scrollCb");
    __publicField(this, "bypassOptions");
    __publicField(this, "mirror");
    __publicField(this, "restoreHandlers", []);
    this.mutationCb = options.mutationCb;
    this.scrollCb = options.scrollCb;
    this.bypassOptions = options.bypassOptions;
    this.mirror = options.mirror;
    this.init();
  }
  init() {
    this.reset();
    this.patchAttachShadow(Element, document);
  }
  addShadowRoot(shadowRoot2, doc) {
    if (!isNativeShadowDom(shadowRoot2)) return;
    if (this.shadowDoms.has(shadowRoot2)) return;
    this.shadowDoms.add(shadowRoot2);
    const observer = initMutationObserver(
      {
        ...this.bypassOptions,
        doc,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      },
      shadowRoot2
    );
    this.restoreHandlers.push(() => observer.disconnect());
    this.restoreHandlers.push(
      initScrollObserver({
        ...this.bypassOptions,
        scrollCb: this.scrollCb,
        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813
        // scroll is not allowed to pass the boundary, so we need to listen the shadow document
        doc: shadowRoot2,
        mirror: this.mirror
      })
    );
    setTimeout(() => {
      if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0)
        this.bypassOptions.stylesheetManager.adoptStyleSheets(
          shadowRoot2.adoptedStyleSheets,
          this.mirror.getId(index.host(shadowRoot2))
        );
      this.restoreHandlers.push(
        initAdoptedStyleSheetObserver(
          {
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          },
          shadowRoot2
        )
      );
    }, 0);
  }
  /**
   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.
   */
  observeAttachShadow(iframeElement) {
    if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;
    this.patchAttachShadow(
      iframeElement.contentWindow.Element,
      iframeElement.contentDocument
    );
  }
  /**
   * Patch 'attachShadow' to observe newly added shadow doms.
   */
  patchAttachShadow(element, doc) {
    const manager = this;
    this.restoreHandlers.push(
      patch(
        element.prototype,
        "attachShadow",
        function(original) {
          return function(option) {
            const sRoot = original.call(this, option);
            const shadowRootEl = index.shadowRoot(this);
            if (shadowRootEl && inDom(this))
              manager.addShadowRoot(shadowRootEl, doc);
            return sRoot;
          };
        }
      )
    );
  }
  reset() {
    this.restoreHandlers.forEach((handler) => {
      try {
        handler();
      } catch (e2) {
      }
    });
    this.restoreHandlers = [];
    this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) {
  lookup[chars.charCodeAt(i$1)] = i$1;
}
var encode = function(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
  for (i2 = 0; i2 < len; i2 += 3) {
    base64 += chars[bytes[i2] >> 2];
    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
    base64 += chars[bytes[i2 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
const canvasVarMap = /* @__PURE__ */ new Map();
function variableListFor$1(ctx, ctor) {
  let contextMap = canvasVarMap.get(ctx);
  if (!contextMap) {
    contextMap = /* @__PURE__ */ new Map();
    canvasVarMap.set(ctx, contextMap);
  }
  if (!contextMap.has(ctor)) {
    contextMap.set(ctor, []);
  }
  return contextMap.get(ctor);
}
const saveWebGLVar = (value, win, ctx) => {
  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === "object"))
    return;
  const name = value.constructor.name;
  const list2 = variableListFor$1(ctx, name);
  let index2 = list2.indexOf(value);
  if (index2 === -1) {
    index2 = list2.length;
    list2.push(value);
  }
  return index2;
};
function serializeArg(value, win, ctx) {
  if (value instanceof Array) {
    return value.map((arg) => serializeArg(arg, win, ctx));
  } else if (value === null) {
    return value;
  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [Object.values(value)]
    };
  } else if (
    // SharedArrayBuffer disabled on most browsers due to spectre.
    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer
    // value instanceof SharedArrayBuffer ||
    value instanceof ArrayBuffer
  ) {
    const name = value.constructor.name;
    const base64 = encode(value);
    return {
      rr_type: name,
      base64
    };
  } else if (value instanceof DataView) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [
        serializeArg(value.buffer, win, ctx),
        value.byteOffset,
        value.byteLength
      ]
    };
  } else if (value instanceof HTMLImageElement) {
    const name = value.constructor.name;
    const { src } = value;
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof HTMLCanvasElement) {
    const name = "HTMLImageElement";
    const src = value.toDataURL();
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof ImageData) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [serializeArg(value.data, win, ctx), value.width, value.height]
    };
  } else if (isInstanceOfWebGLObject(value, win) || typeof value === "object") {
    const name = value.constructor.name;
    const index2 = saveWebGLVar(value, win, ctx);
    return {
      rr_type: name,
      index: index2
    };
  }
  return value;
}
const serializeArgs = (args, win, ctx) => {
  return args.map((arg) => serializeArg(arg, win, ctx));
};
const isInstanceOfWebGLObject = (value, win) => {
  const webGLConstructorNames = [
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLFramebuffer",
    "WebGLProgram",
    "WebGLRenderbuffer",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLTexture",
    "WebGLUniformLocation",
    "WebGLVertexArrayObject",
    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.
    "WebGLVertexArrayObjectOES"
  ];
  const supportedWebGLConstructorNames = webGLConstructorNames.filter(
    (name) => typeof win[name] === "function"
  );
  return Boolean(
    supportedWebGLConstructorNames.find(
      (name) => value instanceof win[name]
    )
  );
};
function initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {
  const handlers = [];
  const props2D = Object.getOwnPropertyNames(
    win.CanvasRenderingContext2D.prototype
  );
  for (const prop of props2D) {
    try {
      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch(
        win.CanvasRenderingContext2D.prototype,
        prop,
        function(original) {
          return function(...args) {
            if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {
              setTimeout(() => {
                const recordArgs = serializeArgs(args, win, this);
                cb(this.canvas, {
                  type: CanvasContext["2D"],
                  property: prop,
                  args: recordArgs
                });
              }, 0);
            }
            return original.apply(this, args);
          };
        }
      );
      handlers.push(restoreHandler);
    } catch {
      const hookHandler = hookSetter(
        win.CanvasRenderingContext2D.prototype,
        prop,
        {
          set(v2) {
            cb(this.canvas, {
              type: CanvasContext["2D"],
              property: prop,
              args: [v2],
              setter: true
            });
          }
        }
      );
      handlers.push(hookHandler);
    }
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
function getNormalizedContextName(contextType) {
  return contextType === "experimental-webgl" ? "webgl" : contextType;
}
function initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {
  const handlers = [];
  try {
    const restoreHandler = patch(
      win.HTMLCanvasElement.prototype,
      "getContext",
      function(original) {
        return function(contextType, ...args) {
          if (!isBlocked(this, blockClass, blockSelector, true)) {
            const ctxName = getNormalizedContextName(contextType);
            if (!("__context" in this)) this.__context = ctxName;
            if (setPreserveDrawingBufferToTrue && ["webgl", "webgl2"].includes(ctxName)) {
              if (args[0] && typeof args[0] === "object") {
                const contextAttributes = args[0];
                if (!contextAttributes.preserveDrawingBuffer) {
                  contextAttributes.preserveDrawingBuffer = true;
                }
              } else {
                args.splice(0, 1, {
                  preserveDrawingBuffer: true
                });
              }
            }
          }
          return original.apply(this, [contextType, ...args]);
        };
      }
    );
    handlers.push(restoreHandler);
  } catch {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
function patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {
  const handlers = [];
  const props = Object.getOwnPropertyNames(prototype);
  for (const prop of props) {
    if (
      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky
      [
        "isContextLost",
        "canvas",
        "drawingBufferWidth",
        "drawingBufferHeight"
      ].includes(prop)
    ) {
      continue;
    }
    try {
      if (typeof prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch(
        prototype,
        prop,
        function(original) {
          return function(...args) {
            const result2 = original.apply(this, args);
            saveWebGLVar(result2, win, this);
            if ("tagName" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {
              const recordArgs = serializeArgs(args, win, this);
              const mutation = {
                type,
                property: prop,
                args: recordArgs
              };
              cb(this.canvas, mutation);
            }
            return result2;
          };
        }
      );
      handlers.push(restoreHandler);
    } catch {
      const hookHandler = hookSetter(prototype, prop, {
        set(v2) {
          cb(this.canvas, {
            type,
            property: prop,
            args: [v2],
            setter: true
          });
        }
      });
      handlers.push(hookHandler);
    }
  }
  return handlers;
}
function initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {
  const handlers = [];
  handlers.push(
    ...patchGLPrototype(
      win.WebGLRenderingContext.prototype,
      CanvasContext.WebGL,
      cb,
      blockClass,
      blockSelector,
      win
    )
  );
  if (typeof win.WebGL2RenderingContext !== "undefined") {
    handlers.push(
      ...patchGLPrototype(
        win.WebGL2RenderingContext.prototype,
        CanvasContext.WebGL2,
        cb,
        blockClass,
        blockSelector,
        win
      )
    );
  }
  return () => {
    handlers.forEach((h) => h());
  };
}
const encodedJs = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=";
const decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0));
const blob = typeof window !== "undefined" && window.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e2) {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
class CanvasManager {
  constructor(options) {
    __publicField(this, "pendingCanvasMutations", /* @__PURE__ */ new Map());
    __publicField(this, "rafStamps", { latestId: 0, invokeId: null });
    __publicField(this, "mirror");
    __publicField(this, "mutationCb");
    __publicField(this, "resetObservers");
    __publicField(this, "frozen", false);
    __publicField(this, "locked", false);
    __publicField(this, "processMutation", (target, mutation) => {
      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
      if (newFrame || !this.rafStamps.invokeId)
        this.rafStamps.invokeId = this.rafStamps.latestId;
      if (!this.pendingCanvasMutations.has(target)) {
        this.pendingCanvasMutations.set(target, []);
      }
      this.pendingCanvasMutations.get(target).push(mutation);
    });
    const {
      sampling = "all",
      win,
      blockClass,
      blockSelector,
      recordCanvas,
      dataURLOptions
    } = options;
    this.mutationCb = options.mutationCb;
    this.mirror = options.mirror;
    if (recordCanvas && sampling === "all")
      this.initCanvasMutationObserver(win, blockClass, blockSelector);
    if (recordCanvas && typeof sampling === "number")
      this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {
        dataURLOptions
      });
  }
  reset() {
    this.pendingCanvasMutations.clear();
    this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = true;
  }
  unfreeze() {
    this.frozen = false;
  }
  lock() {
    this.locked = true;
  }
  unlock() {
    this.locked = false;
  }
  initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {
    const canvasContextReset = initCanvasContextObserver(
      win,
      blockClass,
      blockSelector,
      true
    );
    const snapshotInProgressMap = /* @__PURE__ */ new Map();
    const worker = new WorkerWrapper();
    worker.onmessage = (e2) => {
      const { id } = e2.data;
      snapshotInProgressMap.set(id, false);
      if (!("base64" in e2.data)) return;
      const { base64, type, width, height } = e2.data;
      this.mutationCb({
        id,
        type: CanvasContext["2D"],
        commands: [
          {
            property: "clearRect",
            // wipe canvas
            args: [0, 0, width, height]
          },
          {
            property: "drawImage",
            // draws (semi-transparent) image
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64 }],
                    type
                  }
                ]
              },
              0,
              0
            ]
          }
        ]
      });
    };
    const timeBetweenSnapshots = 1e3 / fps;
    let lastSnapshotTime = 0;
    let rafId;
    const getCanvas = () => {
      const matchedCanvas = [];
      win.document.querySelectorAll("canvas").forEach((canvas) => {
        if (!isBlocked(canvas, blockClass, blockSelector, true)) {
          matchedCanvas.push(canvas);
        }
      });
      return matchedCanvas;
    };
    const takeCanvasSnapshots = (timestamp) => {
      if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {
        rafId = requestAnimationFrame(takeCanvasSnapshots);
        return;
      }
      lastSnapshotTime = timestamp;
      getCanvas().forEach(async (canvas) => {
        var _a2;
        const id = this.mirror.getId(canvas);
        if (snapshotInProgressMap.get(id)) return;
        if (canvas.width === 0 || canvas.height === 0) return;
        snapshotInProgressMap.set(id, true);
        if (["webgl", "webgl2"].includes(canvas.__context)) {
          const context = canvas.getContext(canvas.__context);
          if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {
            context.clear(context.COLOR_BUFFER_BIT);
          }
        }
        const bitmap = await createImageBitmap(canvas);
        worker.postMessage(
          {
            id,
            bitmap,
            width: canvas.width,
            height: canvas.height,
            dataURLOptions: options.dataURLOptions
          },
          [bitmap]
        );
      });
      rafId = requestAnimationFrame(takeCanvasSnapshots);
    };
    rafId = requestAnimationFrame(takeCanvasSnapshots);
    this.resetObservers = () => {
      canvasContextReset();
      cancelAnimationFrame(rafId);
    };
  }
  initCanvasMutationObserver(win, blockClass, blockSelector) {
    this.startRAFTimestamping();
    this.startPendingCanvasMutationFlusher();
    const canvasContextReset = initCanvasContextObserver(
      win,
      blockClass,
      blockSelector,
      false
    );
    const canvas2DReset = initCanvas2DMutationObserver(
      this.processMutation.bind(this),
      win,
      blockClass,
      blockSelector
    );
    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(
      this.processMutation.bind(this),
      win,
      blockClass,
      blockSelector
    );
    this.resetObservers = () => {
      canvasContextReset();
      canvas2DReset();
      canvasWebGL1and2Reset();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const setLatestRAFTimestamp = (timestamp) => {
      this.rafStamps.latestId = timestamp;
      requestAnimationFrame(setLatestRAFTimestamp);
    };
    requestAnimationFrame(setLatestRAFTimestamp);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach(
      (_values, canvas) => {
        const id = this.mirror.getId(canvas);
        this.flushPendingCanvasMutationFor(canvas, id);
      }
    );
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(canvas, id) {
    if (this.frozen || this.locked) {
      return;
    }
    const valuesWithType = this.pendingCanvasMutations.get(canvas);
    if (!valuesWithType || id === -1) return;
    const values = valuesWithType.map((value) => {
      const { type: type2, ...rest } = value;
      return rest;
    });
    const { type } = valuesWithType[0];
    this.mutationCb({ id, type, commands: values });
    this.pendingCanvasMutations.delete(canvas);
  }
}
class StylesheetManager {
  constructor(options) {
    __publicField(this, "trackedLinkElements", /* @__PURE__ */ new WeakSet());
    __publicField(this, "mutationCb");
    __publicField(this, "adoptedStyleSheetCb");
    __publicField(this, "styleMirror", new StyleSheetMirror());
    this.mutationCb = options.mutationCb;
    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;
  }
  attachLinkElement(linkEl, childSn) {
    if ("_cssText" in childSn.attributes)
      this.mutationCb({
        adds: [],
        removes: [],
        texts: [],
        attributes: [
          {
            id: childSn.id,
            attributes: childSn.attributes
          }
        ]
      });
    this.trackLinkElement(linkEl);
  }
  trackLinkElement(linkEl) {
    if (this.trackedLinkElements.has(linkEl)) return;
    this.trackedLinkElements.add(linkEl);
    this.trackStylesheetInLinkElement(linkEl);
  }
  adoptStyleSheets(sheets, hostId) {
    if (sheets.length === 0) return;
    const adoptedStyleSheetData = {
      id: hostId,
      styleIds: []
    };
    const styles = [];
    for (const sheet of sheets) {
      let styleId;
      if (!this.styleMirror.has(sheet)) {
        styleId = this.styleMirror.add(sheet);
        styles.push({
          styleId,
          rules: Array.from(sheet.rules || CSSRule, (r2, index2) => ({
            rule: stringifyRule(r2, sheet.href),
            index: index2
          }))
        });
      } else styleId = this.styleMirror.getId(sheet);
      adoptedStyleSheetData.styleIds.push(styleId);
    }
    if (styles.length > 0) adoptedStyleSheetData.styles = styles;
    this.adoptedStyleSheetCb(adoptedStyleSheetData);
  }
  reset() {
    this.styleMirror.reset();
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  // TODO: take snapshot on stylesheet reload by applying event listener
  trackStylesheetInLinkElement(_linkEl) {
  }
}
class ProcessedNodeManager {
  constructor() {
    __publicField(this, "nodeMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "active", false);
  }
  inOtherBuffer(node2, thisBuffer) {
    const buffers = this.nodeMap.get(node2);
    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);
  }
  add(node2, buffer) {
    if (!this.active) {
      this.active = true;
      requestAnimationFrame(() => {
        this.nodeMap = /* @__PURE__ */ new WeakMap();
        this.active = false;
      });
    }
    this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));
  }
  destroy() {
  }
}
let wrappedEmit;
let takeFullSnapshot$1;
let canvasManager;
let recording = false;
try {
  if (Array.from([1], (x2) => x2 * 2)[0] !== 2) {
    const cleanFrame = document.createElement("iframe");
    document.body.appendChild(cleanFrame);
    Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;
    document.body.removeChild(cleanFrame);
  }
} catch (err) {
  console.debug("Unable to override Array.from", err);
}
const mirror = createMirror$2();
function record(options = {}) {
  const {
    emit,
    checkoutEveryNms,
    checkoutEveryNth,
    blockClass = "rr-block",
    blockSelector = null,
    ignoreClass = "rr-ignore",
    ignoreSelector = null,
    maskTextClass = "rr-mask",
    maskTextSelector = null,
    inlineStylesheet = true,
    maskAllInputs,
    maskInputOptions: _maskInputOptions,
    slimDOMOptions: _slimDOMOptions,
    maskInputFn,
    maskTextFn,
    hooks,
    packFn,
    sampling = {},
    dataURLOptions = {},
    mousemoveWait,
    recordDOM = true,
    recordCanvas = false,
    recordCrossOriginIframes = false,
    recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load",
    userTriggeredOnInput = false,
    collectFonts = false,
    inlineImages = false,
    plugins,
    keepIframeSrcFn = () => false,
    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),
    errorHandler: errorHandler2
  } = options;
  registerErrorHandler(errorHandler2);
  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;
  let passEmitsToParent = false;
  if (!inEmittingFrame) {
    try {
      if (window.parent.document) {
        passEmitsToParent = false;
      }
    } catch (e2) {
      passEmitsToParent = true;
    }
  }
  if (inEmittingFrame && !emit) {
    throw new Error("emit function is required");
  }
  if (!inEmittingFrame && !passEmitsToParent) {
    return () => {
    };
  }
  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {
    sampling.mousemove = mousemoveWait;
  }
  mirror.reset();
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : _maskInputOptions !== void 0 ? _maskInputOptions : { password: true };
  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {
    script: true,
    comment: true,
    headFavicon: true,
    headWhitespace: true,
    headMetaSocial: true,
    headMetaRobots: true,
    headMetaHttpEquiv: true,
    headMetaVerification: true,
    // the following are off for slimDOMOptions === true,
    // as they destroy some (hidden) info:
    headMetaAuthorship: _slimDOMOptions === "all",
    headMetaDescKeywords: _slimDOMOptions === "all",
    headTitleMutations: _slimDOMOptions === "all"
  } : _slimDOMOptions ? _slimDOMOptions : {};
  polyfill$1();
  let lastFullSnapshotEvent;
  let incrementalSnapshotCount = 0;
  const eventProcessor = (e2) => {
    for (const plugin3 of plugins || []) {
      if (plugin3.eventProcessor) {
        e2 = plugin3.eventProcessor(e2);
      }
    }
    if (packFn && // Disable packing events which will be emitted to parent frames.
    !passEmitsToParent) {
      e2 = packFn(e2);
    }
    return e2;
  };
  wrappedEmit = (r2, isCheckout) => {
    var _a2;
    const e2 = r2;
    e2.timestamp = nowTimestamp();
    if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {
      mutationBuffers.forEach((buf) => buf.unfreeze());
    }
    if (inEmittingFrame) {
      emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);
    } else if (passEmitsToParent) {
      const message = {
        type: "rrweb",
        event: eventProcessor(e2),
        origin: window.location.origin,
        isCheckout
      };
      window.parent.postMessage(message, "*");
    }
    if (e2.type === EventType.FullSnapshot) {
      lastFullSnapshotEvent = e2;
      incrementalSnapshotCount = 0;
    } else if (e2.type === EventType.IncrementalSnapshot) {
      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {
        return;
      }
      incrementalSnapshotCount++;
      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
      const exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
      if (exceedCount || exceedTime) {
        takeFullSnapshot$1(true);
      }
    }
  };
  const wrappedMutationEmit = (m) => {
    wrappedEmit({
      type: EventType.IncrementalSnapshot,
      data: {
        source: IncrementalSource.Mutation,
        ...m
      }
    });
  };
  const wrappedScrollEmit = (p) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.Scroll,
      ...p
    }
  });
  const wrappedCanvasMutationEmit = (p) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.CanvasMutation,
      ...p
    }
  });
  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({
    type: EventType.IncrementalSnapshot,
    data: {
      source: IncrementalSource.AdoptedStyleSheet,
      ...a2
    }
  });
  const stylesheetManager = new StylesheetManager({
    mutationCb: wrappedMutationEmit,
    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit
  });
  const iframeManager = new IframeManager({
    mirror,
    mutationCb: wrappedMutationEmit,
    stylesheetManager,
    recordCrossOriginIframes,
    wrappedEmit
  });
  for (const plugin3 of plugins || []) {
    if (plugin3.getMirror)
      plugin3.getMirror({
        nodeMirror: mirror,
        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror
      });
  }
  const processedNodeManager = new ProcessedNodeManager();
  canvasManager = new CanvasManager({
    recordCanvas,
    mutationCb: wrappedCanvasMutationEmit,
    win: window,
    blockClass,
    blockSelector,
    mirror,
    sampling: sampling.canvas,
    dataURLOptions
  });
  const shadowDomManager = new ShadowDomManager({
    mutationCb: wrappedMutationEmit,
    scrollCb: wrappedScrollEmit,
    bypassOptions: {
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskInputOptions,
      dataURLOptions,
      maskTextFn,
      maskInputFn,
      recordCanvas,
      inlineImages,
      sampling,
      slimDOMOptions,
      iframeManager,
      stylesheetManager,
      canvasManager,
      keepIframeSrcFn,
      processedNodeManager
    },
    mirror
  });
  takeFullSnapshot$1 = (isCheckout = false) => {
    if (!recordDOM) {
      return;
    }
    wrappedEmit(
      {
        type: EventType.Meta,
        data: {
          href: window.location.href,
          width: getWindowWidth(),
          height: getWindowHeight()
        }
      },
      isCheckout
    );
    stylesheetManager.reset();
    shadowDomManager.init();
    mutationBuffers.forEach((buf) => buf.lock());
    const node2 = snapshot(document, {
      mirror,
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskAllInputs: maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOM: slimDOMOptions,
      dataURLOptions,
      recordCanvas,
      inlineImages,
      onSerialize: (n2) => {
        if (isSerializedIframe(n2, mirror)) {
          iframeManager.addIframe(n2);
        }
        if (isSerializedStylesheet(n2, mirror)) {
          stylesheetManager.trackLinkElement(n2);
        }
        if (hasShadowRoot(n2)) {
          shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);
        }
      },
      onIframeLoad: (iframe, childSn) => {
        iframeManager.attachIframe(iframe, childSn);
        shadowDomManager.observeAttachShadow(iframe);
      },
      onStylesheetLoad: (linkEl, childSn) => {
        stylesheetManager.attachLinkElement(linkEl, childSn);
      },
      keepIframeSrcFn
    });
    if (!node2) {
      return console.warn("Failed to snapshot the document");
    }
    wrappedEmit(
      {
        type: EventType.FullSnapshot,
        data: {
          node: node2,
          initialOffset: getWindowScroll(window)
        }
      },
      isCheckout
    );
    mutationBuffers.forEach((buf) => buf.unlock());
    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
      stylesheetManager.adoptStyleSheets(
        document.adoptedStyleSheets,
        mirror.getId(document)
      );
  };
  try {
    const handlers = [];
    const observe = (doc) => {
      var _a2;
      return callbackWrapper(initObservers)(
        {
          mutationCb: wrappedMutationEmit,
          mousemoveCb: (positions, source) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source,
              positions
            }
          }),
          mouseInteractionCb: (d) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MouseInteraction,
              ...d
            }
          }),
          scrollCb: wrappedScrollEmit,
          viewportResizeCb: (d) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.ViewportResize,
              ...d
            }
          }),
          inputCb: (v2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Input,
              ...v2
            }
          }),
          mediaInteractionCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.MediaInteraction,
              ...p
            }
          }),
          styleSheetRuleCb: (r2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleSheetRule,
              ...r2
            }
          }),
          styleDeclarationCb: (r2) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.StyleDeclaration,
              ...r2
            }
          }),
          canvasMutationCb: wrappedCanvasMutationEmit,
          fontCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
              source: IncrementalSource.Font,
              ...p
            }
          }),
          selectionCb: (p) => {
            wrappedEmit({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.Selection,
                ...p
              }
            });
          },
          customElementCb: (c2) => {
            wrappedEmit({
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.CustomElement,
                ...c2
              }
            });
          },
          blockClass,
          ignoreClass,
          ignoreSelector,
          maskTextClass,
          maskTextSelector,
          maskInputOptions,
          inlineStylesheet,
          sampling,
          recordDOM,
          recordCanvas,
          inlineImages,
          userTriggeredOnInput,
          collectFonts,
          doc,
          maskInputFn,
          maskTextFn,
          keepIframeSrcFn,
          blockSelector,
          slimDOMOptions,
          dataURLOptions,
          mirror,
          iframeManager,
          stylesheetManager,
          shadowDomManager,
          processedNodeManager,
          canvasManager,
          ignoreCSSAttributes,
          plugins: ((_a2 = plugins == null ? void 0 : plugins.filter((p) => p.observer)) == null ? void 0 : _a2.map((p) => ({
            observer: p.observer,
            options: p.options,
            callback: (payload) => wrappedEmit({
              type: EventType.Plugin,
              data: {
                plugin: p.name,
                payload
              }
            })
          }))) || []
        },
        hooks
      );
    };
    iframeManager.addLoadListener((iframeEl) => {
      try {
        handlers.push(observe(iframeEl.contentDocument));
      } catch (error) {
        console.warn(error);
      }
    });
    const init = () => {
      takeFullSnapshot$1();
      handlers.push(observe(document));
      recording = true;
    };
    if (document.readyState === "interactive" || document.readyState === "complete") {
      init();
    } else {
      handlers.push(
        on("DOMContentLoaded", () => {
          wrappedEmit({
            type: EventType.DomContentLoaded,
            data: {}
          });
          if (recordAfter === "DOMContentLoaded") init();
        })
      );
      handlers.push(
        on(
          "load",
          () => {
            wrappedEmit({
              type: EventType.Load,
              data: {}
            });
            if (recordAfter === "load") init();
          },
          window
        )
      );
    }
    return () => {
      handlers.forEach((h) => h());
      processedNodeManager.destroy();
      recording = false;
      unregisterErrorHandler();
    };
  } catch (error) {
    console.warn(error);
  }
}
record.addCustomEvent = (tag, payload) => {
  if (!recording) {
    throw new Error("please add custom event after start recording");
  }
  wrappedEmit({
    type: EventType.Custom,
    data: {
      tag,
      payload
    }
  });
};
record.freezePage = () => {
  mutationBuffers.forEach((buf) => buf.freeze());
};
record.takeFullSnapshot = (isCheckout) => {
  if (!recording) {
    throw new Error("please take full snapshot after start recording");
  }
  takeFullSnapshot$1(isCheckout);
};
record.mirror = mirror;
var n;
!function(t2) {
  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
}(n || (n = {}));

//# sourceMappingURL=record.js.map


/***/ }),

/***/ "./node_modules/@rrweb/types/dist/types.js":
/*!*************************************************!*\
  !*** ./node_modules/@rrweb/types/dist/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasContext: () => (/* binding */ CanvasContext),
/* harmony export */   EventType: () => (/* binding */ EventType),
/* harmony export */   IncrementalSource: () => (/* binding */ IncrementalSource),
/* harmony export */   MediaInteractions: () => (/* binding */ MediaInteractions),
/* harmony export */   MouseInteractions: () => (/* binding */ MouseInteractions),
/* harmony export */   NodeType: () => (/* binding */ NodeType),
/* harmony export */   PointerTypes: () => (/* binding */ PointerTypes),
/* harmony export */   ReplayerEvents: () => (/* binding */ ReplayerEvents)
/* harmony export */ });
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType || {});
var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource || {});
var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(MouseInteractions || {});
var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(PointerTypes || {});
var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(CanvasContext || {});
var MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
  MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
  MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
  MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
  MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
  MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
  return MediaInteractions2;
})(MediaInteractions || {});
var ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {
  ReplayerEvents2["Start"] = "start";
  ReplayerEvents2["Pause"] = "pause";
  ReplayerEvents2["Resume"] = "resume";
  ReplayerEvents2["Resize"] = "resize";
  ReplayerEvents2["Finish"] = "finish";
  ReplayerEvents2["FullsnapshotRebuilded"] = "fullsnapshot-rebuilded";
  ReplayerEvents2["LoadStylesheetStart"] = "load-stylesheet-start";
  ReplayerEvents2["LoadStylesheetEnd"] = "load-stylesheet-end";
  ReplayerEvents2["SkipStart"] = "skip-start";
  ReplayerEvents2["SkipEnd"] = "skip-end";
  ReplayerEvents2["MouseInteraction"] = "mouse-interaction";
  ReplayerEvents2["EventCast"] = "event-cast";
  ReplayerEvents2["CustomEvent"] = "custom-event";
  ReplayerEvents2["Flush"] = "flush";
  ReplayerEvents2["StateChange"] = "state-change";
  ReplayerEvents2["PlayBack"] = "play-back";
  ReplayerEvents2["Destroy"] = "destroy";
  return ReplayerEvents2;
})(ReplayerEvents || {});
var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
  return NodeType2;
})(NodeType || {});

//# sourceMappingURL=types.js.map


/***/ }),

/***/ "./node_modules/console-polyfill/index.js":
/*!************************************************!*\
  !*** ./node_modules/console-polyfill/index.js ***!
  \************************************************/
/***/ (function() {

// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function(global) {
  'use strict';
  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function() {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);


/***/ }),

/***/ "./node_modules/error-stack-parser/error-stack-parser.js":
/*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/error-stack-parser/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                    .replace(/<anonymous function(: (\w+))?>/, '$2')
                    .replace(/\([^)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ "./node_modules/error-stack-parser/node_modules/stackframe/stackframe.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/error-stack-parser/node_modules/stackframe/stackframe.js ***!
  \*******************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else // removed by dead control flow
{}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./src/api.js":
/*!********************!*\
  !*** ./src/api.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var helpers = __webpack_require__(/*! ./apiUtility */ "./src/apiUtility.js");
var defaultOptions = {
  hostname: 'api.rollbar.com',
  path: '/api/1/item/',
  search: null,
  version: '1',
  protocol: 'https:',
  port: 443
};
var OTLPDefaultOptions = {
  hostname: 'api.rollbar.com',
  path: '/api/1/session/',
  search: null,
  version: '1',
  protocol: 'https:',
  port: 443
};

/**
 * Api is an object that encapsulates methods of communicating with
 * the Rollbar API.  It is a standard interface with some parts implemented
 * differently for server or browser contexts.  It is an object that should
 * be instantiated when used so it can contain non-global options that may
 * be different for another instance of RollbarApi.
 *
 * @param options {
 *    accessToken: the accessToken to use for posting items to rollbar
 *    endpoint: an alternative endpoint to send errors to
 *        must be a valid, fully qualified URL.
 *        The default is: https://api.rollbar.com/api/1/item
 *    proxy: if you wish to proxy requests provide an object
 *        with the following keys:
 *          host or hostname (required): foo.example.com
 *          port (optional): 123
 *          protocol (optional): https
 * }
 */
function Api(options, transport, urllib, truncation) {
  this.options = options;
  this.transport = transport;
  this.url = urllib;
  this.truncation = truncation;
  this.accessToken = options.accessToken;
  this.transportOptions = _getTransport(options, urllib);
  this.OTLPTransportOptions = _getOTLPTransport(options, urllib);
}

/**
 * Wraps transport.post in a Promise to support async/await
 *
 * @param {Object} options - Options for the API request
 * @param {string} options.accessToken - The access token for authentication
 * @param {Object} options.transportOptions - Options for the transport
 * @param {Object} options.payload - The data payload to send
 * @returns {Promise} A promise that resolves with the response or rejects with an error
 * @private
 */
Api.prototype._postPromise = function (_ref) {
  var accessToken = _ref.accessToken,
    transportOptions = _ref.transportOptions,
    payload = _ref.payload;
  var self = this;
  return new Promise(function (resolve, reject) {
    self.transport.post(accessToken, transportOptions, payload, function (err, resp) {
      return err ? reject(err) : resolve(resp);
    });
  });
};

/**
 *
 * @param data
 * @param callback
 */
Api.prototype.postItem = function (data, callback) {
  var transportOptions = helpers.transportOptions(this.transportOptions, 'POST');
  var payload = helpers.buildPayload(data);
  var self = this;

  // ensure the network request is scheduled after the current tick.
  setTimeout(function () {
    self.transport.post(self.accessToken, transportOptions, payload, callback);
  }, 0);
};

/**
 * Posts spans to the Rollbar API using the session endpoint
 *
 * @param {Array} payload - The spans to send
 * @returns {Promise<Object>} A promise that resolves with the API response
 */
Api.prototype.postSpans = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(payload) {
    var transportOptions;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          transportOptions = helpers.transportOptions(this.OTLPTransportOptions, 'POST');
          _context.next = 3;
          return this._postPromise({
            accessToken: this.accessToken,
            transportOptions: transportOptions,
            payload: payload
          });
        case 3:
          return _context.abrupt("return", _context.sent);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  }));
  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 *
 * @param data
 * @param callback
 */
Api.prototype.buildJsonPayload = function (data, callback) {
  var payload = helpers.buildPayload(data);
  var stringifyResult;
  if (this.truncation) {
    stringifyResult = this.truncation.truncate(payload);
  } else {
    stringifyResult = _.stringify(payload);
  }
  if (stringifyResult.error) {
    if (callback) {
      callback(stringifyResult.error);
    }
    return null;
  }
  return stringifyResult.value;
};

/**
 *
 * @param jsonPayload
 * @param callback
 */
Api.prototype.postJsonPayload = function (jsonPayload, callback) {
  var transportOptions = helpers.transportOptions(this.transportOptions, 'POST');
  this.transport.postJsonPayload(this.accessToken, transportOptions, jsonPayload, callback);
};
Api.prototype.configure = function (options) {
  var oldOptions = this.oldOptions;
  this.options = _.merge(oldOptions, options);
  this.transportOptions = _getTransport(this.options, this.url);
  this.OTLPTransportOptions = _getOTLPTransport(this.options, this.url);
  if (this.options.accessToken !== undefined) {
    this.accessToken = this.options.accessToken;
  }
  return this;
};
function _getTransport(options, url) {
  return helpers.getTransportFromOptions(options, defaultOptions, url);
}
function _getOTLPTransport(options, url) {
  var _options$tracing;
  options = _objectSpread(_objectSpread({}, options), {}, {
    endpoint: (_options$tracing = options.tracing) === null || _options$tracing === void 0 ? void 0 : _options$tracing.endpoint
  });
  return helpers.getTransportFromOptions(options, OTLPDefaultOptions, url);
}
module.exports = Api;

/***/ }),

/***/ "./src/apiUtility.js":
/*!***************************!*\
  !*** ./src/apiUtility.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
function buildPayload(data) {
  if (!_.isType(data.context, 'string')) {
    var contextResult = _.stringify(data.context);
    if (contextResult.error) {
      data.context = "Error: could not serialize 'context'";
    } else {
      data.context = contextResult.value || '';
    }
    if (data.context.length > 255) {
      data.context = data.context.substr(0, 255);
    }
  }
  return {
    data: data
  };
}
function getTransportFromOptions(options, defaults, url) {
  var hostname = defaults.hostname;
  var protocol = defaults.protocol;
  var port = defaults.port;
  var path = defaults.path;
  var search = defaults.search;
  var timeout = options.timeout;
  var transport = detectTransport(options);
  var proxy = options.proxy;
  if (options.endpoint) {
    var opts = url.parse(options.endpoint);
    hostname = opts.hostname;
    protocol = opts.protocol;
    port = opts.port;
    path = opts.pathname;
    search = opts.search;
  }
  return {
    timeout: timeout,
    hostname: hostname,
    protocol: protocol,
    port: port,
    path: path,
    search: search,
    proxy: proxy,
    transport: transport
  };
}
function detectTransport(options) {
  var gWindow = typeof window != 'undefined' && window || typeof self != 'undefined' && self;
  var transport = options.defaultTransport || 'xhr';
  if (typeof gWindow.fetch === 'undefined') transport = 'xhr';
  if (typeof gWindow.XMLHttpRequest === 'undefined') transport = 'fetch';
  return transport;
}
function transportOptions(transport, method) {
  var protocol = transport.protocol || 'https:';
  var port = transport.port || (protocol === 'http:' ? 80 : protocol === 'https:' ? 443 : undefined);
  var hostname = transport.hostname;
  var path = transport.path;
  var timeout = transport.timeout;
  var transportAPI = transport.transport;
  if (transport.search) {
    path = path + transport.search;
  }
  if (transport.proxy) {
    path = protocol + '//' + hostname + path;
    hostname = transport.proxy.host || transport.proxy.hostname;
    port = transport.proxy.port;
    protocol = transport.proxy.protocol || protocol;
  }
  return {
    timeout: timeout,
    protocol: protocol,
    hostname: hostname,
    path: path,
    port: port,
    method: method,
    transport: transportAPI
  };
}
function appendPathToPath(base, path) {
  var baseTrailingSlash = /\/$/.test(base);
  var pathBeginningSlash = /^\//.test(path);
  if (baseTrailingSlash && pathBeginningSlash) {
    path = path.substring(1);
  } else if (!baseTrailingSlash && !pathBeginningSlash) {
    path = '/' + path;
  }
  return base + path;
}
module.exports = {
  buildPayload: buildPayload,
  getTransportFromOptions: getTransportFromOptions,
  transportOptions: transportOptions,
  appendPathToPath: appendPathToPath
};

/***/ }),

/***/ "./src/browser/core.js":
/*!*****************************!*\
  !*** ./src/browser/core.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Client = __webpack_require__(/*! ../rollbar */ "./src/rollbar.js");
var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var API = __webpack_require__(/*! ../api */ "./src/api.js");
var logger = __webpack_require__(/*! ./logger */ "./src/browser/logger.js");
var globals = __webpack_require__(/*! ./globalSetup */ "./src/browser/globalSetup.js");
var Transport = __webpack_require__(/*! ./transport */ "./src/browser/transport.js");
var urllib = __webpack_require__(/*! ./url */ "./src/browser/url.js");
var transforms = __webpack_require__(/*! ./transforms */ "./src/browser/transforms.js");
var sharedTransforms = __webpack_require__(/*! ../transforms */ "./src/transforms.js");
var predicates = __webpack_require__(/*! ./predicates */ "./src/browser/predicates.js");
var sharedPredicates = __webpack_require__(/*! ../predicates */ "./src/predicates.js");
var errorParser = __webpack_require__(/*! ../errorParser */ "./src/errorParser.js");
var recorderDefaults = __webpack_require__(/*! ./replay/defaults */ "./src/browser/replay/defaults.js");
var tracingDefaults = __webpack_require__(/*! ../tracing/defaults */ "./src/tracing/defaults.js");
var ReplayMap = (__webpack_require__(/*! ./replay/replayMap */ "./src/browser/replay/replayMap.js")["default"]);
function Rollbar(options, client) {
  this.options = _.handleOptions(defaultOptions, options, null, logger);
  this.options._configuredOptions = options;
  var Telemeter = this.components.telemeter;
  var Instrumenter = this.components.instrumenter;
  var polyfillJSON = this.components.polyfillJSON;
  this.wrapGlobals = this.components.wrapGlobals;
  this.scrub = this.components.scrub;
  var truncation = this.components.truncation;
  var Tracing = this.components.tracing;
  var Recorder = this.components.recorder;
  var transport = new Transport(truncation);
  var api = new API(this.options, transport, urllib, truncation);
  if (Tracing) {
    this.tracing = new Tracing(_gWindow(), this.options);
    this.tracing.initSession();
  }
  if (Recorder && _.isBrowser()) {
    var recorderOptions = this.options.recorder;
    this.recorder = new Recorder(recorderOptions);
    this.replayMap = new ReplayMap({
      recorder: this.recorder,
      api: api,
      tracing: this.tracing
    });
    if (recorderOptions.enabled && recorderOptions.autoStart) {
      this.recorder.start();
    }
  }
  if (Telemeter) {
    this.telemeter = new Telemeter(this.options, this.tracing);
  }
  this.client = client || new Client(this.options, api, logger, this.telemeter, this.tracing, this.replayMap, 'browser');
  var gWindow = _gWindow();
  var gDocument = typeof document != 'undefined' && document;
  this.isChrome = gWindow.chrome && gWindow.chrome.runtime; // check .runtime to avoid Edge browsers
  this.anonymousErrorsPending = 0;
  addTransformsToNotifier(this.client.notifier, this, gWindow);
  addPredicatesToQueue(this.client.queue);
  this.setupUnhandledCapture();
  if (Instrumenter) {
    this.instrumenter = new Instrumenter(this.options, this.client.telemeter, this, gWindow, gDocument);
    this.instrumenter.instrument();
  }
  _.setupJSON(polyfillJSON);

  // Used with rollbar-react for rollbar-react-native compatibility.
  this.rollbar = this;
}
var _instance = null;
Rollbar.init = function (options, client) {
  if (_instance) {
    return _instance.global(options).configure(options);
  }
  _instance = new Rollbar(options, client);
  return _instance;
};
Rollbar.prototype.components = {};
Rollbar.setComponents = function (components) {
  Rollbar.prototype.components = components;
};
function handleUninitialized(maybeCallback) {
  var message = 'Rollbar is not initialized';
  logger.error(message);
  if (maybeCallback) {
    maybeCallback(new Error(message));
  }
}
Rollbar.prototype.global = function (options) {
  this.client.global(options);
  return this;
};
Rollbar.global = function (options) {
  if (_instance) {
    return _instance.global(options);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.configure = function (options, payloadData) {
  var _this$recorder;
  var oldOptions = this.options;
  var payload = {};
  if (payloadData) {
    payload = {
      payload: payloadData
    };
  }
  this.options = _.handleOptions(oldOptions, options, payload, logger);
  this.options._configuredOptions = _.handleOptions(oldOptions._configuredOptions, options, payload);
  (_this$recorder = this.recorder) === null || _this$recorder === void 0 || _this$recorder.configure(this.options);
  this.client.configure(this.options, payloadData);
  this.instrumenter && this.instrumenter.configure(this.options);
  this.setupUnhandledCapture();
  return this;
};
Rollbar.configure = function (options, payloadData) {
  if (_instance) {
    return _instance.configure(options, payloadData);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.lastError = function () {
  return this.client.lastError;
};
Rollbar.lastError = function () {
  if (_instance) {
    return _instance.lastError();
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.log = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.log(item);
  return {
    uuid: uuid
  };
};
Rollbar.log = function () {
  if (_instance) {
    return _instance.log.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.debug = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.debug(item);
  return {
    uuid: uuid
  };
};
Rollbar.debug = function () {
  if (_instance) {
    return _instance.debug.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.info = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.info(item);
  return {
    uuid: uuid
  };
};
Rollbar.info = function () {
  if (_instance) {
    return _instance.info.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.warn = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.warn(item);
  return {
    uuid: uuid
  };
};
Rollbar.warn = function () {
  if (_instance) {
    return _instance.warn.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.warning = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.warning(item);
  return {
    uuid: uuid
  };
};
Rollbar.warning = function () {
  if (_instance) {
    return _instance.warning.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.error = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.error(item);
  return {
    uuid: uuid
  };
};
Rollbar.error = function () {
  if (_instance) {
    return _instance.error.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.critical = function () {
  var item = this._createItem(arguments);
  var uuid = item.uuid;
  this.client.critical(item);
  return {
    uuid: uuid
  };
};
Rollbar.critical = function () {
  if (_instance) {
    return _instance.critical.apply(_instance, arguments);
  } else {
    var maybeCallback = _getFirstFunction(arguments);
    handleUninitialized(maybeCallback);
  }
};
Rollbar.prototype.buildJsonPayload = function (item) {
  return this.client.buildJsonPayload(item);
};
Rollbar.buildJsonPayload = function () {
  if (_instance) {
    return _instance.buildJsonPayload.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.sendJsonPayload = function (jsonPayload) {
  return this.client.sendJsonPayload(jsonPayload);
};
Rollbar.sendJsonPayload = function () {
  if (_instance) {
    return _instance.sendJsonPayload.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.setupUnhandledCapture = function () {
  var gWindow = _gWindow();
  if (!this.unhandledExceptionsInitialized) {
    if (this.options.captureUncaught || this.options.handleUncaughtExceptions) {
      globals.captureUncaughtExceptions(gWindow, this);
      if (this.wrapGlobals && this.options.wrapGlobalEventHandlers) {
        this.wrapGlobals(gWindow, this);
      }
      this.unhandledExceptionsInitialized = true;
    }
  }
  if (!this.unhandledRejectionsInitialized) {
    if (this.options.captureUnhandledRejections || this.options.handleUnhandledRejections) {
      globals.captureUnhandledRejections(gWindow, this);
      this.unhandledRejectionsInitialized = true;
    }
  }
};
Rollbar.prototype.handleUncaughtException = function (message, url, lineno, colno, error, context) {
  if (!this.options.captureUncaught && !this.options.handleUncaughtExceptions) {
    return;
  }

  // Chrome will always send 5+ arguments and error will be valid or null, not undefined.
  // If error is undefined, we have a different caller.
  // Chrome also sends errors from web workers with null error, but does not invoke
  // prepareStackTrace() for these. Test for empty url to skip them.
  if (this.options.inspectAnonymousErrors && this.isChrome && error === null && url === '') {
    return 'anonymous';
  }
  var item;
  var stackInfo = _.makeUnhandledStackInfo(message, url, lineno, colno, error, 'onerror', 'uncaught exception', errorParser);
  if (_.isError(error)) {
    item = this._createItem([message, error, context]);
    item._unhandledStackInfo = stackInfo;
  } else if (_.isError(url)) {
    item = this._createItem([message, url, context]);
    item._unhandledStackInfo = stackInfo;
  } else {
    item = this._createItem([message, context]);
    item.stackInfo = stackInfo;
  }
  item.level = this.options.uncaughtErrorLevel;
  item._isUncaught = true;
  this.client.log(item);
};

/**
 * Chrome only. Other browsers will ignore.
 *
 * Use Error.prepareStackTrace to extract information about errors that
 * do not have a valid error object in onerror().
 *
 * In tested version of Chrome, onerror is called first but has no way
 * to communicate with prepareStackTrace. Use a counter to let this
 * handler know which errors to send to Rollbar.
 *
 * In config options, set inspectAnonymousErrors to enable.
 */
Rollbar.prototype.handleAnonymousErrors = function () {
  if (!this.options.inspectAnonymousErrors || !this.isChrome) {
    return;
  }
  var r = this;
  function prepareStackTrace(error, _stack) {
    if (r.options.inspectAnonymousErrors) {
      if (r.anonymousErrorsPending) {
        // This is the only known way to detect that onerror saw an anonymous error.
        // It depends on onerror reliably being called before Error.prepareStackTrace,
        // which so far holds true on tested versions of Chrome. If versions of Chrome
        // are tested that behave differently, this logic will need to be updated
        // accordingly.
        r.anonymousErrorsPending -= 1;
        if (!error) {
          // Not likely to get here, but calling handleUncaughtException from here
          // without an error object would throw off the anonymousErrorsPending counter,
          // so return now.
          return;
        }

        // Allow this to be tracked later.
        error._isAnonymous = true;

        // url, lineno, colno shouldn't be needed for these errors.
        // If that changes, update this accordingly, using the unused
        // _stack param as needed (rather than parse error.toString()).
        r.handleUncaughtException(error.message, null, null, null, error);
      }
    }

    // Workaround to ensure stack is preserved for normal errors.
    return error.stack;
  }

  // https://v8.dev/docs/stack-trace-api
  try {
    Error.prepareStackTrace = prepareStackTrace;
  } catch (e) {
    this.options.inspectAnonymousErrors = false;
    this.error('anonymous error handler failed', e);
  }
};
Rollbar.prototype.handleUnhandledRejection = function (reason, promise) {
  if (!this.options.captureUnhandledRejections && !this.options.handleUnhandledRejections) {
    return;
  }
  var message = 'unhandled rejection was null or undefined!';
  if (reason) {
    if (reason.message) {
      message = reason.message;
    } else {
      var reasonResult = _.stringify(reason);
      if (reasonResult.value) {
        message = reasonResult.value;
      }
    }
  }
  var context = reason && reason._rollbarContext || promise && promise._rollbarContext;
  var item;
  if (_.isError(reason)) {
    item = this._createItem([message, reason, context]);
  } else {
    item = this._createItem([message, reason, context]);
    item.stackInfo = _.makeUnhandledStackInfo(message, '', 0, 0, null, 'unhandledrejection', '', errorParser);
  }
  item.level = this.options.uncaughtErrorLevel;
  item._isUncaught = true;
  item._originalArgs = item._originalArgs || [];
  item._originalArgs.push(promise);
  this.client.log(item);
};
Rollbar.prototype.wrap = function (f, context, _before) {
  try {
    var ctxFn;
    if (_.isFunction(context)) {
      ctxFn = context;
    } else {
      ctxFn = function ctxFn() {
        return context || {};
      };
    }
    if (!_.isFunction(f)) {
      return f;
    }
    if (f._isWrap) {
      return f;
    }
    if (!f._rollbar_wrapped) {
      f._rollbar_wrapped = function () {
        if (_before && _.isFunction(_before)) {
          _before.apply(this, arguments);
        }
        try {
          return f.apply(this, arguments);
        } catch (exc) {
          var e = exc;
          if (e && window._rollbarWrappedError !== e) {
            if (_.isType(e, 'string')) {
              e = new String(e);
            }
            e._rollbarContext = ctxFn() || {};
            e._rollbarContext._wrappedSource = f.toString();
            window._rollbarWrappedError = e;
          }
          throw e;
        }
      };
      f._rollbar_wrapped._isWrap = true;
      if (f.hasOwnProperty) {
        for (var prop in f) {
          if (f.hasOwnProperty(prop) && prop !== '_rollbar_wrapped') {
            f._rollbar_wrapped[prop] = f[prop];
          }
        }
      }
    }
    return f._rollbar_wrapped;
  } catch (e) {
    // Return the original function if the wrap fails.
    return f;
  }
};
Rollbar.wrap = function (f, context) {
  if (_instance) {
    return _instance.wrap(f, context);
  } else {
    handleUninitialized();
  }
};
Rollbar.prototype.captureEvent = function () {
  var event = _.createTelemetryEvent(arguments);
  return this.client.captureEvent(event.type, event.metadata, event.level);
};
Rollbar.captureEvent = function () {
  if (_instance) {
    return _instance.captureEvent.apply(_instance, arguments);
  } else {
    handleUninitialized();
  }
};

// The following two methods are used internally and are not meant for public use
Rollbar.prototype.captureDomContentLoaded = function (e, ts) {
  if (!ts) {
    ts = new Date();
  }
  return this.client.captureDomContentLoaded(ts);
};
Rollbar.prototype.captureLoad = function (e, ts) {
  if (!ts) {
    ts = new Date();
  }
  return this.client.captureLoad(ts);
};

/* Internal */

function addTransformsToNotifier(notifier, rollbar, gWindow) {
  notifier.addTransform(transforms.handleDomException).addTransform(transforms.handleItemWithError).addTransform(transforms.ensureItemHasSomethingToSay).addTransform(transforms.addBaseInfo).addTransform(transforms.addRequestInfo(gWindow)).addTransform(transforms.addClientInfo(gWindow)).addTransform(transforms.addPluginInfo(gWindow)).addTransform(transforms.addBody).addTransform(sharedTransforms.addMessageWithError).addTransform(sharedTransforms.addTelemetryData).addTransform(sharedTransforms.addConfigToPayload).addTransform(transforms.addScrubber(rollbar.scrub)).addTransform(sharedTransforms.addPayloadOptions).addTransform(sharedTransforms.userTransform(logger)).addTransform(sharedTransforms.addConfiguredOptions).addTransform(sharedTransforms.addDiagnosticKeys).addTransform(sharedTransforms.itemToPayload);
}
function addPredicatesToQueue(queue) {
  queue.addPredicate(sharedPredicates.checkLevel).addPredicate(predicates.checkIgnore).addPredicate(sharedPredicates.userCheckIgnore(logger)).addPredicate(sharedPredicates.urlIsNotBlockListed(logger)).addPredicate(sharedPredicates.urlIsSafeListed(logger)).addPredicate(sharedPredicates.messageIsIgnored(logger));
}
Rollbar.prototype.loadFull = function () {
  logger.info('Unexpected Rollbar.loadFull() called on a Notifier instance. This can happen when Rollbar is loaded multiple times.');
};
Rollbar.prototype._createItem = function (args) {
  return _.createItem(args, logger, this);
};
function _getFirstFunction(args) {
  for (var i = 0, len = args.length; i < len; ++i) {
    if (_.isFunction(args[i])) {
      return args[i];
    }
  }
  return undefined;
}
function _gWindow() {
  return typeof window != 'undefined' && window || typeof self != 'undefined' && self;
}
var defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");
var scrubFields = __webpack_require__(/*! ./defaults/scrubFields */ "./src/browser/defaults/scrubFields.js");
var defaultOptions = {
  version: defaults.version,
  scrubFields: scrubFields.scrubFields,
  logLevel: defaults.logLevel,
  reportLevel: defaults.reportLevel,
  uncaughtErrorLevel: defaults.uncaughtErrorLevel,
  endpoint: defaults.endpoint,
  verbose: false,
  enabled: true,
  transmit: true,
  sendConfig: false,
  includeItemsInTelemetry: true,
  captureIp: true,
  inspectAnonymousErrors: true,
  ignoreDuplicateErrors: true,
  wrapGlobalEventHandlers: false,
  recorder: recorderDefaults,
  tracing: tracingDefaults
};
module.exports = Rollbar;

/***/ }),

/***/ "./src/browser/defaults/scrubFields.js":
/*!*********************************************!*\
  !*** ./src/browser/defaults/scrubFields.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = {
  scrubFields: ['pw', 'pass', 'passwd', 'password', 'secret', 'confirm_password', 'confirmPassword', 'password_confirmation', 'passwordConfirmation', 'access_token', 'accessToken', 'X-Rollbar-Access-Token', 'secret_key', 'secretKey', 'secretToken', 'cc-number', 'card number', 'cardnumber', 'cardnum', 'ccnum', 'ccnumber', 'cc num', 'creditcardnumber', 'credit card number', 'newcreditcardnumber', 'new credit card', 'creditcardno', 'credit card no', 'card#', 'card #', 'cc-csc', 'cvc', 'cvc2', 'cvv2', 'ccv2', 'security code', 'card verification', 'name on credit card', 'name on card', 'nameoncard', 'cardholder', 'card holder', 'name des karteninhabers', 'ccname', 'card type', 'cardtype', 'cc type', 'cctype', 'payment type', 'expiration date', 'expirationdate', 'expdate', 'cc-exp', 'ccmonth', 'ccyear']
};

/***/ }),

/***/ "./src/browser/detection.js":
/*!**********************************!*\
  !*** ./src/browser/detection.js ***!
  \**********************************/
/***/ ((module) => {

// This detection.js module is used to encapsulate any ugly browser/feature
// detection we may need to do.

// Figure out which version of IE we're using, if any.
// This is gleaned from http://stackoverflow.com/questions/5574842/best-way-to-check-for-ie-less-than-9-in-javascript-without-library
// Will return an integer on IE (i.e. 8)
// Will return undefined otherwise
function getIEVersion() {
  var undef;
  if (typeof document === 'undefined') {
    return undef;
  }
  var v = 3,
    div = document.createElement('div'),
    all = div.getElementsByTagName('i');
  while (div.innerHTML = '<!--[if gt IE ' + ++v + ']><i></i><![endif]-->', all[0]);
  return v > 4 ? v : undef;
}
var Detection = {
  ieVersion: getIEVersion
};
module.exports = Detection;

/***/ }),

/***/ "./src/browser/domUtility.js":
/*!***********************************!*\
  !*** ./src/browser/domUtility.js ***!
  \***********************************/
/***/ ((module) => {

function getElementType(e) {
  return (e.getAttribute('type') || '').toLowerCase();
}
function isDescribedElement(element, type, subtypes) {
  if (element.tagName.toLowerCase() !== type.toLowerCase()) {
    return false;
  }
  if (!subtypes) {
    return true;
  }
  element = getElementType(element);
  for (var i = 0; i < subtypes.length; i++) {
    if (subtypes[i] === element) {
      return true;
    }
  }
  return false;
}
function getElementFromEvent(evt, doc) {
  if (evt.target) {
    return evt.target;
  }
  if (doc && doc.elementFromPoint) {
    return doc.elementFromPoint(evt.clientX, evt.clientY);
  }
  return undefined;
}
function treeToArray(elem) {
  var MAX_HEIGHT = 5;
  var out = [];
  var nextDescription;
  for (var height = 0; elem && height < MAX_HEIGHT; height++) {
    nextDescription = describeElement(elem);
    if (nextDescription.tagName === 'html') {
      break;
    }
    out.unshift(nextDescription);
    elem = elem.parentNode;
  }
  return out;
}
function elementArrayToString(a) {
  var MAX_LENGTH = 80;
  var separator = ' > ',
    separatorLength = separator.length;
  var out = [],
    len = 0,
    nextStr,
    totalLength;
  for (var i = a.length - 1; i >= 0; i--) {
    nextStr = descriptionToString(a[i]);
    totalLength = len + out.length * separatorLength + nextStr.length;
    if (i < a.length - 1 && totalLength >= MAX_LENGTH + 3) {
      out.unshift('...');
      break;
    }
    out.unshift(nextStr);
    len += nextStr.length;
  }
  return out.join(separator);
}
function descriptionToString(desc) {
  if (!desc || !desc.tagName) {
    return '';
  }
  var out = [desc.tagName];
  if (desc.id) {
    out.push('#' + desc.id);
  }
  if (desc.classes) {
    out.push('.' + desc.classes.join('.'));
  }
  for (var i = 0; i < desc.attributes.length; i++) {
    out.push('[' + desc.attributes[i].key + '="' + desc.attributes[i].value + '"]');
  }
  return out.join('');
}

/**
 * Input: a dom element
 * Output: null if tagName is falsey or input is falsey, else
 *  {
 *    tagName: String,
 *    id: String | undefined,
 *    classes: [String] | undefined,
 *    attributes: [
 *      {
 *        key: OneOf(type, name, title, alt),
 *        value: String
 *      }
 *    ]
 *  }
 */
function describeElement(elem) {
  if (!elem || !elem.tagName) {
    return null;
  }
  var out = {},
    className,
    key,
    attr,
    i;
  out.tagName = elem.tagName.toLowerCase();
  if (elem.id) {
    out.id = elem.id;
  }
  className = elem.className;
  if (className && typeof className === 'string') {
    out.classes = className.split(/\s+/);
  }
  var attributes = ['type', 'name', 'title', 'alt'];
  out.attributes = [];
  for (i = 0; i < attributes.length; i++) {
    key = attributes[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.attributes.push({
        key: key,
        value: attr
      });
    }
  }
  return out;
}
module.exports = {
  describeElement: describeElement,
  descriptionToString: descriptionToString,
  elementArrayToString: elementArrayToString,
  treeToArray: treeToArray,
  getElementFromEvent: getElementFromEvent,
  isDescribedElement: isDescribedElement,
  getElementType: getElementType
};

/***/ }),

/***/ "./src/browser/globalSetup.js":
/*!************************************!*\
  !*** ./src/browser/globalSetup.js ***!
  \************************************/
/***/ ((module) => {

function captureUncaughtExceptions(window, handler, shim) {
  if (!window) {
    return;
  }
  var oldOnError;
  if (typeof handler._rollbarOldOnError === 'function') {
    oldOnError = handler._rollbarOldOnError;
  } else if (window.onerror) {
    oldOnError = window.onerror;
    while (oldOnError._rollbarOldOnError) {
      oldOnError = oldOnError._rollbarOldOnError;
    }
    handler._rollbarOldOnError = oldOnError;
  }
  handler.handleAnonymousErrors();
  var fn = function fn() {
    var args = Array.prototype.slice.call(arguments, 0);
    _rollbarWindowOnError(window, handler, oldOnError, args);
  };
  if (shim) {
    fn._rollbarOldOnError = oldOnError;
  }
  window.onerror = fn;
}
function _rollbarWindowOnError(window, r, old, args) {
  if (window._rollbarWrappedError) {
    if (!args[4]) {
      args[4] = window._rollbarWrappedError;
    }
    if (!args[5]) {
      args[5] = window._rollbarWrappedError._rollbarContext;
    }
    window._rollbarWrappedError = null;
  }
  var ret = r.handleUncaughtException.apply(r, args);
  if (old) {
    old.apply(window, args);
  }

  // Let other chained onerror handlers above run before setting this.
  // If an error is thrown and caught within a chained onerror handler,
  // Error.prepareStackTrace() will see that one before the one we want.
  if (ret === 'anonymous') {
    r.anonymousErrorsPending += 1; // See Rollbar.prototype.handleAnonymousErrors()
  }
}
function captureUnhandledRejections(window, handler, shim) {
  if (!window) {
    return;
  }
  if (typeof window._rollbarURH === 'function' && window._rollbarURH.belongsToShim) {
    window.removeEventListener('unhandledrejection', window._rollbarURH);
  }
  var rejectionHandler = function rejectionHandler(evt) {
    var reason, promise, detail;
    try {
      reason = evt.reason;
    } catch (e) {
      reason = undefined;
    }
    try {
      promise = evt.promise;
    } catch (e) {
      promise = '[unhandledrejection] error getting `promise` from event';
    }
    try {
      detail = evt.detail;
      if (!reason && detail) {
        reason = detail.reason;
        promise = detail.promise;
      }
    } catch (e) {
      // Ignore
    }
    if (!reason) {
      reason = '[unhandledrejection] error getting `reason` from event';
    }
    if (handler && handler.handleUnhandledRejection) {
      handler.handleUnhandledRejection(reason, promise);
    }
  };
  rejectionHandler.belongsToShim = shim;
  window._rollbarURH = rejectionHandler;
  window.addEventListener('unhandledrejection', rejectionHandler);
}
module.exports = {
  captureUncaughtExceptions: captureUncaughtExceptions,
  captureUnhandledRejections: captureUnhandledRejections
};

/***/ }),

/***/ "./src/browser/logger.js":
/*!*******************************!*\
  !*** ./src/browser/logger.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-console */
__webpack_require__(/*! console-polyfill */ "./node_modules/console-polyfill/index.js");
var detection = __webpack_require__(/*! ./detection */ "./src/browser/detection.js");
var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
function error() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.error(_.formatArgsAsString(args));
  } else {
    console.error.apply(console, args);
  }
}
function info() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.info(_.formatArgsAsString(args));
  } else {
    console.info.apply(console, args);
  }
}
function log() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift('Rollbar:');
  if (detection.ieVersion() <= 8) {
    console.log(_.formatArgsAsString(args));
  } else {
    console.log.apply(console, args);
  }
}

/* eslint-enable no-console */

module.exports = {
  error: error,
  info: info,
  log: log
};

/***/ }),

/***/ "./src/browser/predicates.js":
/*!***********************************!*\
  !*** ./src/browser/predicates.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
function checkIgnore(item, settings) {
  if (_.get(settings, 'plugins.jquery.ignoreAjaxErrors')) {
    return !_.get(item, 'body.message.extra.isAjax');
  }
  return true;
}
module.exports = {
  checkIgnore: checkIgnore
};

/***/ }),

/***/ "./src/browser/replay/defaults.js":
/*!****************************************!*\
  !*** ./src/browser/replay/defaults.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Default options for the rrweb recorder
 * See https://github.com/rrweb-io/rrweb/blob/master/guide.md#options for details
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  enabled: false,
  // Whether recording is enabled
  autoStart: true,
  // Start recording automatically when Rollbar initializes
  debug: {
    logEmits: false // Whether to log emitted events
  },
  // Recording options
  inlineStylesheet: true,
  // Whether to inline stylesheets to improve replay accuracy
  inlineImages: false,
  // Whether to record the image content
  collectFonts: true,
  // Whether to collect fonts in the website

  // Privacy options
  // Fine-grained control over which input types to mask
  // By default only password inputs are masked if maskInputs is true
  maskInputOptions: {
    password: true,
    email: false,
    tel: false,
    text: false,
    color: false,
    date: false,
    'datetime-local': false,
    month: false,
    number: false,
    range: false,
    search: false,
    time: false,
    url: false,
    week: false
  },
  // Remove unnecessary parts of the DOM
  // By default all removable elements are removed
  slimDOMOptions: {
    script: true,
    // Remove script elements
    comment: true,
    // Remove comments
    headFavicon: true,
    // Remove favicons in the head
    headWhitespace: true,
    // Remove whitespace in head
    headMetaDescKeywords: true,
    // Remove meta description and keywords
    headMetaSocial: true,
    // Remove social media meta tags
    headMetaRobots: true,
    // Remove robots meta directives
    headMetaHttpEquiv: true,
    // Remove http-equiv meta directives
    headMetaAuthorship: true,
    // Remove authorship meta directives
    headMetaVerification: true // Remove verification meta directives
  }

  // Custom callbacks for advanced use cases
  // These are undefined by default and can be set programmatically
  // maskInputFn: undefined,      // Custom function to mask input values
  // maskTextFn: undefined,       // Custom function to mask text content
  // errorHandler: undefined,     // Custom error handler for recording errors

  // Plugin system
  // plugins: []                  // List of plugins to use (must be set programmatically)
});

/***/ }),

/***/ "./src/browser/replay/recorder.js":
/*!****************************************!*\
  !*** ./src/browser/replay/recorder.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Recorder)
/* harmony export */ });
/* harmony import */ var _rrweb_record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rrweb/record */ "./node_modules/@rrweb/record/dist/record.js");
/* harmony import */ var _rrweb_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rrweb/types */ "./node_modules/@rrweb/types/dist/types.js");
/* harmony import */ var _tracing_hrtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tracing/hrtime.js */ "./src/tracing/hrtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _options = /*#__PURE__*/new WeakMap();
var _stopFn = /*#__PURE__*/new WeakMap();
var _recordFn = /*#__PURE__*/new WeakMap();
var _events = /*#__PURE__*/new WeakMap();
var Recorder = /*#__PURE__*/function () {
  /**
   * Creates a new Recorder instance for capturing DOM events
   *
   * @param {Object} options - Configuration options for the recorder
   * @param {Function} [recordFn=rrwebRecordFn] - The recording function to use
   */
  function Recorder(options) {
    var recordFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _rrweb_record__WEBPACK_IMPORTED_MODULE_0__.record;
    _classCallCheck(this, Recorder);
    _classPrivateFieldInitSpec(this, _options, void 0);
    _classPrivateFieldInitSpec(this, _stopFn, null);
    _classPrivateFieldInitSpec(this, _recordFn, void 0);
    _classPrivateFieldInitSpec(this, _events, {
      previous: [],
      current: []
    });
    if (!recordFn) {
      throw new TypeError("Expected 'recordFn' to be provided");
    }
    console.log('Recorder: Initializing...');
    console.log('options', options);
    _classPrivateFieldSet(_options, this, options !== null && options !== void 0 ? options : {});
    _classPrivateFieldSet(_recordFn, this, recordFn);
  }
  return _createClass(Recorder, [{
    key: "isRecording",
    get: function get() {
      return _classPrivateFieldGet(_stopFn, this) !== null;
    }
  }, {
    key: "options",
    get: function get() {
      return _classPrivateFieldGet(_options, this);
    },
    set: function set(newOptions) {
      this.configure(newOptions);
    }
  }, {
    key: "configure",
    value: function configure(newOptions) {
      if (this.isRecording && newOptions.enabled === false) {
        this.stop();
      }
      _classPrivateFieldSet(_options, this, newOptions);
    }

    /**
     * Converts recorded events into a formatted payload ready for transport.
     *
     * This method takes the recorder's stored events, creates a new span with the
     * provided tracing context, attaches all events with their timestamps as span
     * events, and then returns a payload ready for transport to the server.
     *
     * @param {Object} tracing - The tracing system instance to create spans
     * @param {string} replayId - Unique identifier to associate with this replay recording
     * @returns {Object|null} A formatted payload containing spans data in OTLP format, or null if no events exist
     */
  }, {
    key: "dump",
    value: function dump(tracing, replayId, occurrenceUuid) {
      var events = _classPrivateFieldGet(_events, this).previous.concat(_classPrivateFieldGet(_events, this).current);
      if (events.length < 2) {
        console.warn("Recorder.dump: Min 2 events req. Found ".concat(events.length));
        return null;
      }
      console.log("Recorder.dump: Dumping ".concat(events.length, " events"));
      var recordingSpan = tracing.startSpan('rrweb-replay-recording', {});
      recordingSpan.setAttribute('rollbar.replay.id', replayId);
      if (occurrenceUuid) {
        recordingSpan.setAttribute('rollbar.occurrence.uuid', occurrenceUuid);
      }
      var earliestEvent = events.reduce(function (earliestEvent, event) {
        return event.timestamp < earliestEvent.timestamp ? event : earliestEvent;
      });
      recordingSpan.span.startTime = _tracing_hrtime_js__WEBPACK_IMPORTED_MODULE_2__["default"].fromMillis(earliestEvent.timestamp);
      var _iterator = _createForOfIteratorHelper(events),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var event = _step.value;
          recordingSpan.addEvent('rrweb-replay-events', {
            eventType: event.type,
            json: JSON.stringify(event.data),
            'rollbar.replay.id': replayId
          }, _tracing_hrtime_js__WEBPACK_IMPORTED_MODULE_2__["default"].fromMillis(event.timestamp));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      recordingSpan.end();
      return tracing.exporter.toPayload();
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;
      if (this.isRecording || this.options.enabled === false) {
        if (this.isRecording) {
          console.log('Recorder: Already started');
        } else {
          console.log('Recorder: Disabled');
        }
        return;
      }
      console.log('Recorder: Starting...');
      this.clear();
      _classPrivateFieldSet(_stopFn, this, _classPrivateFieldGet(_recordFn, this).call(this, _objectSpread({
        emit: function emit(event, isCheckout) {
          var _this$options$debug;
          if ((_this$options$debug = _this.options.debug) !== null && _this$options$debug !== void 0 && _this$options$debug.logEmits) {
            _this._logEvent(event, isCheckout);
          }
          if (isCheckout && event.type === _rrweb_types__WEBPACK_IMPORTED_MODULE_1__.EventType.Meta) {
            _classPrivateFieldGet(_events, _this).previous = _classPrivateFieldGet(_events, _this).current;
            _classPrivateFieldGet(_events, _this).current = [];
          }
          _classPrivateFieldGet(_events, _this).current.push(event);
        },
        checkoutEveryNms: 5 * 60 * 1000
      }, this.options)));
      console.log('Recorder: Started');
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.isRecording) {
        console.log('Recorder: Already stopped');
        return;
      }
      console.log('Recorder: Stopping...');
      _classPrivateFieldGet(_stopFn, this).call(this);
      _classPrivateFieldSet(_stopFn, this, null);
      console.log('Recorder: Stopped');
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldSet(_events, this, {
        previous: [],
        current: []
      });
    }
  }, {
    key: "_logEvent",
    value: function _logEvent(event, isCheckout) {
      console.log("Recorder: ".concat(isCheckout ? 'checkout' : '', " event\n"), function (e) {
        var seen = new WeakSet();
        return JSON.stringify(e, function (_, v) {
          if (_typeof(v) === 'object' && v !== null) {
            if (seen.has(v)) return '[Circular]';
            seen.add(v);
          }
          return v;
        }, 2);
      }(event));
    }
  }]);
}();


/***/ }),

/***/ "./src/browser/replay/replayMap.js":
/*!*****************************************!*\
  !*** ./src/browser/replay/replayMap.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReplayMap)
/* harmony export */ });
/* harmony import */ var _tracing_id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tracing/id.js */ "./src/tracing/id.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }


/**
 * ReplayMap - Manages the mapping between error occurrences and their associated
 * session recordings. This class handles the coordination between when recordings
 * are dumped and when they are eventually sent to the backend.
 */
var _map = /*#__PURE__*/new WeakMap();
var _recorder = /*#__PURE__*/new WeakMap();
var _api = /*#__PURE__*/new WeakMap();
var _tracing = /*#__PURE__*/new WeakMap();
var ReplayMap = /*#__PURE__*/function () {
  /**
   * Creates a new ReplayMap instance
   *
   * @param {Object} props - Configuration props
   * @param {Object} props.recorder - The recorder instance that dumps replay data into spans
   * @param {Object} props.api - The API instance used to send replay payloads to the backend
   * @param {Object} props.tracing - The tracing instance used to create spans and manage context
   */
  function ReplayMap(_ref) {
    var recorder = _ref.recorder,
      api = _ref.api,
      tracing = _ref.tracing;
    _classCallCheck(this, ReplayMap);
    _classPrivateFieldInitSpec(this, _map, void 0);
    _classPrivateFieldInitSpec(this, _recorder, void 0);
    _classPrivateFieldInitSpec(this, _api, void 0);
    _classPrivateFieldInitSpec(this, _tracing, void 0);
    if (!recorder) {
      throw new TypeError("Expected 'recorder' to be provided");
    }
    if (!api) {
      throw new TypeError("Expected 'api' to be provided");
    }
    if (!tracing) {
      throw new TypeError("Expected 'tracing' to be provided");
    }
    _classPrivateFieldSet(_map, this, new Map());
    _classPrivateFieldSet(_recorder, this, recorder);
    _classPrivateFieldSet(_api, this, api);
    _classPrivateFieldSet(_tracing, this, tracing);
  }

  /**
   * Processes a replay by converting recorder events into a transport-ready payload.
   *
   * Calls recorder.dump() to capture events as spans, formats them into a proper payload,
   * and stores the result in the map using replayId as the key.
   *
   * @param {string} replayId - The unique ID for this replay
   * @returns {Promise<string>} A promise resolving to the processed replayId
   * @private
   */
  return _createClass(ReplayMap, [{
    key: "_processReplay",
    value: (function () {
      var _processReplay2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(replayId, occurrenceUuid) {
        var payload;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              try {
                payload = _classPrivateFieldGet(_recorder, this).dump(_classPrivateFieldGet(_tracing, this), replayId, occurrenceUuid);
                _classPrivateFieldGet(_map, this).set(replayId, payload);
              } catch (transformError) {
                console.error('Error transforming spans:', transformError);
                _classPrivateFieldGet(_map, this).set(replayId, null); // TODO(matux): Error span?
              }
              return _context.abrupt("return", replayId);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _processReplay(_x, _x2) {
        return _processReplay2.apply(this, arguments);
      }
      return _processReplay;
    }()
    /**
     * Adds a replay to the map and returns a uniquely generated replay ID.
     *
     * This method immediately returns the replayId and asynchronously processes
     * the replay data in the background. The processing involves converting
     * recorder events into a payload format and storing it in the map.
     *
     * @returns {string} A unique identifier for this replay
     */
    )
  }, {
    key: "add",
    value: function add(occurrenceUuid) {
      var replayId = _tracing_id_js__WEBPACK_IMPORTED_MODULE_0__["default"].gen(8);
      this._processReplay(replayId, occurrenceUuid)["catch"](function (error) {
        console.error('Failed to process replay:', error);
      });
      return replayId;
    }

    /**
     * Sends the replay payload associated with the given replayId to the backend
     * and removes it from the map.
     *
     * Retrieves the payload from the map, checks if it's valid, then sends it
     * to the API endpoint for processing. The payload can be either a spans array
     * or a formatted OTLP payload object.
     *
     * @param {string} replayId - The ID of the replay to send
     * @returns {Promise<boolean>} A promise that resolves to true if the payload was found and sent, false otherwise
     */
  }, {
    key: "send",
    value: (function () {
      var _send = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(replayId) {
        var payload, isEmpty;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (replayId) {
                _context2.next = 3;
                break;
              }
              console.warn('ReplayMap.send: No replayId provided');
              return _context2.abrupt("return", false);
            case 3:
              if (_classPrivateFieldGet(_map, this).has(replayId)) {
                _context2.next = 6;
                break;
              }
              console.warn("ReplayMap.send: No replay found for replayId: ".concat(replayId));
              return _context2.abrupt("return", false);
            case 6:
              payload = _classPrivateFieldGet(_map, this).get(replayId);
              _classPrivateFieldGet(_map, this)["delete"](replayId);

              // Check if payload is empty (could be raw spans array or OTLP payload)
              isEmpty = !payload || Array.isArray(payload) && payload.length === 0 || payload.resourceSpans && payload.resourceSpans.length === 0;
              if (!isEmpty) {
                _context2.next = 12;
                break;
              }
              console.warn("ReplayMap.send: No payload found for replayId: ".concat(replayId));
              return _context2.abrupt("return", false);
            case 12:
              _context2.prev = 12;
              _context2.next = 15;
              return _classPrivateFieldGet(_api, this).postSpans(payload);
            case 15:
              return _context2.abrupt("return", true);
            case 18:
              _context2.prev = 18;
              _context2.t0 = _context2["catch"](12);
              console.error('Error sending replay:', _context2.t0);
              return _context2.abrupt("return", false);
            case 22:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[12, 18]]);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
    /**
     * Discards the replay associated with the given replay ID by removing
     * it from the map without sending it.
     *
     * @param {string} replayId - The ID of the replay to discard
     * @returns {boolean} True if a replay was found and discarded, false otherwise
     */
    )
  }, {
    key: "discard",
    value: function discard(replayId) {
      if (!replayId) {
        console.warn('ReplayMap.discard: No replayId provided');
        return false;
      }
      if (!_classPrivateFieldGet(_map, this).has(replayId)) {
        console.warn("ReplayMap.discard: No replay found for replayId: ".concat(replayId));
        return false;
      }
      _classPrivateFieldGet(_map, this)["delete"](replayId);
      return true;
    }

    /**
     * Gets spans for the given replay ID
     *
     * @param {string} replayId - The ID to retrieve spans for
     * @returns {Array|null} The spans array or null if not found
     */
  }, {
    key: "getSpans",
    value: function getSpans(replayId) {
      var _classPrivateFieldGet2;
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_map, this).get(replayId)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
    }

    /**
     * Sets spans for a given replay ID
     *
     * @param {string} replayId - The ID to set spans for
     * @param {Array} spans - The spans to set
     */
  }, {
    key: "setSpans",
    value: function setSpans(replayId, spans) {
      _classPrivateFieldGet(_map, this).set(replayId, spans);
    }

    /**
     * Returns the size of the map (number of stored replays)
     *
     * @returns {number} The number of replays currently stored
     */
  }, {
    key: "size",
    get: function get() {
      return _classPrivateFieldGet(_map, this).size;
    }

    /**
     * Clears all stored replays without sending them
     */
  }, {
    key: "clear",
    value: function clear() {
      _classPrivateFieldGet(_map, this).clear();
    }
  }]);
}();


/***/ }),

/***/ "./src/browser/rollbar.js":
/*!********************************!*\
  !*** ./src/browser/rollbar.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Rollbar = __webpack_require__(/*! ./core */ "./src/browser/core.js");
var telemeter = __webpack_require__(/*! ../telemetry */ "./src/telemetry.js");
var instrumenter = __webpack_require__(/*! ./telemetry */ "./src/browser/telemetry.js");
var polyfillJSON = __webpack_require__(/*! ../utility/polyfillJSON */ "./src/utility/polyfillJSON.js");
var wrapGlobals = __webpack_require__(/*! ./wrapGlobals */ "./src/browser/wrapGlobals.js");
var scrub = __webpack_require__(/*! ../scrub */ "./src/scrub.js");
var truncation = __webpack_require__(/*! ../truncation */ "./src/truncation.js");
var Tracing = __webpack_require__(/*! ../tracing/tracing */ "./src/tracing/tracing.js");
var Recorder = __webpack_require__(/*! ./replay/recorder */ "./src/browser/replay/recorder.js");
Rollbar.setComponents({
  telemeter: telemeter,
  instrumenter: instrumenter,
  polyfillJSON: polyfillJSON,
  wrapGlobals: wrapGlobals,
  scrub: scrub,
  truncation: truncation,
  tracing: Tracing["default"],
  recorder: Recorder["default"]
});
module.exports = Rollbar;

/***/ }),

/***/ "./src/browser/telemetry.js":
/*!**********************************!*\
  !*** ./src/browser/telemetry.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var headers = __webpack_require__(/*! ../utility/headers */ "./src/utility/headers.js");
var replace = __webpack_require__(/*! ../utility/replace */ "./src/utility/replace.js");
var scrub = __webpack_require__(/*! ../scrub */ "./src/scrub.js");
var urlparser = __webpack_require__(/*! ./url */ "./src/browser/url.js");
var domUtil = __webpack_require__(/*! ./domUtility */ "./src/browser/domUtility.js");
var defaults = {
  network: true,
  networkResponseHeaders: false,
  networkResponseBody: false,
  networkRequestHeaders: false,
  networkRequestBody: false,
  networkErrorOnHttp5xx: false,
  networkErrorOnHttp4xx: false,
  networkErrorOnHttp0: false,
  log: true,
  dom: true,
  navigation: true,
  connectivity: true,
  contentSecurityPolicy: true,
  errorOnContentSecurityPolicy: false
};
function restore(replacements, type) {
  var b;
  while (replacements[type].length) {
    b = replacements[type].shift();
    b[0][b[1]] = b[2];
  }
}
function nameFromDescription(description) {
  if (!description || !description.attributes) {
    return null;
  }
  var attrs = description.attributes;
  for (var a = 0; a < attrs.length; ++a) {
    if (attrs[a].key === 'name') {
      return attrs[a].value;
    }
  }
  return null;
}
function defaultValueScrubber(scrubFields) {
  var patterns = [];
  for (var i = 0; i < scrubFields.length; ++i) {
    patterns.push(new RegExp(scrubFields[i], 'i'));
  }
  return function (description) {
    var name = nameFromDescription(description);
    if (!name) {
      return false;
    }
    for (var i = 0; i < patterns.length; ++i) {
      if (patterns[i].test(name)) {
        return true;
      }
    }
    return false;
  };
}
function Instrumenter(options, telemeter, rollbar, _window, _document) {
  this.options = options;
  var autoInstrument = options.autoInstrument;
  if (options.enabled === false || autoInstrument === false) {
    this.autoInstrument = {};
  } else {
    if (!_.isType(autoInstrument, 'object')) {
      autoInstrument = defaults;
    }
    this.autoInstrument = _.merge(defaults, autoInstrument);
  }
  this.scrubTelemetryInputs = !!options.scrubTelemetryInputs;
  this.telemetryScrubber = options.telemetryScrubber;
  this.defaultValueScrubber = defaultValueScrubber(options.scrubFields);
  this.telemeter = telemeter;
  this.rollbar = rollbar;
  this.diagnostic = rollbar.client.notifier.diagnostic;
  this._window = _window || {};
  this._document = _document || {};
  this.replacements = {
    network: [],
    log: [],
    navigation: [],
    connectivity: []
  };
  this.eventRemovers = {
    dom: [],
    connectivity: [],
    contentsecuritypolicy: []
  };
  this._location = this._window.location;
  this._lastHref = this._location && this._location.href;
}
Instrumenter.prototype.configure = function (options) {
  this.options = _.merge(this.options, options);
  var autoInstrument = options.autoInstrument;
  var oldSettings = _.merge(this.autoInstrument);
  if (options.enabled === false || autoInstrument === false) {
    this.autoInstrument = {};
  } else {
    if (!_.isType(autoInstrument, 'object')) {
      autoInstrument = defaults;
    }
    this.autoInstrument = _.merge(defaults, autoInstrument);
  }
  this.instrument(oldSettings);
  if (options.scrubTelemetryInputs !== undefined) {
    this.scrubTelemetryInputs = !!options.scrubTelemetryInputs;
  }
  if (options.telemetryScrubber !== undefined) {
    this.telemetryScrubber = options.telemetryScrubber;
  }
};

// eslint-disable-next-line complexity
Instrumenter.prototype.instrument = function (oldSettings) {
  if (this.autoInstrument.network && !(oldSettings && oldSettings.network)) {
    this.instrumentNetwork();
  } else if (!this.autoInstrument.network && oldSettings && oldSettings.network) {
    this.deinstrumentNetwork();
  }
  if (this.autoInstrument.log && !(oldSettings && oldSettings.log)) {
    this.instrumentConsole();
  } else if (!this.autoInstrument.log && oldSettings && oldSettings.log) {
    this.deinstrumentConsole();
  }
  if (this.autoInstrument.dom && !(oldSettings && oldSettings.dom)) {
    this.instrumentDom();
  } else if (!this.autoInstrument.dom && oldSettings && oldSettings.dom) {
    this.deinstrumentDom();
  }
  if (this.autoInstrument.navigation && !(oldSettings && oldSettings.navigation)) {
    this.instrumentNavigation();
  } else if (!this.autoInstrument.navigation && oldSettings && oldSettings.navigation) {
    this.deinstrumentNavigation();
  }
  if (this.autoInstrument.connectivity && !(oldSettings && oldSettings.connectivity)) {
    this.instrumentConnectivity();
  } else if (!this.autoInstrument.connectivity && oldSettings && oldSettings.connectivity) {
    this.deinstrumentConnectivity();
  }
  if (this.autoInstrument.contentSecurityPolicy && !(oldSettings && oldSettings.contentSecurityPolicy)) {
    this.instrumentContentSecurityPolicy();
  } else if (!this.autoInstrument.contentSecurityPolicy && oldSettings && oldSettings.contentSecurityPolicy) {
    this.deinstrumentContentSecurityPolicy();
  }
};
Instrumenter.prototype.deinstrumentNetwork = function () {
  restore(this.replacements, 'network');
};
Instrumenter.prototype.instrumentNetwork = function () {
  var self = this;
  function wrapProp(prop, xhr) {
    if (prop in xhr && _.isFunction(xhr[prop])) {
      replace(xhr, prop, function (orig) {
        return self.rollbar.wrap(orig);
      });
    }
  }
  if ('XMLHttpRequest' in this._window) {
    var xhrp = this._window.XMLHttpRequest.prototype;
    replace(xhrp, 'open', function (orig) {
      return function (method, url) {
        var isUrlObject = _isUrlObject(url);
        if (_.isType(url, 'string') || isUrlObject) {
          url = isUrlObject ? url.toString() : url;
          if (this.__rollbar_xhr) {
            this.__rollbar_xhr.method = method;
            this.__rollbar_xhr.url = url;
            this.__rollbar_xhr.status_code = null;
            this.__rollbar_xhr.start_time_ms = _.now();
            this.__rollbar_xhr.end_time_ms = null;
          } else {
            this.__rollbar_xhr = {
              method: method,
              url: url,
              status_code: null,
              start_time_ms: _.now(),
              end_time_ms: null
            };
          }
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
    replace(xhrp, 'setRequestHeader', function (orig) {
      return function (header, value) {
        // If xhr.open is async, __rollbar_xhr may not be initialized yet.
        if (!this.__rollbar_xhr) {
          this.__rollbar_xhr = {};
        }
        if (_.isType(header, 'string') && _.isType(value, 'string')) {
          if (self.autoInstrument.networkRequestHeaders) {
            if (!this.__rollbar_xhr.request_headers) {
              this.__rollbar_xhr.request_headers = {};
            }
            this.__rollbar_xhr.request_headers[header] = value;
          }
          // We want the content type even if request header telemetry is off.
          if (header.toLowerCase() === 'content-type') {
            this.__rollbar_xhr.request_content_type = value;
          }
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
    replace(xhrp, 'send', function (orig) {
      /* eslint-disable no-unused-vars */
      return function (data) {
        /* eslint-enable no-unused-vars */
        var xhr = this;
        function onreadystatechangeHandler() {
          if (xhr.__rollbar_xhr) {
            if (xhr.__rollbar_xhr.status_code === null) {
              xhr.__rollbar_xhr.status_code = 0;
              if (self.autoInstrument.networkRequestBody) {
                xhr.__rollbar_xhr.request = data;
              }
              xhr.__rollbar_event = self.captureNetwork(xhr.__rollbar_xhr, 'xhr', undefined);
            }
            if (xhr.readyState < 2) {
              xhr.__rollbar_xhr.start_time_ms = _.now();
            }
            if (xhr.readyState > 3) {
              xhr.__rollbar_xhr.end_time_ms = _.now();
              var headers = null;
              xhr.__rollbar_xhr.response_content_type = xhr.getResponseHeader('Content-Type');
              if (self.autoInstrument.networkResponseHeaders) {
                var headersConfig = self.autoInstrument.networkResponseHeaders;
                headers = {};
                try {
                  var header, i;
                  if (headersConfig === true) {
                    var allHeaders = xhr.getAllResponseHeaders();
                    if (allHeaders) {
                      var arr = allHeaders.trim().split(/[\r\n]+/);
                      var parts, value;
                      for (i = 0; i < arr.length; i++) {
                        parts = arr[i].split(': ');
                        header = parts.shift();
                        value = parts.join(': ');
                        headers[header] = value;
                      }
                    }
                  } else {
                    for (i = 0; i < headersConfig.length; i++) {
                      header = headersConfig[i];
                      headers[header] = xhr.getResponseHeader(header);
                    }
                  }
                } catch (e) {
                  /* we ignore the errors here that could come from different
                   * browser issues with the xhr methods */
                }
              }
              var body = null;
              if (self.autoInstrument.networkResponseBody) {
                try {
                  body = xhr.responseText;
                } catch (e) {
                  /* ignore errors from reading responseText */
                }
              }
              var response = null;
              if (body || headers) {
                response = {};
                if (body) {
                  if (self.isJsonContentType(xhr.__rollbar_xhr.response_content_type)) {
                    response.body = self.scrubJson(body);
                  } else {
                    response.body = body;
                  }
                }
                if (headers) {
                  response.headers = headers;
                }
              }
              if (response) {
                xhr.__rollbar_xhr.response = response;
              }
              try {
                var code = xhr.status;
                code = code === 1223 ? 204 : code;
                xhr.__rollbar_xhr.status_code = code;
                xhr.__rollbar_event.level = self.telemeter.levelFromStatus(code);
                self.errorOnHttpStatus(xhr.__rollbar_xhr);
              } catch (e) {
                /* ignore possible exception from xhr.status */
              }
            }
          }
        }
        wrapProp('onload', xhr);
        wrapProp('onerror', xhr);
        wrapProp('onprogress', xhr);
        if ('onreadystatechange' in xhr && _.isFunction(xhr.onreadystatechange)) {
          replace(xhr, 'onreadystatechange', function (orig) {
            return self.rollbar.wrap(orig, undefined, onreadystatechangeHandler);
          });
        } else {
          xhr.onreadystatechange = onreadystatechangeHandler;
        }
        if (xhr.__rollbar_xhr && self.trackHttpErrors()) {
          xhr.__rollbar_xhr.stack = new Error().stack;
        }
        return orig.apply(this, arguments);
      };
    }, this.replacements, 'network');
  }
  if ('fetch' in this._window) {
    replace(this._window, 'fetch', function (orig) {
      /* eslint-disable no-unused-vars */
      return function (fn, t) {
        /* eslint-enable no-unused-vars */
        var args = new Array(arguments.length);
        for (var i = 0, len = args.length; i < len; i++) {
          args[i] = arguments[i];
        }
        var input = args[0];
        var method = 'GET';
        var url;
        var isUrlObject = _isUrlObject(input);
        if (_.isType(input, 'string') || isUrlObject) {
          url = isUrlObject ? input.toString() : input;
        } else if (input) {
          url = input.url;
          if (input.method) {
            method = input.method;
          }
        }
        if (args[1] && args[1].method) {
          method = args[1].method;
        }
        var metadata = {
          method: method,
          url: url,
          status_code: null,
          start_time_ms: _.now(),
          end_time_ms: null
        };
        if (args[1] && args[1].headers) {
          // Argument may be a Headers object, or plain object. Ensure here that
          // we are working with a Headers object with case-insensitive keys.
          var reqHeaders = headers(args[1].headers);
          metadata.request_content_type = reqHeaders.get('Content-Type');
          if (self.autoInstrument.networkRequestHeaders) {
            metadata.request_headers = self.fetchHeaders(reqHeaders, self.autoInstrument.networkRequestHeaders);
          }
        }
        if (self.autoInstrument.networkRequestBody) {
          if (args[1] && args[1].body) {
            metadata.request = args[1].body;
          } else if (args[0] && !_.isType(args[0], 'string') && args[0].body) {
            metadata.request = args[0].body;
          }
        }
        self.captureNetwork(metadata, 'fetch', undefined);
        if (self.trackHttpErrors()) {
          metadata.stack = new Error().stack;
        }

        // Start our handler before returning the promise. This allows resp.clone()
        // to execute before other handlers touch the response.
        return orig.apply(this, args).then(function (resp) {
          metadata.end_time_ms = _.now();
          metadata.status_code = resp.status;
          metadata.response_content_type = resp.headers.get('Content-Type');
          var headers = null;
          if (self.autoInstrument.networkResponseHeaders) {
            headers = self.fetchHeaders(resp.headers, self.autoInstrument.networkResponseHeaders);
          }
          var body = null;
          if (self.autoInstrument.networkResponseBody) {
            if (typeof resp.text === 'function') {
              // Response.text() is not implemented on some platforms
              // The response must be cloned to prevent reading (and locking) the original stream.
              // This must be done before other handlers touch the response.
              body = resp.clone().text(); //returns a Promise
            }
          }
          if (headers || body) {
            metadata.response = {};
            if (body) {
              // Test to ensure body is a Promise, which it should always be.
              if (typeof body.then === 'function') {
                body.then(function (text) {
                  if (text && self.isJsonContentType(metadata.response_content_type)) {
                    metadata.response.body = self.scrubJson(text);
                  } else {
                    metadata.response.body = text;
                  }
                });
              } else {
                metadata.response.body = body;
              }
            }
            if (headers) {
              metadata.response.headers = headers;
            }
          }
          self.errorOnHttpStatus(metadata);
          return resp;
        });
      };
    }, this.replacements, 'network');
  }
};
Instrumenter.prototype.captureNetwork = function (metadata, subtype, rollbarUUID) {
  if (metadata.request && this.isJsonContentType(metadata.request_content_type)) {
    metadata.request = this.scrubJson(metadata.request);
  }
  return this.telemeter.captureNetwork(metadata, subtype, rollbarUUID);
};
Instrumenter.prototype.isJsonContentType = function (contentType) {
  return contentType && _.isType(contentType, 'string') && contentType.toLowerCase().includes('json') ? true : false;
};
Instrumenter.prototype.scrubJson = function (json) {
  return JSON.stringify(scrub(JSON.parse(json), this.options.scrubFields));
};
Instrumenter.prototype.fetchHeaders = function (inHeaders, headersConfig) {
  var outHeaders = {};
  try {
    var i;
    if (headersConfig === true) {
      if (typeof inHeaders.entries === 'function') {
        // Headers.entries() is not implemented in IE
        var allHeaders = inHeaders.entries();
        var currentHeader = allHeaders.next();
        while (!currentHeader.done) {
          outHeaders[currentHeader.value[0]] = currentHeader.value[1];
          currentHeader = allHeaders.next();
        }
      }
    } else {
      for (i = 0; i < headersConfig.length; i++) {
        var header = headersConfig[i];
        outHeaders[header] = inHeaders.get(header);
      }
    }
  } catch (e) {
    /* ignore probable IE errors */
  }
  return outHeaders;
};
Instrumenter.prototype.trackHttpErrors = function () {
  return this.autoInstrument.networkErrorOnHttp5xx || this.autoInstrument.networkErrorOnHttp4xx || this.autoInstrument.networkErrorOnHttp0;
};
Instrumenter.prototype.errorOnHttpStatus = function (metadata) {
  var status = metadata.status_code;
  if (status >= 500 && this.autoInstrument.networkErrorOnHttp5xx || status >= 400 && this.autoInstrument.networkErrorOnHttp4xx || status === 0 && this.autoInstrument.networkErrorOnHttp0) {
    var error = new Error('HTTP request failed with Status ' + status);
    error.stack = metadata.stack;
    this.rollbar.error(error, {
      skipFrames: 1
    });
  }
};
Instrumenter.prototype.deinstrumentConsole = function () {
  if (!('console' in this._window && this._window.console.log)) {
    return;
  }
  var b;
  while (this.replacements['log'].length) {
    b = this.replacements['log'].shift();
    this._window.console[b[0]] = b[1];
  }
};
Instrumenter.prototype.instrumentConsole = function () {
  if (!('console' in this._window && this._window.console.log)) {
    return;
  }
  var self = this;
  var c = this._window.console;
  function wrapConsole(method) {
    'use strict';

    // See https://github.com/rollbar/rollbar.js/pull/778
    var orig = c[method];
    var origConsole = c;
    var level = method === 'warn' ? 'warning' : method;
    c[method] = function () {
      var args = Array.prototype.slice.call(arguments);
      var message = _.formatArgsAsString(args);
      self.telemeter.captureLog(message, level, null, _.now());
      if (orig) {
        Function.prototype.apply.call(orig, origConsole, args);
      }
    };
    self.replacements['log'].push([method, orig]);
  }
  var methods = ['debug', 'info', 'warn', 'error', 'log'];
  try {
    for (var i = 0, len = methods.length; i < len; i++) {
      wrapConsole(methods[i]);
    }
  } catch (e) {
    this.diagnostic.instrumentConsole = {
      error: e.message
    };
  }
};
Instrumenter.prototype.deinstrumentDom = function () {
  if (!('addEventListener' in this._window || 'attachEvent' in this._window)) {
    return;
  }
  this.removeListeners('dom');
};
Instrumenter.prototype.instrumentDom = function () {
  if (!('addEventListener' in this._window || 'attachEvent' in this._window)) {
    return;
  }
  var clickHandler = this.handleClick.bind(this);
  var blurHandler = this.handleBlur.bind(this);
  this.addListener('dom', this._window, 'click', 'onclick', clickHandler, true);
  this.addListener('dom', this._window, 'blur', 'onfocusout', blurHandler, true);
};
Instrumenter.prototype.handleClick = function (evt) {
  try {
    var e = domUtil.getElementFromEvent(evt, this._document);
    var hasTag = e && e.tagName;
    var anchorOrButton = domUtil.isDescribedElement(e, 'a') || domUtil.isDescribedElement(e, 'button');
    if (hasTag && (anchorOrButton || domUtil.isDescribedElement(e, 'input', ['button', 'submit']))) {
      this.captureDomEvent('click', e);
    } else if (domUtil.isDescribedElement(e, 'input', ['checkbox', 'radio'])) {
      this.captureDomEvent('input', e, e.value, e.checked);
    }
  } catch (exc) {
    // TODO: Not sure what to do here
  }
};
Instrumenter.prototype.handleBlur = function (evt) {
  try {
    var e = domUtil.getElementFromEvent(evt, this._document);
    if (e && e.tagName) {
      if (domUtil.isDescribedElement(e, 'textarea')) {
        this.captureDomEvent('input', e, e.value);
      } else if (domUtil.isDescribedElement(e, 'select') && e.options && e.options.length) {
        this.handleSelectInputChanged(e);
      } else if (domUtil.isDescribedElement(e, 'input') && !domUtil.isDescribedElement(e, 'input', ['button', 'submit', 'hidden', 'checkbox', 'radio'])) {
        this.captureDomEvent('input', e, e.value);
      }
    }
  } catch (exc) {
    // TODO: Not sure what to do here
  }
};
Instrumenter.prototype.handleSelectInputChanged = function (elem) {
  if (elem.multiple) {
    for (var i = 0; i < elem.options.length; i++) {
      if (elem.options[i].selected) {
        this.captureDomEvent('input', elem, elem.options[i].value);
      }
    }
  } else if (elem.selectedIndex >= 0 && elem.options[elem.selectedIndex]) {
    this.captureDomEvent('input', elem, elem.options[elem.selectedIndex].value);
  }
};
Instrumenter.prototype.captureDomEvent = function (subtype, element, value, isChecked) {
  if (value !== undefined) {
    if (this.scrubTelemetryInputs || domUtil.getElementType(element) === 'password') {
      value = '[scrubbed]';
    } else {
      var description = domUtil.describeElement(element);
      if (this.telemetryScrubber) {
        if (this.telemetryScrubber(description)) {
          value = '[scrubbed]';
        }
      } else if (this.defaultValueScrubber(description)) {
        value = '[scrubbed]';
      }
    }
  }
  var elementString = domUtil.elementArrayToString(domUtil.treeToArray(element));
  this.telemeter.captureDom(subtype, elementString, value, isChecked);
};
Instrumenter.prototype.deinstrumentNavigation = function () {
  var chrome = this._window.chrome;
  var chromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  // See https://github.com/angular/angular.js/pull/13945/files
  var hasPushState = !chromePackagedApp && this._window.history && this._window.history.pushState;
  if (!hasPushState) {
    return;
  }
  restore(this.replacements, 'navigation');
};
Instrumenter.prototype.instrumentNavigation = function () {
  var chrome = this._window.chrome;
  var chromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  // See https://github.com/angular/angular.js/pull/13945/files
  var hasPushState = !chromePackagedApp && this._window.history && this._window.history.pushState;
  if (!hasPushState) {
    return;
  }
  var self = this;
  replace(this._window, 'onpopstate', function (orig) {
    return function () {
      var current = self._location.href;
      self.handleUrlChange(self._lastHref, current);
      if (orig) {
        orig.apply(this, arguments);
      }
    };
  }, this.replacements, 'navigation');
  replace(this._window.history, 'pushState', function (orig) {
    return function () {
      var url = arguments.length > 2 ? arguments[2] : undefined;
      if (url) {
        self.handleUrlChange(self._lastHref, url + '');
      }
      return orig.apply(this, arguments);
    };
  }, this.replacements, 'navigation');
};
Instrumenter.prototype.handleUrlChange = function (from, to) {
  var parsedHref = urlparser.parse(this._location.href);
  var parsedTo = urlparser.parse(to);
  var parsedFrom = urlparser.parse(from);
  this._lastHref = to;
  if (parsedHref.protocol === parsedTo.protocol && parsedHref.host === parsedTo.host) {
    to = parsedTo.path + (parsedTo.hash || '');
  }
  if (parsedHref.protocol === parsedFrom.protocol && parsedHref.host === parsedFrom.host) {
    from = parsedFrom.path + (parsedFrom.hash || '');
  }
  this.telemeter.captureNavigation(from, to, _.now());
};
Instrumenter.prototype.deinstrumentConnectivity = function () {
  if (!('addEventListener' in this._window || 'body' in this._document)) {
    return;
  }
  if (this._window.addEventListener) {
    this.removeListeners('connectivity');
  } else {
    restore(this.replacements, 'connectivity');
  }
};
Instrumenter.prototype.instrumentConnectivity = function () {
  if (!('addEventListener' in this._window || 'body' in this._document)) {
    return;
  }
  if (this._window.addEventListener) {
    this.addListener('connectivity', this._window, 'online', undefined, function () {
      this.telemeter.captureConnectivityChange('online');
    }.bind(this), true);
    this.addListener('connectivity', this._window, 'offline', undefined, function () {
      this.telemeter.captureConnectivityChange('offline');
    }.bind(this), true);
  } else {
    var self = this;
    replace(this._document.body, 'ononline', function (orig) {
      return function () {
        self.telemeter.captureConnectivityChange('online');
        if (orig) {
          orig.apply(this, arguments);
        }
      };
    }, this.replacements, 'connectivity');
    replace(this._document.body, 'onoffline', function (orig) {
      return function () {
        self.telemeter.captureConnectivityChange('offline');
        if (orig) {
          orig.apply(this, arguments);
        }
      };
    }, this.replacements, 'connectivity');
  }
};
Instrumenter.prototype.handleCspEvent = function (cspEvent) {
  var message = 'Security Policy Violation: ' + 'blockedURI: ' + cspEvent.blockedURI + ', ' + 'violatedDirective: ' + cspEvent.violatedDirective + ', ' + 'effectiveDirective: ' + cspEvent.effectiveDirective + ', ';
  if (cspEvent.sourceFile) {
    message += 'location: ' + cspEvent.sourceFile + ', ' + 'line: ' + cspEvent.lineNumber + ', ' + 'col: ' + cspEvent.columnNumber + ', ';
  }
  message += 'originalPolicy: ' + cspEvent.originalPolicy;
  this.telemeter.captureLog(message, 'error', null, _.now());
  this.handleCspError(message);
};
Instrumenter.prototype.handleCspError = function (message) {
  if (this.autoInstrument.errorOnContentSecurityPolicy) {
    this.rollbar.error(message);
  }
};
Instrumenter.prototype.deinstrumentContentSecurityPolicy = function () {
  if (!('addEventListener' in this._document)) {
    return;
  }
  this.removeListeners('contentsecuritypolicy');
};
Instrumenter.prototype.instrumentContentSecurityPolicy = function () {
  if (!('addEventListener' in this._document)) {
    return;
  }
  var cspHandler = this.handleCspEvent.bind(this);
  this.addListener('contentsecuritypolicy', this._document, 'securitypolicyviolation', null, cspHandler, false);
};
Instrumenter.prototype.addListener = function (section, obj, type, altType, handler, capture) {
  if (obj.addEventListener) {
    obj.addEventListener(type, handler, capture);
    this.eventRemovers[section].push(function () {
      obj.removeEventListener(type, handler, capture);
    });
  } else if (altType) {
    obj.attachEvent(altType, handler);
    this.eventRemovers[section].push(function () {
      obj.detachEvent(altType, handler);
    });
  }
};
Instrumenter.prototype.removeListeners = function (section) {
  var r;
  while (this.eventRemovers[section].length) {
    r = this.eventRemovers[section].shift();
    r();
  }
};
function _isUrlObject(input) {
  return typeof URL !== 'undefined' && input instanceof URL;
}
module.exports = Instrumenter;

/***/ }),

/***/ "./src/browser/transforms.js":
/*!***********************************!*\
  !*** ./src/browser/transforms.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var errorParser = __webpack_require__(/*! ../errorParser */ "./src/errorParser.js");
var logger = __webpack_require__(/*! ./logger */ "./src/browser/logger.js");
function handleDomException(item, options, callback) {
  if (item.err && errorParser.Stack(item.err).name === 'DOMException') {
    var originalError = new Error();
    originalError.name = item.err.name;
    originalError.message = item.err.message;
    originalError.stack = item.err.stack;
    originalError.nested = item.err;
    item.err = originalError;
  }
  callback(null, item);
}
function handleItemWithError(item, options, callback) {
  item.data = item.data || {};
  if (item.err) {
    try {
      item.stackInfo = item.err._savedStackTrace || errorParser.parse(item.err, item.skipFrames);
      if (options.addErrorContext) {
        addErrorContext(item);
      }
    } catch (e) {
      logger.error('Error while parsing the error object.', e);
      try {
        item.message = item.err.message || item.err.description || item.message || String(item.err);
      } catch (e2) {
        item.message = String(item.err) || String(e2);
      }
      delete item.err;
    }
  }
  callback(null, item);
}
function addErrorContext(item) {
  var chain = [];
  var err = item.err;
  chain.push(err);
  while (err.nested || err.cause) {
    err = err.nested || err.cause;
    chain.push(err);
  }
  _.addErrorContext(item, chain);
}
function ensureItemHasSomethingToSay(item, options, callback) {
  if (!item.message && !item.stackInfo && !item.custom) {
    callback(new Error('No message, stack info, or custom data'), null);
  }
  callback(null, item);
}
function addBaseInfo(item, options, callback) {
  var environment = options.payload && options.payload.environment || options.environment;
  item.data = _.merge(item.data, {
    environment: environment,
    level: item.level,
    endpoint: options.endpoint,
    platform: 'browser',
    framework: 'browser-js',
    language: 'javascript',
    server: {},
    uuid: item.uuid,
    notifier: {
      name: 'rollbar-browser-js',
      version: options.version
    },
    custom: item.custom
  });
  callback(null, item);
}
function addRequestInfo(window) {
  return function (item, options, callback) {
    var requestInfo = {};
    if (window && window.location) {
      requestInfo.url = window.location.href;
      requestInfo.query_string = window.location.search;
    }
    var remoteString = '$remote_ip';
    if (!options.captureIp) {
      remoteString = null;
    } else if (options.captureIp !== true) {
      remoteString += '_anonymize';
    }
    if (remoteString) requestInfo.user_ip = remoteString;
    if (Object.keys(requestInfo).length > 0) {
      _.set(item, 'data.request', requestInfo);
    }
    callback(null, item);
  };
}
function addClientInfo(window) {
  return function (item, options, callback) {
    if (!window) {
      return callback(null, item);
    }
    var nav = window.navigator || {};
    var scr = window.screen || {};
    _.set(item, 'data.client', {
      runtime_ms: item.timestamp - window._rollbarStartTime,
      timestamp: Math.round(item.timestamp / 1000),
      javascript: {
        browser: nav.userAgent,
        language: nav.language,
        cookie_enabled: nav.cookieEnabled,
        screen: {
          width: scr.width,
          height: scr.height
        }
      }
    });
    callback(null, item);
  };
}
function addPluginInfo(window) {
  return function (item, options, callback) {
    if (!window || !window.navigator) {
      return callback(null, item);
    }
    var plugins = [];
    var navPlugins = window.navigator.plugins || [];
    var cur;
    for (var i = 0, l = navPlugins.length; i < l; ++i) {
      cur = navPlugins[i];
      plugins.push({
        name: cur.name,
        description: cur.description
      });
    }
    _.set(item, 'data.client.javascript.plugins', plugins);
    callback(null, item);
  };
}
function addBody(item, options, callback) {
  if (item.stackInfo) {
    if (item.stackInfo.traceChain) {
      addBodyTraceChain(item, options, callback);
    } else {
      addBodyTrace(item, options, callback);
    }
  } else {
    addBodyMessage(item, options, callback);
  }
}
function addBodyMessage(item, options, callback) {
  var message = item.message;
  var custom = item.custom;
  if (!message) {
    message = 'Item sent with null or missing arguments.';
  }
  var result = {
    body: message
  };
  if (custom) {
    result.extra = _.merge(custom);
  }
  _.set(item, 'data.body', {
    message: result
  });
  callback(null, item);
}
function stackFromItem(item) {
  // Transform a TraceKit stackInfo object into a Rollbar trace
  var stack = item.stackInfo.stack;
  if (stack && stack.length === 0 && item._unhandledStackInfo && item._unhandledStackInfo.stack) {
    stack = item._unhandledStackInfo.stack;
  }
  return stack;
}
function addBodyTraceChain(item, options, callback) {
  var traceChain = item.stackInfo.traceChain;
  var traces = [];
  var traceChainLength = traceChain.length;
  for (var i = 0; i < traceChainLength; i++) {
    var trace = buildTrace(item, traceChain[i], options);
    traces.push(trace);
  }
  _.set(item, 'data.body', {
    trace_chain: traces
  });
  callback(null, item);
}
function addBodyTrace(item, options, callback) {
  var stack = stackFromItem(item);
  if (stack) {
    var trace = buildTrace(item, item.stackInfo, options);
    _.set(item, 'data.body', {
      trace: trace
    });
    callback(null, item);
  } else {
    var stackInfo = item.stackInfo;
    var guess = errorParser.guessErrorClass(stackInfo.message);
    var className = errorClass(stackInfo, guess[0], options);
    var message = guess[1];
    item.message = className + ': ' + message;
    addBodyMessage(item, options, callback);
  }
}
function buildTrace(item, stackInfo, options) {
  var description = item && item.data.description;
  var custom = item && item.custom;
  var stack = stackFromItem(item);
  var guess = errorParser.guessErrorClass(stackInfo.message);
  var className = errorClass(stackInfo, guess[0], options);
  var message = guess[1];
  var trace = {
    exception: {
      "class": className,
      message: message
    }
  };
  if (description) {
    trace.exception.description = description;
  }
  if (stack) {
    if (stack.length === 0) {
      trace.exception.stack = stackInfo.rawStack;
      trace.exception.raw = String(stackInfo.rawException);
    }
    var stackFrame;
    var frame;
    var code;
    var pre;
    var post;
    var contextLength;
    var i, mid;
    trace.frames = [];
    for (i = 0; i < stack.length; ++i) {
      stackFrame = stack[i];
      frame = {
        filename: stackFrame.url ? _.sanitizeUrl(stackFrame.url) : '(unknown)',
        lineno: stackFrame.line || null,
        method: !stackFrame.func || stackFrame.func === '?' ? '[anonymous]' : stackFrame.func,
        colno: stackFrame.column
      };
      if (options.sendFrameUrl) {
        frame.url = stackFrame.url;
      }
      if (frame.method && frame.method.endsWith && frame.method.endsWith('_rollbar_wrapped')) {
        continue;
      }
      code = pre = post = null;
      contextLength = stackFrame.context ? stackFrame.context.length : 0;
      if (contextLength) {
        mid = Math.floor(contextLength / 2);
        pre = stackFrame.context.slice(0, mid);
        code = stackFrame.context[mid];
        post = stackFrame.context.slice(mid);
      }
      if (code) {
        frame.code = code;
      }
      if (pre || post) {
        frame.context = {};
        if (pre && pre.length) {
          frame.context.pre = pre;
        }
        if (post && post.length) {
          frame.context.post = post;
        }
      }
      if (stackFrame.args) {
        frame.args = stackFrame.args;
      }
      trace.frames.push(frame);
    }

    // NOTE(cory): reverse the frames since rollbar.com expects the most recent call last
    trace.frames.reverse();
    if (custom) {
      trace.extra = _.merge(custom);
    }
  }
  return trace;
}
function errorClass(stackInfo, guess, options) {
  if (stackInfo.name) {
    return stackInfo.name;
  } else if (options.guessErrorClass) {
    return guess;
  } else {
    return '(unknown)';
  }
}
function addScrubber(scrubFn) {
  return function (item, options, callback) {
    if (scrubFn) {
      var scrubFields = options.scrubFields || [];
      var scrubPaths = options.scrubPaths || [];
      item.data = scrubFn(item.data, scrubFields, scrubPaths);
    }
    callback(null, item);
  };
}
module.exports = {
  handleDomException: handleDomException,
  handleItemWithError: handleItemWithError,
  ensureItemHasSomethingToSay: ensureItemHasSomethingToSay,
  addBaseInfo: addBaseInfo,
  addRequestInfo: addRequestInfo,
  addClientInfo: addClientInfo,
  addPluginInfo: addPluginInfo,
  addBody: addBody,
  addScrubber: addScrubber
};

/***/ }),

/***/ "./src/browser/transport.js":
/*!**********************************!*\
  !*** ./src/browser/transport.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
var makeFetchRequest = __webpack_require__(/*! ./transport/fetch */ "./src/browser/transport/fetch.js");
var makeXhrRequest = __webpack_require__(/*! ./transport/xhr */ "./src/browser/transport/xhr.js");

/*
 * accessToken may be embedded in payload but that should not
 *   be assumed
 *
 * options: {
 *   hostname
 *   protocol
 *   path
 *   port
 *   method
 *   transport ('xhr' | 'fetch')
 * }
 *
 *  params is an object containing key/value pairs. These
 *    will be appended to the path as 'key=value&key=value'
 *
 * payload is an unserialized object
 */
function Transport(truncation) {
  this.truncation = truncation;
}
Transport.prototype.get = function (accessToken, options, params, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  _.addParamsAndAccessTokenToPath(accessToken, options, params);
  var method = 'GET';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, null, callback, requestFactory, options.timeout, options.transport);
};
Transport.prototype.post = function (accessToken, options, payload, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  if (!payload) {
    return callback(new Error('Cannot send empty request'));
  }
  var stringifyResult;
  if (this.truncation) {
    stringifyResult = this.truncation.truncate(payload);
  } else {
    stringifyResult = _.stringify(payload);
  }
  if (stringifyResult.error) {
    return callback(stringifyResult.error);
  }
  var writeData = stringifyResult.value;
  var method = 'POST';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, writeData, callback, requestFactory, options.timeout, options.transport);
};
Transport.prototype.postJsonPayload = function (accessToken, options, jsonPayload, callback, requestFactory) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  var method = 'POST';
  var url = _.formatUrl(options);
  this._makeZoneRequest(accessToken, url, method, jsonPayload, callback, requestFactory, options.timeout, options.transport);
};

// Wraps `_makeRequest` if zone.js is being used, ensuring that Rollbar
// API calls are not intercepted by any child forked zones.
// This is equivalent to `NgZone.runOutsideAngular` in Angular.
Transport.prototype._makeZoneRequest = function () {
  var gWindow = typeof window != 'undefined' && window || typeof self != 'undefined' && self;
  // Whenever zone.js is loaded and `Zone` is exposed globally, access
  // the root zone to ensure that requests are always made within it.
  // This approach is framework-agnostic, regardless of which
  // framework zone.js is used with.
  var rootZone = gWindow && gWindow.Zone && gWindow.Zone.root;
  var args = Array.prototype.slice.call(arguments);
  if (rootZone) {
    var self = this;
    rootZone.run(function () {
      self._makeRequest.apply(undefined, args);
    });
  } else {
    this._makeRequest.apply(undefined, args);
  }
};
Transport.prototype._makeRequest = function (accessToken, url, method, data, callback, requestFactory, timeout, transport) {
  if (typeof RollbarProxy !== 'undefined') {
    return _proxyRequest(data, callback);
  }
  if (transport === 'fetch') {
    makeFetchRequest(accessToken, url, method, data, callback, timeout);
  } else {
    makeXhrRequest(accessToken, url, method, data, callback, requestFactory, timeout);
  }
};

/* global RollbarProxy */
function _proxyRequest(json, callback) {
  var rollbarProxy = new RollbarProxy();
  rollbarProxy.sendJsonPayload(json, function (_msg) {
    /* do nothing */
  },
  // eslint-disable-line no-unused-vars
  function (err) {
    callback(new Error(err));
  });
}
module.exports = Transport;

/***/ }),

/***/ "./src/browser/transport/fetch.js":
/*!****************************************!*\
  !*** ./src/browser/transport/fetch.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var logger = __webpack_require__(/*! ../logger */ "./src/browser/logger.js");
var _ = __webpack_require__(/*! ../../utility */ "./src/utility.js");
function makeFetchRequest(accessToken, url, method, data, callback, timeout) {
  var controller;
  var timeoutId;
  if (_.isFiniteNumber(timeout)) {
    controller = new AbortController();
    timeoutId = setTimeout(function () {
      controller.abort();
    }, timeout);
  }
  fetch(url, {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-Rollbar-Access-Token': accessToken,
      signal: controller && controller.signal
    },
    body: data
  }).then(function (response) {
    if (timeoutId) clearTimeout(timeoutId);
    return response.json();
  }).then(function (data) {
    callback(null, data);
  })["catch"](function (error) {
    logger.error(error.message);
    callback(error);
  });
}
module.exports = makeFetchRequest;

/***/ }),

/***/ "./src/browser/transport/xhr.js":
/*!**************************************!*\
  !*** ./src/browser/transport/xhr.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global XDomainRequest*/

var _ = __webpack_require__(/*! ../../utility */ "./src/utility.js");
var logger = __webpack_require__(/*! ../logger */ "./src/browser/logger.js");
function makeXhrRequest(accessToken, url, method, data, callback, requestFactory, timeout) {
  var request;
  if (requestFactory) {
    request = requestFactory();
  } else {
    request = _createXMLHTTPObject();
  }
  if (!request) {
    // Give up, no way to send requests
    return callback(new Error('No way to send a request'));
  }
  try {
    try {
      var _onreadystatechange = function onreadystatechange() {
        try {
          if (_onreadystatechange && request.readyState === 4) {
            _onreadystatechange = undefined;
            var parseResponse = _.jsonParse(request.responseText);
            if (_isSuccess(request)) {
              callback(parseResponse.error, parseResponse.value);
              return;
            } else if (_isNormalFailure(request)) {
              if (request.status === 403) {
                // likely caused by using a server access token
                var message = parseResponse.value && parseResponse.value.message;
                logger.error(message);
              }
              // return valid http status codes
              callback(new Error(String(request.status)));
            } else {
              // IE will return a status 12000+ on some sort of connection failure,
              // so we return a blank error
              // http://msdn.microsoft.com/en-us/library/aa383770%28VS.85%29.aspx
              var msg = 'XHR response had no status code (likely connection failure)';
              callback(_newRetriableError(msg));
            }
          }
        } catch (ex) {
          //jquery source mentions firefox may error out while accessing the
          //request members if there is a network error
          //https://github.com/jquery/jquery/blob/a938d7b1282fc0e5c52502c225ae8f0cef219f0a/src/ajax/xhr.js#L111
          var exc;
          if (ex && ex.stack) {
            exc = ex;
          } else {
            exc = new Error(ex);
          }
          callback(exc);
        }
      };
      request.open(method, url, true);
      if (request.setRequestHeader) {
        request.setRequestHeader('Content-Type', 'application/json');
        request.setRequestHeader('X-Rollbar-Access-Token', accessToken);
      }
      if (_.isFiniteNumber(timeout)) {
        request.timeout = timeout;
      }
      request.onreadystatechange = _onreadystatechange;
      request.send(data);
    } catch (e1) {
      // Sending using the normal xmlhttprequest object didn't work, try XDomainRequest
      if (typeof XDomainRequest !== 'undefined') {
        // Assume we are in a really old browser which has a bunch of limitations:
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

        // Extreme paranoia: if we have XDomainRequest then we have a window, but just in case
        if (!window || !window.location) {
          return callback(new Error('No window available during request, unknown environment'));
        }

        // If the current page is http, try and send over http
        if (window.location.href.substring(0, 5) === 'http:' && url.substring(0, 5) === 'https') {
          url = 'http' + url.substring(5);
        }
        var xdomainrequest = new XDomainRequest();
        xdomainrequest.onprogress = function () {};
        xdomainrequest.ontimeout = function () {
          var msg = 'Request timed out';
          var code = 'ETIMEDOUT';
          callback(_newRetriableError(msg, code));
        };
        xdomainrequest.onerror = function () {
          callback(new Error('Error during request'));
        };
        xdomainrequest.onload = function () {
          var parseResponse = _.jsonParse(xdomainrequest.responseText);
          callback(parseResponse.error, parseResponse.value);
        };
        xdomainrequest.open(method, url, true);
        xdomainrequest.send(data);
      } else {
        callback(new Error('Cannot find a method to transport a request'));
      }
    }
  } catch (e2) {
    callback(e2);
  }
}
function _createXMLHTTPObject() {
  /* global ActiveXObject:false */

  var factories = [function () {
    return new XMLHttpRequest();
  }, function () {
    return new ActiveXObject('Msxml2.XMLHTTP');
  }, function () {
    return new ActiveXObject('Msxml3.XMLHTTP');
  }, function () {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }];
  var xmlhttp;
  var i;
  var numFactories = factories.length;
  for (i = 0; i < numFactories; i++) {
    /* eslint-disable no-empty */
    try {
      xmlhttp = factories[i]();
      break;
    } catch (e) {
      // pass
    }
    /* eslint-enable no-empty */
  }
  return xmlhttp;
}
function _isSuccess(r) {
  return r && r.status && r.status === 200;
}
function _isNormalFailure(r) {
  return r && _.isType(r.status, 'number') && r.status >= 400 && r.status < 600;
}
function _newRetriableError(message, code) {
  var err = new Error(message);
  err.code = code || 'ENOTFOUND';
  return err;
}
module.exports = makeXhrRequest;

/***/ }),

/***/ "./src/browser/url.js":
/*!****************************!*\
  !*** ./src/browser/url.js ***!
  \****************************/
/***/ ((module) => {

// See https://nodejs.org/docs/latest/api/url.html
function parse(url) {
  var result = {
    protocol: null,
    auth: null,
    host: null,
    path: null,
    hash: null,
    href: url,
    hostname: null,
    port: null,
    pathname: null,
    search: null,
    query: null
  };
  var i, last;
  i = url.indexOf('//');
  if (i !== -1) {
    result.protocol = url.substring(0, i);
    last = i + 2;
  } else {
    last = 0;
  }
  i = url.indexOf('@', last);
  if (i !== -1) {
    result.auth = url.substring(last, i);
    last = i + 1;
  }
  i = url.indexOf('/', last);
  if (i === -1) {
    i = url.indexOf('?', last);
    if (i === -1) {
      i = url.indexOf('#', last);
      if (i === -1) {
        result.host = url.substring(last);
      } else {
        result.host = url.substring(last, i);
        result.hash = url.substring(i);
      }
      result.hostname = result.host.split(':')[0];
      result.port = result.host.split(':')[1];
      if (result.port) {
        result.port = parseInt(result.port, 10);
      }
      return result;
    } else {
      result.host = url.substring(last, i);
      result.hostname = result.host.split(':')[0];
      result.port = result.host.split(':')[1];
      if (result.port) {
        result.port = parseInt(result.port, 10);
      }
      last = i;
    }
  } else {
    result.host = url.substring(last, i);
    result.hostname = result.host.split(':')[0];
    result.port = result.host.split(':')[1];
    if (result.port) {
      result.port = parseInt(result.port, 10);
    }
    last = i;
  }
  i = url.indexOf('#', last);
  if (i === -1) {
    result.path = url.substring(last);
  } else {
    result.path = url.substring(last, i);
    result.hash = url.substring(i);
  }
  if (result.path) {
    var pathParts = result.path.split('?');
    result.pathname = pathParts[0];
    result.query = pathParts[1];
    result.search = result.query ? '?' + result.query : null;
  }
  return result;
}
module.exports = {
  parse: parse
};

/***/ }),

/***/ "./src/browser/wrapGlobals.js":
/*!************************************!*\
  !*** ./src/browser/wrapGlobals.js ***!
  \************************************/
/***/ ((module) => {

function wrapGlobals(window, handler, shim) {
  if (!window) {
    return;
  }
  // Adapted from https://github.com/bugsnag/bugsnag-js
  var globals = 'EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload'.split(',');
  var i, global;
  for (i = 0; i < globals.length; ++i) {
    global = globals[i];
    if (window[global] && window[global].prototype) {
      _extendListenerPrototype(handler, window[global].prototype, shim);
    }
  }
}
function _extendListenerPrototype(handler, prototype, shim) {
  if (prototype.hasOwnProperty && prototype.hasOwnProperty('addEventListener')) {
    var oldAddEventListener = prototype.addEventListener;
    while (oldAddEventListener._rollbarOldAdd && oldAddEventListener.belongsToShim) {
      oldAddEventListener = oldAddEventListener._rollbarOldAdd;
    }
    var addFn = function addFn(event, callback, bubble) {
      oldAddEventListener.call(this, event, handler.wrap(callback), bubble);
    };
    addFn._rollbarOldAdd = oldAddEventListener;
    addFn.belongsToShim = shim;
    prototype.addEventListener = addFn;
    var oldRemoveEventListener = prototype.removeEventListener;
    while (oldRemoveEventListener._rollbarOldRemove && oldRemoveEventListener.belongsToShim) {
      oldRemoveEventListener = oldRemoveEventListener._rollbarOldRemove;
    }
    var removeFn = function removeFn(event, callback, bubble) {
      oldRemoveEventListener.call(this, event, callback && callback._rollbar_wrapped || callback, bubble);
    };
    removeFn._rollbarOldRemove = oldRemoveEventListener;
    removeFn.belongsToShim = shim;
    prototype.removeEventListener = removeFn;
  }
}
module.exports = wrapGlobals;

/***/ }),

/***/ "./src/defaults.js":
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/***/ ((module) => {

module.exports = {
  version: '3.0.0-alpha.0',
  endpoint: 'api.rollbar.com/api/1/item/',
  logLevel: 'debug',
  reportLevel: 'debug',
  uncaughtErrorLevel: 'error',
  maxItems: 0,
  itemsPerMin: 60
};

/***/ }),

/***/ "./src/errorParser.js":
/*!****************************!*\
  !*** ./src/errorParser.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ErrorStackParser = __webpack_require__(/*! error-stack-parser */ "./node_modules/error-stack-parser/error-stack-parser.js");
var UNKNOWN_FUNCTION = '?';
var ERR_CLASS_REGEXP = new RegExp('^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ');
function guessFunctionName() {
  return UNKNOWN_FUNCTION;
}
function gatherContext() {
  return null;
}
function Frame(stackFrame) {
  var data = {};
  data._stackFrame = stackFrame;
  data.url = stackFrame.fileName;
  data.line = stackFrame.lineNumber;
  data.func = stackFrame.functionName;
  data.column = stackFrame.columnNumber;
  data.args = stackFrame.args;
  data.context = gatherContext();
  return data;
}
function Stack(exception, skip) {
  function getStack() {
    var parserStack = [];
    skip = skip || 0;
    try {
      parserStack = ErrorStackParser.parse(exception);
    } catch (e) {
      parserStack = [];
    }
    var stack = [];
    for (var i = skip; i < parserStack.length; i++) {
      stack.push(new Frame(parserStack[i]));
    }
    return stack;
  }
  return {
    stack: getStack(),
    message: exception.message,
    name: _mostSpecificErrorName(exception),
    rawStack: exception.stack,
    rawException: exception
  };
}
function parse(e, skip) {
  var err = e;
  if (err.nested || err.cause) {
    var traceChain = [];
    while (err) {
      traceChain.push(new Stack(err, skip));
      err = err.nested || err.cause;
      skip = 0; // Only apply skip value to primary error
    }

    // Return primary error with full trace chain attached.
    traceChain[0].traceChain = traceChain;
    return traceChain[0];
  } else {
    return new Stack(err, skip);
  }
}
function guessErrorClass(errMsg) {
  if (!errMsg || !errMsg.match) {
    return ['Unknown error. There was no error message to display.', ''];
  }
  var errClassMatch = errMsg.match(ERR_CLASS_REGEXP);
  var errClass = '(unknown)';
  if (errClassMatch) {
    errClass = errClassMatch[errClassMatch.length - 1];
    errMsg = errMsg.replace((errClassMatch[errClassMatch.length - 2] || '') + errClass + ':', '');
    errMsg = errMsg.replace(/(^[\s]+|[\s]+$)/g, '');
  }
  return [errClass, errMsg];
}

// * Prefers any value over an empty string
// * Prefers any value over 'Error' where possible
// * Prefers name over constructor.name when both are more specific than 'Error'
function _mostSpecificErrorName(error) {
  var name = error.name && error.name.length && error.name;
  var constructorName = error.constructor.name && error.constructor.name.length && error.constructor.name;
  if (!name || !constructorName) {
    return name || constructorName;
  }
  if (name === 'Error') {
    return constructorName;
  }
  return name;
}
module.exports = {
  guessFunctionName: guessFunctionName,
  guessErrorClass: guessErrorClass,
  gatherContext: gatherContext,
  parse: parse,
  Stack: Stack,
  Frame: Frame
};

/***/ }),

/***/ "./src/merge.js":
/*!**********************!*\
  !*** ./src/merge.js ***!
  \**********************/
/***/ ((module) => {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var isPlainObject = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== '[object Object]') {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, 'constructor');
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  // Not own constructor property must be Object
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {
    /**/
  }
  return typeof key === 'undefined' || hasOwn.call(obj, key);
};
function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = {},
    current = null,
    length = arguments.length;
  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {
      continue;
    }
    for (name in current) {
      src = result[name];
      copy = current[name];
      if (result !== copy) {
        if (copy && isPlainObject(copy)) {
          clone = src && isPlainObject(src) ? src : {};
          result[name] = merge(clone, copy);
        } else if (typeof copy !== 'undefined') {
          result[name] = copy;
        }
      }
    }
  }
  return result;
}
module.exports = merge;

/***/ }),

/***/ "./src/notifier.js":
/*!*************************!*\
  !*** ./src/notifier.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * Notifier - the internal object responsible for delegating between the client exposed API, the
 * chain of transforms necessary to turn an item into something that can be sent to Rollbar, and the
 * queue which handles the communcation with the Rollbar API servers.
 *
 * @param queue - an object that conforms to the interface: addItem(item, callback)
 * @param options - an object representing the options to be set for this notifier, this should have
 * any defaults already set by the caller
 */
function Notifier(queue, options) {
  this.queue = queue;
  this.options = options;
  this.transforms = [];
  this.diagnostic = {};
}

/*
 * configure - updates the options for this notifier with the passed in object
 *
 * @param options - an object which gets merged with the current options set on this notifier
 * @returns this
 */
Notifier.prototype.configure = function (options) {
  this.queue && this.queue.configure(options);
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  return this;
};

/*
 * addTransform - adds a transform onto the end of the queue of transforms for this notifier
 *
 * @param transform - a function which takes three arguments:
 *    * item: An Object representing the data to eventually be sent to Rollbar
 *    * options: The current value of the options for this notifier
 *    * callback: function(err: (Null|Error), item: (Null|Object)) the transform must call this
 *    callback with a null value for error if it wants the processing chain to continue, otherwise
 *    with an error to terminate the processing. The item should be the updated item after this
 *    transform is finished modifying it.
 */
Notifier.prototype.addTransform = function (transform) {
  if (_.isFunction(transform)) {
    this.transforms.push(transform);
  }
  return this;
};

/*
 * log - the internal log function which applies the configured transforms and then pushes onto the
 * queue to be sent to the backend.
 *
 * @param item - An object with the following structure:
 *    message [String] - An optional string to be sent to rollbar
 *    error [Error] - An optional error
 *
 * @param callback - A function of type function(err, resp) which will be called with exactly one
 * null argument and one non-null argument. The callback will be called once, either during the
 * transform stage if an error occurs inside a transform, or in response to the communication with
 * the backend. The second argument will be the response from the backend in case of success.
 */
Notifier.prototype.log = function (item, callback) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {};
  }
  if (!this.options.enabled) {
    return callback(new Error('Rollbar is not enabled'));
  }
  this.queue.addPendingItem(item);
  var originalError = item.err;
  this._applyTransforms(item, function (err, i) {
    if (err) {
      this.queue.removePendingItem(item);
      return callback(err, null);
    }
    this.queue.addItem(i, callback, originalError, item);
  }.bind(this));
};

/* Internal */

/*
 * _applyTransforms - Applies the transforms that have been added to this notifier sequentially. See
 * `addTransform` for more information.
 *
 * @param item - An item to be transformed
 * @param callback - A function of type function(err, item) which will be called with a non-null
 * error and a null item in the case of a transform failure, or a null error and non-null item after
 * all transforms have been applied.
 */
Notifier.prototype._applyTransforms = function (item, callback) {
  var transformIndex = -1;
  var transformsLength = this.transforms.length;
  var transforms = this.transforms;
  var options = this.options;
  var _cb = function cb(err, i) {
    if (err) {
      callback(err, null);
      return;
    }
    transformIndex++;
    if (transformIndex === transformsLength) {
      callback(null, i);
      return;
    }
    transforms[transformIndex](i, options, _cb);
  };
  _cb(null, item);
};
module.exports = Notifier;

/***/ }),

/***/ "./src/predicates.js":
/*!***************************!*\
  !*** ./src/predicates.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
function checkLevel(item, settings) {
  var level = item.level;
  var levelVal = _.LEVELS[level] || 0;
  var reportLevel = settings.reportLevel;
  var reportLevelVal = _.LEVELS[reportLevel] || 0;
  if (levelVal < reportLevelVal) {
    return false;
  }
  return true;
}
function userCheckIgnore(logger) {
  return function (item, settings) {
    var isUncaught = !!item._isUncaught;
    delete item._isUncaught;
    var args = item._originalArgs;
    delete item._originalArgs;
    try {
      if (_.isFunction(settings.onSendCallback)) {
        settings.onSendCallback(isUncaught, args, item);
      }
    } catch (e) {
      settings.onSendCallback = null;
      logger.error('Error while calling onSendCallback, removing', e);
    }
    try {
      if (_.isFunction(settings.checkIgnore) && settings.checkIgnore(isUncaught, args, item)) {
        return false;
      }
    } catch (e) {
      settings.checkIgnore = null;
      logger.error('Error while calling custom checkIgnore(), removing', e);
    }
    return true;
  };
}
function urlIsNotBlockListed(logger) {
  return function (item, settings) {
    return !urlIsOnAList(item, settings, 'blocklist', logger);
  };
}
function urlIsSafeListed(logger) {
  return function (item, settings) {
    return urlIsOnAList(item, settings, 'safelist', logger);
  };
}
function matchFrames(trace, list, block) {
  if (!trace) {
    return !block;
  }
  var frames = trace.frames;
  if (!frames || frames.length === 0) {
    return !block;
  }
  var frame, filename, url, urlRegex;
  var listLength = list.length;
  var frameLength = frames.length;
  for (var i = 0; i < frameLength; i++) {
    frame = frames[i];
    filename = frame.filename;
    if (!_.isType(filename, 'string')) {
      return !block;
    }
    for (var j = 0; j < listLength; j++) {
      url = list[j];
      urlRegex = new RegExp(url);
      if (urlRegex.test(filename)) {
        return true;
      }
    }
  }
  return false;
}
function urlIsOnAList(item, settings, safeOrBlock, logger) {
  // safelist is the default
  var block = false;
  if (safeOrBlock === 'blocklist') {
    block = true;
  }
  var list, traces;
  try {
    list = block ? settings.hostBlockList : settings.hostSafeList;
    traces = _.get(item, 'body.trace_chain') || [_.get(item, 'body.trace')];

    // These two checks are important to come first as they are defaults
    // in case the list is missing or the trace is missing or not well-formed
    if (!list || list.length === 0) {
      return !block;
    }
    if (traces.length === 0 || !traces[0]) {
      return !block;
    }
    var tracesLength = traces.length;
    for (var i = 0; i < tracesLength; i++) {
      if (matchFrames(traces[i], list, block)) {
        return true;
      }
    }
  } catch (e
  /* istanbul ignore next */) {
    if (block) {
      settings.hostBlockList = null;
    } else {
      settings.hostSafeList = null;
    }
    var listName = block ? 'hostBlockList' : 'hostSafeList';
    logger.error("Error while reading your configuration's " + listName + ' option. Removing custom ' + listName + '.', e);
    return !block;
  }
  return false;
}
function messageIsIgnored(logger) {
  return function (item, settings) {
    var i, j, ignoredMessages, len, messageIsIgnored, rIgnoredMessage, messages;
    try {
      messageIsIgnored = false;
      ignoredMessages = settings.ignoredMessages;
      if (!ignoredMessages || ignoredMessages.length === 0) {
        return true;
      }
      messages = messagesFromItem(item);
      if (messages.length === 0) {
        return true;
      }
      len = ignoredMessages.length;
      for (i = 0; i < len; i++) {
        rIgnoredMessage = new RegExp(ignoredMessages[i], 'gi');
        for (j = 0; j < messages.length; j++) {
          messageIsIgnored = rIgnoredMessage.test(messages[j]);
          if (messageIsIgnored) {
            return false;
          }
        }
      }
    } catch (e
    /* istanbul ignore next */) {
      settings.ignoredMessages = null;
      logger.error("Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.");
    }
    return true;
  };
}
function messagesFromItem(item) {
  var body = item.body;
  var messages = [];

  // The payload schema only allows one of trace_chain, message, or trace.
  // However, existing test cases are based on having both trace and message present.
  // So here we preserve the ability to collect strings from any combination of these keys.
  if (body.trace_chain) {
    var traceChain = body.trace_chain;
    for (var i = 0; i < traceChain.length; i++) {
      var trace = traceChain[i];
      messages.push(_.get(trace, 'exception.message'));
    }
  }
  if (body.trace) {
    messages.push(_.get(body, 'trace.exception.message'));
  }
  if (body.message) {
    messages.push(_.get(body, 'message.body'));
  }
  return messages;
}
module.exports = {
  checkLevel: checkLevel,
  userCheckIgnore: userCheckIgnore,
  urlIsNotBlockListed: urlIsNotBlockListed,
  urlIsSafeListed: urlIsSafeListed,
  messageIsIgnored: messageIsIgnored
};

/***/ }),

/***/ "./src/queue.js":
/*!**********************!*\
  !*** ./src/queue.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * Queue - an object which handles which handles a queue of items to be sent to Rollbar.
 *   This object handles rate limiting via a passed in rate limiter, retries based on connection
 *   errors, and filtering of items based on a set of configurable predicates. The communication to
 *   the backend is performed via a given API object.
 *
 * @param rateLimiter - An object which conforms to the interface
 *    rateLimiter.shouldSend(item) -> bool
 * @param api - An object which conforms to the interface
 *    api.postItem(payload, function(err, response))
 * @param logger - An object used to log verbose messages if desired
 * @param options - see Queue.prototype.configure
 * @param replayMap - Optional ReplayMap for coordinating session replay with error occurrences
 */
function Queue(rateLimiter, api, logger, options, replayMap) {
  this.rateLimiter = rateLimiter;
  this.api = api;
  this.logger = logger;
  this.options = options;
  this.replayMap = replayMap;
  this.predicates = [];
  this.pendingItems = [];
  this.pendingRequests = [];
  this.retryQueue = [];
  this.retryHandle = null;
  this.waitCallback = null;
  this.waitIntervalID = null;
}

/*
 * configure - updates the options this queue uses
 *
 * @param options
 */
Queue.prototype.configure = function (options) {
  this.api && this.api.configure(options);
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  return this;
};

/*
 * addPredicate - adds a predicate to the end of the list of predicates for this queue
 *
 * @param predicate - function(item, options) -> (bool|{err: Error})
 *  Returning true means that this predicate passes and the item is okay to go on the queue
 *  Returning false means do not add the item to the queue, but it is not an error
 *  Returning {err: Error} means do not add the item to the queue, and the given error explains why
 *  Returning {err: undefined} is equivalent to returning true but don't do that
 */
Queue.prototype.addPredicate = function (predicate) {
  if (_.isFunction(predicate)) {
    this.predicates.push(predicate);
  }
  return this;
};
Queue.prototype.addPendingItem = function (item) {
  this.pendingItems.push(item);
};
Queue.prototype.removePendingItem = function (item) {
  var idx = this.pendingItems.indexOf(item);
  if (idx !== -1) {
    this.pendingItems.splice(idx, 1);
  }
};

/*
 * addItem - Send an item to the Rollbar API if all of the predicates are satisfied
 *
 * @param item - The payload to send to the backend
 * @param callback - function(error, repsonse) which will be called with the response from the API
 *  in the case of a success, otherwise response will be null and error will have a value. If both
 *  error and response are null then the item was stopped by a predicate which did not consider this
 *  to be an error condition, but nonetheless did not send the item to the API.
 *  @param originalError - The original error before any transformations that is to be logged if any
 */
Queue.prototype.addItem = function (item, callback, originalError, originalItem) {
  if (!callback || !_.isFunction(callback)) {
    callback = function callback() {
      return;
    };
  }
  var predicateResult = this._applyPredicates(item);
  if (predicateResult.stop) {
    this.removePendingItem(originalItem);
    callback(predicateResult.err);
    return;
  }
  this._maybeLog(item, originalError);
  this.removePendingItem(originalItem);
  if (!this.options.transmit) {
    callback(new Error('Transmit disabled'));
    return;
  }
  if (this.replayMap && item.body) {
    var replayId = this.replayMap.add(item.uuid);
    item.replayId = replayId;
  }
  this.pendingRequests.push(item);
  try {
    this._makeApiRequest(item, function (err, resp) {
      this._dequeuePendingRequest(item);
      if (!err && resp && item.replayId) {
        this._handleReplayResponse(item.replayId, resp);
      }
      callback(err, resp);
    }.bind(this));
  } catch (e) {
    this._dequeuePendingRequest(item);
    callback(e);
  }
};

/*
 * wait - Stop any further errors from being added to the queue, and get called back when all items
 *   currently processing have finished sending to the backend.
 *
 * @param callback - function() called when all pending items have been sent
 */
Queue.prototype.wait = function (callback) {
  if (!_.isFunction(callback)) {
    return;
  }
  this.waitCallback = callback;
  if (this._maybeCallWait()) {
    return;
  }
  if (this.waitIntervalID) {
    this.waitIntervalID = clearInterval(this.waitIntervalID);
  }
  this.waitIntervalID = setInterval(function () {
    this._maybeCallWait();
  }.bind(this), 500);
};

/* _applyPredicates - Sequentially applies the predicates that have been added to the queue to the
 *   given item with the currently configured options.
 *
 * @param item - An item in the queue
 * @returns {stop: bool, err: (Error|null)} - stop being true means do not add item to the queue,
 *   the error value should be passed up to a callbak if we are stopping.
 */
Queue.prototype._applyPredicates = function (item) {
  var p = null;
  for (var i = 0, len = this.predicates.length; i < len; i++) {
    p = this.predicates[i](item, this.options);
    if (!p || p.err !== undefined) {
      return {
        stop: true,
        err: p.err
      };
    }
  }
  return {
    stop: false,
    err: null
  };
};

/*
 * _makeApiRequest - Send an item to Rollbar, callback when done, if there is an error make an
 *   effort to retry if we are configured to do so.
 *
 * @param item - an item ready to send to the backend
 * @param callback - function(err, response)
 */
Queue.prototype._makeApiRequest = function (item, callback) {
  var rateLimitResponse = this.rateLimiter.shouldSend(item);
  if (rateLimitResponse.shouldSend) {
    this.api.postItem(item, function (err, resp) {
      if (err) {
        this._maybeRetry(err, item, callback);
      } else {
        callback(err, resp);
      }
    }.bind(this));
  } else if (rateLimitResponse.error) {
    callback(rateLimitResponse.error);
  } else {
    this.api.postItem(rateLimitResponse.payload, callback);
  }
};

// These are errors basically mean there is no internet connection
var RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE', 'EAI_AGAIN'];

/*
 * _maybeRetry - Given the error returned by the API, decide if we should retry or just callback
 *   with the error.
 *
 * @param err - an error returned by the API transport
 * @param item - the item that was trying to be sent when this error occured
 * @param callback - function(err, response)
 */
Queue.prototype._maybeRetry = function (err, item, callback) {
  var shouldRetry = false;
  if (this.options.retryInterval) {
    for (var i = 0, len = RETRIABLE_ERRORS.length; i < len; i++) {
      if (err.code === RETRIABLE_ERRORS[i]) {
        shouldRetry = true;
        break;
      }
    }
    if (shouldRetry && _.isFiniteNumber(this.options.maxRetries)) {
      item.retries = item.retries ? item.retries + 1 : 1;
      if (item.retries > this.options.maxRetries) {
        shouldRetry = false;
      }
    }
  }
  if (shouldRetry) {
    this._retryApiRequest(item, callback);
  } else {
    callback(err);
  }
};

/*
 * _retryApiRequest - Add an item and a callback to a queue and possibly start a timer to process
 *   that queue based on the retryInterval in the options for this queue.
 *
 * @param item - an item that failed to send due to an error we deem retriable
 * @param callback - function(err, response)
 */
Queue.prototype._retryApiRequest = function (item, callback) {
  this.retryQueue.push({
    item: item,
    callback: callback
  });
  if (!this.retryHandle) {
    this.retryHandle = setInterval(function () {
      while (this.retryQueue.length) {
        var retryObject = this.retryQueue.shift();
        this._makeApiRequest(retryObject.item, retryObject.callback);
      }
    }.bind(this), this.options.retryInterval);
  }
};

/*
 * _dequeuePendingRequest - Removes the item from the pending request queue, this queue is used to
 *   enable to functionality of providing a callback that clients can pass to `wait` to be notified
 *   when the pending request queue has been emptied. This must be called when the API finishes
 *   processing this item. If a `wait` callback is configured, it is called by this function.
 *
 * @param item - the item previously added to the pending request queue
 */
Queue.prototype._dequeuePendingRequest = function (item) {
  var idx = this.pendingRequests.indexOf(item);
  if (idx !== -1) {
    this.pendingRequests.splice(idx, 1);
    this._maybeCallWait();
  }
};
Queue.prototype._maybeLog = function (data, originalError) {
  if (this.logger && this.options.verbose) {
    var message = originalError;
    message = message || _.get(data, 'body.trace.exception.message');
    message = message || _.get(data, 'body.trace_chain.0.exception.message');
    if (message) {
      this.logger.error(message);
      return;
    }
    message = _.get(data, 'body.message.body');
    if (message) {
      this.logger.log(message);
    }
  }
};
Queue.prototype._maybeCallWait = function () {
  if (_.isFunction(this.waitCallback) && this.pendingItems.length === 0 && this.pendingRequests.length === 0) {
    if (this.waitIntervalID) {
      this.waitIntervalID = clearInterval(this.waitIntervalID);
    }
    this.waitCallback();
    return true;
  }
  return false;
};

/**
 * Handles the API response for an item with a replay ID.
 * Based on the success or failure status of the response,
 * it either sends or discards the associated session replay.
 *
 * @param {string} replayId - The ID of the replay to handle
 * @param {Object} response - The API response
 * @returns {Promise<boolean>} A promise that resolves to true if replay was sent successfully,
 *                             false if replay was discarded or an error occurred
 * @private
 */
Queue.prototype._handleReplayResponse = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(replayId, response) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (this.replayMap) {
            _context.next = 3;
            break;
          }
          console.warn('Queue._handleReplayResponse: ReplayMap not available');
          return _context.abrupt("return", false);
        case 3:
          if (replayId) {
            _context.next = 6;
            break;
          }
          console.warn('Queue._handleReplayResponse: No replayId provided');
          return _context.abrupt("return", false);
        case 6:
          _context.prev = 6;
          if (!(response && response.err === 0)) {
            _context.next = 14;
            break;
          }
          _context.next = 10;
          return this.replayMap.send(replayId);
        case 10:
          result = _context.sent;
          return _context.abrupt("return", result);
        case 14:
          this.replayMap.discard(replayId);
          return _context.abrupt("return", false);
        case 16:
          _context.next = 22;
          break;
        case 18:
          _context.prev = 18;
          _context.t0 = _context["catch"](6);
          console.error('Error handling replay response:', _context.t0);
          return _context.abrupt("return", false);
        case 22:
        case "end":
          return _context.stop();
      }
    }, _callee, this, [[6, 18]]);
  }));
  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
module.exports = Queue;

/***/ }),

/***/ "./src/rateLimiter.js":
/*!****************************!*\
  !*** ./src/rateLimiter.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * RateLimiter - an object that encapsulates the logic for counting items sent to Rollbar
 *
 * @param options - the same options that are accepted by configureGlobal offered as a convenience
 */
function RateLimiter(options) {
  this.startTime = _.now();
  this.counter = 0;
  this.perMinCounter = 0;
  this.platform = null;
  this.platformOptions = {};
  this.configureGlobal(options);
}
RateLimiter.globalSettings = {
  startTime: _.now(),
  maxItems: undefined,
  itemsPerMinute: undefined
};

/*
 * configureGlobal - set the global rate limiter options
 *
 * @param options - Only the following values are recognized:
 *    startTime: a timestamp of the form returned by (new Date()).getTime()
 *    maxItems: the maximum items
 *    itemsPerMinute: the max number of items to send in a given minute
 */
RateLimiter.prototype.configureGlobal = function (options) {
  if (options.startTime !== undefined) {
    RateLimiter.globalSettings.startTime = options.startTime;
  }
  if (options.maxItems !== undefined) {
    RateLimiter.globalSettings.maxItems = options.maxItems;
  }
  if (options.itemsPerMinute !== undefined) {
    RateLimiter.globalSettings.itemsPerMinute = options.itemsPerMinute;
  }
};

/*
 * shouldSend - determine if we should send a given item based on rate limit settings
 *
 * @param item - the item we are about to send
 * @returns An object with the following structure:
 *  error: (Error|null)
 *  shouldSend: bool
 *  payload: (Object|null)
 *  If shouldSend is false, the item passed as a parameter should not be sent to Rollbar, and
 *  exactly one of error or payload will be non-null. If error is non-null, the returned Error will
 *  describe the situation, but it means that we were already over a rate limit (either globally or
 *  per minute) when this item was checked. If error is null, and therefore payload is non-null, it
 *  means this item put us over the global rate limit and the payload should be sent to Rollbar in
 *  place of the passed in item.
 */
RateLimiter.prototype.shouldSend = function (item, now) {
  now = now || _.now();
  var elapsedTime = now - this.startTime;
  if (elapsedTime < 0 || elapsedTime >= 60000) {
    this.startTime = now;
    this.perMinCounter = 0;
  }
  var globalRateLimit = RateLimiter.globalSettings.maxItems;
  var globalRateLimitPerMin = RateLimiter.globalSettings.itemsPerMinute;
  if (checkRate(item, globalRateLimit, this.counter)) {
    return shouldSendValue(this.platform, this.platformOptions, globalRateLimit + ' max items reached', false);
  } else if (checkRate(item, globalRateLimitPerMin, this.perMinCounter)) {
    return shouldSendValue(this.platform, this.platformOptions, globalRateLimitPerMin + ' items per minute reached', false);
  }
  this.counter++;
  this.perMinCounter++;
  var shouldSend = !checkRate(item, globalRateLimit, this.counter);
  var perMinute = shouldSend;
  shouldSend = shouldSend && !checkRate(item, globalRateLimitPerMin, this.perMinCounter);
  return shouldSendValue(this.platform, this.platformOptions, null, shouldSend, globalRateLimit, globalRateLimitPerMin, perMinute);
};
RateLimiter.prototype.setPlatformOptions = function (platform, options) {
  this.platform = platform;
  this.platformOptions = options;
};

/* Helpers */

function checkRate(item, limit, counter) {
  return !item.ignoreRateLimit && limit >= 1 && counter > limit;
}
function shouldSendValue(platform, options, error, shouldSend, globalRateLimit, limitPerMin, perMinute) {
  var payload = null;
  if (error) {
    error = new Error(error);
  }
  if (!error && !shouldSend) {
    payload = rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute);
  }
  return {
    error: error,
    shouldSend: shouldSend,
    payload: payload
  };
}
function rateLimitPayload(platform, options, globalRateLimit, limitPerMin, perMinute) {
  var environment = options.environment || options.payload && options.payload.environment;
  var msg;
  if (perMinute) {
    msg = 'item per minute limit reached, ignoring errors until timeout';
  } else {
    msg = 'maxItems has been hit, ignoring errors until reset.';
  }
  var item = {
    body: {
      message: {
        body: msg,
        extra: {
          maxItems: globalRateLimit,
          itemsPerMinute: limitPerMin
        }
      }
    },
    language: 'javascript',
    environment: environment,
    notifier: {
      version: options.notifier && options.notifier.version || options.version
    }
  };
  if (platform === 'browser') {
    item.platform = 'browser';
    item.framework = 'browser-js';
    item.notifier.name = 'rollbar-browser-js';
  } else if (platform === 'server') {
    item.framework = options.framework || 'node-js';
    item.notifier.name = options.notifier.name;
  } else if (platform === 'react-native') {
    item.framework = options.framework || 'react-native';
    item.notifier.name = options.notifier.name;
  }
  return item;
}
module.exports = RateLimiter;

/***/ }),

/***/ "./src/rollbar.js":
/*!************************!*\
  !*** ./src/rollbar.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var RateLimiter = __webpack_require__(/*! ./rateLimiter */ "./src/rateLimiter.js");
var Queue = __webpack_require__(/*! ./queue */ "./src/queue.js");
var Notifier = __webpack_require__(/*! ./notifier */ "./src/notifier.js");
var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");

/*
 * Rollbar - the interface to Rollbar
 *
 * @param options
 * @param api
 * @param logger
 */
function Rollbar(options, api, logger, telemeter, tracing, replayMap, platform) {
  this.options = _.merge(options);
  this.logger = logger;
  Rollbar.rateLimiter.configureGlobal(this.options);
  Rollbar.rateLimiter.setPlatformOptions(platform, this.options);
  this.api = api;
  this.queue = new Queue(Rollbar.rateLimiter, api, logger, this.options, replayMap);
  this.tracing = tracing;

  // Legacy OpenTracing support
  // This must happen before the Notifier is created
  var tracer = this.options.tracer || null;
  if (validateTracer(tracer)) {
    this.tracer = tracer;
    // set to a string for api response serialization
    this.options.tracer = 'opentracing-tracer-enabled';
    this.options._configuredOptions.tracer = 'opentracing-tracer-enabled';
  } else {
    this.tracer = null;
  }
  this.notifier = new Notifier(this.queue, this.options);
  this.telemeter = telemeter;
  setStackTraceLimit(options);
  this.lastError = null;
  this.lastErrorHash = 'none';
}
var defaultOptions = {
  maxItems: 0,
  itemsPerMinute: 60
};
Rollbar.rateLimiter = new RateLimiter(defaultOptions);
Rollbar.prototype.global = function (options) {
  Rollbar.rateLimiter.configureGlobal(options);
  return this;
};
Rollbar.prototype.configure = function (options, payloadData) {
  var oldOptions = this.options;
  var payload = {};
  if (payloadData) {
    payload = {
      payload: payloadData
    };
  }
  this.options = _.merge(oldOptions, options, payload);

  // Legacy OpenTracing support
  // This must happen before the Notifier is configured
  var tracer = this.options.tracer || null;
  if (validateTracer(tracer)) {
    this.tracer = tracer;
    // set to a string for api response serialization
    this.options.tracer = 'opentracing-tracer-enabled';
    this.options._configuredOptions.tracer = 'opentracing-tracer-enabled';
  } else {
    this.tracer = null;
  }
  this.notifier && this.notifier.configure(this.options);
  this.telemeter && this.telemeter.configure(this.options);
  setStackTraceLimit(options);
  this.global(this.options);
  if (validateTracer(options.tracer)) {
    this.tracer = options.tracer;
  }
  return this;
};
Rollbar.prototype.log = function (item) {
  var level = this._defaultLogLevel();
  return this._log(level, item);
};
Rollbar.prototype.debug = function (item) {
  this._log('debug', item);
};
Rollbar.prototype.info = function (item) {
  this._log('info', item);
};
Rollbar.prototype.warn = function (item) {
  this._log('warning', item);
};
Rollbar.prototype.warning = function (item) {
  this._log('warning', item);
};
Rollbar.prototype.error = function (item) {
  this._log('error', item);
};
Rollbar.prototype.critical = function (item) {
  this._log('critical', item);
};
Rollbar.prototype.wait = function (callback) {
  this.queue.wait(callback);
};
Rollbar.prototype.captureEvent = function (type, metadata, level) {
  return this.telemeter && this.telemeter.captureEvent(type, metadata, level);
};
Rollbar.prototype.captureDomContentLoaded = function (ts) {
  return this.telemeter && this.telemeter.captureDomContentLoaded(ts);
};
Rollbar.prototype.captureLoad = function (ts) {
  return this.telemeter && this.telemeter.captureLoad(ts);
};
Rollbar.prototype.buildJsonPayload = function (item) {
  return this.api.buildJsonPayload(item);
};
Rollbar.prototype.sendJsonPayload = function (jsonPayload) {
  this.api.postJsonPayload(jsonPayload);
};

/* Internal */

Rollbar.prototype._log = function (defaultLevel, item) {
  var callback;
  if (item.callback) {
    callback = item.callback;
    delete item.callback;
  }
  if (this.options.ignoreDuplicateErrors && this._sameAsLastError(item)) {
    if (callback) {
      var error = new Error('ignored identical item');
      error.item = item;
      callback(error);
    }
    return;
  }
  try {
    this._addTracingAttributes(item);

    // Legacy OpenTracing support
    this._addTracingInfo(item);
    item.level = item.level || defaultLevel;
    var telemeter = this.telemeter;
    if (telemeter) {
      telemeter._captureRollbarItem(item);
      item.telemetryEvents = telemeter.copyEvents() || [];
      if (telemeter.telemetrySpan) {
        telemeter.telemetrySpan.end();
        telemeter.telemetrySpan = telemeter.tracing.startSpan('rollbar-telemetry', {});
      }
    }
    this.notifier.log(item, callback);
  } catch (e) {
    if (callback) {
      callback(e);
    }
    this.logger.error(e);
  }
};
Rollbar.prototype._addTracingAttributes = function (item) {
  var _this$tracing;
  var span = (_this$tracing = this.tracing) === null || _this$tracing === void 0 ? void 0 : _this$tracing.getSpan();
  if (!span) {
    return;
  }
  var attributes = [{
    key: 'session_id',
    value: this.tracing.sessionId
  }, {
    key: 'span_id',
    value: span.spanId
  }, {
    key: 'trace_id',
    value: span.traceId
  }];
  _.addItemAttributes(item, attributes);
  span.addEvent('rollbar.occurrence', [{
    key: 'rollbar.occurrence.uuid',
    value: item.uuid
  }]);
};
Rollbar.prototype._defaultLogLevel = function () {
  return this.options.logLevel || 'debug';
};
Rollbar.prototype._sameAsLastError = function (item) {
  if (!item._isUncaught) {
    return false;
  }
  var itemHash = generateItemHash(item);
  if (this.lastErrorHash === itemHash) {
    return true;
  }
  this.lastError = item.err;
  this.lastErrorHash = itemHash;
  return false;
};
Rollbar.prototype._addTracingInfo = function (item) {
  // Tracer validation occurs in the constructor
  // or in the Rollbar.prototype.configure methods
  if (this.tracer) {
    // add rollbar occurrence uuid to span
    var span = this.tracer.scope().active();
    if (validateSpan(span)) {
      span.setTag('rollbar.error_uuid', item.uuid);
      span.setTag('rollbar.has_error', true);
      span.setTag('error', true);
      span.setTag('rollbar.item_url', "https://rollbar.com/item/uuid/?uuid=".concat(item.uuid));
      span.setTag('rollbar.occurrence_url', "https://rollbar.com/occurrence/uuid/?uuid=".concat(item.uuid));

      // add span ID & trace ID to occurrence
      var opentracingSpanId = span.context().toSpanId();
      var opentracingTraceId = span.context().toTraceId();
      if (item.custom) {
        item.custom.opentracing_span_id = opentracingSpanId;
        item.custom.opentracing_trace_id = opentracingTraceId;
      } else {
        item.custom = {
          opentracing_span_id: opentracingSpanId,
          opentracing_trace_id: opentracingTraceId
        };
      }
    }
  }
};
function generateItemHash(item) {
  var message = item.message || '';
  var stack = (item.err || {}).stack || String(item.err);
  return message + '::' + stack;
}

// Node.js, Chrome, Safari, and some other browsers support this property
// which globally sets the number of stack frames returned in an Error object.
// If a browser can't use it, no harm done.
function setStackTraceLimit(options) {
  if (options.stackTraceLimit) {
    Error.stackTraceLimit = options.stackTraceLimit;
  }
}

/**
 * Validate the Tracer object provided to the Client
 * is valid for our Opentracing use case.
 * @param {opentracer.Tracer} tracer
 */
function validateTracer(tracer) {
  if (!tracer) {
    return false;
  }
  if (!tracer.scope || typeof tracer.scope !== 'function') {
    return false;
  }
  var scope = tracer.scope();
  if (!scope || !scope.active || typeof scope.active !== 'function') {
    return false;
  }
  return true;
}

/**
 * Validate the Span object provided
 * @param {opentracer.Span} span
 */
function validateSpan(span) {
  if (!span || !span.context || typeof span.context !== 'function') {
    return false;
  }
  var spanContext = span.context();
  if (!spanContext || !spanContext.toSpanId || !spanContext.toTraceId || typeof spanContext.toSpanId !== 'function' || typeof spanContext.toTraceId !== 'function') {
    return false;
  }
  return true;
}
module.exports = Rollbar;

/***/ }),

/***/ "./src/scrub.js":
/*!**********************!*\
  !*** ./src/scrub.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var traverse = __webpack_require__(/*! ./utility/traverse */ "./src/utility/traverse.js");
function scrub(data, scrubFields, scrubPaths) {
  scrubFields = scrubFields || [];
  if (scrubPaths) {
    for (var i = 0; i < scrubPaths.length; ++i) {
      scrubPath(data, scrubPaths[i]);
    }
  }
  var paramRes = _getScrubFieldRegexs(scrubFields);
  var queryRes = _getScrubQueryParamRegexs(scrubFields);
  function redactQueryParam(dummy0, paramPart) {
    return paramPart + _.redact();
  }
  function paramScrubber(v) {
    var i;
    if (_.isType(v, 'string')) {
      for (i = 0; i < queryRes.length; ++i) {
        v = v.replace(queryRes[i], redactQueryParam);
      }
    }
    return v;
  }
  function valScrubber(k, v) {
    var i;
    for (i = 0; i < paramRes.length; ++i) {
      if (paramRes[i].test(k)) {
        v = _.redact();
        break;
      }
    }
    return v;
  }
  function scrubber(k, v, seen) {
    var tmpV = valScrubber(k, v);
    if (tmpV === v) {
      if (_.isType(v, 'object') || _.isType(v, 'array')) {
        return traverse(v, scrubber, seen);
      }
      return paramScrubber(tmpV);
    } else {
      return tmpV;
    }
  }
  return traverse(data, scrubber);
}
function scrubPath(obj, path) {
  var keys = path.split('.');
  var last = keys.length - 1;
  try {
    for (var i = 0; i <= last; ++i) {
      if (i < last) {
        obj = obj[keys[i]];
      } else {
        obj[keys[i]] = _.redact();
      }
    }
  } catch (e) {
    // Missing key is OK;
  }
}
function _getScrubFieldRegexs(scrubFields) {
  var ret = [];
  var pat;
  for (var i = 0; i < scrubFields.length; ++i) {
    pat = '^\\[?(%5[bB])?' + scrubFields[i] + '\\[?(%5[bB])?\\]?(%5[dD])?$';
    ret.push(new RegExp(pat, 'i'));
  }
  return ret;
}
function _getScrubQueryParamRegexs(scrubFields) {
  var ret = [];
  var pat;
  for (var i = 0; i < scrubFields.length; ++i) {
    pat = '\\[?(%5[bB])?' + scrubFields[i] + '\\[?(%5[bB])?\\]?(%5[dD])?';
    ret.push(new RegExp('(' + pat + '=)([^&\\n]+)', 'igm'));
  }
  return ret;
}
module.exports = scrub;

/***/ }),

/***/ "./src/telemetry.js":
/*!**************************!*\
  !*** ./src/telemetry.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var MAX_EVENTS = 100;

// Temporary workaround while solving commonjs -> esm issues in Node 18 - 20.
function fromMillis(millis) {
  return [Math.trunc(millis / 1000), Math.round(millis % 1000 * 1e6)];
}
function Telemeter(options, tracing) {
  var _this$tracing;
  this.queue = [];
  this.options = _.merge(options);
  var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
  this.maxQueueSize = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
  this.tracing = tracing;
  this.telemetrySpan = (_this$tracing = this.tracing) === null || _this$tracing === void 0 ? void 0 : _this$tracing.startSpan('rollbar-telemetry', {});
}
Telemeter.prototype.configure = function (options) {
  var oldOptions = this.options;
  this.options = _.merge(oldOptions, options);
  var maxTelemetryEvents = this.options.maxTelemetryEvents || MAX_EVENTS;
  var newMaxEvents = Math.max(0, Math.min(maxTelemetryEvents, MAX_EVENTS));
  var deleteCount = 0;
  if (this.queue.length > newMaxEvents) {
    deleteCount = this.queue.length - newMaxEvents;
  }
  this.maxQueueSize = newMaxEvents;
  this.queue.splice(0, deleteCount);
};
Telemeter.prototype.copyEvents = function () {
  var events = Array.prototype.slice.call(this.queue, 0);
  if (_.isFunction(this.options.filterTelemetry)) {
    try {
      var i = events.length;
      while (i--) {
        if (this.options.filterTelemetry(events[i])) {
          events.splice(i, 1);
        }
      }
    } catch (e) {
      this.options.filterTelemetry = null;
    }
  }
  return events;
};
Telemeter.prototype.capture = function (type, metadata, level, rollbarUUID, timestamp) {
  var e = {
    level: getLevel(type, level),
    type: type,
    timestamp_ms: timestamp || _.now(),
    body: metadata,
    source: 'client'
  };
  if (rollbarUUID) {
    e.uuid = rollbarUUID;
  }
  try {
    if (_.isFunction(this.options.filterTelemetry) && this.options.filterTelemetry(e)) {
      return false;
    }
  } catch (exc) {
    this.options.filterTelemetry = null;
  }
  this.push(e);
  return e;
};
Telemeter.prototype.captureEvent = function (type, metadata, level, rollbarUUID) {
  return this.capture(type, metadata, level, rollbarUUID);
};
Telemeter.prototype.captureError = function (err, level, rollbarUUID, timestamp) {
  var _this$telemetrySpan;
  var message = err.message || String(err);
  var metadata = {
    message: message
  };
  if (err.stack) {
    metadata.stack = err.stack;
  }
  (_this$telemetrySpan = this.telemetrySpan) === null || _this$telemetrySpan === void 0 || _this$telemetrySpan.addEvent('rollbar-occurrence-event', {
    message: message,
    level: level,
    type: 'error',
    uuid: rollbarUUID,
    'occurrence.type': 'error',
    // deprecated
    'occurrence.uuid': rollbarUUID // deprecated
  }, fromMillis(timestamp));
  return this.capture('error', metadata, level, rollbarUUID, timestamp);
};
Telemeter.prototype.captureLog = function (message, level, rollbarUUID, timestamp) {
  // If the uuid is present, this is a message occurrence.
  if (rollbarUUID) {
    var _this$telemetrySpan2;
    (_this$telemetrySpan2 = this.telemetrySpan) === null || _this$telemetrySpan2 === void 0 || _this$telemetrySpan2.addEvent('rollbar-occurrence-event', {
      message: message,
      level: level,
      type: 'message',
      uuid: rollbarUUID,
      'occurrence.type': 'message',
      // deprecated
      'occurrence.uuid': rollbarUUID // deprecated
    }, fromMillis(timestamp));
  } else {
    var _this$telemetrySpan3;
    (_this$telemetrySpan3 = this.telemetrySpan) === null || _this$telemetrySpan3 === void 0 || _this$telemetrySpan3.addEvent('log-event', {
      message: message,
      level: level
    }, fromMillis(timestamp));
  }
  return this.capture('log', {
    message: message
  }, level, rollbarUUID, timestamp);
};
Telemeter.prototype.captureNetwork = function (metadata, subtype, rollbarUUID, requestData) {
  subtype = subtype || 'xhr';
  metadata.subtype = metadata.subtype || subtype;
  if (requestData) {
    metadata.request = requestData;
  }
  var level = this.levelFromStatus(metadata.status_code);
  return this.capture('network', metadata, level, rollbarUUID);
};
Telemeter.prototype.levelFromStatus = function (statusCode) {
  if (statusCode >= 200 && statusCode < 400) {
    return 'info';
  }
  if (statusCode === 0 || statusCode >= 400) {
    return 'error';
  }
  return 'info';
};
Telemeter.prototype.captureDom = function (subtype, element, value, checked, rollbarUUID) {
  var metadata = {
    subtype: subtype,
    element: element
  };
  if (value !== undefined) {
    metadata.value = value;
  }
  if (checked !== undefined) {
    metadata.checked = checked;
  }
  return this.capture('dom', metadata, 'info', rollbarUUID);
};
Telemeter.prototype.captureNavigation = function (from, to, rollbarUUID, timestamp) {
  var _this$telemetrySpan4;
  (_this$telemetrySpan4 = this.telemetrySpan) === null || _this$telemetrySpan4 === void 0 || _this$telemetrySpan4.addEvent('session-navigation-event', {
    'previous.url.full': from,
    'url.full': to
  }, fromMillis(timestamp));
  return this.capture('navigation', {
    from: from,
    to: to
  }, 'info', rollbarUUID, timestamp);
};
Telemeter.prototype.captureDomContentLoaded = function (ts) {
  return this.capture('navigation', {
    subtype: 'DOMContentLoaded'
  }, 'info', undefined, ts && ts.getTime());
  /**
   * If we decide to make this a dom event instead, then use the line below:
  return this.capture('dom', {subtype: 'DOMContentLoaded'}, 'info', undefined, ts && ts.getTime());
  */
};
Telemeter.prototype.captureLoad = function (ts) {
  return this.capture('navigation', {
    subtype: 'load'
  }, 'info', undefined, ts && ts.getTime());
  /**
   * If we decide to make this a dom event instead, then use the line below:
  return this.capture('dom', {subtype: 'load'}, 'info', undefined, ts && ts.getTime());
  */
};
Telemeter.prototype.captureConnectivityChange = function (type, rollbarUUID) {
  return this.captureNetwork({
    change: type
  }, 'connectivity', rollbarUUID);
};

// Only intended to be used internally by the notifier
Telemeter.prototype._captureRollbarItem = function (item) {
  if (!this.options.includeItemsInTelemetry) {
    return;
  }
  if (item.err) {
    return this.captureError(item.err, item.level, item.uuid, item.timestamp);
  }
  if (item.message) {
    return this.captureLog(item.message, item.level, item.uuid, item.timestamp);
  }
  if (item.custom) {
    return this.capture('log', item.custom, item.level, item.uuid, item.timestamp);
  }
};
Telemeter.prototype.push = function (e) {
  this.queue.push(e);
  if (this.queue.length > this.maxQueueSize) {
    this.queue.shift();
  }
};
function getLevel(type, level) {
  if (level) {
    return level;
  }
  var defaultLevel = {
    error: 'error',
    manual: 'info'
  };
  return defaultLevel[type] || 'info';
}
module.exports = Telemeter;

/***/ }),

/***/ "./src/tracing/context.js":
/*!********************************!*\
  !*** ./src/tracing/context.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Context: () => (/* binding */ Context),
/* harmony export */   ROOT_CONTEXT: () => (/* binding */ ROOT_CONTEXT)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Context = /*#__PURE__*/function () {
  function Context(parentContext) {
    _classCallCheck(this, Context);
    this._currentContext = parentContext ? new Map(parentContext) : new Map();
  }
  return _createClass(Context, [{
    key: "getValue",
    value: function getValue(key) {
      return this._currentContext.get(key);
    }
  }, {
    key: "setValue",
    value: function setValue(key, value) {
      var context = new Context(this._currentContext);
      context._currentContext.set(key, value);
      return context;
    }
  }, {
    key: "deleteValue",
    value: function deleteValue(key) {
      var context = new Context(self._currentContext);
      context._currentContext["delete"](key);
      return context;
    }
  }]);
}();
var ROOT_CONTEXT = new Context();

/***/ }),

/***/ "./src/tracing/contextManager.js":
/*!***************************************!*\
  !*** ./src/tracing/contextManager.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContextManager: () => (/* binding */ ContextManager),
/* harmony export */   createContextKey: () => (/* binding */ createContextKey)
/* harmony export */ });
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ "./src/tracing/context.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var ContextManager = /*#__PURE__*/function () {
  function ContextManager() {
    _classCallCheck(this, ContextManager);
    this.currentContext = _context_js__WEBPACK_IMPORTED_MODULE_0__.ROOT_CONTEXT;
  }
  return _createClass(ContextManager, [{
    key: "active",
    value: function active() {
      return this.currentContext;
    }
  }, {
    key: "enterContext",
    value: function enterContext(context) {
      var previousContext = this.currentContext;
      this.currentContext = context || _context_js__WEBPACK_IMPORTED_MODULE_0__.ROOT_CONTEXT;
      return previousContext;
    }
  }, {
    key: "exitContext",
    value: function exitContext(context) {
      this.currentContext = context;
      return this.currentContext;
    }
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var previousContext = this.enterContext(context);
      try {
        for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          args[_key - 3] = arguments[_key];
        }
        return fn.call.apply(fn, [thisArg].concat(args));
      } finally {
        this.exitContext(previousContext);
      }
    }
  }]);
}();
function createContextKey(key) {
  // Use Symbol for OpenTelemetry compatibility.
  return Symbol["for"](key);
}

/***/ }),

/***/ "./src/tracing/defaults.js":
/*!*********************************!*\
  !*** ./src/tracing/defaults.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Default tracing options
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  enabled: false,
  endpoint: 'api.rollbar.com/api/1/session/'
});

/***/ }),

/***/ "./src/tracing/exporter.js":
/*!*********************************!*\
  !*** ./src/tracing/exporter.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpanExporter: () => (/* binding */ SpanExporter),
/* harmony export */   spanExportQueue: () => (/* binding */ spanExportQueue)
/* harmony export */ });
/* harmony import */ var _hrtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hrtime */ "./src/tracing/hrtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


/**
 * SpanExporter is responsible for exporting ReadableSpan objects
 * and transforming them into the OTLP-compatible format.
 */
var SpanExporter = /*#__PURE__*/function () {
  function SpanExporter() {
    _classCallCheck(this, SpanExporter);
  }
  return _createClass(SpanExporter, [{
    key: "export",
    value:
    /**
     * Export spans to the span export queue
     *
     * @param {Array} spans - Array of ReadableSpan objects to export
     * @param {Function} _resultCallback - Optional callback (not used)
     */
    function _export(spans, _resultCallback) {
      console.log(spans); // console exporter, TODO: make optional
      spanExportQueue.push.apply(spanExportQueue, _toConsumableArray(spans));
    }

    /**
     * Transforms an array of ReadableSpan objects into the OTLP format payload
     * compatible with the Rollbar API. This follows the OpenTelemetry protocol
     * specification for traces.
     *
     * @returns {Object} OTLP format payload for API transmission
     */
  }, {
    key: "toPayload",
    value: function toPayload() {
      var _this = this;
      var spans = spanExportQueue.slice();
      spanExportQueue.length = 0;
      if (!spans || !spans.length) {
        return {
          resourceSpans: []
        };
      }
      var resource = spans[0] && spans[0].resource || {};
      var scopeMap = new Map();
      var _iterator = _createForOfIteratorHelper(spans),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var span = _step.value;
          var scopeKey = span.instrumentationScope ? "".concat(span.instrumentationScope.name, ":").concat(span.instrumentationScope.version) : 'default:1.0.0';
          if (!scopeMap.has(scopeKey)) {
            scopeMap.set(scopeKey, {
              scope: span.instrumentationScope || {
                name: 'default',
                version: '1.0.0',
                attributes: []
              },
              spans: []
            });
          }
          scopeMap.get(scopeKey).spans.push(this._transformSpan(span));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        resourceSpans: [{
          resource: this._transformResource(resource),
          scopeSpans: Array.from(scopeMap.values()).map(function (scopeData) {
            return {
              scope: _this._transformInstrumentationScope(scopeData.scope),
              spans: scopeData.spans
            };
          })
        }]
      };
    }

    /**
     * Transforms a ReadableSpan into the OTLP Span format
     *
     * @private
     * @param {Object} span - ReadableSpan object to transform
     * @returns {Object} OTLP Span format
     */
  }, {
    key: "_transformSpan",
    value: function _transformSpan(span) {
      var _this2 = this;
      var transformAttributes = function transformAttributes(attributes) {
        return Object.entries(attributes || {}).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return {
            key: key,
            value: _this2._transformAnyValue(value)
          };
        });
      };
      var transformEvents = function transformEvents(events) {
        return (events || []).map(function (event) {
          return {
            timeUnixNano: _hrtime__WEBPACK_IMPORTED_MODULE_0__["default"].toNanos(event.time),
            name: event.name,
            attributes: transformAttributes(event.attributes)
          };
        });
      };
      return {
        traceId: span.spanContext.traceId,
        spanId: span.spanContext.spanId,
        parentSpanId: span.parentSpanId || '',
        name: span.name,
        kind: span.kind || 1,
        // INTERNAL by default
        startTimeUnixNano: _hrtime__WEBPACK_IMPORTED_MODULE_0__["default"].toNanos(span.startTime),
        endTimeUnixNano: _hrtime__WEBPACK_IMPORTED_MODULE_0__["default"].toNanos(span.endTime),
        attributes: transformAttributes(span.attributes),
        events: transformEvents(span.events)
      };
    }

    /**
     * Transforms a resource object into OTLP Resource format
     *
     * @private
     * @param {Object} resource - Resource information
     * @returns {Object} OTLP Resource format
     */
  }, {
    key: "_transformResource",
    value: function _transformResource(resource) {
      var _this3 = this;
      var attributes = resource.attributes || {};
      var keyValues = Object.entries(attributes).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];
        return {
          key: key,
          value: _this3._transformAnyValue(value)
        };
      });
      return {
        attributes: keyValues
      };
    }

    /**
     * Transforms an instrumentation scope into OTLP InstrumentationScope format
     *
     * @private
     * @param {Object} scope - Instrumentation scope information
     * @returns {Object} OTLP InstrumentationScope format
     */
  }, {
    key: "_transformInstrumentationScope",
    value: function _transformInstrumentationScope(scope) {
      var _this4 = this;
      return {
        name: scope.name || '',
        version: scope.version || '',
        attributes: (scope.attributes || []).map(function (attr) {
          return {
            key: attr.key,
            value: _this4._transformAnyValue(attr.value)
          };
        })
      };
    }

    /**
     * Transforms a JavaScript value into an OTLP AnyValue
     *
     * @private
     * @param {any} value - Value to transform
     * @returns {Object} OTLP AnyValue format
     */
  }, {
    key: "_transformAnyValue",
    value: function _transformAnyValue(value) {
      var _this5 = this;
      if (value === null || value === undefined) {
        return {
          stringValue: ''
        };
      }
      var type = _typeof(value);
      if (type === 'string') {
        return {
          stringValue: value
        };
      } else if (type === 'number') {
        if (Number.isInteger(value)) {
          return {
            intValue: value.toString()
          };
        } else {
          return {
            doubleValue: value
          };
        }
      } else if (type === 'boolean') {
        return {
          boolValue: value
        };
      } else if (Array.isArray(value)) {
        return {
          arrayValue: {
            values: value.map(function (v) {
              return _this5._transformAnyValue(v);
            })
          }
        };
      } else if (type === 'object') {
        return {
          kvlistValue: {
            values: Object.entries(value).map(function (_ref5) {
              var _ref6 = _slicedToArray(_ref5, 2),
                k = _ref6[0],
                v = _ref6[1];
              return {
                key: k,
                value: _this5._transformAnyValue(v)
              };
            })
          }
        };
      }
      return {
        stringValue: String(value)
      };
    }
  }]);
}();
var spanExportQueue = [];

/***/ }),

/***/ "./src/tracing/hrtime.js":
/*!*******************************!*\
  !*** ./src/tracing/hrtime.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module hrtime
 *
 * @description Methods for handling OpenTelemetry hrtime.
 */

/**
 * Convert a duration in milliseconds to an OpenTelemetry hrtime tuple.
 *
 * @param {number} millis - The duration in milliseconds.
 * @returns {[number, number]} An array where the first element is seconds
 *   and the second is nanoseconds.
 */
function fromMillis(millis) {
  return [Math.trunc(millis / 1000), Math.round(millis % 1000 * 1e6)];
}

/**
 * Convert an OpenTelemetry hrtime tuple back to a duration in milliseconds.
 *
 * @param {[number, number]} hrtime - The hrtime tuple [seconds, nanoseconds].
 * @returns {number} The total duration in milliseconds.
 */
function toMillis(hrtime) {
  return hrtime[0] * 1e3 + Math.round(hrtime[1] / 1e6);
}

/**
 * Convert an OpenTelemetry hrtime tuple back to a duration in nanoseconds.
 *
 * @param {[number, number]} hrtime - The hrtime tuple [seconds, nanoseconds].
 * @returns {number} The total duration in nanoseconds.
 */
function toNanos(hrtime) {
  return hrtime[0] * 1e9 + hrtime[1];
}

/**
 * Adds two OpenTelemetry hrtime tuples.
 *
 * @param {[number, number]} a - The first hrtime tuple [s, ns].
 * @param {[number, number]} b - The second hrtime tuple [s, ns].
 * @returns {[number, number]} Summed hrtime tuple, normalized.
 *
 */
function add(a, b) {
  return [a[0] + b[0] + Math.trunc((a[1] + b[1]) / 1e9), (a[1] + b[1]) % 1e9];
}

/**
 * Get the current high-resolution time as an OpenTelemetry hrtime tuple.
 *
 * Uses the Performance API (timeOrigin + now()).
 *
 * @returns {[number, number]} The current hrtime tuple [s, ns].
 */
function now() {
  return add(fromMillis(performance.timeOrigin), fromMillis(performance.now()));
}

/**
 * Check if a value is a valid OpenTelemetry hrtime tuple.
 *
 * An hrtime tuple is an Array of exactly two numbers:
 *   [seconds, nanoseconds]
 *
 * @param {*} value  anything to test
 * @returns {boolean} true if `value` is a [number, number] array of length 2
 *
 * @example
 * isHrTime([ 1, 500 ]);         // true
 * isHrTime([ 0, 1e9 ]);         // true
 * isHrTime([ '1', 500 ]);       // false
 * isHrTime({ 0: 1, 1: 500 });   // false
 */
function isHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';
}

/**
 * Methods for handling hrtime. OpenTelemetry uses the [seconds, nanoseconds]
 * format for hrtime in the `ReadableSpan` interface.
 *
 * @example
 * import hrtime from '@tracing/hrtime.js';
 *
 * hrtime.fromMillis(1000);
 * hrtime.toMillis([0, 1000]);
 * hrtime.add([0, 0], [0, 1000]);
 * hrtime.now();
 * hrtime.isHrTime([0, 1000]);
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  fromMillis: fromMillis,
  toMillis: toMillis,
  toNanos: toNanos,
  add: add,
  now: now,
  isHrTime: isHrTime
});

/***/ }),

/***/ "./src/tracing/id.js":
/*!***************************!*\
  !*** ./src/tracing/id.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Generate a random hexadecimal ID of specified byte length
 *
 * @param {number} bytes - Number of bytes for the ID (default: 16)
 * @returns {string} - Hexadecimal string representation
 */
function gen() {
  var bytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var randomBytes = new Uint8Array(bytes);
  crypto.getRandomValues(randomBytes);
  var randHex = Array.from(randomBytes, function (_byte) {
    return _byte.toString(16).padStart(2, '0');
  }).join('');
  return randHex;
}

/**
 * Tracing id generation utils
 *
 * @example
 * import id from './id.js';
 *
 * const spanId = id.gen(8); // => "a1b2c3d4e5f6..."
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  gen: gen
});

/***/ }),

/***/ "./src/tracing/session.js":
/*!********************************!*\
  !*** ./src/tracing/session.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Session: () => (/* binding */ Session)
/* harmony export */ });
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id.js */ "./src/tracing/id.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var SESSION_KEY = 'RollbarSession';
var Session = /*#__PURE__*/function () {
  function Session(tracing, options) {
    _classCallCheck(this, Session);
    this.options = options;
    this.tracing = tracing;
    this.window = tracing.window;
    this.session = null;
  }
  return _createClass(Session, [{
    key: "init",
    value: function init() {
      if (this.session) {
        return this;
      }
      return this.getSession() || this.createSession();
    }
  }, {
    key: "getSession",
    value: function getSession() {
      try {
        var serializedSession = this.window.sessionStorage.getItem(SESSION_KEY);
        if (!serializedSession) {
          return null;
        }
        this.session = JSON.parse(serializedSession);
      } catch (_unused) {
        return null;
      }
      return this;
    }
  }, {
    key: "createSession",
    value: function createSession() {
      this.session = {
        id: _id_js__WEBPACK_IMPORTED_MODULE_0__["default"].gen(),
        createdAt: Date.now()
      };
      return this.setSession(this.session);
    }
  }, {
    key: "setSession",
    value: function setSession(session) {
      var sessionString = JSON.stringify(session);
      try {
        this.window.sessionStorage.setItem(SESSION_KEY, sessionString);
      } catch (_unused2) {
        return null;
      }
      return this;
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/span.js":
/*!*****************************!*\
  !*** ./src/tracing/span.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Span: () => (/* binding */ Span)
/* harmony export */ });
/* harmony import */ var _hrtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hrtime.js */ "./src/tracing/hrtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Span = /*#__PURE__*/function () {
  function Span(options) {
    _classCallCheck(this, Span);
    this.initReadableSpan(options);
    this.spanProcessor = options.spanProcessor;
    this.spanProcessor.onStart(this, options.context);
    if (options.attributes) {
      this.setAttributes(options.attributes);
    }
    return this;
  }
  return _createClass(Span, [{
    key: "initReadableSpan",
    value: function initReadableSpan(options) {
      this.span = {
        name: options.name,
        kind: options.kind,
        spanContext: options.spanContext,
        parentSpanId: options.parentSpanId,
        startTime: options.startTime || _hrtime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now(),
        endTime: [0, 0],
        status: {
          code: 0,
          message: ''
        },
        attributes: {
          'session.id': options.session.id
        },
        links: [],
        events: [],
        duration: 0,
        ended: false,
        resource: options.resource,
        instrumentationScope: options.scope,
        droppedAttributesCount: 0,
        droppedEventsCount: 0,
        droppedLinksCount: 0
      };
    }
  }, {
    key: "spanContext",
    value: function spanContext() {
      return this.span.spanContext;
    }
  }, {
    key: "spanId",
    get: function get() {
      return this.span.spanContext.spanId;
    }
  }, {
    key: "traceId",
    get: function get() {
      return this.span.spanContext.traceId;
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(key, value) {
      if (value == null || this.ended) return this;
      if (key.length === 0) return this;
      this.span.attributes[key] = value;
      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          k = _Object$entries$_i[0],
          v = _Object$entries$_i[1];
        this.setAttribute(k, v);
      }
      return this;
    }
  }, {
    key: "addEvent",
    value: function addEvent(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var time = arguments.length > 2 ? arguments[2] : undefined;
      if (this.span.ended) return this;
      this.span.events.push({
        name: name,
        attributes: attributes,
        time: time || _hrtime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now(),
        droppedAttributesCount: 0
      });
      return this;
    }
  }, {
    key: "isRecording",
    value: function isRecording() {
      return this.span.ended === false;
    }
  }, {
    key: "end",
    value: function end(attributes, time) {
      if (attributes) this.setAttributes(attributes);
      this.span.endTime = time || _hrtime_js__WEBPACK_IMPORTED_MODULE_0__["default"].now();
      this.span.ended = true;
      this.spanProcessor.onEnd(this);
    }
  }, {
    key: "export",
    value: function _export() {
      return this.span;
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/spanProcessor.js":
/*!**************************************!*\
  !*** ./src/tracing/spanProcessor.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpanProcessor: () => (/* binding */ SpanProcessor)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SpanProcessor = /*#__PURE__*/function () {
  function SpanProcessor(exporter) {
    _classCallCheck(this, SpanProcessor);
    this.exporter = exporter;
    this.pendingSpans = new Map();
  }
  return _createClass(SpanProcessor, [{
    key: "onStart",
    value: function onStart(span, _parentContext) {
      this.pendingSpans.set(span.span.spanContext.spanId, span);
    }
  }, {
    key: "onEnd",
    value: function onEnd(span) {
      this.exporter["export"]([span["export"]()]);
      this.pendingSpans["delete"](span.span.spanContext.spanId);
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/tracer.js":
/*!*******************************!*\
  !*** ./src/tracing/tracer.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tracer: () => (/* binding */ Tracer)
/* harmony export */ });
/* harmony import */ var _span_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./span.js */ "./src/tracing/span.js");
/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id.js */ "./src/tracing/id.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var Tracer = /*#__PURE__*/function () {
  function Tracer(tracing, spanProcessor) {
    _classCallCheck(this, Tracer);
    this.spanProcessor = spanProcessor;
    this.tracing = tracing;
  }
  return _createClass(Tracer, [{
    key: "startSpan",
    value: function startSpan(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.tracing.contextManager.active();
      var parentSpan = this.tracing.getSpan(context);
      var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
      var spanId = _id_js__WEBPACK_IMPORTED_MODULE_1__["default"].gen(8);
      var traceId;
      var traceFlags = 0;
      var traceState = null;
      var parentSpanId;
      if (parentSpanContext) {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        parentSpanId = parentSpanContext.spanId;
      } else {
        traceId = _id_js__WEBPACK_IMPORTED_MODULE_1__["default"].gen(16);
      }
      var kind = 0;
      var spanContext = {
        traceId: traceId,
        spanId: spanId,
        traceFlags: traceFlags,
        traceState: traceState
      };
      var span = new _span_js__WEBPACK_IMPORTED_MODULE_0__.Span({
        resource: this.tracing.resource,
        scope: this.tracing.scope,
        session: this.tracing.session.session,
        context: context,
        spanContext: spanContext,
        name: name,
        kind: kind,
        parentSpanId: parentSpanId,
        spanProcessor: this.spanProcessor
      });
      return span;
    }
  }]);
}();

/***/ }),

/***/ "./src/tracing/tracing.js":
/*!********************************!*\
  !*** ./src/tracing/tracing.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tracing)
/* harmony export */ });
/* harmony import */ var _contextManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contextManager.js */ "./src/tracing/contextManager.js");
/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./session.js */ "./src/tracing/session.js");
/* harmony import */ var _exporter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exporter.js */ "./src/tracing/exporter.js");
/* harmony import */ var _spanProcessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./spanProcessor.js */ "./src/tracing/spanProcessor.js");
/* harmony import */ var _tracer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tracer.js */ "./src/tracing/tracer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





var SPAN_KEY = (0,_contextManager_js__WEBPACK_IMPORTED_MODULE_0__.createContextKey)('Rollbar Context Key SPAN');
var Tracing = /*#__PURE__*/function () {
  function Tracing(gWindow, options) {
    _classCallCheck(this, Tracing);
    this.options = options;
    this.window = gWindow;
    this.session = new _session_js__WEBPACK_IMPORTED_MODULE_1__.Session(this, options);
    this.createTracer();
  }
  return _createClass(Tracing, [{
    key: "initSession",
    value: function initSession() {
      if (this.session) {
        this.session.init();
      }
    }
  }, {
    key: "sessionId",
    get: function get() {
      if (this.session) {
        return this.session.session.id;
      }
      return null;
    }
  }, {
    key: "resource",
    get: function get() {
      var _this$options$payload, _this$options$payload2;
      return {
        attributes: _objectSpread(_objectSpread({}, this.options.resource || {}), {}, {
          'rollbar.environment': (_this$options$payload = (_this$options$payload2 = this.options.payload) === null || _this$options$payload2 === void 0 ? void 0 : _this$options$payload2.environment) !== null && _this$options$payload !== void 0 ? _this$options$payload : this.options.environment
        })
      };
    }
  }, {
    key: "scope",
    get: function get() {
      return {
        name: 'rollbar-browser-js',
        version: this.options.version
      };
    }
  }, {
    key: "createTracer",
    value: function createTracer() {
      this.contextManager = new _contextManager_js__WEBPACK_IMPORTED_MODULE_0__.ContextManager();
      this.exporter = new _exporter_js__WEBPACK_IMPORTED_MODULE_2__.SpanExporter();
      this.spanProcessor = new _spanProcessor_js__WEBPACK_IMPORTED_MODULE_3__.SpanProcessor(this.exporter);
      this.tracer = new _tracer_js__WEBPACK_IMPORTED_MODULE_4__.Tracer(this, this.spanProcessor);
    }
  }, {
    key: "getTracer",
    value: function getTracer() {
      return this.tracer;
    }
  }, {
    key: "getSpan",
    value: function getSpan() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextManager.active();
      return context.getValue(SPAN_KEY);
    }
  }, {
    key: "setSpan",
    value: function setSpan() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextManager.active();
      var span = arguments.length > 1 ? arguments[1] : undefined;
      return context.setValue(SPAN_KEY, span);
    }
  }, {
    key: "startSpan",
    value: function startSpan(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.contextManager.active();
      return this.tracer.startSpan(name, options, context);
    }
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var _this$contextManager;
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      return (_this$contextManager = this.contextManager)["with"].apply(_this$contextManager, [context, fn, thisArg].concat(args));
    }
  }, {
    key: "withSpan",
    value: function withSpan(name, options, fn, thisArg) {
      var span = this.startSpan(name, options);
      return this["with"](this.setSpan(this.contextManager.active(), span), fn, thisArg, span);
    }
  }]);
}();


/***/ }),

/***/ "./src/transforms.js":
/*!***************************!*\
  !*** ./src/transforms.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
function itemToPayload(item, options, callback) {
  var data = item.data;
  if (item._isUncaught) {
    data._isUncaught = true;
  }
  if (item._originalArgs) {
    data._originalArgs = item._originalArgs;
  }
  callback(null, data);
}
function addPayloadOptions(item, options, callback) {
  var payloadOptions = options.payload || {};
  if (payloadOptions.body) {
    delete payloadOptions.body;
  }
  item.data = _.merge(item.data, payloadOptions);
  callback(null, item);
}
function addTelemetryData(item, options, callback) {
  if (item.telemetryEvents) {
    _.set(item, 'data.body.telemetry', item.telemetryEvents);
  }
  callback(null, item);
}
function addMessageWithError(item, options, callback) {
  if (!item.message) {
    callback(null, item);
    return;
  }
  var tracePath = 'data.body.trace_chain.0';
  var trace = _.get(item, tracePath);
  if (!trace) {
    tracePath = 'data.body.trace';
    trace = _.get(item, tracePath);
  }
  if (trace) {
    if (!(trace.exception && trace.exception.description)) {
      _.set(item, tracePath + '.exception.description', item.message);
      callback(null, item);
      return;
    }
    var extra = _.get(item, tracePath + '.extra') || {};
    var newExtra = _.merge(extra, {
      message: item.message
    });
    _.set(item, tracePath + '.extra', newExtra);
  }
  callback(null, item);
}
function userTransform(logger) {
  return function (item, options, callback) {
    var newItem = _.merge(item);
    var response = null;
    try {
      if (_.isFunction(options.transform)) {
        response = options.transform(newItem.data, item);
      }
    } catch (e) {
      options.transform = null;
      logger.error('Error while calling custom transform() function. Removing custom transform().', e);
      callback(null, item);
      return;
    }
    if (_.isPromise(response)) {
      response.then(function (promisedItem) {
        if (promisedItem) {
          newItem.data = promisedItem;
        }
        callback(null, newItem);
      }, function (error) {
        callback(error, item);
      });
    } else {
      callback(null, newItem);
    }
  };
}
function addConfigToPayload(item, options, callback) {
  if (!options.sendConfig) {
    return callback(null, item);
  }
  var configKey = '_rollbarConfig';
  var custom = _.get(item, 'data.custom') || {};
  custom[configKey] = options;
  item.data.custom = custom;
  callback(null, item);
}
function addFunctionOption(options, name) {
  if (_.isFunction(options[name])) {
    options[name] = options[name].toString();
  }
}
function addConfiguredOptions(item, options, callback) {
  var configuredOptions = options._configuredOptions;

  // These must be stringified or they'll get dropped during serialization.
  addFunctionOption(configuredOptions, 'transform');
  addFunctionOption(configuredOptions, 'checkIgnore');
  addFunctionOption(configuredOptions, 'onSendCallback');
  delete configuredOptions.accessToken;
  item.data.notifier.configured_options = configuredOptions;
  callback(null, item);
}
function addDiagnosticKeys(item, options, callback) {
  var diagnostic = _.merge(item.notifier.client.notifier.diagnostic, item.diagnostic);
  if (_.get(item, 'err._isAnonymous')) {
    diagnostic.is_anonymous = true;
  }
  if (item._isUncaught) {
    diagnostic.is_uncaught = item._isUncaught;
  }
  if (item.err) {
    try {
      diagnostic.raw_error = {
        message: item.err.message,
        name: item.err.name,
        constructor_name: item.err.constructor && item.err.constructor.name,
        filename: item.err.fileName,
        line: item.err.lineNumber,
        column: item.err.columnNumber,
        stack: item.err.stack
      };
    } catch (e) {
      diagnostic.raw_error = {
        failed: String(e)
      };
    }
  }
  item.data.notifier.diagnostic = _.merge(item.data.notifier.diagnostic, diagnostic);
  callback(null, item);
}
module.exports = {
  itemToPayload: itemToPayload,
  addPayloadOptions: addPayloadOptions,
  addTelemetryData: addTelemetryData,
  addMessageWithError: addMessageWithError,
  userTransform: userTransform,
  addConfigToPayload: addConfigToPayload,
  addConfiguredOptions: addConfiguredOptions,
  addDiagnosticKeys: addDiagnosticKeys
};

/***/ }),

/***/ "./src/truncation.js":
/*!***************************!*\
  !*** ./src/truncation.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./utility */ "./src/utility.js");
var traverse = __webpack_require__(/*! ./utility/traverse */ "./src/utility/traverse.js");
function raw(payload, jsonBackup) {
  return [payload, _.stringify(payload, jsonBackup)];
}
function selectFrames(frames, range) {
  var len = frames.length;
  if (len > range * 2) {
    return frames.slice(0, range).concat(frames.slice(len - range));
  }
  return frames;
}
function truncateFrames(payload, jsonBackup, range) {
  range = typeof range === 'undefined' ? 30 : range;
  var body = payload.data.body;
  var frames;
  if (body.trace_chain) {
    var chain = body.trace_chain;
    for (var i = 0; i < chain.length; i++) {
      frames = chain[i].frames;
      frames = selectFrames(frames, range);
      chain[i].frames = frames;
    }
  } else if (body.trace) {
    frames = body.trace.frames;
    frames = selectFrames(frames, range);
    body.trace.frames = frames;
  }
  return [payload, _.stringify(payload, jsonBackup)];
}
function maybeTruncateValue(len, val) {
  if (!val) {
    return val;
  }
  if (val.length > len) {
    return val.slice(0, len - 3).concat('...');
  }
  return val;
}
function truncateStrings(len, payload, jsonBackup) {
  function truncator(k, v, seen) {
    switch (_.typeName(v)) {
      case 'string':
        return maybeTruncateValue(len, v);
      case 'object':
      case 'array':
        return traverse(v, truncator, seen);
      default:
        return v;
    }
  }
  payload = traverse(payload, truncator);
  return [payload, _.stringify(payload, jsonBackup)];
}
function truncateTraceData(traceData) {
  if (traceData.exception) {
    delete traceData.exception.description;
    traceData.exception.message = maybeTruncateValue(255, traceData.exception.message);
  }
  traceData.frames = selectFrames(traceData.frames, 1);
  return traceData;
}
function minBody(payload, jsonBackup) {
  var body = payload.data.body;
  if (body.trace_chain) {
    var chain = body.trace_chain;
    for (var i = 0; i < chain.length; i++) {
      chain[i] = truncateTraceData(chain[i]);
    }
  } else if (body.trace) {
    body.trace = truncateTraceData(body.trace);
  }
  return [payload, _.stringify(payload, jsonBackup)];
}
function needsTruncation(payload, maxSize) {
  return _.maxByteSize(payload) > maxSize;
}
function truncate(payload, jsonBackup, maxSize) {
  maxSize = typeof maxSize === 'undefined' ? 512 * 1024 : maxSize;
  var strategies = [raw, truncateFrames, truncateStrings.bind(null, 1024), truncateStrings.bind(null, 512), truncateStrings.bind(null, 256), minBody];
  var strategy, results, result;
  while (strategy = strategies.shift()) {
    results = strategy(payload, jsonBackup);
    payload = results[0];
    result = results[1];
    if (result.error || !needsTruncation(result.value, maxSize)) {
      return result;
    }
  }
  return result;
}
module.exports = {
  truncate: truncate,
  /* for testing */
  raw: raw,
  truncateFrames: truncateFrames,
  truncateStrings: truncateStrings,
  maybeTruncateValue: maybeTruncateValue
};

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var merge = __webpack_require__(/*! ./merge */ "./src/merge.js");
var RollbarJSON = {};
function setupJSON(polyfillJSON) {
  if (isFunction(RollbarJSON.stringify) && isFunction(RollbarJSON.parse)) {
    return;
  }
  if (isDefined(JSON)) {
    // If polyfill is provided, prefer it over existing non-native shims.
    if (polyfillJSON) {
      if (isNativeFunction(JSON.stringify)) {
        RollbarJSON.stringify = JSON.stringify;
      }
      if (isNativeFunction(JSON.parse)) {
        RollbarJSON.parse = JSON.parse;
      }
    } else {
      // else accept any interface that is present.
      if (isFunction(JSON.stringify)) {
        RollbarJSON.stringify = JSON.stringify;
      }
      if (isFunction(JSON.parse)) {
        RollbarJSON.parse = JSON.parse;
      }
    }
  }
  if (!isFunction(RollbarJSON.stringify) || !isFunction(RollbarJSON.parse)) {
    polyfillJSON && polyfillJSON(RollbarJSON);
  }
}

/*
 * isType - Given a Javascript value and a string, returns true if the type of the value matches the
 * given string.
 *
 * @param x - any value
 * @param t - a lowercase string containing one of the following type names:
 *    - undefined
 *    - null
 *    - error
 *    - number
 *    - boolean
 *    - string
 *    - symbol
 *    - function
 *    - object
 *    - array
 * @returns true if x is of type t, otherwise false
 */
function isType(x, t) {
  return t === typeName(x);
}

/*
 * typeName - Given a Javascript value, returns the type of the object as a string
 */
function typeName(x) {
  var name = _typeof(x);
  if (name !== 'object') {
    return name;
  }
  if (!x) {
    return 'null';
  }
  if (x instanceof Error) {
    return 'error';
  }
  return {}.toString.call(x).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}

/* isFunction - a convenience function for checking if a value is a function
 *
 * @param f - any value
 * @returns true if f is a function, otherwise false
 */
function isFunction(f) {
  return isType(f, 'function');
}

/* isNativeFunction - a convenience function for checking if a value is a native JS function
 *
 * @param f - any value
 * @returns true if f is a native JS function, otherwise false
 */
function isNativeFunction(f) {
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var funcMatchString = Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?');
  var reIsNative = RegExp('^' + funcMatchString + '$');
  return isObject(f) && reIsNative.test(f);
}

/* isObject - Checks if the argument is an object
 *
 * @param value - any value
 * @returns true is value is an object function is an object)
 */
function isObject(value) {
  var type = _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

/* isString - Checks if the argument is a string
 *
 * @param value - any value
 * @returns true if value is a string
 */
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}

/**
 * isFiniteNumber - determines whether the passed value is a finite number
 *
 * @param {*} n - any value
 * @returns true if value is a finite number
 */
function isFiniteNumber(n) {
  return Number.isFinite(n);
}

/*
 * isDefined - a convenience function for checking if a value is not equal to undefined
 *
 * @param u - any value
 * @returns true if u is anything other than undefined
 */
function isDefined(u) {
  return !isType(u, 'undefined');
}

/*
 * isIterable - convenience function for checking if a value can be iterated, essentially
 * whether it is an object or an array.
 *
 * @param i - any value
 * @returns true if i is an object or an array as determined by `typeName`
 */
function isIterable(i) {
  var type = typeName(i);
  return type === 'object' || type === 'array';
}

/*
 * isError - convenience function for checking if a value is of an error type
 *
 * @param e - any value
 * @returns true if e is an error
 */
function isError(e) {
  // Detect both Error and Firefox Exception type
  return isType(e, 'error') || isType(e, 'exception');
}

/* isPromise - a convenience function for checking if a value is a promise
 *
 * @param p - any value
 * @returns true if f is a function, otherwise false
 */
function isPromise(p) {
  return isObject(p) && isType(p.then, 'function');
}

/**
 * isBrowser - a convenience function for checking if the code is running in a browser
 *
 * @returns true if the code is running in a browser environment
 */
function isBrowser() {
  return typeof window !== 'undefined';
}
function redact() {
  return '********';
}

// from http://stackoverflow.com/a/8809472/1138191
function uuid4() {
  var d = now();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
  });
  return uuid;
}
var LEVELS = {
  debug: 0,
  info: 1,
  warning: 2,
  error: 3,
  critical: 4
};
function sanitizeUrl(url) {
  var baseUrlParts = parseUri(url);
  if (!baseUrlParts) {
    return '(unknown)';
  }

  // remove a trailing # if there is no anchor
  if (baseUrlParts.anchor === '') {
    baseUrlParts.source = baseUrlParts.source.replace('#', '');
  }
  url = baseUrlParts.source.replace('?' + baseUrlParts.query, '');
  return url;
}
var parseUriOptions = {
  strictMode: false,
  key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
  q: {
    name: 'queryKey',
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};
function parseUri(str) {
  if (!isType(str, 'string')) {
    return undefined;
  }
  var o = parseUriOptions;
  var m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str);
  var uri = {};
  for (var i = 0, l = o.key.length; i < l; ++i) {
    uri[o.key[i]] = m[i] || '';
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) {
      uri[o.q.name][$1] = $2;
    }
  });
  return uri;
}
function addParamsAndAccessTokenToPath(accessToken, options, params) {
  params = params || {};
  params.access_token = accessToken;
  var paramsArray = [];
  var k;
  for (k in params) {
    if (Object.prototype.hasOwnProperty.call(params, k)) {
      paramsArray.push([k, params[k]].join('='));
    }
  }
  var query = '?' + paramsArray.sort().join('&');
  options = options || {};
  options.path = options.path || '';
  var qs = options.path.indexOf('?');
  var h = options.path.indexOf('#');
  var p;
  if (qs !== -1 && (h === -1 || h > qs)) {
    p = options.path;
    options.path = p.substring(0, qs) + query + '&' + p.substring(qs + 1);
  } else {
    if (h !== -1) {
      p = options.path;
      options.path = p.substring(0, h) + query + p.substring(h);
    } else {
      options.path = options.path + query;
    }
  }
}
function formatUrl(u, protocol) {
  protocol = protocol || u.protocol;
  if (!protocol && u.port) {
    if (u.port === 80) {
      protocol = 'http:';
    } else if (u.port === 443) {
      protocol = 'https:';
    }
  }
  protocol = protocol || 'https:';
  if (!u.hostname) {
    return null;
  }
  var result = protocol + '//' + u.hostname;
  if (u.port) {
    result = result + ':' + u.port;
  }
  if (u.path) {
    result = result + u.path;
  }
  return result;
}
function stringify(obj, backup) {
  var value, error;
  try {
    value = RollbarJSON.stringify(obj);
  } catch (jsonError) {
    if (backup && isFunction(backup)) {
      try {
        value = backup(obj);
      } catch (backupError) {
        error = backupError;
      }
    } else {
      error = jsonError;
    }
  }
  return {
    error: error,
    value: value
  };
}
function maxByteSize(string) {
  // The transport will use utf-8, so assume utf-8 encoding.
  //
  // This minimal implementation will accurately count bytes for all UCS-2 and
  // single code point UTF-16. If presented with multi code point UTF-16,
  // which should be rare, it will safely overcount, not undercount.
  //
  // While robust utf-8 encoders exist, this is far smaller and far more performant.
  // For quickly counting payload size for truncation, smaller is better.

  var count = 0;
  var length = string.length;
  for (var i = 0; i < length; i++) {
    var code = string.charCodeAt(i);
    if (code < 128) {
      // up to 7 bits
      count = count + 1;
    } else if (code < 2048) {
      // up to 11 bits
      count = count + 2;
    } else if (code < 65536) {
      // up to 16 bits
      count = count + 3;
    }
  }
  return count;
}
function jsonParse(s) {
  var value, error;
  try {
    value = RollbarJSON.parse(s);
  } catch (e) {
    error = e;
  }
  return {
    error: error,
    value: value
  };
}
function makeUnhandledStackInfo(message, url, lineno, colno, error, mode, backupMessage, errorParser) {
  var location = {
    url: url || '',
    line: lineno,
    column: colno
  };
  location.func = errorParser.guessFunctionName(location.url, location.line);
  location.context = errorParser.gatherContext(location.url, location.line);
  var href = typeof document !== 'undefined' && document && document.location && document.location.href;
  var useragent = typeof window !== 'undefined' && window && window.navigator && window.navigator.userAgent;
  return {
    mode: mode,
    message: error ? String(error) : message || backupMessage,
    url: href,
    stack: [location],
    useragent: useragent
  };
}
function wrapCallback(logger, f) {
  return function (err, resp) {
    try {
      f(err, resp);
    } catch (e) {
      logger.error(e);
    }
  };
}
function nonCircularClone(obj) {
  var seen = [obj];
  function clone(obj, seen) {
    var value,
      name,
      newSeen,
      result = {};
    try {
      for (name in obj) {
        value = obj[name];
        if (value && (isType(value, 'object') || isType(value, 'array'))) {
          if (seen.includes(value)) {
            result[name] = 'Removed circular reference: ' + typeName(value);
          } else {
            newSeen = seen.slice();
            newSeen.push(value);
            result[name] = clone(value, newSeen);
          }
          continue;
        }
        result[name] = value;
      }
    } catch (e) {
      result = 'Failed cloning custom data: ' + e.message;
    }
    return result;
  }
  return clone(obj, seen);
}
function createItem(args, logger, notifier, requestKeys, lambdaContext) {
  var message, err, custom, callback, request;
  var arg;
  var extraArgs = [];
  var diagnostic = {};
  var argTypes = [];
  for (var i = 0, l = args.length; i < l; ++i) {
    arg = args[i];
    var typ = typeName(arg);
    argTypes.push(typ);
    switch (typ) {
      case 'undefined':
        break;
      case 'string':
        message ? extraArgs.push(arg) : message = arg;
        break;
      case 'function':
        callback = wrapCallback(logger, arg);
        break;
      case 'date':
        extraArgs.push(arg);
        break;
      case 'error':
      case 'domexception':
      case 'exception':
        // Firefox Exception type
        err ? extraArgs.push(arg) : err = arg;
        break;
      case 'object':
      case 'array':
        if (arg instanceof Error || typeof DOMException !== 'undefined' && arg instanceof DOMException) {
          err ? extraArgs.push(arg) : err = arg;
          break;
        }
        if (requestKeys && typ === 'object' && !request) {
          for (var j = 0, len = requestKeys.length; j < len; ++j) {
            if (arg[requestKeys[j]] !== undefined) {
              request = arg;
              break;
            }
          }
          if (request) {
            break;
          }
        }
        custom ? extraArgs.push(arg) : custom = arg;
        break;
      default:
        if (arg instanceof Error || typeof DOMException !== 'undefined' && arg instanceof DOMException) {
          err ? extraArgs.push(arg) : err = arg;
          break;
        }
        extraArgs.push(arg);
    }
  }

  // if custom is an array this turns it into an object with integer keys
  if (custom) custom = nonCircularClone(custom);
  if (extraArgs.length > 0) {
    if (!custom) custom = nonCircularClone({});
    custom.extraArgs = nonCircularClone(extraArgs);
  }
  var item = {
    message: message,
    err: err,
    custom: custom,
    timestamp: now(),
    callback: callback,
    notifier: notifier,
    diagnostic: diagnostic,
    uuid: uuid4()
  };
  item.data = item.data || {};
  setCustomItemKeys(item, custom);
  if (requestKeys && request) {
    item.request = request;
  }
  if (lambdaContext) {
    item.lambdaContext = lambdaContext;
  }
  item._originalArgs = args;
  item.diagnostic.original_arg_types = argTypes;
  return item;
}
function setCustomItemKeys(item, custom) {
  if (custom && custom.level !== undefined) {
    item.level = custom.level;
    delete custom.level;
  }
  if (custom && custom.skipFrames !== undefined) {
    item.skipFrames = custom.skipFrames;
    delete custom.skipFrames;
  }
}
function addErrorContext(item, errors) {
  var custom = item.data.custom || {};
  var contextAdded = false;
  try {
    for (var i = 0; i < errors.length; ++i) {
      if (errors[i].hasOwnProperty('rollbarContext')) {
        custom = merge(custom, nonCircularClone(errors[i].rollbarContext));
        contextAdded = true;
      }
    }

    // Avoid adding an empty object to the data.
    if (contextAdded) {
      item.data.custom = custom;
    }
  } catch (e) {
    item.diagnostic.error_context = 'Failed: ' + e.message;
  }
}
var TELEMETRY_TYPES = ['log', 'network', 'dom', 'navigation', 'error', 'manual'];
var TELEMETRY_LEVELS = ['critical', 'error', 'warning', 'info', 'debug'];
function arrayIncludes(arr, val) {
  for (var k = 0; k < arr.length; ++k) {
    if (arr[k] === val) {
      return true;
    }
  }
  return false;
}
function createTelemetryEvent(args) {
  var type, metadata, level;
  var arg;
  for (var i = 0, l = args.length; i < l; ++i) {
    arg = args[i];
    var typ = typeName(arg);
    switch (typ) {
      case 'string':
        if (!type && arrayIncludes(TELEMETRY_TYPES, arg)) {
          type = arg;
        } else if (!level && arrayIncludes(TELEMETRY_LEVELS, arg)) {
          level = arg;
        }
        break;
      case 'object':
        metadata = arg;
        break;
      default:
        break;
    }
  }
  var event = {
    type: type || 'manual',
    metadata: metadata || {},
    level: level
  };
  return event;
}
function addItemAttributes(item, attributes) {
  item.data.attributes = item.data.attributes || [];
  if (attributes) {
    var _item$data$attributes;
    (_item$data$attributes = item.data.attributes).push.apply(_item$data$attributes, _toConsumableArray(attributes));
  }
}

/*
 * get - given an obj/array and a keypath, return the value at that keypath or
 *       undefined if not possible.
 *
 * @param obj - an object or array
 * @param path - a string of keys separated by '.' such as 'plugin.jquery.0.message'
 *    which would correspond to 42 in `{plugin: {jquery: [{message: 42}]}}`
 */
function get(obj, path) {
  if (!obj) {
    return undefined;
  }
  var keys = path.split('.');
  var result = obj;
  try {
    for (var i = 0, len = keys.length; i < len; ++i) {
      result = result[keys[i]];
    }
  } catch (e) {
    result = undefined;
  }
  return result;
}
function set(obj, path, value) {
  if (!obj) {
    return;
  }
  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {
    obj[keys[0]] = value;
    return;
  }
  try {
    var temp = obj[keys[0]] || {};
    var replacement = temp;
    for (var i = 1; i < len - 1; ++i) {
      temp[keys[i]] = temp[keys[i]] || {};
      temp = temp[keys[i]];
    }
    temp[keys[len - 1]] = value;
    obj[keys[0]] = replacement;
  } catch (e) {
    return;
  }
}
function formatArgsAsString(args) {
  var i, len, arg;
  var result = [];
  for (i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    switch (typeName(arg)) {
      case 'object':
        arg = stringify(arg);
        arg = arg.error || arg.value;
        if (arg.length > 500) {
          arg = arg.substr(0, 497) + '...';
        }
        break;
      case 'null':
        arg = 'null';
        break;
      case 'undefined':
        arg = 'undefined';
        break;
      case 'symbol':
        arg = arg.toString();
        break;
    }
    result.push(arg);
  }
  return result.join(' ');
}
function now() {
  if (Date.now) {
    return +Date.now();
  }
  return +new Date();
}
function filterIp(requestData, captureIp) {
  if (!requestData || !requestData['user_ip'] || captureIp === true) {
    return;
  }
  var newIp = requestData['user_ip'];
  if (!captureIp) {
    newIp = null;
  } else {
    try {
      var parts;
      if (newIp.indexOf('.') !== -1) {
        parts = newIp.split('.');
        parts.pop();
        parts.push('0');
        newIp = parts.join('.');
      } else if (newIp.indexOf(':') !== -1) {
        parts = newIp.split(':');
        if (parts.length > 2) {
          var beginning = parts.slice(0, 3);
          var slashIdx = beginning[2].indexOf('/');
          if (slashIdx !== -1) {
            beginning[2] = beginning[2].substring(0, slashIdx);
          }
          var terminal = '0000:0000:0000:0000:0000';
          newIp = beginning.concat(terminal).join(':');
        }
      } else {
        newIp = null;
      }
    } catch (e) {
      newIp = null;
    }
  }
  requestData['user_ip'] = newIp;
}
function handleOptions(current, input, payload, logger) {
  var result = merge(current, input, payload);
  result = updateDeprecatedOptions(result, logger);
  if (!input || input.overwriteScrubFields) {
    return result;
  }
  if (input.scrubFields) {
    result.scrubFields = (current.scrubFields || []).concat(input.scrubFields);
  }
  return result;
}
function updateDeprecatedOptions(options, logger) {
  if (options.hostWhiteList && !options.hostSafeList) {
    options.hostSafeList = options.hostWhiteList;
    options.hostWhiteList = undefined;
    logger && logger.log('hostWhiteList is deprecated. Use hostSafeList.');
  }
  if (options.hostBlackList && !options.hostBlockList) {
    options.hostBlockList = options.hostBlackList;
    options.hostBlackList = undefined;
    logger && logger.log('hostBlackList is deprecated. Use hostBlockList.');
  }
  return options;
}
module.exports = {
  addParamsAndAccessTokenToPath: addParamsAndAccessTokenToPath,
  createItem: createItem,
  addErrorContext: addErrorContext,
  createTelemetryEvent: createTelemetryEvent,
  addItemAttributes: addItemAttributes,
  filterIp: filterIp,
  formatArgsAsString: formatArgsAsString,
  formatUrl: formatUrl,
  get: get,
  handleOptions: handleOptions,
  isError: isError,
  isFiniteNumber: isFiniteNumber,
  isFunction: isFunction,
  isIterable: isIterable,
  isNativeFunction: isNativeFunction,
  isObject: isObject,
  isString: isString,
  isType: isType,
  isPromise: isPromise,
  isBrowser: isBrowser,
  jsonParse: jsonParse,
  LEVELS: LEVELS,
  makeUnhandledStackInfo: makeUnhandledStackInfo,
  merge: merge,
  now: now,
  redact: redact,
  RollbarJSON: RollbarJSON,
  sanitizeUrl: sanitizeUrl,
  set: set,
  setupJSON: setupJSON,
  stringify: stringify,
  maxByteSize: maxByteSize,
  typeName: typeName,
  uuid4: uuid4
};

/***/ }),

/***/ "./src/utility/headers.js":
/*!********************************!*\
  !*** ./src/utility/headers.js ***!
  \********************************/
/***/ ((module) => {

/*
 * headers - Detect when fetch Headers are undefined and use a partial polyfill.
 *
 * A full polyfill is not used in order to keep package size as small as possible.
 * Since this is only used internally and is not added to the window object,
 * the full interface doesn't need to be supported.
 *
 * This implementation is modified from whatwg-fetch:
 * https://github.com/github/fetch
 */
function headers(headers) {
  if (typeof Headers === 'undefined') {
    return new FetchHeaders(headers);
  }
  return new Headers(headers);
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };
  return iterator;
}
function FetchHeaders(headers) {
  this.map = {};
  if (headers instanceof FetchHeaders) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
FetchHeaders.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
FetchHeaders.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
FetchHeaders.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
FetchHeaders.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
FetchHeaders.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
module.exports = headers;

/***/ }),

/***/ "./src/utility/polyfillJSON.js":
/*!*************************************!*\
  !*** ./src/utility/polyfillJSON.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var polyfillJSON = __webpack_require__(/*! ../../vendor/JSON-js/json3 */ "./vendor/JSON-js/json3.js");
module.exports = polyfillJSON;

/***/ }),

/***/ "./src/utility/replace.js":
/*!********************************!*\
  !*** ./src/utility/replace.js ***!
  \********************************/
/***/ ((module) => {

function replace(obj, name, replacement, replacements, type) {
  var orig = obj[name];
  obj[name] = replacement(orig);
  if (replacements) {
    replacements[type].push([obj, name, orig]);
  }
}
module.exports = replace;

/***/ }),

/***/ "./src/utility/traverse.js":
/*!*********************************!*\
  !*** ./src/utility/traverse.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../utility */ "./src/utility.js");
function traverse(obj, func, seen) {
  var k, v, i;
  var isObj = _.isType(obj, 'object');
  var isArray = _.isType(obj, 'array');
  var keys = [];
  var seenIndex;

  // Best might be to use Map here with `obj` as the keys, but we want to support IE < 11.
  seen = seen || {
    obj: [],
    mapped: []
  };
  if (isObj) {
    seenIndex = seen.obj.indexOf(obj);
    if (isObj && seenIndex !== -1) {
      // Prefer the mapped object if there is one.
      return seen.mapped[seenIndex] || seen.obj[seenIndex];
    }
    seen.obj.push(obj);
    seenIndex = seen.obj.length - 1;
  }
  if (isObj) {
    for (k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, k)) {
        keys.push(k);
      }
    }
  } else if (isArray) {
    for (i = 0; i < obj.length; ++i) {
      keys.push(i);
    }
  }
  var result = isObj ? {} : [];
  var same = true;
  for (i = 0; i < keys.length; ++i) {
    k = keys[i];
    v = obj[k];
    result[k] = func(k, v, seen);
    same = same && result[k] === obj[k];
  }
  if (isObj && !same) {
    seen.mapped[seenIndex] = result;
  }
  return !same ? result : obj;
}
module.exports = traverse;

/***/ }),

/***/ "./vendor/JSON-js/json3.js":
/*!*********************************!*\
  !*** ./vendor/JSON-js/json3.js ***!
  \*********************************/
/***/ ((module) => {

//  json3.js
//  2017-02-21
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.
//          This has been modified to use JSON-js/json_parse_state.js as the
//          parser instead of the one built around eval found in JSON-js/json2.js

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
  for, this
  */

/*property
  JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
  getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
  lastIndex, length, parse, prototype, push, replace, slice, stringify,
  test, toJSON, toString, valueOf
  */

var setupCustomJSON = function(JSON) {

  var rx_one = /^[\],:{}\s]*$/;
  var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
  var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
  var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

  function f(n) {
    // Format integers to have at least two digits.
    return n < 10
      ? "0" + n
      : n;
  }

  function this_value() {
    return this.valueOf();
  }

  if (typeof Date.prototype.toJSON !== "function") {

    Date.prototype.toJSON = function () {

      return isFinite(this.valueOf())
        ? this.getUTCFullYear() + "-" +
        f(this.getUTCMonth() + 1) + "-" +
        f(this.getUTCDate()) + "T" +
        f(this.getUTCHours()) + ":" +
        f(this.getUTCMinutes()) + ":" +
        f(this.getUTCSeconds()) + "Z"
        : null;
    };

    Boolean.prototype.toJSON = this_value;
    Number.prototype.toJSON = this_value;
    String.prototype.toJSON = this_value;
  }

  var gap;
  var indent;
  var meta;
  var rep;


  function quote(string) {

    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.

    rx_escapable.lastIndex = 0;
    return rx_escapable.test(string)
      ? "\"" + string.replace(rx_escapable, function (a) {
        var c = meta[a];
        return typeof c === "string"
          ? c
          : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + "\""
    : "\"" + string + "\"";
  }


  function str(key, holder) {

    // Produce a string from holder[key].

    var i;          // The loop counter.
    var k;          // The member key.
    var v;          // The member value.
    var length;
    var mind = gap;
    var partial;
    var value = holder[key];

    // If the value has a toJSON method, call it to obtain a replacement value.

    if (value && typeof value === "object" &&
        typeof value.toJSON === "function") {
      value = value.toJSON(key);
    }

    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.

    if (typeof rep === "function") {
      value = rep.call(holder, key, value);
    }

    // What happens next depends on the value's type.

    switch (typeof value) {
      case "string":
        return quote(value);

      case "number":

        // JSON numbers must be finite. Encode non-finite numbers as null.

        return isFinite(value)
          ? String(value)
          : "null";

      case "boolean":
      case "null":

        // If the value is a boolean or null, convert it to a string. Note:
        // typeof null does not produce "null". The case is included here in
        // the remote chance that this gets fixed someday.

        return String(value);

        // If the type is "object", we might be dealing with an object or an array or
        // null.

      case "object":

        // Due to a specification blunder in ECMAScript, typeof null is "object",
        // so watch out for that case.

        if (!value) {
          return "null";
        }

        // Make an array to hold the partial results of stringifying this object value.

        gap += indent;
        partial = [];

        // Is the value an array?

        if (Object.prototype.toString.apply(value) === "[object Array]") {

          // The value is an array. Stringify every element. Use null as a placeholder
          // for non-JSON values.

          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || "null";
          }

          // Join all of the elements together, separated with commas, and wrap them in
          // brackets.

          v = partial.length === 0
            ? "[]"
            : gap
            ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
            : "[" + partial.join(",") + "]";
          gap = mind;
          return v;
        }

        // If the replacer is an array, use it to select the members to be stringified.

        if (rep && typeof rep === "object") {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === "string") {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (
                      gap
                      ? ": "
                      : ":"
                      ) + v);
              }
            }
          }
        } else {

          // Otherwise, iterate through all of the keys in the object.

          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (
                      gap
                      ? ": "
                      : ":"
                      ) + v);
              }
            }
          }
        }

        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0
          ? "{}"
          : gap
          ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
          : "{" + partial.join(",") + "}";
        gap = mind;
        return v;
    }
  }

  // If the JSON object does not yet have a stringify method, give it one.

  if (typeof JSON.stringify !== "function") {
    meta = {    // table of character substitutions
      "\b": "\\b",
      "\t": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      "\"": "\\\"",
      "\\": "\\\\"
    };
    JSON.stringify = function (value, replacer, space) {

      // The stringify method takes a value and an optional replacer, and an optional
      // space parameter, and returns a JSON text. The replacer can be a function
      // that can replace values, or an array of strings that will select the keys.
      // A default replacer method can be provided. Use of the space parameter can
      // produce text that is more easily readable.

      var i;
      gap = "";
      indent = "";

      // If the space parameter is a number, make an indent string containing that
      // many spaces.

      if (typeof space === "number") {
        for (i = 0; i < space; i += 1) {
          indent += " ";
        }

        // If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === "string") {
        indent = space;
      }

      // If there is a replacer, it must be a function or an array.
      // Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== "function" &&
          (typeof replacer !== "object" ||
           typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }

      // Make a fake root object containing our value under the key of "".
      // Return the result of stringifying the value.

      return str("", {"": value});
    };
  }


  // If the JSON object does not yet have a parse method, give it one.

  if (typeof JSON.parse !== "function") {
    JSON.parse = (function () {

      // This function creates a JSON parse function that uses a state machine rather
      // than the dangerous eval function to parse a JSON text.

      var state;      // The state of the parser, one of
      // 'go'         The starting state
      // 'ok'         The final, accepting state
      // 'firstokey'  Ready for the first key of the object or
      //              the closing of an empty object
      // 'okey'       Ready for the next key of the object
      // 'colon'      Ready for the colon
      // 'ovalue'     Ready for the value half of a key/value pair
      // 'ocomma'     Ready for a comma or closing }
      // 'firstavalue' Ready for the first value of an array or
      //              an empty array
      // 'avalue'     Ready for the next value of an array
      // 'acomma'     Ready for a comma or closing ]
      var stack;      // The stack, for controlling nesting.
      var container;  // The current container object or array
      var key;        // The current key
      var value;      // The current value
      var escapes = { // Escapement translation table
        "\\": "\\",
        "\"": "\"",
        "/": "/",
        "t": "\t",
        "n": "\n",
        "r": "\r",
        "f": "\f",
        "b": "\b"
      };
      var string = {   // The actions for string tokens
        go: function () {
          state = "ok";
        },
        firstokey: function () {
          key = value;
          state = "colon";
        },
        okey: function () {
          key = value;
          state = "colon";
        },
        ovalue: function () {
          state = "ocomma";
        },
        firstavalue: function () {
          state = "acomma";
        },
        avalue: function () {
          state = "acomma";
        }
      };
      var number = {   // The actions for number tokens
        go: function () {
          state = "ok";
        },
        ovalue: function () {
          state = "ocomma";
        },
        firstavalue: function () {
          state = "acomma";
        },
        avalue: function () {
          state = "acomma";
        }
      };
      var action = {

        // The action table describes the behavior of the machine. It contains an
        // object for each token. Each object contains a method that is called when
        // a token is matched in a state. An object will lack a method for illegal
        // states.

        "{": {
          go: function () {
            stack.push({state: "ok"});
            container = {};
            state = "firstokey";
          },
          ovalue: function () {
            stack.push({container: container, state: "ocomma", key: key});
            container = {};
            state = "firstokey";
          },
          firstavalue: function () {
            stack.push({container: container, state: "acomma"});
            container = {};
            state = "firstokey";
          },
          avalue: function () {
            stack.push({container: container, state: "acomma"});
            container = {};
            state = "firstokey";
          }
        },
        "}": {
          firstokey: function () {
            var pop = stack.pop();
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          },
          ocomma: function () {
            var pop = stack.pop();
            container[key] = value;
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          }
        },
        "[": {
          go: function () {
            stack.push({state: "ok"});
            container = [];
            state = "firstavalue";
          },
          ovalue: function () {
            stack.push({container: container, state: "ocomma", key: key});
            container = [];
            state = "firstavalue";
          },
          firstavalue: function () {
            stack.push({container: container, state: "acomma"});
            container = [];
            state = "firstavalue";
          },
          avalue: function () {
            stack.push({container: container, state: "acomma"});
            container = [];
            state = "firstavalue";
          }
        },
        "]": {
          firstavalue: function () {
            var pop = stack.pop();
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          },
          acomma: function () {
            var pop = stack.pop();
            container.push(value);
            value = container;
            container = pop.container;
            key = pop.key;
            state = pop.state;
          }
        },
        ":": {
          colon: function () {
            if (Object.hasOwnProperty.call(container, key)) {
              throw new SyntaxError("Duplicate key '" + key + "\"");
            }
            state = "ovalue";
          }
        },
        ",": {
          ocomma: function () {
            container[key] = value;
            state = "okey";
          },
          acomma: function () {
            container.push(value);
            state = "avalue";
          }
        },
        "true": {
          go: function () {
            value = true;
            state = "ok";
          },
          ovalue: function () {
            value = true;
            state = "ocomma";
          },
          firstavalue: function () {
            value = true;
            state = "acomma";
          },
          avalue: function () {
            value = true;
            state = "acomma";
          }
        },
        "false": {
          go: function () {
            value = false;
            state = "ok";
          },
          ovalue: function () {
            value = false;
            state = "ocomma";
          },
          firstavalue: function () {
            value = false;
            state = "acomma";
          },
          avalue: function () {
            value = false;
            state = "acomma";
          }
        },
        "null": {
          go: function () {
            value = null;
            state = "ok";
          },
          ovalue: function () {
            value = null;
            state = "ocomma";
          },
          firstavalue: function () {
            value = null;
            state = "acomma";
          },
          avalue: function () {
            value = null;
            state = "acomma";
          }
        }
      };

      function debackslashify(text) {

        // Remove and replace any backslash escapement.

        return text.replace(/\\(?:u(.{4})|([^u]))/g, function (ignore, b, c) {
          return b
            ? String.fromCharCode(parseInt(b, 16))
            : escapes[c];
        });
      }

      return function (source, reviver) {

        // A regular expression is used to extract tokens from the JSON text.
        // The extraction process is cautious.

        var result;
        var tx = /^[\u0020\t\n\r]*(?:([,:\[\]{}]|true|false|null)|(-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)|"((?:[^\r\n\t\\\"]|\\(?:["\\\/trnfb]|u[0-9a-fA-F]{4}))*)")/;

        // Set the starting state.

        state = "go";

        // The stack records the container, key, and state for each object or array
        // that contains another object or array while processing nested structures.

        stack = [];

        // If any error occurs, we will catch it and ultimately throw a syntax error.

        try {

          // For each token...

          while (true) {
            result = tx.exec(source);
            if (!result) {
              break;
            }

            // result is the result array from matching the tokenizing regular expression.
            //  result[0] contains everything that matched, including any initial whitespace.
            //  result[1] contains any punctuation that was matched, or true, false, or null.
            //  result[2] contains a matched number, still in string form.
            //  result[3] contains a matched string, without quotes but with escapement.

            if (result[1]) {

              // Token: Execute the action for this state and token.

              action[result[1]][state]();

            } else if (result[2]) {

              // Number token: Convert the number string into a number value and execute
              // the action for this state and number.

              value = +result[2];
              number[state]();
            } else {

              // String token: Replace the escapement sequences and execute the action for
              // this state and string.

              value = debackslashify(result[3]);
              string[state]();
            }

            // Remove the token from the string. The loop will continue as long as there
            // are tokens. This is a slow process, but it allows the use of ^ matching,
            // which assures that no illegal tokens slip through.

            source = source.slice(result[0].length);
          }

          // If we find a state/token combination that is illegal, then the action will
          // cause an error. We handle the error by simply changing the state.

        } catch (e) {
          state = e;
        }

        // The parsing is finished. If we are not in the final "ok" state, or if the
        // remaining source contains anything except whitespace, then we did not have
        //a well-formed JSON text.

        if (state !== "ok" || (/[^\u0020\t\n\r]/.test(source))) {
          throw (state instanceof SyntaxError)
            ? state
            : new SyntaxError("JSON");
        }

        // If there is a reviver function, we recursively walk the new structure,
        // passing each name/value pair to the reviver function for possible
        // transformation, starting with a temporary root object that holds the current
        // value in an empty key. If there is not a reviver function, we simply return
        // that value.

        return (typeof reviver === "function")
          ? (function walk(holder, key) {
            var k;
            var v;
            var val = holder[key];
            if (val && typeof val === "object") {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(val, k)) {
                  v = walk(val, k);
                  if (v !== undefined) {
                    val[k] = v;
                  } else {
                    delete val[k];
                  }
                }
              }
            }
            return reviver.call(holder, key, val);
          }({"": value}, ""))
        : value;
      };
    }());
  }
}

module.exports = setupCustomJSON;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**************************************!*\
  !*** ./test/browser.rollbar.test.js ***!
  \**************************************/
/* globals expect */
/* globals describe */
/* globals it */
/* globals sinon */

var Rollbar = __webpack_require__(/*! ../src/browser/rollbar */ "./src/browser/rollbar.js");

const DUMMY_TRACE_ID = 'some-trace-id';
const DUMMY_SPAN_ID = 'some-span-id';

const ValidOpenTracingTracerStub = {
  scope: () => {
    return {
      active: () => {
        return {
          setTag: () => {},
          context: () => {
            return {
              toTraceId: () => DUMMY_TRACE_ID,
              toSpanId: () => DUMMY_SPAN_ID,
            };
          },
        };
      },
    };
  },
};

const InvalidOpenTracingTracerStub = {
  foo: () => {},
};

function TestClientGen() {
  var TestClient = function () {
    this.transforms = [];
    this.predicates = [];
    this.notifier = {
      addTransform: function (t) {
        this.transforms.push(t);
        return this.notifier;
      }.bind(this),
    };
    this.queue = {
      addPredicate: function (p) {
        this.predicates.push(p);
        return this.queue;
      }.bind(this),
    };
    this.logCalls = [];
    var logs = 'log,debug,info,warn,warning,error,critical'.split(',');
    for (var i = 0, len = logs.length; i < len; i++) {
      var fn = logs[i].slice(0);
      this[fn] = function (fn, item) {
        this.logCalls.push({ func: fn, item: item });
      }.bind(this, fn);
    }
    this.options = {};
    this.payloadData = {};
    this.configure = function (o, payloadData) {
      this.options = o;
      this.payloadData = payloadData;
    };
    this.tracer = ValidOpenTracingTracerStub;
  };

  return TestClient;
}

describe('Rollbar()', function () {
  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
  });

  it('should have all of the expected methods with a real client', function (done) {
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options));

    expect(rollbar).to.have.property('log');
    expect(rollbar).to.have.property('debug');
    expect(rollbar).to.have.property('info');
    expect(rollbar).to.have.property('warn');
    expect(rollbar).to.have.property('warning');
    expect(rollbar).to.have.property('error');
    expect(rollbar).to.have.property('critical');

    done();
  });

  it('should have all of the expected methods', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    expect(rollbar).to.have.property('log');
    expect(rollbar).to.have.property('debug');
    expect(rollbar).to.have.property('info');
    expect(rollbar).to.have.property('warn');
    expect(rollbar).to.have.property('warning');
    expect(rollbar).to.have.property('error');
    expect(rollbar).to.have.property('critical');

    done();
  });

  it('should have some default options', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    expect(rollbar.options.scrubFields).to.contain('password');
    done();
  });

  it('should merge with the defaults options', function (done) {
    var client = new (TestClientGen())();
    var options = {
      scrubFields: ['foobar'],
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));

    expect(rollbar.options.scrubFields).to.contain('foobar');
    expect(rollbar.options.scrubFields).to.contain('password');
    done();
  });

  it('should overwrite default if specified', function (done) {
    var client = new (TestClientGen())();
    var options = {
      scrubFields: ['foobar'],
      overwriteScrubFields: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));

    expect(rollbar.options.scrubFields).to.contain('foobar');
    expect(rollbar.options.scrubFields).to.not.contain('password');
    done();
  });

  it('should replace deprecated options', function (done) {
    var client = new (TestClientGen())();
    var options = {
      hostWhiteList: ['foo'],
      hostBlackList: ['bar'],
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));

    expect(rollbar.options.hostWhiteList).to.eql(undefined);
    expect(rollbar.options.hostBlackList).to.eql(undefined);
    expect(rollbar.options.hostSafeList).to.contain('foo');
    expect(rollbar.options.hostBlockList).to.contain('bar');
    done();
  });

  it('should return a uuid when logging', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var result = rollbar.log('a messasge', 'another one');
    expect(result.uuid).to.be.ok();

    done();
  });

  it('should package up the inputs', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var result = rollbar.log('a message', 'another one');
    var loggedItem = client.logCalls[0].item;
    expect(loggedItem.message).to.eql('a message');
    expect(loggedItem.custom).to.be.ok();

    done();
  });

  it('should call the client with the right method', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var methods = 'log,debug,info,warn,warning,error,critical'.split(',');
    for (var i = 0; i < methods.length; i++) {
      var msg = 'message:' + i;
      rollbar[methods[i]](msg);
      expect(client.logCalls[i].func).to.eql(methods[i]);
      expect(client.logCalls[i].item.message).to.eql(msg);
    }

    done();
  });

  // Legacy OpenTracing support
  it('should have a tracer if valid tracer is provided', function (done) {
    var options = { tracer: ValidOpenTracingTracerStub };
    var rollbar = (window.rollbar = new Rollbar(options));

    expect(rollbar.client.tracer).to.eql(ValidOpenTracingTracerStub);

    done();
  });

  // Legacy OpenTracing support
  it('should not have a tracer if invalid tracer is provided', function (done) {
    var options = { tracer: InvalidOpenTracingTracerStub };
    var rollbar = (window.rollbar = new Rollbar(options));

    expect(rollbar.client.tracer).to.eql(null);

    done();
  });
});

describe('configure', function () {
  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
  });

  it('should configure client', function (done) {
    var client = new (TestClientGen())();
    var options = {
      payload: {
        a: 42,
        environment: 'testtest',
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));
    expect(rollbar.options.payload.environment).to.eql('testtest');

    rollbar.configure({ payload: { environment: 'borkbork' } });
    expect(rollbar.options.payload.environment).to.eql('borkbork');
    expect(client.options.payload.environment).to.eql('borkbork');
    done();
  });
  it('should accept a second parameter and use it as the payload value', function (done) {
    var client = new (TestClientGen())();
    var options = {
      payload: {
        a: 42,
        environment: 'testtest',
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));
    expect(rollbar.options.payload.environment).to.eql('testtest');

    rollbar.configure({ somekey: 'borkbork' }, { b: 97 });
    expect(rollbar.options.somekey).to.eql('borkbork');
    expect(rollbar.options.payload.b).to.eql(97);
    expect(client.payloadData.b).to.eql(97);
    done();
  });
  it('should accept a second parameter and override the payload with it', function (done) {
    var client = new (TestClientGen())();
    var options = {
      payload: {
        a: 42,
        environment: 'testtest',
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));
    expect(rollbar.options.payload.environment).to.eql('testtest');

    rollbar.configure({ somekey: 'borkbork', payload: { b: 101 } }, { b: 97 });
    expect(rollbar.options.somekey).to.eql('borkbork');
    expect(rollbar.options.payload.b).to.eql(97);
    expect(client.payloadData.b).to.eql(97);
    done();
  });
  it('should replace deprecated options', function (done) {
    var client = new (TestClientGen())();
    var options = {
      hostWhiteList: ['foo'],
      hostBlackList: ['bar'],
    };
    var rollbar = (window.rollbar = new Rollbar(
      { autoInstrument: false },
      client,
    ));
    rollbar.configure(options);

    expect(rollbar.options.hostWhiteList).to.eql(undefined);
    expect(rollbar.options.hostBlackList).to.eql(undefined);
    expect(rollbar.options.hostSafeList).to.contain('foo');
    expect(rollbar.options.hostBlockList).to.contain('bar');
    done();
  });
  it('should store configured options', function (done) {
    var client = new (TestClientGen())();
    var options = {
      captureUncaught: true,
      payload: {
        a: 42,
        environment: 'testtest',
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options, client));
    expect(rollbar.options._configuredOptions.payload.environment).to.eql(
      'testtest',
    );
    expect(rollbar.options._configuredOptions.captureUncaught).to.eql(true);

    rollbar.configure({
      captureUncaught: false,
      payload: { environment: 'borkbork' },
    });
    expect(rollbar.options._configuredOptions.payload.environment).to.eql(
      'borkbork',
    );
    expect(rollbar.options._configuredOptions.captureUncaught).to.eql(false);
    done();
  });
});

describe('options.captureUncaught', function () {
  beforeEach(function (done) {
    // Load the HTML page, so errors can be generated.
    document.write(window.__html__['examples/error.html']);

    window.server = sinon.createFakeServer();
    done();
  });

  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
    window.server.restore();
  });

  function stubResponse(server) {
    server.respondWith('POST', 'api/1/item', [
      200,
      { 'Content-Type': 'application/json' },
      '{"err": 0, "result":{ "uuid": "d4c7acef55bf4c9ea95e4fe9428a8287"}}',
    ]);
  }

  it('should capture when enabled in constructor', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var element = document.getElementById('throw-error');
    element.click();

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test error');
      expect(body.data.notifier.diagnostic.raw_error.message).to.eql(
        'test error',
      );
      expect(body.data.notifier.diagnostic.is_uncaught).to.eql(true);

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
      });

      done();
    }, 1);
  });

  it('should respond to enable/disable in configure', function (done) {
    var server = window.server;
    var element = document.getElementById('throw-error');
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: false,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    element.click();

    setTimeout(function () {
      server.respond();
      expect(server.requests.length).to.eql(0); // Disabled, no event
      server.requests.length = 0;

      rollbar.configure({
        captureUncaught: true,
      });

      element.click();

      setTimeout(function () {
        server.respond();

        var body = JSON.parse(server.requests[0].requestBody);

        expect(body.data.body.trace.exception.message).to.eql('test error');
        expect(body.data.notifier.diagnostic.is_anonymous).to.not.be.ok();

        server.requests.length = 0;

        rollbar.configure({
          captureUncaught: false,
        });

        element.click();

        setTimeout(function () {
          server.respond();
          expect(server.requests.length).to.eql(0); // Disabled, no event

          done();
        }, 1);
      }, 1);
    }, 1);
  });

  // Test case expects Chrome, which is the currently configured karma js/browser
  // engine at the time of this comment. However, karma's Chrome and ChromeHeadless
  // don't actually behave like real Chrome so we settle for stubbing some things.
  it('should capture external error data when inspectAnonymousErrors is true', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    // We're supposedly running on ChromeHeadless, but still need to spoof Chrome. :\
    window.chrome = { runtime: true };

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      inspectAnonymousErrors: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    // Simulate receiving onerror without an error object.
    rollbar.anonymousErrorsPending += 1;

    try {
      throw new Error('anon error');
    } catch (e) {
      Error.prepareStackTrace(e);
    }

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('anon error');
      expect(body.data.notifier.diagnostic.is_anonymous).to.eql(true);

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
      });

      done();
    }, 1);
  });

  it('should ignore duplicate errors by default', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var element = document.getElementById('throw-error');

    // generate same error twice
    for (var i = 0; i < 2; i++) {
      element.click(); // use for loop to ensure the stack traces have identical line/col info
    }

    setTimeout(function () {
      server.respond();

      // transmit only once
      expect(server.requests.length).to.eql(1);

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test error');

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
      });

      done();
    }, 1);
  });

  it('should transmit duplicate errors when set in config', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      ignoreDuplicateErrors: false,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var element = document.getElementById('throw-error');

    // generate same error twice
    for (var i = 0; i < 2; i++) {
      element.click(); // use for loop to ensure the stack traces have identical line/col info
    }

    setTimeout(function () {
      server.respond();

      // transmit both errors
      expect(server.requests.length).to.eql(2);

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test error');

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
      });

      done();
    }, 1);
  });
  it('should send DOMException as trace_chain', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var element = document.getElementById('throw-dom-exception');
    element.click();

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace_chain[0].exception.message).to.eql(
        'test DOMException',
      );

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
      });

      done();
    }, 1);
  });

  it('should capture exta frames when stackTraceLimit is set', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var oldLimit = Error.stackTraceLimit;
    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      stackTraceLimit: 50,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var element = document.getElementById('throw-depp-stack-error');
    element.click();

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('deep stack error');
      expect(body.data.body.trace.frames.length).to.be.above(20);

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
        stackTraceLimit: oldLimit, // reset to default
      });

      done();
    }, 1);
  });

  it('should add _wrappedSource when wrapGlobalEventHandlers is set', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      wrapGlobalEventHandlers: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var element = document.getElementById('throw-event-handler-error');
    element.click();

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql(
        'event handler error',
      );
      expect(body.data.body.trace.extra).to.have.property('_wrappedSource');

      // karma doesn't unload the browser between tests, so the onerror handler
      // will remain installed. Unset captureUncaught so the onerror handler
      // won't affect other tests.
      rollbar.configure({
        captureUncaught: false,
        wrapGlobalEventHandlers: false,
      });

      done();
    }, 100);
  });
});

describe('options.captureUnhandledRejections', function () {
  beforeEach(function (done) {
    window.server = sinon.createFakeServer();
    done();
  });

  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
    window.server.restore();
  });

  function stubResponse(server) {
    server.respondWith('POST', 'api/1/item', [
      200,
      { 'Content-Type': 'application/json' },
      '{"err": 0, "result":{ "uuid": "d4c7acef55bf4c9ea95e4fe9428a8287"}}',
    ]);
  }

  it('should capture when enabled in constructor', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUnhandledRejections: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    Promise.reject(new Error('test reject'));

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test reject');
      expect(body.data.notifier.diagnostic.is_uncaught).to.eql(true);

      rollbar.configure({
        captureUnhandledRejections: false,
      });
      window.removeEventListener('unhandledrejection', window._rollbarURH);

      done();
    }, 500);
  });

  it('should respond to enable in configure', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUnhandledRejections: false,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.configure({
      captureUnhandledRejections: true,
    });

    Promise.reject(new Error('test reject'));

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test reject');

      server.requests.length = 0;

      rollbar.configure({
        captureUnhandledRejections: false,
      });
      window.removeEventListener('unhandledrejection', window._rollbarURH);

      done();
    }, 500);
  });

  it('should respond to disable in configure', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUnhandledRejections: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.configure({
      captureUnhandledRejections: false,
    });

    Promise.reject(new Error('test reject'));

    setTimeout(function () {
      server.respond();

      expect(server.requests.length).to.eql(0); // Disabled, no event
      server.requests.length = 0;

      window.removeEventListener('unhandledrejection', window._rollbarURH);

      done();
    }, 500);
  });
});

describe('log', function () {
  beforeEach(function (done) {
    window.server = sinon.createFakeServer();
    done();
  });

  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
    window.server.restore();
  });

  function stubResponse(server) {
    server.respondWith('POST', 'api/1/item', [
      200,
      { 'Content-Type': 'application/json' },
      '{"err": 0, "result":{ "uuid": "d4c7acef55bf4c9ea95e4fe9428a8287"}}',
    ]);
  }

  it('should send message when called with message and extra args', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log('test message', { foo: 'bar' });

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.message.body).to.eql('test message');
      expect(body.data.body.message.extra).to.eql({ foo: 'bar' });
      expect(body.data.notifier.diagnostic.is_uncaught).to.eql(undefined);
      expect(body.data.notifier.diagnostic.original_arg_types).to.eql([
        'string',
        'object',
      ]);

      done();
    }, 1);
  });

  it('should send exception when called with error and extra args', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log(new Error('test error'), { foo: 'bar' });

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test error');
      expect(body.data.body.trace.extra).to.eql({ foo: 'bar' });
      expect(body.data.notifier.diagnostic.is_uncaught).to.eql(undefined);
      expect(body.data.notifier.diagnostic.original_arg_types).to.eql([
        'error',
        'object',
      ]);

      done();
    }, 1);
  });

  it('should add custom data when called with error context', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      addErrorContext: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var err = new Error('test error');
    err.rollbarContext = { err: 'test' };

    rollbar.error(err, { foo: 'bar' });

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql('test error');
      expect(body.data.custom.foo).to.eql('bar');
      expect(body.data.custom.err).to.eql('test');

      done();
    }, 1);
  });

  it('should add tracing attributes when called in an active span', function (done) {
    const server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    const options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
    };
    const rollbar = (window.rollbar = new Rollbar(options));

    const err = new Error('test error');

    rollbar.tracing.withSpan('test', {}, () => {
      rollbar.error(err);
    });

    setTimeout(function () {
      try{
        server.respond();

        var body = JSON.parse(server.requests[0].requestBody);

        expect(body.data.body.trace.exception.message).to.eql('test error');
        expect(body.data.attributes).to.be.an('array');
        expect(body.data.attributes.length).to.eql(3);
        expect(body.data.attributes[0].key).to.eql('session_id');
        expect(body.data.attributes[0].value).to.match(/^[a-f0-9]{32}$/);
        expect(body.data.attributes[1].key).to.eql('span_id');
        expect(body.data.attributes[1].value).to.match(/^[a-f0-9]{16}$/);
        expect(body.data.attributes[2].key).to.eql('trace_id');
        expect(body.data.attributes[2].value).to.match(/^[a-f0-9]{32}$/);

        done();
      } catch (e) {
        done(e);
      }
    }, 1);
  });


  it('should send message when called with only null arguments', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUnhandledRejections: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log(null);

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.message.body).to.eql(
        'Item sent with null or missing arguments.',
      );
      expect(body.data.notifier.diagnostic.original_arg_types).to.eql(['null']);

      done();
    }, 1);
  });

  it('should skipFrames when set', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUnhandledRejections: true,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var error = new Error('error with stack');

    rollbar.log(error);
    rollbar.log(error, { skipFrames: 1 });

    setTimeout(function () {
      server.respond();

      var frames1 = JSON.parse(server.requests[0].requestBody).data.body.trace
        .frames;
      var frames2 = JSON.parse(server.requests[1].requestBody).data.body.trace
        .frames;

      expect(frames1.length).to.eql(frames2.length + 1);
      expect(frames1.slice(0, -1)).to.eql(frames2);

      done();
    }, 1);
  });

  it('should call the item callback on error', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    // Create an invalid tracer, in order to force an error in notifier._log()
    var tracer = {
      scope: function () {
        return {
          active: function () {
            throw new Error('Test error');
          },
        };
      },
    };

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      tracer: tracer,
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var callbackCalled;
    var callback = function (err) {
      callbackCalled = err;
    };

    rollbar.log('test', callback);

    setTimeout(function () {
      server.respond();

      expect(callbackCalled.message).to.eql('Test error');

      done();
    }, 1);
  });
});

// Test direct call to onerror, as used in verification of browser js install.
describe('onerror', function () {
  beforeEach(function (done) {
    window.server = sinon.createFakeServer();
    done();
  });

  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
    window.server.restore();
  });

  function stubResponse(server) {
    server.respondWith('POST', 'api/1/item', [
      200,
      { 'Content-Type': 'application/json' },
      '{"err": 0, "result":{ "uuid": "d4c7acef55bf4c9ea95e4fe9428a8287"}}',
    ]);
  }

  it('should send message when calling onerror directly', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
    };
    window.rollbar = new Rollbar(options);

    window.onerror(
      'TestRollbarError: testing window.onerror',
      window.location.href,
    );

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.trace.exception.message).to.eql(
        'testing window.onerror',
      );

      done();
    }, 1);
  });
});

describe('callback options', function () {
  beforeEach(function (done) {
    window.server = sinon.createFakeServer();
    done();
  });

  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
    window.server.restore();
  });

  function stubResponse(server) {
    server.respondWith('POST', 'api/1/item', [
      200,
      { 'Content-Type': 'application/json' },
      '{"err": 0, "result":{ "uuid": "d4c7acef55bf4c9ea95e4fe9428a8287"}}',
    ]);
  }

  it('should use checkIgnore when set', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      checkIgnore: function (_isUncaught, _args, _payload) {
        return true;
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log('test'); // generate a payload to ignore

    setTimeout(function () {
      server.respond();

      expect(server.requests.length).to.eql(0);

      done();
    }, 1);
  });

  it('should receive valid arguments at checkIgnore', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      checkIgnore: function (_isUncaught, args, payload) {
        if (_isUncaught === false && args[0] instanceof Error && payload.uuid) {
          return true;
        }
        return false;
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log(new Error('test'));

    setTimeout(function () {
      server.respond();

      // Should be ignored if all checks pass.
      expect(server.requests.length).to.eql(0);

      done();
    }, 1);
  });

  it('should receive uncaught at checkIgnore', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      captureUncaught: true,
      checkIgnore: function (isUncaught, args, payload) {
        if (isUncaught === true) {
          return true;
        }
        return false;
      },
    };
    window.rollbar = new Rollbar(options);

    var element = document.getElementById('throw-error');
    element.click();

    setTimeout(function () {
      server.respond();

      // Should be ignored if checkIgnore receives isUncaught.
      expect(server.requests.length).to.eql(0);

      done();
    }, 1);
  });

  it('should send when checkIgnore returns false', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      checkIgnore: function (_isUncaught, _args, _payload) {
        return false;
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log('test'); // generate a payload to inspect

    setTimeout(function () {
      server.respond();

      expect(server.requests.length).to.eql(1);
      var body = JSON.parse(server.requests[0].requestBody);
      expect(
        body.data.notifier.configured_options.checkIgnore.substr(0, 8),
      ).to.eql('function');

      done();
    }, 1);
  });

  it('should use onSendCallback when set', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      onSendCallback: function (_isUncaught, _args, payload) {
        payload.foo = 'bar';
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log('test'); // generate a payload to inspect

    setTimeout(function () {
      server.respond();

      expect(server.requests.length).to.eql(1);
      var body = JSON.parse(server.requests[0].requestBody);
      expect(body.data.foo).to.eql('bar');
      expect(
        body.data.notifier.configured_options.onSendCallback.substr(0, 8),
      ).to.eql('function');

      done();
    }, 1);
  });

  it('should use transform when set', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      transform: function (data, _item) {
        data.foo = 'baz';
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log('test'); // generate a payload to inspect

    setTimeout(function () {
      server.respond();

      expect(server.requests.length).to.eql(1);
      var body = JSON.parse(server.requests[0].requestBody);
      expect(body.data.foo).to.eql('baz');
      expect(
        body.data.notifier.configured_options.transform.substr(0, 8),
      ).to.eql('function');

      done();
    }, 1);
  });
});

describe('options.autoInstrument', function () {
  beforeEach(function (done) {
    window.server = sinon.createFakeServer();
    done();
  });

  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
    window.server.restore();
  });

  function stubResponse(server) {
    server.respondWith('POST', 'api/1/item', [
      200,
      { 'Content-Type': 'application/json' },
      '{"err": 0, "result":{ "uuid": "d4c7acef55bf4c9ea95e4fe9428a8287"}}',
    ]);
  }

  describe('options.autoInstrument.contentSecurityPolicy', function () {
    beforeEach(function (done) {
      var options = {
        accessToken: 'POST_CLIENT_ITEM_TOKEN',
        autoInstrument: {
          log: false,
          contentSecurityPolicy: true,
          errorOnContentSecurityPolicy: true,
        },
      };
      window.rollbar = new Rollbar(options);
      done();
    });

    afterEach(function () {
      window.rollbar.configure({
        autoInstrument: false,
        captureUncaught: false,
      });
    });

    it('should report content security policy errors', function (done) {
      var queue = rollbar.client.notifier.queue;
      var queueStub = sinon.stub(queue, '_makeApiRequest');

      // Load the HTML page, so errors can be generated.
      document.write(window.__html__['examples/csp-errors.html']);

      setTimeout(function () {
        try {
          var item = queueStub.getCall(0).args[0];
          var message = item.body.message.body;
          var telemetry = item.body.telemetry[0];

          expect(message).to.match(/Security Policy Violation/);
          expect(message).to.match(/blockedURI: https:\/\/example.com\/v3\//);
          expect(message).to.match(/violatedDirective: script-src/);
          expect(message).to.match(
            /originalPolicy: default-src 'self' 'unsafe-inline' 'unsafe-eval';/,
          );

          expect(telemetry.level).to.eql('error');
          expect(telemetry.type).to.eql('log');
          expect(telemetry.body.message).to.match(/Security Policy Violation/);
          expect(telemetry.body.message).to.match(
            /blockedURI: https:\/\/example.com\/v3\//,
          );
          expect(telemetry.body.message).to.match(
            /violatedDirective: script-src/,
          );
          expect(telemetry.body.message).to.match(
            /originalPolicy: default-src 'self' 'unsafe-inline' 'unsafe-eval';/,
          );

          done();
        } catch (e) {
          done(e);
        }
      }, 100);
    });
  });

  it('should add telemetry events when console.log is called', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    console.log('console test'); // generate a telemetry event

    rollbar.log('test'); // generate a payload to inspect

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      expect(body.data.body.telemetry[0].body.message).to.eql('console test');

      done();
    }, 1);
  });

  function initRollbarForNetworkTelemetry() {
    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      autoInstrument: {
        log: false,
        network: true,
        networkResponseHeaders: true,
        networkResponseBody: true,
        networkRequestBody: true,
        networkRequestHeaders: true,
      },
    };
    return new Rollbar(options);
  }

  it('should add telemetry events for POST xhr calls', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    server.respondWith('POST', 'https://example.com/xhr-test', [
      200,
      { 'Content-Type': 'application/json', Password: '123456' },
      JSON.stringify({ name: 'foo', password: '123456' }),
    ]);

    var rollbar = (window.rollbar = initRollbarForNetworkTelemetry());

    // generate a telemetry event
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://example.com/xhr-test', true);
    xhr.setRequestHeader('Content-type', 'application/json');
    xhr.setRequestHeader('Secret', 'abcdef');
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        try {
          rollbar.log('test'); // generate a payload to inspect

          setTimeout(function () {
            server.respond();

            expect(server.requests.length).to.eql(2);
            var body = JSON.parse(server.requests[1].requestBody);

            // Verify request capture and scrubbing
            expect(body.data.body.telemetry[0].body.request).to.eql(
              '{"name":"bar","secret":"********"}',
            );

            // Verify request headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.request_headers).to.eql({
              'Content-type': 'application/json',
              Secret: '********',
            });

            // Verify response capture and scrubbing
            expect(body.data.body.telemetry[0].body.response.body).to.eql(
              '{"name":"foo","password":"********"}',
            );
            expect(
              body.data.body.telemetry[0].body.response.headers['Password'],
            ).to.eql('********');

            done();
          }, 1);
        } catch (e) {
          done(e);
        }
      }
    };
    xhr.send(JSON.stringify({ name: 'bar', secret: 'xhr post' }));
    server.respond();
  });

  it('should add telemetry events for GET xhr calls', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    server.respondWith('GET', 'https://example.com/xhr-test', [
      200,
      { 'Content-Type': 'application/json', Password: 'abcdef' },
      JSON.stringify({ name: 'foo', password: '123456' }),
    ]);

    var rollbar = (window.rollbar = initRollbarForNetworkTelemetry());

    // generate a telemetry event
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://example.com/xhr-test', true);
    xhr.setRequestHeader('Secret', 'abcdef');
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        try {
          rollbar.log('test'); // generate a payload to inspect

          setTimeout(function () {
            server.respond();

            expect(server.requests.length).to.eql(2);
            var body = JSON.parse(server.requests[1].requestBody);

            // Verify request headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.request_headers).to.eql({
              Secret: '********',
            });

            // Verify response capture and scrubbing
            expect(body.data.body.telemetry[0].body.response.body).to.eql(
              '{"name":"foo","password":"********"}',
            );
            expect(
              body.data.body.telemetry[0].body.response.headers['Password'],
            ).to.eql('********');

            done();
          }, 1);
        } catch (e) {
          done(e);
        }
      }
    };
    xhr.send(JSON.stringify({ name: 'bar', secret: 'xhr post' }));
    server.respond();
  });

  it('should handle non-string Content-Type', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    server.respondWith('GET', 'https://example.com/xhr-test', [
      200,
      {
        'Content-Type': {}, // unexpected/invalid (non-string) content type
        Password: 'abcdef',
      },
      JSON.stringify({ name: 'foo', password: '123456' }),
    ]);

    var rollbar = (window.rollbar = initRollbarForNetworkTelemetry());

    // generate a telemetry event
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://example.com/xhr-test', true);
    xhr.setRequestHeader('Secret', 'abcdef');
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        try {
          rollbar.log('test'); // generate a payload to inspect

          setTimeout(function () {
            server.respond();

            expect(server.requests.length).to.eql(2);
            var body = JSON.parse(server.requests[1].requestBody);

            // Verify request headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.request_headers).to.eql({
              Secret: '********',
            });

            // Not scrubbed for unrecognized content type
            expect(body.data.body.telemetry[0].body.response.body).to.eql(
              '{"name":"foo","password":"123456"}',
            );

            expect(
              body.data.body.telemetry[0].body.response.headers['Password'],
            ).to.eql('********');

            done();
          }, 1);
        } catch (e) {
          done(e);
        }
      }
    };
    xhr.send(JSON.stringify({ name: 'bar', secret: 'xhr post' }));
    server.respond();
  });

  it('should send errors for xhr http errors', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    server.respondWith('POST', 'xhr-test', [
      404,
      { 'Content-Type': 'application/json' },
      JSON.stringify({ foo: 'bar' }),
    ]);

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      autoInstrument: {
        log: false,
        network: true,
        networkErrorOnHttp4xx: true,
      },
    };
    window.rollbar = new Rollbar(options);

    // generate a telemetry event
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://example.com/xhr-test', true);
    xhr.setRequestHeader('Content-type', 'application/json');
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        try {
          setTimeout(function () {
            try {
              server.respond();

              expect(server.requests.length).to.eql(2);
              var body = JSON.parse(server.requests[1].requestBody);

              expect(body.data.body.trace.exception.message).to.eql(
                'HTTP request failed with Status 404',
              );

              // Just knowing a stack is present is enough for this test.
              expect(body.data.body.trace.frames.length).to.be.above(1);

              done();
            } catch (e) {
              done(e);
            }
          }, 1);
        } catch (e) {
          done(e);
        }
      }
    };
    xhr.send(JSON.stringify({ name: 'bar', secret: 'xhr post' }));
    setTimeout(function () {
      server.respond();
    }, 1);
  });

  it('should add telemetry events for fetch calls', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    window.fetchStub = sinon.stub(window, 'fetch');

    var responseBody = JSON.stringify({ name: 'foo', password: '123456' });
    window.fetch.returns(
      Promise.resolve(
        new Response(responseBody, {
          status: 200,
          statusText: 'OK',
          headers: { 'content-type': 'application/json', password: '123456' },
        }),
      ),
    );

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      autoInstrument: {
        log: false,
        network: true,
        networkResponseHeaders: true,
        networkResponseBody: true,
        networkRequestBody: true,
        networkRequestHeaders: true,
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    var fetchHeaders = new Headers();
    fetchHeaders.append('Content-Type', 'application/json');
    fetchHeaders.append('Secret', '123456');

    const fetchInit = {
      method: 'POST',
      headers: fetchHeaders,
      body: JSON.stringify({ name: 'bar', secret: 'fetch post' }),
    };
    var fetchRequest = new Request('https://example.com/fetch-test');
    window
      .fetch(fetchRequest, fetchInit)
      .then(function (response) {
        // Assert that the original stream reader hasn't been read.
        expect(response.bodyUsed).to.eql(false);
        return response.text();
      })
      .then(function (text) {
        expect(text).to.eql(responseBody);

        try {
          rollbar.log('test'); // generate a payload to inspect
        } catch (e) {
          done(e);
          return;
        }

        setTimeout(function () {
          try {
            server.respond();

            expect(window.fetchStub.called).to.be.ok();
            expect(server.requests.length).to.eql(1);
            var body = JSON.parse(server.requests[0].requestBody);

            // Verify request capture and scrubbing
            expect(body.data.body.telemetry[0].body.request).to.eql(
              '{"name":"bar","secret":"********"}',
            );

            // Verify request headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.request_headers).to.eql({
              'content-type': 'application/json',
              secret: '********',
            });

            // Verify response capture and scrubbing
            expect(body.data.body.telemetry[0].body.response.body).to.eql(
              '{"name":"foo","password":"********"}',
            );

            // Verify response headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.response.headers).to.eql({
              'content-type': 'application/json',
              password: '********',
            });

            rollbar.configure({ autoInstrument: false });
            window.fetch.restore();
            done();
          } catch (e) {
            done(e);
            return;
          }
        }, 1);
      });
  });

  it('should report error for http 4xx fetch calls, when enabled', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    window.fetchStub = sinon.stub(window, 'fetch');
    window.fetch.returns(
      Promise.resolve(
        new Response(JSON.stringify({ foo: 'bar' }), {
          status: 404,
          statusText: 'Not Found',
          headers: { 'content-type': 'application/json' },
        }),
      ),
    );

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      autoInstrument: {
        log: false,
        network: true,
        networkErrorOnHttp4xx: true,
      },
    };
    window.rollbar = new Rollbar(options);

    var fetchHeaders = new Headers();
    fetchHeaders.append('Content-Type', 'application/json');

    const fetchInit = {
      method: 'POST',
      headers: fetchHeaders,
      body: JSON.stringify({ foo: 'bar' }),
    };
    var fetchRequest = new Request('https://example.com/xhr-test');
    window.fetch(fetchRequest, fetchInit).then(function (_response) {
      setTimeout(function () {
        try {
          server.respond();

          expect(server.requests.length).to.eql(1);
          var body = JSON.parse(server.requests[0].requestBody);

          expect(body.data.body.trace.exception.message).to.eql(
            'HTTP request failed with Status 404',
          );

          // Just knowing a stack is present is enough for this test.
          expect(body.data.body.trace.frames.length).to.be.above(1);

          rollbar.configure({ autoInstrument: false });
          window.fetch.restore();
          done();
        } catch (e) {
          done(e);
        }
      }, 1);
    });
  });

  it('should add telemetry headers when fetch Headers object is undefined', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    window.fetchStub = sinon.stub(window, 'fetch');

    var readableStream = new ReadableStream({
      start(controller) {
        controller.enqueue(JSON.stringify({ name: 'foo', password: '123456' }));
        controller.close();
      },
    });

    window.fetch.returns(
      Promise.resolve(
        new Response(readableStream, {
          status: 200,
          statusText: 'OK',
          headers: { 'content-type': 'application/json', password: '123456' },
        }),
      ),
    );

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
      autoInstrument: {
        log: false,
        network: true,
        networkResponseHeaders: true,
        networkRequestHeaders: true,
      },
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    // Remove Headers from window object
    var originalHeaders = window.Headers;
    delete window.Headers;

    const fetchInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Secret: '123456' },
      body: JSON.stringify({ name: 'bar', secret: 'xhr post' }),
    };
    var fetchRequest = new Request('https://example.com/xhr-test');
    window.fetch(fetchRequest, fetchInit).then(function (response) {
      try {
        rollbar.log('test'); // generate a payload to inspect
        setTimeout(function () {
          try {
            server.respond();

            expect(server.requests.length).to.eql(1);
            var body = JSON.parse(server.requests[0].requestBody);

            // Verify request headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.request_headers).to.eql({
              'content-type': 'application/json',
              secret: '********',
            });

            // Verify response headers capture and case-insensitive scrubbing
            expect(body.data.body.telemetry[0].body.response.headers).to.eql({
              'content-type': 'application/json',
              password: '********',
            });

            // Assert that the original stream reader hasn't been read.
            expect(response.bodyUsed).to.eql(false);

            rollbar.configure({ autoInstrument: false });
            window.fetch.restore();
            window.Headers = originalHeaders;
            done();
          } catch (e) {
            done(e);
          }
        });
      } catch (e) {
        done(e);
      }
    });
  });

  it('should add a diagnostic message when wrapConsole fails', function (done) {
    var server = window.server;
    stubResponse(server);
    server.requests.length = 0;

    var oldConsole = window.console;
    var newConsole = {};
    Object.defineProperty(newConsole, 'log', {
      get: function () {
        return function (message) {
          oldConsole.log(message);
          return message;
        };
      },
    });
    window.console = newConsole;

    var options = {
      accessToken: 'POST_CLIENT_ITEM_TOKEN',
    };
    var rollbar = (window.rollbar = new Rollbar(options));

    rollbar.log('test'); // generate a payload to inspect

    setTimeout(function () {
      server.respond();

      var body = JSON.parse(server.requests[0].requestBody);

      window.console = oldConsole;

      expect(
        rollbar.client.notifier.diagnostic.instrumentConsole,
      ).to.have.property('error');
      expect(body.data.notifier.diagnostic.instrumentConsole).to.have.property(
        'error',
      );

      done();
    }, 1);
  });
});

describe('captureEvent', function () {
  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
  });

  it('should handle missing/default type and level', function (done) {
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options));

    var event = rollbar.captureEvent({ foo: 'bar' });
    expect(event.type).to.eql('manual');
    expect(event.level).to.eql('info');
    expect(event.body.foo).to.eql('bar');

    done();
  });
  it('should handle specified type and level', function (done) {
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options));

    var event = rollbar.captureEvent('log', { foo: 'bar' }, 'debug');
    expect(event.type).to.eql('log');
    expect(event.level).to.eql('debug');
    expect(event.body.foo).to.eql('bar');

    done();
  });
  it('should handle extra args', function (done) {
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options));

    var event = rollbar.captureEvent(
      'meaningless',
      'info',
      { foo: 'bar' },
      23,
      'debug',
    );
    expect(event.type).to.eql('manual');
    expect(event.level).to.eql('info');
    expect(event.body.foo).to.eql('bar');

    done();
  });
  it('should handle level that matches a type string', function (done) {
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options));

    var event = rollbar.captureEvent('log', { foo: 'bar' }, 'error');
    // ensure level 'error' doesn't overwrite type 'log'
    expect(event.type).to.eql('log');
    expect(event.level).to.eql('error');
    expect(event.body.foo).to.eql('bar');

    done();
  });
});

describe('createItem', function () {
  afterEach(function () {
    window.rollbar.configure({ autoInstrument: false, captureUncaught: false });
  });

  it('should handle multiple strings', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = ['first', 'second'];
    var item = rollbar._createItem(args);
    expect(item.message).to.eql('first');
    expect(item.custom.extraArgs['0']).to.eql('second');

    done();
  });
  it('should handle errors', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [new Error('Whoa'), 'first', 'second'];
    var item = rollbar._createItem(args);
    expect(item.err).to.eql(args[0]);
    expect(item.message).to.eql('first');
    expect(item.custom.extraArgs['0']).to.eql('second');

    done();
  });
  it('should handle a callback', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var myCallbackCalled = false;
    var myCallback = function () {
      myCallbackCalled = true;
    };
    var args = [new Error('Whoa'), 'first', myCallback, 'second'];
    var item = rollbar._createItem(args);
    expect(item.err).to.eql(args[0]);
    expect(item.message).to.eql('first');
    expect(item.custom.extraArgs).to.eql(['second']);
    expect(item.callback).to.be.ok();
    item.callback();
    expect(myCallbackCalled).to.be.ok();

    done();
  });
  it('should handle arrays', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [new Error('Whoa'), 'first', [1, 2, 3], 'second'];
    var item = rollbar._createItem(args);
    expect(item.err).to.eql(args[0]);
    expect(item.message).to.eql('first');
    expect(item.custom['0']).to.eql(1);
    expect(item.custom.extraArgs).to.eql(['second']);

    done();
  });
  it('should handle objects', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [new Error('Whoa'), 'first', { a: 1, b: 2 }, 'second'];
    var item = rollbar._createItem(args);
    expect(item.err).to.eql(args[0]);
    expect(item.message).to.eql('first');
    expect(item.custom.a).to.eql(1);
    expect(item.custom.b).to.eql(2);
    expect(item.custom.extraArgs).to.eql(['second']);

    done();
  });
  it('should handle custom arguments', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [
      new Error('Whoa'),
      { level: 'info', skipFrames: 1, foo: 'bar' },
    ];
    var item = rollbar._createItem(args);
    expect(item.err).to.eql(args[0]);
    expect(item.level).to.eql('info');
    expect(item.skipFrames).to.eql(1);
    expect(item.custom.foo).to.eql('bar');
    expect(item.custom.level).to.not.be.ok();
    expect(item.custom.skipFrames).to.not.be.ok();

    done();
  });
  it('should have a timestamp', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [new Error('Whoa'), 'first', { a: 1, b: 2 }, 'second'];
    var item = rollbar._createItem(args);
    var now = new Date().getTime();
    expect(item.timestamp).to.be.within(now - 1000, now + 1000);

    done();
  });
  it('should have an uuid', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [new Error('Whoa'), 'first', { a: 1, b: 2 }, 'second'];
    var item = rollbar._createItem(args);
    expect(item.uuid).to.be.ok();

    var parts = item.uuid.split('-');
    expect(parts.length).to.eql(5);
    // Type 4 UUID
    expect(parts[2][0]).to.eql('4');

    done();
  });
  it('should handle dates', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var y2k = new Date(2000, 0, 1);
    var args = [new Error('Whoa'), 'first', y2k, { a: 1, b: 2 }, 'second'];
    var item = rollbar._createItem(args);
    expect(item.custom.extraArgs).to.eql([y2k, 'second']);

    done();
  });
  it('should handle numbers', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    var args = [new Error('Whoa'), 'first', 42, { a: 1, b: 2 }, 'second'];
    var item = rollbar._createItem(args);
    expect(item.custom.extraArgs).to.eql([42, 'second']);

    done();
  });
  it('should handle domexceptions', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = (window.rollbar = new Rollbar(options, client));

    if (document && document.querySelectorAll) {
      var e;
      try {
        document.querySelectorAll('div:foo');
      } catch (ee) {
        e = ee;
      }
      var args = [e, 'first', 42, { a: 1, b: 2 }, 'second'];
      var item = rollbar._createItem(args);
      expect(item.err).to.be.ok();
    }

    done();
  });
});

describe('singleton', function () {
  it('should pass through the underlying client after init', function (done) {
    var client = new (TestClientGen())();
    var options = {};
    var rollbar = Rollbar.init(options, client);

    rollbar.log('hello 1');
    Rollbar.log('hello 2');

    var loggedItemDirect = client.logCalls[0].item;
    var loggedItemSingleton = client.logCalls[1].item;
    expect(loggedItemDirect.message).to.eql('hello 1');
    expect(loggedItemSingleton.message).to.eql('hello 2');

    done();
  });
});

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQ0FBcUMsU0FBUyxXQUFXLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxZQUFZO0FBQ3BCLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUZBQXVGO0FBQzdGLE1BQU0sbUVBQW1FO0FBQ3pFLE1BQU0saURBQWlEO0FBQ3ZELE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMENBQTBDO0FBQzlGLHNEQUFzRCxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLDJFQUEyRTtBQUNqRixNQUFNLGlDQUFpQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekMsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3Qyx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUErQztBQUN2RDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkRBQTZEO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixhQUFhLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUErQztBQUN2RDtBQUNBLHdCQUF3QjtBQUN4QixRQUFRO0FBQ1IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsVUFBVTtBQUNWLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxLQUFLLHVCQUF1QiwyQkFBMkIsd0JBQXdCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHLEdBQUcsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVCQUF1QixnQkFBZ0I7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBLEtBQUs7QUFDTCxZQUFZLE9BQU87QUFDbkIsc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUF1RDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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Q0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQix1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2xsYmFyL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vbm9kZV9tb2R1bGVzL0BycndlYi9yZWNvcmQvZGlzdC9yZWNvcmQuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL25vZGVfbW9kdWxlcy9AcnJ3ZWIvdHlwZXMvZGlzdC90eXBlcy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtcG9seWZpbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL25vZGVfbW9kdWxlcy9lcnJvci1zdGFjay1wYXJzZXIvZXJyb3Itc3RhY2stcGFyc2VyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9ub2RlX21vZHVsZXMvZXJyb3Itc3RhY2stcGFyc2VyL25vZGVfbW9kdWxlcy9zdGFja2ZyYW1lL3N0YWNrZnJhbWUuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9hcGkuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9hcGlVdGlsaXR5LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9jb3JlLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9kZWZhdWx0cy9zY3J1YkZpZWxkcy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvZGV0ZWN0aW9uLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9kb21VdGlsaXR5LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9nbG9iYWxTZXR1cC5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvbG9nZ2VyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9wcmVkaWNhdGVzLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci9yZXBsYXkvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3JlcGxheS9yZWNvcmRlci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvcmVwbGF5L3JlcGxheU1hcC5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvcm9sbGJhci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvdGVsZW1ldHJ5LmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci90cmFuc2Zvcm1zLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9icm93c2VyL3RyYW5zcG9ydC9mZXRjaC5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvdHJhbnNwb3J0L3hoci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2Jyb3dzZXIvdXJsLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvYnJvd3Nlci93cmFwR2xvYmFscy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvZXJyb3JQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL25vdGlmaWVyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvcHJlZGljYXRlcy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3F1ZXVlLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvcmF0ZUxpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy9yb2xsYmFyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvc2NydWIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90ZWxlbWV0cnkuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL2NvbnRleHRNYW5hZ2VyLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdHJhY2luZy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3RyYWNpbmcvZXhwb3J0ZXIuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL2hydGltZS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3RyYWNpbmcvaWQuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL3Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL3NwYW4uanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL3NwYW5Qcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cmFjaW5nL3RyYWNlci5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3RyYWNpbmcvdHJhY2luZy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3RyYW5zZm9ybXMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci8uL3NyYy90cnVuY2F0aW9uLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdXRpbGl0eS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3V0aWxpdHkvaGVhZGVycy5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vc3JjL3V0aWxpdHkvcG9seWZpbGxKU09OLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdXRpbGl0eS9yZXBsYWNlLmpzIiwid2VicGFjazovL3JvbGxiYXIvLi9zcmMvdXRpbGl0eS90cmF2ZXJzZS5qcyIsIndlYnBhY2s6Ly9yb2xsYmFyLy4vdmVuZG9yL0pTT04tanMvanNvbjMuanMiLCJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9yb2xsYmFyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9yb2xsYmFyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcm9sbGJhci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3JvbGxiYXIvLi90ZXN0L2Jyb3dzZXIucm9sbGJhci50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbnZhciBfYTtcbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIE5vZGVUeXBlJDMgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlVHlwZTIpID0+IHtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICByZXR1cm4gTm9kZVR5cGUyO1xufSkoTm9kZVR5cGUkMyB8fCB7fSk7XG5jb25zdCB0ZXN0YWJsZUFjY2Vzc29ycyQxID0ge1xuICBOb2RlOiBbXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiLCBcInBhcmVudEVsZW1lbnRcIiwgXCJ0ZXh0Q29udGVudFwiXSxcbiAgU2hhZG93Um9vdDogW1wiaG9zdFwiLCBcInN0eWxlU2hlZXRzXCJdLFxuICBFbGVtZW50OiBbXCJzaGFkb3dSb290XCIsIFwicXVlcnlTZWxlY3RvclwiLCBcInF1ZXJ5U2VsZWN0b3JBbGxcIl0sXG4gIE11dGF0aW9uT2JzZXJ2ZXI6IFtdXG59O1xuY29uc3QgdGVzdGFibGVNZXRob2RzJDEgPSB7XG4gIE5vZGU6IFtcImNvbnRhaW5zXCIsIFwiZ2V0Um9vdE5vZGVcIl0sXG4gIFNoYWRvd1Jvb3Q6IFtcImdldFNlbGVjdGlvblwiXSxcbiAgRWxlbWVudDogW10sXG4gIE11dGF0aW9uT2JzZXJ2ZXI6IFtcImNvbnN0cnVjdG9yXCJdXG59O1xuY29uc3QgdW50YWludGVkQmFzZVByb3RvdHlwZSQxID0ge307XG5jb25zdCBpc0FuZ3VsYXJab25lUHJlc2VudCQxID0gKCkgPT4ge1xuICByZXR1cm4gISFnbG9iYWxUaGlzLlpvbmU7XG59O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoa2V5KSB7XG4gIGlmICh1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV07XG4gIGNvbnN0IGRlZmF1bHRPYmogPSBnbG9iYWxUaGlzW2tleV07XG4gIGNvbnN0IGRlZmF1bHRQcm90b3R5cGUgPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgY29uc3QgYWNjZXNzb3JOYW1lcyA9IGtleSBpbiB0ZXN0YWJsZUFjY2Vzc29ycyQxID8gdGVzdGFibGVBY2Nlc3NvcnMkMVtrZXldIDogdm9pZCAwO1xuICBjb25zdCBpc1VudGFpbnRlZEFjY2Vzc29ycyA9IEJvb2xlYW4oXG4gICAgYWNjZXNzb3JOYW1lcyAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBhY2Nlc3Nvck5hbWVzLmV2ZXJ5KFxuICAgICAgKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgICAoX2IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0UHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IG1ldGhvZE5hbWVzID0ga2V5IGluIHRlc3RhYmxlTWV0aG9kcyQxID8gdGVzdGFibGVNZXRob2RzJDFba2V5XSA6IHZvaWQgMDtcbiAgY29uc3QgaXNVbnRhaW50ZWRNZXRob2RzID0gQm9vbGVhbihcbiAgICBtZXRob2ROYW1lcyAmJiBtZXRob2ROYW1lcy5ldmVyeShcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgICAgKG1ldGhvZCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiICYmICgoX2EyID0gZGVmYXVsdFByb3RvdHlwZVttZXRob2RdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGlmIChpc1VudGFpbnRlZEFjY2Vzc29ycyAmJiBpc1VudGFpbnRlZE1ldGhvZHMgJiYgIWlzQW5ndWxhclpvbmVQcmVzZW50JDEoKSkge1xuICAgIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgaWZyYW1lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lRWwpO1xuICAgIGNvbnN0IHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgaWYgKCF3aW4pIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICBjb25zdCB1bnRhaW50ZWRPYmplY3QgPSB3aW5ba2V5XS5wcm90b3R5cGU7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWVFbCk7XG4gICAgaWYgKCF1bnRhaW50ZWRPYmplY3QpIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICAgIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSA9IHVudGFpbnRlZE9iamVjdDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gIH1cbn1cbmNvbnN0IHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkQWNjZXNzb3IkMShrZXksIGluc3RhbmNlLCBhY2Nlc3Nvcikge1xuICB2YXIgX2EyO1xuICBjb25zdCBjYWNoZUtleSA9IGAke2tleX0uJHtTdHJpbmcoYWNjZXNzb3IpfWA7XG4gIGlmICh1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDFbY2FjaGVLZXldKVxuICAgIHJldHVybiB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDFbY2FjaGVLZXldLmNhbGwoXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gIGNvbnN0IHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSk7XG4gIGNvbnN0IHVudGFpbnRlZEFjY2Vzc29yID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgdW50YWludGVkUHJvdG90eXBlLFxuICAgIGFjY2Vzc29yXG4gICkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0O1xuICBpZiAoIXVudGFpbnRlZEFjY2Vzc29yKSByZXR1cm4gaW5zdGFuY2VbYWNjZXNzb3JdO1xuICB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDFbY2FjaGVLZXldID0gdW50YWludGVkQWNjZXNzb3I7XG4gIHJldHVybiB1bnRhaW50ZWRBY2Nlc3Nvci5jYWxsKGluc3RhbmNlKTtcbn1cbmNvbnN0IHVudGFpbnRlZE1ldGhvZENhY2hlJDEgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZE1ldGhvZCQxKGtleSwgaW5zdGFuY2UsIG1ldGhvZCkge1xuICBjb25zdCBjYWNoZUtleSA9IGAke2tleX0uJHtTdHJpbmcobWV0aG9kKX1gO1xuICBpZiAodW50YWludGVkTWV0aG9kQ2FjaGUkMVtjYWNoZUtleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldLmJpbmQoXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gIGNvbnN0IHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSk7XG4gIGNvbnN0IHVudGFpbnRlZE1ldGhvZCA9IHVudGFpbnRlZFByb3RvdHlwZVttZXRob2RdO1xuICBpZiAodHlwZW9mIHVudGFpbnRlZE1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXTtcbiAgdW50YWludGVkTWV0aG9kQ2FjaGUkMVtjYWNoZUtleV0gPSB1bnRhaW50ZWRNZXRob2Q7XG4gIHJldHVybiB1bnRhaW50ZWRNZXRob2QuYmluZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjaGlsZE5vZGVzJDEobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcImNoaWxkTm9kZXNcIik7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlJDEobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcInBhcmVudE5vZGVcIik7XG59XG5mdW5jdGlvbiBwYXJlbnRFbGVtZW50JDEobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcInBhcmVudEVsZW1lbnRcIik7XG59XG5mdW5jdGlvbiB0ZXh0Q29udGVudCQxKG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJ0ZXh0Q29udGVudFwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zJDEobjIsIG90aGVyKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QkMShcIk5vZGVcIiwgbjIsIFwiY29udGFpbnNcIikob3RoZXIpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUkMShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkTWV0aG9kJDEoXCJOb2RlXCIsIG4yLCBcImdldFJvb3ROb2RlXCIpKCk7XG59XG5mdW5jdGlvbiBob3N0JDEobjIpIHtcbiAgaWYgKCFuMiB8fCAhKFwiaG9zdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiU2hhZG93Um9vdFwiLCBuMiwgXCJob3N0XCIpO1xufVxuZnVuY3Rpb24gc3R5bGVTaGVldHMkMShuMikge1xuICByZXR1cm4gbjIuc3R5bGVTaGVldHM7XG59XG5mdW5jdGlvbiBzaGFkb3dSb290JDEobjIpIHtcbiAgaWYgKCFuMiB8fCAhKFwic2hhZG93Um9vdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJzaGFkb3dSb290XCIpO1xufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvciQxKG4yLCBzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwkMShuMiwgc2VsZWN0b3JzKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yQWxsXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyQ3RvciQxKCkge1xuICByZXR1cm4gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoXCJNdXRhdGlvbk9ic2VydmVyXCIpLmNvbnN0cnVjdG9yO1xufVxuY29uc3QgaW5kZXgkMSA9IHtcbiAgY2hpbGROb2RlczogY2hpbGROb2RlcyQxLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlJDEsXG4gIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQkMSxcbiAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50JDEsXG4gIGNvbnRhaW5zOiBjb250YWlucyQxLFxuICBnZXRSb290Tm9kZTogZ2V0Um9vdE5vZGUkMSxcbiAgaG9zdDogaG9zdCQxLFxuICBzdHlsZVNoZWV0czogc3R5bGVTaGVldHMkMSxcbiAgc2hhZG93Um9vdDogc2hhZG93Um9vdCQxLFxuICBxdWVyeVNlbGVjdG9yOiBxdWVyeVNlbGVjdG9yJDEsXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IHF1ZXJ5U2VsZWN0b3JBbGwkMSxcbiAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3IkMVxufTtcbmZ1bmN0aW9uIGlzRWxlbWVudChuMikge1xuICByZXR1cm4gbjIubm9kZVR5cGUgPT09IG4yLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuMikge1xuICBjb25zdCBob3N0RWwgPSAoXG4gICAgLy8gYW5jaG9yIGFuZCB0ZXh0YXJlYSBlbGVtZW50cyBhbHNvIGhhdmUgYSBgaG9zdGAgcHJvcGVydHlcbiAgICAvLyBidXQgb25seSBzaGFkb3cgcm9vdHMgaGF2ZSBhIGBtb2RlYCBwcm9wZXJ0eVxuICAgIG4yICYmIFwiaG9zdFwiIGluIG4yICYmIFwibW9kZVwiIGluIG4yICYmIGluZGV4JDEuaG9zdChuMikgfHwgbnVsbFxuICApO1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBob3N0RWwgJiYgXCJzaGFkb3dSb290XCIgaW4gaG9zdEVsICYmIGluZGV4JDEuc2hhZG93Um9vdChob3N0RWwpID09PSBuMlxuICApO1xufVxuZnVuY3Rpb24gaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdDIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzaGFkb3dSb290MikgPT09IFwiW29iamVjdCBTaGFkb3dSb290XVwiO1xufVxuZnVuY3Rpb24gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhjc3NUZXh0KSB7XG4gIGlmIChjc3NUZXh0LmluY2x1ZGVzKFwiIGJhY2tncm91bmQtY2xpcDogdGV4dDtcIikgJiYgIWNzc1RleHQuaW5jbHVkZXMoXCIgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpKSB7XG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShcbiAgICAgIC9cXHNiYWNrZ3JvdW5kLWNsaXA6XFxzKnRleHQ7L2csXG4gICAgICBcIiAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDsgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cbmZ1bmN0aW9uIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlMikge1xuICBjb25zdCB7IGNzc1RleHQgfSA9IHJ1bGUyO1xuICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKSByZXR1cm4gY3NzVGV4dDtcbiAgY29uc3Qgc3RhdGVtZW50ID0gW1wiQGltcG9ydFwiLCBgdXJsKCR7SlNPTi5zdHJpbmdpZnkocnVsZTIuaHJlZil9KWBdO1xuICBpZiAocnVsZTIubGF5ZXJOYW1lID09PSBcIlwiKSB7XG4gICAgc3RhdGVtZW50LnB1c2goYGxheWVyYCk7XG4gIH0gZWxzZSBpZiAocnVsZTIubGF5ZXJOYW1lKSB7XG4gICAgc3RhdGVtZW50LnB1c2goYGxheWVyKCR7cnVsZTIubGF5ZXJOYW1lfSlgKTtcbiAgfVxuICBpZiAocnVsZTIuc3VwcG9ydHNUZXh0KSB7XG4gICAgc3RhdGVtZW50LnB1c2goYHN1cHBvcnRzKCR7cnVsZTIuc3VwcG9ydHNUZXh0fSlgKTtcbiAgfVxuICBpZiAocnVsZTIubWVkaWEubGVuZ3RoKSB7XG4gICAgc3RhdGVtZW50LnB1c2gocnVsZTIubWVkaWEubWVkaWFUZXh0KTtcbiAgfVxuICByZXR1cm4gc3RhdGVtZW50LmpvaW4oXCIgXCIpICsgXCI7XCI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZXNoZWV0KHMyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcnVsZXMyID0gczIucnVsZXMgfHwgczIuY3NzUnVsZXM7XG4gICAgaWYgKCFydWxlczIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc2hlZXRIcmVmID0gczIuaHJlZjtcbiAgICBpZiAoIXNoZWV0SHJlZiAmJiBzMi5vd25lck5vZGUgJiYgczIub3duZXJOb2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIHNoZWV0SHJlZiA9IHMyLm93bmVyTm9kZS5vd25lckRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ2lmaWVkUnVsZXMgPSBBcnJheS5mcm9tKFxuICAgICAgcnVsZXMyLFxuICAgICAgKHJ1bGUyKSA9PiBzdHJpbmdpZnlSdWxlKHJ1bGUyLCBzaGVldEhyZWYpXG4gICAgKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKHN0cmluZ2lmaWVkUnVsZXMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlSdWxlKHJ1bGUyLCBzaGVldEhyZWYpIHtcbiAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlMikpIHtcbiAgICBsZXQgaW1wb3J0U3RyaW5naWZpZWQ7XG4gICAgdHJ5IHtcbiAgICAgIGltcG9ydFN0cmluZ2lmaWVkID0gLy8gZm9yIHNhbWUtb3JpZ2luIHN0eWxlc2hlZXRzLFxuICAgICAgLy8gd2UgY2FuIGFjY2VzcyB0aGUgaW1wb3J0ZWQgc3R5bGVzaGVldCBydWxlcyBkaXJlY3RseVxuICAgICAgc3RyaW5naWZ5U3R5bGVzaGVldChydWxlMi5zdHlsZVNoZWV0KSB8fCAvLyB3b3JrIGFyb3VuZCBicm93c2VyIGlzc3VlcyB3aXRoIHRoZSByYXcgc3RyaW5nIGBAaW1wb3J0IHVybCguLi4pYCBzdGF0ZW1lbnRcbiAgICAgIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlMik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGltcG9ydFN0cmluZ2lmaWVkID0gcnVsZTIuY3NzVGV4dDtcbiAgICB9XG4gICAgaWYgKHJ1bGUyLnN0eWxlU2hlZXQuaHJlZikge1xuICAgICAgcmV0dXJuIGFic29sdXRpZnlVUkxzKGltcG9ydFN0cmluZ2lmaWVkLCBydWxlMi5zdHlsZVNoZWV0LmhyZWYpO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0U3RyaW5naWZpZWQ7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJ1bGVTdHJpbmdpZmllZCA9IHJ1bGUyLmNzc1RleHQ7XG4gICAgaWYgKGlzQ1NTU3R5bGVSdWxlKHJ1bGUyKSAmJiBydWxlMi5zZWxlY3RvclRleHQuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICBydWxlU3RyaW5naWZpZWQgPSBmaXhTYWZhcmlDb2xvbnMocnVsZVN0cmluZ2lmaWVkKTtcbiAgICB9XG4gICAgaWYgKHNoZWV0SHJlZikge1xuICAgICAgcmV0dXJuIGFic29sdXRpZnlVUkxzKHJ1bGVTdHJpbmdpZmllZCwgc2hlZXRIcmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVTdHJpbmdpZmllZDtcbiAgfVxufVxuZnVuY3Rpb24gZml4U2FmYXJpQ29sb25zKGNzc1N0cmluZ2lmaWVkKSB7XG4gIGNvbnN0IHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XG4gIHJldHVybiBjc3NTdHJpbmdpZmllZC5yZXBsYWNlKHJlZ2V4LCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUyKSB7XG4gIHJldHVybiBcInN0eWxlU2hlZXRcIiBpbiBydWxlMjtcbn1cbmZ1bmN0aW9uIGlzQ1NTU3R5bGVSdWxlKHJ1bGUyKSB7XG4gIHJldHVybiBcInNlbGVjdG9yVGV4dFwiIGluIHJ1bGUyO1xufVxuY2xhc3MgTWlycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWROb2RlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm5vZGVNZXRhTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgfVxuICBnZXRJZChuMikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCFuMikgcmV0dXJuIC0xO1xuICAgIGNvbnN0IGlkID0gKF9hMiA9IHRoaXMuZ2V0TWV0YShuMikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQ7XG4gICAgcmV0dXJuIGlkID8/IC0xO1xuICB9XG4gIGdldE5vZGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldElkcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlkTm9kZU1hcC5rZXlzKCkpO1xuICB9XG4gIGdldE1ldGEobjIpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5nZXQobjIpIHx8IG51bGw7XG4gIH1cbiAgLy8gcmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGlkTm9kZU1hcFxuICAvLyBkb2Vzbid0IHJlbW92ZSB0aGUgbm9kZSBmcm9tIG5vZGVNZXRhTWFwXG4gIHJlbW92ZU5vZGVGcm9tTWFwKG4yKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldElkKG4yKTtcbiAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xuICAgIGlmIChuMi5jaGlsZE5vZGVzKSB7XG4gICAgICBuMi5jaGlsZE5vZGVzLmZvckVhY2goXG4gICAgICAgIChjaGlsZE5vZGUpID0+IHRoaXMucmVtb3ZlTm9kZUZyb21NYXAoY2hpbGROb2RlKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaGFzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmhhcyhpZCk7XG4gIH1cbiAgaGFzTm9kZShub2RlMikge1xuICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmhhcyhub2RlMik7XG4gIH1cbiAgYWRkKG4yLCBtZXRhKSB7XG4gICAgY29uc3QgaWQgPSBtZXRhLmlkO1xuICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbjIpO1xuICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgfVxuICByZXBsYWNlKGlkLCBuMikge1xuICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLmdldE5vZGUoaWQpO1xuICAgIGlmIChvbGROb2RlKSB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5ub2RlTWV0YU1hcC5nZXQob2xkTm9kZSk7XG4gICAgICBpZiAobWV0YSkgdGhpcy5ub2RlTWV0YU1hcC5zZXQobjIsIG1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4yKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmlkTm9kZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5ub2RlTWV0YU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVNaXJyb3IkMigpIHtcbiAgcmV0dXJuIG5ldyBNaXJyb3IoKTtcbn1cbmZ1bmN0aW9uIG1hc2tJbnB1dFZhbHVlKHtcbiAgZWxlbWVudCxcbiAgbWFza0lucHV0T3B0aW9ucyxcbiAgdGFnTmFtZSxcbiAgdHlwZSxcbiAgdmFsdWUsXG4gIG1hc2tJbnB1dEZuXG59KSB7XG4gIGxldCB0ZXh0ID0gdmFsdWUgfHwgXCJcIjtcbiAgY29uc3QgYWN0dWFsVHlwZSA9IHR5cGUgJiYgdG9Mb3dlckNhc2UodHlwZSk7XG4gIGlmIChtYXNrSW5wdXRPcHRpb25zW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgYWN0dWFsVHlwZSAmJiBtYXNrSW5wdXRPcHRpb25zW2FjdHVhbFR5cGVdKSB7XG4gICAgaWYgKG1hc2tJbnB1dEZuKSB7XG4gICAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHQgPSBcIipcIi5yZXBlYXQodGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKHN0cikge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5jb25zdCBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSA9IFwiX19ycndlYl9vcmlnaW5hbF9fXCI7XG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGlmICghY3R4KSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgY2h1bmtTaXplID0gNTA7XG4gIGZvciAobGV0IHgyID0gMDsgeDIgPCBjYW52YXMud2lkdGg7IHgyICs9IGNodW5rU2l6ZSkge1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSArPSBjaHVua1NpemUpIHtcbiAgICAgIGNvbnN0IGdldEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGE7XG4gICAgICBjb25zdCBvcmlnaW5hbEdldEltYWdlRGF0YSA9IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FIGluIGdldEltYWdlRGF0YSA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRV0gOiBnZXRJbWFnZURhdGE7XG4gICAgICBjb25zdCBwaXhlbEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICBvcmlnaW5hbEdldEltYWdlRGF0YS5jYWxsKFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICB4MixcbiAgICAgICAgICB5LFxuICAgICAgICAgIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLndpZHRoIC0geDIpLFxuICAgICAgICAgIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLmhlaWdodCAtIHkpXG4gICAgICAgICkuZGF0YS5idWZmZXJcbiAgICAgICk7XG4gICAgICBpZiAocGl4ZWxCdWZmZXIuc29tZSgocGl4ZWwpID0+IHBpeGVsICE9PSAwKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldElucHV0VHlwZShlbGVtZW50KSB7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtcnItaXMtcGFzc3dvcmRcIikgPyBcInBhc3N3b3JkXCIgOiB0eXBlID8gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICB0b0xvd2VyQ2FzZSh0eXBlKVxuICApIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHBhdGgsIGJhc2VVUkwpIHtcbiAgbGV0IHVybDtcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVUkwgPz8gd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZWdleCA9IC9cXC4oWzAtOWEtel0rKSg/OiQpL2k7XG4gIGNvbnN0IG1hdGNoID0gdXJsLnBhdGhuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIChtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2hbMV0pID8/IG51bGw7XG59XG5mdW5jdGlvbiBleHRyYWN0T3JpZ2luKHVybCkge1xuICBsZXQgb3JpZ2luID0gXCJcIjtcbiAgaWYgKHVybC5pbmRleE9mKFwiLy9cIikgPiAtMSkge1xuICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIikuc2xpY2UoMCwgMykuam9pbihcIi9cIik7XG4gIH0gZWxzZSB7XG4gICAgb3JpZ2luID0gdXJsLnNwbGl0KFwiL1wiKVswXTtcbiAgfVxuICBvcmlnaW4gPSBvcmlnaW4uc3BsaXQoXCI/XCIpWzBdO1xuICByZXR1cm4gb3JpZ2luO1xufVxuY29uc3QgVVJMX0lOX0NTU19SRUYgPSAvdXJsXFwoKD86KCcpKFteJ10qKSd8KFwiKSguKj8pXCJ8KFteKV0qKSlcXCkvZ207XG5jb25zdCBVUkxfUFJPVE9DT0xfTUFUQ0ggPSAvXig/OlthLXorXSs6KT9cXC9cXC8vaTtcbmNvbnN0IFVSTF9XV1dfTUFUQ0ggPSAvXnd3d1xcLi4qL2k7XG5jb25zdCBEQVRBX1VSSSA9IC9eKGRhdGE6KShbXixdKiksKC4qKS9pO1xuZnVuY3Rpb24gYWJzb2x1dGlmeVVSTHMoY3NzVGV4dCwgaHJlZikge1xuICByZXR1cm4gKGNzc1RleHQgfHwgXCJcIikucmVwbGFjZShcbiAgICBVUkxfSU5fQ1NTX1JFRixcbiAgICAob3JpZ2luLCBxdW90ZTEsIHBhdGgxLCBxdW90ZTIsIHBhdGgyLCBwYXRoMykgPT4ge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoMSB8fCBwYXRoMiB8fCBwYXRoMztcbiAgICAgIGNvbnN0IG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8IFwiXCI7XG4gICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICB9XG4gICAgICBpZiAoVVJMX1BST1RPQ09MX01BVENILnRlc3QoZmlsZVBhdGgpIHx8IFVSTF9XV1dfTUFUQ0gudGVzdChmaWxlUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xuICAgICAgfVxuICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke2ZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxlUGF0aFswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZXh0cmFjdE9yaWdpbihocmVmKSArIGZpbGVQYXRofSR7bWF5YmVRdW90ZX0pYDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWNrID0gaHJlZi5zcGxpdChcIi9cIik7XG4gICAgICBjb25zdCBwYXJ0cyA9IGZpbGVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0ID09PSBcIi5cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiLi5cIikge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBgdXJsKCR7bWF5YmVRdW90ZX0ke3N0YWNrLmpvaW4oXCIvXCIpfSR7bWF5YmVRdW90ZX0pYDtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDc3NTdHJpbmcoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKC8oXFwvXFwqW14qXSpcXCpcXC8pfFtcXHM7XS9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q3NzVGV4dChjc3NUZXh0LCBzdHlsZSkge1xuICBjb25zdCBjaGlsZE5vZGVzMiA9IEFycmF5LmZyb20oc3R5bGUuY2hpbGROb2Rlcyk7XG4gIGNvbnN0IHNwbGl0cyA9IFtdO1xuICBpZiAoY2hpbGROb2RlczIubGVuZ3RoID4gMSAmJiBjc3NUZXh0ICYmIHR5cGVvZiBjc3NUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgY3NzVGV4dE5vcm0gPSBub3JtYWxpemVDc3NTdHJpbmcoY3NzVGV4dCk7XG4gICAgZm9yIChsZXQgaTIgPSAxOyBpMiA8IGNoaWxkTm9kZXMyLmxlbmd0aDsgaTIrKykge1xuICAgICAgaWYgKGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCAmJiB0eXBlb2YgY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHRleHRDb250ZW50Tm9ybSA9IG5vcm1hbGl6ZUNzc1N0cmluZyhjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQpO1xuICAgICAgICBmb3IgKGxldCBqID0gMzsgaiA8IHRleHRDb250ZW50Tm9ybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGJpdCA9IHRleHRDb250ZW50Tm9ybS5zdWJzdHJpbmcoMCwgaik7XG4gICAgICAgICAgaWYgKGNzc1RleHROb3JtLnNwbGl0KGJpdCkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpdE5vcm0gPSBjc3NUZXh0Tm9ybS5pbmRleE9mKGJpdCk7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gc3BsaXROb3JtOyBrIDwgY3NzVGV4dC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAobm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQuc3Vic3RyaW5nKDAsIGspKS5sZW5ndGggPT09IHNwbGl0Tm9ybSkge1xuICAgICAgICAgICAgICAgIHNwbGl0cy5wdXNoKGNzc1RleHQuc3Vic3RyaW5nKDAsIGspKTtcbiAgICAgICAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5zdWJzdHJpbmcoayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzcGxpdHMucHVzaChjc3NUZXh0KTtcbiAgcmV0dXJuIHNwbGl0cztcbn1cbmZ1bmN0aW9uIG1hcmtDc3NTcGxpdHMoY3NzVGV4dCwgc3R5bGUpIHtcbiAgcmV0dXJuIHNwbGl0Q3NzVGV4dChjc3NUZXh0LCBzdHlsZSkuam9pbihcIi8qIHJyX3NwbGl0ICovXCIpO1xufVxubGV0IF9pZCA9IDE7XG5jb25zdCB0YWdOYW1lUmVnZXggPSBuZXcgUmVnRXhwKFwiW15hLXowLTktXzpdXCIpO1xuY29uc3QgSUdOT1JFRF9OT0RFID0gLTI7XG5mdW5jdGlvbiBnZW5JZCgpIHtcbiAgcmV0dXJuIF9pZCsrO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRUYWdOYW1lJDEoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkge1xuICAgIHJldHVybiBcImZvcm1cIjtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWRUYWdOYW1lID0gdG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWVSZWdleC50ZXN0KHByb2Nlc3NlZFRhZ05hbWUpKSB7XG4gICAgcmV0dXJuIFwiZGl2XCI7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NlZFRhZ05hbWU7XG59XG5sZXQgY2FudmFzU2VydmljZTtcbmxldCBjYW52YXNDdHg7XG5jb25zdCBTUkNTRVRfTk9UX1NQQUNFUyA9IC9eW14gXFx0XFxuXFxyXFx1MDAwY10rLztcbmNvbnN0IFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvO1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICBpZiAoYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICB9XG4gIGxldCBwb3MgPSAwO1xuICBmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuICAgIGxldCBjaGFyczI7XG4gICAgY29uc3QgbWF0Y2ggPSByZWdFeC5leGVjKGF0dHJpYnV0ZVZhbHVlLnN1YnN0cmluZyhwb3MpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNoYXJzMiA9IG1hdGNoWzBdO1xuICAgICAgcG9zICs9IGNoYXJzMi5sZW5ndGg7XG4gICAgICByZXR1cm4gY2hhcnMyO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyk7XG4gICAgaWYgKHBvcyA+PSBhdHRyaWJ1dGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgdXJsID0gY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX05PVF9TUEFDRVMpO1xuICAgIGlmICh1cmwuc2xpY2UoLTEpID09PSBcIixcIikge1xuICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpKTtcbiAgICAgIG91dHB1dC5wdXNoKHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZXNjcmlwdG9yc1N0ciA9IFwiXCI7XG4gICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsKTtcbiAgICAgIGxldCBpblBhcmVucyA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYzIgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQXQocG9zKTtcbiAgICAgICAgaWYgKGMyID09PSBcIlwiKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKCFpblBhcmVucykge1xuICAgICAgICAgIGlmIChjMiA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChjMiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIGluUGFyZW5zID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGMyID09PSBcIilcIikge1xuICAgICAgICAgICAgaW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRvcnNTdHIgKz0gYzI7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oXCIsIFwiKTtcbn1cbmNvbnN0IGNhY2hlZERvY3VtZW50ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhYnNvbHV0ZVRvRG9jKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcbiAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdldEhyZWYoZG9jLCBhdHRyaWJ1dGVWYWx1ZSk7XG59XG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIEJvb2xlYW4oZWwudGFnTmFtZSA9PT0gXCJzdmdcIiB8fCBlbC5vd25lclNWR0VsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0SHJlZihkb2MsIGN1c3RvbUhyZWYpIHtcbiAgbGV0IGEyID0gY2FjaGVkRG9jdW1lbnQuZ2V0KGRvYyk7XG4gIGlmICghYTIpIHtcbiAgICBhMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBjYWNoZWREb2N1bWVudC5zZXQoZG9jLCBhMik7XG4gIH1cbiAgaWYgKCFjdXN0b21IcmVmKSB7XG4gICAgY3VzdG9tSHJlZiA9IFwiXCI7XG4gIH0gZWxzZSBpZiAoY3VzdG9tSHJlZi5zdGFydHNXaXRoKFwiYmxvYjpcIikgfHwgY3VzdG9tSHJlZi5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gY3VzdG9tSHJlZjtcbiAgfVxuICBhMi5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGN1c3RvbUhyZWYpO1xuICByZXR1cm4gYTIuaHJlZjtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKG5hbWUgPT09IFwic3JjXCIgfHwgbmFtZSA9PT0gXCJocmVmXCIgJiYgISh0YWdOYW1lID09PSBcInVzZVwiICYmIHZhbHVlWzBdID09PSBcIiNcIikpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcInhsaW5rOmhyZWZcIiAmJiB2YWx1ZVswXSAhPT0gXCIjXCIpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcImJhY2tncm91bmRcIiAmJiAodGFnTmFtZSA9PT0gXCJ0YWJsZVwiIHx8IHRhZ05hbWUgPT09IFwidGRcIiB8fCB0YWdOYW1lID09PSBcInRoXCIpKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzcmNzZXRcIikge1xuICAgIHJldHVybiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHModmFsdWUsIGdldEhyZWYoZG9jKSk7XG4gIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gXCJvYmplY3RcIiAmJiBuYW1lID09PSBcImRhdGFcIikge1xuICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBuYW1lLCBfdmFsdWUpIHtcbiAgcmV0dXJuICh0YWdOYW1lID09PSBcInZpZGVvXCIgfHwgdGFnTmFtZSA9PT0gXCJhdWRpb1wiKSAmJiBuYW1lID09PSBcImF1dG9wbGF5XCI7XG59XG5mdW5jdGlvbiBfaXNCbG9ja2VkRWxlbWVudChlbGVtZW50LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGVJbmRleCA9IGVsZW1lbnQuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07ICkge1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTGlzdFtlSW5kZXhdO1xuICAgICAgICBpZiAoYmxvY2tDbGFzcy50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhibG9ja1NlbGVjdG9yKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2xhc3NNYXRjaGVzUmVnZXgobm9kZTIsIHJlZ2V4LCBjaGVja0FuY2VzdG9ycykge1xuICBpZiAoIW5vZGUyKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlMi5ub2RlVHlwZSAhPT0gbm9kZTIuRUxFTUVOVF9OT0RFKSB7XG4gICAgaWYgKCFjaGVja0FuY2VzdG9ycykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjbGFzc01hdGNoZXNSZWdleChpbmRleCQxLnBhcmVudE5vZGUobm9kZTIpLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpO1xuICB9XG4gIGZvciAobGV0IGVJbmRleCA9IG5vZGUyLmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOyApIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBub2RlMi5jbGFzc0xpc3RbZUluZGV4XTtcbiAgICBpZiAocmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFjaGVja0FuY2VzdG9ycykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgoaW5kZXgkMS5wYXJlbnROb2RlKG5vZGUyKSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcbn1cbmZ1bmN0aW9uIG5lZWRNYXNraW5nVGV4dChub2RlMiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgbGV0IGVsO1xuICBpZiAoaXNFbGVtZW50KG5vZGUyKSkge1xuICAgIGVsID0gbm9kZTI7XG4gICAgaWYgKCFpbmRleCQxLmNoaWxkTm9kZXMoZWwpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbmRleCQxLnBhcmVudEVsZW1lbnQobm9kZTIpID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGVsID0gaW5kZXgkMS5wYXJlbnRFbGVtZW50KG5vZGUyKTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgbWFza1RleHRDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgICAgIGlmIChlbC5jbG9zZXN0KGAuJHttYXNrVGV4dENsYXNzfWApKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMobWFza1RleHRDbGFzcykpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIG1hc2tUZXh0Q2xhc3MsIGNoZWNrQW5jZXN0b3JzKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXNrVGV4dFNlbGVjdG9yKSB7XG4gICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcbiAgICAgICAgaWYgKGVsLmNsb3Nlc3QobWFza1RleHRTZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMobWFza1RleHRTZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbmNlSWZyYW1lTG9hZGVkKGlmcmFtZUVsLCBsaXN0ZW5lciwgaWZyYW1lTG9hZFRpbWVvdXQpIHtcbiAgY29uc3Qgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgaWYgKCF3aW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGZpcmVkID0gZmFsc2U7XG4gIGxldCByZWFkeVN0YXRlO1xuICB0cnkge1xuICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWZpcmVkKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCBpZnJhbWVMb2FkVGltZW91dCk7XG4gICAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJsYW5rVXJsID0gXCJhYm91dDpibGFua1wiO1xuICBpZiAod2luLmxvY2F0aW9uLmhyZWYgIT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHwgaWZyYW1lRWwuc3JjID09PSBcIlwiKSB7XG4gICAgc2V0VGltZW91dChsaXN0ZW5lciwgMCk7XG4gICAgcmV0dXJuIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxpc3RlbmVyKTtcbiAgfVxuICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBvbmNlU3R5bGVzaGVldExvYWRlZChsaW5rLCBsaXN0ZW5lciwgc3R5bGVTaGVldExvYWRUaW1lb3V0KSB7XG4gIGxldCBmaXJlZCA9IGZhbHNlO1xuICBsZXQgc3R5bGVTaGVldExvYWRlZDtcbiAgdHJ5IHtcbiAgICBzdHlsZVNoZWV0TG9hZGVkID0gbGluay5zaGVldDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHN0eWxlU2hlZXRMb2FkZWQpIHJldHVybjtcbiAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwgc3R5bGVTaGVldExvYWRUaW1lb3V0KTtcbiAgbGluay5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBmaXJlZCA9IHRydWU7XG4gICAgbGlzdGVuZXIoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkb2MsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBuZWVkc01hc2ssXG4gICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICBtYXNrSW5wdXRPcHRpb25zID0ge30sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsXG4gICAgY3NzQ2FwdHVyZWQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgcm9vdElkID0gZ2V0Um9vdElkKGRvYywgbWlycm9yMik7XG4gIHN3aXRjaCAobjIubm9kZVR5cGUpIHtcbiAgICBjYXNlIG4yLkRPQ1VNRU5UX05PREU6XG4gICAgICBpZiAobjIuY29tcGF0TW9kZSAhPT0gXCJDU1MxQ29tcGF0XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50LFxuICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgIGNvbXBhdE1vZGU6IG4yLmNvbXBhdE1vZGVcbiAgICAgICAgICAvLyBwcm9iYWJseSBcIkJhY2tDb21wYXRcIlxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50LFxuICAgICAgICAgIGNoaWxkTm9kZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSBuMi5ET0NVTUVOVF9UWVBFX05PREU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50VHlwZSxcbiAgICAgICAgbmFtZTogbjIubmFtZSxcbiAgICAgICAgcHVibGljSWQ6IG4yLnB1YmxpY0lkLFxuICAgICAgICBzeXN0ZW1JZDogbjIuc3lzdGVtSWQsXG4gICAgICAgIHJvb3RJZFxuICAgICAgfTtcbiAgICBjYXNlIG4yLkVMRU1FTlRfTk9ERTpcbiAgICAgIHJldHVybiBzZXJpYWxpemVFbGVtZW50Tm9kZShuMiwge1xuICAgICAgICBkb2MsXG4gICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQsXG4gICAgICAgIHJvb3RJZFxuICAgICAgfSk7XG4gICAgY2FzZSBuMi5URVhUX05PREU6XG4gICAgICByZXR1cm4gc2VyaWFsaXplVGV4dE5vZGUobjIsIHtcbiAgICAgICAgZG9jLFxuICAgICAgICBuZWVkc01hc2ssXG4gICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgY3NzQ2FwdHVyZWRcbiAgICAgIH0pO1xuICAgIGNhc2UgbjIuQ0RBVEFfU0VDVElPTl9OT0RFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5DREFUQSxcbiAgICAgICAgdGV4dENvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHJvb3RJZFxuICAgICAgfTtcbiAgICBjYXNlIG4yLkNPTU1FTlRfTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuQ29tbWVudCxcbiAgICAgICAgdGV4dENvbnRlbnQ6IGluZGV4JDEudGV4dENvbnRlbnQobjIpIHx8IFwiXCIsXG4gICAgICAgIHJvb3RJZFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSb290SWQoZG9jLCBtaXJyb3IyKSB7XG4gIGlmICghbWlycm9yMi5oYXNOb2RlKGRvYykpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGRvY0lkID0gbWlycm9yMi5nZXRJZChkb2MpO1xuICByZXR1cm4gZG9jSWQgPT09IDEgPyB2b2lkIDAgOiBkb2NJZDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRleHROb2RlKG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgbmVlZHNNYXNrLCBtYXNrVGV4dEZuLCByb290SWQsIGNzc0NhcHR1cmVkIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXJlbnQgPSBpbmRleCQxLnBhcmVudE5vZGUobjIpO1xuICBjb25zdCBwYXJlbnRUYWdOYW1lID0gcGFyZW50ICYmIHBhcmVudC50YWdOYW1lO1xuICBsZXQgdGV4dENvbnRlbnQyID0gXCJcIjtcbiAgY29uc3QgaXNTdHlsZSA9IHBhcmVudFRhZ05hbWUgPT09IFwiU1RZTEVcIiA/IHRydWUgOiB2b2lkIDA7XG4gIGNvbnN0IGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTQ1JJUFRcIiA/IHRydWUgOiB2b2lkIDA7XG4gIGlmIChpc1NjcmlwdCkge1xuICAgIHRleHRDb250ZW50MiA9IFwiU0NSSVBUX1BMQUNFSE9MREVSXCI7XG4gIH0gZWxzZSBpZiAoIWNzc0NhcHR1cmVkKSB7XG4gICAgdGV4dENvbnRlbnQyID0gaW5kZXgkMS50ZXh0Q29udGVudChuMik7XG4gICAgaWYgKGlzU3R5bGUgJiYgdGV4dENvbnRlbnQyKSB7XG4gICAgICB0ZXh0Q29udGVudDIgPSBhYnNvbHV0aWZ5VVJMcyh0ZXh0Q29udGVudDIsIGdldEhyZWYob3B0aW9ucy5kb2MpKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1N0eWxlICYmICFpc1NjcmlwdCAmJiB0ZXh0Q29udGVudDIgJiYgbmVlZHNNYXNrKSB7XG4gICAgdGV4dENvbnRlbnQyID0gbWFza1RleHRGbiA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQyLCBpbmRleCQxLnBhcmVudEVsZW1lbnQobjIpKSA6IHRleHRDb250ZW50Mi5yZXBsYWNlKC9bXFxTXS9nLCBcIipcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBOb2RlVHlwZSQzLlRleHQsXG4gICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50MiB8fCBcIlwiLFxuICAgIHJvb3RJZFxuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICBtYXNrSW5wdXRPcHRpb25zID0ge30sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgZGF0YVVSTE9wdGlvbnMgPSB7fSxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLFxuICAgIHJvb3RJZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbmVlZEJsb2NrID0gX2lzQmxvY2tlZEVsZW1lbnQobjIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICBjb25zdCB0YWdOYW1lID0gZ2V0VmFsaWRUYWdOYW1lJDEobjIpO1xuICBsZXQgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBsZW4gPSBuMi5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxlbjsgaTIrKykge1xuICAgIGNvbnN0IGF0dHIgPSBuMi5hdHRyaWJ1dGVzW2kyXTtcbiAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHIubmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoXG4gICAgICAgIGRvYyxcbiAgICAgICAgdGFnTmFtZSxcbiAgICAgICAgdG9Mb3dlckNhc2UoYXR0ci5uYW1lKSxcbiAgICAgICAgYXR0ci52YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwibGlua1wiICYmIGlubGluZVN0eWxlc2hlZXQpIHtcbiAgICBjb25zdCBzdHlsZXNoZWV0ID0gQXJyYXkuZnJvbShkb2Muc3R5bGVTaGVldHMpLmZpbmQoKHMyKSA9PiB7XG4gICAgICByZXR1cm4gczIuaHJlZiA9PT0gbjIuaHJlZjtcbiAgICB9KTtcbiAgICBsZXQgY3NzVGV4dCA9IG51bGw7XG4gICAgaWYgKHN0eWxlc2hlZXQpIHtcbiAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KHN0eWxlc2hlZXQpO1xuICAgIH1cbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMucmVsO1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuaHJlZjtcbiAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBjc3NUZXh0O1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJzdHlsZVwiICYmIG4yLnNoZWV0KSB7XG4gICAgbGV0IGNzc1RleHQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KFxuICAgICAgbjIuc2hlZXRcbiAgICApO1xuICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICBpZiAobjIuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNzc1RleHQgPSBtYXJrQ3NzU3BsaXRzKGNzc1RleHQsIG4yKTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBjc3NUZXh0O1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJpbnB1dFwiIHx8IHRhZ05hbWUgPT09IFwidGV4dGFyZWFcIiB8fCB0YWdOYW1lID09PSBcInNlbGVjdFwiKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuMi52YWx1ZTtcbiAgICBjb25zdCBjaGVja2VkID0gbjIuY2hlY2tlZDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlICE9PSBcInJhZGlvXCIgJiYgYXR0cmlidXRlcy50eXBlICE9PSBcImNoZWNrYm94XCIgJiYgYXR0cmlidXRlcy50eXBlICE9PSBcInN1Ym1pdFwiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJidXR0b25cIiAmJiB2YWx1ZSkge1xuICAgICAgYXR0cmlidXRlcy52YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgZWxlbWVudDogbjIsXG4gICAgICAgIHR5cGU6IGdldElucHV0VHlwZShuMiksXG4gICAgICAgIHRhZ05hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrSW5wdXRGblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjaGVja2VkKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJvcHRpb25cIikge1xuICAgIGlmIChuMi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1tcInNlbGVjdFwiXSkge1xuICAgICAgYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNlbGVjdGVkO1xuICAgIH1cbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJkaWFsb2dcIiAmJiBuMi5vcGVuKSB7XG4gICAgYXR0cmlidXRlcy5ycl9vcGVuX21vZGUgPSBuMi5tYXRjaGVzKFwiZGlhbG9nOm1vZGFsXCIpID8gXCJtb2RhbFwiIDogXCJub24tbW9kYWxcIjtcbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJjYW52YXNcIiAmJiByZWNvcmRDYW52YXMpIHtcbiAgICBpZiAobjIuX19jb250ZXh0ID09PSBcIjJkXCIpIHtcbiAgICAgIGlmICghaXMyRENhbnZhc0JsYW5rKG4yKSkge1xuICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBuMi50b0RhdGFVUkwoXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFwiX19jb250ZXh0XCIgaW4gbjIpKSB7XG4gICAgICBjb25zdCBjYW52YXNEYXRhVVJMID0gbjIudG9EYXRhVVJMKFxuICAgICAgICBkYXRhVVJMT3B0aW9ucy50eXBlLFxuICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICApO1xuICAgICAgY29uc3QgYmxhbmtDYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGJsYW5rQ2FudmFzLndpZHRoID0gbjIud2lkdGg7XG4gICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuMi5oZWlnaHQ7XG4gICAgICBjb25zdCBibGFua0NhbnZhc0RhdGFVUkwgPSBibGFua0NhbnZhcy50b0RhdGFVUkwoXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICk7XG4gICAgICBpZiAoY2FudmFzRGF0YVVSTCAhPT0gYmxhbmtDYW52YXNEYXRhVVJMKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc0RhdGFVUkw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImltZ1wiICYmIGlubGluZUltYWdlcykge1xuICAgIGlmICghY2FudmFzU2VydmljZSkge1xuICAgICAgY2FudmFzU2VydmljZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY2FudmFzQ3R4ID0gY2FudmFzU2VydmljZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlID0gbjI7XG4gICAgY29uc3QgaW1hZ2VTcmMgPSBpbWFnZS5jdXJyZW50U3JjIHx8IGltYWdlLmdldEF0dHJpYnV0ZShcInNyY1wiKSB8fCBcIjx1bmtub3duLXNyYz5cIjtcbiAgICBjb25zdCBwcmlvckNyb3NzT3JpZ2luID0gaW1hZ2UuY3Jvc3NPcmlnaW47XG4gICAgY29uc3QgcmVjb3JkSW5saW5lSW1hZ2UgPSAoKSA9PiB7XG4gICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gICAgICB0cnkge1xuICAgICAgICBjYW52YXNTZXJ2aWNlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICBjYW52YXNTZXJ2aWNlLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIGNhbnZhc0N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNTZXJ2aWNlLnRvRGF0YVVSTChcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy50eXBlLFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoaW1hZ2UuY3Jvc3NPcmlnaW4gIT09IFwiYW5vbnltb3VzXCIpIHtcbiAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMClcbiAgICAgICAgICAgIHJlY29yZElubGluZUltYWdlKCk7XG4gICAgICAgICAgZWxzZSBpbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBDYW5ub3QgaW5saW5lIGltZyBzcmM9JHtpbWFnZVNyY30hIEVycm9yOiAke2Vycn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luID09PSBcImFub255bW91c1wiKSB7XG4gICAgICAgIHByaW9yQ3Jvc3NPcmlnaW4gPyBhdHRyaWJ1dGVzLmNyb3NzT3JpZ2luID0gcHJpb3JDcm9zc09yaWdpbiA6IGltYWdlLnJlbW92ZUF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMCkgcmVjb3JkSW5saW5lSW1hZ2UoKTtcbiAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJhdWRpb1wiIHx8IHRhZ05hbWUgPT09IFwidmlkZW9cIikge1xuICAgIGNvbnN0IG1lZGlhQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhU3RhdGUgPSBuMi5wYXVzZWQgPyBcInBhdXNlZFwiIDogXCJwbGF5ZWRcIjtcbiAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFDdXJyZW50VGltZSA9IG4yLmN1cnJlbnRUaW1lO1xuICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVBsYXliYWNrUmF0ZSA9IG4yLnBsYXliYWNrUmF0ZTtcbiAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFNdXRlZCA9IG4yLm11dGVkO1xuICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUxvb3AgPSBuMi5sb29wO1xuICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVZvbHVtZSA9IG4yLnZvbHVtZTtcbiAgfVxuICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XG4gICAgaWYgKG4yLnNjcm9sbExlZnQpIHtcbiAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsTGVmdCA9IG4yLnNjcm9sbExlZnQ7XG4gICAgfVxuICAgIGlmIChuMi5zY3JvbGxUb3ApIHtcbiAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsVG9wID0gbjIuc2Nyb2xsVG9wO1xuICAgIH1cbiAgfVxuICBpZiAobmVlZEJsb2NrKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBuMi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBhdHRyaWJ1dGVzID0ge1xuICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMuY2xhc3MsXG4gICAgICBycl93aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgcnJfaGVpZ2h0OiBgJHtoZWlnaHR9cHhgXG4gICAgfTtcbiAgfVxuICBpZiAodGFnTmFtZSA9PT0gXCJpZnJhbWVcIiAmJiAha2VlcElmcmFtZVNyY0ZuKGF0dHJpYnV0ZXMuc3JjKSkge1xuICAgIGlmICghbjIuY29udGVudERvY3VtZW50KSB7XG4gICAgICBhdHRyaWJ1dGVzLnJyX3NyYyA9IGF0dHJpYnV0ZXMuc3JjO1xuICAgIH1cbiAgICBkZWxldGUgYXR0cmlidXRlcy5zcmM7XG4gIH1cbiAgbGV0IGlzQ3VzdG9tRWxlbWVudDtcbiAgdHJ5IHtcbiAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xuICB9IGNhdGNoIChlMikge1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogTm9kZVR5cGUkMy5FbGVtZW50LFxuICAgIHRhZ05hbWUsXG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICBpc1NWRzogaXNTVkdFbGVtZW50KG4yKSB8fCB2b2lkIDAsXG4gICAgbmVlZEJsb2NrLFxuICAgIHJvb3RJZCxcbiAgICBpc0N1c3RvbTogaXNDdXN0b21FbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xuICBpZiAobWF5YmVBdHRyID09PSB2b2lkIDAgfHwgbWF5YmVBdHRyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1heWJlQXR0ci50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XG4gIGlmIChzbGltRE9NT3B0aW9ucy5jb21tZW50ICYmIHNuLnR5cGUgPT09IE5vZGVUeXBlJDMuQ29tbWVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHNuLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkge1xuICAgIGlmIChzbGltRE9NT3B0aW9ucy5zY3JpcHQgJiYgLy8gc2NyaXB0IHRhZ1xuICAgIChzbi50YWdOYW1lID09PSBcInNjcmlwdFwiIHx8IC8vIChtb2R1bGUpcHJlbG9hZCBsaW5rXG4gICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgKHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWxvYWRcIiB8fCBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJtb2R1bGVwcmVsb2FkXCIpICYmIHNuLmF0dHJpYnV0ZXMuYXMgPT09IFwic2NyaXB0XCIgfHwgLy8gcHJlZmV0Y2ggbGlua1xuICAgIHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWZldGNoXCIgJiYgdHlwZW9mIHNuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBleHRyYWN0RmlsZUV4dGVuc2lvbihzbi5hdHRyaWJ1dGVzLmhyZWYpID09PSBcImpzXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRGYXZpY29uICYmIChzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzaG9ydGN1dCBpY29uXCIgfHwgc24udGFnTmFtZSA9PT0gXCJtZXRhXCIgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaChcbiAgICAgIC9ebXNhcHBsaWNhdGlvbi10aWxlKGltYWdlfGNvbG9yKSQvXG4gICAgKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYXBwbGljYXRpb24tbmFtZVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcImljb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJhcHBsZS10b3VjaC1pY29uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwic2hvcnRjdXQgaWNvblwiKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc24udGFnTmFtZSA9PT0gXCJtZXRhXCIpIHtcbiAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YURlc2NLZXl3b3JkcyAmJiBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL15kZXNjcmlwdGlvbnxrZXl3b3JkcyQvKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFTb2NpYWwgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL14ob2d8dHdpdHRlcnxmYik6LykgfHwgLy8gb2cgPSBvcGVuZ3JhcGggKGZhY2Vib29rKVxuICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eKG9nfHR3aXR0ZXIpOi8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwaW50ZXJlc3RcIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhUm9ib3RzICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicm9ib3RzXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdvb2dsZWJvdFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJiaW5nYm90XCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUh0dHBFcXVpdiAmJiBzbi5hdHRyaWJ1dGVzW1wiaHR0cC1lcXVpdlwiXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUF1dGhvcnNoaXAgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJhdXRob3JcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ2VuZXJhdG9yXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImZyYW1ld29ya1wiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwdWJsaXNoZXJcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicHJvZ2lkXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXmFydGljbGU6LykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXnByb2R1Y3Q6LykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVZlcmlmaWNhdGlvbiAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdvb2dsZS1zaXRlLXZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ5YW5kZXgtdmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImNzcmYtdG9rZW5cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicDpkb21haW5fdmVyaWZ5XCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInZlcmlmeS12MVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ2ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwic2hvcGlmeS1jaGVja291dC1hcGktdG9rZW5cIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgbWFza1RleHRTZWxlY3RvcixcbiAgICBza2lwQ2hpbGQgPSBmYWxzZSxcbiAgICBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSxcbiAgICBtYXNrSW5wdXRPcHRpb25zID0ge30sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBzbGltRE9NT3B0aW9ucyxcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIGlubGluZUltYWdlcyA9IGZhbHNlLFxuICAgIHJlY29yZENhbnZhcyA9IGZhbHNlLFxuICAgIG9uU2VyaWFsaXplLFxuICAgIG9uSWZyYW1lTG9hZCxcbiAgICBpZnJhbWVMb2FkVGltZW91dCA9IDVlMyxcbiAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IDVlMyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLFxuICAgIGNzc0NhcHR1cmVkID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB7IG5lZWRzTWFzayB9ID0gb3B0aW9ucztcbiAgbGV0IHsgcHJlc2VydmVXaGl0ZVNwYWNlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgaWYgKCFuZWVkc01hc2spIHtcbiAgICBjb25zdCBjaGVja0FuY2VzdG9ycyA9IG5lZWRzTWFzayA9PT0gdm9pZCAwO1xuICAgIG5lZWRzTWFzayA9IG5lZWRNYXNraW5nVGV4dChcbiAgICAgIG4yLFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBjaGVja0FuY2VzdG9yc1xuICAgICk7XG4gIH1cbiAgY29uc3QgX3NlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplTm9kZShuMiwge1xuICAgIGRvYyxcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIG5lZWRzTWFzayxcbiAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICBuZXdseUFkZGVkRWxlbWVudCxcbiAgICBjc3NDYXB0dXJlZFxuICB9KTtcbiAgaWYgKCFfc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zb2xlLndhcm4objIsIFwibm90IHNlcmlhbGl6ZWRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGlkO1xuICBpZiAobWlycm9yMi5oYXNOb2RlKG4yKSkge1xuICAgIGlkID0gbWlycm9yMi5nZXRJZChuMik7XG4gIH0gZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8ICFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiYgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuVGV4dCAmJiAhX3NlcmlhbGl6ZWROb2RlLnRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskL2dtLCBcIlwiKS5sZW5ndGgpIHtcbiAgICBpZCA9IElHTk9SRURfTk9ERTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IGdlbklkKCk7XG4gIH1cbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBPYmplY3QuYXNzaWduKF9zZXJpYWxpemVkTm9kZSwgeyBpZCB9KTtcbiAgbWlycm9yMi5hZGQobjIsIHNlcmlhbGl6ZWROb2RlKTtcbiAgaWYgKGlkID09PSBJR05PUkVEX05PREUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob25TZXJpYWxpemUpIHtcbiAgICBvblNlcmlhbGl6ZShuMik7XG4gIH1cbiAgbGV0IHJlY29yZENoaWxkID0gIXNraXBDaGlsZDtcbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkge1xuICAgIHJlY29yZENoaWxkID0gcmVjb3JkQ2hpbGQgJiYgIXNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcbiAgICBkZWxldGUgc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3RFbCA9IGluZGV4JDEuc2hhZG93Um9vdChuMik7XG4gICAgaWYgKHNoYWRvd1Jvb3RFbCAmJiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290RWwpKVxuICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3dIb3N0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRG9jdW1lbnQgfHwgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSAmJiByZWNvcmRDaGlsZCkge1xuICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkV2hpdGVzcGFjZSAmJiBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJoZWFkXCIpIHtcbiAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBieXBhc3NPcHRpb25zID0ge1xuICAgICAgZG9jLFxuICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICBuZWVkc01hc2ssXG4gICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgIHNraXBDaGlsZCxcbiAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgbWFza1RleHRGbixcbiAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgIGlubGluZUltYWdlcyxcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgIG9uU2VyaWFsaXplLFxuICAgICAgb25JZnJhbWVMb2FkLFxuICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgY3NzQ2FwdHVyZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnZhbHVlICE9PSB2b2lkIDApIDtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5fY3NzVGV4dCAhPT0gdm9pZCAwICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLl9jc3NUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJ5cGFzc09wdGlvbnMuY3NzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZE4gb2YgQXJyYXkuZnJvbShpbmRleCQxLmNoaWxkTm9kZXMobjIpKSkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xuICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2hhZG93Um9vdEVsID0gbnVsbDtcbiAgICBpZiAoaXNFbGVtZW50KG4yKSAmJiAoc2hhZG93Um9vdEVsID0gaW5kZXgkMS5zaGFkb3dSb290KG4yKSkpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGROIG9mIEFycmF5LmZyb20oaW5kZXgkMS5jaGlsZE5vZGVzKHNoYWRvd1Jvb3RFbCkpKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XG4gICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XG4gICAgICAgICAgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdEVsKSAmJiAoc2VyaWFsaXplZENoaWxkTm9kZS5pc1NoYWRvdyA9IHRydWUpO1xuICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnQgPSBpbmRleCQxLnBhcmVudE5vZGUobjIpO1xuICBpZiAocGFyZW50ICYmIGlzU2hhZG93Um9vdChwYXJlbnQpICYmIGlzTmF0aXZlU2hhZG93RG9tKHBhcmVudCkpIHtcbiAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvdyA9IHRydWU7XG4gIH1cbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImlmcmFtZVwiKSB7XG4gICAgb25jZUlmcmFtZUxvYWRlZChcbiAgICAgIG4yLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCBpZnJhbWVEb2MgPSBuMi5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGlmIChpZnJhbWVEb2MgJiYgb25JZnJhbWVMb2FkKSB7XG4gICAgICAgICAgY29uc3Qgc2VyaWFsaXplZElmcmFtZU5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGlmcmFtZURvYywge1xuICAgICAgICAgICAgZG9jOiBpZnJhbWVEb2MsXG4gICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG5lZWRzTWFzayxcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgbWFza1RleHRGbixcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgIGlubGluZUltYWdlcyxcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgICAgIG9uU2VyaWFsaXplLFxuICAgICAgICAgICAgb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHNlcmlhbGl6ZWRJZnJhbWVOb2RlKSB7XG4gICAgICAgICAgICBvbklmcmFtZUxvYWQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBzZXJpYWxpemVkSWZyYW1lTm9kZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpZnJhbWVMb2FkVGltZW91dFxuICAgICk7XG4gIH1cbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImxpbmtcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwic3RyaW5nXCIgJiYgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYpID09PSBcImNzc1wiKSkge1xuICAgIG9uY2VTdHlsZXNoZWV0TG9hZGVkKFxuICAgICAgbjIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGlmIChvblN0eWxlc2hlZXRMb2FkKSB7XG4gICAgICAgICAgY29uc3Qgc2VyaWFsaXplZExpbmtOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwge1xuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBuZWVkc01hc2ssXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzZXJpYWxpemVkTGlua05vZGUpIHtcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBzZXJpYWxpemVkTGlua05vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0XG4gICAgKTtcbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZE5vZGU7XG59XG5mdW5jdGlvbiBzbmFwc2hvdChuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbWlycm9yOiBtaXJyb3IyID0gbmV3IE1pcnJvcigpLFxuICAgIGJsb2NrQ2xhc3MgPSBcInJyLWJsb2NrXCIsXG4gICAgYmxvY2tTZWxlY3RvciA9IG51bGwsXG4gICAgbWFza1RleHRDbGFzcyA9IFwicnItbWFza1wiLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLFxuICAgIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLFxuICAgIGlubGluZUltYWdlcyA9IGZhbHNlLFxuICAgIHJlY29yZENhbnZhcyA9IGZhbHNlLFxuICAgIG1hc2tBbGxJbnB1dHMgPSBmYWxzZSxcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHNsaW1ET00gPSBmYWxzZSxcbiAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgb25TZXJpYWxpemUsXG4gICAgb25JZnJhbWVMb2FkLFxuICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgIGtlZXBJZnJhbWVTcmNGbiA9ICgpID0+IGZhbHNlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtYXNrSW5wdXRPcHRpb25zID0gbWFza0FsbElucHV0cyA9PT0gdHJ1ZSA/IHtcbiAgICBjb2xvcjogdHJ1ZSxcbiAgICBkYXRlOiB0cnVlLFxuICAgIFwiZGF0ZXRpbWUtbG9jYWxcIjogdHJ1ZSxcbiAgICBlbWFpbDogdHJ1ZSxcbiAgICBtb250aDogdHJ1ZSxcbiAgICBudW1iZXI6IHRydWUsXG4gICAgcmFuZ2U6IHRydWUsXG4gICAgc2VhcmNoOiB0cnVlLFxuICAgIHRlbDogdHJ1ZSxcbiAgICB0ZXh0OiB0cnVlLFxuICAgIHRpbWU6IHRydWUsXG4gICAgdXJsOiB0cnVlLFxuICAgIHdlZWs6IHRydWUsXG4gICAgdGV4dGFyZWE6IHRydWUsXG4gICAgc2VsZWN0OiB0cnVlLFxuICAgIHBhc3N3b3JkOiB0cnVlXG4gIH0gOiBtYXNrQWxsSW5wdXRzID09PSBmYWxzZSA/IHtcbiAgICBwYXNzd29yZDogdHJ1ZVxuICB9IDogbWFza0FsbElucHV0cztcbiAgY29uc3Qgc2xpbURPTU9wdGlvbnMgPSBzbGltRE9NID09PSB0cnVlIHx8IHNsaW1ET00gPT09IFwiYWxsXCIgPyAoXG4gICAgLy8gaWYgdHJ1ZTogc2V0IG9mIHNlbnNpYmxlIG9wdGlvbnMgdGhhdCBzaG91bGQgbm90IHRocm93IGF3YXkgYW55IGluZm9ybWF0aW9uXG4gICAge1xuICAgICAgc2NyaXB0OiB0cnVlLFxuICAgICAgY29tbWVudDogdHJ1ZSxcbiAgICAgIGhlYWRGYXZpY29uOiB0cnVlLFxuICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgICBoZWFkTWV0YURlc2NLZXl3b3Jkczogc2xpbURPTSA9PT0gXCJhbGxcIixcbiAgICAgIC8vIGRlc3RydWN0aXZlXG4gICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhUm9ib3RzOiB0cnVlLFxuICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IHRydWUsXG4gICAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZVxuICAgIH1cbiAgKSA6IHNsaW1ET00gPT09IGZhbHNlID8ge30gOiBzbGltRE9NO1xuICByZXR1cm4gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwge1xuICAgIGRvYzogbjIsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBtYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBzbGltRE9NT3B0aW9ucyxcbiAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICBpbmxpbmVJbWFnZXMsXG4gICAgcmVjb3JkQ2FudmFzLFxuICAgIHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICBvblNlcmlhbGl6ZSxcbiAgICBvbklmcmFtZUxvYWQsXG4gICAgaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEoeDIpIHtcbiAgcmV0dXJuIHgyICYmIHgyLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcImRlZmF1bHRcIikgPyB4MltcImRlZmF1bHRcIl0gOiB4Mjtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZSQxKG4yKSB7XG4gIGlmIChuMi5fX2VzTW9kdWxlKSByZXR1cm4gbjI7XG4gIHZhciBmMiA9IG4yLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZjIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGEyID0gZnVuY3Rpb24gYTIyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBhMjIpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYyLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBhMi5wcm90b3R5cGUgPSBmMi5wcm90b3R5cGU7XG4gIH0gZWxzZSBhMiA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3Qua2V5cyhuMikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4yLCBrKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbjJba107XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYTI7XG59XG52YXIgcGljb2NvbG9yc19icm93c2VyJDEgPSB7IGV4cG9ydHM6IHt9IH07XG52YXIgeCQxID0gU3RyaW5nO1xudmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IGlzQ29sb3JTdXBwb3J0ZWQ6IGZhbHNlLCByZXNldDogeCQxLCBib2xkOiB4JDEsIGRpbTogeCQxLCBpdGFsaWM6IHgkMSwgdW5kZXJsaW5lOiB4JDEsIGludmVyc2U6IHgkMSwgaGlkZGVuOiB4JDEsIHN0cmlrZXRocm91Z2g6IHgkMSwgYmxhY2s6IHgkMSwgcmVkOiB4JDEsIGdyZWVuOiB4JDEsIHllbGxvdzogeCQxLCBibHVlOiB4JDEsIG1hZ2VudGE6IHgkMSwgY3lhbjogeCQxLCB3aGl0ZTogeCQxLCBncmF5OiB4JDEsIGJnQmxhY2s6IHgkMSwgYmdSZWQ6IHgkMSwgYmdHcmVlbjogeCQxLCBiZ1llbGxvdzogeCQxLCBiZ0JsdWU6IHgkMSwgYmdNYWdlbnRhOiB4JDEsIGJnQ3lhbjogeCQxLCBiZ1doaXRlOiB4JDEgfTtcbn07XG5waWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzID0gY3JlYXRlJDEoKTtcbnBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHMuY3JlYXRlQ29sb3JzID0gY3JlYXRlJDE7XG52YXIgcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyQxID0gcGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cztcbmNvbnN0IF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQyID0ge307XG5jb25zdCBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdDogX192aXRlQnJvd3NlckV4dGVybmFsJDJcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5jb25zdCByZXF1aXJlJCQyJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0QXVnbWVudGVkTmFtZXNwYWNlJDEoX192aXRlQnJvd3NlckV4dGVybmFsJDEkMSk7XG5sZXQgcGljbyQxID0gcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyQxO1xubGV0IHRlcm1pbmFsSGlnaGxpZ2h0JDEkMSA9IHJlcXVpcmUkJDIkMTtcbmxldCBDc3NTeW50YXhFcnJvciQzJDEgPSBjbGFzcyBDc3NTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBzb3VyY2UsIGZpbGUsIHBsdWdpbjIyKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJDc3NTeW50YXhFcnJvclwiO1xuICAgIHRoaXMucmVhc29uID0gbWVzc2FnZTtcbiAgICBpZiAoZmlsZSkge1xuICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChwbHVnaW4yMikge1xuICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW4yMjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb2x1bW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBsaW5lLmNvbHVtbjtcbiAgICAgICAgdGhpcy5lbmRMaW5lID0gY29sdW1uLmxpbmU7XG4gICAgICAgIHRoaXMuZW5kQ29sdW1uID0gY29sdW1uLmNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRNZXNzYWdlKCk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3NTeW50YXhFcnJvcik7XG4gICAgfVxuICB9XG4gIHNldE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wbHVnaW4gPyB0aGlzLnBsdWdpbiArIFwiOiBcIiA6IFwiXCI7XG4gICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6IFwiPGNzcyBpbnB1dD5cIjtcbiAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOlwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbjtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlICs9IFwiOiBcIiArIHRoaXMucmVhc29uO1xuICB9XG4gIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuIFwiXCI7XG4gICAgbGV0IGNzcyA9IHRoaXMuc291cmNlO1xuICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHBpY28kMS5pc0NvbG9yU3VwcG9ydGVkO1xuICAgIGlmICh0ZXJtaW5hbEhpZ2hsaWdodCQxJDEpIHtcbiAgICAgIGlmIChjb2xvcikgY3NzID0gdGVybWluYWxIaWdobGlnaHQkMSQxKGNzcyk7XG4gICAgfVxuICAgIGxldCBsaW5lcyA9IGNzcy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApO1xuICAgIGxldCBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgIGxldCBtYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgICBsZXQgbWFyaywgYXNpZGU7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBsZXQgeyBib2xkLCBncmF5LCByZWQgfSA9IHBpY28kMS5jcmVhdGVDb2xvcnModHJ1ZSk7XG4gICAgICBtYXJrID0gKHRleHQpID0+IGJvbGQocmVkKHRleHQpKTtcbiAgICAgIGFzaWRlID0gKHRleHQpID0+IGdyYXkodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmsgPSBhc2lkZSA9IChzdHIpID0+IHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcCgobGluZSwgaW5kZXgyKSA9PiB7XG4gICAgICBsZXQgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXgyO1xuICAgICAgbGV0IGd1dHRlciA9IFwiIFwiICsgKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgXCIgfCBcIjtcbiAgICAgIGlmIChudW1iZXIgPT09IHRoaXMubGluZSkge1xuICAgICAgICBsZXQgc3BhY2luZyA9IGFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSArIGxpbmUuc2xpY2UoMCwgdGhpcy5jb2x1bW4gLSAxKS5yZXBsYWNlKC9bXlxcdF0vZywgXCIgXCIpO1xuICAgICAgICByZXR1cm4gbWFyayhcIj5cIikgKyBhc2lkZShndXR0ZXIpICsgbGluZSArIFwiXFxuIFwiICsgc3BhY2luZyArIG1hcmsoXCJeXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiIFwiICsgYXNpZGUoZ3V0dGVyKSArIGxpbmU7XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgY29kZSA9IHRoaXMuc2hvd1NvdXJjZUNvZGUoKTtcbiAgICBpZiAoY29kZSkge1xuICAgICAgY29kZSA9IFwiXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIGNvZGU7XG4gIH1cbn07XG52YXIgY3NzU3ludGF4RXJyb3IkMSA9IENzc1N5bnRheEVycm9yJDMkMTtcbkNzc1N5bnRheEVycm9yJDMkMS5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3IkMyQxO1xudmFyIHN5bWJvbHMkMSA9IHt9O1xuc3ltYm9scyQxLmlzQ2xlYW4gPSBTeW1ib2woXCJpc0NsZWFuXCIpO1xuc3ltYm9scyQxLm15ID0gU3ltYm9sKFwibXlcIik7XG5jb25zdCBERUZBVUxUX1JBVyQxID0ge1xuICBhZnRlcjogXCJcXG5cIixcbiAgYmVmb3JlQ2xvc2U6IFwiXFxuXCIsXG4gIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gIGJlZm9yZURlY2w6IFwiXFxuXCIsXG4gIGJlZm9yZU9wZW46IFwiIFwiLFxuICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICBjb2xvbjogXCI6IFwiLFxuICBjb21tZW50TGVmdDogXCIgXCIsXG4gIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gIGVtcHR5Qm9keTogXCJcIixcbiAgaW5kZW50OiBcIiAgICBcIixcbiAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUkMShzdHIpIHtcbiAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxubGV0IFN0cmluZ2lmaWVyJDIkMSA9IGNsYXNzIFN0cmluZ2lmaWVyIHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gIH1cbiAgYXRydWxlKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICBsZXQgbmFtZSA9IFwiQFwiICsgbm9kZTIubmFtZTtcbiAgICBsZXQgcGFyYW1zID0gbm9kZTIucGFyYW1zID8gdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJwYXJhbXNcIikgOiBcIlwiO1xuICAgIGlmICh0eXBlb2Ygbm9kZTIucmF3cy5hZnRlck5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG5hbWUgKz0gbm9kZTIucmF3cy5hZnRlck5hbWU7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgIG5hbWUgKz0gXCIgXCI7XG4gICAgfVxuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgdGhpcy5ibG9jayhub2RlMiwgbmFtZSArIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSAobm9kZTIucmF3cy5iZXR3ZWVuIHx8IFwiXCIpICsgKHNlbWljb2xvbiA/IFwiO1wiIDogXCJcIik7XG4gICAgICB0aGlzLmJ1aWxkZXIobmFtZSArIHBhcmFtcyArIGVuZCwgbm9kZTIpO1xuICAgIH1cbiAgfVxuICBiZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ29tbWVudFwiKTtcbiAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNsb3NlXCIpO1xuICAgIH1cbiAgICBsZXQgYnVmID0gbm9kZTIucGFyZW50O1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgd2hpbGUgKGJ1ZiAmJiBidWYudHlwZSAhPT0gXCJyb290XCIpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgICBidWYgPSBidWYucGFyZW50O1xuICAgIH1cbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIGxldCBpbmRlbnQgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJpbmRlbnRcIik7XG4gICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IGRlcHRoOyBzdGVwKyspIHZhbHVlICs9IGluZGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGJsb2NrKG5vZGUyLCBzdGFydCkge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArIFwie1wiLCBub2RlMiwgXCJzdGFydFwiKTtcbiAgICBsZXQgYWZ0ZXI7XG4gICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIiwgXCJlbXB0eUJvZHlcIik7XG4gICAgfVxuICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKTtcbiAgICB0aGlzLmJ1aWxkZXIoXCJ9XCIsIG5vZGUyLCBcImVuZFwiKTtcbiAgfVxuICBib2R5KG5vZGUyKSB7XG4gICAgbGV0IGxhc3QgPSBub2RlMi5ub2Rlcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsYXN0ID4gMCkge1xuICAgICAgaWYgKG5vZGUyLm5vZGVzW2xhc3RdLnR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIGxhc3QgLT0gMTtcbiAgICB9XG4gICAgbGV0IHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUyLCBcInNlbWljb2xvblwiKTtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZTIubm9kZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlMi5ub2Rlc1tpMl07XG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsIFwiYmVmb3JlXCIpO1xuICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSk7XG4gICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaTIgfHwgc2VtaWNvbG9uKTtcbiAgICB9XG4gIH1cbiAgY29tbWVudChub2RlMikge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yYXcobm9kZTIsIFwibGVmdFwiLCBcImNvbW1lbnRMZWZ0XCIpO1xuICAgIGxldCByaWdodCA9IHRoaXMucmF3KG5vZGUyLCBcInJpZ2h0XCIsIFwiY29tbWVudFJpZ2h0XCIpO1xuICAgIHRoaXMuYnVpbGRlcihcIi8qXCIgKyBsZWZ0ICsgbm9kZTIudGV4dCArIHJpZ2h0ICsgXCIqL1wiLCBub2RlMik7XG4gIH1cbiAgZGVjbChub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiY29sb25cIik7XG4gICAgbGV0IHN0cmluZyA9IG5vZGUyLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAobm9kZTIuaW1wb3J0YW50KSB7XG4gICAgICBzdHJpbmcgKz0gbm9kZTIucmF3cy5pbXBvcnRhbnQgfHwgXCIgIWltcG9ydGFudFwiO1xuICAgIH1cbiAgICBpZiAoc2VtaWNvbG9uKSBzdHJpbmcgKz0gXCI7XCI7XG4gICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZTIpO1xuICB9XG4gIGRvY3VtZW50KG5vZGUyKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgfVxuICByYXcobm9kZTIsIG93biwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICghZGV0ZWN0KSBkZXRlY3QgPSBvd247XG4gICAgaWYgKG93bikge1xuICAgICAgdmFsdWUgPSBub2RlMi5yYXdzW293bl07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBub2RlMi5wYXJlbnQ7XG4gICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVckMVtkZXRlY3RdO1xuICAgIGxldCByb290MiA9IG5vZGUyLnJvb3QoKTtcbiAgICBpZiAoIXJvb3QyLnJhd0NhY2hlKSByb290Mi5yYXdDYWNoZSA9IHt9O1xuICAgIGlmICh0eXBlb2Ygcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHJvb3QyLnJhd0NhY2hlW2RldGVjdF07XG4gICAgfVxuICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIgfHwgZGV0ZWN0ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWV0aG9kID0gXCJyYXdcIiArIGNhcGl0YWxpemUkMShkZXRlY3QpO1xuICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXNbbWV0aG9kXShyb290Miwgbm9kZTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Nbb3duXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB2YWx1ZSA9IERFRkFVTFRfUkFXJDFbZGV0ZWN0XTtcbiAgICByb290Mi5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZUNsb3NlKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZUNvbW1lbnQocm9vdDIsIG5vZGUyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtDb21tZW50cygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVEZWNsKHJvb3QyLCBub2RlMikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrRGVjbHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlT3Blbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLnR5cGUgIT09IFwiZGVjbFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZVJ1bGUocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiAoaTIucGFyZW50ICE9PSByb290MiB8fCByb290Mi5maXJzdCAhPT0gaTIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdDb2xvbihyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrRGVjbHMoKGkyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmV0d2VlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0VtcHR5Qm9keShyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3SW5kZW50KHJvb3QyKSB7XG4gICAgaWYgKHJvb3QyLnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdDIucmF3cy5pbmRlbnQ7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBsZXQgcCA9IGkyLnBhcmVudDtcbiAgICAgIGlmIChwICYmIHAgIT09IHJvb3QyICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290Mikge1xuICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gaTIucmF3cy5iZWZvcmUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgdmFsdWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3U2VtaWNvbG9uKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoICYmIGkyLmxhc3QudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLnNlbWljb2xvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdWYWx1ZShub2RlMiwgcHJvcCkge1xuICAgIGxldCB2YWx1ZSA9IG5vZGUyW3Byb3BdO1xuICAgIGxldCByYXcgPSBub2RlMi5yYXdzW3Byb3BdO1xuICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJhdy5yYXc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByb290KG5vZGUyKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICBpZiAobm9kZTIucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3MuYWZ0ZXIpO1xuICB9XG4gIHJ1bGUobm9kZTIpIHtcbiAgICB0aGlzLmJsb2NrKG5vZGUyLCB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInNlbGVjdG9yXCIpKTtcbiAgICBpZiAobm9kZTIucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLm93blNlbWljb2xvbiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdpZnkobm9kZTIsIHNlbWljb2xvbikge1xuICAgIGlmICghdGhpc1tub2RlMi50eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlVua25vd24gQVNUIG5vZGUgdHlwZSBcIiArIG5vZGUyLnR5cGUgKyBcIi4gTWF5YmUgeW91IG5lZWQgdG8gY2hhbmdlIFBvc3RDU1Mgc3RyaW5naWZpZXIuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXNbbm9kZTIudHlwZV0obm9kZTIsIHNlbWljb2xvbik7XG4gIH1cbn07XG52YXIgc3RyaW5naWZpZXIkMSA9IFN0cmluZ2lmaWVyJDIkMTtcblN0cmluZ2lmaWVyJDIkMS5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMiQxO1xubGV0IFN0cmluZ2lmaWVyJDEkMSA9IHN0cmluZ2lmaWVyJDE7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNCQxKG5vZGUyLCBidWlsZGVyKSB7XG4gIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIkMSQxKGJ1aWxkZXIpO1xuICBzdHIuc3RyaW5naWZ5KG5vZGUyKTtcbn1cbnZhciBzdHJpbmdpZnlfMSQxID0gc3RyaW5naWZ5JDQkMTtcbnN0cmluZ2lmeSQ0JDEuZGVmYXVsdCA9IHN0cmluZ2lmeSQ0JDE7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDIkMSwgbXk6IG15JDIkMSB9ID0gc3ltYm9scyQxO1xubGV0IENzc1N5bnRheEVycm9yJDIkMSA9IGNzc1N5bnRheEVycm9yJDE7XG5sZXQgU3RyaW5naWZpZXIyJDEgPSBzdHJpbmdpZmllciQxO1xubGV0IHN0cmluZ2lmeSQzJDEgPSBzdHJpbmdpZnlfMSQxO1xuZnVuY3Rpb24gY2xvbmVOb2RlJDEob2JqLCBwYXJlbnQpIHtcbiAgbGV0IGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgZm9yIChsZXQgaTIgaW4gb2JqKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaTIgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICBsZXQgdmFsdWUgPSBvYmpbaTJdO1xuICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChpMiA9PT0gXCJwYXJlbnRcIiAmJiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAocGFyZW50KSBjbG9uZWRbaTJdID0gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAoaTIgPT09IFwic291cmNlXCIpIHtcbiAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjbG9uZWRbaTJdID0gdmFsdWUubWFwKChqKSA9PiBjbG9uZU5vZGUkMShqLCBjbG9uZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlJDEodmFsdWUpO1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxubGV0IE5vZGUkNCQxID0gY2xhc3MgTm9kZTIge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cyA9IHt9KSB7XG4gICAgdGhpcy5yYXdzID0ge307XG4gICAgdGhpc1tpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICB0aGlzW215JDIkMV0gPSB0cnVlO1xuICAgIGZvciAobGV0IG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChuYW1lID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBub2RlMiBvZiBkZWZhdWx0c1tuYW1lXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZTIuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIuY2xvbmUoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkVG9FcnJvcihlcnJvcikge1xuICAgIGVycm9yLnBvc3Rjc3NOb2RlID0gdGhpcztcbiAgICBpZiAoZXJyb3Iuc3RhY2sgJiYgdGhpcy5zb3VyY2UgJiYgL1xcblxcc3s0fWF0IC8udGVzdChlcnJvci5zdGFjaykpIHtcbiAgICAgIGxldCBzMiA9IHRoaXMuc291cmNlO1xuICAgICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKFxuICAgICAgICAvXFxuXFxzezR9YXQgLyxcbiAgICAgICAgYCQmJHtzMi5pbnB1dC5mcm9tfToke3MyLnN0YXJ0LmxpbmV9OiR7czIuc3RhcnQuY29sdW1ufSQmYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGFmdGVyKGFkZCkge1xuICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGFkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXNzaWduKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJlZm9yZShhZGQpIHtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgYWRkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICBkZWxldGUgdGhpcy5yYXdzLmJlZm9yZTtcbiAgICBkZWxldGUgdGhpcy5yYXdzLmFmdGVyO1xuICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlbjtcbiAgfVxuICBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSBjbG9uZU5vZGUkMSh0aGlzKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG92ZXJyaWRlcykge1xuICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lQWZ0ZXIob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZCk7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBjbG9uZUJlZm9yZShvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGNsb25lZCk7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBlcnJvcihtZXNzYWdlLCBvcHRzID0ge30pIHtcbiAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgIGxldCB7IGVuZCwgc3RhcnQgfSA9IHRoaXMucmFuZ2VCeShvcHRzKTtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5pbnB1dC5lcnJvcihcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgeyBjb2x1bW46IHN0YXJ0LmNvbHVtbiwgbGluZTogc3RhcnQubGluZSB9LFxuICAgICAgICB7IGNvbHVtbjogZW5kLmNvbHVtbiwgbGluZTogZW5kLmxpbmUgfSxcbiAgICAgICAgb3B0c1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvciQyJDEobWVzc2FnZSk7XG4gIH1cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgbWFya0RpcnR5KCkge1xuICAgIGlmICh0aGlzW2lzQ2xlYW4kMiQxXSkge1xuICAgICAgdGhpc1tpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICAgIGxldCBuZXh0ID0gdGhpcztcbiAgICAgIHdoaWxlIChuZXh0ID0gbmV4dC5wYXJlbnQpIHtcbiAgICAgICAgbmV4dFtpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gIH1cbiAgcG9zaXRpb25CeShvcHRzLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgIGxldCBwb3MgPSB0aGlzLnNvdXJjZS5zdGFydDtcbiAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHRzLndvcmQpIHtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgbGV0IGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKSBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIHBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgIGxldCBjb2x1bW4gPSB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW47XG4gICAgbGV0IGxpbmUgPSB0aGlzLnNvdXJjZS5zdGFydC5saW5lO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBpbmRleDI7IGkyKyspIHtcbiAgICAgIGlmIChzdHJpbmdbaTJdID09PSBcIlxcblwiKSB7XG4gICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgIGxpbmUgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUgfTtcbiAgfVxuICBwcmV2KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgLSAxXTtcbiAgfVxuICByYW5nZUJ5KG9wdHMpIHtcbiAgICBsZXQgc3RhcnQgPSB7XG4gICAgICBjb2x1bW46IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbixcbiAgICAgIGxpbmU6IHRoaXMuc291cmNlLnN0YXJ0LmxpbmVcbiAgICB9O1xuICAgIGxldCBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICB9IDoge1xuICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgbGluZTogc3RhcnQubGluZVxuICAgIH07XG4gICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgbGV0IGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIgKyBvcHRzLndvcmQubGVuZ3RoLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRzLnN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIGNvbHVtbjogb3B0cy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuZW5kKSB7XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICBjb2x1bW46IG9wdHMuZW5kLmNvbHVtbixcbiAgICAgICAgICBsaW5lOiBvcHRzLmVuZC5saW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmVuZEluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQubGluZSA8IHN0YXJ0LmxpbmUgfHwgZW5kLmxpbmUgPT09IHN0YXJ0LmxpbmUgJiYgZW5kLmNvbHVtbiA8PSBzdGFydC5jb2x1bW4pIHtcbiAgICAgIGVuZCA9IHsgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLCBsaW5lOiBzdGFydC5saW5lIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuZCwgc3RhcnQgfTtcbiAgfVxuICByYXcocHJvcCwgZGVmYXVsdFR5cGUpIHtcbiAgICBsZXQgc3RyID0gbmV3IFN0cmluZ2lmaWVyMiQxKCk7XG4gICAgcmV0dXJuIHN0ci5yYXcodGhpcywgcHJvcCwgZGVmYXVsdFR5cGUpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXBsYWNlV2l0aCguLi5ub2Rlcykge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgbGV0IGJvb2ttYXJrID0gdGhpcztcbiAgICAgIGxldCBmb3VuZFNlbGYgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlMiA9PT0gdGhpcykge1xuICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmRTZWxmKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICBib29rbWFyayA9IG5vZGUyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShib29rbWFyaywgbm9kZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kU2VsZikge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb290KCkge1xuICAgIGxldCByZXN1bHQyID0gdGhpcztcbiAgICB3aGlsZSAocmVzdWx0Mi5wYXJlbnQgJiYgcmVzdWx0Mi5wYXJlbnQudHlwZSAhPT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICByZXN1bHQyID0gcmVzdWx0Mi5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIHRvSlNPTihfLCBpbnB1dHMpIHtcbiAgICBsZXQgZml4ZWQgPSB7fTtcbiAgICBsZXQgZW1pdElucHV0cyA9IGlucHV0cyA9PSBudWxsO1xuICAgIGlucHV0cyA9IGlucHV0cyB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBpbnB1dHNOZXh0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJwYXJlbnRcIiB8fCBuYW1lID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKChpMikgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwib2JqZWN0XCIgJiYgaTIudG9KU09OKSB7XG4gICAgICAgICAgICByZXR1cm4gaTIudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUudG9KU09OKSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgbGV0IGlucHV0SWQgPSBpbnB1dHMuZ2V0KHZhbHVlLmlucHV0KTtcbiAgICAgICAgaWYgKGlucHV0SWQgPT0gbnVsbCkge1xuICAgICAgICAgIGlucHV0SWQgPSBpbnB1dHNOZXh0SW5kZXg7XG4gICAgICAgICAgaW5wdXRzLnNldCh2YWx1ZS5pbnB1dCwgaW5wdXRzTmV4dEluZGV4KTtcbiAgICAgICAgICBpbnB1dHNOZXh0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBmaXhlZFtuYW1lXSA9IHtcbiAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICBpbnB1dElkLFxuICAgICAgICAgIHN0YXJ0OiB2YWx1ZS5zdGFydFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVtaXRJbnB1dHMpIHtcbiAgICAgIGZpeGVkLmlucHV0cyA9IFsuLi5pbnB1dHMua2V5cygpXS5tYXAoKGlucHV0MikgPT4gaW5wdXQyLnRvSlNPTigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkO1xuICB9XG4gIHRvUHJveHkoKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5Q2FjaGUpIHtcbiAgICAgIHRoaXMucHJveHlDYWNoZSA9IG5ldyBQcm94eSh0aGlzLCB0aGlzLmdldFByb3h5UHJvY2Vzc29yKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlO1xuICB9XG4gIHRvU3RyaW5nKHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmeSQzJDEpIHtcbiAgICBpZiAoc3RyaW5naWZpZXIyLnN0cmluZ2lmeSkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZpZXIyLnN0cmluZ2lmeTtcbiAgICBsZXQgcmVzdWx0MiA9IFwiXCI7XG4gICAgc3RyaW5naWZpZXIyKHRoaXMsIChpMikgPT4ge1xuICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm9kZTogdGhpcyB9O1xuICAgIGZvciAobGV0IGkyIGluIG9wdHMpIGRhdGFbaTJdID0gb3B0c1tpMl07XG4gICAgcmV0dXJuIHJlc3VsdDIud2Fybih0ZXh0LCBkYXRhKTtcbiAgfVxuICBnZXQgcHJveHlPZigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub2RlJDEgPSBOb2RlJDQkMTtcbk5vZGUkNCQxLmRlZmF1bHQgPSBOb2RlJDQkMTtcbmxldCBOb2RlJDMkMSA9IG5vZGUkMTtcbmxldCBEZWNsYXJhdGlvbiQ0JDEgPSBjbGFzcyBEZWNsYXJhdGlvbiBleHRlbmRzIE5vZGUkMyQxIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBpZiAoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKSB9O1xuICAgIH1cbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJkZWNsXCI7XG4gIH1cbiAgZ2V0IHZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aChcIi0tXCIpIHx8IHRoaXMucHJvcFswXSA9PT0gXCIkXCI7XG4gIH1cbn07XG52YXIgZGVjbGFyYXRpb24kMSA9IERlY2xhcmF0aW9uJDQkMTtcbkRlY2xhcmF0aW9uJDQkMS5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNCQxO1xubGV0IHVybEFscGhhYmV0JDEgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbmxldCBjdXN0b21BbHBoYWJldCQxID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICBsZXQgaTIgPSBzaXplO1xuICAgIHdoaWxlIChpMi0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoIHwgMF07XG4gICAgfVxuICAgIHJldHVybiBpZDtcbiAgfTtcbn07XG5sZXQgbmFub2lkJDEkMSA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkyID0gc2l6ZTtcbiAgd2hpbGUgKGkyLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldCQxW01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG52YXIgbm9uU2VjdXJlJDEgPSB7IG5hbm9pZDogbmFub2lkJDEkMSwgY3VzdG9tQWxwaGFiZXQ6IGN1c3RvbUFscGhhYmV0JDEgfTtcbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lciQyJDEsIFNvdXJjZU1hcEdlbmVyYXRvcjogU291cmNlTWFwR2VuZXJhdG9yJDIkMSB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgZXhpc3RzU3luYzogZXhpc3RzU3luYyQxLCByZWFkRmlsZVN5bmM6IHJlYWRGaWxlU3luYyQxIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBkaXJuYW1lOiBkaXJuYW1lJDEkMSwgam9pbjogam9pbiQxIH0gPSByZXF1aXJlJCQyJDE7XG5mdW5jdGlvbiBmcm9tQmFzZTY0JDEoc3RyKSB7XG4gIGlmIChCdWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpO1xuICB9XG59XG5sZXQgUHJldmlvdXNNYXAkMiQxID0gY2xhc3MgUHJldmlvdXNNYXAge1xuICBjb25zdHJ1Y3Rvcihjc3MsIG9wdHMpIHtcbiAgICBpZiAob3B0cy5tYXAgPT09IGZhbHNlKSByZXR1cm47XG4gICAgdGhpcy5sb2FkQW5ub3RhdGlvbihjc3MpO1xuICAgIHRoaXMuaW5saW5lID0gdGhpcy5zdGFydFdpdGgodGhpcy5hbm5vdGF0aW9uLCBcImRhdGE6XCIpO1xuICAgIGxldCBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdm9pZCAwO1xuICAgIGxldCB0ZXh0ID0gdGhpcy5sb2FkTWFwKG9wdHMuZnJvbSwgcHJldik7XG4gICAgaWYgKCF0aGlzLm1hcEZpbGUgJiYgb3B0cy5mcm9tKSB7XG4gICAgICB0aGlzLm1hcEZpbGUgPSBvcHRzLmZyb207XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcEZpbGUpIHRoaXMucm9vdCA9IGRpcm5hbWUkMSQxKHRoaXMubWFwRmlsZSk7XG4gICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgY29uc3VtZXIoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQyJDEodGhpcy50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc3VtZXJDYWNoZTtcbiAgfVxuICBkZWNvZGVJbmxpbmUodGV4dCkge1xuICAgIGxldCBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87XG4gICAgbGV0IGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvO1xuICAgIGxldCBjaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/OCwvO1xuICAgIGxldCB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC87XG4gICAgaWYgKGNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCB1cmkudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgIH1cbiAgICBpZiAoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCBiYXNlVXJpLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVybiBmcm9tQmFzZTY0JDEodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICB9XG4gICAgbGV0IGVuY29kaW5nID0gdGV4dC5tYXRjaCgvZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFteLF0rKSwvKVsxXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGVuY29kaW5nIFwiICsgZW5jb2RpbmcpO1xuICB9XG4gIGdldEFubm90YXRpb25VUkwoc291cmNlTWFwU3RyaW5nKSB7XG4gICAgcmV0dXJuIHNvdXJjZU1hcFN0cmluZy5yZXBsYWNlKC9eXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vLCBcIlwiKS50cmltKCk7XG4gIH1cbiAgaXNNYXAobWFwKSB7XG4gICAgaWYgKHR5cGVvZiBtYXAgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHlwZW9mIG1hcC5tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFwLl9tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KG1hcC5zZWN0aW9ucyk7XG4gIH1cbiAgbG9hZEFubm90YXRpb24oY3NzKSB7XG4gICAgbGV0IGNvbW1lbnRzID0gY3NzLm1hdGNoKC9cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS9nbSk7XG4gICAgaWYgKCFjb21tZW50cykgcmV0dXJuO1xuICAgIGxldCBzdGFydCA9IGNzcy5sYXN0SW5kZXhPZihjb21tZW50cy5wb3AoKSk7XG4gICAgbGV0IGVuZCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgc3RhcnQpO1xuICAgIGlmIChzdGFydCA+IC0xICYmIGVuZCA+IC0xKSB7XG4gICAgICB0aGlzLmFubm90YXRpb24gPSB0aGlzLmdldEFubm90YXRpb25VUkwoY3NzLnN1YnN0cmluZyhzdGFydCwgZW5kKSk7XG4gICAgfVxuICB9XG4gIGxvYWRGaWxlKHBhdGgpIHtcbiAgICB0aGlzLnJvb3QgPSBkaXJuYW1lJDEkMShwYXRoKTtcbiAgICBpZiAoZXhpc3RzU3luYyQxKHBhdGgpKSB7XG4gICAgICB0aGlzLm1hcEZpbGUgPSBwYXRoO1xuICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyQxKHBhdGgsIFwidXRmLThcIikudG9TdHJpbmcoKS50cmltKCk7XG4gICAgfVxuICB9XG4gIGxvYWRNYXAoZmlsZSwgcHJldikge1xuICAgIGlmIChwcmV2ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICBpZiAodHlwZW9mIHByZXYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGV0IHByZXZQYXRoID0gcHJldihmaWxlKTtcbiAgICAgICAgaWYgKHByZXZQYXRoKSB7XG4gICAgICAgICAgbGV0IG1hcCA9IHRoaXMubG9hZEZpbGUocHJldlBhdGgpO1xuICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVW5hYmxlIHRvIGxvYWQgcHJldmlvdXMgc291cmNlIG1hcDogXCIgKyBwcmV2UGF0aC50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXYgaW5zdGFuY2VvZiBTb3VyY2VNYXBDb25zdW1lciQyJDEpIHtcbiAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyJDEuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgU291cmNlTWFwR2VuZXJhdG9yJDIkMSkge1xuICAgICAgICByZXR1cm4gcHJldi50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTWFwKHByZXYpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcmV2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlVuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiBcIiArIHByZXYudG9TdHJpbmcoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZUlubGluZSh0aGlzLmFubm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hbm5vdGF0aW9uKSB7XG4gICAgICBsZXQgbWFwID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgaWYgKGZpbGUpIG1hcCA9IGpvaW4kMShkaXJuYW1lJDEkMShmaWxlKSwgbWFwKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRGaWxlKG1hcCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2l0aChzdHJpbmcsIHN0YXJ0KSB7XG4gICAgaWYgKCFzdHJpbmcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcbiAgfVxuICB3aXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKTtcbiAgfVxufTtcbnZhciBwcmV2aW91c01hcCQxID0gUHJldmlvdXNNYXAkMiQxO1xuUHJldmlvdXNNYXAkMiQxLmRlZmF1bHQgPSBQcmV2aW91c01hcCQyJDE7XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lcjogU291cmNlTWFwQ29uc3VtZXIkMSQxLCBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvciQxJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IGZpbGVVUkxUb1BhdGg6IGZpbGVVUkxUb1BhdGgkMSwgcGF0aFRvRmlsZVVSTDogcGF0aFRvRmlsZVVSTCQxJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IGlzQWJzb2x1dGU6IGlzQWJzb2x1dGUkMSwgcmVzb2x2ZTogcmVzb2x2ZSQxJDEgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCB7IG5hbm9pZDogbmFub2lkJDIgfSA9IG5vblNlY3VyZSQxO1xubGV0IHRlcm1pbmFsSGlnaGxpZ2h0JDIgPSByZXF1aXJlJCQyJDE7XG5sZXQgQ3NzU3ludGF4RXJyb3IkMSQxID0gY3NzU3ludGF4RXJyb3IkMTtcbmxldCBQcmV2aW91c01hcCQxJDEgPSBwcmV2aW91c01hcCQxO1xubGV0IGZyb21PZmZzZXRDYWNoZSQxID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSQxJDEgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyJDEkMSAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMSQxKTtcbmxldCBwYXRoQXZhaWxhYmxlJDEkMSA9IEJvb2xlYW4ocmVzb2x2ZSQxJDEgJiYgaXNBYnNvbHV0ZSQxKTtcbmxldCBJbnB1dCQ0JDEgPSBjbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGNzcyA9PT0gbnVsbCB8fCB0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBjc3MgPT09IFwib2JqZWN0XCIgJiYgIWNzcy50b1N0cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3N0Q1NTIHJlY2VpdmVkICR7Y3NzfSBpbnN0ZWFkIG9mIENTUyBzdHJpbmdgKTtcbiAgICB9XG4gICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5jc3NbMF0gPT09IFwiXFx1RkVGRlwiIHx8IHRoaXMuY3NzWzBdID09PSBcIu+/vlwiKSB7XG4gICAgICB0aGlzLmhhc0JPTSA9IHRydWU7XG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhc0JPTSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICBpZiAoIXBhdGhBdmFpbGFibGUkMSQxIHx8IC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fCBpc0Fic29sdXRlJDEob3B0cy5mcm9tKSkge1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHRzLmZyb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbGUgPSByZXNvbHZlJDEkMShvcHRzLmZyb20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aEF2YWlsYWJsZSQxJDEgJiYgc291cmNlTWFwQXZhaWxhYmxlJDEkMSkge1xuICAgICAgbGV0IG1hcCA9IG5ldyBQcmV2aW91c01hcCQxJDEodGhpcy5jc3MsIG9wdHMpO1xuICAgICAgaWYgKG1hcC50ZXh0KSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBsZXQgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGU7XG4gICAgICAgIGlmICghdGhpcy5maWxlICYmIGZpbGUpIHRoaXMuZmlsZSA9IHRoaXMubWFwUmVzb2x2ZShmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgIHRoaXMuaWQgPSBcIjxpbnB1dCBjc3MgXCIgKyBuYW5vaWQkMig2KSArIFwiPlwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gIH1cbiAgZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzID0ge30pIHtcbiAgICBsZXQgcmVzdWx0MiwgZW5kTGluZSwgZW5kQ29sdW1uO1xuICAgIGlmIChsaW5lICYmIHR5cGVvZiBsaW5lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBsZXQgc3RhcnQgPSBsaW5lO1xuICAgICAgbGV0IGVuZCA9IGNvbHVtbjtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICBjb2x1bW4gPSBwb3MuY29sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmU7XG4gICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICBlbmRMaW5lID0gcG9zLmxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IHBvcy5jb2w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmU7XG4gICAgICAgIGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghY29sdW1uKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICB9XG4gICAgbGV0IG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKTtcbiAgICBpZiAob3JpZ2luKSB7XG4gICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEkMShcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5saW5lIDogeyBjb2x1bW46IG9yaWdpbi5jb2x1bW4sIGxpbmU6IG9yaWdpbi5saW5lIH0sXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4uY29sdW1uIDogeyBjb2x1bW46IG9yaWdpbi5lbmRDb2x1bW4sIGxpbmU6IG9yaWdpbi5lbmRMaW5lIH0sXG4gICAgICAgIG9yaWdpbi5zb3VyY2UsXG4gICAgICAgIG9yaWdpbi5maWxlLFxuICAgICAgICBvcHRzLnBsdWdpblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxJDEoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGVuZExpbmUgPT09IHZvaWQgMCA/IGxpbmUgOiB7IGNvbHVtbiwgbGluZSB9LFxuICAgICAgICBlbmRMaW5lID09PSB2b2lkIDAgPyBjb2x1bW4gOiB7IGNvbHVtbjogZW5kQ29sdW1uLCBsaW5lOiBlbmRMaW5lIH0sXG4gICAgICAgIHRoaXMuY3NzLFxuICAgICAgICB0aGlzLmZpbGUsXG4gICAgICAgIG9wdHMucGx1Z2luXG4gICAgICApO1xuICAgIH1cbiAgICByZXN1bHQyLmlucHV0ID0geyBjb2x1bW4sIGVuZENvbHVtbiwgZW5kTGluZSwgbGluZSwgc291cmNlOiB0aGlzLmNzcyB9O1xuICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDEkMSkge1xuICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSQxKHRoaXMuZmlsZSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdDIuaW5wdXQuZmlsZSA9IHRoaXMuZmlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgZnJvbU9mZnNldChvZmZzZXQpIHtcbiAgICBsZXQgbGFzdExpbmUsIGxpbmVUb0luZGV4O1xuICAgIGlmICghdGhpc1tmcm9tT2Zmc2V0Q2FjaGUkMV0pIHtcbiAgICAgIGxldCBsaW5lcyA9IHRoaXMuY3NzLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgbGluZVRvSW5kZXggPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICAgIGxldCBwcmV2SW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGxpbmVzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKykge1xuICAgICAgICBsaW5lVG9JbmRleFtpMl0gPSBwcmV2SW5kZXg7XG4gICAgICAgIHByZXZJbmRleCArPSBsaW5lc1tpMl0ubGVuZ3RoICsgMTtcbiAgICAgIH1cbiAgICAgIHRoaXNbZnJvbU9mZnNldENhY2hlJDFdID0gbGluZVRvSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVUb0luZGV4ID0gdGhpc1tmcm9tT2Zmc2V0Q2FjaGUkMV07XG4gICAgfVxuICAgIGxhc3RMaW5lID0gbGluZVRvSW5kZXhbbGluZVRvSW5kZXgubGVuZ3RoIC0gMV07XG4gICAgbGV0IG1pbiA9IDA7XG4gICAgaWYgKG9mZnNldCA+PSBsYXN0TGluZSkge1xuICAgICAgbWluID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDI7XG4gICAgICBsZXQgbWlkO1xuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVRvSW5kZXhbbWlkXSkge1xuICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID49IGxpbmVUb0luZGV4W21pZCArIDFdKSB7XG4gICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVRvSW5kZXhbbWluXSArIDEsXG4gICAgICBsaW5lOiBtaW4gKyAxXG4gICAgfTtcbiAgfVxuICBtYXBSZXNvbHZlKGZpbGUpIHtcbiAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkge1xuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlJDEkMSh0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgdGhpcy5tYXAucm9vdCB8fCBcIi5cIiwgZmlsZSk7XG4gIH1cbiAgb3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKSB7XG4gICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjb25zdW1lciA9IHRoaXMubWFwLmNvbnN1bWVyKCk7XG4gICAgbGV0IGZyb20gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHsgY29sdW1uLCBsaW5lIH0pO1xuICAgIGlmICghZnJvbS5zb3VyY2UpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdG87XG4gICAgaWYgKHR5cGVvZiBlbmRMaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0byA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBjb2x1bW46IGVuZENvbHVtbiwgbGluZTogZW5kTGluZSB9KTtcbiAgICB9XG4gICAgbGV0IGZyb21Vcmw7XG4gICAgaWYgKGlzQWJzb2x1dGUkMShmcm9tLnNvdXJjZSkpIHtcbiAgICAgIGZyb21VcmwgPSBwYXRoVG9GaWxlVVJMJDEkMShmcm9tLnNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21VcmwgPSBuZXcgVVJMKFxuICAgICAgICBmcm9tLnNvdXJjZSxcbiAgICAgICAgdGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHBhdGhUb0ZpbGVVUkwkMSQxKHRoaXMubWFwLm1hcEZpbGUpXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0MiA9IHtcbiAgICAgIGNvbHVtbjogZnJvbS5jb2x1bW4sXG4gICAgICBlbmRDb2x1bW46IHRvICYmIHRvLmNvbHVtbixcbiAgICAgIGVuZExpbmU6IHRvICYmIHRvLmxpbmUsXG4gICAgICBsaW5lOiBmcm9tLmxpbmUsXG4gICAgICB1cmw6IGZyb21VcmwudG9TdHJpbmcoKVxuICAgIH07XG4gICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIikge1xuICAgICAgaWYgKGZpbGVVUkxUb1BhdGgkMSkge1xuICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoJDEoZnJvbVVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzb3VyY2UgPSBjb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGZyb20uc291cmNlKTtcbiAgICBpZiAoc291cmNlKSByZXN1bHQyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIG9mIFtcImhhc0JPTVwiLCBcImNzc1wiLCBcImZpbGVcIiwgXCJpZFwiXSkge1xuICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICBqc29uLm1hcCA9IHsgLi4udGhpcy5tYXAgfTtcbiAgICAgIGlmIChqc29uLm1hcC5jb25zdW1lckNhY2hlKSB7XG4gICAgICAgIGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZDtcbiAgfVxufTtcbnZhciBpbnB1dCQxID0gSW5wdXQkNCQxO1xuSW5wdXQkNCQxLmRlZmF1bHQgPSBJbnB1dCQ0JDE7XG5pZiAodGVybWluYWxIaWdobGlnaHQkMiAmJiB0ZXJtaW5hbEhpZ2hsaWdodCQyLnJlZ2lzdGVySW5wdXQpIHtcbiAgdGVybWluYWxIaWdobGlnaHQkMi5yZWdpc3RlcklucHV0KElucHV0JDQkMSk7XG59XG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lcjogU291cmNlTWFwQ29uc3VtZXIkMywgU291cmNlTWFwR2VuZXJhdG9yOiBTb3VyY2VNYXBHZW5lcmF0b3IkMyB9ID0gcmVxdWlyZSQkMiQxO1xubGV0IHsgZGlybmFtZTogZGlybmFtZSQyLCByZWxhdGl2ZTogcmVsYXRpdmUkMSwgcmVzb2x2ZTogcmVzb2x2ZSQyLCBzZXA6IHNlcCQxIH0gPSByZXF1aXJlJCQyJDE7XG5sZXQgeyBwYXRoVG9GaWxlVVJMOiBwYXRoVG9GaWxlVVJMJDIgfSA9IHJlcXVpcmUkJDIkMTtcbmxldCBJbnB1dCQzJDEgPSBpbnB1dCQxO1xubGV0IHNvdXJjZU1hcEF2YWlsYWJsZSQyID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQzICYmIFNvdXJjZU1hcEdlbmVyYXRvciQzKTtcbmxldCBwYXRoQXZhaWxhYmxlJDIgPSBCb29sZWFuKGRpcm5hbWUkMiAmJiByZXNvbHZlJDIgJiYgcmVsYXRpdmUkMSAmJiBzZXAkMSk7XG5sZXQgTWFwR2VuZXJhdG9yJDIkMSA9IGNsYXNzIE1hcEdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ2lmeTIsIHJvb3QyLCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTI7XG4gICAgdGhpcy5tYXBPcHRzID0gb3B0cy5tYXAgfHwge307XG4gICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNzcyA9IGNzc1N0cmluZztcbiAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nO1xuICAgIHRoaXMudXNlc0ZpbGVVcmxzID0gIXRoaXMubWFwT3B0cy5mcm9tICYmIHRoaXMubWFwT3B0cy5hYnNvbHV0ZTtcbiAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tZW1vaXplZFVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZEFubm90YXRpb24oKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgY29udGVudCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIHRoaXMudG9CYXNlNjQodGhpcy5tYXAudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5vdXRwdXRGaWxlKCkgKyBcIi5tYXBcIjtcbiAgICB9XG4gICAgbGV0IGVvbCA9IFwiXFxuXCI7XG4gICAgaWYgKHRoaXMuY3NzLmluY2x1ZGVzKFwiXFxyXFxuXCIpKSBlb2wgPSBcIlxcclxcblwiO1xuICAgIHRoaXMuY3NzICs9IGVvbCArIFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBjb250ZW50ICsgXCIgKi9cIjtcbiAgfVxuICBhcHBseVByZXZNYXBzKCkge1xuICAgIGZvciAobGV0IHByZXYgb2YgdGhpcy5wcmV2aW91cygpKSB7XG4gICAgICBsZXQgZnJvbSA9IHRoaXMudG9VcmwodGhpcy5wYXRoKHByZXYuZmlsZSkpO1xuICAgICAgbGV0IHJvb3QyID0gcHJldi5yb290IHx8IGRpcm5hbWUkMihwcmV2LmZpbGUpO1xuICAgICAgbGV0IG1hcDtcbiAgICAgIGlmICh0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgIG1hcCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQzKHByZXYudGV4dCk7XG4gICAgICAgIGlmIChtYXAuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgIH1cbiAgfVxuICBjbGVhckFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIGxldCBub2RlMjtcbiAgICAgIGZvciAobGV0IGkyID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZTIudGV4dC5pbmRleE9mKFwiIyBzb3VyY2VNYXBwaW5nVVJMPVwiKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbio/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGUoKSB7XG4gICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICBpZiAocGF0aEF2YWlsYWJsZSQyICYmIHNvdXJjZU1hcEF2YWlsYWJsZSQyICYmIHRoaXMuaXNNYXAoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc3VsdDIgPSBcIlwiO1xuICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCAoaTIpID0+IHtcbiAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtyZXN1bHQyXTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGVNYXAoKSB7XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZVN0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLnByZXZpb3VzKClbMF0uY29uc3VtZXIoKTtcbiAgICAgIHByZXYuZmlsZSA9IHRoaXMub3V0cHV0RmlsZSgpO1xuICAgICAgdGhpcy5tYXAgPSBTb3VyY2VNYXBHZW5lcmF0b3IkMy5mcm9tU291cmNlTWFwKHByZXYsIHtcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IkMyh7XG4gICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7IGNvbHVtbjogMCwgbGluZTogMSB9LFxuICAgICAgICBvcmlnaW5hbDogeyBjb2x1bW46IDAsIGxpbmU6IDEgfSxcbiAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtcbiAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwKSB0aGlzLmFwcGx5UHJldk1hcHMoKTtcbiAgICBpZiAodGhpcy5pc0Fubm90YXRpb24oKSkgdGhpcy5hZGRBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNzc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3MsIHRoaXMubWFwXTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGVTdHJpbmcoKSB7XG4gICAgdGhpcy5jc3MgPSBcIlwiO1xuICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvciQzKHtcbiAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICB9KTtcbiAgICBsZXQgbGluZSA9IDE7XG4gICAgbGV0IGNvbHVtbiA9IDE7XG4gICAgbGV0IG5vU291cmNlID0gXCI8bm8gc291cmNlPlwiO1xuICAgIGxldCBtYXBwaW5nID0ge1xuICAgICAgZ2VuZXJhdGVkOiB7IGNvbHVtbjogMCwgbGluZTogMCB9LFxuICAgICAgb3JpZ2luYWw6IHsgY29sdW1uOiAwLCBsaW5lOiAwIH0sXG4gICAgICBzb3VyY2U6IFwiXCJcbiAgICB9O1xuICAgIGxldCBsaW5lcywgbGFzdDtcbiAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIChzdHIsIG5vZGUyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLmNzcyArPSBzdHI7XG4gICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJlbmRcIikge1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2Uuc3RhcnQpIHtcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2Uuc3RhcnQuY29sdW1uIC0gMTtcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgICAgIGlmIChsaW5lcykge1xuICAgICAgICBsaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgbGFzdCA9IHN0ci5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgY29sdW1uID0gc3RyLmxlbmd0aCAtIGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW4gKz0gc3RyLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgbGV0IHAgPSBub2RlMi5wYXJlbnQgfHwgeyByYXdzOiB7fSB9O1xuICAgICAgICBsZXQgY2hpbGRsZXNzID0gbm9kZTIudHlwZSA9PT0gXCJkZWNsXCIgfHwgbm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiAhbm9kZTIubm9kZXM7XG4gICAgICAgIGlmICghY2hpbGRsZXNzIHx8IG5vZGUyICE9PSBwLmxhc3QgfHwgcC5yYXdzLnNlbWljb2xvbikge1xuICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLmVuZCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLmVuZC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2UuZW5kLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDI7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaXNBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoKGkyKSA9PiBpMi5hbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNJbmxpbmUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmlubGluZTtcbiAgICB9XG4gICAgbGV0IGFubm90YXRpb24gPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICBpZiAodHlwZW9mIGFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgYW5ub3RhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKChpMikgPT4gaTIuaW5saW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNNYXAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm9wdHMubWFwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgaXNTb3VyY2VzQ29udGVudCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudDtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZSgoaTIpID0+IGkyLndpdGhDb250ZW50KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvdXRwdXRGaWxlKCkge1xuICAgIGlmICh0aGlzLm9wdHMudG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLnRvKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5mcm9tKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwidG8uY3NzXCI7XG4gICAgfVxuICB9XG4gIHBhdGgoZmlsZSkge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuYWJzb2x1dGUpIHJldHVybiBmaWxlO1xuICAgIGlmIChmaWxlLmNoYXJDb2RlQXQoMCkgPT09IDYwKSByZXR1cm4gZmlsZTtcbiAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkgcmV0dXJuIGZpbGU7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRQYXRocy5nZXQoZmlsZSk7XG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgZnJvbSA9IHRoaXMub3B0cy50byA/IGRpcm5hbWUkMih0aGlzLm9wdHMudG8pIDogXCIuXCI7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZnJvbSA9IGRpcm5hbWUkMihyZXNvbHZlJDIoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSByZWxhdGl2ZSQxKGZyb20sIGZpbGUpO1xuICAgIHRoaXMubWVtb2l6ZWRQYXRocy5zZXQoZmlsZSwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcHJldmlvdXMoKSB7XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290LndhbGsoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gbm9kZTIuc291cmNlLmlucHV0Lm1hcDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpbnB1dDIgPSBuZXcgSW5wdXQkMyQxKHRoaXMub3JpZ2luYWxDU1MsIHRoaXMub3B0cyk7XG4gICAgICAgIGlmIChpbnB1dDIubWFwKSB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKGlucHV0Mi5tYXApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7XG4gIH1cbiAgc2V0U291cmNlc0NvbnRlbnQoKSB7XG4gICAgbGV0IGFscmVhZHkgPSB7fTtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLnJvb3Qud2Fsaygobm9kZTIpID0+IHtcbiAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSkge1xuICAgICAgICAgIGxldCBmcm9tID0gbm9kZTIuc291cmNlLmlucHV0LmZyb207XG4gICAgICAgICAgaWYgKGZyb20gJiYgIWFscmVhZHlbZnJvbV0pIHtcbiAgICAgICAgICAgIGFscmVhZHlbZnJvbV0gPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGZyb21VcmwgPSB0aGlzLnVzZXNGaWxlVXJscyA/IHRoaXMudG9GaWxlVXJsKGZyb20pIDogdGhpcy50b1VybCh0aGlzLnBhdGgoZnJvbSkpO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlMi5zb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiO1xuICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tLCB0aGlzLmNzcyk7XG4gICAgfVxuICB9XG4gIHNvdXJjZVBhdGgobm9kZTIpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMubWFwT3B0cy5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXNlc0ZpbGVVcmxzKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0ZpbGVVcmwobm9kZTIuc291cmNlLmlucHV0LmZyb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZTIuc291cmNlLmlucHV0LmZyb20pKTtcbiAgICB9XG4gIH1cbiAgdG9CYXNlNjQoc3RyKSB7XG4gICAgaWYgKEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH1cbiAgfVxuICB0b0ZpbGVVcmwocGF0aCkge1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkRmlsZVVSTHMuZ2V0KHBhdGgpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgaWYgKHBhdGhUb0ZpbGVVUkwkMikge1xuICAgICAgbGV0IGZpbGVVUkwgPSBwYXRoVG9GaWxlVVJMJDIocGF0aCkudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5zZXQocGF0aCwgZmlsZVVSTCk7XG4gICAgICByZXR1cm4gZmlsZVVSTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImBtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0b1VybChwYXRoKSB7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgIGlmIChzZXAkMSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICAgIH1cbiAgICBsZXQgdXJsID0gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICB0aGlzLm1lbW9pemVkVVJMcy5zZXQocGF0aCwgdXJsKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG59O1xudmFyIG1hcEdlbmVyYXRvciQxID0gTWFwR2VuZXJhdG9yJDIkMTtcbmxldCBOb2RlJDIkMSA9IG5vZGUkMTtcbmxldCBDb21tZW50JDQkMSA9IGNsYXNzIENvbW1lbnQgZXh0ZW5kcyBOb2RlJDIkMSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwiY29tbWVudFwiO1xuICB9XG59O1xudmFyIGNvbW1lbnQkMSA9IENvbW1lbnQkNCQxO1xuQ29tbWVudCQ0JDEuZGVmYXVsdCA9IENvbW1lbnQkNCQxO1xubGV0IHsgaXNDbGVhbjogaXNDbGVhbiQxJDEsIG15OiBteSQxJDEgfSA9IHN5bWJvbHMkMTtcbmxldCBEZWNsYXJhdGlvbiQzJDEgPSBkZWNsYXJhdGlvbiQxO1xubGV0IENvbW1lbnQkMyQxID0gY29tbWVudCQxO1xubGV0IE5vZGUkMSQxID0gbm9kZSQxO1xubGV0IHBhcnNlJDQkMSwgUnVsZSQ0JDEsIEF0UnVsZSQ0JDEsIFJvb3QkNiQxO1xuZnVuY3Rpb24gY2xlYW5Tb3VyY2UkMShub2Rlcykge1xuICByZXR1cm4gbm9kZXMubWFwKChpMikgPT4ge1xuICAgIGlmIChpMi5ub2RlcykgaTIubm9kZXMgPSBjbGVhblNvdXJjZSQxKGkyLm5vZGVzKTtcbiAgICBkZWxldGUgaTIuc291cmNlO1xuICAgIHJldHVybiBpMjtcbiAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcCQxKG5vZGUyKSB7XG4gIG5vZGUyW2lzQ2xlYW4kMSQxXSA9IGZhbHNlO1xuICBpZiAobm9kZTIucHJveHlPZi5ub2Rlcykge1xuICAgIGZvciAobGV0IGkyIG9mIG5vZGUyLnByb3h5T2Yubm9kZXMpIHtcbiAgICAgIG1hcmtEaXJ0eVVwJDEoaTIpO1xuICAgIH1cbiAgfVxufVxubGV0IENvbnRhaW5lciQ3JDEgPSBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBOb2RlJDEkMSB7XG4gIGFwcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlMik7XG4gICAgfVxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgc3VwZXIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2YgdGhpcy5ub2Rlcykgbm9kZTIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICB9XG4gIH1cbiAgZWFjaChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgIGxldCBpdGVyYXRvciA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICBsZXQgaW5kZXgyLCByZXN1bHQyO1xuICAgIHdoaWxlICh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXgyXSwgaW5kZXgyKTtcbiAgICAgIGlmIChyZXN1bHQyID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGV2ZXJ5KGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbik7XG4gIH1cbiAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge307XG4gICAgdGhpcy5sYXN0RWFjaCArPSAxO1xuICAgIGxldCBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2g7XG4gICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA9IDA7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9XG4gIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICB9IGVsc2UgaWYgKCFub2RlMltwcm9wXSkge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImVhY2hcIiB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiAmJiBwcm9wLnN0YXJ0c1dpdGgoXCJ3YWxrXCIpKSB7XG4gICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oXG4gICAgICAgICAgICAgIC4uLmFyZ3MubWFwKChpMikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChjaGlsZCwgaW5kZXgyKSA9PiBpMihjaGlsZC50b1Byb3h5KCksIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJldmVyeVwiIHx8IHByb3AgPT09IFwic29tZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKFxuICAgICAgICAgICAgICAoY2hpbGQsIC4uLm90aGVyKSA9PiBjYihjaGlsZC50b1Byb3h5KCksIC4uLm90aGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyLm5vZGVzLm1hcCgoaTIpID0+IGkyLnRvUHJveHkoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJmaXJzdFwiIHx8IHByb3AgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcInNlbGVjdG9yXCIpIHtcbiAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGluZGV4KGNoaWxkKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNoaWxkO1xuICAgIGlmIChjaGlsZC5wcm94eU9mKSBjaGlsZCA9IGNoaWxkLnByb3h5T2Y7XG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgfVxuICBpbnNlcnRBZnRlcihleGlzdCwgYWRkKSB7XG4gICAgbGV0IGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpO1xuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZTIpO1xuICAgIGxldCBpbmRleDI7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleDIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgIGxldCBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgbGV0IHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gXCJwcmVwZW5kXCIgOiBmYWxzZTtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSwgdHlwZSkucmV2ZXJzZSgpO1xuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBmb3IgKGxldCBub2RlMiBvZiBub2RlcykgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlMik7XG4gICAgbGV0IGluZGV4MjtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICBpZiAoZXhpc3RJbmRleCA8PSBpbmRleDIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5vZGVzID0gY2xlYW5Tb3VyY2UkMShwYXJzZSQ0JDEobm9kZXMpLm5vZGVzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbm9kZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApO1xuICAgICAgZm9yIChsZXQgaTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyLCBcImlnbm9yZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUgPT09IFwicm9vdFwiICYmIHRoaXMudHlwZSAhPT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgZm9yIChsZXQgaTIgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyLCBcImlnbm9yZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUpIHtcbiAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgZmllbGQgaXMgbWlzc2VkIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBub2Rlcy52YWx1ZSA9IFN0cmluZyhub2Rlcy52YWx1ZSk7XG4gICAgICB9XG4gICAgICBub2RlcyA9IFtuZXcgRGVjbGFyYXRpb24kMyQxKG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3Rvcikge1xuICAgICAgbm9kZXMgPSBbbmV3IFJ1bGUkNCQxKG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICBub2RlcyA9IFtuZXcgQXRSdWxlJDQkMShub2RlcyldO1xuICAgIH0gZWxzZSBpZiAobm9kZXMudGV4dCkge1xuICAgICAgbm9kZXMgPSBbbmV3IENvbW1lbnQkMyQxKG5vZGVzKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgfVxuICAgIGxldCBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoKGkyKSA9PiB7XG4gICAgICBpZiAoIWkyW215JDEkMV0pIENvbnRhaW5lci5yZWJ1aWxkKGkyKTtcbiAgICAgIGkyID0gaTIucHJveHlPZjtcbiAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMik7XG4gICAgICBpZiAoaTJbaXNDbGVhbiQxJDFdKSBtYXJrRGlydHlVcCQxKGkyKTtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpMi5wYXJlbnQgPSB0aGlzLnByb3h5T2Y7XG4gICAgICByZXR1cm4gaTI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgfVxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmZpcnN0LCBcInByZXBlbmRcIikucmV2ZXJzZSgpO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy51bnNoaWZ0KG5vZGUyKTtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoKGNoaWxkKSB7XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQWxsKCkge1xuICAgIGZvciAobGV0IG5vZGUyIG9mIHRoaXMucHJveHlPZi5ub2Rlcykgbm9kZTIucGFyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlPZi5ub2RlcyA9IFtdO1xuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICBjaGlsZCA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgIHRoaXMucHJveHlPZi5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgIGxldCBpbmRleDI7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgaWYgKGluZGV4MiA+PSBjaGlsZCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLndhbGtEZWNscygoZGVjbCkgPT4ge1xuICAgICAgaWYgKG9wdHMucHJvcHMgJiYgIW9wdHMucHJvcHMuaW5jbHVkZXMoZGVjbC5wcm9wKSkgcmV0dXJuO1xuICAgICAgaWYgKG9wdHMuZmFzdCAmJiAhZGVjbC52YWx1ZS5pbmNsdWRlcyhvcHRzLmZhc3QpKSByZXR1cm47XG4gICAgICBkZWNsLnZhbHVlID0gZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc29tZShjb25kaXRpb24pO1xuICB9XG4gIHdhbGsoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGxldCByZXN1bHQyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQyICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgIHJlc3VsdDIgPSBjaGlsZC53YWxrKGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0pO1xuICB9XG4gIHdhbGtBdFJ1bGVzKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIG5hbWUudGVzdChjaGlsZC5uYW1lKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBjaGlsZC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhbGtEZWNscyhwcm9wLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gcHJvcDtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcm9wIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIHByb3AudGVzdChjaGlsZC5wcm9wKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgY2hpbGQucHJvcCA9PT0gcHJvcCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrUnVsZXMoc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBzZWxlY3Rvci50ZXN0KGNoaWxkLnNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgY2hpbGQuc2VsZWN0b3IgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmaXJzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdO1xuICB9XG4gIGdldCBsYXN0KCkge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCAtIDFdO1xuICB9XG59O1xuQ29udGFpbmVyJDckMS5yZWdpc3RlclBhcnNlID0gKGRlcGVuZGFudCkgPT4ge1xuICBwYXJzZSQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDckMS5yZWdpc3RlclJ1bGUgPSAoZGVwZW5kYW50KSA9PiB7XG4gIFJ1bGUkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJBdFJ1bGUgPSAoZGVwZW5kYW50KSA9PiB7XG4gIEF0UnVsZSQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDckMS5yZWdpc3RlclJvb3QgPSAoZGVwZW5kYW50KSA9PiB7XG4gIFJvb3QkNiQxID0gZGVwZW5kYW50O1xufTtcbnZhciBjb250YWluZXIkMSA9IENvbnRhaW5lciQ3JDE7XG5Db250YWluZXIkNyQxLmRlZmF1bHQgPSBDb250YWluZXIkNyQxO1xuQ29udGFpbmVyJDckMS5yZWJ1aWxkID0gKG5vZGUyKSA9PiB7XG4gIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBBdFJ1bGUkNCQxLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJ1bGUkNCQxLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIERlY2xhcmF0aW9uJDMkMS5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBDb21tZW50JDMkMS5wcm90b3R5cGUpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSb290JDYkMS5wcm90b3R5cGUpO1xuICB9XG4gIG5vZGUyW215JDEkMV0gPSB0cnVlO1xuICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICBub2RlMi5ub2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgQ29udGFpbmVyJDckMS5yZWJ1aWxkKGNoaWxkKTtcbiAgICB9KTtcbiAgfVxufTtcbmxldCBDb250YWluZXIkNiQxID0gY29udGFpbmVyJDE7XG5sZXQgTGF6eVJlc3VsdCQ0JDEsIFByb2Nlc3NvciQzJDE7XG5sZXQgRG9jdW1lbnQkMyQxID0gY2xhc3MgRG9jdW1lbnQyIGV4dGVuZHMgQ29udGFpbmVyJDYkMSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoeyB0eXBlOiBcImRvY3VtZW50XCIsIC4uLmRlZmF1bHRzIH0pO1xuICAgIGlmICghdGhpcy5ub2Rlcykge1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cbiAgfVxuICB0b1Jlc3VsdChvcHRzID0ge30pIHtcbiAgICBsZXQgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDQkMShuZXcgUHJvY2Vzc29yJDMkMSgpLCB0aGlzLCBvcHRzKTtcbiAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgfVxufTtcbkRvY3VtZW50JDMkMS5yZWdpc3RlckxhenlSZXN1bHQgPSAoZGVwZW5kYW50KSA9PiB7XG4gIExhenlSZXN1bHQkNCQxID0gZGVwZW5kYW50O1xufTtcbkRvY3VtZW50JDMkMS5yZWdpc3RlclByb2Nlc3NvciA9IChkZXBlbmRhbnQpID0+IHtcbiAgUHJvY2Vzc29yJDMkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgZG9jdW1lbnQkMSQxID0gRG9jdW1lbnQkMyQxO1xuRG9jdW1lbnQkMyQxLmRlZmF1bHQgPSBEb2N1bWVudCQzJDE7XG5sZXQgcHJpbnRlZCQxID0ge307XG52YXIgd2Fybk9uY2UkMiQxID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBpZiAocHJpbnRlZCQxW21lc3NhZ2VdKSByZXR1cm47XG4gIHByaW50ZWQkMVttZXNzYWdlXSA9IHRydWU7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIH1cbn07XG5sZXQgV2FybmluZyQyJDEgPSBjbGFzcyBXYXJuaW5nIHtcbiAgY29uc3RydWN0b3IodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gXCJ3YXJuaW5nXCI7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpO1xuICAgICAgdGhpcy5saW5lID0gcmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmU7XG4gICAgICB0aGlzLmVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgfVxuICAgIGZvciAobGV0IG9wdCBpbiBvcHRzKSB0aGlzW29wdF0gPSBvcHRzW29wdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgIHBsdWdpbjogdGhpcy5wbHVnaW4sXG4gICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGx1Z2luKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW4gKyBcIjogXCIgKyB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cbn07XG52YXIgd2FybmluZyQxID0gV2FybmluZyQyJDE7XG5XYXJuaW5nJDIkMS5kZWZhdWx0ID0gV2FybmluZyQyJDE7XG5sZXQgV2FybmluZyQxJDEgPSB3YXJuaW5nJDE7XG5sZXQgUmVzdWx0JDMkMSA9IGNsYXNzIFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yKHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKSB7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLnJvb3QgPSByb290MjtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuY3NzID0gdm9pZCAwO1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzcztcbiAgfVxuICB3YXJuKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGlmICghb3B0cy5wbHVnaW4pIHtcbiAgICAgIGlmICh0aGlzLmxhc3RQbHVnaW4gJiYgdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgb3B0cy5wbHVnaW4gPSB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdhcm5pbmcyID0gbmV3IFdhcm5pbmckMSQxKHRleHQsIG9wdHMpO1xuICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nMik7XG4gICAgcmV0dXJuIHdhcm5pbmcyO1xuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbHRlcigoaTIpID0+IGkyLnR5cGUgPT09IFwid2FybmluZ1wiKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbn07XG52YXIgcmVzdWx0JDEgPSBSZXN1bHQkMyQxO1xuUmVzdWx0JDMkMS5kZWZhdWx0ID0gUmVzdWx0JDMkMTtcbmNvbnN0IFNJTkdMRV9RVU9URSQxID0gXCInXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IERPVUJMRV9RVU9URSQxID0gJ1wiJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgQkFDS1NMQVNIJDEgPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgU0xBU0gkMSA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBORVdMSU5FJDEgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTUEFDRSQxID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEZFRUQkMSA9IFwiXFxmXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFRBQiQxID0gXCJcdFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDUiQxID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgT1BFTl9TUVVBUkUkMSA9IFwiW1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDTE9TRV9TUVVBUkUkMSA9IFwiXVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUEVOX1BBUkVOVEhFU0VTJDEgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfUEFSRU5USEVTRVMkMSA9IFwiKVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUEVOX0NVUkxZJDEgPSBcIntcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfQ1VSTFkkMSA9IFwifVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTRU1JQ09MT04kMSA9IFwiO1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBBU1RFUklTSyQxID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENPTE9OJDEgPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQVQkMSA9IFwiQFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBSRV9BVF9FTkQkMSA9IC9bXFx0XFxuXFxmXFxyIFwiIycoKS87W1xcXFxcXF17fV0vZztcbmNvbnN0IFJFX1dPUkRfRU5EJDEgPSAvW1xcdFxcblxcZlxcciAhXCIjJygpOjtAW1xcXFxcXF17fV18XFwvKD89XFwqKS9nO1xuY29uc3QgUkVfQkFEX0JSQUNLRVQkMSA9IC8uW1xcclxcblwiJygvXFxcXF0vO1xuY29uc3QgUkVfSEVYX0VTQ0FQRSQxID0gL1tcXGRhLWZdL2k7XG52YXIgdG9rZW5pemUkMSA9IGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dDIsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgY3NzID0gaW5wdXQyLmNzcy52YWx1ZU9mKCk7XG4gIGxldCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZUVycm9ycztcbiAgbGV0IGNvZGUsIG5leHQsIHF1b3RlLCBjb250ZW50LCBlc2NhcGU7XG4gIGxldCBlc2NhcGVkLCBlc2NhcGVQb3MsIHByZXYsIG4yLCBjdXJyZW50VG9rZW47XG4gIGxldCBsZW5ndGggPSBjc3MubGVuZ3RoO1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IGJ1ZmZlciA9IFtdO1xuICBsZXQgcmV0dXJuZWQgPSBbXTtcbiAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICBmdW5jdGlvbiB1bmNsb3NlZCh3aGF0KSB7XG4gICAgdGhyb3cgaW5wdXQyLmVycm9yKFwiVW5jbG9zZWQgXCIgKyB3aGF0LCBwb3MpO1xuICB9XG4gIGZ1bmN0aW9uIGVuZE9mRmlsZSgpIHtcbiAgICByZXR1cm4gcmV0dXJuZWQubGVuZ3RoID09PSAwICYmIHBvcyA+PSBsZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dFRva2VuKG9wdHMpIHtcbiAgICBpZiAocmV0dXJuZWQubGVuZ3RoKSByZXR1cm4gcmV0dXJuZWQucG9wKCk7XG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHJldHVybjtcbiAgICBsZXQgaWdub3JlVW5jbG9zZWQgPSBvcHRzID8gb3B0cy5pZ25vcmVVbmNsb3NlZCA6IGZhbHNlO1xuICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChwb3MpO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSBORVdMSU5FJDE6XG4gICAgICBjYXNlIFNQQUNFJDE6XG4gICAgICBjYXNlIFRBQiQxOlxuICAgICAgY2FzZSBDUiQxOlxuICAgICAgY2FzZSBGRUVEJDE6IHtcbiAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPT09IFNQQUNFJDEgfHwgY29kZSA9PT0gTkVXTElORSQxIHx8IGNvZGUgPT09IFRBQiQxIHx8IGNvZGUgPT09IENSJDEgfHwgY29kZSA9PT0gRkVFRCQxKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW1wic3BhY2VcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCldO1xuICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIE9QRU5fU1FVQVJFJDE6XG4gICAgICBjYXNlIENMT1NFX1NRVUFSRSQxOlxuICAgICAgY2FzZSBPUEVOX0NVUkxZJDE6XG4gICAgICBjYXNlIENMT1NFX0NVUkxZJDE6XG4gICAgICBjYXNlIENPTE9OJDE6XG4gICAgICBjYXNlIFNFTUlDT0xPTiQxOlxuICAgICAgY2FzZSBDTE9TRV9QQVJFTlRIRVNFUyQxOiB7XG4gICAgICAgIGxldCBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFtjb250cm9sQ2hhciwgY29udHJvbENoYXIsIHBvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBPUEVOX1BBUkVOVEhFU0VTJDE6IHtcbiAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiBcIlwiO1xuICAgICAgICBuMiA9IGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgICBpZiAocHJldiA9PT0gXCJ1cmxcIiAmJiBuMiAhPT0gU0lOR0xFX1FVT1RFJDEgJiYgbjIgIT09IERPVUJMRV9RVU9URSQxICYmIG4yICE9PSBTUEFDRSQxICYmIG4yICE9PSBORVdMSU5FJDEgJiYgbjIgIT09IFRBQiQxICYmIG4yICE9PSBGRUVEJDEgJiYgbjIgIT09IENSJDEpIHtcbiAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIJDEpIHtcbiAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJicmFja2V0c1wiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIHBvcyArIDEpO1xuICAgICAgICAgIGNvbnRlbnQgPSBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IC0xIHx8IFJFX0JBRF9CUkFDS0VUJDEudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1wiKFwiLCBcIihcIiwgcG9zXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1wiYnJhY2tldHNcIiwgY29udGVudCwgcG9zLCBuZXh0XTtcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBTSU5HTEVfUVVPVEUkMTpcbiAgICAgIGNhc2UgRE9VQkxFX1FVT1RFJDE6IHtcbiAgICAgICAgcXVvdGUgPSBjb2RlID09PSBTSU5HTEVfUVVPVEUkMSA/IFwiJ1wiIDogJ1wiJztcbiAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoXCJzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG4gICAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gkMSkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgY3VycmVudFRva2VuID0gW1wic3RyaW5nXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEFUJDE6IHtcbiAgICAgICAgUkVfQVRfRU5EJDEubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgUkVfQVRfRU5EJDEudGVzdChjc3MpO1xuICAgICAgICBpZiAoUkVfQVRfRU5EJDEubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQkMS5sYXN0SW5kZXggLSAyO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcImF0LXdvcmRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgQkFDS1NMQVNIJDE6IHtcbiAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gQkFDS1NMQVNIJDEpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpO1xuICAgICAgICBpZiAoZXNjYXBlICYmIGNvZGUgIT09IFNMQVNIJDEgJiYgY29kZSAhPT0gU1BBQ0UkMSAmJiBjb2RlICE9PSBORVdMSU5FJDEgJiYgY29kZSAhPT0gVEFCJDEgJiYgY29kZSAhPT0gQ1IkMSAmJiBjb2RlICE9PSBGRUVEJDEpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUkMS50ZXN0KGNzcy5jaGFyQXQobmV4dCkpKSB7XG4gICAgICAgICAgICB3aGlsZSAoUkVfSEVYX0VTQ0FQRSQxLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFJDEpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJ3b3JkXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmIChjb2RlID09PSBTTEFTSCQxICYmIGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpID09PSBBU1RFUklTSyQxKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgcG9zICsgMikgKyAxO1xuICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJjb21tZW50XCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJFX1dPUkRfRU5EJDEubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICBSRV9XT1JEX0VORCQxLnRlc3QoY3NzKTtcbiAgICAgICAgICBpZiAoUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCA9IFJFX1dPUkRfRU5EJDEubGFzdEluZGV4IC0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFRva2VuID0gW1wid29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgICAgYnVmZmVyLnB1c2goY3VycmVudFRva2VuKTtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3MrKztcbiAgICByZXR1cm4gY3VycmVudFRva2VuO1xuICB9XG4gIGZ1bmN0aW9uIGJhY2sodG9rZW4pIHtcbiAgICByZXR1cm5lZC5wdXNoKHRva2VuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhY2ssXG4gICAgZW5kT2ZGaWxlLFxuICAgIG5leHRUb2tlbixcbiAgICBwb3NpdGlvblxuICB9O1xufTtcbmxldCBDb250YWluZXIkNSQxID0gY29udGFpbmVyJDE7XG5sZXQgQXRSdWxlJDMkMSA9IGNsYXNzIEF0UnVsZSBleHRlbmRzIENvbnRhaW5lciQ1JDEge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICB9XG4gIGFwcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gIH1cbiAgcHJlcGVuZCguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmQoLi4uY2hpbGRyZW4pO1xuICB9XG59O1xudmFyIGF0UnVsZSQxID0gQXRSdWxlJDMkMTtcbkF0UnVsZSQzJDEuZGVmYXVsdCA9IEF0UnVsZSQzJDE7XG5Db250YWluZXIkNSQxLnJlZ2lzdGVyQXRSdWxlKEF0UnVsZSQzJDEpO1xubGV0IENvbnRhaW5lciQ0JDEgPSBjb250YWluZXIkMTtcbmxldCBMYXp5UmVzdWx0JDMkMSwgUHJvY2Vzc29yJDIkMTtcbmxldCBSb290JDUkMSA9IGNsYXNzIFJvb3QgZXh0ZW5kcyBDb250YWluZXIkNCQxIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJyb290XCI7XG4gICAgaWYgKCF0aGlzLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gIH1cbiAgbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBzdXBlci5ub3JtYWxpemUoY2hpbGQpO1xuICAgIGlmIChzYW1wbGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInByZXBlbmRcIikge1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc2FtcGxlLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICBmb3IgKGxldCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgIGlmICghaWdub3JlICYmIGluZGV4MiA9PT0gMCAmJiB0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzW2luZGV4Ml0ucmF3cy5iZWZvcmU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdCQzJDEobmV3IFByb2Nlc3NvciQyJDEoKSwgdGhpcywgb3B0cyk7XG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gIH1cbn07XG5Sb290JDUkMS5yZWdpc3RlckxhenlSZXN1bHQgPSAoZGVwZW5kYW50KSA9PiB7XG4gIExhenlSZXN1bHQkMyQxID0gZGVwZW5kYW50O1xufTtcblJvb3QkNSQxLnJlZ2lzdGVyUHJvY2Vzc29yID0gKGRlcGVuZGFudCkgPT4ge1xuICBQcm9jZXNzb3IkMiQxID0gZGVwZW5kYW50O1xufTtcbnZhciByb290JDEgPSBSb290JDUkMTtcblJvb3QkNSQxLmRlZmF1bHQgPSBSb290JDUkMTtcbkNvbnRhaW5lciQ0JDEucmVnaXN0ZXJSb290KFJvb3QkNSQxKTtcbmxldCBsaXN0JDIkMSA9IHtcbiAgY29tbWEoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGxpc3QkMiQxLnNwbGl0KHN0cmluZywgW1wiLFwiXSwgdHJ1ZSk7XG4gIH0sXG4gIHNwYWNlKHN0cmluZykge1xuICAgIGxldCBzcGFjZXMgPSBbXCIgXCIsIFwiXFxuXCIsIFwiXHRcIl07XG4gICAgcmV0dXJuIGxpc3QkMiQxLnNwbGl0KHN0cmluZywgc3BhY2VzKTtcbiAgfSxcbiAgc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgbGV0IGFycmF5ID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBcIlwiO1xuICAgIGxldCBzcGxpdCA9IGZhbHNlO1xuICAgIGxldCBmdW5jID0gMDtcbiAgICBsZXQgaW5RdW90ZSA9IGZhbHNlO1xuICAgIGxldCBwcmV2UXVvdGUgPSBcIlwiO1xuICAgIGxldCBlc2NhcGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBsZXR0ZXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGUpIHtcbiAgICAgICAgaWYgKGxldHRlciA9PT0gcHJldlF1b3RlKSB7XG4gICAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1wiJyB8fCBsZXR0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIoXCIpIHtcbiAgICAgICAgZnVuYyArPSAxO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKVwiKSB7XG4gICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxO1xuICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAwKSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3JzLmluY2x1ZGVzKGxldHRlcikpIHNwbGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgICAgIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICBzcGxpdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCArPSBsZXR0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcbnZhciBsaXN0XzEkMSA9IGxpc3QkMiQxO1xubGlzdCQyJDEuZGVmYXVsdCA9IGxpc3QkMiQxO1xubGV0IENvbnRhaW5lciQzJDEgPSBjb250YWluZXIkMTtcbmxldCBsaXN0JDEkMSA9IGxpc3RfMSQxO1xubGV0IFJ1bGUkMyQxID0gY2xhc3MgUnVsZSBleHRlbmRzIENvbnRhaW5lciQzJDEge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgfVxuICBnZXQgc2VsZWN0b3JzKCkge1xuICAgIHJldHVybiBsaXN0JDEkMS5jb21tYSh0aGlzLnNlbGVjdG9yKTtcbiAgfVxuICBzZXQgc2VsZWN0b3JzKHZhbHVlcykge1xuICAgIGxldCBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbDtcbiAgICBsZXQgc2VwMiA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIixcIiArIHRoaXMucmF3KFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcDIpO1xuICB9XG59O1xudmFyIHJ1bGUkMSA9IFJ1bGUkMyQxO1xuUnVsZSQzJDEuZGVmYXVsdCA9IFJ1bGUkMyQxO1xuQ29udGFpbmVyJDMkMS5yZWdpc3RlclJ1bGUoUnVsZSQzJDEpO1xubGV0IERlY2xhcmF0aW9uJDIkMSA9IGRlY2xhcmF0aW9uJDE7XG5sZXQgdG9rZW5pemVyMiQxID0gdG9rZW5pemUkMTtcbmxldCBDb21tZW50JDIkMSA9IGNvbW1lbnQkMTtcbmxldCBBdFJ1bGUkMiQxID0gYXRSdWxlJDE7XG5sZXQgUm9vdCQ0JDEgPSByb290JDE7XG5sZXQgUnVsZSQyJDEgPSBydWxlJDE7XG5jb25zdCBTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMSA9IHtcbiAgZW1wdHk6IHRydWUsXG4gIHNwYWNlOiB0cnVlXG59O1xuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24kMSh0b2tlbnMpIHtcbiAgZm9yIChsZXQgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgbGV0IHBvcyA9IHRva2VuWzNdIHx8IHRva2VuWzJdO1xuICAgIGlmIChwb3MpIHJldHVybiBwb3M7XG4gIH1cbn1cbmxldCBQYXJzZXIkMSQxID0gY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQyKSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0MjtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0JDEoKTtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3Q7XG4gICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKTtcbiAgICB0aGlzLnJvb3Quc291cmNlID0geyBpbnB1dDogaW5wdXQyLCBzdGFydDogeyBjb2x1bW46IDEsIGxpbmU6IDEsIG9mZnNldDogMCB9IH07XG4gIH1cbiAgYXRydWxlKHRva2VuKSB7XG4gICAgbGV0IG5vZGUyID0gbmV3IEF0UnVsZSQyJDEoKTtcbiAgICBub2RlMi5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSk7XG4gICAgaWYgKG5vZGUyLm5hbWUgPT09IFwiXCIpIHtcbiAgICAgIHRoaXMudW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pO1xuICAgIH1cbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgcHJldjtcbiAgICBsZXQgc2hpZnQ7XG4gICAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgICBsZXQgb3BlbiA9IGZhbHNlO1xuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICB3aGlsZSAoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIgJiYgYnJhY2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzaGlmdCA9IHBhcmFtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgcHJldiA9IHBhcmFtc1tzaGlmdF07XG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBwcmV2WzBdID09PSBcInNwYWNlXCIpIHtcbiAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1stLXNoaWZ0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHByZXZbM10gfHwgcHJldlsyXSk7XG4gICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICBsYXN0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHBhcmFtcyk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpO1xuICAgICAgdGhpcy5yYXcobm9kZTIsIFwicGFyYW1zXCIsIHBhcmFtcyk7XG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICB0b2tlbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzNdIHx8IHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlMi5yYXdzLmJldHdlZW47XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gXCJcIjtcbiAgICAgIG5vZGUyLnBhcmFtcyA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChvcGVuKSB7XG4gICAgICBub2RlMi5ub2RlcyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgfVxuICB9XG4gIGNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucykge1xuICAgIGxldCBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKTtcbiAgICBpZiAoY29sb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgbGV0IGZvdW5kZWQgPSAwO1xuICAgIGxldCB0b2tlbjtcbiAgICBmb3IgKGxldCBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbal07XG4gICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIikge1xuICAgICAgICBmb3VuZGVkICs9IDE7XG4gICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiTWlzc2VkIHNlbWljb2xvblwiLFxuICAgICAgdG9rZW5bMF0gPT09IFwid29yZFwiID8gdG9rZW5bM10gKyAxIDogdG9rZW5bMl1cbiAgICApO1xuICB9XG4gIGNvbG9uKHRva2Vucykge1xuICAgIGxldCBicmFja2V0cyA9IDA7XG4gICAgbGV0IHRva2VuLCB0eXBlLCBwcmV2O1xuICAgIGZvciAobGV0IFtpMiwgZWxlbWVudF0gb2YgdG9rZW5zLmVudHJpZXMoKSkge1xuICAgICAgdG9rZW4gPSBlbGVtZW50O1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwiKFwiKSB7XG4gICAgICAgIGJyYWNrZXRzICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCIpXCIpIHtcbiAgICAgICAgYnJhY2tldHMgLT0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChicmFja2V0cyA9PT0gMCAmJiB0eXBlID09PSBcIjpcIikge1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNvbG9uKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2WzBdID09PSBcIndvcmRcIiAmJiBwcmV2WzFdID09PSBcInByb2dpZFwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2ID0gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb21tZW50KHRva2VuKSB7XG4gICAgbGV0IG5vZGUyID0gbmV3IENvbW1lbnQkMiQxKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgbGV0IHRleHQgPSB0b2tlblsxXS5zbGljZSgyLCAtMik7XG4gICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgIG5vZGUyLnRleHQgPSBcIlwiO1xuICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gdGV4dDtcbiAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pO1xuICAgICAgbm9kZTIudGV4dCA9IG1hdGNoWzJdO1xuICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gbWF0Y2hbMV07XG4gICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gbWF0Y2hbM107XG4gICAgfVxuICB9XG4gIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjIkMSh0aGlzLmlucHV0KTtcbiAgfVxuICBkZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICBsZXQgbm9kZTIgPSBuZXcgRGVjbGFyYXRpb24kMiQxKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgIGxldCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFswXSA9PT0gXCI7XCIpIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgIHRva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24oXG4gICAgICBsYXN0WzNdIHx8IGxhc3RbMl0gfHwgZmluZExhc3RXaXRoUG9zaXRpb24kMSh0b2tlbnMpXG4gICAgKTtcbiAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgIHdoaWxlICh0b2tlbnNbMF1bMF0gIT09IFwid29yZFwiKSB7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIG5vZGUyLnNvdXJjZS5zdGFydCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5zWzBdWzJdKTtcbiAgICBub2RlMi5wcm9wID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGV0IHR5cGUgPSB0b2tlbnNbMF1bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCI6XCIgfHwgdHlwZSA9PT0gXCJzcGFjZVwiIHx8IHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZTIucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICB9XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICBsZXQgdG9rZW47XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodG9rZW5bMF0gPT09IFwiOlwiKSB7XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwid29yZFwiICYmIC9cXHcvLnRlc3QodG9rZW5bMV0pKSB7XG4gICAgICAgICAgdGhpcy51bmtub3duV29yZChbdG9rZW5dKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlMi5wcm9wWzBdID09PSBcIl9cIiB8fCBub2RlMi5wcm9wWzBdID09PSBcIipcIikge1xuICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gbm9kZTIucHJvcFswXTtcbiAgICAgIG5vZGUyLnByb3AgPSBub2RlMi5wcm9wLnNsaWNlKDEpO1xuICAgIH1cbiAgICBsZXQgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgZmlyc3RTcGFjZXMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgfVxuICAgIHRoaXMucHJlY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICBmb3IgKGxldCBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCIhaW1wb3J0YW50XCIpIHtcbiAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMuc3RyaW5nRnJvbSh0b2tlbnMsIGkyKTtcbiAgICAgICAgc3RyaW5nID0gdGhpcy5zcGFjZXNGcm9tRW5kKHRva2VucykgKyBzdHJpbmc7XG4gICAgICAgIGlmIChzdHJpbmcgIT09IFwiICFpbXBvcnRhbnRcIikgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSBcImltcG9ydGFudFwiKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IHRva2Vucy5zbGljZSgwKTtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGogPSBpMjsgaiA+IDA7IGotLSkge1xuICAgICAgICAgIGxldCB0eXBlID0gY2FjaGVbal1bMF07XG4gICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDAgJiYgdHlwZSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDApIHtcbiAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyO1xuICAgICAgICAgIHRva2VucyA9IGNhY2hlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIiAmJiB0b2tlblswXSAhPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNXb3JkID0gdG9rZW5zLnNvbWUoKGkyKSA9PiBpMlswXSAhPT0gXCJzcGFjZVwiICYmIGkyWzBdICE9PSBcImNvbW1lbnRcIik7XG4gICAgaWYgKGhhc1dvcmQpIHtcbiAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSBmaXJzdFNwYWNlcy5tYXAoKGkyKSA9PiBpMlsxXSkuam9pbihcIlwiKTtcbiAgICAgIGZpcnN0U3BhY2VzID0gW107XG4gICAgfVxuICAgIHRoaXMucmF3KG5vZGUyLCBcInZhbHVlXCIsIGZpcnN0U3BhY2VzLmNvbmNhdCh0b2tlbnMpLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKG5vZGUyLnZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICB9XG4gIH1cbiAgZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJEb3VibGUgY29sb25cIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG4gIGVtcHR5UnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBSdWxlJDIkMSgpO1xuICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgIG5vZGUyLnNlbGVjdG9yID0gXCJcIjtcbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICB9XG4gIGVuZCh0b2tlbikge1xuICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSk7XG4gICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudC5wYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKTtcbiAgICB9XG4gIH1cbiAgZW5kRmlsZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKCk7XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICB0aGlzLnJvb3Quc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy50b2tlbml6ZXIucG9zaXRpb24oKSk7XG4gIH1cbiAgZnJlZVNlbWljb2xvbih0b2tlbikge1xuICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMpIHtcbiAgICAgIGxldCBwcmV2ID0gdGhpcy5jdXJyZW50Lm5vZGVzW3RoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gXCJydWxlXCIgJiYgIXByZXYucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgcHJldi5yYXdzLm93blNlbWljb2xvbiA9IHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEhlbHBlcnNcbiAgZ2V0UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQuZnJvbU9mZnNldChvZmZzZXQpO1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW46IHBvcy5jb2wsXG4gICAgICBsaW5lOiBwb3MubGluZSxcbiAgICAgIG9mZnNldFxuICAgIH07XG4gIH1cbiAgaW5pdChub2RlMiwgb2Zmc2V0KSB7XG4gICAgdGhpcy5jdXJyZW50LnB1c2gobm9kZTIpO1xuICAgIG5vZGUyLnNvdXJjZSA9IHtcbiAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgc3RhcnQ6IHRoaXMuZ2V0UG9zaXRpb24ob2Zmc2V0KVxuICAgIH07XG4gICAgbm9kZTIucmF3cy5iZWZvcmUgPSB0aGlzLnNwYWNlcztcbiAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiY29tbWVudFwiKSB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICB9XG4gIG90aGVyKHN0YXJ0KSB7XG4gICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBsZXQgY29sb24gPSBmYWxzZTtcbiAgICBsZXQgYnJhY2tldCA9IG51bGw7XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgbGV0IGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aChcIi0tXCIpO1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgdG9rZW4gPSBzdGFydDtcbiAgICB3aGlsZSAodG9rZW4pIHtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgfSBlbHNlIGlmIChjdXN0b21Qcm9wZXJ0eSAmJiBjb2xvbiAmJiB0eXBlID09PSBcIntcIikge1xuICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBpZiAoY29sb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgdGhpcy5ydWxlKHRva2Vucyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICBjb2xvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIGJyYWNrZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSBlbmQgPSB0cnVlO1xuICAgIGlmIChicmFja2V0cy5sZW5ndGggPiAwKSB0aGlzLnVuY2xvc2VkQnJhY2tldChicmFja2V0KTtcbiAgICBpZiAoZW5kICYmIGNvbG9uKSB7XG4gICAgICBpZiAoIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgIGlmICh0b2tlbiAhPT0gXCJzcGFjZVwiICYmIHRva2VuICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICB9XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgbGV0IHRva2VuO1xuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgIGNhc2UgXCJzcGFjZVwiOlxuICAgICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgIHRoaXMuZnJlZVNlbWljb2xvbih0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgIHRoaXMuY29tbWVudCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhdC13b3JkXCI6XG4gICAgICAgICAgdGhpcy5hdHJ1bGUodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgIHRoaXMuZW1wdHlSdWxlKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLm90aGVyKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbmRGaWxlKCk7XG4gIH1cbiAgcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oKSB7XG4gIH1cbiAgcmF3KG5vZGUyLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgbGV0IHRva2VuLCB0eXBlO1xuICAgIGxldCBsZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbGV0IGNsZWFuID0gdHJ1ZTtcbiAgICBsZXQgbmV4dCwgcHJldjtcbiAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCJzcGFjZVwiICYmIGkyID09PSBsZW5ndGggLSAxICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBwcmV2ID0gdG9rZW5zW2kyIC0gMV0gPyB0b2tlbnNbaTIgLSAxXVswXSA6IFwiZW1wdHlcIjtcbiAgICAgICAgbmV4dCA9IHRva2Vuc1tpMiArIDFdID8gdG9rZW5zW2kyICsgMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SJDFbcHJldl0gJiYgIVNBRkVfQ09NTUVOVF9ORUlHSEJPUiQxW25leHRdKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHRva2VuWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbGVhbikge1xuICAgICAgbGV0IHJhdyA9IHRva2Vucy5yZWR1Y2UoKGFsbCwgaTIpID0+IGFsbCArIGkyWzFdLCBcIlwiKTtcbiAgICAgIG5vZGUyLnJhd3NbcHJvcF0gPSB7IHJhdywgdmFsdWUgfTtcbiAgICB9XG4gICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgfVxuICBydWxlKHRva2Vucykge1xuICAgIHRva2Vucy5wb3AoKTtcbiAgICBsZXQgbm9kZTIgPSBuZXcgUnVsZSQyJDEoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKTtcbiAgICB0aGlzLnJhdyhub2RlMiwgXCJzZWxlY3RvclwiLCB0b2tlbnMpO1xuICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICB9XG4gIHNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFRva2VuVHlwZTtcbiAgICBsZXQgc3BhY2VzID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiICYmIGxhc3RUb2tlblR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlcztcbiAgfVxuICAvLyBFcnJvcnNcbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQodG9rZW5zKSB7XG4gICAgbGV0IG5leHQ7XG4gICAgbGV0IHNwYWNlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgIHNwYWNlcyArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlcztcbiAgfVxuICBzcGFjZXNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlO1xuICAgIGxldCBzcGFjZXMgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIpIGJyZWFrO1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgIH1cbiAgICByZXR1cm4gc3BhY2VzO1xuICB9XG4gIHN0cmluZ0Zyb20odG9rZW5zLCBmcm9tKSB7XG4gICAgbGV0IHJlc3VsdDIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkyID0gZnJvbTsgaTIgPCB0b2tlbnMubGVuZ3RoOyBpMisrKSB7XG4gICAgICByZXN1bHQyICs9IHRva2Vuc1tpMl1bMV07XG4gICAgfVxuICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIHVuY2xvc2VkQmxvY2soKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuY3VycmVudC5zb3VyY2Uuc3RhcnQ7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJsb2NrXCIsIHBvcy5saW5lLCBwb3MuY29sdW1uKTtcbiAgfVxuICB1bmNsb3NlZEJyYWNrZXQoYnJhY2tldCkge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIlVuY2xvc2VkIGJyYWNrZXRcIixcbiAgICAgIHsgb2Zmc2V0OiBicmFja2V0WzJdIH0sXG4gICAgICB7IG9mZnNldDogYnJhY2tldFsyXSArIDEgfVxuICAgICk7XG4gIH1cbiAgdW5leHBlY3RlZENsb3NlKHRva2VuKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiVW5leHBlY3RlZCB9XCIsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIDEgfVxuICAgICk7XG4gIH1cbiAgdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgIFwiVW5rbm93biB3b3JkXCIsXG4gICAgICB7IG9mZnNldDogdG9rZW5zWzBdWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5zWzBdWzJdICsgdG9rZW5zWzBdWzFdLmxlbmd0aCB9XG4gICAgKTtcbiAgfVxuICB1bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIkF0LXJ1bGUgd2l0aG91dCBuYW1lXCIsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aCB9XG4gICAgKTtcbiAgfVxufTtcbnZhciBwYXJzZXIkMSA9IFBhcnNlciQxJDE7XG5sZXQgQ29udGFpbmVyJDIkMSA9IGNvbnRhaW5lciQxO1xubGV0IFBhcnNlcjIkMSA9IHBhcnNlciQxO1xubGV0IElucHV0JDIkMSA9IGlucHV0JDE7XG5mdW5jdGlvbiBwYXJzZSQzJDEoY3NzLCBvcHRzKSB7XG4gIGxldCBpbnB1dDIgPSBuZXcgSW5wdXQkMiQxKGNzcywgb3B0cyk7XG4gIGxldCBwYXJzZXIyID0gbmV3IFBhcnNlcjIkMShpbnB1dDIpO1xuICB0cnkge1xuICAgIHBhcnNlcjIucGFyc2UoKTtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoZTIubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmIG9wdHMgJiYgb3B0cy5mcm9tKSB7XG4gICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNDU1Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2NzcyBwYXJzZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU2FzcyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zYXNzIHBhcnNlclwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgTGVzcyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1sZXNzIHBhcnNlclwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGUyO1xuICB9XG4gIHJldHVybiBwYXJzZXIyLnJvb3Q7XG59XG52YXIgcGFyc2VfMSQxID0gcGFyc2UkMyQxO1xucGFyc2UkMyQxLmRlZmF1bHQgPSBwYXJzZSQzJDE7XG5Db250YWluZXIkMiQxLnJlZ2lzdGVyUGFyc2UocGFyc2UkMyQxKTtcbmxldCB7IGlzQ2xlYW46IGlzQ2xlYW4kMywgbXk6IG15JDMgfSA9IHN5bWJvbHMkMTtcbmxldCBNYXBHZW5lcmF0b3IkMSQxID0gbWFwR2VuZXJhdG9yJDE7XG5sZXQgc3RyaW5naWZ5JDIkMSA9IHN0cmluZ2lmeV8xJDE7XG5sZXQgQ29udGFpbmVyJDEkMSA9IGNvbnRhaW5lciQxO1xubGV0IERvY3VtZW50JDIkMSA9IGRvY3VtZW50JDEkMTtcbmxldCB3YXJuT25jZSQxJDEgPSB3YXJuT25jZSQyJDE7XG5sZXQgUmVzdWx0JDIkMSA9IHJlc3VsdCQxO1xubGV0IHBhcnNlJDIkMSA9IHBhcnNlXzEkMTtcbmxldCBSb290JDMkMSA9IHJvb3QkMTtcbmNvbnN0IFRZUEVfVE9fQ0xBU1NfTkFNRSQxID0ge1xuICBhdHJ1bGU6IFwiQXRSdWxlXCIsXG4gIGNvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICBkZWNsOiBcIkRlY2xhcmF0aW9uXCIsXG4gIGRvY3VtZW50OiBcIkRvY3VtZW50XCIsXG4gIHJvb3Q6IFwiUm9vdFwiLFxuICBydWxlOiBcIlJ1bGVcIlxufTtcbmNvbnN0IFBMVUdJTl9QUk9QUyQxID0ge1xuICBBdFJ1bGU6IHRydWUsXG4gIEF0UnVsZUV4aXQ6IHRydWUsXG4gIENvbW1lbnQ6IHRydWUsXG4gIENvbW1lbnRFeGl0OiB0cnVlLFxuICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgRGVjbGFyYXRpb25FeGl0OiB0cnVlLFxuICBEb2N1bWVudDogdHJ1ZSxcbiAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICBPbmNlOiB0cnVlLFxuICBPbmNlRXhpdDogdHJ1ZSxcbiAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgcHJlcGFyZTogdHJ1ZSxcbiAgUm9vdDogdHJ1ZSxcbiAgUm9vdEV4aXQ6IHRydWUsXG4gIFJ1bGU6IHRydWUsXG4gIFJ1bGVFeGl0OiB0cnVlXG59O1xuY29uc3QgTk9UX1ZJU0lUT1JTJDEgPSB7XG4gIE9uY2U6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWVcbn07XG5jb25zdCBDSElMRFJFTiQxID0gMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSQxKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyQxKG5vZGUyKSB7XG4gIGxldCBrZXkgPSBmYWxzZTtcbiAgbGV0IHR5cGUgPSBUWVBFX1RPX0NMQVNTX05BTUUkMVtub2RlMi50eXBlXTtcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAga2V5ID0gbm9kZTIucHJvcC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICBrZXkgPSBub2RlMi5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgaWYgKGtleSAmJiBub2RlMi5hcHBlbmQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgIENISUxEUkVOJDEsXG4gICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgXTtcbiAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICByZXR1cm4gW3R5cGUsIHR5cGUgKyBcIi1cIiArIGtleSwgdHlwZSArIFwiRXhpdFwiLCB0eXBlICsgXCJFeGl0LVwiICsga2V5XTtcbiAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICByZXR1cm4gW3R5cGUsIENISUxEUkVOJDEsIHR5cGUgKyBcIkV4aXRcIl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt0eXBlLCB0eXBlICsgXCJFeGl0XCJdO1xuICB9XG59XG5mdW5jdGlvbiB0b1N0YWNrJDEobm9kZTIpIHtcbiAgbGV0IGV2ZW50cztcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgIGV2ZW50cyA9IFtcIkRvY3VtZW50XCIsIENISUxEUkVOJDEsIFwiRG9jdW1lbnRFeGl0XCJdO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgZXZlbnRzID0gW1wiUm9vdFwiLCBDSElMRFJFTiQxLCBcIlJvb3RFeGl0XCJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGdldEV2ZW50cyQxKG5vZGUyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV2ZW50SW5kZXg6IDAsXG4gICAgZXZlbnRzLFxuICAgIGl0ZXJhdG9yOiAwLFxuICAgIG5vZGU6IG5vZGUyLFxuICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICB2aXNpdG9yczogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuTWFya3MkMShub2RlMikge1xuICBub2RlMltpc0NsZWFuJDNdID0gZmFsc2U7XG4gIGlmIChub2RlMi5ub2Rlcykgbm9kZTIubm9kZXMuZm9yRWFjaCgoaTIpID0+IGNsZWFuTWFya3MkMShpMikpO1xuICByZXR1cm4gbm9kZTI7XG59XG5sZXQgcG9zdGNzcyQyJDEgPSB7fTtcbmxldCBMYXp5UmVzdWx0JDIkMSA9IGNsYXNzIExhenlSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICBsZXQgcm9vdDI7XG4gICAgaWYgKHR5cGVvZiBjc3MgPT09IFwib2JqZWN0XCIgJiYgY3NzICE9PSBudWxsICYmIChjc3MudHlwZSA9PT0gXCJyb290XCIgfHwgY3NzLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHtcbiAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcyk7XG4gICAgfSBlbHNlIGlmIChjc3MgaW5zdGFuY2VvZiBMYXp5UmVzdWx0IHx8IGNzcyBpbnN0YW5jZW9mIFJlc3VsdCQyJDEpIHtcbiAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcy5yb290KTtcbiAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXAgPT09IFwidW5kZWZpbmVkXCIpIG9wdHMubWFwID0ge307XG4gICAgICAgIGlmICghb3B0cy5tYXAuaW5saW5lKSBvcHRzLm1hcC5pbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXJzZXIyID0gcGFyc2UkMiQxO1xuICAgICAgaWYgKG9wdHMuc3ludGF4KSBwYXJzZXIyID0gb3B0cy5zeW50YXgucGFyc2U7XG4gICAgICBpZiAob3B0cy5wYXJzZXIpIHBhcnNlcjIgPSBvcHRzLnBhcnNlcjtcbiAgICAgIGlmIChwYXJzZXIyLnBhcnNlKSBwYXJzZXIyID0gcGFyc2VyMi5wYXJzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJvb3QyID0gcGFyc2VyMihjc3MsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAocm9vdDIgJiYgIXJvb3QyW215JDNdKSB7XG4gICAgICAgIENvbnRhaW5lciQxJDEucmVidWlsZChyb290Mik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQyJDEocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgIHRoaXMuaGVscGVycyA9IHsgLi4ucG9zdGNzcyQyJDEsIHBvc3Rjc3M6IHBvc3Rjc3MkMiQxLCByZXN1bHQ6IHRoaXMucmVzdWx0IH07XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wcm9jZXNzb3IucGx1Z2lucy5tYXAoKHBsdWdpbjIyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLnByZXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucGx1Z2luMjIsIC4uLnBsdWdpbjIyLnByZXBhcmUodGhpcy5yZXN1bHQpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGx1Z2luMjI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgIGlmICghdGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnJ1bkFzeW5jKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gIH1cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gIH1cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICB9XG4gIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2luc1wiKTtcbiAgfVxuICBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICBsZXQgcGx1Z2luMjIgPSB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luO1xuICAgIHRyeSB7XG4gICAgICBpZiAobm9kZTIpIG5vZGUyLmFkZFRvRXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiAhZXJyb3IucGx1Z2luKSB7XG4gICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGxldCBwbHVnaW5OYW1lID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICBsZXQgcGx1Z2luVmVyID0gcGx1Z2luMjIucG9zdGNzc1ZlcnNpb247XG4gICAgICAgICAgbGV0IHJ1bnRpbWVWZXIgPSB0aGlzLnJlc3VsdC5wcm9jZXNzb3IudmVyc2lvbjtcbiAgICAgICAgICBsZXQgYTIgPSBwbHVnaW5WZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGxldCBiID0gcnVudGltZVZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgaWYgKGEyWzBdICE9PSBiWzBdIHx8IHBhcnNlSW50KGEyWzFdKSA+IHBhcnNlSW50KGJbMV0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlVua25vd24gZXJyb3IgZnJvbSBQb3N0Q1NTIHBsdWdpbi4gWW91ciBjdXJyZW50IFBvc3RDU1MgdmVyc2lvbiBpcyBcIiArIHJ1bnRpbWVWZXIgKyBcIiwgYnV0IFwiICsgcGx1Z2luTmFtZSArIFwiIHVzZXMgXCIgKyBwbHVnaW5WZXIgKyBcIi4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcHJlcGFyZVZpc2l0b3JzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgbGV0IGFkZCA9IChwbHVnaW4yMiwgdHlwZSwgY2IpID0+IHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtwbHVnaW4yMiwgY2JdKTtcbiAgICB9O1xuICAgIGZvciAobGV0IHBsdWdpbjIyIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiBwbHVnaW4yMikge1xuICAgICAgICAgIGlmICghUExVR0lOX1BST1BTJDFbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmtub3duIGV2ZW50ICR7ZXZlbnR9IGluICR7cGx1Z2luMjIucG9zdGNzc1BsdWdpbn0uIFRyeSB0byB1cGRhdGUgUG9zdENTUyAoJHt0aGlzLnByb2Nlc3Nvci52ZXJzaW9ufSBub3cpLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghTk9UX1ZJU0lUT1JTJDFbZXZlbnRdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gcGx1Z2luMjJbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkKFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgKyBcIi1cIiArIGZpbHRlci50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMltldmVudF1bZmlsdGVyXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGFzTGlzdGVuZXIgPSBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID4gMDtcbiAgfVxuICBhc3luYyBydW5Bc3luYygpIHtcbiAgICB0aGlzLnBsdWdpbiA9IDA7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGxldCBwbHVnaW4yMiA9IHRoaXMucGx1Z2luc1tpMl07XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgIHdoaWxlICghcm9vdDJbaXNDbGVhbiQzXSkge1xuICAgICAgICByb290Mltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0YWNrID0gW3RvU3RhY2skMShyb290MildO1xuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwcm9taXNlID0gdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgIGxldCBub2RlMiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICBmb3IgKGxldCBbcGx1Z2luMjIsIHZpc2l0b3JdIG9mIHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgIGxldCByb290cyA9IHJvb3QyLm5vZGVzLm1hcChcbiAgICAgICAgICAgICAgICAoc3ViUm9vdCkgPT4gdmlzaXRvcihzdWJSb290LCB0aGlzLmhlbHBlcnMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF3YWl0IHZpc2l0b3Iocm9vdDIsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCk7XG4gIH1cbiAgcnVuT25Sb290KHBsdWdpbjIyKSB7XG4gICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLk9uY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgbGV0IHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAoXG4gICAgICAgICAgICAocm9vdDIpID0+IHBsdWdpbjIyLk9uY2Uocm9vdDIsIHRoaXMuaGVscGVycylcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc1Byb21pc2UkMShyb290c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyb290cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZSh0aGlzLnJlc3VsdC5yb290LCB0aGlzLmhlbHBlcnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RyaW5naWZ5KCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IHRydWU7XG4gICAgdGhpcy5zeW5jKCk7XG4gICAgbGV0IG9wdHMgPSB0aGlzLnJlc3VsdC5vcHRzO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkkMiQxO1xuICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5O1xuICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyO1xuICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yJDEkMShzdHIsIHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0Lm9wdHMpO1xuICAgIGxldCBkYXRhID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXTtcbiAgICB0aGlzLnJlc3VsdC5tYXAgPSBkYXRhWzFdO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcGx1Z2luMjIgb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgIHdoaWxlICghcm9vdDJbaXNDbGVhbiQzXSkge1xuICAgICAgICByb290Mltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YWxrU3luYyhyb290Mik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgIGZvciAobGV0IHN1YlJvb3Qgb2Ygcm9vdDIubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMub3B0cykpIHtcbiAgICAgICAgd2Fybk9uY2UkMSQxKFxuICAgICAgICAgIFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzcztcbiAgfVxuICB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgZm9yIChsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSBvZiB2aXNpdG9ycykge1xuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgbGV0IHByb21pc2U7XG4gICAgICB0cnkge1xuICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyLnByb3h5T2YpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvbWlzZSQxKHByb21pc2UpKSB7XG4gICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2aXNpdFRpY2soc3RhY2spIHtcbiAgICBsZXQgdmlzaXQyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgbGV0IHsgbm9kZTogbm9kZTIsIHZpc2l0b3JzIH0gPSB2aXNpdDI7XG4gICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZpc2l0b3JzLmxlbmd0aCA+IDAgJiYgdmlzaXQyLnZpc2l0b3JJbmRleCA8IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgbGV0IFtwbHVnaW4yMiwgdmlzaXRvcl0gPSB2aXNpdG9yc1t2aXNpdDIudmlzaXRvckluZGV4XTtcbiAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggKz0gMTtcbiAgICAgIGlmICh2aXNpdDIudmlzaXRvckluZGV4ID09PSB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gW107XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3Iobm9kZTIudG9Qcm94eSgpLCB0aGlzLmhlbHBlcnMpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlzaXQyLml0ZXJhdG9yICE9PSAwKSB7XG4gICAgICBsZXQgaXRlcmF0b3IgPSB2aXNpdDIuaXRlcmF0b3I7XG4gICAgICBsZXQgY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgPSBub2RlMi5ub2Rlc1tub2RlMi5pbmRleGVzW2l0ZXJhdG9yXV0pIHtcbiAgICAgICAgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuJDNdKSB7XG4gICAgICAgICAgY2hpbGRbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrJDEoY2hpbGQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IDA7XG4gICAgICBkZWxldGUgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgfVxuICAgIGxldCBldmVudHMgPSB2aXNpdDIuZXZlbnRzO1xuICAgIHdoaWxlICh2aXNpdDIuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGxldCBldmVudCA9IGV2ZW50c1t2aXNpdDIuZXZlbnRJbmRleF07XG4gICAgICB2aXNpdDIuZXZlbnRJbmRleCArPSAxO1xuICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTiQxKSB7XG4gICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlMltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSBub2RlMi5nZXRJdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuICB3YWxrU3luYyhub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgIGxldCBldmVudHMgPSBnZXRFdmVudHMkMShub2RlMik7XG4gICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOJDEpIHtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgbm9kZTIuZWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbiQzXSkgdGhpcy53YWxrU3luYyhjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYgKHZpc2l0b3JzKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMi50b1Byb3h5KCkpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLndhcm5pbmdzKCk7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudDtcbiAgfVxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNzcztcbiAgfVxuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLm1hcDtcbiAgfVxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLm1lc3NhZ2VzO1xuICB9XG4gIGdldCBvcHRzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICB9XG4gIGdldCBwcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgfVxuICBnZXQgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdDtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiTGF6eVJlc3VsdFwiO1xuICB9XG59O1xuTGF6eVJlc3VsdCQyJDEucmVnaXN0ZXJQb3N0Y3NzID0gKGRlcGVuZGFudCkgPT4ge1xuICBwb3N0Y3NzJDIkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgbGF6eVJlc3VsdCQxID0gTGF6eVJlc3VsdCQyJDE7XG5MYXp5UmVzdWx0JDIkMS5kZWZhdWx0ID0gTGF6eVJlc3VsdCQyJDE7XG5Sb290JDMkMS5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyJDEpO1xuRG9jdW1lbnQkMiQxLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIkMSk7XG5sZXQgTWFwR2VuZXJhdG9yMiQxID0gbWFwR2VuZXJhdG9yJDE7XG5sZXQgc3RyaW5naWZ5JDEkMSA9IHN0cmluZ2lmeV8xJDE7XG5sZXQgd2Fybk9uY2UyJDEgPSB3YXJuT25jZSQyJDE7XG5sZXQgcGFyc2UkMSQxID0gcGFyc2VfMSQxO1xuY29uc3QgUmVzdWx0JDEkMSA9IHJlc3VsdCQxO1xubGV0IE5vV29ya1Jlc3VsdCQxJDEgPSBjbGFzcyBOb1dvcmtSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICBjc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICB0aGlzLl9jc3MgPSBjc3M7XG4gICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgdGhpcy5fbWFwID0gdm9pZCAwO1xuICAgIGxldCByb290MjtcbiAgICBsZXQgc3RyID0gc3RyaW5naWZ5JDEkMTtcbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMSQxKHRoaXMuX3Byb2Nlc3Nvciwgcm9vdDIsIHRoaXMuX29wdHMpO1xuICAgIHRoaXMucmVzdWx0LmNzcyA9IGNzcztcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucmVzdWx0LCBcInJvb3RcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yb290O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yMiQxKHN0ciwgcm9vdDIsIHRoaXMuX29wdHMsIGNzcyk7XG4gICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICBsZXQgW2dlbmVyYXRlZENTUywgZ2VuZXJhdGVkTWFwXSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgICAgaWYgKGdlbmVyYXRlZENTUykge1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1M7XG4gICAgICB9XG4gICAgICBpZiAoZ2VuZXJhdGVkTWFwKSB7XG4gICAgICAgIHRoaXMucmVzdWx0Lm1hcCA9IGdlbmVyYXRlZE1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXN1bHQuY3NzID0gbWFwLmNzcztcbiAgICB9XG4gIH1cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgfVxuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgfVxuICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gIH1cbiAgc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gIH1cbiAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMuX29wdHMpKSB7XG4gICAgICAgIHdhcm5PbmNlMiQxKFxuICAgICAgICAgIFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9jc3M7XG4gIH1cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gIH1cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICB9XG4gIGdldCBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm1hcDtcbiAgfVxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldCBvcHRzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICB9XG4gIGdldCBwcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgfVxuICBnZXQgcm9vdCgpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgfVxuICAgIGxldCByb290MjtcbiAgICBsZXQgcGFyc2VyMiA9IHBhcnNlJDEkMTtcbiAgICB0cnkge1xuICAgICAgcm9vdDIgPSBwYXJzZXIyKHRoaXMuX2NzcywgdGhpcy5fb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSByb290MjtcbiAgICAgIHJldHVybiByb290MjtcbiAgICB9XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIk5vV29ya1Jlc3VsdFwiO1xuICB9XG59O1xudmFyIG5vV29ya1Jlc3VsdCQxID0gTm9Xb3JrUmVzdWx0JDEkMTtcbk5vV29ya1Jlc3VsdCQxJDEuZGVmYXVsdCA9IE5vV29ya1Jlc3VsdCQxJDE7XG5sZXQgTm9Xb3JrUmVzdWx0MiQxID0gbm9Xb3JrUmVzdWx0JDE7XG5sZXQgTGF6eVJlc3VsdCQxJDEgPSBsYXp5UmVzdWx0JDE7XG5sZXQgRG9jdW1lbnQkMSQxID0gZG9jdW1lbnQkMSQxO1xubGV0IFJvb3QkMiQxID0gcm9vdCQxO1xubGV0IFByb2Nlc3NvciQxJDEgPSBjbGFzcyBQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zID0gW10pIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcIjguNC4zOFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpO1xuICB9XG4gIG5vcm1hbGl6ZShwbHVnaW5zKSB7XG4gICAgbGV0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpMiBvZiBwbHVnaW5zKSB7XG4gICAgICBpZiAoaTIucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICBpMiA9IGkyKCk7XG4gICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgaTIgPSBpMi5wb3N0Y3NzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KGkyLnBsdWdpbnMpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpMi5wbHVnaW5zKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIGkyLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIChpMi5wYXJzZSB8fCBpMi5zdHJpbmdpZnkpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlBvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSBvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCBpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaTIgKyBcIiBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpblwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cbiAgcHJvY2Vzcyhjc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5wbHVnaW5zLmxlbmd0aCAmJiAhb3B0cy5wYXJzZXIgJiYgIW9wdHMuc3RyaW5naWZpZXIgJiYgIW9wdHMuc3ludGF4KSB7XG4gICAgICByZXR1cm4gbmV3IE5vV29ya1Jlc3VsdDIkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IExhenlSZXN1bHQkMSQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgfVxuICB9XG4gIHVzZShwbHVnaW4yMikge1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW3BsdWdpbjIyXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIHByb2Nlc3NvciQxID0gUHJvY2Vzc29yJDEkMTtcblByb2Nlc3NvciQxJDEuZGVmYXVsdCA9IFByb2Nlc3NvciQxJDE7XG5Sb290JDIkMS5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IkMSQxKTtcbkRvY3VtZW50JDEkMS5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IkMSQxKTtcbmxldCBEZWNsYXJhdGlvbiQxJDEgPSBkZWNsYXJhdGlvbiQxO1xubGV0IFByZXZpb3VzTWFwMiQxID0gcHJldmlvdXNNYXAkMTtcbmxldCBDb21tZW50JDEkMSA9IGNvbW1lbnQkMTtcbmxldCBBdFJ1bGUkMSQxID0gYXRSdWxlJDE7XG5sZXQgSW5wdXQkMSQxID0gaW5wdXQkMTtcbmxldCBSb290JDEkMSA9IHJvb3QkMTtcbmxldCBSdWxlJDEkMSA9IHJ1bGUkMTtcbmZ1bmN0aW9uIGZyb21KU09OJDEkMShqc29uLCBpbnB1dHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcCgobjIpID0+IGZyb21KU09OJDEkMShuMikpO1xuICBsZXQgeyBpbnB1dHM6IG93bklucHV0cywgLi4uZGVmYXVsdHMgfSA9IGpzb247XG4gIGlmIChvd25JbnB1dHMpIHtcbiAgICBpbnB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dDIgb2Ygb3duSW5wdXRzKSB7XG4gICAgICBsZXQgaW5wdXRIeWRyYXRlZCA9IHsgLi4uaW5wdXQyLCBfX3Byb3RvX186IElucHV0JDEkMS5wcm90b3R5cGUgfTtcbiAgICAgIGlmIChpbnB1dEh5ZHJhdGVkLm1hcCkge1xuICAgICAgICBpbnB1dEh5ZHJhdGVkLm1hcCA9IHtcbiAgICAgICAgICAuLi5pbnB1dEh5ZHJhdGVkLm1hcCxcbiAgICAgICAgICBfX3Byb3RvX186IFByZXZpb3VzTWFwMiQxLnByb3RvdHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZCk7XG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy5ub2Rlcykge1xuICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAoKG4yKSA9PiBmcm9tSlNPTiQxJDEobjIsIGlucHV0cykpO1xuICB9XG4gIGlmIChkZWZhdWx0cy5zb3VyY2UpIHtcbiAgICBsZXQgeyBpbnB1dElkLCAuLi5zb3VyY2UgfSA9IGRlZmF1bHRzLnNvdXJjZTtcbiAgICBkZWZhdWx0cy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgaWYgKGlucHV0SWQgIT0gbnVsbCkge1xuICAgICAgZGVmYXVsdHMuc291cmNlLmlucHV0ID0gaW5wdXRzW2lucHV0SWRdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICByZXR1cm4gbmV3IFJvb3QkMSQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImRlY2xcIikge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24kMSQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgIHJldHVybiBuZXcgUnVsZSQxJDEoZGVmYXVsdHMpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50JDEkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgIHJldHVybiBuZXcgQXRSdWxlJDEkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsganNvbi50eXBlKTtcbiAgfVxufVxudmFyIGZyb21KU09OXzEkMSA9IGZyb21KU09OJDEkMTtcbmZyb21KU09OJDEkMS5kZWZhdWx0ID0gZnJvbUpTT04kMSQxO1xubGV0IENzc1N5bnRheEVycm9yMiQxID0gY3NzU3ludGF4RXJyb3IkMTtcbmxldCBEZWNsYXJhdGlvbjIkMSA9IGRlY2xhcmF0aW9uJDE7XG5sZXQgTGF6eVJlc3VsdDIkMSA9IGxhenlSZXN1bHQkMTtcbmxldCBDb250YWluZXIyJDEgPSBjb250YWluZXIkMTtcbmxldCBQcm9jZXNzb3IyJDEgPSBwcm9jZXNzb3IkMTtcbmxldCBzdHJpbmdpZnkkNSA9IHN0cmluZ2lmeV8xJDE7XG5sZXQgZnJvbUpTT04kMiA9IGZyb21KU09OXzEkMTtcbmxldCBEb2N1bWVudDIyID0gZG9jdW1lbnQkMSQxO1xubGV0IFdhcm5pbmcyJDEgPSB3YXJuaW5nJDE7XG5sZXQgQ29tbWVudDIkMSA9IGNvbW1lbnQkMTtcbmxldCBBdFJ1bGUyJDEgPSBhdFJ1bGUkMTtcbmxldCBSZXN1bHQyJDEgPSByZXN1bHQkMTtcbmxldCBJbnB1dDIkMSA9IGlucHV0JDE7XG5sZXQgcGFyc2UkNSA9IHBhcnNlXzEkMTtcbmxldCBsaXN0JDMgPSBsaXN0XzEkMTtcbmxldCBSdWxlMiQxID0gcnVsZSQxO1xubGV0IFJvb3QyJDEgPSByb290JDE7XG5sZXQgTm9kZTIkMSA9IG5vZGUkMTtcbmZ1bmN0aW9uIHBvc3Rjc3MkMyguLi5wbHVnaW5zKSB7XG4gIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IyJDEocGx1Z2lucyk7XG59XG5wb3N0Y3NzJDMucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKG5hbWUsIGluaXRpYWxpemVyKSB7XG4gIGxldCB3YXJuaW5nUHJpbnRlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIG5hbWUgKyBcIjogcG9zdGNzcy5wbHVnaW4gd2FzIGRlcHJlY2F0ZWQuIE1pZ3JhdGlvbiBndWlkZTpcXG5odHRwczovL2V2aWxtYXJ0aWFucy5jb20vY2hyb25pY2xlcy9wb3N0Y3NzLTgtcGx1Z2luLW1pZ3JhdGlvblwiXG4gICAgICApO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKFwiY25cIikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIG5hbWUgKyBcIjog6YeM6Z2iIHBvc3Rjc3MucGx1Z2luIOiiq+W8g+eUqC4g6L+B56e75oyH5Y2XOlxcbmh0dHBzOi8vd3d3LnczY3RlY2guY29tL3RvcGljLzIyMjZcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdHJhbnNmb3JtZXIgPSBpbml0aWFsaXplciguLi5hcmdzKTtcbiAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzUGx1Z2luID0gbmFtZTtcbiAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbiA9IG5ldyBQcm9jZXNzb3IyJDEoKS52ZXJzaW9uO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgfVxuICBsZXQgY2FjaGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSk7XG4gIGNyZWF0b3IucHJvY2VzcyA9IGZ1bmN0aW9uKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICByZXR1cm4gcG9zdGNzcyQzKFtjcmVhdG9yKHBsdWdpbk9wdHMpXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKTtcbiAgfTtcbiAgcmV0dXJuIGNyZWF0b3I7XG59O1xucG9zdGNzcyQzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeSQ1O1xucG9zdGNzcyQzLnBhcnNlID0gcGFyc2UkNTtcbnBvc3Rjc3MkMy5mcm9tSlNPTiA9IGZyb21KU09OJDI7XG5wb3N0Y3NzJDMubGlzdCA9IGxpc3QkMztcbnBvc3Rjc3MkMy5jb21tZW50ID0gKGRlZmF1bHRzKSA9PiBuZXcgQ29tbWVudDIkMShkZWZhdWx0cyk7XG5wb3N0Y3NzJDMuYXRSdWxlID0gKGRlZmF1bHRzKSA9PiBuZXcgQXRSdWxlMiQxKGRlZmF1bHRzKTtcbnBvc3Rjc3MkMy5kZWNsID0gKGRlZmF1bHRzKSA9PiBuZXcgRGVjbGFyYXRpb24yJDEoZGVmYXVsdHMpO1xucG9zdGNzcyQzLnJ1bGUgPSAoZGVmYXVsdHMpID0+IG5ldyBSdWxlMiQxKGRlZmF1bHRzKTtcbnBvc3Rjc3MkMy5yb290ID0gKGRlZmF1bHRzKSA9PiBuZXcgUm9vdDIkMShkZWZhdWx0cyk7XG5wb3N0Y3NzJDMuZG9jdW1lbnQgPSAoZGVmYXVsdHMpID0+IG5ldyBEb2N1bWVudDIyKGRlZmF1bHRzKTtcbnBvc3Rjc3MkMy5Dc3NTeW50YXhFcnJvciA9IENzc1N5bnRheEVycm9yMiQxO1xucG9zdGNzcyQzLkRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24yJDE7XG5wb3N0Y3NzJDMuQ29udGFpbmVyID0gQ29udGFpbmVyMiQxO1xucG9zdGNzcyQzLlByb2Nlc3NvciA9IFByb2Nlc3NvcjIkMTtcbnBvc3Rjc3MkMy5Eb2N1bWVudCA9IERvY3VtZW50MjI7XG5wb3N0Y3NzJDMuQ29tbWVudCA9IENvbW1lbnQyJDE7XG5wb3N0Y3NzJDMuV2FybmluZyA9IFdhcm5pbmcyJDE7XG5wb3N0Y3NzJDMuQXRSdWxlID0gQXRSdWxlMiQxO1xucG9zdGNzcyQzLlJlc3VsdCA9IFJlc3VsdDIkMTtcbnBvc3Rjc3MkMy5JbnB1dCA9IElucHV0MiQxO1xucG9zdGNzcyQzLlJ1bGUgPSBSdWxlMiQxO1xucG9zdGNzcyQzLlJvb3QgPSBSb290MiQxO1xucG9zdGNzcyQzLk5vZGUgPSBOb2RlMiQxO1xuTGF6eVJlc3VsdDIkMS5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcyQzKTtcbnZhciBwb3N0Y3NzXzEkMSA9IHBvc3Rjc3MkMztcbnBvc3Rjc3MkMy5kZWZhdWx0ID0gcG9zdGNzcyQzO1xuY29uc3QgcG9zdGNzcyQxJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMShwb3N0Y3NzXzEkMSk7XG5wb3N0Y3NzJDEkMS5zdHJpbmdpZnk7XG5wb3N0Y3NzJDEkMS5mcm9tSlNPTjtcbnBvc3Rjc3MkMSQxLnBsdWdpbjtcbnBvc3Rjc3MkMSQxLnBhcnNlO1xucG9zdGNzcyQxJDEubGlzdDtcbnBvc3Rjc3MkMSQxLmRvY3VtZW50O1xucG9zdGNzcyQxJDEuY29tbWVudDtcbnBvc3Rjc3MkMSQxLmF0UnVsZTtcbnBvc3Rjc3MkMSQxLnJ1bGU7XG5wb3N0Y3NzJDEkMS5kZWNsO1xucG9zdGNzcyQxJDEucm9vdDtcbnBvc3Rjc3MkMSQxLkNzc1N5bnRheEVycm9yO1xucG9zdGNzcyQxJDEuRGVjbGFyYXRpb247XG5wb3N0Y3NzJDEkMS5Db250YWluZXI7XG5wb3N0Y3NzJDEkMS5Qcm9jZXNzb3I7XG5wb3N0Y3NzJDEkMS5Eb2N1bWVudDtcbnBvc3Rjc3MkMSQxLkNvbW1lbnQ7XG5wb3N0Y3NzJDEkMS5XYXJuaW5nO1xucG9zdGNzcyQxJDEuQXRSdWxlO1xucG9zdGNzcyQxJDEuUmVzdWx0O1xucG9zdGNzcyQxJDEuSW5wdXQ7XG5wb3N0Y3NzJDEkMS5SdWxlO1xucG9zdGNzcyQxJDEuUm9vdDtcbnBvc3Rjc3MkMSQxLk5vZGU7XG52YXIgX19kZWZQcm9wMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcDIob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wMihvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh4Mikge1xuICByZXR1cm4geDIgJiYgeDIuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiZGVmYXVsdFwiKSA/IHgyW1wiZGVmYXVsdFwiXSA6IHgyO1xufVxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4yKSB7XG4gIGlmIChuMi5fX2VzTW9kdWxlKSByZXR1cm4gbjI7XG4gIHZhciBmMiA9IG4yLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZjIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGEyID0gZnVuY3Rpb24gYTIyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBhMjIpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYyLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBhMi5wcm90b3R5cGUgPSBmMi5wcm90b3R5cGU7XG4gIH0gZWxzZSBhMiA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3Qua2V5cyhuMikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4yLCBrKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbjJba107XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYTI7XG59XG52YXIgcGljb2NvbG9yc19icm93c2VyID0geyBleHBvcnRzOiB7fSB9O1xudmFyIHggPSBTdHJpbmc7XG52YXIgY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IGlzQ29sb3JTdXBwb3J0ZWQ6IGZhbHNlLCByZXNldDogeCwgYm9sZDogeCwgZGltOiB4LCBpdGFsaWM6IHgsIHVuZGVybGluZTogeCwgaW52ZXJzZTogeCwgaGlkZGVuOiB4LCBzdHJpa2V0aHJvdWdoOiB4LCBibGFjazogeCwgcmVkOiB4LCBncmVlbjogeCwgeWVsbG93OiB4LCBibHVlOiB4LCBtYWdlbnRhOiB4LCBjeWFuOiB4LCB3aGl0ZTogeCwgZ3JheTogeCwgYmdCbGFjazogeCwgYmdSZWQ6IHgsIGJnR3JlZW46IHgsIGJnWWVsbG93OiB4LCBiZ0JsdWU6IHgsIGJnTWFnZW50YTogeCwgYmdDeWFuOiB4LCBiZ1doaXRlOiB4IH07XG59O1xucGljb2NvbG9yc19icm93c2VyLmV4cG9ydHMgPSBjcmVhdGUoKTtcbnBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzLmNyZWF0ZUNvbG9ycyA9IGNyZWF0ZTtcbnZhciBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzID0gcGljb2NvbG9yc19icm93c2VyLmV4cG9ydHM7XG5jb25zdCBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwgPSB7fTtcbmNvbnN0IF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdDogX192aXRlQnJvd3NlckV4dGVybmFsXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuY29uc3QgcmVxdWlyZSQkMiA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UoX192aXRlQnJvd3NlckV4dGVybmFsJDEpO1xubGV0IHBpY28gPSBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzO1xubGV0IHRlcm1pbmFsSGlnaGxpZ2h0JDEgPSByZXF1aXJlJCQyO1xubGV0IENzc1N5bnRheEVycm9yJDMgPSBjbGFzcyBDc3NTeW50YXhFcnJvcjIgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4yMikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiQ3NzU3ludGF4RXJyb3JcIjtcbiAgICB0aGlzLnJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgfVxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAocGx1Z2luMjIpIHtcbiAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luMjI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29sdW1uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgIHRoaXMuY29sdW1uID0gbGluZS5jb2x1bW47XG4gICAgICAgIHRoaXMuZW5kTGluZSA9IGNvbHVtbi5saW5lO1xuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0TWVzc2FnZSgpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3NzU3ludGF4RXJyb3IyKTtcbiAgICB9XG4gIH1cbiAgc2V0TWVzc2FnZSgpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBsdWdpbiA/IHRoaXMucGx1Z2luICsgXCI6IFwiIDogXCJcIjtcbiAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogXCI8Y3NzIGlucHV0PlwiO1xuICAgIGlmICh0eXBlb2YgdGhpcy5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6XCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sdW1uO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6IFwiICsgdGhpcy5yZWFzb247XG4gIH1cbiAgc2hvd1NvdXJjZUNvZGUoY29sb3IpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm4gXCJcIjtcbiAgICBsZXQgY3NzID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gcGljby5pc0NvbG9yU3VwcG9ydGVkO1xuICAgIGlmICh0ZXJtaW5hbEhpZ2hsaWdodCQxKSB7XG4gICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0JDEoY3NzKTtcbiAgICB9XG4gICAgbGV0IGxpbmVzID0gY3NzLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgodGhpcy5saW5lIC0gMywgMCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMubGluZSArIDIsIGxpbmVzLmxlbmd0aCk7XG4gICAgbGV0IG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoO1xuICAgIGxldCBtYXJrLCBhc2lkZTtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGxldCB7IGJvbGQsIGdyYXksIHJlZCB9ID0gcGljby5jcmVhdGVDb2xvcnModHJ1ZSk7XG4gICAgICBtYXJrID0gKHRleHQpID0+IGJvbGQocmVkKHRleHQpKTtcbiAgICAgIGFzaWRlID0gKHRleHQpID0+IGdyYXkodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmsgPSBhc2lkZSA9IChzdHIpID0+IHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcCgobGluZSwgaW5kZXgyKSA9PiB7XG4gICAgICBsZXQgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXgyO1xuICAgICAgbGV0IGd1dHRlciA9IFwiIFwiICsgKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgXCIgfCBcIjtcbiAgICAgIGlmIChudW1iZXIgPT09IHRoaXMubGluZSkge1xuICAgICAgICBsZXQgc3BhY2luZyA9IGFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSArIGxpbmUuc2xpY2UoMCwgdGhpcy5jb2x1bW4gLSAxKS5yZXBsYWNlKC9bXlxcdF0vZywgXCIgXCIpO1xuICAgICAgICByZXR1cm4gbWFyayhcIj5cIikgKyBhc2lkZShndXR0ZXIpICsgbGluZSArIFwiXFxuIFwiICsgc3BhY2luZyArIG1hcmsoXCJeXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiIFwiICsgYXNpZGUoZ3V0dGVyKSArIGxpbmU7XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgY29kZSA9IHRoaXMuc2hvd1NvdXJjZUNvZGUoKTtcbiAgICBpZiAoY29kZSkge1xuICAgICAgY29kZSA9IFwiXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIGNvZGU7XG4gIH1cbn07XG52YXIgY3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvciQzO1xuQ3NzU3ludGF4RXJyb3IkMy5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3IkMztcbnZhciBzeW1ib2xzID0ge307XG5zeW1ib2xzLmlzQ2xlYW4gPSBTeW1ib2woXCJpc0NsZWFuXCIpO1xuc3ltYm9scy5teSA9IFN5bWJvbChcIm15XCIpO1xuY29uc3QgREVGQVVMVF9SQVcgPSB7XG4gIGFmdGVyOiBcIlxcblwiLFxuICBiZWZvcmVDbG9zZTogXCJcXG5cIixcbiAgYmVmb3JlQ29tbWVudDogXCJcXG5cIixcbiAgYmVmb3JlRGVjbDogXCJcXG5cIixcbiAgYmVmb3JlT3BlbjogXCIgXCIsXG4gIGJlZm9yZVJ1bGU6IFwiXFxuXCIsXG4gIGNvbG9uOiBcIjogXCIsXG4gIGNvbW1lbnRMZWZ0OiBcIiBcIixcbiAgY29tbWVudFJpZ2h0OiBcIiBcIixcbiAgZW1wdHlCb2R5OiBcIlwiLFxuICBpbmRlbnQ6IFwiICAgIFwiLFxuICBzZW1pY29sb246IGZhbHNlXG59O1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxubGV0IFN0cmluZ2lmaWVyJDIgPSBjbGFzcyBTdHJpbmdpZmllcjIge1xuICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgfVxuICBhdHJ1bGUobm9kZTIsIHNlbWljb2xvbikge1xuICAgIGxldCBuYW1lID0gXCJAXCIgKyBub2RlMi5uYW1lO1xuICAgIGxldCBwYXJhbXMgPSBub2RlMi5wYXJhbXMgPyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInBhcmFtc1wiKSA6IFwiXCI7XG4gICAgaWYgKHR5cGVvZiBub2RlMi5yYXdzLmFmdGVyTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbmFtZSArPSBub2RlMi5yYXdzLmFmdGVyTmFtZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgbmFtZSArPSBcIiBcIjtcbiAgICB9XG4gICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICB0aGlzLmJsb2NrKG5vZGUyLCBuYW1lICsgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVuZCA9IChub2RlMi5yYXdzLmJldHdlZW4gfHwgXCJcIikgKyAoc2VtaWNvbG9uID8gXCI7XCIgOiBcIlwiKTtcbiAgICAgIHRoaXMuYnVpbGRlcihuYW1lICsgcGFyYW1zICsgZW5kLCBub2RlMik7XG4gICAgfVxuICB9XG4gIGJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDb21tZW50XCIpO1xuICAgIH0gZWxzZSBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ2xvc2VcIik7XG4gICAgfVxuICAgIGxldCBidWYgPSBub2RlMi5wYXJlbnQ7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICB3aGlsZSAoYnVmICYmIGJ1Zi50eXBlICE9PSBcInJvb3RcIikge1xuICAgICAgZGVwdGggKz0gMTtcbiAgICAgIGJ1ZiA9IGJ1Zi5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgbGV0IGluZGVudCA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImluZGVudFwiKTtcbiAgICAgIGlmIChpbmRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKykgdmFsdWUgKz0gaW5kZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgYmxvY2sobm9kZTIsIHN0YXJ0KSB7XG4gICAgbGV0IGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICB0aGlzLmJ1aWxkZXIoc3RhcnQgKyBiZXR3ZWVuICsgXCJ7XCIsIG5vZGUyLCBcInN0YXJ0XCIpO1xuICAgIGxldCBhZnRlcjtcbiAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiLCBcImVtcHR5Qm9keVwiKTtcbiAgICB9XG4gICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpO1xuICAgIHRoaXMuYnVpbGRlcihcIn1cIiwgbm9kZTIsIFwiZW5kXCIpO1xuICB9XG4gIGJvZHkobm9kZTIpIHtcbiAgICBsZXQgbGFzdCA9IG5vZGUyLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxhc3QgPiAwKSB7XG4gICAgICBpZiAobm9kZTIubm9kZXNbbGFzdF0udHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgbGFzdCAtPSAxO1xuICAgIH1cbiAgICBsZXQgc2VtaWNvbG9uID0gdGhpcy5yYXcobm9kZTIsIFwic2VtaWNvbG9uXCIpO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBub2RlMi5ub2Rlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGxldCBjaGlsZCA9IG5vZGUyLm5vZGVzW2kyXTtcbiAgICAgIGxldCBiZWZvcmUgPSB0aGlzLnJhdyhjaGlsZCwgXCJiZWZvcmVcIik7XG4gICAgICBpZiAoYmVmb3JlKSB0aGlzLmJ1aWxkZXIoYmVmb3JlKTtcbiAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpMiB8fCBzZW1pY29sb24pO1xuICAgIH1cbiAgfVxuICBjb21tZW50KG5vZGUyKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJhdyhub2RlMiwgXCJsZWZ0XCIsIFwiY29tbWVudExlZnRcIik7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yYXcobm9kZTIsIFwicmlnaHRcIiwgXCJjb21tZW50UmlnaHRcIik7XG4gICAgdGhpcy5idWlsZGVyKFwiLypcIiArIGxlZnQgKyBub2RlMi50ZXh0ICsgcmlnaHQgKyBcIiovXCIsIG5vZGUyKTtcbiAgfVxuICBkZWNsKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICBsZXQgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJjb2xvblwiKTtcbiAgICBsZXQgc3RyaW5nID0gbm9kZTIucHJvcCArIGJldHdlZW4gKyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInZhbHVlXCIpO1xuICAgIGlmIChub2RlMi5pbXBvcnRhbnQpIHtcbiAgICAgIHN0cmluZyArPSBub2RlMi5yYXdzLmltcG9ydGFudCB8fCBcIiAhaW1wb3J0YW50XCI7XG4gICAgfVxuICAgIGlmIChzZW1pY29sb24pIHN0cmluZyArPSBcIjtcIjtcbiAgICB0aGlzLmJ1aWxkZXIoc3RyaW5nLCBub2RlMik7XG4gIH1cbiAgZG9jdW1lbnQobm9kZTIpIHtcbiAgICB0aGlzLmJvZHkobm9kZTIpO1xuICB9XG4gIHJhdyhub2RlMiwgb3duLCBkZXRlY3QpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93bjtcbiAgICBpZiAob3duKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUyLnJhd3Nbb3duXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IG5vZGUyLnBhcmVudDtcbiAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgcGFyZW50LmZpcnN0ID09PSBub2RlMikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybiBERUZBVUxUX1JBV1tkZXRlY3RdO1xuICAgIGxldCByb290MiA9IG5vZGUyLnJvb3QoKTtcbiAgICBpZiAoIXJvb3QyLnJhd0NhY2hlKSByb290Mi5yYXdDYWNoZSA9IHt9O1xuICAgIGlmICh0eXBlb2Ygcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHJvb3QyLnJhd0NhY2hlW2RldGVjdF07XG4gICAgfVxuICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIgfHwgZGV0ZWN0ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWV0aG9kID0gXCJyYXdcIiArIGNhcGl0YWxpemUoZGV0ZWN0KTtcbiAgICAgIGlmICh0aGlzW21ldGhvZF0pIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzW21ldGhvZF0ocm9vdDIsIG5vZGUyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBpMi5yYXdzW293bl07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikgdmFsdWUgPSBERUZBVUxUX1JBV1tkZXRlY3RdO1xuICAgIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlQ2xvc2Uocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5hZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlQ29tbWVudChyb290Miwgbm9kZTIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2Fsa0NvbW1lbnRzKChpMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0JlZm9yZURlY2wocm9vdDIsIG5vZGUyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtEZWNscygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdCZWZvcmVPcGVuKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIudHlwZSAhPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW47XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3QmVmb3JlUnVsZShyb290Mikge1xuICAgIGxldCB2YWx1ZTtcbiAgICByb290Mi53YWxrKChpMikgPT4ge1xuICAgICAgaWYgKGkyLm5vZGVzICYmIChpMi5wYXJlbnQgIT09IHJvb3QyIHx8IHJvb3QyLmZpcnN0ICE9PSBpMikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd0NvbG9uKHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGtEZWNscygoaTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZXR3ZWVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgXCJcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmF3RW1wdHlCb2R5KHJvb3QyKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHJvb3QyLndhbGsoKGkyKSA9PiB7XG4gICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdJbmRlbnQocm9vdDIpIHtcbiAgICBpZiAocm9vdDIucmF3cy5pbmRlbnQpIHJldHVybiByb290Mi5yYXdzLmluZGVudDtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGxldCBwID0gaTIucGFyZW50O1xuICAgICAgaWYgKHAgJiYgcCAhPT0gcm9vdDIgJiYgcC5wYXJlbnQgJiYgcC5wYXJlbnQgPT09IHJvb3QyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSBpMi5yYXdzLmJlZm9yZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByYXdTZW1pY29sb24ocm9vdDIpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgcm9vdDIud2FsaygoaTIpID0+IHtcbiAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggJiYgaTIubGFzdC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICB2YWx1ZSA9IGkyLnJhd3Muc2VtaWNvbG9uO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJhd1ZhbHVlKG5vZGUyLCBwcm9wKSB7XG4gICAgbGV0IHZhbHVlID0gbm9kZTJbcHJvcF07XG4gICAgbGV0IHJhdyA9IG5vZGUyLnJhd3NbcHJvcF07XG4gICAgaWYgKHJhdyAmJiByYXcudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmF3LnJhdztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJvb3Qobm9kZTIpIHtcbiAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgIGlmIChub2RlMi5yYXdzLmFmdGVyKSB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5hZnRlcik7XG4gIH1cbiAgcnVsZShub2RlMikge1xuICAgIHRoaXMuYmxvY2sobm9kZTIsIHRoaXMucmF3VmFsdWUobm9kZTIsIFwic2VsZWN0b3JcIikpO1xuICAgIGlmIChub2RlMi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uLCBub2RlMiwgXCJlbmRcIik7XG4gICAgfVxuICB9XG4gIHN0cmluZ2lmeShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgaWYgKCF0aGlzW25vZGUyLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biBBU1Qgbm9kZSB0eXBlIFwiICsgbm9kZTIudHlwZSArIFwiLiBNYXliZSB5b3UgbmVlZCB0byBjaGFuZ2UgUG9zdENTUyBzdHJpbmdpZmllci5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpc1tub2RlMi50eXBlXShub2RlMiwgc2VtaWNvbG9uKTtcbiAgfVxufTtcbnZhciBzdHJpbmdpZmllciA9IFN0cmluZ2lmaWVyJDI7XG5TdHJpbmdpZmllciQyLmRlZmF1bHQgPSBTdHJpbmdpZmllciQyO1xubGV0IFN0cmluZ2lmaWVyJDEgPSBzdHJpbmdpZmllcjtcbmZ1bmN0aW9uIHN0cmluZ2lmeSQ0KG5vZGUyLCBidWlsZGVyKSB7XG4gIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIkMShidWlsZGVyKTtcbiAgc3RyLnN0cmluZ2lmeShub2RlMik7XG59XG52YXIgc3RyaW5naWZ5XzEgPSBzdHJpbmdpZnkkNDtcbnN0cmluZ2lmeSQ0LmRlZmF1bHQgPSBzdHJpbmdpZnkkNDtcbmxldCB7IGlzQ2xlYW46IGlzQ2xlYW4kMiwgbXk6IG15JDIgfSA9IHN5bWJvbHM7XG5sZXQgQ3NzU3ludGF4RXJyb3IkMiA9IGNzc1N5bnRheEVycm9yO1xubGV0IFN0cmluZ2lmaWVyMjIgPSBzdHJpbmdpZmllcjtcbmxldCBzdHJpbmdpZnkkMyA9IHN0cmluZ2lmeV8xO1xuZnVuY3Rpb24gY2xvbmVOb2RlKG9iaiwgcGFyZW50KSB7XG4gIGxldCBjbG9uZWQgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG4gIGZvciAobGV0IGkyIGluIG9iaikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkyID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgbGV0IHZhbHVlID0gb2JqW2kyXTtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAoaTIgPT09IFwicGFyZW50XCIgJiYgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHBhcmVudCkgY2xvbmVkW2kyXSA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKGkyID09PSBcInNvdXJjZVwiKSB7XG4gICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlLm1hcCgoaikgPT4gY2xvbmVOb2RlKGosIGNsb25lZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkgdmFsdWUgPSBjbG9uZU5vZGUodmFsdWUpO1xuICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxubGV0IE5vZGUkNCA9IGNsYXNzIE5vZGUzIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMgPSB7fSkge1xuICAgIHRoaXMucmF3cyA9IHt9O1xuICAgIHRoaXNbaXNDbGVhbiQyXSA9IGZhbHNlO1xuICAgIHRoaXNbbXkkMl0gPSB0cnVlO1xuICAgIGZvciAobGV0IG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChuYW1lID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBub2RlMiBvZiBkZWZhdWx0c1tuYW1lXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZTIuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIuY2xvbmUoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWRkVG9FcnJvcihlcnJvcikge1xuICAgIGVycm9yLnBvc3Rjc3NOb2RlID0gdGhpcztcbiAgICBpZiAoZXJyb3Iuc3RhY2sgJiYgdGhpcy5zb3VyY2UgJiYgL1xcblxcc3s0fWF0IC8udGVzdChlcnJvci5zdGFjaykpIHtcbiAgICAgIGxldCBzMiA9IHRoaXMuc291cmNlO1xuICAgICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKFxuICAgICAgICAvXFxuXFxzezR9YXQgLyxcbiAgICAgICAgYCQmJHtzMi5pbnB1dC5mcm9tfToke3MyLnN0YXJ0LmxpbmV9OiR7czIuc3RhcnQuY29sdW1ufSQmYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGFmdGVyKGFkZCkge1xuICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGFkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXNzaWduKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJlZm9yZShhZGQpIHtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgYWRkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICBkZWxldGUgdGhpcy5yYXdzLmJlZm9yZTtcbiAgICBkZWxldGUgdGhpcy5yYXdzLmFmdGVyO1xuICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlbjtcbiAgfVxuICBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcyk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBjbG9uZUFmdGVyKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBjbG9uZWQpO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgY2xvbmVCZWZvcmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBjbG9uZWQpO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgZXJyb3IobWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICBsZXQgeyBlbmQsIHN0YXJ0IH0gPSB0aGlzLnJhbmdlQnkob3B0cyk7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHsgY29sdW1uOiBzdGFydC5jb2x1bW4sIGxpbmU6IHN0YXJ0LmxpbmUgfSxcbiAgICAgICAgeyBjb2x1bW46IGVuZC5jb2x1bW4sIGxpbmU6IGVuZC5saW5lIH0sXG4gICAgICAgIG9wdHNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3NzU3ludGF4RXJyb3IkMihtZXNzYWdlKTtcbiAgfVxuICBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGlmIChwcm9wID09PSBcInByb3BcIiB8fCBwcm9wID09PSBcInZhbHVlXCIgfHwgcHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcImltcG9ydGFudFwiIHx8IC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHByb3AgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBtYXJrRGlydHkoKSB7XG4gICAgaWYgKHRoaXNbaXNDbGVhbiQyXSkge1xuICAgICAgdGhpc1tpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICBsZXQgbmV4dCA9IHRoaXM7XG4gICAgICB3aGlsZSAobmV4dCA9IG5leHQucGFyZW50KSB7XG4gICAgICAgIG5leHRbaXNDbGVhbiQyXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgKyAxXTtcbiAgfVxuICBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0O1xuICAgIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMud29yZCkge1xuICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgcG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgIGxldCBzdHJpbmcgPSBzdHJpbmdSZXByZXNlbnRhdGlvbiB8fCB0aGlzLnRvU3RyaW5nKCk7XG4gICAgbGV0IGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbjtcbiAgICBsZXQgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGluZGV4MjsgaTIrKykge1xuICAgICAgaWYgKHN0cmluZ1tpMl0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgbGluZSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSB9O1xuICB9XG4gIHByZXYoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICBsZXQgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiAtIDFdO1xuICB9XG4gIHJhbmdlQnkob3B0cykge1xuICAgIGxldCBzdGFydCA9IHtcbiAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uLFxuICAgICAgbGluZTogdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuICAgIH07XG4gICAgbGV0IGVuZCA9IHRoaXMuc291cmNlLmVuZCA/IHtcbiAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiArIDEsXG4gICAgICBsaW5lOiB0aGlzLnNvdXJjZS5lbmQubGluZVxuICAgIH0gOiB7XG4gICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsXG4gICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgfTtcbiAgICBpZiAob3B0cy53b3JkKSB7XG4gICAgICBsZXQgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4MiArIG9wdHMud29yZC5sZW5ndGgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdHMuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICBsaW5lOiBvcHRzLnN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5lbmQpIHtcbiAgICAgICAgZW5kID0ge1xuICAgICAgICAgIGNvbHVtbjogb3B0cy5lbmQuY29sdW1uLFxuICAgICAgICAgIGxpbmU6IG9wdHMuZW5kLmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZW5kSW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmVuZEluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZC5saW5lIDwgc3RhcnQubGluZSB8fCBlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbikge1xuICAgICAgZW5kID0geyBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsIGxpbmU6IHN0YXJ0LmxpbmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5kLCBzdGFydCB9O1xuICB9XG4gIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIyMigpO1xuICAgIHJldHVybiBzdHIucmF3KHRoaXMsIHByb3AsIGRlZmF1bHRUeXBlKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZVdpdGgoLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGxldCBib29rbWFyayA9IHRoaXM7XG4gICAgICBsZXQgZm91bmRTZWxmID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZTIgPT09IHRoaXMpIHtcbiAgICAgICAgICBmb3VuZFNlbGYgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kU2VsZikge1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgYm9va21hcmsgPSBub2RlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm9vdCgpIHtcbiAgICBsZXQgcmVzdWx0MiA9IHRoaXM7XG4gICAgd2hpbGUgKHJlc3VsdDIucGFyZW50ICYmIHJlc3VsdDIucGFyZW50LnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgcmVzdWx0MiA9IHJlc3VsdDIucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB0b0pTT04oXywgaW5wdXRzKSB7XG4gICAgbGV0IGZpeGVkID0ge307XG4gICAgbGV0IGVtaXRJbnB1dHMgPSBpbnB1dHMgPT0gbnVsbDtcbiAgICBpbnB1dHMgPSBpbnB1dHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgaW5wdXRzTmV4dEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwicGFyZW50XCIgfHwgbmFtZSA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgbGV0IHZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLm1hcCgoaTIpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIGkyLnRvSlNPTikge1xuICAgICAgICAgICAgcmV0dXJuIGkyLnRvSlNPTihudWxsLCBpbnB1dHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLnRvSlNPTihudWxsLCBpbnB1dHMpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgIGxldCBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dCk7XG4gICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICBpbnB1dElkID0gaW5wdXRzTmV4dEluZGV4O1xuICAgICAgICAgIGlucHV0cy5zZXQodmFsdWUuaW5wdXQsIGlucHV0c05leHRJbmRleCk7XG4gICAgICAgICAgaW5wdXRzTmV4dEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZml4ZWRbbmFtZV0gPSB7XG4gICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXG4gICAgICAgICAgaW5wdXRJZCxcbiAgICAgICAgICBzdGFydDogdmFsdWUuc3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbWl0SW5wdXRzKSB7XG4gICAgICBmaXhlZC5pbnB1dHMgPSBbLi4uaW5wdXRzLmtleXMoKV0ubWFwKChpbnB1dDIpID0+IGlucHV0Mi50b0pTT04oKSk7XG4gICAgfVxuICAgIHJldHVybiBmaXhlZDtcbiAgfVxuICB0b1Byb3h5KCkge1xuICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJveHlDYWNoZTtcbiAgfVxuICB0b1N0cmluZyhzdHJpbmdpZmllcjIgPSBzdHJpbmdpZnkkMykge1xuICAgIGlmIChzdHJpbmdpZmllcjIuc3RyaW5naWZ5KSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZmllcjIuc3RyaW5naWZ5O1xuICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICBzdHJpbmdpZmllcjIodGhpcywgKGkyKSA9PiB7XG4gICAgICByZXN1bHQyICs9IGkyO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIHdhcm4ocmVzdWx0MiwgdGV4dCwgb3B0cykge1xuICAgIGxldCBkYXRhID0geyBub2RlOiB0aGlzIH07XG4gICAgZm9yIChsZXQgaTIgaW4gb3B0cykgZGF0YVtpMl0gPSBvcHRzW2kyXTtcbiAgICByZXR1cm4gcmVzdWx0Mi53YXJuKHRleHQsIGRhdGEpO1xuICB9XG4gIGdldCBwcm94eU9mKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vZGUgPSBOb2RlJDQ7XG5Ob2RlJDQuZGVmYXVsdCA9IE5vZGUkNDtcbmxldCBOb2RlJDMgPSBub2RlO1xubGV0IERlY2xhcmF0aW9uJDQgPSBjbGFzcyBEZWNsYXJhdGlvbjIgZXh0ZW5kcyBOb2RlJDMge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIGlmIChkZWZhdWx0cyAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZWZhdWx0cyA9IHsgLi4uZGVmYXVsdHMsIHZhbHVlOiBTdHJpbmcoZGVmYXVsdHMudmFsdWUpIH07XG4gICAgfVxuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImRlY2xcIjtcbiAgfVxuICBnZXQgdmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5zdGFydHNXaXRoKFwiLS1cIikgfHwgdGhpcy5wcm9wWzBdID09PSBcIiRcIjtcbiAgfVxufTtcbnZhciBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uJDQ7XG5EZWNsYXJhdGlvbiQ0LmRlZmF1bHQgPSBEZWNsYXJhdGlvbiQ0O1xubGV0IHVybEFscGhhYmV0ID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCI7XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGxldCBpMiA9IHNpemU7XG4gICAgd2hpbGUgKGkyLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGggfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xuICB9O1xufTtcbmxldCBuYW5vaWQkMSA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkyID0gc2l6ZTtcbiAgd2hpbGUgKGkyLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xudmFyIG5vblNlY3VyZSA9IHsgbmFub2lkOiBuYW5vaWQkMSwgY3VzdG9tQWxwaGFiZXQgfTtcbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lciQyLCBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvciQyIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgZGlybmFtZTogZGlybmFtZSQxLCBqb2luIH0gPSByZXF1aXJlJCQyO1xuZnVuY3Rpb24gZnJvbUJhc2U2NChzdHIpIHtcbiAgaWYgKEJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cik7XG4gIH1cbn1cbmxldCBQcmV2aW91c01hcCQyID0gY2xhc3MgUHJldmlvdXNNYXAyIHtcbiAgY29uc3RydWN0b3IoY3NzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMubWFwID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKTtcbiAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgXCJkYXRhOlwiKTtcbiAgICBsZXQgcHJldiA9IG9wdHMubWFwID8gb3B0cy5tYXAucHJldiA6IHZvaWQgMDtcbiAgICBsZXQgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpO1xuICAgIGlmICghdGhpcy5tYXBGaWxlICYmIG9wdHMuZnJvbSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gb3B0cy5mcm9tO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXBGaWxlKSB0aGlzLnJvb3QgPSBkaXJuYW1lJDEodGhpcy5tYXBGaWxlKTtcbiAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBjb25zdW1lcigpIHtcbiAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDIodGhpcy50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc3VtZXJDYWNoZTtcbiAgfVxuICBkZWNvZGVJbmxpbmUodGV4dCkge1xuICAgIGxldCBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87XG4gICAgbGV0IGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvO1xuICAgIGxldCBjaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/OCwvO1xuICAgIGxldCB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC87XG4gICAgaWYgKGNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCB1cmkudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgIH1cbiAgICBpZiAoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCBiYXNlVXJpLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVybiBmcm9tQmFzZTY0KHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7XG4gICAgfVxuICAgIGxldCBlbmNvZGluZyA9IHRleHQubWF0Y2goL2RhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXixdKyksLylbMV07XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyBcIiArIGVuY29kaW5nKTtcbiAgfVxuICBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZykge1xuICAgIHJldHVybiBzb3VyY2VNYXBTdHJpbmcucmVwbGFjZSgvXlxcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9LywgXCJcIikudHJpbSgpO1xuICB9XG4gIGlzTWFwKG1hcCkge1xuICAgIGlmICh0eXBlb2YgbWFwICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHR5cGVvZiBtYXAubWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShtYXAuc2VjdGlvbnMpO1xuICB9XG4gIGxvYWRBbm5vdGF0aW9uKGNzcykge1xuICAgIGxldCBjb21tZW50cyA9IGNzcy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vZ20pO1xuICAgIGlmICghY29tbWVudHMpIHJldHVybjtcbiAgICBsZXQgc3RhcnQgPSBjc3MubGFzdEluZGV4T2YoY29tbWVudHMucG9wKCkpO1xuICAgIGxldCBlbmQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHN0YXJ0KTtcbiAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uVVJMKGNzcy5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgIH1cbiAgfVxuICBsb2FkRmlsZShwYXRoKSB7XG4gICAgdGhpcy5yb290ID0gZGlybmFtZSQxKHBhdGgpO1xuICAgIGlmIChleGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICB0aGlzLm1hcEZpbGUgPSBwYXRoO1xuICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyhwYXRoLCBcInV0Zi04XCIpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgIH1cbiAgfVxuICBsb2FkTWFwKGZpbGUsIHByZXYpIHtcbiAgICBpZiAocHJldiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxldCBwcmV2UGF0aCA9IHByZXYoZmlsZSk7XG4gICAgICAgIGlmIChwcmV2UGF0aCkge1xuICAgICAgICAgIGxldCBtYXAgPSB0aGlzLmxvYWRGaWxlKHByZXZQYXRoKTtcbiAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIlVuYWJsZSB0byBsb2FkIHByZXZpb3VzIHNvdXJjZSBtYXA6IFwiICsgcHJldlBhdGgudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgU291cmNlTWFwQ29uc3VtZXIkMikge1xuICAgICAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yJDIuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgU291cmNlTWFwR2VuZXJhdG9yJDIpIHtcbiAgICAgICAgcmV0dXJuIHByZXYudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hcChwcmV2KSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogXCIgKyBwcmV2LnRvU3RyaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbikge1xuICAgICAgbGV0IG1hcCA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgIGlmIChmaWxlKSBtYXAgPSBqb2luKGRpcm5hbWUkMShmaWxlKSwgbWFwKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRGaWxlKG1hcCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0V2l0aChzdHJpbmcsIHN0YXJ0KSB7XG4gICAgaWYgKCFzdHJpbmcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcbiAgfVxuICB3aXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKTtcbiAgfVxufTtcbnZhciBwcmV2aW91c01hcCA9IFByZXZpb3VzTWFwJDI7XG5QcmV2aW91c01hcCQyLmRlZmF1bHQgPSBQcmV2aW91c01hcCQyO1xubGV0IHsgU291cmNlTWFwQ29uc3VtZXI6IFNvdXJjZU1hcENvbnN1bWVyJDEsIFNvdXJjZU1hcEdlbmVyYXRvcjogU291cmNlTWFwR2VuZXJhdG9yJDEgfSA9IHJlcXVpcmUkJDI7XG5sZXQgeyBmaWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMOiBwYXRoVG9GaWxlVVJMJDEgfSA9IHJlcXVpcmUkJDI7XG5sZXQgeyBpc0Fic29sdXRlLCByZXNvbHZlOiByZXNvbHZlJDEgfSA9IHJlcXVpcmUkJDI7XG5sZXQgeyBuYW5vaWQgfSA9IG5vblNlY3VyZTtcbmxldCB0ZXJtaW5hbEhpZ2hsaWdodCA9IHJlcXVpcmUkJDI7XG5sZXQgQ3NzU3ludGF4RXJyb3IkMSA9IGNzc1N5bnRheEVycm9yO1xubGV0IFByZXZpb3VzTWFwJDEgPSBwcmV2aW91c01hcDtcbmxldCBmcm9tT2Zmc2V0Q2FjaGUgPSBTeW1ib2woXCJmcm9tT2Zmc2V0Q2FjaGVcIik7XG5sZXQgc291cmNlTWFwQXZhaWxhYmxlJDEgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyJDEgJiYgU291cmNlTWFwR2VuZXJhdG9yJDEpO1xubGV0IHBhdGhBdmFpbGFibGUkMSA9IEJvb2xlYW4ocmVzb2x2ZSQxICYmIGlzQWJzb2x1dGUpO1xubGV0IElucHV0JDQgPSBjbGFzcyBJbnB1dDIge1xuICBjb25zdHJ1Y3Rvcihjc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmIChjc3MgPT09IG51bGwgfHwgdHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgY3NzID09PSBcIm9iamVjdFwiICYmICFjc3MudG9TdHJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zdENTUyByZWNlaXZlZCAke2Nzc30gaW5zdGVhZCBvZiBDU1Mgc3RyaW5nYCk7XG4gICAgfVxuICAgIHRoaXMuY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuY3NzWzBdID09PSBcIlxcdUZFRkZcIiB8fCB0aGlzLmNzc1swXSA9PT0gXCLvv75cIikge1xuICAgICAgdGhpcy5oYXNCT00gPSB0cnVlO1xuICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYXNCT00gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuZnJvbSkge1xuICAgICAgaWYgKCFwYXRoQXZhaWxhYmxlJDEgfHwgL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IGlzQWJzb2x1dGUob3B0cy5mcm9tKSkge1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHRzLmZyb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbGUgPSByZXNvbHZlJDEob3B0cy5mcm9tKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGhBdmFpbGFibGUkMSAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMSkge1xuICAgICAgbGV0IG1hcCA9IG5ldyBQcmV2aW91c01hcCQxKHRoaXMuY3NzLCBvcHRzKTtcbiAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgbGV0IGZpbGUgPSBtYXAuY29uc3VtZXIoKS5maWxlO1xuICAgICAgICBpZiAoIXRoaXMuZmlsZSAmJiBmaWxlKSB0aGlzLmZpbGUgPSB0aGlzLm1hcFJlc29sdmUoZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5maWxlKSB7XG4gICAgICB0aGlzLmlkID0gXCI8aW5wdXQgY3NzIFwiICsgbmFub2lkKDYpICsgXCI+XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbTtcbiAgfVxuICBlcnJvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIG9wdHMgPSB7fSkge1xuICAgIGxldCByZXN1bHQyLCBlbmRMaW5lLCBlbmRDb2x1bW47XG4gICAgaWYgKGxpbmUgJiYgdHlwZW9mIGxpbmUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGxldCBzdGFydCA9IGxpbmU7XG4gICAgICBsZXQgZW5kID0gY29sdW1uO1xuICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZnJvbU9mZnNldChzdGFydC5vZmZzZXQpO1xuICAgICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lID0gc3RhcnQubGluZTtcbiAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldCk7XG4gICAgICAgIGVuZExpbmUgPSBwb3MubGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gcG9zLmNvbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZExpbmUgPSBlbmQubGluZTtcbiAgICAgICAgZW5kQ29sdW1uID0gZW5kLmNvbHVtbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFjb2x1bW4pIHtcbiAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQobGluZSk7XG4gICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICBjb2x1bW4gPSBwb3MuY29sO1xuICAgIH1cbiAgICBsZXQgb3JpZ2luID0gdGhpcy5vcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pO1xuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMShcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5saW5lIDogeyBjb2x1bW46IG9yaWdpbi5jb2x1bW4sIGxpbmU6IG9yaWdpbi5saW5lIH0sXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4uY29sdW1uIDogeyBjb2x1bW46IG9yaWdpbi5lbmRDb2x1bW4sIGxpbmU6IG9yaWdpbi5lbmRMaW5lIH0sXG4gICAgICAgIG9yaWdpbi5zb3VyY2UsXG4gICAgICAgIG9yaWdpbi5maWxlLFxuICAgICAgICBvcHRzLnBsdWdpblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlbmRMaW5lID09PSB2b2lkIDAgPyBsaW5lIDogeyBjb2x1bW4sIGxpbmUgfSxcbiAgICAgICAgZW5kTGluZSA9PT0gdm9pZCAwID8gY29sdW1uIDogeyBjb2x1bW46IGVuZENvbHVtbiwgbGluZTogZW5kTGluZSB9LFxuICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgdGhpcy5maWxlLFxuICAgICAgICBvcHRzLnBsdWdpblxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzdWx0Mi5pbnB1dCA9IHsgY29sdW1uLCBlbmRDb2x1bW4sIGVuZExpbmUsIGxpbmUsIHNvdXJjZTogdGhpcy5jc3MgfTtcbiAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICBpZiAocGF0aFRvRmlsZVVSTCQxKSB7XG4gICAgICAgIHJlc3VsdDIuaW5wdXQudXJsID0gcGF0aFRvRmlsZVVSTCQxKHRoaXMuZmlsZSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdDIuaW5wdXQuZmlsZSA9IHRoaXMuZmlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgZnJvbU9mZnNldChvZmZzZXQpIHtcbiAgICBsZXQgbGFzdExpbmUsIGxpbmVUb0luZGV4O1xuICAgIGlmICghdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdKSB7XG4gICAgICBsZXQgbGluZXMgPSB0aGlzLmNzcy5zcGxpdChcIlxcblwiKTtcbiAgICAgIGxpbmVUb0luZGV4ID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICBsZXQgcHJldkluZGV4ID0gMDtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgbDIgPSBsaW5lcy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspIHtcbiAgICAgICAgbGluZVRvSW5kZXhbaTJdID0gcHJldkluZGV4O1xuICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaTJdLmxlbmd0aCArIDE7XG4gICAgICB9XG4gICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZV0gPSBsaW5lVG9JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZV07XG4gICAgfVxuICAgIGxhc3RMaW5lID0gbGluZVRvSW5kZXhbbGluZVRvSW5kZXgubGVuZ3RoIC0gMV07XG4gICAgbGV0IG1pbiA9IDA7XG4gICAgaWYgKG9mZnNldCA+PSBsYXN0TGluZSkge1xuICAgICAgbWluID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDI7XG4gICAgICBsZXQgbWlkO1xuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVRvSW5kZXhbbWlkXSkge1xuICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID49IGxpbmVUb0luZGV4W21pZCArIDFdKSB7XG4gICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVRvSW5kZXhbbWluXSArIDEsXG4gICAgICBsaW5lOiBtaW4gKyAxXG4gICAgfTtcbiAgfVxuICBtYXBSZXNvbHZlKGZpbGUpIHtcbiAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkge1xuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlJDEodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHRoaXMubWFwLnJvb3QgfHwgXCIuXCIsIGZpbGUpO1xuICB9XG4gIG9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICAgIGlmICghdGhpcy5tYXApIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpO1xuICAgIGxldCBmcm9tID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbiwgbGluZSB9KTtcbiAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRvO1xuICAgIGlmICh0eXBlb2YgZW5kTGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdG8gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHsgY29sdW1uOiBlbmRDb2x1bW4sIGxpbmU6IGVuZExpbmUgfSk7XG4gICAgfVxuICAgIGxldCBmcm9tVXJsO1xuICAgIGlmIChpc0Fic29sdXRlKGZyb20uc291cmNlKSkge1xuICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwkMShmcm9tLnNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21VcmwgPSBuZXcgVVJMKFxuICAgICAgICBmcm9tLnNvdXJjZSxcbiAgICAgICAgdGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLm1hcC5tYXBGaWxlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDIgPSB7XG4gICAgICBjb2x1bW46IGZyb20uY29sdW1uLFxuICAgICAgZW5kQ29sdW1uOiB0byAmJiB0by5jb2x1bW4sXG4gICAgICBlbmRMaW5lOiB0byAmJiB0by5saW5lLFxuICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgdXJsOiBmcm9tVXJsLnRvU3RyaW5nKClcbiAgICB9O1xuICAgIGlmIChmcm9tVXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgIGlmIChmaWxlVVJMVG9QYXRoKSB7XG4gICAgICAgIHJlc3VsdDIuZmlsZSA9IGZpbGVVUkxUb1BhdGgoZnJvbVVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzb3VyY2UgPSBjb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGZyb20uc291cmNlKTtcbiAgICBpZiAoc291cmNlKSByZXN1bHQyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIG9mIFtcImhhc0JPTVwiLCBcImNzc1wiLCBcImZpbGVcIiwgXCJpZFwiXSkge1xuICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICBqc29uLm1hcCA9IHsgLi4udGhpcy5tYXAgfTtcbiAgICAgIGlmIChqc29uLm1hcC5jb25zdW1lckNhY2hlKSB7XG4gICAgICAgIGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZDtcbiAgfVxufTtcbnZhciBpbnB1dCA9IElucHV0JDQ7XG5JbnB1dCQ0LmRlZmF1bHQgPSBJbnB1dCQ0O1xuaWYgKHRlcm1pbmFsSGlnaGxpZ2h0ICYmIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQpIHtcbiAgdGVybWluYWxIaWdobGlnaHQucmVnaXN0ZXJJbnB1dChJbnB1dCQ0KTtcbn1cbmxldCB7IFNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IgfSA9IHJlcXVpcmUkJDI7XG5sZXQgeyBkaXJuYW1lLCByZWxhdGl2ZSwgcmVzb2x2ZSwgc2VwIH0gPSByZXF1aXJlJCQyO1xubGV0IHsgcGF0aFRvRmlsZVVSTCB9ID0gcmVxdWlyZSQkMjtcbmxldCBJbnB1dCQzID0gaW5wdXQ7XG5sZXQgc291cmNlTWFwQXZhaWxhYmxlID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciAmJiBTb3VyY2VNYXBHZW5lcmF0b3IpO1xubGV0IHBhdGhBdmFpbGFibGUgPSBCb29sZWFuKGRpcm5hbWUgJiYgcmVzb2x2ZSAmJiByZWxhdGl2ZSAmJiBzZXApO1xubGV0IE1hcEdlbmVyYXRvciQyID0gY2xhc3MgTWFwR2VuZXJhdG9yMiB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ2lmeTIsIHJvb3QyLCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTI7XG4gICAgdGhpcy5tYXBPcHRzID0gb3B0cy5tYXAgfHwge307XG4gICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNzcyA9IGNzc1N0cmluZztcbiAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nO1xuICAgIHRoaXMudXNlc0ZpbGVVcmxzID0gIXRoaXMubWFwT3B0cy5mcm9tICYmIHRoaXMubWFwT3B0cy5hYnNvbHV0ZTtcbiAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tZW1vaXplZFVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZEFubm90YXRpb24oKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgY29udGVudCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIHRoaXMudG9CYXNlNjQodGhpcy5tYXAudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5vdXRwdXRGaWxlKCkgKyBcIi5tYXBcIjtcbiAgICB9XG4gICAgbGV0IGVvbCA9IFwiXFxuXCI7XG4gICAgaWYgKHRoaXMuY3NzLmluY2x1ZGVzKFwiXFxyXFxuXCIpKSBlb2wgPSBcIlxcclxcblwiO1xuICAgIHRoaXMuY3NzICs9IGVvbCArIFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBjb250ZW50ICsgXCIgKi9cIjtcbiAgfVxuICBhcHBseVByZXZNYXBzKCkge1xuICAgIGZvciAobGV0IHByZXYgb2YgdGhpcy5wcmV2aW91cygpKSB7XG4gICAgICBsZXQgZnJvbSA9IHRoaXMudG9VcmwodGhpcy5wYXRoKHByZXYuZmlsZSkpO1xuICAgICAgbGV0IHJvb3QyID0gcHJldi5yb290IHx8IGRpcm5hbWUocHJldi5maWxlKTtcbiAgICAgIGxldCBtYXA7XG4gICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICBtYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIocHJldi50ZXh0KTtcbiAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcCA9IHByZXYuY29uc3VtZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZnJvbSwgdGhpcy50b1VybCh0aGlzLnBhdGgocm9vdDIpKSk7XG4gICAgfVxuICB9XG4gIGNsZWFyQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgbGV0IG5vZGUyO1xuICAgICAgZm9yIChsZXQgaTIgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICBub2RlMiA9IHRoaXMucm9vdC5ub2Rlc1tpMl07XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgY29udGludWU7XG4gICAgICAgIGlmIChub2RlMi50ZXh0LmluZGV4T2YoXCIjIHNvdXJjZU1hcHBpbmdVUkw9XCIpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvXFxuKj9cXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sIFwiXCIpO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgIGlmIChwYXRoQXZhaWxhYmxlICYmIHNvdXJjZU1hcEF2YWlsYWJsZSAmJiB0aGlzLmlzTWFwKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgKGkyKSA9PiB7XG4gICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbcmVzdWx0Ml07XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlTWFwKCkge1xuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVTdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxldCBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKCk7XG4gICAgICBwcmV2LmZpbGUgPSB0aGlzLm91dHB1dEZpbGUoKTtcbiAgICAgIHRoaXMubWFwID0gU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAocHJldiwge1xuICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7IGNvbHVtbjogMCwgbGluZTogMSB9LFxuICAgICAgICBvcmlnaW5hbDogeyBjb2x1bW46IDAsIGxpbmU6IDEgfSxcbiAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtcbiAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwKSB0aGlzLmFwcGx5UHJldk1hcHMoKTtcbiAgICBpZiAodGhpcy5pc0Fubm90YXRpb24oKSkgdGhpcy5hZGRBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNzc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3MsIHRoaXMubWFwXTtcbiAgICB9XG4gIH1cbiAgZ2VuZXJhdGVTdHJpbmcoKSB7XG4gICAgdGhpcy5jc3MgPSBcIlwiO1xuICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgbGV0IGxpbmUgPSAxO1xuICAgIGxldCBjb2x1bW4gPSAxO1xuICAgIGxldCBub1NvdXJjZSA9IFwiPG5vIHNvdXJjZT5cIjtcbiAgICBsZXQgbWFwcGluZyA9IHtcbiAgICAgIGdlbmVyYXRlZDogeyBjb2x1bW46IDAsIGxpbmU6IDAgfSxcbiAgICAgIG9yaWdpbmFsOiB7IGNvbHVtbjogMCwgbGluZTogMCB9LFxuICAgICAgc291cmNlOiBcIlwiXG4gICAgfTtcbiAgICBsZXQgbGluZXMsIGxhc3Q7XG4gICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCAoc3RyLCBub2RlMiwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5jc3MgKz0gc3RyO1xuICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwiZW5kXCIpIHtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLnN0YXJ0KSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XG4gICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgbGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGxhc3QgPSBzdHIubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIGNvbHVtbiA9IHN0ci5sZW5ndGggLSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJzdGFydFwiKSB7XG4gICAgICAgIGxldCBwID0gbm9kZTIucGFyZW50IHx8IHsgcmF3czoge30gfTtcbiAgICAgICAgbGV0IGNoaWxkbGVzcyA9IG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgIW5vZGUyLm5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkbGVzcyB8fCBub2RlMiAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5lbmQubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLmVuZC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAyO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlzQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKChpMikgPT4gaTIuYW5ub3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmU7XG4gICAgfVxuICAgIGxldCBhbm5vdGF0aW9uID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGFubm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZSgoaTIpID0+IGkyLmlubGluZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzTWFwKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuICEhdGhpcy5vcHRzLm1hcDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoKGkyKSA9PiBpMi53aXRoQ29udGVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb3V0cHV0RmlsZSgpIHtcbiAgICBpZiAodGhpcy5vcHRzLnRvKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy50byk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInRvLmNzc1wiO1xuICAgIH1cbiAgfVxuICBwYXRoKGZpbGUpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmFic29sdXRlKSByZXR1cm4gZmlsZTtcbiAgICBpZiAoZmlsZS5jaGFyQ29kZUF0KDApID09PSA2MCkgcmV0dXJuIGZpbGU7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlO1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkUGF0aHMuZ2V0KGZpbGUpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IGZyb20gPSB0aGlzLm9wdHMudG8gPyBkaXJuYW1lKHRoaXMub3B0cy50bykgOiBcIi5cIjtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmcm9tID0gZGlybmFtZShyZXNvbHZlKGZyb20sIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKSk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gcmVsYXRpdmUoZnJvbSwgZmlsZSk7XG4gICAgdGhpcy5tZW1vaXplZFBhdGhzLnNldChmaWxlLCBwYXRoKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBwcmV2aW91cygpIHtcbiAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzTWFwcyA9IFtdO1xuICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3Qud2Fsaygobm9kZTIpID0+IHtcbiAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5pbnB1dC5tYXApIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSBub2RlMi5zb3VyY2UuaW5wdXQubWFwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcy5pbmNsdWRlcyhtYXApKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldmlvdXNNYXBzLnB1c2gobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGlucHV0MiA9IG5ldyBJbnB1dCQzKHRoaXMub3JpZ2luYWxDU1MsIHRoaXMub3B0cyk7XG4gICAgICAgIGlmIChpbnB1dDIubWFwKSB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKGlucHV0Mi5tYXApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7XG4gIH1cbiAgc2V0U291cmNlc0NvbnRlbnQoKSB7XG4gICAgbGV0IGFscmVhZHkgPSB7fTtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLnJvb3Qud2Fsaygobm9kZTIpID0+IHtcbiAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSkge1xuICAgICAgICAgIGxldCBmcm9tID0gbm9kZTIuc291cmNlLmlucHV0LmZyb207XG4gICAgICAgICAgaWYgKGZyb20gJiYgIWFscmVhZHlbZnJvbV0pIHtcbiAgICAgICAgICAgIGFscmVhZHlbZnJvbV0gPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGZyb21VcmwgPSB0aGlzLnVzZXNGaWxlVXJscyA/IHRoaXMudG9GaWxlVXJsKGZyb20pIDogdGhpcy50b1VybCh0aGlzLnBhdGgoZnJvbSkpO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlMi5zb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgIGxldCBmcm9tID0gdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiO1xuICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tLCB0aGlzLmNzcyk7XG4gICAgfVxuICB9XG4gIHNvdXJjZVBhdGgobm9kZTIpIHtcbiAgICBpZiAodGhpcy5tYXBPcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMubWFwT3B0cy5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXNlc0ZpbGVVcmxzKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0ZpbGVVcmwobm9kZTIuc291cmNlLmlucHV0LmZyb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZTIuc291cmNlLmlucHV0LmZyb20pKTtcbiAgICB9XG4gIH1cbiAgdG9CYXNlNjQoc3RyKSB7XG4gICAgaWYgKEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH1cbiAgfVxuICB0b0ZpbGVVcmwocGF0aCkge1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkRmlsZVVSTHMuZ2V0KHBhdGgpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgaWYgKHBhdGhUb0ZpbGVVUkwpIHtcbiAgICAgIGxldCBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTChwYXRoKS50b1N0cmluZygpO1xuICAgICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzLnNldChwYXRoLCBmaWxlVVJMKTtcbiAgICAgIHJldHVybiBmaWxlVVJMO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiYG1hcC5hYnNvbHV0ZWAgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRvVXJsKHBhdGgpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpcy5tZW1vaXplZFVSTHMuZ2V0KHBhdGgpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgaWYgKHNlcCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICAgIH1cbiAgICBsZXQgdXJsID0gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICB0aGlzLm1lbW9pemVkVVJMcy5zZXQocGF0aCwgdXJsKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG59O1xudmFyIG1hcEdlbmVyYXRvciA9IE1hcEdlbmVyYXRvciQyO1xubGV0IE5vZGUkMiA9IG5vZGU7XG5sZXQgQ29tbWVudCQ0ID0gY2xhc3MgQ29tbWVudDIgZXh0ZW5kcyBOb2RlJDIge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKTtcbiAgICB0aGlzLnR5cGUgPSBcImNvbW1lbnRcIjtcbiAgfVxufTtcbnZhciBjb21tZW50ID0gQ29tbWVudCQ0O1xuQ29tbWVudCQ0LmRlZmF1bHQgPSBDb21tZW50JDQ7XG5sZXQgeyBpc0NsZWFuOiBpc0NsZWFuJDEsIG15OiBteSQxIH0gPSBzeW1ib2xzO1xubGV0IERlY2xhcmF0aW9uJDMgPSBkZWNsYXJhdGlvbjtcbmxldCBDb21tZW50JDMgPSBjb21tZW50O1xubGV0IE5vZGUkMSA9IG5vZGU7XG5sZXQgcGFyc2UkNCwgUnVsZSQ0LCBBdFJ1bGUkNCwgUm9vdCQ2O1xuZnVuY3Rpb24gY2xlYW5Tb3VyY2Uobm9kZXMpIHtcbiAgcmV0dXJuIG5vZGVzLm1hcCgoaTIpID0+IHtcbiAgICBpZiAoaTIubm9kZXMpIGkyLm5vZGVzID0gY2xlYW5Tb3VyY2UoaTIubm9kZXMpO1xuICAgIGRlbGV0ZSBpMi5zb3VyY2U7XG4gICAgcmV0dXJuIGkyO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcmtEaXJ0eVVwKG5vZGUyKSB7XG4gIG5vZGUyW2lzQ2xlYW4kMV0gPSBmYWxzZTtcbiAgaWYgKG5vZGUyLnByb3h5T2Yubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpMiBvZiBub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgICBtYXJrRGlydHlVcChpMik7XG4gICAgfVxuICB9XG59XG5sZXQgQ29udGFpbmVyJDcgPSBjbGFzcyBDb250YWluZXIyIGV4dGVuZHMgTm9kZSQxIHtcbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKG5vZGUyKTtcbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICBzdXBlci5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBub2RlMiBvZiB0aGlzLm5vZGVzKSBub2RlMi5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgIH1cbiAgfVxuICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpO1xuICAgIGxldCBpbmRleDIsIHJlc3VsdDI7XG4gICAgd2hpbGUgKHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPCB0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKHRoaXMucHJveHlPZi5ub2Rlc1tpbmRleDJdLCBpbmRleDIpO1xuICAgICAgaWYgKHJlc3VsdDIgPT09IGZhbHNlKSBicmVhaztcbiAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH1cbiAgZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKTtcbiAgfVxuICBnZXRJdGVyYXRvcigpIHtcbiAgICBpZiAoIXRoaXMubGFzdEVhY2gpIHRoaXMubGFzdEVhY2ggPSAwO1xuICAgIGlmICghdGhpcy5pbmRleGVzKSB0aGlzLmluZGV4ZXMgPSB7fTtcbiAgICB0aGlzLmxhc3RFYWNoICs9IDE7XG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5sYXN0RWFjaDtcbiAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdID0gMDtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG4gIH1cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5vZGUyW3Byb3BdKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZWFjaFwiIHx8IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiICYmIHByb3Auc3RhcnRzV2l0aChcIndhbGtcIikpIHtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXShcbiAgICAgICAgICAgICAgLi4uYXJncy5tYXAoKGkyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKGNoaWxkLCBpbmRleDIpID0+IGkyKGNoaWxkLnRvUHJveHkoKSwgaW5kZXgyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImV2ZXJ5XCIgfHwgcHJvcCA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oXG4gICAgICAgICAgICAgIChjaGlsZCwgLi4ub3RoZXIpID0+IGNiKGNoaWxkLnRvUHJveHkoKSwgLi4ub3RoZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTIubm9kZXMubWFwKChpMikgPT4gaTIudG9Qcm94eSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImZpcnN0XCIgfHwgcHJvcCA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0udG9Qcm94eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGlmIChwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwic2VsZWN0b3JcIikge1xuICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaW5kZXgoY2hpbGQpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiKSByZXR1cm4gY2hpbGQ7XG4gICAgaWYgKGNoaWxkLnByb3h5T2YpIGNoaWxkID0gY2hpbGQucHJveHlPZjtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICB9XG4gIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICBsZXQgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdKS5yZXZlcnNlKCk7XG4gICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXggKyAxLCAwLCBub2RlMik7XG4gICAgbGV0IGluZGV4MjtcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICBpZiAoZXhpc3RJbmRleCA8IGluZGV4Mikge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluc2VydEJlZm9yZShleGlzdCwgYWRkKSB7XG4gICAgbGV0IGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICBsZXQgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyBcInByZXBlbmRcIiA6IGZhbHNlO1xuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdLCB0eXBlKS5yZXZlcnNlKCk7XG4gICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgIGZvciAobGV0IG5vZGUyIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXgsIDAsIG5vZGUyKTtcbiAgICBsZXQgaW5kZXgyO1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgIGlmIChleGlzdEluZGV4IDw9IGluZGV4Mikge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5vcm1hbGl6ZShub2Rlcywgc2FtcGxlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbm9kZXMgPSBjbGVhblNvdXJjZShwYXJzZSQ0KG5vZGVzKS5ub2Rlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG5vZGVzID0gW107XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkyIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSBcInJvb3RcIiAmJiB0aGlzLnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgbm9kZXMgPSBub2Rlcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkyIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfSBlbHNlIGlmIChub2Rlcy5wcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGVzLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGZpZWxkIGlzIG1pc3NlZCBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSBbbmV3IERlY2xhcmF0aW9uJDMobm9kZXMpXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzLnNlbGVjdG9yKSB7XG4gICAgICBub2RlcyA9IFtuZXcgUnVsZSQ0KG5vZGVzKV07XG4gICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICBub2RlcyA9IFtuZXcgQXRSdWxlJDQobm9kZXMpXTtcbiAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgIG5vZGVzID0gW25ldyBDb21tZW50JDMobm9kZXMpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZCA9IG5vZGVzLm1hcCgoaTIpID0+IHtcbiAgICAgIGlmICghaTJbbXkkMV0pIENvbnRhaW5lcjIucmVidWlsZChpMik7XG4gICAgICBpMiA9IGkyLnByb3h5T2Y7XG4gICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgaWYgKGkyW2lzQ2xlYW4kMV0pIG1hcmtEaXJ0eVVwKGkyKTtcbiAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpMi5wYXJlbnQgPSB0aGlzLnByb3h5T2Y7XG4gICAgICByZXR1cm4gaTI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgfVxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmZpcnN0LCBcInByZXBlbmRcIikucmV2ZXJzZSgpO1xuICAgICAgZm9yIChsZXQgbm9kZTIgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy51bnNoaWZ0KG5vZGUyKTtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoKGNoaWxkKSB7XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQWxsKCkge1xuICAgIGZvciAobGV0IG5vZGUyIG9mIHRoaXMucHJveHlPZi5ub2Rlcykgbm9kZTIucGFyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlPZi5ub2RlcyA9IFtdO1xuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICBjaGlsZCA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgIHRoaXMucHJveHlPZi5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgIGxldCBpbmRleDI7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgaWYgKGluZGV4MiA+PSBjaGlsZCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLndhbGtEZWNscygoZGVjbCkgPT4ge1xuICAgICAgaWYgKG9wdHMucHJvcHMgJiYgIW9wdHMucHJvcHMuaW5jbHVkZXMoZGVjbC5wcm9wKSkgcmV0dXJuO1xuICAgICAgaWYgKG9wdHMuZmFzdCAmJiAhZGVjbC52YWx1ZS5pbmNsdWRlcyhvcHRzLmZhc3QpKSByZXR1cm47XG4gICAgICBkZWNsLnZhbHVlID0gZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc29tZShjb25kaXRpb24pO1xuICB9XG4gIHdhbGsoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKChjaGlsZCwgaTIpID0+IHtcbiAgICAgIGxldCByZXN1bHQyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQyICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgIHJlc3VsdDIgPSBjaGlsZC53YWxrKGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0pO1xuICB9XG4gIHdhbGtBdFJ1bGVzKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIG5hbWUudGVzdChjaGlsZC5uYW1lKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBjaGlsZC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhbGtEZWNscyhwcm9wLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gcHJvcDtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcm9wIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaTIpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIHByb3AudGVzdChjaGlsZC5wcm9wKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgY2hpbGQucHJvcCA9PT0gcHJvcCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWxrUnVsZXMoc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpMikgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBzZWxlY3Rvci50ZXN0KGNoaWxkLnNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkyKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgY2hpbGQuc2VsZWN0b3IgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmaXJzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdO1xuICB9XG4gIGdldCBsYXN0KCkge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCAtIDFdO1xuICB9XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJQYXJzZSA9IChkZXBlbmRhbnQpID0+IHtcbiAgcGFyc2UkNCA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNy5yZWdpc3RlclJ1bGUgPSAoZGVwZW5kYW50KSA9PiB7XG4gIFJ1bGUkNCA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNy5yZWdpc3RlckF0UnVsZSA9IChkZXBlbmRhbnQpID0+IHtcbiAgQXRSdWxlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJSb290ID0gKGRlcGVuZGFudCkgPT4ge1xuICBSb290JDYgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGNvbnRhaW5lciA9IENvbnRhaW5lciQ3O1xuQ29udGFpbmVyJDcuZGVmYXVsdCA9IENvbnRhaW5lciQ3O1xuQ29udGFpbmVyJDcucmVidWlsZCA9IChub2RlMikgPT4ge1xuICBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQXRSdWxlJDQucHJvdG90eXBlKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJ1bGVcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUnVsZSQ0LnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIERlY2xhcmF0aW9uJDMucHJvdG90eXBlKTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQ29tbWVudCQzLnByb3RvdHlwZSk7XG4gIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJvb3QkNi5wcm90b3R5cGUpO1xuICB9XG4gIG5vZGUyW215JDFdID0gdHJ1ZTtcbiAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgbm9kZTIubm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIENvbnRhaW5lciQ3LnJlYnVpbGQoY2hpbGQpO1xuICAgIH0pO1xuICB9XG59O1xubGV0IENvbnRhaW5lciQ2ID0gY29udGFpbmVyO1xubGV0IExhenlSZXN1bHQkNCwgUHJvY2Vzc29yJDM7XG5sZXQgRG9jdW1lbnQkMyA9IGNsYXNzIERvY3VtZW50MjMgZXh0ZW5kcyBDb250YWluZXIkNiB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoeyB0eXBlOiBcImRvY3VtZW50XCIsIC4uLmRlZmF1bHRzIH0pO1xuICAgIGlmICghdGhpcy5ub2Rlcykge1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cbiAgfVxuICB0b1Jlc3VsdChvcHRzID0ge30pIHtcbiAgICBsZXQgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDQobmV3IFByb2Nlc3NvciQzKCksIHRoaXMsIG9wdHMpO1xuICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICB9XG59O1xuRG9jdW1lbnQkMy5yZWdpc3RlckxhenlSZXN1bHQgPSAoZGVwZW5kYW50KSA9PiB7XG4gIExhenlSZXN1bHQkNCA9IGRlcGVuZGFudDtcbn07XG5Eb2N1bWVudCQzLnJlZ2lzdGVyUHJvY2Vzc29yID0gKGRlcGVuZGFudCkgPT4ge1xuICBQcm9jZXNzb3IkMyA9IGRlcGVuZGFudDtcbn07XG52YXIgZG9jdW1lbnQkMSA9IERvY3VtZW50JDM7XG5Eb2N1bWVudCQzLmRlZmF1bHQgPSBEb2N1bWVudCQzO1xubGV0IHByaW50ZWQgPSB7fTtcbnZhciB3YXJuT25jZSQyID0gZnVuY3Rpb24gd2Fybk9uY2UyKG1lc3NhZ2UpIHtcbiAgaWYgKHByaW50ZWRbbWVzc2FnZV0pIHJldHVybjtcbiAgcHJpbnRlZFttZXNzYWdlXSA9IHRydWU7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIH1cbn07XG5sZXQgV2FybmluZyQyID0gY2xhc3MgV2FybmluZzIge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSBcIndhcm5pbmdcIjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGlmIChvcHRzLm5vZGUgJiYgb3B0cy5ub2RlLnNvdXJjZSkge1xuICAgICAgbGV0IHJhbmdlID0gb3B0cy5ub2RlLnJhbmdlQnkob3B0cyk7XG4gICAgICB0aGlzLmxpbmUgPSByYW5nZS5zdGFydC5saW5lO1xuICAgICAgdGhpcy5jb2x1bW4gPSByYW5nZS5zdGFydC5jb2x1bW47XG4gICAgICB0aGlzLmVuZExpbmUgPSByYW5nZS5lbmQubGluZTtcbiAgICAgIHRoaXMuZW5kQ29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICB9XG4gICAgZm9yIChsZXQgb3B0IGluIG9wdHMpIHRoaXNbb3B0XSA9IG9wdHNbb3B0XTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmVycm9yKHRoaXMudGV4dCwge1xuICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgd29yZDogdGhpcy53b3JkXG4gICAgICB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArIFwiOiBcIiArIHRoaXMudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxufTtcbnZhciB3YXJuaW5nID0gV2FybmluZyQyO1xuV2FybmluZyQyLmRlZmF1bHQgPSBXYXJuaW5nJDI7XG5sZXQgV2FybmluZyQxID0gd2FybmluZztcbmxldCBSZXN1bHQkMyA9IGNsYXNzIFJlc3VsdDIge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IyLCByb290Miwgb3B0cykge1xuICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNzcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3M7XG4gIH1cbiAgd2Fybih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB3YXJuaW5nMiA9IG5ldyBXYXJuaW5nJDEodGV4dCwgb3B0cyk7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKHdhcm5pbmcyKTtcbiAgICByZXR1cm4gd2FybmluZzI7XG4gIH1cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKChpMikgPT4gaTIudHlwZSA9PT0gXCJ3YXJuaW5nXCIpO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNzcztcbiAgfVxufTtcbnZhciByZXN1bHQgPSBSZXN1bHQkMztcblJlc3VsdCQzLmRlZmF1bHQgPSBSZXN1bHQkMztcbmNvbnN0IFNJTkdMRV9RVU9URSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBET1VCTEVfUVVPVEUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBCQUNLU0xBU0ggPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgU0xBU0ggPSBcIi9cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNQQUNFID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IEZFRUQgPSBcIlxcZlwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBUQUIgPSBcIlx0XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENSID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgT1BFTl9TUVVBUkUgPSBcIltcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfU1FVQVJFID0gXCJdXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QRU5fUEFSRU5USEVTRVMgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ0xPU0VfUEFSRU5USEVTRVMgPSBcIilcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgT1BFTl9DVVJMWSA9IFwie1wiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBDTE9TRV9DVVJMWSA9IFwifVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBTRU1JQ09MT04gPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQVNURVJJU0sgPSBcIipcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQ09MT04gPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgQVQgPSBcIkBcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgUkVfQVRfRU5EID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nO1xuY29uc3QgUkVfV09SRF9FTkQgPSAvW1xcdFxcblxcZlxcciAhXCIjJygpOjtAW1xcXFxcXF17fV18XFwvKD89XFwqKS9nO1xuY29uc3QgUkVfQkFEX0JSQUNLRVQgPSAvLltcXHJcXG5cIicoL1xcXFxdLztcbmNvbnN0IFJFX0hFWF9FU0NBUEUgPSAvW1xcZGEtZl0vaTtcbnZhciB0b2tlbml6ZSA9IGZ1bmN0aW9uIHRva2VuaXplcjIoaW5wdXQyLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGNzcyA9IGlucHV0Mi5jc3MudmFsdWVPZigpO1xuICBsZXQgaWdub3JlID0gb3B0aW9ucy5pZ25vcmVFcnJvcnM7XG4gIGxldCBjb2RlLCBuZXh0LCBxdW90ZSwgY29udGVudCwgZXNjYXBlO1xuICBsZXQgZXNjYXBlZCwgZXNjYXBlUG9zLCBwcmV2LCBuMiwgY3VycmVudFRva2VuO1xuICBsZXQgbGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBidWZmZXIgPSBbXTtcbiAgbGV0IHJldHVybmVkID0gW107XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCkge1xuICAgIHRocm93IGlucHV0Mi5lcnJvcihcIlVuY2xvc2VkIFwiICsgd2hhdCwgcG9zKTtcbiAgfVxuICBmdW5jdGlvbiBlbmRPZkZpbGUoKSB7XG4gICAgcmV0dXJuIHJldHVybmVkLmxlbmd0aCA9PT0gMCAmJiBwb3MgPj0gbGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpO1xuICAgIGlmIChwb3MgPj0gbGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZTtcbiAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKTtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgTkVXTElORTpcbiAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICBjYXNlIFRBQjpcbiAgICAgIGNhc2UgQ1I6XG4gICAgICBjYXNlIEZFRUQ6IHtcbiAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPT09IFNQQUNFIHx8IGNvZGUgPT09IE5FV0xJTkUgfHwgY29kZSA9PT0gVEFCIHx8IGNvZGUgPT09IENSIHx8IGNvZGUgPT09IEZFRUQpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJzcGFjZVwiLCBjc3Muc2xpY2UocG9zLCBuZXh0KV07XG4gICAgICAgIHBvcyA9IG5leHQgLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgT1BFTl9TUVVBUkU6XG4gICAgICBjYXNlIENMT1NFX1NRVUFSRTpcbiAgICAgIGNhc2UgT1BFTl9DVVJMWTpcbiAgICAgIGNhc2UgQ0xPU0VfQ1VSTFk6XG4gICAgICBjYXNlIENPTE9OOlxuICAgICAgY2FzZSBTRU1JQ09MT046XG4gICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTOiB7XG4gICAgICAgIGxldCBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFtjb250cm9sQ2hhciwgY29udHJvbENoYXIsIHBvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBPUEVOX1BBUkVOVEhFU0VTOiB7XG4gICAgICAgIHByZXYgPSBidWZmZXIubGVuZ3RoID8gYnVmZmVyLnBvcCgpWzFdIDogXCJcIjtcbiAgICAgICAgbjIgPSBjc3MuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICAgICAgaWYgKHByZXYgPT09IFwidXJsXCIgJiYgbjIgIT09IFNJTkdMRV9RVU9URSAmJiBuMiAhPT0gRE9VQkxFX1FVT1RFICYmIG4yICE9PSBTUEFDRSAmJiBuMiAhPT0gTkVXTElORSAmJiBuMiAhPT0gVEFCICYmIG4yICE9PSBGRUVEICYmIG4yICE9PSBDUikge1xuICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJicmFja2V0XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJicmFja2V0c1wiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIHBvcyArIDEpO1xuICAgICAgICAgIGNvbnRlbnQgPSBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IC0xIHx8IFJFX0JBRF9CUkFDS0VULnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcIihcIiwgXCIoXCIsIHBvc107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcImJyYWNrZXRzXCIsIGNvbnRlbnQsIHBvcywgbmV4dF07XG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgU0lOR0xFX1FVT1RFOlxuICAgICAgY2FzZSBET1VCTEVfUVVPVEU6IHtcbiAgICAgICAgcXVvdGUgPSBjb2RlID09PSBTSU5HTEVfUVVPVEUgPyBcIidcIiA6ICdcIic7XG4gICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKHF1b3RlLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuY2xvc2VkKFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJzdHJpbmdcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgQVQ6IHtcbiAgICAgICAgUkVfQVRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgIFJFX0FUX0VORC50ZXN0KGNzcyk7XG4gICAgICAgIGlmIChSRV9BVF9FTkQubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQubGFzdEluZGV4IC0gMjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJhdC13b3JkXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEJBQ0tTTEFTSDoge1xuICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBCQUNLU0xBU0gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpO1xuICAgICAgICBpZiAoZXNjYXBlICYmIGNvZGUgIT09IFNMQVNIICYmIGNvZGUgIT09IFNQQUNFICYmIGNvZGUgIT09IE5FV0xJTkUgJiYgY29kZSAhPT0gVEFCICYmIGNvZGUgIT09IENSICYmIGNvZGUgIT09IEZFRUQpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQpKSkge1xuICAgICAgICAgICAgd2hpbGUgKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbXCJ3b3JkXCIsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XTtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmIChjb2RlID09PSBTTEFTSCAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIqL1wiLCBwb3MgKyAyKSArIDE7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcImNvbW1lbnRcIiwgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdO1xuICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUkVfV09SRF9FTkQubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICBSRV9XT1JEX0VORC50ZXN0KGNzcyk7XG4gICAgICAgICAgaWYgKFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQubGFzdEluZGV4IC0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFRva2VuID0gW1wid29yZFwiLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF07XG4gICAgICAgICAgYnVmZmVyLnB1c2goY3VycmVudFRva2VuKTtcbiAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3MrKztcbiAgICByZXR1cm4gY3VycmVudFRva2VuO1xuICB9XG4gIGZ1bmN0aW9uIGJhY2sodG9rZW4pIHtcbiAgICByZXR1cm5lZC5wdXNoKHRva2VuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhY2ssXG4gICAgZW5kT2ZGaWxlLFxuICAgIG5leHRUb2tlbixcbiAgICBwb3NpdGlvblxuICB9O1xufTtcbmxldCBDb250YWluZXIkNSA9IGNvbnRhaW5lcjtcbmxldCBBdFJ1bGUkMyA9IGNsYXNzIEF0UnVsZTIgZXh0ZW5kcyBDb250YWluZXIkNSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwiYXRydWxlXCI7XG4gIH1cbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICByZXR1cm4gc3VwZXIuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgfVxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICByZXR1cm4gc3VwZXIucHJlcGVuZCguLi5jaGlsZHJlbik7XG4gIH1cbn07XG52YXIgYXRSdWxlID0gQXRSdWxlJDM7XG5BdFJ1bGUkMy5kZWZhdWx0ID0gQXRSdWxlJDM7XG5Db250YWluZXIkNS5yZWdpc3RlckF0UnVsZShBdFJ1bGUkMyk7XG5sZXQgQ29udGFpbmVyJDQgPSBjb250YWluZXI7XG5sZXQgTGF6eVJlc3VsdCQzLCBQcm9jZXNzb3IkMjtcbmxldCBSb290JDUgPSBjbGFzcyBSb290MiBleHRlbmRzIENvbnRhaW5lciQ0IHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cyk7XG4gICAgdGhpcy50eXBlID0gXCJyb290XCI7XG4gICAgaWYgKCF0aGlzLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gIH1cbiAgbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBzdXBlci5ub3JtYWxpemUoY2hpbGQpO1xuICAgIGlmIChzYW1wbGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInByZXBlbmRcIikge1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc2FtcGxlLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICBmb3IgKGxldCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgbGV0IGluZGV4MiA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgIGlmICghaWdub3JlICYmIGluZGV4MiA9PT0gMCAmJiB0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzW2luZGV4Ml0ucmF3cy5iZWZvcmU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdCQzKG5ldyBQcm9jZXNzb3IkMigpLCB0aGlzLCBvcHRzKTtcbiAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgfVxufTtcblJvb3QkNS5yZWdpc3RlckxhenlSZXN1bHQgPSAoZGVwZW5kYW50KSA9PiB7XG4gIExhenlSZXN1bHQkMyA9IGRlcGVuZGFudDtcbn07XG5Sb290JDUucmVnaXN0ZXJQcm9jZXNzb3IgPSAoZGVwZW5kYW50KSA9PiB7XG4gIFByb2Nlc3NvciQyID0gZGVwZW5kYW50O1xufTtcbnZhciByb290ID0gUm9vdCQ1O1xuUm9vdCQ1LmRlZmF1bHQgPSBSb290JDU7XG5Db250YWluZXIkNC5yZWdpc3RlclJvb3QoUm9vdCQ1KTtcbmxldCBsaXN0JDIgPSB7XG4gIGNvbW1hKHN0cmluZykge1xuICAgIHJldHVybiBsaXN0JDIuc3BsaXQoc3RyaW5nLCBbXCIsXCJdLCB0cnVlKTtcbiAgfSxcbiAgc3BhY2Uoc3RyaW5nKSB7XG4gICAgbGV0IHNwYWNlcyA9IFtcIiBcIiwgXCJcXG5cIiwgXCJcdFwiXTtcbiAgICByZXR1cm4gbGlzdCQyLnNwbGl0KHN0cmluZywgc3BhY2VzKTtcbiAgfSxcbiAgc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgbGV0IGFycmF5ID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBcIlwiO1xuICAgIGxldCBzcGxpdCA9IGZhbHNlO1xuICAgIGxldCBmdW5jID0gMDtcbiAgICBsZXQgaW5RdW90ZSA9IGZhbHNlO1xuICAgIGxldCBwcmV2UXVvdGUgPSBcIlwiO1xuICAgIGxldCBlc2NhcGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBsZXR0ZXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGUpIHtcbiAgICAgICAgaWYgKGxldHRlciA9PT0gcHJldlF1b3RlKSB7XG4gICAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1wiJyB8fCBsZXR0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIoXCIpIHtcbiAgICAgICAgZnVuYyArPSAxO1xuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKVwiKSB7XG4gICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxO1xuICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAwKSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3JzLmluY2x1ZGVzKGxldHRlcikpIHNwbGl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgICAgIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICBzcGxpdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCArPSBsZXR0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcbnZhciBsaXN0XzEgPSBsaXN0JDI7XG5saXN0JDIuZGVmYXVsdCA9IGxpc3QkMjtcbmxldCBDb250YWluZXIkMyA9IGNvbnRhaW5lcjtcbmxldCBsaXN0JDEgPSBsaXN0XzE7XG5sZXQgUnVsZSQzID0gY2xhc3MgUnVsZTIgZXh0ZW5kcyBDb250YWluZXIkMyB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpO1xuICAgIHRoaXMudHlwZSA9IFwicnVsZVwiO1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICB9XG4gIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgcmV0dXJuIGxpc3QkMS5jb21tYSh0aGlzLnNlbGVjdG9yKTtcbiAgfVxuICBzZXQgc2VsZWN0b3JzKHZhbHVlcykge1xuICAgIGxldCBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbDtcbiAgICBsZXQgc2VwMiA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIixcIiArIHRoaXMucmF3KFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcDIpO1xuICB9XG59O1xudmFyIHJ1bGUgPSBSdWxlJDM7XG5SdWxlJDMuZGVmYXVsdCA9IFJ1bGUkMztcbkNvbnRhaW5lciQzLnJlZ2lzdGVyUnVsZShSdWxlJDMpO1xubGV0IERlY2xhcmF0aW9uJDIgPSBkZWNsYXJhdGlvbjtcbmxldCB0b2tlbml6ZXIyMiA9IHRva2VuaXplO1xubGV0IENvbW1lbnQkMiA9IGNvbW1lbnQ7XG5sZXQgQXRSdWxlJDIgPSBhdFJ1bGU7XG5sZXQgUm9vdCQ0ID0gcm9vdDtcbmxldCBSdWxlJDIgPSBydWxlO1xuY29uc3QgU0FGRV9DT01NRU5UX05FSUdIQk9SID0ge1xuICBlbXB0eTogdHJ1ZSxcbiAgc3BhY2U6IHRydWVcbn07XG5mdW5jdGlvbiBmaW5kTGFzdFdpdGhQb3NpdGlvbih0b2tlbnMpIHtcbiAgZm9yIChsZXQgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgbGV0IHBvcyA9IHRva2VuWzNdIHx8IHRva2VuWzJdO1xuICAgIGlmIChwb3MpIHJldHVybiBwb3M7XG4gIH1cbn1cbmxldCBQYXJzZXIkMSA9IGNsYXNzIFBhcnNlcjIge1xuICBjb25zdHJ1Y3RvcihpbnB1dDIpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgIHRoaXMucm9vdCA9IG5ldyBSb290JDQoKTtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3Q7XG4gICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKTtcbiAgICB0aGlzLnJvb3Quc291cmNlID0geyBpbnB1dDogaW5wdXQyLCBzdGFydDogeyBjb2x1bW46IDEsIGxpbmU6IDEsIG9mZnNldDogMCB9IH07XG4gIH1cbiAgYXRydWxlKHRva2VuKSB7XG4gICAgbGV0IG5vZGUyID0gbmV3IEF0UnVsZSQyKCk7XG4gICAgbm9kZTIubmFtZSA9IHRva2VuWzFdLnNsaWNlKDEpO1xuICAgIGlmIChub2RlMi5uYW1lID09PSBcIlwiKSB7XG4gICAgICB0aGlzLnVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IHByZXY7XG4gICAgbGV0IHNoaWZ0O1xuICAgIGxldCBsYXN0ID0gZmFsc2U7XG4gICAgbGV0IG9wZW4gPSBmYWxzZTtcbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiICYmIGJyYWNrZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSk7XG4gICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdO1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgJiYgcHJldlswXSA9PT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihwcmV2WzNdIHx8IHByZXZbMl0pO1xuICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgICAgbGFzdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZChwYXJhbXMpO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTtcbiAgICAgIHRoaXMucmF3KG5vZGUyLCBcInBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgdG9rZW4gPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gbm9kZTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IFwiXCI7XG4gICAgICBub2RlMi5wYXJhbXMgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAob3Blbikge1xuICAgICAgbm9kZTIubm9kZXMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgIH1cbiAgfVxuICBjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpIHtcbiAgICBsZXQgY29sb24gPSB0aGlzLmNvbG9uKHRva2Vucyk7XG4gICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGxldCBmb3VuZGVkID0gMDtcbiAgICBsZXQgdG9rZW47XG4gICAgZm9yIChsZXQgaiA9IGNvbG9uIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2pdO1xuICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgZm91bmRlZCArPSAxO1xuICAgICAgICBpZiAoZm91bmRlZCA9PT0gMikgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIk1pc3NlZCBzZW1pY29sb25cIixcbiAgICAgIHRva2VuWzBdID09PSBcIndvcmRcIiA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdXG4gICAgKTtcbiAgfVxuICBjb2xvbih0b2tlbnMpIHtcbiAgICBsZXQgYnJhY2tldHMgPSAwO1xuICAgIGxldCB0b2tlbiwgdHlwZSwgcHJldjtcbiAgICBmb3IgKGxldCBbaTIsIGVsZW1lbnRdIG9mIHRva2Vucy5lbnRyaWVzKCkpIHtcbiAgICAgIHRva2VuID0gZWxlbWVudDtcbiAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgIGlmICh0eXBlID09PSBcIihcIikge1xuICAgICAgICBicmFja2V0cyArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiKVwiKSB7XG4gICAgICAgIGJyYWNrZXRzIC09IDE7XG4gICAgICB9XG4gICAgICBpZiAoYnJhY2tldHMgPT09IDAgJiYgdHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgdGhpcy5kb3VibGVDb2xvbih0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldlswXSA9PT0gXCJ3b3JkXCIgJiYgcHJldlsxXSA9PT0gXCJwcm9naWRcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldiA9IHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29tbWVudCh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBDb21tZW50JDIoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICBsZXQgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKTtcbiAgICBpZiAoL15cXHMqJC8udGVzdCh0ZXh0KSkge1xuICAgICAgbm9kZTIudGV4dCA9IFwiXCI7XG4gICAgICBub2RlMi5yYXdzLmxlZnQgPSB0ZXh0O1xuICAgICAgbm9kZTIucmF3cy5yaWdodCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXRjaCA9IHRleHQubWF0Y2goL14oXFxzKikoW15dKlxcUykoXFxzKikkLyk7XG4gICAgICBub2RlMi50ZXh0ID0gbWF0Y2hbMl07XG4gICAgICBub2RlMi5yYXdzLmxlZnQgPSBtYXRjaFsxXTtcbiAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBtYXRjaFszXTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlVG9rZW5pemVyKCkge1xuICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyMjIodGhpcy5pbnB1dCk7XG4gIH1cbiAgZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgbGV0IG5vZGUyID0gbmV3IERlY2xhcmF0aW9uJDIoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgbGV0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0WzBdID09PSBcIjtcIikge1xuICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgdG9rZW5zLnBvcCgpO1xuICAgIH1cbiAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihcbiAgICAgIGxhc3RbM10gfHwgbGFzdFsyXSB8fCBmaW5kTGFzdFdpdGhQb3NpdGlvbih0b2tlbnMpXG4gICAgKTtcbiAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgIHdoaWxlICh0b2tlbnNbMF1bMF0gIT09IFwid29yZFwiKSB7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIG5vZGUyLnNvdXJjZS5zdGFydCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5zWzBdWzJdKTtcbiAgICBub2RlMi5wcm9wID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGV0IHR5cGUgPSB0b2tlbnNbMF1bMF07XG4gICAgICBpZiAodHlwZSA9PT0gXCI6XCIgfHwgdHlwZSA9PT0gXCJzcGFjZVwiIHx8IHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZTIucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICB9XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICBsZXQgdG9rZW47XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodG9rZW5bMF0gPT09IFwiOlwiKSB7XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwid29yZFwiICYmIC9cXHcvLnRlc3QodG9rZW5bMV0pKSB7XG4gICAgICAgICAgdGhpcy51bmtub3duV29yZChbdG9rZW5dKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlMi5wcm9wWzBdID09PSBcIl9cIiB8fCBub2RlMi5wcm9wWzBdID09PSBcIipcIikge1xuICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gbm9kZTIucHJvcFswXTtcbiAgICAgIG5vZGUyLnByb3AgPSBub2RlMi5wcm9wLnNsaWNlKDEpO1xuICAgIH1cbiAgICBsZXQgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgZmlyc3RTcGFjZXMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgfVxuICAgIHRoaXMucHJlY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICBmb3IgKGxldCBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCIhaW1wb3J0YW50XCIpIHtcbiAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMuc3RyaW5nRnJvbSh0b2tlbnMsIGkyKTtcbiAgICAgICAgc3RyaW5nID0gdGhpcy5zcGFjZXNGcm9tRW5kKHRva2VucykgKyBzdHJpbmc7XG4gICAgICAgIGlmIChzdHJpbmcgIT09IFwiICFpbXBvcnRhbnRcIikgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSBcImltcG9ydGFudFwiKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IHRva2Vucy5zbGljZSgwKTtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGogPSBpMjsgaiA+IDA7IGotLSkge1xuICAgICAgICAgIGxldCB0eXBlID0gY2FjaGVbal1bMF07XG4gICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDAgJiYgdHlwZSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDApIHtcbiAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyO1xuICAgICAgICAgIHRva2VucyA9IGNhY2hlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIiAmJiB0b2tlblswXSAhPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNXb3JkID0gdG9rZW5zLnNvbWUoKGkyKSA9PiBpMlswXSAhPT0gXCJzcGFjZVwiICYmIGkyWzBdICE9PSBcImNvbW1lbnRcIik7XG4gICAgaWYgKGhhc1dvcmQpIHtcbiAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSBmaXJzdFNwYWNlcy5tYXAoKGkyKSA9PiBpMlsxXSkuam9pbihcIlwiKTtcbiAgICAgIGZpcnN0U3BhY2VzID0gW107XG4gICAgfVxuICAgIHRoaXMucmF3KG5vZGUyLCBcInZhbHVlXCIsIGZpcnN0U3BhY2VzLmNvbmNhdCh0b2tlbnMpLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKG5vZGUyLnZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICB9XG4gIH1cbiAgZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJEb3VibGUgY29sb25cIixcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApO1xuICB9XG4gIGVtcHR5UnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlMiA9IG5ldyBSdWxlJDIoKTtcbiAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICBub2RlMi5zZWxlY3RvciA9IFwiXCI7XG4gICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgfVxuICBlbmQodG9rZW4pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8IFwiXCIpICsgdGhpcy5zcGFjZXM7XG4gICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWRDbG9zZSh0b2tlbik7XG4gICAgfVxuICB9XG4gIGVuZEZpbGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHRoaXMudW5jbG9zZWRCbG9jaygpO1xuICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8IFwiXCIpICsgdGhpcy5zcGFjZXM7XG4gICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpO1xuICB9XG4gIGZyZWVTZW1pY29sb24odG9rZW4pIHtcbiAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICBsZXQgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwicnVsZVwiICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgIHByZXYucmF3cy5vd25TZW1pY29sb24gPSB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBIZWxwZXJzXG4gIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmlucHV0LmZyb21PZmZzZXQob2Zmc2V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uOiBwb3MuY29sLFxuICAgICAgbGluZTogcG9zLmxpbmUsXG4gICAgICBvZmZzZXRcbiAgICB9O1xuICB9XG4gIGluaXQobm9kZTIsIG9mZnNldCkge1xuICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUyKTtcbiAgICBub2RlMi5zb3VyY2UgPSB7XG4gICAgICBpbnB1dDogdGhpcy5pbnB1dCxcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFBvc2l0aW9uKG9mZnNldClcbiAgICB9O1xuICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gdGhpcy5zcGFjZXM7XG4gICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgfVxuICBvdGhlcihzdGFydCkge1xuICAgIGxldCBlbmQgPSBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgbGV0IGNvbG9uID0gZmFsc2U7XG4gICAgbGV0IGJyYWNrZXQgPSBudWxsO1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjdXN0b21Qcm9wZXJ0eSA9IHN0YXJ0WzFdLnN0YXJ0c1dpdGgoXCItLVwiKTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IHRva2VuID0gc3RhcnQ7XG4gICAgd2hpbGUgKHRva2VuKSB7XG4gICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VzdG9tUHJvcGVydHkgJiYgY29sb24gJiYgdHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgaWYgKGNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgIHRoaXMucnVsZSh0b2tlbnMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgY29sb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSBicmFja2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZTtcbiAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldCk7XG4gICAgaWYgKGVuZCAmJiBjb2xvbikge1xuICAgICAgaWYgKCFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgIHRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICBpZiAodG9rZW4gIT09IFwic3BhY2VcIiAmJiB0b2tlbiAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgfVxuICB9XG4gIHBhcnNlKCkge1xuICAgIGxldCB0b2tlbjtcbiAgICB3aGlsZSAoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICBjYXNlIFwic3BhY2VcIjpcbiAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICB0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXQtd29yZFwiOlxuICAgICAgICAgIHRoaXMuYXRydWxlKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICB0aGlzLmVtcHR5UnVsZSh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5vdGhlcih0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5kRmlsZSgpO1xuICB9XG4gIHByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKCkge1xuICB9XG4gIHJhdyhub2RlMiwgcHJvcCwgdG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCB0b2tlbiwgdHlwZTtcbiAgICBsZXQgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxldCBjbGVhbiA9IHRydWU7XG4gICAgbGV0IG5leHQsIHByZXY7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgaWYgKHR5cGUgPT09IFwic3BhY2VcIiAmJiBpMiA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgcHJldiA9IHRva2Vuc1tpMiAtIDFdID8gdG9rZW5zW2kyIC0gMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgIG5leHQgPSB0b2tlbnNbaTIgKyAxXSA/IHRva2Vuc1tpMiArIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICBpZiAoIVNBRkVfQ09NTUVOVF9ORUlHSEJPUltwcmV2XSAmJiAhU0FGRV9DT01NRU5UX05FSUdIQk9SW25leHRdKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHRva2VuWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbGVhbikge1xuICAgICAgbGV0IHJhdyA9IHRva2Vucy5yZWR1Y2UoKGFsbCwgaTIpID0+IGFsbCArIGkyWzFdLCBcIlwiKTtcbiAgICAgIG5vZGUyLnJhd3NbcHJvcF0gPSB7IHJhdywgdmFsdWUgfTtcbiAgICB9XG4gICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgfVxuICBydWxlKHRva2Vucykge1xuICAgIHRva2Vucy5wb3AoKTtcbiAgICBsZXQgbm9kZTIgPSBuZXcgUnVsZSQyKCk7XG4gICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyk7XG4gICAgdGhpcy5yYXcobm9kZTIsIFwic2VsZWN0b3JcIiwgdG9rZW5zKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgfVxuICBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGU7XG4gICAgbGV0IHNwYWNlcyA9IFwiXCI7XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIiAmJiBsYXN0VG9rZW5UeXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgLy8gRXJyb3JzXG4gIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucykge1xuICAgIGxldCBuZXh0O1xuICAgIGxldCBzcGFjZXMgPSBcIlwiO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICBzcGFjZXMgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgfVxuICAgIHJldHVybiBzcGFjZXM7XG4gIH1cbiAgc3BhY2VzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFRva2VuVHlwZTtcbiAgICBsZXQgc3BhY2VzID0gXCJcIjtcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiKSBicmVhaztcbiAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlcztcbiAgfVxuICBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpMiA9IGZyb207IGkyIDwgdG9rZW5zLmxlbmd0aDsgaTIrKykge1xuICAgICAgcmVzdWx0MiArPSB0b2tlbnNbaTJdWzFdO1xuICAgIH1cbiAgICB0b2tlbnMuc3BsaWNlKGZyb20sIHRva2Vucy5sZW5ndGggLSBmcm9tKTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfVxuICB1bmNsb3NlZEJsb2NrKCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0O1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBibG9ja1wiLCBwb3MubGluZSwgcG9zLmNvbHVtbik7XG4gIH1cbiAgdW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJVbmNsb3NlZCBicmFja2V0XCIsXG4gICAgICB7IG9mZnNldDogYnJhY2tldFsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IGJyYWNrZXRbMl0gKyAxIH1cbiAgICApO1xuICB9XG4gIHVuZXhwZWN0ZWRDbG9zZSh0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgfVwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyAxIH1cbiAgICApO1xuICB9XG4gIHVua25vd25Xb3JkKHRva2Vucykge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICBcIlVua25vd24gd29yZFwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSArIHRva2Vuc1swXVsxXS5sZW5ndGggfVxuICAgICk7XG4gIH1cbiAgdW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgXCJBdC1ydWxlIHdpdGhvdXQgbmFtZVwiLFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdIH0sXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGggfVxuICAgICk7XG4gIH1cbn07XG52YXIgcGFyc2VyID0gUGFyc2VyJDE7XG5sZXQgQ29udGFpbmVyJDIgPSBjb250YWluZXI7XG5sZXQgUGFyc2VyMjIgPSBwYXJzZXI7XG5sZXQgSW5wdXQkMiA9IGlucHV0O1xuZnVuY3Rpb24gcGFyc2UkMyhjc3MsIG9wdHMpIHtcbiAgbGV0IGlucHV0MiA9IG5ldyBJbnB1dCQyKGNzcywgb3B0cyk7XG4gIGxldCBwYXJzZXIyID0gbmV3IFBhcnNlcjIyKGlucHV0Mik7XG4gIHRyeSB7XG4gICAgcGFyc2VyMi5wYXJzZSgpO1xuICB9IGNhdGNoIChlMikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChlMi5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgaWYgKC9cXC5zY3NzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU0NTUyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zY3NzIHBhcnNlclwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5zYXNzL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTYXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNhc3MgcGFyc2VyXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcLmxlc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBMZXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLWxlc3MgcGFyc2VyXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZTI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlcjIucm9vdDtcbn1cbnZhciBwYXJzZV8xID0gcGFyc2UkMztcbnBhcnNlJDMuZGVmYXVsdCA9IHBhcnNlJDM7XG5Db250YWluZXIkMi5yZWdpc3RlclBhcnNlKHBhcnNlJDMpO1xubGV0IHsgaXNDbGVhbiwgbXkgfSA9IHN5bWJvbHM7XG5sZXQgTWFwR2VuZXJhdG9yJDEgPSBtYXBHZW5lcmF0b3I7XG5sZXQgc3RyaW5naWZ5JDIgPSBzdHJpbmdpZnlfMTtcbmxldCBDb250YWluZXIkMSA9IGNvbnRhaW5lcjtcbmxldCBEb2N1bWVudCQyID0gZG9jdW1lbnQkMTtcbmxldCB3YXJuT25jZSQxID0gd2Fybk9uY2UkMjtcbmxldCBSZXN1bHQkMiA9IHJlc3VsdDtcbmxldCBwYXJzZSQyID0gcGFyc2VfMTtcbmxldCBSb290JDMgPSByb290O1xuY29uc3QgVFlQRV9UT19DTEFTU19OQU1FID0ge1xuICBhdHJ1bGU6IFwiQXRSdWxlXCIsXG4gIGNvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICBkZWNsOiBcIkRlY2xhcmF0aW9uXCIsXG4gIGRvY3VtZW50OiBcIkRvY3VtZW50XCIsXG4gIHJvb3Q6IFwiUm9vdFwiLFxuICBydWxlOiBcIlJ1bGVcIlxufTtcbmNvbnN0IFBMVUdJTl9QUk9QUyA9IHtcbiAgQXRSdWxlOiB0cnVlLFxuICBBdFJ1bGVFeGl0OiB0cnVlLFxuICBDb21tZW50OiB0cnVlLFxuICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgRGVjbGFyYXRpb246IHRydWUsXG4gIERlY2xhcmF0aW9uRXhpdDogdHJ1ZSxcbiAgRG9jdW1lbnQ6IHRydWUsXG4gIERvY3VtZW50RXhpdDogdHJ1ZSxcbiAgT25jZTogdHJ1ZSxcbiAgT25jZUV4aXQ6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWUsXG4gIFJvb3Q6IHRydWUsXG4gIFJvb3RFeGl0OiB0cnVlLFxuICBSdWxlOiB0cnVlLFxuICBSdWxlRXhpdDogdHJ1ZVxufTtcbmNvbnN0IE5PVF9WSVNJVE9SUyA9IHtcbiAgT25jZTogdHJ1ZSxcbiAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgcHJlcGFyZTogdHJ1ZVxufTtcbmNvbnN0IENISUxEUkVOID0gMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRFdmVudHMobm9kZTIpIHtcbiAgbGV0IGtleSA9IGZhbHNlO1xuICBsZXQgdHlwZSA9IFRZUEVfVE9fQ0xBU1NfTkFNRVtub2RlMi50eXBlXTtcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAga2V5ID0gbm9kZTIucHJvcC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICBrZXkgPSBub2RlMi5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgaWYgKGtleSAmJiBub2RlMi5hcHBlbmQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgIENISUxEUkVOLFxuICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgIF07XG4gIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIFt0eXBlLCB0eXBlICsgXCItXCIgKyBrZXksIHR5cGUgKyBcIkV4aXRcIiwgdHlwZSArIFwiRXhpdC1cIiArIGtleV07XG4gIH0gZWxzZSBpZiAobm9kZTIuYXBwZW5kKSB7XG4gICAgcmV0dXJuIFt0eXBlLCBDSElMRFJFTiwgdHlwZSArIFwiRXhpdFwiXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3R5cGUsIHR5cGUgKyBcIkV4aXRcIl07XG4gIH1cbn1cbmZ1bmN0aW9uIHRvU3RhY2sobm9kZTIpIHtcbiAgbGV0IGV2ZW50cztcbiAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgIGV2ZW50cyA9IFtcIkRvY3VtZW50XCIsIENISUxEUkVOLCBcIkRvY3VtZW50RXhpdFwiXTtcbiAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgIGV2ZW50cyA9IFtcIlJvb3RcIiwgQ0hJTERSRU4sIFwiUm9vdEV4aXRcIl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZ2V0RXZlbnRzKG5vZGUyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV2ZW50SW5kZXg6IDAsXG4gICAgZXZlbnRzLFxuICAgIGl0ZXJhdG9yOiAwLFxuICAgIG5vZGU6IG5vZGUyLFxuICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICB2aXNpdG9yczogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuTWFya3Mobm9kZTIpIHtcbiAgbm9kZTJbaXNDbGVhbl0gPSBmYWxzZTtcbiAgaWYgKG5vZGUyLm5vZGVzKSBub2RlMi5ub2Rlcy5mb3JFYWNoKChpMikgPT4gY2xlYW5NYXJrcyhpMikpO1xuICByZXR1cm4gbm9kZTI7XG59XG5sZXQgcG9zdGNzcyQyID0ge307XG5sZXQgTGF6eVJlc3VsdCQyID0gY2xhc3MgTGF6eVJlc3VsdDIge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICBsZXQgcm9vdDI7XG4gICAgaWYgKHR5cGVvZiBjc3MgPT09IFwib2JqZWN0XCIgJiYgY3NzICE9PSBudWxsICYmIChjc3MudHlwZSA9PT0gXCJyb290XCIgfHwgY3NzLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHtcbiAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyhjc3MpO1xuICAgIH0gZWxzZSBpZiAoY3NzIGluc3RhbmNlb2YgTGF6eVJlc3VsdDIgfHwgY3NzIGluc3RhbmNlb2YgUmVzdWx0JDIpIHtcbiAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyhjc3Mucm9vdCk7XG4gICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWFwID09PSBcInVuZGVmaW5lZFwiKSBvcHRzLm1hcCA9IHt9O1xuICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2U7XG4gICAgICAgIG9wdHMubWFwLnByZXYgPSBjc3MubWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFyc2VyMiA9IHBhcnNlJDI7XG4gICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlcjIgPSBvcHRzLnN5bnRheC5wYXJzZTtcbiAgICAgIGlmIChvcHRzLnBhcnNlcikgcGFyc2VyMiA9IG9wdHMucGFyc2VyO1xuICAgICAgaWYgKHBhcnNlcjIucGFyc2UpIHBhcnNlcjIgPSBwYXJzZXIyLnBhcnNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcm9vdDIgPSBwYXJzZXIyKGNzcywgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChyb290MiAmJiAhcm9vdDJbbXldKSB7XG4gICAgICAgIENvbnRhaW5lciQxLnJlYnVpbGQocm9vdDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMihwcm9jZXNzb3IyLCByb290Miwgb3B0cyk7XG4gICAgdGhpcy5oZWxwZXJzID0geyAuLi5wb3N0Y3NzJDIsIHBvc3Rjc3M6IHBvc3Rjc3MkMiwgcmVzdWx0OiB0aGlzLnJlc3VsdCB9O1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucHJvY2Vzc29yLnBsdWdpbnMubWFwKChwbHVnaW4yMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5wcmVwYXJlKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnBsdWdpbjIyLCAuLi5wbHVnaW4yMi5wcmVwYXJlKHRoaXMucmVzdWx0KSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbjIyO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nO1xuICB9XG4gIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgfVxuICBnZXRBc3luY0Vycm9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnNcIik7XG4gIH1cbiAgaGFuZGxlRXJyb3IoZXJyb3IsIG5vZGUyKSB7XG4gICAgbGV0IHBsdWdpbjIyID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpbjtcbiAgICB0cnkge1xuICAgICAgaWYgKG5vZGUyKSBub2RlMi5hZGRUb0Vycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICBlcnJvci5zZXRNZXNzYWdlKCk7XG4gICAgICB9IGVsc2UgaWYgKHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgcGx1Z2luTmFtZSA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgbGV0IHBsdWdpblZlciA9IHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uO1xuICAgICAgICAgIGxldCBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb247XG4gICAgICAgICAgbGV0IGEyID0gcGx1Z2luVmVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICBsZXQgYiA9IHJ1bnRpbWVWZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGlmIChhMlswXSAhPT0gYlswXSB8fCBwYXJzZUludChhMlsxXSkgPiBwYXJzZUludChiWzFdKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVbmtub3duIGVycm9yIGZyb20gUG9zdENTUyBwbHVnaW4uIFlvdXIgY3VycmVudCBQb3N0Q1NTIHZlcnNpb24gaXMgXCIgKyBydW50aW1lVmVyICsgXCIsIGJ1dCBcIiArIHBsdWdpbk5hbWUgKyBcIiB1c2VzIFwiICsgcGx1Z2luVmVyICsgXCIuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHByZXBhcmVWaXNpdG9ycygpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgIGxldCBhZGQgPSAocGx1Z2luMjIsIHR5cGUsIGNiKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChbcGx1Z2luMjIsIGNiXSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBwbHVnaW4yMiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gcGx1Z2luMjIpIHtcbiAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QU1tldmVudF0gJiYgL15bQS1aXS8udGVzdChldmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZXZlbnQgJHtldmVudH0gaW4gJHtwbHVnaW4yMi5wb3N0Y3NzUGx1Z2lufS4gVHJ5IHRvIHVwZGF0ZSBQb3N0Q1NTICgke3RoaXMucHJvY2Vzc29yLnZlcnNpb259IG5vdykuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFOT1RfVklTSVRPUlNbZXZlbnRdKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gcGx1Z2luMjJbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkKFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgKyBcIi1cIiArIGZpbHRlci50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMltldmVudF1bZmlsdGVyXVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGFzTGlzdGVuZXIgPSBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID4gMDtcbiAgfVxuICBhc3luYyBydW5Bc3luYygpIHtcbiAgICB0aGlzLnBsdWdpbiA9IDA7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGxldCBwbHVnaW4yMiA9IHRoaXMucGx1Z2luc1tpMl07XG4gICAgICBsZXQgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICB3aGlsZSAoIXJvb3QyW2lzQ2xlYW5dKSB7XG4gICAgICAgIHJvb3QyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0YWNrID0gW3RvU3RhY2socm9vdDIpXTtcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcHJvbWlzZSA9IHRoaXMudmlzaXRUaWNrKHN0YWNrKTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgbGV0IG5vZGUyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgIGZvciAobGV0IFtwbHVnaW4yMiwgdmlzaXRvcl0gb2YgdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJvb3RzID0gcm9vdDIubm9kZXMubWFwKFxuICAgICAgICAgICAgICAgIChzdWJSb290KSA9PiB2aXNpdG9yKHN1YlJvb3QsIHRoaXMuaGVscGVycylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXdhaXQgdmlzaXRvcihyb290MiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKTtcbiAgfVxuICBydW5PblJvb3QocGx1Z2luMjIpIHtcbiAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIuT25jZSkge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQucm9vdC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICBsZXQgcm9vdHMgPSB0aGlzLnJlc3VsdC5yb290Lm5vZGVzLm1hcChcbiAgICAgICAgICAgIChyb290MikgPT4gcGx1Z2luMjIuT25jZShyb290MiwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzUHJvbWlzZShyb290c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyb290cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZSh0aGlzLnJlc3VsdC5yb290LCB0aGlzLmhlbHBlcnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RyaW5naWZ5KCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IHRydWU7XG4gICAgdGhpcy5zeW5jKCk7XG4gICAgbGV0IG9wdHMgPSB0aGlzLnJlc3VsdC5vcHRzO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkkMjtcbiAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeTtcbiAgICBpZiAob3B0cy5zdHJpbmdpZmllcikgc3RyID0gb3B0cy5zdHJpbmdpZmllcjtcbiAgICBpZiAoc3RyLnN0cmluZ2lmeSkgc3RyID0gc3RyLnN0cmluZ2lmeTtcbiAgICBsZXQgbWFwID0gbmV3IE1hcEdlbmVyYXRvciQxKHN0ciwgdGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQub3B0cyk7XG4gICAgbGV0IGRhdGEgPSBtYXAuZ2VuZXJhdGUoKTtcbiAgICB0aGlzLnJlc3VsdC5jc3MgPSBkYXRhWzBdO1xuICAgIHRoaXMucmVzdWx0Lm1hcCA9IGRhdGFbMV07XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9XG4gIHN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgIH1cbiAgICBmb3IgKGxldCBwbHVnaW4yMiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGxldCBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgbGV0IHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgIHdoaWxlICghcm9vdDJbaXNDbGVhbl0pIHtcbiAgICAgICAgcm9vdDJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICB0aGlzLndhbGtTeW5jKHJvb3QyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgZm9yIChsZXQgc3ViUm9vdCBvZiByb290Mi5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHN1YlJvb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgcm9vdDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCEoXCJmcm9tXCIgaW4gdGhpcy5vcHRzKSkge1xuICAgICAgICB3YXJuT25jZSQxKFxuICAgICAgICAgIFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzcztcbiAgfVxuICB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgZm9yIChsZXQgW3BsdWdpbjIyLCB2aXNpdG9yXSBvZiB2aXNpdG9ycykge1xuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgbGV0IHByb21pc2U7XG4gICAgICB0cnkge1xuICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyLnByb3h5T2YpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmlzaXRUaWNrKHN0YWNrKSB7XG4gICAgbGV0IHZpc2l0MiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGxldCB7IG5vZGU6IG5vZGUyLCB2aXNpdG9ycyB9ID0gdmlzaXQyO1xuICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0Mi52aXNpdG9ySW5kZXggPCB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxldCBbcGx1Z2luMjIsIHZpc2l0b3JdID0gdmlzaXRvcnNbdmlzaXQyLnZpc2l0b3JJbmRleF07XG4gICAgICB2aXNpdDIudmlzaXRvckluZGV4ICs9IDE7XG4gICAgICBpZiAodmlzaXQyLnZpc2l0b3JJbmRleCA9PT0gdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IFtdO1xuICAgICAgICB2aXNpdDIudmlzaXRvckluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUyLnRvUHJveHkoKSwgdGhpcy5oZWxwZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpc2l0Mi5pdGVyYXRvciAhPT0gMCkge1xuICAgICAgbGV0IGl0ZXJhdG9yID0gdmlzaXQyLml0ZXJhdG9yO1xuICAgICAgbGV0IGNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkID0gbm9kZTIubm9kZXNbbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl1dKSB7XG4gICAgICAgIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgICAgIGlmICghY2hpbGRbaXNDbGVhbl0pIHtcbiAgICAgICAgICBjaGlsZFtpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrKGNoaWxkKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2aXNpdDIuaXRlcmF0b3IgPSAwO1xuICAgICAgZGVsZXRlIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgIH1cbiAgICBsZXQgZXZlbnRzID0gdmlzaXQyLmV2ZW50cztcbiAgICB3aGlsZSAodmlzaXQyLmV2ZW50SW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBsZXQgZXZlbnQgPSBldmVudHNbdmlzaXQyLmV2ZW50SW5kZXhdO1xuICAgICAgdmlzaXQyLmV2ZW50SW5kZXggKz0gMTtcbiAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSBub2RlMi5nZXRJdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuICB3YWxrU3luYyhub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICBsZXQgZXZlbnRzID0gZ2V0RXZlbnRzKG5vZGUyKTtcbiAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgbm9kZTIuZWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbl0pIHRoaXMud2Fsa1N5bmMoY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgIGlmICh0aGlzLnZpc2l0U3luYyh2aXNpdG9ycywgbm9kZTIudG9Qcm94eSgpKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNvbnRlbnQ7XG4gIH1cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3M7XG4gIH1cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXA7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlcztcbiAgfVxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgfVxuICBnZXQgcHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gIH1cbiAgZ2V0IHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luYygpLnJvb3Q7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkxhenlSZXN1bHRcIjtcbiAgfVxufTtcbkxhenlSZXN1bHQkMi5yZWdpc3RlclBvc3Rjc3MgPSAoZGVwZW5kYW50KSA9PiB7XG4gIHBvc3Rjc3MkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgbGF6eVJlc3VsdCA9IExhenlSZXN1bHQkMjtcbkxhenlSZXN1bHQkMi5kZWZhdWx0ID0gTGF6eVJlc3VsdCQyO1xuUm9vdCQzLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIpO1xuRG9jdW1lbnQkMi5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyKTtcbmxldCBNYXBHZW5lcmF0b3IyMiA9IG1hcEdlbmVyYXRvcjtcbmxldCBzdHJpbmdpZnkkMSA9IHN0cmluZ2lmeV8xO1xubGV0IHdhcm5PbmNlMjIgPSB3YXJuT25jZSQyO1xubGV0IHBhcnNlJDEgPSBwYXJzZV8xO1xuY29uc3QgUmVzdWx0JDEgPSByZXN1bHQ7XG5sZXQgTm9Xb3JrUmVzdWx0JDEgPSBjbGFzcyBOb1dvcmtSZXN1bHQyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgdGhpcy5fY3NzID0gY3NzO1xuICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgICBsZXQgcm9vdDI7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeSQxO1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQxKHRoaXMuX3Byb2Nlc3Nvciwgcm9vdDIsIHRoaXMuX29wdHMpO1xuICAgIHRoaXMucmVzdWx0LmNzcyA9IGNzcztcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucmVzdWx0LCBcInJvb3RcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yb290O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yMjIoc3RyLCByb290MiwgdGhpcy5fb3B0cywgY3NzKTtcbiAgICBpZiAobWFwLmlzTWFwKCkpIHtcbiAgICAgIGxldCBbZ2VuZXJhdGVkQ1NTLCBnZW5lcmF0ZWRNYXBdID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgICBpZiAoZ2VuZXJhdGVkQ1NTKSB7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTUztcbiAgICAgIH1cbiAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXAuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzO1xuICAgIH1cbiAgfVxuICBhc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICB9XG4gIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgfVxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCEoXCJmcm9tXCIgaW4gdGhpcy5fb3B0cykpIHtcbiAgICAgICAgd2Fybk9uY2UyMihcbiAgICAgICAgICBcIldpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3NzO1xuICB9XG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICB9XG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgfVxuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5tYXA7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgfVxuICBnZXQgcHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gIH1cbiAgZ2V0IHJvb3QoKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH1cbiAgICBsZXQgcm9vdDI7XG4gICAgbGV0IHBhcnNlcjIgPSBwYXJzZSQxO1xuICAgIHRyeSB7XG4gICAgICByb290MiA9IHBhcnNlcjIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcm9vdCA9IHJvb3QyO1xuICAgICAgcmV0dXJuIHJvb3QyO1xuICAgIH1cbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiTm9Xb3JrUmVzdWx0XCI7XG4gIH1cbn07XG52YXIgbm9Xb3JrUmVzdWx0ID0gTm9Xb3JrUmVzdWx0JDE7XG5Ob1dvcmtSZXN1bHQkMS5kZWZhdWx0ID0gTm9Xb3JrUmVzdWx0JDE7XG5sZXQgTm9Xb3JrUmVzdWx0MjIgPSBub1dvcmtSZXN1bHQ7XG5sZXQgTGF6eVJlc3VsdCQxID0gbGF6eVJlc3VsdDtcbmxldCBEb2N1bWVudCQxID0gZG9jdW1lbnQkMTtcbmxldCBSb290JDIgPSByb290O1xubGV0IFByb2Nlc3NvciQxID0gY2xhc3MgUHJvY2Vzc29yMiB7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbnMgPSBbXSkge1xuICAgIHRoaXMudmVyc2lvbiA9IFwiOC40LjM4XCI7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucyk7XG4gIH1cbiAgbm9ybWFsaXplKHBsdWdpbnMpIHtcbiAgICBsZXQgbm9ybWFsaXplZCA9IFtdO1xuICAgIGZvciAobGV0IGkyIG9mIHBsdWdpbnMpIHtcbiAgICAgIGlmIChpMi5wb3N0Y3NzID09PSB0cnVlKSB7XG4gICAgICAgIGkyID0gaTIoKTtcbiAgICAgIH0gZWxzZSBpZiAoaTIucG9zdGNzcykge1xuICAgICAgICBpMiA9IGkyLnBvc3Rjc3M7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGkyID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoaTIucGx1Z2lucykpIHtcbiAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQuY29uY2F0KGkyLnBsdWdpbnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwib2JqZWN0XCIgJiYgaTIucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwib2JqZWN0XCIgJiYgKGkyLnBhcnNlIHx8IGkyLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiUG9zdENTUyBzeW50YXhlcyBjYW5ub3QgYmUgdXNlZCBhcyBwbHVnaW5zLiBJbnN0ZWFkLCBwbGVhc2UgdXNlIG9uZSBvZiB0aGUgc3ludGF4L3BhcnNlci9zdHJpbmdpZmllciBvcHRpb25zIGFzIG91dGxpbmVkIGluIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihpMiArIFwiIGlzIG5vdCBhIFBvc3RDU1MgcGx1Z2luXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuICBwcm9jZXNzKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbnMubGVuZ3RoICYmICFvcHRzLnBhcnNlciAmJiAhb3B0cy5zdHJpbmdpZmllciAmJiAhb3B0cy5zeW50YXgpIHtcbiAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0MjIodGhpcywgY3NzLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEodGhpcywgY3NzLCBvcHRzKTtcbiAgICB9XG4gIH1cbiAgdXNlKHBsdWdpbjIyKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbcGx1Z2luMjJdKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgcHJvY2Vzc29yID0gUHJvY2Vzc29yJDE7XG5Qcm9jZXNzb3IkMS5kZWZhdWx0ID0gUHJvY2Vzc29yJDE7XG5Sb290JDIucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEpO1xuRG9jdW1lbnQkMS5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IkMSk7XG5sZXQgRGVjbGFyYXRpb24kMSA9IGRlY2xhcmF0aW9uO1xubGV0IFByZXZpb3VzTWFwMjIgPSBwcmV2aW91c01hcDtcbmxldCBDb21tZW50JDEgPSBjb21tZW50O1xubGV0IEF0UnVsZSQxID0gYXRSdWxlO1xubGV0IElucHV0JDEgPSBpbnB1dDtcbmxldCBSb290JDEgPSByb290O1xubGV0IFJ1bGUkMSA9IHJ1bGU7XG5mdW5jdGlvbiBmcm9tSlNPTiQxKGpzb24sIGlucHV0cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkgcmV0dXJuIGpzb24ubWFwKChuMikgPT4gZnJvbUpTT04kMShuMikpO1xuICBsZXQgeyBpbnB1dHM6IG93bklucHV0cywgLi4uZGVmYXVsdHMgfSA9IGpzb247XG4gIGlmIChvd25JbnB1dHMpIHtcbiAgICBpbnB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dDIgb2Ygb3duSW5wdXRzKSB7XG4gICAgICBsZXQgaW5wdXRIeWRyYXRlZCA9IHsgLi4uaW5wdXQyLCBfX3Byb3RvX186IElucHV0JDEucHJvdG90eXBlIH07XG4gICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgaW5wdXRIeWRyYXRlZC5tYXAgPSB7XG4gICAgICAgICAgLi4uaW5wdXRIeWRyYXRlZC5tYXAsXG4gICAgICAgICAgX19wcm90b19fOiBQcmV2aW91c01hcDIyLnByb3RvdHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZCk7XG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy5ub2Rlcykge1xuICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAoKG4yKSA9PiBmcm9tSlNPTiQxKG4yLCBpbnB1dHMpKTtcbiAgfVxuICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgbGV0IHsgaW5wdXRJZCwgLi4uc291cmNlIH0gPSBkZWZhdWx0cy5zb3VyY2U7XG4gICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgcmV0dXJuIG5ldyBSb290JDEoZGVmYXVsdHMpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbiQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgIHJldHVybiBuZXcgUnVsZSQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIHJldHVybiBuZXcgQ29tbWVudCQxKGRlZmF1bHRzKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUkMShkZWZhdWx0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsganNvbi50eXBlKTtcbiAgfVxufVxudmFyIGZyb21KU09OXzEgPSBmcm9tSlNPTiQxO1xuZnJvbUpTT04kMS5kZWZhdWx0ID0gZnJvbUpTT04kMTtcbmxldCBDc3NTeW50YXhFcnJvcjIyID0gY3NzU3ludGF4RXJyb3I7XG5sZXQgRGVjbGFyYXRpb24yMiA9IGRlY2xhcmF0aW9uO1xubGV0IExhenlSZXN1bHQyMiA9IGxhenlSZXN1bHQ7XG5sZXQgQ29udGFpbmVyMjIgPSBjb250YWluZXI7XG5sZXQgUHJvY2Vzc29yMjIgPSBwcm9jZXNzb3I7XG5sZXQgc3RyaW5naWZ5ID0gc3RyaW5naWZ5XzE7XG5sZXQgZnJvbUpTT04gPSBmcm9tSlNPTl8xO1xubGV0IERvY3VtZW50MjIyID0gZG9jdW1lbnQkMTtcbmxldCBXYXJuaW5nMjIgPSB3YXJuaW5nO1xubGV0IENvbW1lbnQyMiA9IGNvbW1lbnQ7XG5sZXQgQXRSdWxlMjIgPSBhdFJ1bGU7XG5sZXQgUmVzdWx0MjIgPSByZXN1bHQ7XG5sZXQgSW5wdXQyMiA9IGlucHV0O1xubGV0IHBhcnNlID0gcGFyc2VfMTtcbmxldCBsaXN0ID0gbGlzdF8xO1xubGV0IFJ1bGUyMiA9IHJ1bGU7XG5sZXQgUm9vdDIyID0gcm9vdDtcbmxldCBOb2RlMjIgPSBub2RlO1xuZnVuY3Rpb24gcG9zdGNzcyguLi5wbHVnaW5zKSB7XG4gIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IyMihwbHVnaW5zKTtcbn1cbnBvc3Rjc3MucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luMihuYW1lLCBpbml0aWFsaXplcikge1xuICBsZXQgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmICF3YXJuaW5nUHJpbnRlZCkge1xuICAgICAgd2FybmluZ1ByaW50ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIlxuICAgICAgKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5MQU5HICYmIHByb2Nlc3MuZW52LkxBTkcuc3RhcnRzV2l0aChcImNuXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncyk7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1ZlcnNpb24gPSBuZXcgUHJvY2Vzc29yMjIoKS52ZXJzaW9uO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgfVxuICBsZXQgY2FjaGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSk7XG4gIGNyZWF0b3IucHJvY2VzcyA9IGZ1bmN0aW9uKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICByZXR1cm4gcG9zdGNzcyhbY3JlYXRvcihwbHVnaW5PcHRzKV0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gIH07XG4gIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3Muc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xucG9zdGNzcy5wYXJzZSA9IHBhcnNlO1xucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OO1xucG9zdGNzcy5saXN0ID0gbGlzdDtcbnBvc3Rjc3MuY29tbWVudCA9IChkZWZhdWx0cykgPT4gbmV3IENvbW1lbnQyMihkZWZhdWx0cyk7XG5wb3N0Y3NzLmF0UnVsZSA9IChkZWZhdWx0cykgPT4gbmV3IEF0UnVsZTIyKGRlZmF1bHRzKTtcbnBvc3Rjc3MuZGVjbCA9IChkZWZhdWx0cykgPT4gbmV3IERlY2xhcmF0aW9uMjIoZGVmYXVsdHMpO1xucG9zdGNzcy5ydWxlID0gKGRlZmF1bHRzKSA9PiBuZXcgUnVsZTIyKGRlZmF1bHRzKTtcbnBvc3Rjc3Mucm9vdCA9IChkZWZhdWx0cykgPT4gbmV3IFJvb3QyMihkZWZhdWx0cyk7XG5wb3N0Y3NzLmRvY3VtZW50ID0gKGRlZmF1bHRzKSA9PiBuZXcgRG9jdW1lbnQyMjIoZGVmYXVsdHMpO1xucG9zdGNzcy5Dc3NTeW50YXhFcnJvciA9IENzc1N5bnRheEVycm9yMjI7XG5wb3N0Y3NzLkRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24yMjtcbnBvc3Rjc3MuQ29udGFpbmVyID0gQ29udGFpbmVyMjI7XG5wb3N0Y3NzLlByb2Nlc3NvciA9IFByb2Nlc3NvcjIyO1xucG9zdGNzcy5Eb2N1bWVudCA9IERvY3VtZW50MjIyO1xucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudDIyO1xucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZzIyO1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGUyMjtcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0MjI7XG5wb3N0Y3NzLklucHV0ID0gSW5wdXQyMjtcbnBvc3Rjc3MuUnVsZSA9IFJ1bGUyMjtcbnBvc3Rjc3MuUm9vdCA9IFJvb3QyMjtcbnBvc3Rjc3MuTm9kZSA9IE5vZGUyMjtcbkxhenlSZXN1bHQyMi5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcyk7XG52YXIgcG9zdGNzc18xID0gcG9zdGNzcztcbnBvc3Rjc3MuZGVmYXVsdCA9IHBvc3Rjc3M7XG5jb25zdCBwb3N0Y3NzJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocG9zdGNzc18xKTtcbnBvc3Rjc3MkMS5zdHJpbmdpZnk7XG5wb3N0Y3NzJDEuZnJvbUpTT047XG5wb3N0Y3NzJDEucGx1Z2luO1xucG9zdGNzcyQxLnBhcnNlO1xucG9zdGNzcyQxLmxpc3Q7XG5wb3N0Y3NzJDEuZG9jdW1lbnQ7XG5wb3N0Y3NzJDEuY29tbWVudDtcbnBvc3Rjc3MkMS5hdFJ1bGU7XG5wb3N0Y3NzJDEucnVsZTtcbnBvc3Rjc3MkMS5kZWNsO1xucG9zdGNzcyQxLnJvb3Q7XG5wb3N0Y3NzJDEuQ3NzU3ludGF4RXJyb3I7XG5wb3N0Y3NzJDEuRGVjbGFyYXRpb247XG5wb3N0Y3NzJDEuQ29udGFpbmVyO1xucG9zdGNzcyQxLlByb2Nlc3NvcjtcbnBvc3Rjc3MkMS5Eb2N1bWVudDtcbnBvc3Rjc3MkMS5Db21tZW50O1xucG9zdGNzcyQxLldhcm5pbmc7XG5wb3N0Y3NzJDEuQXRSdWxlO1xucG9zdGNzcyQxLlJlc3VsdDtcbnBvc3Rjc3MkMS5JbnB1dDtcbnBvc3Rjc3MkMS5SdWxlO1xucG9zdGNzcyQxLlJvb3Q7XG5wb3N0Y3NzJDEuTm9kZTtcbmNsYXNzIEJhc2VSUk5vZGUge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0cnVjdG9yKC4uLl9hcmdzKSB7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJwYXJlbnRFbGVtZW50XCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50Tm9kZVwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm93bmVyRG9jdW1lbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJmaXJzdENoaWxkXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibGFzdENoaWxkXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicHJldmlvdXNTaWJsaW5nXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibmV4dFNpYmxpbmdcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJFTEVNRU5UX05PREVcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJURVhUX05PREVcIiwgMyk7XG4gICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJub2RlVHlwZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5vZGVOYW1lXCIpO1xuICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiUlJOb2RlVHlwZVwiKTtcbiAgfVxuICBnZXQgY2hpbGROb2RlcygpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzMiA9IFtdO1xuICAgIGxldCBjaGlsZEl0ZXJhdG9yID0gdGhpcy5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZEl0ZXJhdG9yKSB7XG4gICAgICBjaGlsZE5vZGVzMi5wdXNoKGNoaWxkSXRlcmF0b3IpO1xuICAgICAgY2hpbGRJdGVyYXRvciA9IGNoaWxkSXRlcmF0b3IubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzMjtcbiAgfVxuICBjb250YWlucyhub2RlMikge1xuICAgIGlmICghKG5vZGUyIGluc3RhbmNlb2YgQmFzZVJSTm9kZSkpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIGlmIChub2RlMi5vd25lckRvY3VtZW50ICE9PSB0aGlzLm93bmVyRG9jdW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIGlmIChub2RlMiA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgd2hpbGUgKG5vZGUyLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChub2RlMi5wYXJlbnROb2RlID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgYXBwZW5kQ2hpbGQoX25ld0NoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQ2hpbGQnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuYFxuICAgICk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBpbnNlcnRCZWZvcmUoX25ld0NoaWxkLCBfcmVmQ2hpbGQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdpbnNlcnRCZWZvcmUnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuYFxuICAgICk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZW1vdmVDaGlsZChfbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSUkRvbUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ3JlbW92ZUNoaWxkJyBvbiAnUlJOb2RlJzogVGhpcyBSUk5vZGUgdHlwZSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgbWV0aG9kLmBcbiAgICApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJSTm9kZVwiO1xuICB9XG59XG5jb25zdCB0ZXN0YWJsZUFjY2Vzc29ycyA9IHtcbiAgTm9kZTogW1wiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIiwgXCJwYXJlbnRFbGVtZW50XCIsIFwidGV4dENvbnRlbnRcIl0sXG4gIFNoYWRvd1Jvb3Q6IFtcImhvc3RcIiwgXCJzdHlsZVNoZWV0c1wiXSxcbiAgRWxlbWVudDogW1wic2hhZG93Um9vdFwiLCBcInF1ZXJ5U2VsZWN0b3JcIiwgXCJxdWVyeVNlbGVjdG9yQWxsXCJdLFxuICBNdXRhdGlvbk9ic2VydmVyOiBbXVxufTtcbmNvbnN0IHRlc3RhYmxlTWV0aG9kcyA9IHtcbiAgTm9kZTogW1wiY29udGFpbnNcIiwgXCJnZXRSb290Tm9kZVwiXSxcbiAgU2hhZG93Um9vdDogW1wiZ2V0U2VsZWN0aW9uXCJdLFxuICBFbGVtZW50OiBbXSxcbiAgTXV0YXRpb25PYnNlcnZlcjogW1wiY29uc3RydWN0b3JcIl1cbn07XG5jb25zdCB1bnRhaW50ZWRCYXNlUHJvdG90eXBlID0ge307XG5jb25zdCBpc0FuZ3VsYXJab25lUHJlc2VudCA9ICgpID0+IHtcbiAgcmV0dXJuICEhZ2xvYmFsVGhpcy5ab25lO1xufTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpIHtcbiAgaWYgKHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldO1xuICBjb25zdCBkZWZhdWx0T2JqID0gZ2xvYmFsVGhpc1trZXldO1xuICBjb25zdCBkZWZhdWx0UHJvdG90eXBlID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVBY2Nlc3NvcnMgPyB0ZXN0YWJsZUFjY2Vzc29yc1trZXldIDogdm9pZCAwO1xuICBjb25zdCBpc1VudGFpbnRlZEFjY2Vzc29ycyA9IEJvb2xlYW4oXG4gICAgYWNjZXNzb3JOYW1lcyAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBhY2Nlc3Nvck5hbWVzLmV2ZXJ5KFxuICAgICAgKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgICAoX2IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0UHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IG1ldGhvZE5hbWVzID0ga2V5IGluIHRlc3RhYmxlTWV0aG9kcyA/IHRlc3RhYmxlTWV0aG9kc1trZXldIDogdm9pZCAwO1xuICBjb25zdCBpc1VudGFpbnRlZE1ldGhvZHMgPSBCb29sZWFuKFxuICAgIG1ldGhvZE5hbWVzICYmIG1ldGhvZE5hbWVzLmV2ZXJ5KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgICAgfVxuICAgIClcbiAgKTtcbiAgaWYgKGlzVW50YWludGVkQWNjZXNzb3JzICYmIGlzVW50YWludGVkTWV0aG9kcyAmJiAhaXNBbmd1bGFyWm9uZVByZXNlbnQoKSkge1xuICAgIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGlmcmFtZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICBjb25zdCB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgY29uc3QgdW50YWludGVkT2JqZWN0ID0gd2luW2tleV0ucHJvdG90eXBlO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgIGlmICghdW50YWludGVkT2JqZWN0KSByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldID0gdW50YWludGVkT2JqZWN0O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgfVxufVxuY29uc3QgdW50YWludGVkQWNjZXNzb3JDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkQWNjZXNzb3Ioa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtrZXl9LiR7U3RyaW5nKGFjY2Vzc29yKX1gO1xuICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0pXG4gICAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGVbY2FjaGVLZXldLmNhbGwoXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gIGNvbnN0IHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpO1xuICBjb25zdCB1bnRhaW50ZWRBY2Nlc3NvciA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIHVudGFpbnRlZFByb3RvdHlwZSxcbiAgICBhY2Nlc3NvclxuICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldDtcbiAgaWYgKCF1bnRhaW50ZWRBY2Nlc3NvcikgcmV0dXJuIGluc3RhbmNlW2FjY2Vzc29yXTtcbiAgdW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRBY2Nlc3NvcjtcbiAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yLmNhbGwoaW5zdGFuY2UpO1xufVxuY29uc3QgdW50YWludGVkTWV0aG9kQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZE1ldGhvZChrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHtrZXl9LiR7U3RyaW5nKG1ldGhvZCl9YDtcbiAgaWYgKHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSlcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kQ2FjaGVbY2FjaGVLZXldLmJpbmQoXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gIGNvbnN0IHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpO1xuICBjb25zdCB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgaWYgKHR5cGVvZiB1bnRhaW50ZWRNZXRob2QgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGluc3RhbmNlW21ldGhvZF07XG4gIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZC5iaW5kKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNoaWxkTm9kZXMobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJjaGlsZE5vZGVzXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZShuMikge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInBhcmVudE5vZGVcIik7XG59XG5mdW5jdGlvbiBwYXJlbnRFbGVtZW50KG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwicGFyZW50RWxlbWVudFwiKTtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50KG4yKSB7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwidGV4dENvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBjb250YWlucyhuMiwgb3RoZXIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiY29udGFpbnNcIikob3RoZXIpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUobjIpIHtcbiAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiZ2V0Um9vdE5vZGVcIikoKTtcbn1cbmZ1bmN0aW9uIGhvc3QobjIpIHtcbiAgaWYgKCFuMiB8fCAhKFwiaG9zdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIlNoYWRvd1Jvb3RcIiwgbjIsIFwiaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIHN0eWxlU2hlZXRzKG4yKSB7XG4gIHJldHVybiBuMi5zdHlsZVNoZWV0cztcbn1cbmZ1bmN0aW9uIHNoYWRvd1Jvb3QobjIpIHtcbiAgaWYgKCFuMiB8fCAhKFwic2hhZG93Um9vdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwic2hhZG93Um9vdFwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IobjIsIHNlbGVjdG9ycykge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwobjIsIHNlbGVjdG9ycykge1xuICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JBbGxcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uT2JzZXJ2ZXJDdG9yKCkge1xuICByZXR1cm4gZ2V0VW50YWludGVkUHJvdG90eXBlKFwiTXV0YXRpb25PYnNlcnZlclwiKS5jb25zdHJ1Y3Rvcjtcbn1cbmNvbnN0IGluZGV4ID0ge1xuICBjaGlsZE5vZGVzLFxuICBwYXJlbnROb2RlLFxuICBwYXJlbnRFbGVtZW50LFxuICB0ZXh0Q29udGVudCxcbiAgY29udGFpbnMsXG4gIGdldFJvb3ROb2RlLFxuICBob3N0LFxuICBzdHlsZVNoZWV0cyxcbiAgc2hhZG93Um9vdCxcbiAgcXVlcnlTZWxlY3RvcixcbiAgcXVlcnlTZWxlY3RvckFsbCxcbiAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3Jcbn07XG5mdW5jdGlvbiBvbih0eXBlLCBmbiwgdGFyZ2V0ID0gZG9jdW1lbnQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG59XG5jb25zdCBERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcgPSBcIlBsZWFzZSBzdG9wIGltcG9ydCBtaXJyb3IgZGlyZWN0bHkuIEluc3RlYWQgb2YgdGhhdCxcXHJcXG5ub3cgeW91IGNhbiB1c2UgcmVwbGF5ZXIuZ2V0TWlycm9yKCkgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2Ugb2YgYSByZXBsYXllcixcXHJcXG5vciB5b3UgY2FuIHVzZSByZWNvcmQubWlycm9yIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIGR1cmluZyByZWNvcmRpbmcuXCI7XG5sZXQgX21pcnJvciA9IHtcbiAgbWFwOiB7fSxcbiAgZ2V0SWQoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIHJldHVybiAtMTtcbiAgfSxcbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlbW92ZU5vZGVGcm9tTWFwKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgfSxcbiAgaGFzKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlc2V0KCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgfVxufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5Qcm94eSAmJiB3aW5kb3cuUmVmbGVjdCkge1xuICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHByb3AgPT09IFwibWFwXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICBsZXQgcHJldmlvdXMgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9LCByZW1haW5pbmcpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIGQsIGlzUmV2b2tlZCwgd2luID0gd2luZG93KSB7XG4gIGNvbnN0IG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB3aW4uT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgaXNSZXZva2VkID8gZCA6IHtcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcbiAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBvcmlnaW5hbCB8fCB7fSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBwYXRjaChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV07XG4gICAgY29uc3Qgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsKTtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSB3cmFwcGVkLnByb3RvdHlwZSB8fCB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcbiAgICAgICAgX19ycndlYl9vcmlnaW5hbF9fOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb3VyY2VbbmFtZV0gPSBvcmlnaW5hbDtcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cbmxldCBub3dUaW1lc3RhbXAgPSBEYXRlLm5vdztcbmlmICghLyogQF9fUFVSRV9fICovIC9bMS05XVswLTldezEyfS8udGVzdChEYXRlLm5vdygpLnRvU3RyaW5nKCkpKSB7XG4gIG5vd1RpbWVzdGFtcCA9ICgpID0+ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKHdpbikge1xuICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IDogd2luLnBhZ2VYT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVhPZmZzZXQgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2EyID0gaW5kZXgucGFyZW50RWxlbWVudChkb2MuYm9keSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsTGVmdCkgfHwgKChfYiA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY3JvbGxMZWZ0KSB8fCAwLFxuICAgIHRvcDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgOiB3aW4ucGFnZVlPZmZzZXQgIT09IHZvaWQgMCA/IHdpbi5wYWdlWU9mZnNldCA6IChkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fCAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgJiYgKChfYyA9IGluZGV4LnBhcmVudEVsZW1lbnQoZG9jLmJvZHkpKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2Nyb2xsVG9wKSB8fCAoKF9kID0gZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNjcm9sbFRvcCkgfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZTIpIHtcbiAgaWYgKCFub2RlMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVsID0gbm9kZTIubm9kZVR5cGUgPT09IG5vZGUyLkVMRU1FTlRfTk9ERSA/IG5vZGUyIDogaW5kZXgucGFyZW50RWxlbWVudChub2RlMik7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tlZChub2RlMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgaWYgKCFub2RlMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUyKTtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChcIi5cIiArIGJsb2NrQ2xhc3MpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBibG9ja0NsYXNzLCBjaGVja0FuY2VzdG9ycykpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxuICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChibG9ja1NlbGVjdG9yKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkKG4yLCBtaXJyb3IyKSB7XG4gIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBpc0lnbm9yZWQobjIsIG1pcnJvcjIsIHNsaW1ET01PcHRpb25zKSB7XG4gIGlmIChuMi50YWdOYW1lID09PSBcIlRJVExFXCIgJiYgc2xpbURPTU9wdGlvbnMuaGVhZFRpdGxlTXV0YXRpb25zKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG1pcnJvcjIuZ2V0SWQobjIpID09PSBJR05PUkVEX05PREU7XG59XG5mdW5jdGlvbiBpc0FuY2VzdG9yUmVtb3ZlZCh0YXJnZXQsIG1pcnJvcjIpIHtcbiAgaWYgKGlzU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICBpZiAoIW1pcnJvcjIuaGFzKGlkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodGFyZ2V0KTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghcGFyZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHBhcmVudCwgbWlycm9yMik7XG59XG5mdW5jdGlvbiBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBCb29sZWFuKGV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbn1cbmZ1bmN0aW9uIHBvbHlmaWxsJDEod2luID0gd2luZG93KSB7XG4gIGlmIChcIk5vZGVMaXN0XCIgaW4gd2luICYmICF3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICB3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgfVxuICBpZiAoXCJET01Ub2tlbkxpc3RcIiBpbiB3aW4gJiYgIXdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICB3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yMikge1xuICByZXR1cm4gQm9vbGVhbihuMi5ub2RlTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiBtaXJyb3IyLmdldE1ldGEobjIpKTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcjIpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbjIubm9kZU5hbWUgPT09IFwiTElOS1wiICYmIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREUgJiYgbjIuZ2V0QXR0cmlidXRlICYmIG4yLmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKVxuICApO1xufVxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuMikge1xuICBpZiAoIW4yKSByZXR1cm4gZmFsc2U7XG4gIGlmIChuMiBpbnN0YW5jZW9mIEJhc2VSUk5vZGUgJiYgXCJzaGFkb3dSb290XCIgaW4gbjIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihuMi5zaGFkb3dSb290KTtcbiAgfVxuICByZXR1cm4gQm9vbGVhbihpbmRleC5zaGFkb3dSb290KG4yKSk7XG59XG5jbGFzcyBTdHlsZVNoZWV0TWlycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIsIDEpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZUlETWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRTdHlsZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBnZXRJZChzdHlsZXNoZWV0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5nZXQoc3R5bGVzaGVldCkgPz8gLTE7XG4gIH1cbiAgaGFzKHN0eWxlc2hlZXQpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgSWYgdGhlIHN0eWxlc2hlZXQgaXMgaW4gdGhlIG1pcnJvciwgcmV0dXJucyB0aGUgaWQgb2YgdGhlIHN0eWxlc2hlZXQuIElmIG5vdCwgcmV0dXJuIHRoZSBuZXcgYXNzaWduZWQgaWQuXG4gICAqL1xuICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcbiAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xuICAgIGxldCBuZXdJZDtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XG4gICAgfSBlbHNlIG5ld0lkID0gaWQ7XG4gICAgdGhpcy5zdHlsZUlETWFwLnNldChzdHlsZXNoZWV0LCBuZXdJZCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XG4gICAgcmV0dXJuIG5ld0lkO1xuICB9XG4gIGdldFN0eWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmlkID0gMTtcbiAgfVxuICBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmlkKys7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRvd0hvc3QobjIpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IHNoYWRvd0hvc3QgPSBudWxsO1xuICBpZiAoXCJnZXRSb290Tm9kZVwiIGluIG4yICYmICgoX2EyID0gaW5kZXguZ2V0Um9vdE5vZGUobjIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5vZGVUeXBlKSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGluZGV4Lmhvc3QoaW5kZXguZ2V0Um9vdE5vZGUobjIpKSlcbiAgICBzaGFkb3dIb3N0ID0gaW5kZXguaG9zdChpbmRleC5nZXRSb290Tm9kZShuMikpO1xuICByZXR1cm4gc2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIGdldFJvb3RTaGFkb3dIb3N0KG4yKSB7XG4gIGxldCByb290U2hhZG93SG9zdCA9IG4yO1xuICBsZXQgc2hhZG93SG9zdDtcbiAgd2hpbGUgKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSlcbiAgICByb290U2hhZG93SG9zdCA9IHNoYWRvd0hvc3Q7XG4gIHJldHVybiByb290U2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuMikge1xuICBjb25zdCBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3QobjIpO1xuICByZXR1cm4gaW5kZXguY29udGFpbnMoZG9jLCBzaGFkb3dIb3N0KTtcbn1cbmZ1bmN0aW9uIGluRG9tKG4yKSB7XG4gIGNvbnN0IGRvYyA9IG4yLm93bmVyRG9jdW1lbnQ7XG4gIGlmICghZG9jKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpbmRleC5jb250YWlucyhkb2MsIG4yKSB8fCBzaGFkb3dIb3N0SW5Eb20objIpO1xufVxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIENhbnZhc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gKChDYW52YXNDb250ZXh0MikgPT4ge1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIjJEXCJdID0gMF0gPSBcIjJEXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0xcIl0gPSAxXSA9IFwiV2ViR0xcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gIHJldHVybiBDYW52YXNDb250ZXh0Mjtcbn0pKENhbnZhc0NvbnRleHQgfHwge30pO1xudmFyIE1lZGlhSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoTWVkaWFJbnRlcmFjdGlvbnMyKSA9PiB7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQbGF5XCJdID0gMF0gPSBcIlBsYXlcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJTZWVrZWRcIl0gPSAyXSA9IFwiU2Vla2VkXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJWb2x1bWVDaGFuZ2VcIl0gPSAzXSA9IFwiVm9sdW1lQ2hhbmdlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJSYXRlQ2hhbmdlXCJdID0gNF0gPSBcIlJhdGVDaGFuZ2VcIjtcbiAgcmV0dXJuIE1lZGlhSW50ZXJhY3Rpb25zMjtcbn0pKE1lZGlhSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBOb2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5vZGVUeXBlMikgPT4ge1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gIHJldHVybiBOb2RlVHlwZTI7XG59KShOb2RlVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3QobjIpIHtcbiAgcmV0dXJuIFwiX19sblwiIGluIG4yO1xufVxuY2xhc3MgRG91YmxlTGlua2VkTGlzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhlYWRcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhaWxcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0KHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBvdXRzaWRlIG9mIGxpc3QgcmFuZ2VcIik7XG4gICAgfVxuICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgIGZvciAobGV0IGluZGV4MiA9IDA7IGluZGV4MiA8IHBvc2l0aW9uOyBpbmRleDIrKykge1xuICAgICAgY3VycmVudCA9IChjdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Lm5leHQpIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG4gIGFkZE5vZGUobjIpIHtcbiAgICBjb25zdCBub2RlMiA9IHtcbiAgICAgIHZhbHVlOiBuMixcbiAgICAgIHByZXZpb3VzOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgbjIuX19sbiA9IG5vZGUyO1xuICAgIGlmIChuMi5wcmV2aW91c1NpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBuMi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0O1xuICAgICAgbm9kZTIubmV4dCA9IGN1cnJlbnQ7XG4gICAgICBub2RlMi5wcmV2aW91cyA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuO1xuICAgICAgbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGUyO1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobjIubmV4dFNpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLm5leHRTaWJsaW5nKSAmJiBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cztcbiAgICAgIG5vZGUyLnByZXZpb3VzID0gY3VycmVudDtcbiAgICAgIG5vZGUyLm5leHQgPSBuMi5uZXh0U2libGluZy5fX2xuO1xuICAgICAgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudC5uZXh0ID0gbm9kZTI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbm9kZTI7XG4gICAgICB9XG4gICAgICBub2RlMi5uZXh0ID0gdGhpcy5oZWFkO1xuICAgICAgdGhpcy5oZWFkID0gbm9kZTI7XG4gICAgfVxuICAgIGlmIChub2RlMi5uZXh0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBub2RlMjtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxuICByZW1vdmVOb2RlKG4yKSB7XG4gICAgY29uc3QgY3VycmVudCA9IG4yLl9fbG47XG4gICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50LnByZXZpb3VzKSB7XG4gICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICBpZiAoY3VycmVudC5uZXh0KSB7XG4gICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobjIuX19sbikge1xuICAgICAgZGVsZXRlIG4yLl9fbG47XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoLS07XG4gIH1cbn1cbmNvbnN0IG1vdmVLZXkgPSAoaWQsIHBhcmVudElkKSA9PiBgJHtpZH1AJHtwYXJlbnRJZH1gO1xuY2xhc3MgTXV0YXRpb25CdWZmZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJvemVuXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9ja2VkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGV4dHNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdHRyaWJ1dGVzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXR0cmlidXRlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3Zlc1wiLCBbXSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hcFJlbW92ZXNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3ZlZE1hcFwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZGVkU2V0XCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3ZlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZHJvcHBlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3Zlc1N1YlRyZWVDYWNoZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmxvY2tDbGFzc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmxvY2tTZWxlY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRDbGFzc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRTZWxlY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5saW5lU3R5bGVzaGVldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza0lucHV0T3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRGblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza0lucHV0Rm5cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtlZXBJZnJhbWVTcmNGblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb3JkQ2FudmFzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmxpbmVJbWFnZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNsaW1ET01PcHRpb25zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhVVJMT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9jXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZU1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlc2hlZXRNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dEb21NYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjYW52YXNNYW5hZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm9jZXNzZWROb2RlTWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5hdHRhY2hlZERvY1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uc1wiLCAobXV0YXRpb25zKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZm9yRWFjaCh0aGlzLnByb2Nlc3NNdXRhdGlvbik7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW1pdFwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWRkcyA9IFtdO1xuICAgICAgY29uc3QgYWRkZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgYWRkTGlzdCA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KCk7XG4gICAgICBjb25zdCBnZXROZXh0SWQgPSAobjIpID0+IHtcbiAgICAgICAgbGV0IG5zID0gbjI7XG4gICAgICAgIGxldCBuZXh0SWQgPSBJR05PUkVEX05PREU7XG4gICAgICAgIHdoaWxlIChuZXh0SWQgPT09IElHTk9SRURfTk9ERSkge1xuICAgICAgICAgIG5zID0gbnMgJiYgbnMubmV4dFNpYmxpbmc7XG4gICAgICAgICAgbmV4dElkID0gbnMgJiYgdGhpcy5taXJyb3IuZ2V0SWQobnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0SWQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgcHVzaEFkZCA9IChuMikgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWluRG9tKG4yKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3NzQ2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG4yLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudFRhZyA9IHBhcmVudC50YWdOYW1lO1xuICAgICAgICAgIGlmIChwYXJlbnRUYWcgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50VGFnID09PSBcIlNUWUxFXCIgJiYgdGhpcy5hZGRlZFNldC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgY3NzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChwYXJlbnQpID8gdGhpcy5taXJyb3IuZ2V0SWQoZ2V0U2hhZG93SG9zdChuMikpIDogdGhpcy5taXJyb3IuZ2V0SWQocGFyZW50KTtcbiAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKG4yKTtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSAtMSB8fCBuZXh0SWQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc24gPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgZG9jOiB0aGlzLmRvYyxcbiAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICAgIGJsb2NrQ2xhc3M6IHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yOiB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgbWFza1RleHRDbGFzczogdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IHRoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBtYXNrVGV4dEZuOiB0aGlzLm1hc2tUZXh0Rm4sXG4gICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm4sXG4gICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHRoaXMuc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IHRoaXMuZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgcmVjb3JkQ2FudmFzOiB0aGlzLnJlY29yZENhbnZhcyxcbiAgICAgICAgICBpbmxpbmVJbWFnZXM6IHRoaXMuaW5saW5lSW1hZ2VzLFxuICAgICAgICAgIG9uU2VyaWFsaXplOiAoY3VycmVudE4pID0+IHtcbiAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKGN1cnJlbnROKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KGN1cnJlbnROLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnROXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3QoaW5kZXguc2hhZG93Um9vdChuMiksIHRoaXMuZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uSWZyYW1lTG9hZDogKGlmcmFtZSwgY2hpbGRTbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rLCBjaGlsZFNuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3NzQ2FwdHVyZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzbikge1xuICAgICAgICAgIGFkZHMucHVzaCh7XG4gICAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICAgIG5leHRJZCxcbiAgICAgICAgICAgIG5vZGU6IHNuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkZWRJZHMuYWRkKHNuLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdoaWxlICh0aGlzLm1hcFJlbW92ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnJlbW92ZU5vZGVGcm9tTWFwKHRoaXMubWFwUmVtb3Zlcy5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbjIgb2YgdGhpcy5tb3ZlZFNldCkge1xuICAgICAgICBpZiAoaXNQYXJlbnRSZW1vdmVkKHRoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSwgbjIsIHRoaXMubWlycm9yKSAmJiAhdGhpcy5tb3ZlZFNldC5oYXMoaW5kZXgucGFyZW50Tm9kZShuMikpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG4yIG9mIHRoaXMuYWRkZWRTZXQpIHtcbiAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQodGhpcy5kcm9wcGVkU2V0LCBuMikgJiYgIWlzUGFyZW50UmVtb3ZlZCh0aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUsIG4yLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICBwdXNoQWRkKG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FuY2VzdG9ySW5TZXQodGhpcy5tb3ZlZFNldCwgbjIpKSB7XG4gICAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYW5kaWRhdGUgPSBudWxsO1xuICAgICAgd2hpbGUgKGFkZExpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxldCBub2RlMiA9IG51bGw7XG4gICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKGluZGV4LnBhcmVudE5vZGUoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKHBhcmVudElkICE9PSAtMSAmJiBuZXh0SWQgIT09IC0xKSB7XG4gICAgICAgICAgICBub2RlMiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlMikge1xuICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcbiAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IF9ub2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKF9ub2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXgucGFyZW50Tm9kZShfbm9kZS52YWx1ZSkpO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQoX25vZGUudmFsdWUpO1xuICAgICAgICAgICAgICBpZiAobmV4dElkID09PSAtMSkgY29udGludWU7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG5vZGUyID0gX25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5oYW5kbGVkTm9kZSA9IF9ub2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodW5oYW5kbGVkTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhZG93SG9zdCA9IGluZGV4Lmhvc3QocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkMiA9IHRoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElkMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgICB3aGlsZSAoYWRkTGlzdC5oZWFkKSB7XG4gICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUoYWRkTGlzdC5oZWFkLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlID0gbm9kZTIucHJldmlvdXM7XG4gICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShub2RlMi52YWx1ZSk7XG4gICAgICAgIHB1c2hBZGQobm9kZTIudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdGV4dHM6IHRoaXMudGV4dHMubWFwKCh0ZXh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgbjIgPSB0ZXh0Lm5vZGU7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKG4yKSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKCh0ZXh0KSA9PiAhYWRkZWRJZHMuaGFzKHRleHQuaWQpKS5maWx0ZXIoKHRleHQpID0+IHRoaXMubWlycm9yLmhhcyh0ZXh0LmlkKSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gYXR0cmlidXRlO1xuICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZGlmZkFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLnN0eWxlRGlmZik7XG4gICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5fdW5jaGFuZ2VkU3R5bGVzKTtcbiAgICAgICAgICAgIGlmIChkaWZmQXNTdHIubGVuZ3RoIDwgYXR0cmlidXRlcy5zdHlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKChkaWZmQXNTdHIgKyB1bmNoYW5nZWRBc1N0cikuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCA9PT0gYXR0cmlidXRlcy5zdHlsZS5zcGxpdChcInZhcihcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm1pcnJvci5nZXRJZChhdHRyaWJ1dGUubm9kZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKChhdHRyaWJ1dGUpID0+ICFhZGRlZElkcy5oYXMoYXR0cmlidXRlLmlkKSkuZmlsdGVyKChhdHRyaWJ1dGUpID0+IHRoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpKSxcbiAgICAgICAgcmVtb3ZlczogdGhpcy5yZW1vdmVzLFxuICAgICAgICBhZGRzXG4gICAgICB9O1xuICAgICAgaWYgKCFwYXlsb2FkLnRleHRzLmxlbmd0aCAmJiAhcGF5bG9hZC5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhcGF5bG9hZC5yZW1vdmVzLmxlbmd0aCAmJiAhcGF5bG9hZC5hZGRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRleHRzID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICB0aGlzLnJlbW92ZXMgPSBbXTtcbiAgICAgIHRoaXMuYWRkZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5tb3ZlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmRyb3BwZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5yZW1vdmVzU3ViVHJlZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcbiAgICAgIHRoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uXCIsICh0ZXh0YXJlYSkgPT4ge1xuICAgICAgbGV0IGl0ZW0gPSB0aGlzLmF0dHJpYnV0ZU1hcC5nZXQodGV4dGFyZWEpO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgbm9kZTogdGV4dGFyZWEsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KHRleHRhcmVhLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uYXR0cmlidXRlcy52YWx1ZSA9IEFycmF5LmZyb20oXG4gICAgICAgIGluZGV4LmNoaWxkTm9kZXModGV4dGFyZWEpLFxuICAgICAgICAoY24pID0+IGluZGV4LnRleHRDb250ZW50KGNuKSB8fCBcIlwiXG4gICAgICApLmpvaW4oXCJcIik7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NNdXRhdGlvblwiLCAobSkgPT4ge1xuICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgdGhpcy5taXJyb3IsIHRoaXMuc2xpbURPTU9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGFyYWN0ZXJEYXRhXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGV4LnRleHRDb250ZW50KG0udGFyZ2V0KTtcbiAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSAmJiB2YWx1ZSAhPT0gbS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChcbiAgICAgICAgICAgICAgICBtLnRhcmdldCxcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAvLyBjaGVja0FuY2VzdG9yc1xuICAgICAgICAgICAgICApICYmIHZhbHVlID8gdGhpcy5tYXNrVGV4dEZuID8gdGhpcy5tYXNrVGV4dEZuKHZhbHVlLCBjbG9zZXN0RWxlbWVudE9mTm9kZShtLnRhcmdldCkpIDogdmFsdWUucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpIDogdmFsdWUsXG4gICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImF0dHJpYnV0ZXNcIjoge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG0udGFyZ2V0O1xuICAgICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lID0gbS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IG0udGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgIHRhZ05hbWU6IHRhcmdldC50YWdOYW1lLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8IHZhbHVlID09PSBtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KG0udGFyZ2V0KTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09IFwiSUZSQU1FXCIgJiYgYXR0cmlidXRlTmFtZSA9PT0gXCJzcmNcIiAmJiAhdGhpcy5rZWVwSWZyYW1lU3JjRm4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwicnJfc3JjXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgICBzdHlsZURpZmY6IHt9LFxuICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KG0udGFyZ2V0LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidHlwZVwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgKG0ub2xkVmFsdWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKFxuICAgICAgICAgICAgICB0aGlzLmRvYyxcbiAgICAgICAgICAgICAgdG9Mb3dlckNhc2UodGFyZ2V0LnRhZ05hbWUpLFxuICAgICAgICAgICAgICB0b0xvd2VyQ2FzZShhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy51bmF0dGFjaGVkRG9jKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5hdHRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPSB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgb2xkID0gdGhpcy51bmF0dGFjaGVkRG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICBpZiAobS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBtLm9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20odGFyZ2V0LnN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpIHx8IG5ld1ByaW9yaXR5ICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLl91bmNoYW5nZWRTdHlsZXNbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcG5hbWUgb2YgQXJyYXkuZnJvbShvbGQuc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwib3BlblwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIkRJQUxPR1wiKSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQubWF0Y2hlcyhcImRpYWxvZzptb2RhbFwiKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1tcInJyX29wZW5fbW9kZVwiXSA9IFwibW9kYWxcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbXCJycl9vcGVuX21vZGVcIl0gPSBcIm5vbi1tb2RhbFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjaGlsZExpc3RcIjoge1xuICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCB0cnVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAobS50YXJnZXQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG0uYWRkZWROb2Rlcy5mb3JFYWNoKChuMikgPT4gdGhpcy5nZW5BZGRzKG4yLCBtLnRhcmdldCkpO1xuICAgICAgICAgIG0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlSWQgPSB0aGlzLm1pcnJvci5nZXRJZChuMik7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChtLnRhcmdldCkgPyB0aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KG0udGFyZ2V0KSkgOiB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8IGlzSWdub3JlZChuMiwgdGhpcy5taXJyb3IsIHRoaXMuc2xpbURPTU9wdGlvbnMpIHx8ICFpc1NlcmlhbGl6ZWQobjIsIHRoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRlZFNldC5oYXMobjIpKSB7XG4gICAgICAgICAgICAgIGRlZXBEZWxldGUodGhpcy5hZGRlZFNldCwgbjIpO1xuICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hZGRlZFNldC5oYXMobS50YXJnZXQpICYmIG5vZGVJZCA9PT0gLTEpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JSZW1vdmVkKG0udGFyZ2V0LCB0aGlzLm1pcnJvcikpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubW92ZWRTZXQuaGFzKG4yKSAmJiB0aGlzLm1vdmVkTWFwW21vdmVLZXkobm9kZUlkLCBwYXJlbnRJZCldKSB7XG4gICAgICAgICAgICAgIGRlZXBEZWxldGUodGhpcy5tb3ZlZFNldCwgbjIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpID8gdHJ1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcHJvY2Vzc1JlbW92ZXMobjIsIHRoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcFJlbW92ZXMucHVzaChuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VuQWRkc1wiLCAobjIsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuaW5PdGhlckJ1ZmZlcihuMiwgdGhpcykpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmFkZGVkU2V0LmhhcyhuMikgfHwgdGhpcy5tb3ZlZFNldC5oYXMobjIpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5taXJyb3IuaGFzTm9kZShuMikpIHtcbiAgICAgICAgaWYgKGlzSWdub3JlZChuMiwgdGhpcy5taXJyb3IsIHRoaXMuc2xpbURPTU9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgbGV0IHRhcmdldElkID0gbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXRJZCA9IHRoaXMubWlycm9yLmdldElkKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldElkICYmIHRhcmdldElkICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMubW92ZWRNYXBbbW92ZUtleSh0aGlzLm1pcnJvci5nZXRJZChuMiksIHRhcmdldElkKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZGVkU2V0LmFkZChuMik7XG4gICAgICAgIHRoaXMuZHJvcHBlZFNldC5kZWxldGUobjIpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Jsb2NrZWQobjIsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkpIHtcbiAgICAgICAgaW5kZXguY2hpbGROb2RlcyhuMikuZm9yRWFjaCgoY2hpbGROKSA9PiB0aGlzLmdlbkFkZHMoY2hpbGROKSk7XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIGluZGV4LmNoaWxkTm9kZXMoaW5kZXguc2hhZG93Um9vdChuMikpLmZvckVhY2goKGNoaWxkTikgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5hZGQoY2hpbGROLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuQWRkcyhjaGlsZE4sIG4yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIFtcbiAgICAgIFwibXV0YXRpb25DYlwiLFxuICAgICAgXCJibG9ja0NsYXNzXCIsXG4gICAgICBcImJsb2NrU2VsZWN0b3JcIixcbiAgICAgIFwibWFza1RleHRDbGFzc1wiLFxuICAgICAgXCJtYXNrVGV4dFNlbGVjdG9yXCIsXG4gICAgICBcImlubGluZVN0eWxlc2hlZXRcIixcbiAgICAgIFwibWFza0lucHV0T3B0aW9uc1wiLFxuICAgICAgXCJtYXNrVGV4dEZuXCIsXG4gICAgICBcIm1hc2tJbnB1dEZuXCIsXG4gICAgICBcImtlZXBJZnJhbWVTcmNGblwiLFxuICAgICAgXCJyZWNvcmRDYW52YXNcIixcbiAgICAgIFwiaW5saW5lSW1hZ2VzXCIsXG4gICAgICBcInNsaW1ET01PcHRpb25zXCIsXG4gICAgICBcImRhdGFVUkxPcHRpb25zXCIsXG4gICAgICBcImRvY1wiLFxuICAgICAgXCJtaXJyb3JcIixcbiAgICAgIFwiaWZyYW1lTWFuYWdlclwiLFxuICAgICAgXCJzdHlsZXNoZWV0TWFuYWdlclwiLFxuICAgICAgXCJzaGFkb3dEb21NYW5hZ2VyXCIsXG4gICAgICBcImNhbnZhc01hbmFnZXJcIixcbiAgICAgIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIlxuICAgIF0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfSk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XG4gIH1cbiAgdW5mcmVlemUoKSB7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5mcmVlemUoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBpc0Zyb3plbigpIHtcbiAgICByZXR1cm4gdGhpcy5mcm96ZW47XG4gIH1cbiAgbG9jaygpIHtcbiAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcbiAgfVxuICB1bmxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5sb2NrKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnJlc2V0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbjIpIHtcbiAgYWRkc1NldC5kZWxldGUobjIpO1xuICBpbmRleC5jaGlsZE5vZGVzKG4yKS5mb3JFYWNoKChjaGlsZE4pID0+IGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKSk7XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVtb3ZlcyhuMiwgY2FjaGUpIHtcbiAgY29uc3QgcXVldWUgPSBbbjJdO1xuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dCA9IHF1ZXVlLnBvcCgpO1xuICAgIGlmIChjYWNoZS5oYXMobmV4dCkpIGNvbnRpbnVlO1xuICAgIGNhY2hlLmFkZChuZXh0KTtcbiAgICBpbmRleC5jaGlsZE5vZGVzKG5leHQpLmZvckVhY2goKG4yMikgPT4gcXVldWUucHVzaChuMjIpKTtcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgaWYgKHJlbW92ZXMuc2l6ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMik7XG59XG5mdW5jdGlvbiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBfbWlycm9yMikge1xuICBjb25zdCBub2RlMiA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICBpZiAoIW5vZGUyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiByZW1vdmVzLmhhcyhub2RlMik7XG59XG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuMikge1xuICBpZiAoc2V0LnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuMik7XG59XG5mdW5jdGlvbiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgY29uc3QgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gIGlmICghcGFyZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzZXQuaGFzKHBhcmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIHBhcmVudCk7XG59XG5sZXQgZXJyb3JIYW5kbGVyO1xuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICBlcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckVycm9ySGFuZGxlcigpIHtcbiAgZXJyb3JIYW5kbGVyID0gdm9pZCAwO1xufVxuY29uc3QgY2FsbGJhY2tXcmFwcGVyID0gKGNiKSA9PiB7XG4gIGlmICghZXJyb3JIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGNiO1xuICB9XG4gIGNvbnN0IHJyd2ViV3JhcHBlZCA9ICguLi5yZXN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYiguLi5yZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9ySGFuZGxlciAmJiBlcnJvckhhbmRsZXIoZXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJyd2ViV3JhcHBlZDtcbn07XG5jb25zdCBtdXRhdGlvbkJ1ZmZlcnMgPSBbXTtcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKFwiY29tcG9zZWRQYXRoXCIgaW4gZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFwicGF0aFwiIGluIGV2ZW50ICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBldmVudCAmJiBldmVudC50YXJnZXQ7XG59XG5mdW5jdGlvbiBpbml0TXV0YXRpb25PYnNlcnZlcihvcHRpb25zLCByb290RWwpIHtcbiAgY29uc3QgbXV0YXRpb25CdWZmZXIgPSBuZXcgTXV0YXRpb25CdWZmZXIoKTtcbiAgbXV0YXRpb25CdWZmZXJzLnB1c2gobXV0YXRpb25CdWZmZXIpO1xuICBtdXRhdGlvbkJ1ZmZlci5pbml0KG9wdGlvbnMpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyAobXV0YXRpb25PYnNlcnZlckN0b3IoKSkoXG4gICAgY2FsbGJhY2tXcmFwcGVyKG11dGF0aW9uQnVmZmVyLnByb2Nlc3NNdXRhdGlvbnMuYmluZChtdXRhdGlvbkJ1ZmZlcikpXG4gICk7XG4gIG9ic2VydmVyLm9ic2VydmUocm9vdEVsLCB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gaW5pdE1vdmVPYnNlcnZlcih7XG4gIG1vdXNlbW92ZUNiLFxuICBzYW1wbGluZyxcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjJcbn0pIHtcbiAgaWYgKHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZSA6IDUwO1xuICBjb25zdCBjYWxsYmFja1RocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrIDogNTAwO1xuICBsZXQgcG9zaXRpb25zID0gW107XG4gIGxldCB0aW1lQmFzZWxpbmU7XG4gIGNvbnN0IHdyYXBwZWRDYiA9IHRocm90dGxlKFxuICAgIGNhbGxiYWNrV3JhcHBlcihcbiAgICAgIChzb3VyY2UpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBEYXRlLm5vdygpIC0gdGltZUJhc2VsaW5lO1xuICAgICAgICBtb3VzZW1vdmVDYihcbiAgICAgICAgICBwb3NpdGlvbnMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzb3VyY2VcbiAgICAgICAgKTtcbiAgICAgICAgcG9zaXRpb25zID0gW107XG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XG4gICAgICB9XG4gICAgKSxcbiAgICBjYWxsYmFja1RocmVzaG9sZFxuICApO1xuICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICB0aHJvdHRsZShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gbGVnYWN5X2lzVG91Y2hFdmVudChldnQpID8gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZ0O1xuICAgICAgICBpZiAoIXRpbWVCYXNlbGluZSkge1xuICAgICAgICAgIHRpbWVCYXNlbGluZSA9IG5vd1RpbWVzdGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICAgIHk6IGNsaWVudFksXG4gICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICB0aW1lT2Zmc2V0OiBub3dUaW1lc3RhbXAoKSAtIHRpbWVCYXNlbGluZVxuICAgICAgICB9KTtcbiAgICAgICAgd3JhcHBlZENiKFxuICAgICAgICAgIHR5cGVvZiBEcmFnRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZXZ0IGluc3RhbmNlb2YgRHJhZ0V2ZW50ID8gSW5jcmVtZW50YWxTb3VyY2UuRHJhZyA6IGV2dCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUgOiBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAge1xuICAgICAgICB0cmFpbGluZzogZmFsc2VcbiAgICAgIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgIG9uKFwibW91c2Vtb3ZlXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxuICAgIG9uKFwidG91Y2htb3ZlXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxuICAgIG9uKFwiZHJhZ1wiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKVxuICBdO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIoe1xuICBtb3VzZUludGVyYWN0aW9uQ2IsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBibG9ja0NsYXNzLFxuICBibG9ja1NlbGVjdG9yLFxuICBzYW1wbGluZ1xufSkge1xuICBpZiAoc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgZGlzYWJsZU1hcCA9IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHRydWUgfHwgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdm9pZCAwID8ge30gOiBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uO1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBsZXQgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgY29uc3QgZ2V0SGFuZGxlciA9IChldmVudEtleSkgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmIChpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xuICAgICAgaWYgKFwicG9pbnRlclR5cGVcIiBpbiBldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Nb3VzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xuICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gXCJUb3VjaFN0YXJ0XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcbiAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hFbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcbiAgICAgIH0gZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgIGlmICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIlRvdWNoXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2ggfHwgdGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJNb3VzZVwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSB7XG4gICAgICAgICAgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XG4gICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBlMiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgIGlmICghZTIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGUyO1xuICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoe1xuICAgICAgICB0eXBlOiBNb3VzZUludGVyYWN0aW9uc1t0aGlzRXZlbnRLZXldLFxuICAgICAgICBpZCxcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgLi4ucG9pbnRlclR5cGUgIT09IG51bGwgJiYgeyBwb2ludGVyVHlwZSB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucykuZmlsdGVyKFxuICAgIChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiYgIWtleS5lbmRzV2l0aChcIl9EZXBhcnRlZFwiKSAmJiBkaXNhYmxlTWFwW2tleV0gIT09IGZhbHNlXG4gICkuZm9yRWFjaCgoZXZlbnRLZXkpID0+IHtcbiAgICBsZXQgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XG4gICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcDpcbiAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZShcbiAgICAgICAgICAgIFwibW91c2VcIixcbiAgICAgICAgICAgIFwicG9pbnRlclwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxuICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcnMucHVzaChvbihldmVudE5hbWUsIGhhbmRsZXIsIGRvYykpO1xuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoe1xuICBzY3JvbGxDYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIHNhbXBsaW5nXG59KSB7XG4gIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gY2FsbGJhY2tXcmFwcGVyKFxuICAgIHRocm90dGxlKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKChldnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgc2Nyb2xsQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB4OiBzY3JvbGxMZWZ0VG9wLmxlZnQsXG4gICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMFxuICAgIClcbiAgKTtcbiAgcmV0dXJuIG9uKFwic2Nyb2xsXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpO1xufVxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIoeyB2aWV3cG9ydFJlc2l6ZUNiIH0sIHsgd2luIH0pIHtcbiAgbGV0IGxhc3RIID0gLTE7XG4gIGxldCBsYXN0VyA9IC0xO1xuICBjb25zdCB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUoXG4gICAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBnZXRXaW5kb3dIZWlnaHQoKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICBpZiAobGFzdEggIT09IGhlaWdodCB8fCBsYXN0VyAhPT0gd2lkdGgpIHtcbiAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiKHtcbiAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIod2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoaGVpZ2h0KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RIID0gaGVpZ2h0O1xuICAgICAgICAgIGxhc3RXID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgMjAwXG4gICAgKVxuICApO1xuICByZXR1cm4gb24oXCJyZXNpemVcIiwgdXBkYXRlRGltZW5zaW9uLCB3aW4pO1xufVxuY29uc3QgSU5QVVRfVEFHUyA9IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl07XG5jb25zdCBsYXN0SW5wdXRWYWx1ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaW5pdElucHV0T2JzZXJ2ZXIoe1xuICBpbnB1dENiLFxuICBkb2MsXG4gIG1pcnJvcjogbWlycm9yMixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgaWdub3JlQ2xhc3MsXG4gIGlnbm9yZVNlbGVjdG9yLFxuICBtYXNrSW5wdXRPcHRpb25zLFxuICBtYXNrSW5wdXRGbixcbiAgc2FtcGxpbmcsXG4gIHVzZXJUcmlnZ2VyZWRPbklucHV0XG59KSB7XG4gIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgY29uc3QgdXNlclRyaWdnZXJlZCA9IGV2ZW50LmlzVHJ1c3RlZDtcbiAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xuICAgIGlmICh0YXJnZXQgJiYgdGFnTmFtZSA9PT0gXCJPUFRJT05cIikge1xuICAgICAgdGFyZ2V0ID0gaW5kZXgucGFyZW50RWxlbWVudCh0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldCB8fCAhdGFnTmFtZSB8fCBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKSB8fCBpZ25vcmVTZWxlY3RvciAmJiB0YXJnZXQubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRleHQgPSB0YXJnZXQudmFsdWU7XG4gICAgbGV0IGlzQ2hlY2tlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KSB8fCBcIlwiO1xuICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICBpc0NoZWNrZWQgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICB9IGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XG4gICAgICB0ZXh0ID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICBlbGVtZW50OiB0YXJnZXQsXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIHRhZ05hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBtYXNrSW5wdXRGblxuICAgICAgfSk7XG4gICAgfVxuICAgIGNiV2l0aERlZHVwKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7IHRleHQsIGlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZCB9IDogeyB0ZXh0LCBpc0NoZWNrZWQgfVxuICAgICk7XG4gICAgY29uc3QgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcbiAgICAgIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIiR7bmFtZX1cIl1gKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwgIT09IHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHRleHQyID0gZWwudmFsdWU7XG4gICAgICAgICAgY2JXaXRoRGVkdXAoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID8geyB0ZXh0OiB0ZXh0MiwgaXNDaGVja2VkOiAhaXNDaGVja2VkLCB1c2VyVHJpZ2dlcmVkOiBmYWxzZSB9IDogeyB0ZXh0OiB0ZXh0MiwgaXNDaGVja2VkOiAhaXNDaGVja2VkIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2Mikge1xuICAgIGNvbnN0IGxhc3RJbnB1dFZhbHVlID0gbGFzdElucHV0VmFsdWVNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFsYXN0SW5wdXRWYWx1ZSB8fCBsYXN0SW5wdXRWYWx1ZS50ZXh0ICE9PSB2Mi50ZXh0IHx8IGxhc3RJbnB1dFZhbHVlLmlzQ2hlY2tlZCAhPT0gdjIuaXNDaGVja2VkKSB7XG4gICAgICBsYXN0SW5wdXRWYWx1ZU1hcC5zZXQodGFyZ2V0LCB2Mik7XG4gICAgICBjb25zdCBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICAgIGNhbGxiYWNrV3JhcHBlcihpbnB1dENiKSh7XG4gICAgICAgIC4uLnYyLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50cyA9IHNhbXBsaW5nLmlucHV0ID09PSBcImxhc3RcIiA/IFtcImNoYW5nZVwiXSA6IFtcImlucHV0XCIsIFwiY2hhbmdlXCJdO1xuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50cy5tYXAoXG4gICAgKGV2ZW50TmFtZSkgPT4gb24oZXZlbnROYW1lLCBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSwgZG9jKVxuICApO1xuICBjb25zdCBjdXJyZW50V2luZG93ID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLFxuICAgIFwidmFsdWVcIlxuICApO1xuICBjb25zdCBob29rUHJvcGVydGllcyA9IFtcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgXCJjaGVja2VkXCJdLFxuICAgIFtjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiXSxcbiAgICAvLyBTb21lIFVJIGxpYnJhcnkgdXNlIHNlbGVjdGVkSW5kZXggdG8gc2V0IHNlbGVjdCB2YWx1ZVxuICAgIFtjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCJdLFxuICAgIFtjdXJyZW50V2luZG93LkhUTUxPcHRpb25FbGVtZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiXVxuICBdO1xuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yICYmIHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcbiAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgLi4uaG9va1Byb3BlcnRpZXMubWFwKFxuICAgICAgICAocCkgPT4gaG9va1NldHRlcihcbiAgICAgICAgICBwWzBdLFxuICAgICAgICAgIHBbMV0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGlzVHJ1c3RlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAvLyB1c2VyVHJpZ2dlcmVkIHRvIGZhbHNlIGFzIHRoaXMgY291bGQgd2VsbCBiZSBwcm9ncmFtbWF0aWNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50V2luZG93XG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyhydWxlMikge1xuICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgZnVuY3Rpb24gcmVjdXJzZShjaGlsZFJ1bGUsIHBvcykge1xuICAgIGlmIChoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpICYmIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTR3JvdXBpbmdSdWxlIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikgJiYgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NNZWRpYVJ1bGUgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0NvbmRpdGlvblJ1bGUpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oXG4gICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlLmNzc1J1bGVzXG4gICAgICApO1xuICAgICAgY29uc3QgaW5kZXgyID0gcnVsZXMyLmluZGV4T2YoY2hpbGRSdWxlKTtcbiAgICAgIHBvcy51bnNoaWZ0KGluZGV4Mik7XG4gICAgfSBlbHNlIGlmIChjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldCkge1xuICAgICAgY29uc3QgcnVsZXMyID0gQXJyYXkuZnJvbShjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldC5jc3NSdWxlcyk7XG4gICAgICBjb25zdCBpbmRleDIgPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgcG9zLnVuc2hpZnQoaW5kZXgyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICByZXR1cm4gcmVjdXJzZShydWxlMiwgcG9zaXRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldElkQW5kU3R5bGVJZChzaGVldCwgbWlycm9yMiwgc3R5bGVNaXJyb3IpIHtcbiAgbGV0IGlkLCBzdHlsZUlkO1xuICBpZiAoIXNoZWV0KSByZXR1cm4ge307XG4gIGlmIChzaGVldC5vd25lck5vZGUpIGlkID0gbWlycm9yMi5nZXRJZChzaGVldC5vd25lck5vZGUpO1xuICBlbHNlIHN0eWxlSWQgPSBzdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XG4gIHJldHVybiB7XG4gICAgc3R5bGVJZCxcbiAgICBpZFxuICB9O1xufVxuZnVuY3Rpb24gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcih7IHN0eWxlU2hlZXRSdWxlQ2IsIG1pcnJvcjogbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIgfSwgeyB3aW4gfSkge1xuICBpZiAoIXdpbi5DU1NTdHlsZVNoZWV0IHx8ICF3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5zZXJ0UnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlO1xuICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eShpbnNlcnRSdWxlLCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgY29uc3QgW3J1bGUyLCBpbmRleDJdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICApO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgIGFkZHM6IFt7IHJ1bGU6IHJ1bGUyLCBpbmRleDogaW5kZXgyIH1dXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xuICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuYWRkUnVsZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBzdHlsZUJsb2NrLCBpbmRleDIgPSB0aGlzLmNzc1J1bGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IHJ1bGUyID0gYCR7c2VsZWN0b3J9IHsgJHtzdHlsZUJsb2NrfSB9YDtcbiAgICByZXR1cm4gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUuYXBwbHkodGhpcywgW3J1bGUyLCBpbmRleDJdKTtcbiAgfTtcbiAgY29uc3QgZGVsZXRlUnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlO1xuICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShkZWxldGVSdWxlLCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgY29uc3QgW2luZGV4Ml0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXg6IGluZGV4MiB9XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZVJ1bGUgPSBmdW5jdGlvbihpbmRleDIpIHtcbiAgICByZXR1cm4gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUuYXBwbHkodGhpcywgW2luZGV4Ml0pO1xuICB9O1xuICBsZXQgcmVwbGFjZTtcbiAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlKSB7XG4gICAgcmVwbGFjZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcbiAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICBjb25zdCBbdGV4dF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICByZXBsYWNlOiB0ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG4gIGxldCByZXBsYWNlU3luYztcbiAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYykge1xuICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IG5ldyBQcm94eShyZXBsYWNlU3luYywge1xuICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgIHJlcGxhY2VTeW5jOiB0ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcyA9IHt9O1xuICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpKSB7XG4gICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0dyb3VwaW5nUnVsZSA9IHdpbi5DU1NHcm91cGluZ1J1bGU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU01lZGlhUnVsZVwiKSkge1xuICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU01lZGlhUnVsZSA9IHdpbi5DU1NNZWRpYVJ1bGU7XG4gICAgfVxuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NDb25kaXRpb25SdWxlXCIpKSB7XG4gICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xuICAgIH1cbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTU3VwcG9ydHNSdWxlXCIpKSB7XG4gICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdW5tb2RpZmllZEZ1bmN0aW9ucyA9IHt9O1xuICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xuICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBpbnNlcnRSdWxlOiB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgZGVsZXRlUnVsZTogdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZVxuICAgIH07XG4gICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eShcbiAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSxcbiAgICAgIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbcnVsZTIsIGluZGV4Ml0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgICB0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsXG4gICAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlMixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4MiB8fCAwXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gMFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KFxuICAgICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlLFxuICAgICAge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtpbmRleDJdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgICAgdGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LFxuICAgICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IFsuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBpbmRleDJdIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBpbnNlcnRSdWxlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZGVsZXRlUnVsZTtcbiAgICByZXBsYWNlICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IHJlcGxhY2UpO1xuICAgIHJlcGxhY2VTeW5jICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSByZXBsYWNlU3luYyk7XG4gICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKChbdHlwZUtleSwgdHlwZV0pID0+IHtcbiAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGU7XG4gICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKHtcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBzdHlsZXNoZWV0TWFuYWdlclxufSwgaG9zdDIpIHtcbiAgdmFyIF9hMiwgX2IsIF9jO1xuICBsZXQgaG9zdElkID0gbnVsbDtcbiAgaWYgKGhvc3QyLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiKSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGhvc3QyKTtcbiAgZWxzZSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGluZGV4Lmhvc3QoaG9zdDIpKTtcbiAgY29uc3QgcGF0Y2hUYXJnZXQgPSBob3N0Mi5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIiA/IChfYTIgPSBob3N0Mi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5Eb2N1bWVudCA6IChfYyA9IChfYiA9IGhvc3QyLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLlNoYWRvd1Jvb3Q7XG4gIGNvbnN0IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yID0gKHBhdGNoVGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUpID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBwYXRjaFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlLFxuICAgIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCJcbiAgKSA6IHZvaWQgMDtcbiAgaWYgKGhvc3RJZCA9PT0gbnVsbCB8fCBob3N0SWQgPT09IC0xIHx8ICFwYXRjaFRhcmdldCB8fCAhb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgIGdldCgpIHtcbiAgICAgIHZhciBfYTM7XG4gICAgICByZXR1cm4gKF9hMyA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0KHNoZWV0cykge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSAoX2EzID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcywgc2hlZXRzKTtcbiAgICAgIGlmIChob3N0SWQgIT09IG51bGwgJiYgaG9zdElkICE9PSAtMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGdldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgc2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXRcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKHtcbiAgc3R5bGVEZWNsYXJhdGlvbkNiLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gIHN0eWxlc2hlZXRNYW5hZ2VyXG59LCB7IHdpbiB9KSB7XG4gIGNvbnN0IHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xuICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcbiAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xuICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcbiAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gbmV3IFByb3h5KHJlbW92ZVByb3BlcnR5LCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgY29uc3QgW3Byb3BlcnR5XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICByZW1vdmU6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7XG4gIG1lZGlhSW50ZXJhY3Rpb25DYixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBzYW1wbGluZyxcbiAgZG9jXG59KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgKHR5cGUpID0+IHRocm90dGxlKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSwgbG9vcCB9ID0gdGFyZ2V0O1xuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgICB2b2x1bWUsXG4gICAgICAgICAgbXV0ZWQsXG4gICAgICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIHNhbXBsaW5nLm1lZGlhIHx8IDUwMFxuICAgIClcbiAgKTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgb24oXCJwbGF5XCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuUGxheSksIGRvYyksXG4gICAgb24oXCJwYXVzZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBhdXNlKSwgZG9jKSxcbiAgICBvbihcInNlZWtlZFwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlNlZWtlZCksIGRvYyksXG4gICAgb24oXCJ2b2x1bWVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5Wb2x1bWVDaGFuZ2UpLCBkb2MpLFxuICAgIG9uKFwicmF0ZWNoYW5nZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlJhdGVDaGFuZ2UpLCBkb2MpXG4gIF07XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdEZvbnRPYnNlcnZlcih7IGZvbnRDYiwgZG9jIH0pIHtcbiAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIXdpbikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBjb25zdCBmb250TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IG9yaWdpbmFsRm9udEZhY2UgPSB3aW4uRm9udEZhY2U7XG4gIHdpbi5Gb250RmFjZSA9IGZ1bmN0aW9uIEZvbnRGYWNlMihmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBmb250RmFjZSA9IG5ldyBvcmlnaW5hbEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycyk7XG4gICAgZm9udE1hcC5zZXQoZm9udEZhY2UsIHtcbiAgICAgIGZhbWlseSxcbiAgICAgIGJ1ZmZlcjogdHlwZW9mIHNvdXJjZSAhPT0gXCJzdHJpbmdcIixcbiAgICAgIGRlc2NyaXB0b3JzLFxuICAgICAgZm9udFNvdXJjZTogdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiA/IHNvdXJjZSA6IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoc291cmNlKSkpXG4gICAgfSk7XG4gICAgcmV0dXJuIGZvbnRGYWNlO1xuICB9O1xuICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgIGRvYy5mb250cyxcbiAgICBcImFkZFwiLFxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm9udEZhY2UpIHtcbiAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgIGZvbnRDYihwKTtcbiAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xuICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XG4gIH0pO1xuICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgY29uc3QgeyBkb2MsIG1pcnJvcjogbWlycm9yMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgfSA9IHBhcmFtO1xuICBsZXQgY29sbGFwc2VkID0gdHJ1ZTtcbiAgY29uc3QgdXBkYXRlU2VsZWN0aW9uID0gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgY29sbGFwc2VkICYmIChzZWxlY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkpIHJldHVybjtcbiAgICBjb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgZmFsc2U7XG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgY29uc3QgY291bnQgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fCAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjb3VudDsgaTIrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpMik7XG4gICAgICBjb25zdCB7IHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgfSA9IHJhbmdlO1xuICAgICAgY29uc3QgYmxvY2tlZCA9IGlzQmxvY2tlZChzdGFydENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkgfHwgaXNCbG9ja2VkKGVuZENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSk7XG4gICAgICBpZiAoYmxvY2tlZCkgY29udGludWU7XG4gICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBtaXJyb3IyLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZDogbWlycm9yMi5nZXRJZChlbmRDb250YWluZXIpLFxuICAgICAgICBlbmRPZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcbiAgfSk7XG4gIHVwZGF0ZVNlbGVjdGlvbigpO1xuICByZXR1cm4gb24oXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdXBkYXRlU2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIoe1xuICBkb2MsXG4gIGN1c3RvbUVsZW1lbnRDYlxufSkge1xuICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goXG4gICAgd2luLmN1c3RvbUVsZW1lbnRzLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XG4gICAgICAgICAgICBkZWZpbmU6IHtcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ3VzdG9tIGVsZW1lbnQgY2FsbGJhY2sgZmFpbGVkIGZvciAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9uc10pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIHJldHVybiByZXN0b3JlSGFuZGxlcjtcbn1cbmZ1bmN0aW9uIG1lcmdlSG9va3MobzIsIGhvb2tzKSB7XG4gIGNvbnN0IHtcbiAgICBtdXRhdGlvbkNiLFxuICAgIG1vdXNlbW92ZUNiLFxuICAgIG1vdXNlSW50ZXJhY3Rpb25DYixcbiAgICBzY3JvbGxDYixcbiAgICB2aWV3cG9ydFJlc2l6ZUNiLFxuICAgIGlucHV0Q2IsXG4gICAgbWVkaWFJbnRlcmFjdGlvbkNiLFxuICAgIHN0eWxlU2hlZXRSdWxlQ2IsXG4gICAgc3R5bGVEZWNsYXJhdGlvbkNiLFxuICAgIGNhbnZhc011dGF0aW9uQ2IsXG4gICAgZm9udENiLFxuICAgIHNlbGVjdGlvbkNiLFxuICAgIGN1c3RvbUVsZW1lbnRDYlxuICB9ID0gbzI7XG4gIG8yLm11dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5tdXRhdGlvbikge1xuICAgICAgaG9va3MubXV0YXRpb24oLi4ucCk7XG4gICAgfVxuICAgIG11dGF0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLm1vdXNlbW92ZUNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XG4gICAgICBob29rcy5tb3VzZW1vdmUoLi4ucCk7XG4gICAgfVxuICAgIG1vdXNlbW92ZUNiKC4uLnApO1xuICB9O1xuICBvMi5tb3VzZUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XG4gICAgICBob29rcy5tb3VzZUludGVyYWN0aW9uKC4uLnApO1xuICAgIH1cbiAgICBtb3VzZUludGVyYWN0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLnNjcm9sbENiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XG4gICAgICBob29rcy5zY3JvbGwoLi4ucCk7XG4gICAgfVxuICAgIHNjcm9sbENiKC4uLnApO1xuICB9O1xuICBvMi52aWV3cG9ydFJlc2l6ZUNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcbiAgICAgIGhvb2tzLnZpZXdwb3J0UmVzaXplKC4uLnApO1xuICAgIH1cbiAgICB2aWV3cG9ydFJlc2l6ZUNiKC4uLnApO1xuICB9O1xuICBvMi5pbnB1dENiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3MuaW5wdXQpIHtcbiAgICAgIGhvb2tzLmlucHV0KC4uLnApO1xuICAgIH1cbiAgICBpbnB1dENiKC4uLnApO1xuICB9O1xuICBvMi5tZWRpYUludGVyYWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcbiAgICAgIGhvb2tzLm1lZGlhSW50ZWFjdGlvbiguLi5wKTtcbiAgICB9XG4gICAgbWVkaWFJbnRlcmFjdGlvbkNiKC4uLnApO1xuICB9O1xuICBvMi5zdHlsZVNoZWV0UnVsZUNiID0gKC4uLnApID0+IHtcbiAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcbiAgICAgIGhvb2tzLnN0eWxlU2hlZXRSdWxlKC4uLnApO1xuICAgIH1cbiAgICBzdHlsZVNoZWV0UnVsZUNiKC4uLnApO1xuICB9O1xuICBvMi5zdHlsZURlY2xhcmF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XG4gICAgICBob29rcy5zdHlsZURlY2xhcmF0aW9uKC4uLnApO1xuICAgIH1cbiAgICBzdHlsZURlY2xhcmF0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLmNhbnZhc011dGF0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xuICAgICAgaG9va3MuY2FudmFzTXV0YXRpb24oLi4ucCk7XG4gICAgfVxuICAgIGNhbnZhc011dGF0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLmZvbnRDYiA9ICguLi5wKSA9PiB7XG4gICAgaWYgKGhvb2tzLmZvbnQpIHtcbiAgICAgIGhvb2tzLmZvbnQoLi4ucCk7XG4gICAgfVxuICAgIGZvbnRDYiguLi5wKTtcbiAgfTtcbiAgbzIuc2VsZWN0aW9uQ2IgPSAoLi4ucCkgPT4ge1xuICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcbiAgICAgIGhvb2tzLnNlbGVjdGlvbiguLi5wKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uQ2IoLi4ucCk7XG4gIH07XG4gIG8yLmN1c3RvbUVsZW1lbnRDYiA9ICguLi5jMikgPT4ge1xuICAgIGlmIChob29rcy5jdXN0b21FbGVtZW50KSB7XG4gICAgICBob29rcy5jdXN0b21FbGVtZW50KC4uLmMyKTtcbiAgICB9XG4gICAgY3VzdG9tRWxlbWVudENiKC4uLmMyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGluaXRPYnNlcnZlcnMobzIsIGhvb2tzID0ge30pIHtcbiAgY29uc3QgY3VycmVudFdpbmRvdyA9IG8yLmRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIG1lcmdlSG9va3MobzIsIGhvb2tzKTtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gIH1cbiAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8yKTtcbiAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobzIsIHtcbiAgICB3aW46IGN1cnJlbnRXaW5kb3dcbiAgfSk7XG4gIGNvbnN0IGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8yKTtcbiAgY29uc3QgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgbGV0IHN0eWxlU2hlZXRPYnNlcnZlciA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBmb250T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8yLCB7IHdpbjogY3VycmVudFdpbmRvdyB9KTtcbiAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvMiwge1xuICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgfSk7XG4gICAgaWYgKG8yLmNvbGxlY3RGb250cykge1xuICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8yKTtcbiAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvMik7XG4gIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XG4gIGZvciAoY29uc3QgcGx1Z2luMyBvZiBvMi5wbHVnaW5zKSB7XG4gICAgcGx1Z2luSGFuZGxlcnMucHVzaChcbiAgICAgIHBsdWdpbjMub2JzZXJ2ZXIocGx1Z2luMy5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luMy5vcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGIpID0+IGIucmVzZXQoKSk7XG4gICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xuICAgIG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc2Nyb2xsSGFuZGxlcigpO1xuICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xuICAgIGlucHV0SGFuZGxlcigpO1xuICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xuICAgIGZvbnRPYnNlcnZlcigpO1xuICAgIHNlbGVjdGlvbk9ic2VydmVyKCk7XG4gICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XG4gICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3dbcHJvcF0gIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIE5vdGU6IEdlbmVyYWxseSwgdGhpcyBjaGVjayBfc2hvdWxkbid0XyBiZSBuZWNlc3NhcnlcbiAgICAvLyBIb3dldmVyLCBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBqc2RvbSkgdGhpcyBjYW4gc29tZXRpbWVzIGZhaWwsIHNvIHdlIGNoZWNrIGZvciBpdCBoZXJlXG4gICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImluc2VydFJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmIFwiZGVsZXRlUnVsZVwiIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGVcbiAgKTtcbn1cbmNsYXNzIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZUlkVG9SZW1vdGVJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZVJlbW90ZUlkVG9JZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XG4gIH1cbiAgZ2V0SWQoaWZyYW1lLCByZW1vdGVJZCwgaWRUb1JlbW90ZU1hcCwgcmVtb3RlVG9JZE1hcCkge1xuICAgIGNvbnN0IGlkVG9SZW1vdGVJZE1hcCA9IGlkVG9SZW1vdGVNYXAgfHwgdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSByZW1vdGVUb0lkTWFwIHx8IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgbGV0IGlkID0gaWRUb1JlbW90ZUlkTWFwLmdldChyZW1vdGVJZCk7XG4gICAgaWYgKCFpZCkge1xuICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xuICAgICAgaWRUb1JlbW90ZUlkTWFwLnNldChyZW1vdGVJZCwgaWQpO1xuICAgICAgcmVtb3RlSWRUb0lkTWFwLnNldChpZCwgcmVtb3RlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZ2V0SWRzKGlmcmFtZSwgcmVtb3RlSWQpIHtcbiAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgcmV0dXJuIHJlbW90ZUlkLm1hcChcbiAgICAgIChpZCkgPT4gdGhpcy5nZXRJZChpZnJhbWUsIGlkLCBpZFRvUmVtb3RlSWRNYXAsIHJlbW90ZUlkVG9JZE1hcClcbiAgICApO1xuICB9XG4gIGdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIG1hcCkge1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IG1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwibnVtYmVyXCIpIHJldHVybiBpZDtcbiAgICBjb25zdCByZW1vdGVJZCA9IHJlbW90ZUlkVG9JZE1hcC5nZXQoaWQpO1xuICAgIGlmICghcmVtb3RlSWQpIHJldHVybiAtMTtcbiAgICByZXR1cm4gcmVtb3RlSWQ7XG4gIH1cbiAgZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XG4gICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICByZXR1cm4gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgcmVtb3RlSWRUb0lkTWFwKSk7XG4gIH1cbiAgcmVzZXQoaWZyYW1lKSB7XG4gICAgaWYgKCFpZnJhbWUpIHtcbiAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgfVxuICBnZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKSB7XG4gICAgbGV0IGlkVG9SZW1vdGVJZE1hcCA9IHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLmdldChpZnJhbWUpO1xuICAgIGlmICghaWRUb1JlbW90ZUlkTWFwKSB7XG4gICAgICBpZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuc2V0KGlmcmFtZSwgaWRUb1JlbW90ZUlkTWFwKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkVG9SZW1vdGVJZE1hcDtcbiAgfVxuICBnZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKSB7XG4gICAgbGV0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmdldChpZnJhbWUpO1xuICAgIGlmICghcmVtb3RlSWRUb0lkTWFwKSB7XG4gICAgICByZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuc2V0KGlmcmFtZSwgcmVtb3RlSWRUb0lkTWFwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZUlkVG9JZE1hcDtcbiAgfVxufVxuY2xhc3MgSWZyYW1lTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWZyYW1lc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3JcIiwgbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3cmFwcGVkRW1pdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9hZExpc3RlbmVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzXCIpO1xuICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICB0aGlzLndyYXBwZWRFbWl0ID0gb3B0aW9ucy53cmFwcGVkRW1pdDtcbiAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyID0gb3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICB0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IG9wdGlvbnMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzO1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihcbiAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IuZ2VuZXJhdGVJZC5iaW5kKFxuICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xuICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgYWRkSWZyYW1lKGlmcmFtZUVsKSB7XG4gICAgdGhpcy5pZnJhbWVzLnNldChpZnJhbWVFbCwgdHJ1ZSk7XG4gICAgaWYgKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpXG4gICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLnNldChpZnJhbWVFbC5jb250ZW50V2luZG93LCBpZnJhbWVFbCk7XG4gIH1cbiAgYWRkTG9hZExpc3RlbmVyKGNiKSB7XG4gICAgdGhpcy5sb2FkTGlzdGVuZXIgPSBjYjtcbiAgfVxuICBhdHRhY2hJZnJhbWUoaWZyYW1lRWwsIGNoaWxkU24pIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgYWRkczogW1xuICAgICAgICB7XG4gICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcbiAgICAgICAgICBuZXh0SWQ6IG51bGwsXG4gICAgICAgICAgbm9kZTogY2hpbGRTblxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmVtb3ZlczogW10sXG4gICAgICB0ZXh0czogW10sXG4gICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKVxuICAgICAgKF9hMiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIChfYiA9IHRoaXMubG9hZExpc3RlbmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBpZnJhbWVFbCk7XG4gICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcbiAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhcbiAgICAgICAgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyxcbiAgICAgICAgdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwuY29udGVudERvY3VtZW50KVxuICAgICAgKTtcbiAgfVxuICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudCA9IG1lc3NhZ2U7XG4gICAgaWYgKGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEudHlwZSAhPT0gXCJycndlYlwiIHx8IC8vIFRvIGZpbHRlciBvdXQgdGhlIHJyd2ViIG1lc3NhZ2VzIHdoaWNoIGFyZSBmb3J3YXJkZWQgYnkgc29tZSBzaXRlcy5cbiAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5vcmlnaW4gIT09IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEub3JpZ2luKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlmcmFtZVNvdXJjZVdpbmRvdyA9IG1lc3NhZ2Uuc291cmNlO1xuICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KSByZXR1cm47XG4gICAgY29uc3QgaWZyYW1lRWwgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLmdldChtZXNzYWdlLnNvdXJjZSk7XG4gICAgaWYgKCFpZnJhbWVFbCkgcmV0dXJuO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkRXZlbnQgPSB0aGlzLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoXG4gICAgICBpZnJhbWVFbCxcbiAgICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuZXZlbnRcbiAgICApO1xuICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KVxuICAgICAgdGhpcy53cmFwcGVkRW1pdChcbiAgICAgICAgdHJhbnNmb3JtZWRFdmVudCxcbiAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5pc0NoZWNrb3V0XG4gICAgICApO1xuICB9XG4gIHRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGUyKSB7XG4gICAgdmFyIF9hMjtcbiAgICBzd2l0Y2ggKGUyLnR5cGUpIHtcbiAgICAgIGNhc2UgRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdDoge1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoZTIuZGF0YS5ub2RlLCBpZnJhbWVFbCk7XG4gICAgICAgIGNvbnN0IHJvb3RJZCA9IGUyLmRhdGEubm9kZS5pZDtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XG4gICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZTIuZGF0YS5ub2RlLCByb290SWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpbWVzdGFtcDogZTIudGltZXN0YW1wLFxuICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlOiBlMi5kYXRhLm5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRXZlbnRUeXBlLk1ldGE6XG4gICAgICBjYXNlIEV2ZW50VHlwZS5Mb2FkOlxuICAgICAgY2FzZSBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZDoge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjYXNlIEV2ZW50VHlwZS5QbHVnaW46IHtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuQ3VzdG9tOiB7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkcyhcbiAgICAgICAgICBlMi5kYXRhLnBheWxvYWQsXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgW1wiaWRcIiwgXCJwYXJlbnRJZFwiLCBcInByZXZpb3VzSWRcIiwgXCJuZXh0SWRcIl1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdDoge1xuICAgICAgICBzd2l0Y2ggKGUyLmRhdGEuc291cmNlKSB7XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5hZGRzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0SWRcIixcbiAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIlxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobjIubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgIHJvb3RJZCAmJiB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKG4yLm5vZGUsIHJvb3RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUyLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJwYXJlbnRJZFwiLCBcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS50ZXh0cy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlOiB7XG4gICAgICAgICAgICBlMi5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNjcm9sbDpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wic3R5bGVJZFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRm9udDoge1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgW1wic3RhcnRcIiwgXCJlbmRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcInN0eWxlSWRzXCJdKTtcbiAgICAgICAgICAgIChfYTIgPSBlMi5kYXRhLnN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFtcInN0eWxlSWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgdHlwZW9mIG9ialtrZXldICE9PSBcIm51bWJlclwiKSBjb250aW51ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgb2JqW2tleV1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkKGlmcmFtZUVsLCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmVwbGFjZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlSWRPbk5vZGUobm9kZTIsIGlmcmFtZUVsKSB7XG4gICAgdGhpcy5yZXBsYWNlSWRzKG5vZGUyLCBpZnJhbWVFbCwgW1wiaWRcIiwgXCJyb290SWRcIl0pO1xuICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlMikge1xuICAgICAgbm9kZTIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShjaGlsZCwgaWZyYW1lRWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUyLCByb290SWQpIHtcbiAgICBpZiAobm9kZTIudHlwZSAhPT0gTm9kZVR5cGUuRG9jdW1lbnQgJiYgIW5vZGUyLnJvb3RJZCkgbm9kZTIucm9vdElkID0gcm9vdElkO1xuICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlMikge1xuICAgICAgbm9kZTIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKGNoaWxkLCByb290SWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBTaGFkb3dEb21NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dEb21zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2Nyb2xsQ2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJ5cGFzc09wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzdG9yZUhhbmRsZXJzXCIsIFtdKTtcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XG4gICAgdGhpcy5ieXBhc3NPcHRpb25zID0gb3B0aW9ucy5ieXBhc3NPcHRpb25zO1xuICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhFbGVtZW50LCBkb2N1bWVudCk7XG4gIH1cbiAgYWRkU2hhZG93Um9vdChzaGFkb3dSb290MiwgZG9jKSB7XG4gICAgaWYgKCFpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290MikpIHJldHVybjtcbiAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290MikpIHJldHVybjtcbiAgICB0aGlzLnNoYWRvd0RvbXMuYWRkKHNoYWRvd1Jvb3QyKTtcbiAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKFxuICAgICAge1xuICAgICAgICAuLi50aGlzLmJ5cGFzc09wdGlvbnMsXG4gICAgICAgIGRvYyxcbiAgICAgICAgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLFxuICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyOiB0aGlzXG4gICAgICB9LFxuICAgICAgc2hhZG93Um9vdDJcbiAgICApO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpKTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKFxuICAgICAgaW5pdFNjcm9sbE9ic2VydmVyKHtcbiAgICAgICAgLi4udGhpcy5ieXBhc3NPcHRpb25zLFxuICAgICAgICBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYixcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcHJhdmVlbnB1Z2xpYS8wODMyZGE2ODdlZDVhNWQ3YTA5MDcwNDZjOWVmMTgxM1xuICAgICAgICAvLyBzY3JvbGwgaXMgbm90IGFsbG93ZWQgdG8gcGFzcyB0aGUgYm91bmRhcnksIHNvIHdlIG5lZWQgdG8gbGlzdGVuIHRoZSBzaGFkb3cgZG9jdW1lbnRcbiAgICAgICAgZG9jOiBzaGFkb3dSb290MixcbiAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxuICAgICAgfSlcbiAgICApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHNoYWRvd1Jvb3QyLmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMClcbiAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoXG4gICAgICAgICAgc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICAgIHRoaXMubWlycm9yLmdldElkKGluZGV4Lmhvc3Qoc2hhZG93Um9vdDIpKVxuICAgICAgICApO1xuICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChcbiAgICAgICAgaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiB0aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNoYWRvd1Jvb3QyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCAnYXR0YWNoU2hhZG93JyBvZiBhbiBJRnJhbWVFbGVtZW50IHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqL1xuICBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcbiAgICBpZiAoIWlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdyB8fCAhaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpIHJldHVybjtcbiAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KFxuICAgICAgaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93LkVsZW1lbnQsXG4gICAgICBpZnJhbWVFbGVtZW50LmNvbnRlbnREb2N1bWVudFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoICdhdHRhY2hTaGFkb3cnIHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqL1xuICBwYXRjaEF0dGFjaFNoYWRvdyhlbGVtZW50LCBkb2MpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKFxuICAgICAgcGF0Y2goXG4gICAgICAgIGVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICBcImF0dGFjaFNoYWRvd1wiLFxuICAgICAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNSb290ID0gb3JpZ2luYWwuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdEVsID0gaW5kZXguc2hhZG93Um9vdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290RWwgJiYgaW5Eb20odGhpcykpXG4gICAgICAgICAgICAgIG1hbmFnZXIuYWRkU2hhZG93Um9vdChzaGFkb3dSb290RWwsIGRvYyk7XG4gICAgICAgICAgICByZXR1cm4gc1Jvb3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuc2hhZG93RG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICB9XG59XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoYXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpMiwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHtcbiAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTJdID4+IDJdO1xuICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaTJdICYgMykgPDwgNCB8IGJ5dGVzW2kyICsgMV0gPj4gNF07XG4gICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdO1xuICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpMiArIDJdICYgNjNdO1xuICB9XG4gIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gIH1cbiAgcmV0dXJuIGJhc2U2NDtcbn07XG5jb25zdCBjYW52YXNWYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBjdG9yKSB7XG4gIGxldCBjb250ZXh0TWFwID0gY2FudmFzVmFyTWFwLmdldChjdHgpO1xuICBpZiAoIWNvbnRleHRNYXApIHtcbiAgICBjb250ZXh0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjYW52YXNWYXJNYXAuc2V0KGN0eCwgY29udGV4dE1hcCk7XG4gIH1cbiAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xuICAgIGNvbnRleHRNYXAuc2V0KGN0b3IsIFtdKTtcbiAgfVxuICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XG59XG5jb25zdCBzYXZlV2ViR0xWYXIgPSAodmFsdWUsIHdpbiwgY3R4KSA9PiB7XG4gIGlmICghdmFsdWUgfHwgIShpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpKVxuICAgIHJldHVybjtcbiAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGNvbnN0IGxpc3QyID0gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBuYW1lKTtcbiAgbGV0IGluZGV4MiA9IGxpc3QyLmluZGV4T2YodmFsdWUpO1xuICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgIGluZGV4MiA9IGxpc3QyLmxlbmd0aDtcbiAgICBsaXN0Mi5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gaW5kZXgyO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFyZyh2YWx1ZSwgd2luLCBjdHgpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgcnJfdHlwZTogbmFtZSxcbiAgICAgIGFyZ3M6IFtPYmplY3QudmFsdWVzKHZhbHVlKV1cbiAgICB9O1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIFNoYXJlZEFycmF5QnVmZmVyIGRpc2FibGVkIG9uIG1vc3QgYnJvd3NlcnMgZHVlIHRvIHNwZWN0cmUuXG4gICAgLy8gTW9yZSBpbmZvOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TaGFyZWRBcnJheUJ1ZmZlci9TaGFyZWRBcnJheUJ1ZmZlclxuICAgIC8vIHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIgfHxcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICkge1xuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBiYXNlNjRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgcnJfdHlwZTogbmFtZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAgc2VyaWFsaXplQXJnKHZhbHVlLmJ1ZmZlciwgd2luLCBjdHgpLFxuICAgICAgICB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICBdXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCB7IHNyYyB9ID0gdmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICBjb25zdCBuYW1lID0gXCJIVE1MSW1hZ2VFbGVtZW50XCI7XG4gICAgY29uc3Qgc3JjID0gdmFsdWUudG9EYXRhVVJMKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBhcmdzOiBbc2VyaWFsaXplQXJnKHZhbHVlLmRhdGEsIHdpbiwgY3R4KSwgdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodF1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IGluZGV4MiA9IHNhdmVXZWJHTFZhcih2YWx1ZSwgd2luLCBjdHgpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgaW5kZXg6IGluZGV4MlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3Qgc2VyaWFsaXplQXJncyA9IChhcmdzLCB3aW4sIGN0eCkgPT4ge1xuICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpKTtcbn07XG5jb25zdCBpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCA9ICh2YWx1ZSwgd2luKSA9PiB7XG4gIGNvbnN0IHdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IFtcbiAgICBcIldlYkdMQWN0aXZlSW5mb1wiLFxuICAgIFwiV2ViR0xCdWZmZXJcIixcbiAgICBcIldlYkdMRnJhbWVidWZmZXJcIixcbiAgICBcIldlYkdMUHJvZ3JhbVwiLFxuICAgIFwiV2ViR0xSZW5kZXJidWZmZXJcIixcbiAgICBcIldlYkdMU2hhZGVyXCIsXG4gICAgXCJXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdFwiLFxuICAgIFwiV2ViR0xUZXh0dXJlXCIsXG4gICAgXCJXZWJHTFVuaWZvcm1Mb2NhdGlvblwiLFxuICAgIFwiV2ViR0xWZXJ0ZXhBcnJheU9iamVjdFwiLFxuICAgIC8vIEluIG9sZCBDaHJvbWUgdmVyc2lvbnMsIHZhbHVlIHdvbid0IGJlIGFuIGluc3RhbmNlb2YgV2ViR0xWZXJ0ZXhBcnJheU9iamVjdC5cbiAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RPRVNcIlxuICBdO1xuICBjb25zdCBzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMgPSB3ZWJHTENvbnN0cnVjdG9yTmFtZXMuZmlsdGVyKFxuICAgIChuYW1lKSA9PiB0eXBlb2Ygd2luW25hbWVdID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbmQoXG4gICAgICAobmFtZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiB3aW5bbmFtZV1cbiAgICApXG4gICk7XG59O1xuZnVuY3Rpb24gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIGNvbnN0IHByb3BzMkQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhcbiAgICB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVxuICApO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMyRCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgICAgICB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIoXG4gICAgICAgIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLFxuICAgICAgICBwcm9wLFxuICAgICAgICB7XG4gICAgICAgICAgc2V0KHYyKSB7XG4gICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICBhcmdzOiBbdjJdLFxuICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpIHtcbiAgcmV0dXJuIGNvbnRleHRUeXBlID09PSBcImV4cGVyaW1lbnRhbC13ZWJnbFwiID8gXCJ3ZWJnbFwiIDogY29udGV4dFR5cGU7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICAgIHdpbi5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICBcImdldENvbnRleHRcIixcbiAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0VHlwZSwgLi4uYXJncykge1xuICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHhOYW1lID0gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKTtcbiAgICAgICAgICAgIGlmICghKFwiX19jb250ZXh0XCIgaW4gdGhpcykpIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcbiAgICAgICAgICAgIGlmIChzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUgJiYgW1wid2ViZ2xcIiwgXCJ3ZWJnbDJcIl0uaW5jbHVkZXMoY3R4TmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDEsIHtcbiAgICAgICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbY29udGV4dFR5cGUsIC4uLmFyZ3NdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICB9IGNhdGNoIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIHBhdGNoIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0XCIpO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGNoR0xQcm90b3R5cGUocHJvdG90eXBlLCB0eXBlLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgd2luKSB7XG4gIGNvbnN0IGhhbmRsZXJzID0gW107XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgaWYgKFxuICAgICAgLy9wcm9wLnN0YXJ0c1dpdGgoJ2dldCcpIHx8ICAvLyBlLmcuIGdldFByb2dyYW1QYXJhbWV0ZXIsIGJ1dCB0b28gcmlza3lcbiAgICAgIFtcbiAgICAgICAgXCJpc0NvbnRleHRMb3N0XCIsXG4gICAgICAgIFwiY2FudmFzXCIsXG4gICAgICAgIFwiZHJhd2luZ0J1ZmZlcldpZHRoXCIsXG4gICAgICAgIFwiZHJhd2luZ0J1ZmZlckhlaWdodFwiXG4gICAgICBdLmluY2x1ZGVzKHByb3ApXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgICAgICBwcm90b3R5cGUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHNhdmVXZWJHTFZhcihyZXN1bHQyLCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKFwidGFnTmFtZVwiIGluIHRoaXMuY2FudmFzICYmICFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywgbXV0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc3QgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICBzZXQodjIpIHtcbiAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgYXJnczogW3YyXSxcbiAgICAgICAgICAgIHNldHRlcjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlcnM7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgaGFuZGxlcnMucHVzaChcbiAgICAuLi5wYXRjaEdMUHJvdG90eXBlKFxuICAgICAgd2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsXG4gICAgICBDYW52YXNDb250ZXh0LldlYkdMLFxuICAgICAgY2IsXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHdpblxuICAgIClcbiAgKTtcbiAgaWYgKHR5cGVvZiB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGhhbmRsZXJzLnB1c2goXG4gICAgICAuLi5wYXRjaEdMUHJvdG90eXBlKFxuICAgICAgICB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsXG4gICAgICAgIENhbnZhc0NvbnRleHQuV2ViR0wyLFxuICAgICAgICBjYixcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgd2luXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5jb25zdCBlbmNvZGVkSnMgPSBcIktHWjFibU4wYVc5dUtDa2dld29nSUNKMWMyVWdjM1J5YVdOMElqc0tJQ0IyWVhJZ1kyaGhjbk1nUFNBaVFVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UxUlZWbGRZV1ZwaFltTmtaV1puYUdscWEyeHRibTl3Y1hKemRIVjJkM2g1ZWpBeE1qTTBOVFkzT0Rrckx5STdDaUFnZG1GeUlHeHZiMnQxY0NBOUlIUjVjR1Z2WmlCVmFXNTBPRUZ5Y21GNUlEMDlQU0FpZFc1a1pXWnBibVZrSWlBL0lGdGRJRG9nYm1WM0lGVnBiblE0UVhKeVlYa29NalUyS1RzS0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05vWVhKekxteGxibWQwYURzZ2FTc3JLU0I3Q2lBZ0lDQnNiMjlyZFhCYlkyaGhjbk11WTJoaGNrTnZaR1ZCZENocEtWMGdQU0JwT3dvZ0lIMEtJQ0IyWVhJZ1pXNWpiMlJsSUQwZ1puVnVZM1JwYjI0b1lYSnlZWGxpZFdabVpYSXBJSHNLSUNBZ0lIWmhjaUJpZVhSbGN5QTlJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHRnljbUY1WW5WbVptVnlLU3dnYVRJc0lHeGxiaUE5SUdKNWRHVnpMbXhsYm1kMGFDd2dZbUZ6WlRZMElEMGdJaUk3Q2lBZ0lDQm1iM0lnS0dreUlEMGdNRHNnYVRJZ1BDQnNaVzQ3SUdreUlDczlJRE1wSUhzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXMko1ZEdWelcya3lYU0ErUGlBeVhUc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6V3loaWVYUmxjMXRwTWwwZ0ppQXpLU0E4UENBMElId2dZbmwwWlhOYmFUSWdLeUF4WFNBK1BpQTBYVHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKeld5aGllWFJsYzF0cE1pQXJJREZkSUNZZ01UVXBJRHc4SURJZ2ZDQmllWFJsYzF0cE1pQXJJREpkSUQ0K0lEWmRPd29nSUNBZ0lDQmlZWE5sTmpRZ0t6MGdZMmhoY25OYllubDBaWE5iYVRJZ0t5QXlYU0FtSURZelhUc0tJQ0FnSUgwS0lDQWdJR2xtSUNoc1pXNGdKU0F6SUQwOVBTQXlLU0I3Q2lBZ0lDQWdJR0poYzJVMk5DQTlJR0poYzJVMk5DNXpkV0p6ZEhKcGJtY29NQ3dnWW1GelpUWTBMbXhsYm1kMGFDQXRJREVwSUNzZ0lqMGlPd29nSUNBZ2ZTQmxiSE5sSUdsbUlDaHNaVzRnSlNBeklEMDlQU0F4S1NCN0NpQWdJQ0FnSUdKaGMyVTJOQ0E5SUdKaGMyVTJOQzV6ZFdKemRISnBibWNvTUN3Z1ltRnpaVFkwTG14bGJtZDBhQ0F0SURJcElDc2dJajA5SWpzS0lDQWdJSDBLSUNBZ0lISmxkSFZ5YmlCaVlYTmxOalE3Q2lBZ2ZUc0tJQ0JqYjI1emRDQnNZWE4wUW14dllrMWhjQ0E5SUM4cUlFQmZYMUJWVWtWZlh5QXFMeUJ1WlhjZ1RXRndLQ2s3Q2lBZ1kyOXVjM1FnZEhKaGJuTndZWEpsYm5SQ2JHOWlUV0Z3SUQwZ0x5b2dRRjlmVUZWU1JWOWZJQ292SUc1bGR5Qk5ZWEFvS1RzS0lDQmhjM2x1WXlCbWRXNWpkR2x2YmlCblpYUlVjbUZ1YzNCaGNtVnVkRUpzYjJKR2IzSW9kMmxrZEdnc0lHaGxhV2RvZEN3Z1pHRjBZVlZTVEU5d2RHbHZibk1wSUhzS0lDQWdJR052Ym5OMElHbGtJRDBnWUNSN2QybGtkR2g5TFNSN2FHVnBaMmgwZldBN0NpQWdJQ0JwWmlBb0lrOW1abk5qY21WbGJrTmhiblpoY3lJZ2FXNGdaMnh2WW1Gc1ZHaHBjeWtnZXdvZ0lDQWdJQ0JwWmlBb2RISmhibk53WVhKbGJuUkNiRzlpVFdGd0xtaGhjeWhwWkNrcElISmxkSFZ5YmlCMGNtRnVjM0JoY21WdWRFSnNiMkpOWVhBdVoyVjBLR2xrS1RzS0lDQWdJQ0FnWTI5dWMzUWdiMlptYzJOeVpXVnVJRDBnYm1WM0lFOW1abk5qY21WbGJrTmhiblpoY3loM2FXUjBhQ3dnYUdWcFoyaDBLVHNLSUNBZ0lDQWdiMlptYzJOeVpXVnVMbWRsZEVOdmJuUmxlSFFvSWpKa0lpazdDaUFnSUNBZ0lHTnZibk4wSUdKc2IySWdQU0JoZDJGcGRDQnZabVp6WTNKbFpXNHVZMjl1ZG1WeWRGUnZRbXh2WWloa1lYUmhWVkpNVDNCMGFXOXVjeWs3Q2lBZ0lDQWdJR052Ym5OMElHRnljbUY1UW5WbVptVnlJRDBnWVhkaGFYUWdZbXh2WWk1aGNuSmhlVUoxWm1abGNpZ3BPd29nSUNBZ0lDQmpiMjV6ZENCaVlYTmxOalFnUFNCbGJtTnZaR1VvWVhKeVlYbENkV1ptWlhJcE93b2dJQ0FnSUNCMGNtRnVjM0JoY21WdWRFSnNiMkpOWVhBdWMyVjBLR2xrTENCaVlYTmxOalFwT3dvZ0lDQWdJQ0J5WlhSMWNtNGdZbUZ6WlRZME93b2dJQ0FnZlNCbGJITmxJSHNLSUNBZ0lDQWdjbVYwZFhKdUlDSWlPd29nSUNBZ2ZRb2dJSDBLSUNCamIyNXpkQ0IzYjNKclpYSWdQU0J6Wld4bU93b2dJSGR2Y210bGNpNXZibTFsYzNOaFoyVWdQU0JoYzNsdVl5Qm1kVzVqZEdsdmJpaGxLU0I3Q2lBZ0lDQnBaaUFvSWs5bVpuTmpjbVZsYmtOaGJuWmhjeUlnYVc0Z1oyeHZZbUZzVkdocGN5a2dld29nSUNBZ0lDQmpiMjV6ZENCN0lHbGtMQ0JpYVhSdFlYQXNJSGRwWkhSb0xDQm9aV2xuYUhRc0lHUmhkR0ZWVWt4UGNIUnBiMjV6SUgwZ1BTQmxMbVJoZEdFN0NpQWdJQ0FnSUdOdmJuTjBJSFJ5WVc1emNHRnlaVzUwUW1GelpUWTBJRDBnWjJWMFZISmhibk53WVhKbGJuUkNiRzlpUm05eUtBb2dJQ0FnSUNBZ0lIZHBaSFJvTEFvZ0lDQWdJQ0FnSUdobGFXZG9kQ3dLSUNBZ0lDQWdJQ0JrWVhSaFZWSk1UM0IwYVc5dWN3b2dJQ0FnSUNBcE93b2dJQ0FnSUNCamIyNXpkQ0J2Wm1aelkzSmxaVzRnUFNCdVpYY2dUMlptYzJOeVpXVnVRMkZ1ZG1GektIZHBaSFJvTENCb1pXbG5hSFFwT3dvZ0lDQWdJQ0JqYjI1emRDQmpkSGdnUFNCdlptWnpZM0psWlc0dVoyVjBRMjl1ZEdWNGRDZ2lNbVFpS1RzS0lDQWdJQ0FnWTNSNExtUnlZWGRKYldGblpTaGlhWFJ0WVhBc0lEQXNJREFwT3dvZ0lDQWdJQ0JpYVhSdFlYQXVZMnh2YzJVb0tUc0tJQ0FnSUNBZ1kyOXVjM1FnWW14dllpQTlJR0YzWVdsMElHOW1abk5qY21WbGJpNWpiMjUyWlhKMFZHOUNiRzlpS0dSaGRHRlZVa3hQY0hScGIyNXpLVHNLSUNBZ0lDQWdZMjl1YzNRZ2RIbHdaU0E5SUdKc2IySXVkSGx3WlRzS0lDQWdJQ0FnWTI5dWMzUWdZWEp5WVhsQ2RXWm1aWElnUFNCaGQyRnBkQ0JpYkc5aUxtRnljbUY1UW5WbVptVnlLQ2s3Q2lBZ0lDQWdJR052Ym5OMElHSmhjMlUyTkNBOUlHVnVZMjlrWlNoaGNuSmhlVUoxWm1abGNpazdDaUFnSUNBZ0lHbG1JQ2doYkdGemRFSnNiMkpOWVhBdWFHRnpLR2xrS1NBbUppQmhkMkZwZENCMGNtRnVjM0JoY21WdWRFSmhjMlUyTkNBOVBUMGdZbUZ6WlRZMEtTQjdDaUFnSUNBZ0lDQWdiR0Z6ZEVKc2IySk5ZWEF1YzJWMEtHbGtMQ0JpWVhObE5qUXBPd29nSUNBZ0lDQWdJSEpsZEhWeWJpQjNiM0pyWlhJdWNHOXpkRTFsYzNOaFoyVW9leUJwWkNCOUtUc0tJQ0FnSUNBZ2ZRb2dJQ0FnSUNCcFppQW9iR0Z6ZEVKc2IySk5ZWEF1WjJWMEtHbGtLU0E5UFQwZ1ltRnpaVFkwS1NCeVpYUjFjbTRnZDI5eWEyVnlMbkJ2YzNSTlpYTnpZV2RsS0hzZ2FXUWdmU2s3Q2lBZ0lDQWdJSGR2Y210bGNpNXdiM04wVFdWemMyRm5aU2g3Q2lBZ0lDQWdJQ0FnYVdRc0NpQWdJQ0FnSUNBZ2RIbHdaU3dLSUNBZ0lDQWdJQ0JpWVhObE5qUXNDaUFnSUNBZ0lDQWdkMmxrZEdnc0NpQWdJQ0FnSUNBZ2FHVnBaMmgwQ2lBZ0lDQWdJSDBwT3dvZ0lDQWdJQ0JzWVhOMFFteHZZazFoY0M1elpYUW9hV1FzSUdKaGMyVTJOQ2s3Q2lBZ0lDQjlJR1ZzYzJVZ2V3b2dJQ0FnSUNCeVpYUjFjbTRnZDI5eWEyVnlMbkJ2YzNSTlpYTnpZV2RsS0hzZ2FXUTZJR1V1WkdGMFlTNXBaQ0I5S1RzS0lDQWdJSDBLSUNCOU93cDlLU2dwT3dvdkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMXBiV0ZuWlMxaWFYUnRZWEF0WkdGMFlTMTFjbXd0ZDI5eWEyVnlMVWxLY0VNM1oxOWlMbXB6TG0xaGNBbz1cIjtcbmNvbnN0IGRlY29kZUJhc2U2NCA9IChiYXNlNjQpID0+IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJhc2U2NCksIChjMikgPT4gYzIuY2hhckNvZGVBdCgwKSk7XG5jb25zdCBibG9iID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuQmxvYiAmJiBuZXcgQmxvYihbZGVjb2RlQmFzZTY0KGVuY29kZWRKcyldLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLThcIiB9KTtcbmZ1bmN0aW9uIFdvcmtlcldyYXBwZXIob3B0aW9ucykge1xuICBsZXQgb2JqVVJMO1xuICB0cnkge1xuICAgIG9ialVSTCA9IGJsb2IgJiYgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGlmICghb2JqVVJMKSB0aHJvdyBcIlwiO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIob2JqVVJMLCB7XG4gICAgICBuYW1lOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWVcbiAgICB9KTtcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgIH0pO1xuICAgIHJldHVybiB3b3JrZXI7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIoXG4gICAgICBcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGVuY29kZWRKcyxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lXG4gICAgICB9XG4gICAgKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBvYmpVUkwgJiYgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKG9ialVSTCk7XG4gIH1cbn1cbmNsYXNzIENhbnZhc01hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlbmRpbmdDYW52YXNNdXRhdGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJhZlN0YW1wc1wiLCB7IGxhdGVzdElkOiAwLCBpbnZva2VJZDogbnVsbCB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNldE9ic2VydmVyc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJvemVuXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9ja2VkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uXCIsICh0YXJnZXQsIG11dGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBuZXdGcmFtZSA9IHRoaXMucmFmU3RhbXBzLmludm9rZUlkICYmIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcbiAgICAgIGlmIChuZXdGcmFtZSB8fCAhdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpXG4gICAgICAgIHRoaXMucmFmU3RhbXBzLmludm9rZUlkID0gdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldCh0YXJnZXQpLnB1c2gobXV0YXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHNhbXBsaW5nID0gXCJhbGxcIixcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgZGF0YVVSTE9wdGlvbnNcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICBpZiAocmVjb3JkQ2FudmFzICYmIHNhbXBsaW5nID09PSBcImFsbFwiKVxuICAgICAgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSBcIm51bWJlclwiKVxuICAgICAgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xuICAgICAgICBkYXRhVVJMT3B0aW9uc1xuICAgICAgfSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5yZXNldE9ic2VydmVycyAmJiB0aGlzLnJlc2V0T2JzZXJ2ZXJzKCk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgfVxuICB1bmZyZWV6ZSgpIHtcbiAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICB9XG4gIHVubG9jaygpIHtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB9XG4gIGluaXRDYW52YXNGUFNPYnNlcnZlcihmcHMsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIoXG4gICAgICB3aW4sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbnN0IHNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcldyYXBwZXIoKTtcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKGUyKSA9PiB7XG4gICAgICBjb25zdCB7IGlkIH0gPSBlMi5kYXRhO1xuICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgZmFsc2UpO1xuICAgICAgaWYgKCEoXCJiYXNlNjRcIiBpbiBlMi5kYXRhKSkgcmV0dXJuO1xuICAgICAgY29uc3QgeyBiYXNlNjQsIHR5cGUsIHdpZHRoLCBoZWlnaHQgfSA9IGUyLmRhdGE7XG4gICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICBjb21tYW5kczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImNsZWFyUmVjdFwiLFxuICAgICAgICAgICAgLy8gd2lwZSBjYW52YXNcbiAgICAgICAgICAgIGFyZ3M6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvcGVydHk6IFwiZHJhd0ltYWdlXCIsXG4gICAgICAgICAgICAvLyBkcmF3cyAoc2VtaS10cmFuc3BhcmVudCkgaW1hZ2VcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiSW1hZ2VCaXRtYXBcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiQmxvYlwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbeyBycl90eXBlOiBcIkFycmF5QnVmZmVyXCIsIGJhc2U2NCB9XSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDFlMyAvIGZwcztcbiAgICBsZXQgbGFzdFNuYXBzaG90VGltZSA9IDA7XG4gICAgbGV0IHJhZklkO1xuICAgIGNvbnN0IGdldENhbnZhcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZWRDYW52YXMgPSBbXTtcbiAgICAgIHdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiY2FudmFzXCIpLmZvckVhY2goKGNhbnZhcykgPT4ge1xuICAgICAgICBpZiAoIWlzQmxvY2tlZChjYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgbWF0Y2hlZENhbnZhcy5wdXNoKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XG4gICAgfTtcbiAgICBjb25zdCB0YWtlQ2FudmFzU25hcHNob3RzID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgaWYgKGxhc3RTbmFwc2hvdFRpbWUgJiYgdGltZXN0YW1wIC0gbGFzdFNuYXBzaG90VGltZSA8IHRpbWVCZXR3ZWVuU25hcHNob3RzKSB7XG4gICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xuICAgICAgZ2V0Q2FudmFzKCkuZm9yRWFjaChhc3luYyAoY2FudmFzKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcbiAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKSByZXR1cm47XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKFtcIndlYmdsXCIsIFwid2ViZ2wyXCJdLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xuICAgICAgICAgIGlmICgoKF9hMiA9IGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGV4dC5jbGVhcihjb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChjYW52YXMpO1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBiaXRtYXAsXG4gICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtiaXRtYXBdXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgIH07XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XG4gICAgdGhpcy5yZXNldE9ic2VydmVycyA9ICgpID0+IHtcbiAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgIH07XG4gIH1cbiAgaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgdGhpcy5zdGFydFJBRlRpbWVzdGFtcGluZygpO1xuICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XG4gICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcihcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGNvbnN0IGNhbnZhczJEUmVzZXQgPSBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yXG4gICAgKTtcbiAgICBjb25zdCBjYW52YXNXZWJHTDFhbmQyUmVzZXQgPSBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHdpbixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yXG4gICAgKTtcbiAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gKCkgPT4ge1xuICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XG4gICAgICBjYW52YXMyRFJlc2V0KCk7XG4gICAgICBjYW52YXNXZWJHTDFhbmQyUmVzZXQoKTtcbiAgICB9O1xuICB9XG4gIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSk7XG4gIH1cbiAgc3RhcnRSQUZUaW1lc3RhbXBpbmcoKSB7XG4gICAgY29uc3Qgc2V0TGF0ZXN0UkFGVGltZXN0YW1wID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgPSB0aW1lc3RhbXA7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgICB9O1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xuICB9XG4gIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpIHtcbiAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZm9yRWFjaChcbiAgICAgIChfdmFsdWVzLCBjYW52YXMpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xuICAgICAgICB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xuICB9XG4gIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpIHtcbiAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzV2l0aFR5cGUgPSB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KGNhbnZhcyk7XG4gICAgaWYgKCF2YWx1ZXNXaXRoVHlwZSB8fCBpZCA9PT0gLTEpIHJldHVybjtcbiAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZXNXaXRoVHlwZS5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7IHR5cGU6IHR5cGUyLCAuLi5yZXN0IH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gdmFsdWVzV2l0aFR5cGVbMF07XG4gICAgdGhpcy5tdXRhdGlvbkNiKHsgaWQsIHR5cGUsIGNvbW1hbmRzOiB2YWx1ZXMgfSk7XG4gICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmRlbGV0ZShjYW52YXMpO1xuICB9XG59XG5jbGFzcyBTdHlsZXNoZWV0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHJhY2tlZExpbmtFbGVtZW50c1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkb3B0ZWRTdHlsZVNoZWV0Q2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlTWlycm9yXCIsIG5ldyBTdHlsZVNoZWV0TWlycm9yKCkpO1xuICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IgPSBvcHRpb25zLmFkb3B0ZWRTdHlsZVNoZWV0Q2I7XG4gIH1cbiAgYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKSB7XG4gICAgaWYgKFwiX2Nzc1RleHRcIiBpbiBjaGlsZFNuLmF0dHJpYnV0ZXMpXG4gICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICBhZGRzOiBbXSxcbiAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBjaGlsZFNuLmlkLFxuICAgICAgICAgICAgYXR0cmlidXRlczogY2hpbGRTbi5hdHRyaWJ1dGVzXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB0aGlzLnRyYWNrTGlua0VsZW1lbnQobGlua0VsKTtcbiAgfVxuICB0cmFja0xpbmtFbGVtZW50KGxpbmtFbCkge1xuICAgIGlmICh0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuaGFzKGxpbmtFbCkpIHJldHVybjtcbiAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuYWRkKGxpbmtFbCk7XG4gICAgdGhpcy50cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KGxpbmtFbCk7XG4gIH1cbiAgYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCkge1xuICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgYWRvcHRlZFN0eWxlU2hlZXREYXRhID0ge1xuICAgICAgaWQ6IGhvc3RJZCxcbiAgICAgIHN0eWxlSWRzOiBbXVxuICAgIH07XG4gICAgY29uc3Qgc3R5bGVzID0gW107XG4gICAgZm9yIChjb25zdCBzaGVldCBvZiBzaGVldHMpIHtcbiAgICAgIGxldCBzdHlsZUlkO1xuICAgICAgaWYgKCF0aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcbiAgICAgICAgc3R5bGVJZCA9IHRoaXMuc3R5bGVNaXJyb3IuYWRkKHNoZWV0KTtcbiAgICAgICAgc3R5bGVzLnB1c2goe1xuICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgcnVsZXM6IEFycmF5LmZyb20oc2hlZXQucnVsZXMgfHwgQ1NTUnVsZSwgKHIyLCBpbmRleDIpID0+ICh7XG4gICAgICAgICAgICBydWxlOiBzdHJpbmdpZnlSdWxlKHIyLCBzaGVldC5ocmVmKSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Ugc3R5bGVJZCA9IHRoaXMuc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XG4gICAgfVxuICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlcyA9IHN0eWxlcztcbiAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IoYWRvcHRlZFN0eWxlU2hlZXREYXRhKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0eWxlTWlycm9yLnJlc2V0KCk7XG4gICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gIH1cbiAgLy8gVE9ETzogdGFrZSBzbmFwc2hvdCBvbiBzdHlsZXNoZWV0IHJlbG9hZCBieSBhcHBseWluZyBldmVudCBsaXN0ZW5lclxuICB0cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KF9saW5rRWwpIHtcbiAgfVxufVxuY2xhc3MgUHJvY2Vzc2VkTm9kZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibm9kZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFjdGl2ZVwiLCBmYWxzZSk7XG4gIH1cbiAgaW5PdGhlckJ1ZmZlcihub2RlMiwgdGhpc0J1ZmZlcikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKTtcbiAgICByZXR1cm4gYnVmZmVycyAmJiBBcnJheS5mcm9tKGJ1ZmZlcnMpLnNvbWUoKGJ1ZmZlcikgPT4gYnVmZmVyICE9PSB0aGlzQnVmZmVyKTtcbiAgfVxuICBhZGQobm9kZTIsIGJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMubm9kZU1hcC5zZXQobm9kZTIsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKS5hZGQoYnVmZmVyKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxubGV0IHdyYXBwZWRFbWl0O1xubGV0IHRha2VGdWxsU25hcHNob3QkMTtcbmxldCBjYW52YXNNYW5hZ2VyO1xubGV0IHJlY29yZGluZyA9IGZhbHNlO1xudHJ5IHtcbiAgaWYgKEFycmF5LmZyb20oWzFdLCAoeDIpID0+IHgyICogMilbMF0gIT09IDIpIHtcbiAgICBjb25zdCBjbGVhbkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsZWFuRnJhbWUpO1xuICAgIEFycmF5LmZyb20gPSAoKF9hID0gY2xlYW5GcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuQXJyYXkuZnJvbSkgfHwgQXJyYXkuZnJvbTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsZWFuRnJhbWUpO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgY29uc29sZS5kZWJ1ZyhcIlVuYWJsZSB0byBvdmVycmlkZSBBcnJheS5mcm9tXCIsIGVycik7XG59XG5jb25zdCBtaXJyb3IgPSBjcmVhdGVNaXJyb3IkMigpO1xuZnVuY3Rpb24gcmVjb3JkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZW1pdCxcbiAgICBjaGVja291dEV2ZXJ5Tm1zLFxuICAgIGNoZWNrb3V0RXZlcnlOdGgsXG4gICAgYmxvY2tDbGFzcyA9IFwicnItYmxvY2tcIixcbiAgICBibG9ja1NlbGVjdG9yID0gbnVsbCxcbiAgICBpZ25vcmVDbGFzcyA9IFwicnItaWdub3JlXCIsXG4gICAgaWdub3JlU2VsZWN0b3IgPSBudWxsLFxuICAgIG1hc2tUZXh0Q2xhc3MgPSBcInJyLW1hc2tcIixcbiAgICBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSxcbiAgICBtYXNrQWxsSW5wdXRzLFxuICAgIG1hc2tJbnB1dE9wdGlvbnM6IF9tYXNrSW5wdXRPcHRpb25zLFxuICAgIHNsaW1ET01PcHRpb25zOiBfc2xpbURPTU9wdGlvbnMsXG4gICAgbWFza0lucHV0Rm4sXG4gICAgbWFza1RleHRGbixcbiAgICBob29rcyxcbiAgICBwYWNrRm4sXG4gICAgc2FtcGxpbmcgPSB7fSxcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIG1vdXNlbW92ZVdhaXQsXG4gICAgcmVjb3JkRE9NID0gdHJ1ZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBmYWxzZSxcbiAgICByZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiID8gb3B0aW9ucy5yZWNvcmRBZnRlciA6IFwibG9hZFwiLFxuICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsXG4gICAgY29sbGVjdEZvbnRzID0gZmFsc2UsXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcGx1Z2lucyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pLFxuICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyMlxuICB9ID0gb3B0aW9ucztcbiAgcmVnaXN0ZXJFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyMik7XG4gIGNvbnN0IGluRW1pdHRpbmdGcmFtZSA9IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdyA6IHRydWU7XG4gIGxldCBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xuICBpZiAoIWluRW1pdHRpbmdGcmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAod2luZG93LnBhcmVudC5kb2N1bWVudCkge1xuICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpbkVtaXR0aW5nRnJhbWUgJiYgIWVtaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbWl0IGZ1bmN0aW9uIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmICghaW5FbWl0dGluZ0ZyYW1lICYmICFwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBpZiAobW91c2Vtb3ZlV2FpdCAhPT0gdm9pZCAwICYmIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gdm9pZCAwKSB7XG4gICAgc2FtcGxpbmcubW91c2Vtb3ZlID0gbW91c2Vtb3ZlV2FpdDtcbiAgfVxuICBtaXJyb3IucmVzZXQoKTtcbiAgY29uc3QgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgY29sb3I6IHRydWUsXG4gICAgZGF0ZTogdHJ1ZSxcbiAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgZW1haWw6IHRydWUsXG4gICAgbW9udGg6IHRydWUsXG4gICAgbnVtYmVyOiB0cnVlLFxuICAgIHJhbmdlOiB0cnVlLFxuICAgIHNlYXJjaDogdHJ1ZSxcbiAgICB0ZWw6IHRydWUsXG4gICAgdGV4dDogdHJ1ZSxcbiAgICB0aW1lOiB0cnVlLFxuICAgIHVybDogdHJ1ZSxcbiAgICB3ZWVrOiB0cnVlLFxuICAgIHRleHRhcmVhOiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZSxcbiAgICBwYXNzd29yZDogdHJ1ZVxuICB9IDogX21hc2tJbnB1dE9wdGlvbnMgIT09IHZvaWQgMCA/IF9tYXNrSW5wdXRPcHRpb25zIDogeyBwYXNzd29yZDogdHJ1ZSB9O1xuICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIgPyB7XG4gICAgc2NyaXB0OiB0cnVlLFxuICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb2ZmIGZvciBzbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSxcbiAgICAvLyBhcyB0aGV5IGRlc3Ryb3kgc29tZSAoaGlkZGVuKSBpbmZvOlxuICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIsXG4gICAgaGVhZFRpdGxlTXV0YXRpb25zOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCJcbiAgfSA6IF9zbGltRE9NT3B0aW9ucyA/IF9zbGltRE9NT3B0aW9ucyA6IHt9O1xuICBwb2x5ZmlsbCQxKCk7XG4gIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XG4gIGxldCBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICBjb25zdCBldmVudFByb2Nlc3NvciA9IChlMikgPT4ge1xuICAgIGZvciAoY29uc3QgcGx1Z2luMyBvZiBwbHVnaW5zIHx8IFtdKSB7XG4gICAgICBpZiAocGx1Z2luMy5ldmVudFByb2Nlc3Nvcikge1xuICAgICAgICBlMiA9IHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IoZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFja0ZuICYmIC8vIERpc2FibGUgcGFja2luZyBldmVudHMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIHRvIHBhcmVudCBmcmFtZXMuXG4gICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICBlMiA9IHBhY2tGbihlMik7XG4gICAgfVxuICAgIHJldHVybiBlMjtcbiAgfTtcbiAgd3JhcHBlZEVtaXQgPSAocjIsIGlzQ2hlY2tvdXQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IGUyID0gcjI7XG4gICAgZTIudGltZXN0YW1wID0gbm93VGltZXN0YW1wKCk7XG4gICAgaWYgKCgoX2EyID0gbXV0YXRpb25CdWZmZXJzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlzRnJvemVuKCkpICYmIGUyLnR5cGUgIT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QgJiYgIShlMi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCAmJiBlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24pKSB7XG4gICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5mcmVlemUoKSk7XG4gICAgfVxuICAgIGlmIChpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICAgIGVtaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGVtaXQoZXZlbnRQcm9jZXNzb3IoZTIpLCBpc0NoZWNrb3V0KTtcbiAgICB9IGVsc2UgaWYgKHBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBcInJyd2ViXCIsXG4gICAgICAgIGV2ZW50OiBldmVudFByb2Nlc3NvcihlMiksXG4gICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgaXNDaGVja291dFxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgXCIqXCIpO1xuICAgIH1cbiAgICBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCkge1xuICAgICAgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50ID0gZTI7XG4gICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QpIHtcbiAgICAgIGlmIChlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24gJiYgZTIuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQrKztcbiAgICAgIGNvbnN0IGV4Y2VlZENvdW50ID0gY2hlY2tvdXRFdmVyeU50aCAmJiBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPj0gY2hlY2tvdXRFdmVyeU50aDtcbiAgICAgIGNvbnN0IGV4Y2VlZFRpbWUgPSBjaGVja291dEV2ZXJ5Tm1zICYmIGUyLnRpbWVzdGFtcCAtIGxhc3RGdWxsU25hcHNob3RFdmVudC50aW1lc3RhbXAgPiBjaGVja291dEV2ZXJ5Tm1zO1xuICAgICAgaWYgKGV4Y2VlZENvdW50IHx8IGV4Y2VlZFRpbWUpIHtcbiAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCQxKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd3JhcHBlZE11dGF0aW9uRW1pdCA9IChtKSA9PiB7XG4gICAgd3JhcHBlZEVtaXQoe1xuICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgIC4uLm1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgd3JhcHBlZFNjcm9sbEVtaXQgPSAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgIGRhdGE6IHtcbiAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsLFxuICAgICAgLi4ucFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQgPSAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgIGRhdGE6IHtcbiAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb24sXG4gICAgICAuLi5wXG4gICAgfVxuICB9KTtcbiAgY29uc3Qgd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCA9IChhMikgPT4gd3JhcHBlZEVtaXQoe1xuICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgIGRhdGE6IHtcbiAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQsXG4gICAgICAuLi5hMlxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgIGFkb3B0ZWRTdHlsZVNoZWV0Q2I6IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXRcbiAgfSk7XG4gIGNvbnN0IGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XG4gICAgbWlycm9yLFxuICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLFxuICAgIHdyYXBwZWRFbWl0XG4gIH0pO1xuICBmb3IgKGNvbnN0IHBsdWdpbjMgb2YgcGx1Z2lucyB8fCBbXSkge1xuICAgIGlmIChwbHVnaW4zLmdldE1pcnJvcilcbiAgICAgIHBsdWdpbjMuZ2V0TWlycm9yKHtcbiAgICAgICAgbm9kZU1pcnJvcjogbWlycm9yLFxuICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcbiAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXG4gICAgICB9KTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWROb2RlTWFuYWdlciA9IG5ldyBQcm9jZXNzZWROb2RlTWFuYWdlcigpO1xuICBjYW52YXNNYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xuICAgIHJlY29yZENhbnZhcyxcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxuICAgIHdpbjogd2luZG93LFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBtaXJyb3IsXG4gICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcbiAgICBkYXRhVVJMT3B0aW9uc1xuICB9KTtcbiAgY29uc3Qgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcbiAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICBieXBhc3NPcHRpb25zOiB7XG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICBtYXNrSW5wdXRGbixcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGlubGluZUltYWdlcyxcbiAgICAgIHNhbXBsaW5nLFxuICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICBpZnJhbWVNYW5hZ2VyLFxuICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICBjYW52YXNNYW5hZ2VyLFxuICAgICAga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXJcbiAgICB9LFxuICAgIG1pcnJvclxuICB9KTtcbiAgdGFrZUZ1bGxTbmFwc2hvdCQxID0gKGlzQ2hlY2tvdXQgPSBmYWxzZSkgPT4ge1xuICAgIGlmICghcmVjb3JkRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdyYXBwZWRFbWl0KFxuICAgICAge1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuTWV0YSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGhyZWY6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxuICAgICAgICAgIGhlaWdodDogZ2V0V2luZG93SGVpZ2h0KClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzQ2hlY2tvdXRcbiAgICApO1xuICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnJlc2V0KCk7XG4gICAgc2hhZG93RG9tTWFuYWdlci5pbml0KCk7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLmxvY2soKSk7XG4gICAgY29uc3Qgbm9kZTIgPSBzbmFwc2hvdChkb2N1bWVudCwge1xuICAgICAgbWlycm9yLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgbWFza1RleHRGbixcbiAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgc2xpbURPTTogc2xpbURPTU9wdGlvbnMsXG4gICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGlubGluZUltYWdlcyxcbiAgICAgIG9uU2VyaWFsaXplOiAobjIpID0+IHtcbiAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yKSkge1xuICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChuMiwgbWlycm9yKSkge1xuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChpbmRleC5zaGFkb3dSb290KG4yKSwgZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25JZnJhbWVMb2FkOiAoaWZyYW1lLCBjaGlsZFNuKSA9PiB7XG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XG4gICAgICAgIHNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgfSxcbiAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rRWwsIGNoaWxkU24pID0+IHtcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKTtcbiAgICAgIH0sXG4gICAgICBrZWVwSWZyYW1lU3JjRm5cbiAgICB9KTtcbiAgICBpZiAoIW5vZGUyKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudFwiKTtcbiAgICB9XG4gICAgd3JhcHBlZEVtaXQoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5GdWxsU25hcHNob3QsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgICBpbml0aWFsT2Zmc2V0OiBnZXRXaW5kb3dTY3JvbGwod2luZG93KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNDaGVja291dFxuICAgICk7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLnVubG9jaygpKTtcbiAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxuICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhcbiAgICAgICAgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICBtaXJyb3IuZ2V0SWQoZG9jdW1lbnQpXG4gICAgICApO1xuICB9O1xuICB0cnkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XG4gICAgY29uc3Qgb2JzZXJ2ZSA9IChkb2MpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGluaXRPYnNlcnZlcnMpKFxuICAgICAgICB7XG4gICAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgICBtb3VzZW1vdmVDYjogKHBvc2l0aW9ucywgc291cmNlKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBwb3NpdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uLFxuICAgICAgICAgICAgICAuLi5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSxcbiAgICAgICAgICAgICAgLi4uZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGlucHV0Q2I6ICh2MikgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQsXG4gICAgICAgICAgICAgIC4uLnYyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiOiAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2I6IChyMikgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGUsXG4gICAgICAgICAgICAgIC4uLnIyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiAocjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgIC4uLnIyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICAgICAgICBmb250Q2I6IChwKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Gb250LFxuICAgICAgICAgICAgICAuLi5wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2VsZWN0aW9uQ2I6IChwKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogKGMyKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICAgIC4uLmMyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBpZ25vcmVDbGFzcyxcbiAgICAgICAgICBpZ25vcmVTZWxlY3RvcixcbiAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIHNhbXBsaW5nLFxuICAgICAgICAgIHJlY29yZERPTSxcbiAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0LFxuICAgICAgICAgIGNvbGxlY3RGb250cyxcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgICAgbWFza1RleHRGbixcbiAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICBtaXJyb3IsXG4gICAgICAgICAgaWZyYW1lTWFuYWdlcixcbiAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLFxuICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLFxuICAgICAgICAgIGNhbnZhc01hbmFnZXIsXG4gICAgICAgICAgaWdub3JlQ1NTQXR0cmlidXRlcyxcbiAgICAgICAgICBwbHVnaW5zOiAoKF9hMiA9IHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuZmlsdGVyKChwKSA9PiBwLm9ic2VydmVyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tYXAoKHApID0+ICh7XG4gICAgICAgICAgICBvYnNlcnZlcjogcC5vYnNlcnZlcixcbiAgICAgICAgICAgIG9wdGlvbnM6IHAub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAocGF5bG9hZCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUGx1Z2luLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcGx1Z2luOiBwLm5hbWUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pKSkgfHwgW11cbiAgICAgICAgfSxcbiAgICAgICAgaG9va3NcbiAgICAgICk7XG4gICAgfTtcbiAgICBpZnJhbWVNYW5hZ2VyLmFkZExvYWRMaXN0ZW5lcigoaWZyYW1lRWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgIHRha2VGdWxsU25hcHNob3QkMSgpO1xuICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XG4gICAgICByZWNvcmRpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucHVzaChcbiAgICAgICAgb24oXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZCxcbiAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSBcIkRPTUNvbnRlbnRMb2FkZWRcIikgaW5pdCgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2goXG4gICAgICAgIG9uKFxuICAgICAgICAgIFwibG9hZFwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvYWQsXG4gICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gXCJsb2FkXCIpIGluaXQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdpbmRvd1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgIHJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgdW5yZWdpc3RlckVycm9ySGFuZGxlcigpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxufVxucmVjb3JkLmFkZEN1c3RvbUV2ZW50ID0gKHRhZywgcGF5bG9hZCkgPT4ge1xuICBpZiAoIXJlY29yZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBsZWFzZSBhZGQgY3VzdG9tIGV2ZW50IGFmdGVyIHN0YXJ0IHJlY29yZGluZ1wiKTtcbiAgfVxuICB3cmFwcGVkRW1pdCh7XG4gICAgdHlwZTogRXZlbnRUeXBlLkN1c3RvbSxcbiAgICBkYXRhOiB7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkXG4gICAgfVxuICB9KTtcbn07XG5yZWNvcmQuZnJlZXplUGFnZSA9ICgpID0+IHtcbiAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLmZyZWV6ZSgpKTtcbn07XG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdCA9IChpc0NoZWNrb3V0KSA9PiB7XG4gIGlmICghcmVjb3JkaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIHRha2UgZnVsbCBzbmFwc2hvdCBhZnRlciBzdGFydCByZWNvcmRpbmdcIik7XG4gIH1cbiAgdGFrZUZ1bGxTbmFwc2hvdCQxKGlzQ2hlY2tvdXQpO1xufTtcbnJlY29yZC5taXJyb3IgPSBtaXJyb3I7XG52YXIgbjtcbiFmdW5jdGlvbih0Mikge1xuICB0Mlt0Mi5Ob3RTdGFydGVkID0gMF0gPSBcIk5vdFN0YXJ0ZWRcIiwgdDJbdDIuUnVubmluZyA9IDFdID0gXCJSdW5uaW5nXCIsIHQyW3QyLlN0b3BwZWQgPSAyXSA9IFwiU3RvcHBlZFwiO1xufShuIHx8IChuID0ge30pKTtcbmV4cG9ydCB7XG4gIHJlY29yZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29yZC5qcy5tYXBcbiIsInZhciBFdmVudFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFdmVudFR5cGUyKSA9PiB7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRnVsbFNuYXBzaG90XCJdID0gMl0gPSBcIkZ1bGxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkN1c3RvbVwiXSA9IDVdID0gXCJDdXN0b21cIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xuICByZXR1cm4gRXZlbnRUeXBlMjtcbn0pKEV2ZW50VHlwZSB8fCB7fSk7XG52YXIgSW5jcmVtZW50YWxTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gKChJbmNyZW1lbnRhbFNvdXJjZTIpID0+IHtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KShJbmNyZW1lbnRhbFNvdXJjZSB8fCB7fSk7XG52YXIgTW91c2VJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChNb3VzZUludGVyYWN0aW9uczIpID0+IHtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlVXBcIl0gPSAwXSA9IFwiTW91c2VVcFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VEb3duXCJdID0gMV0gPSBcIk1vdXNlRG93blwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNvbnRleHRNZW51XCJdID0gM10gPSBcIkNvbnRleHRNZW51XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJEYmxDbGlja1wiXSA9IDRdID0gXCJEYmxDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkJsdXJcIl0gPSA2XSA9IFwiQmx1clwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hTdGFydFwiXSA9IDddID0gXCJUb3VjaFN0YXJ0XCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaEVuZFwiXSA9IDldID0gXCJUb3VjaEVuZFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hDYW5jZWxcIl0gPSAxMF0gPSBcIlRvdWNoQ2FuY2VsXCI7XG4gIHJldHVybiBNb3VzZUludGVyYWN0aW9uczI7XG59KShNb3VzZUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgUG9pbnRlclR5cGVzID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlclR5cGVzMikgPT4ge1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJNb3VzZVwiXSA9IDBdID0gXCJNb3VzZVwiO1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJQZW5cIl0gPSAxXSA9IFwiUGVuXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlRvdWNoXCJdID0gMl0gPSBcIlRvdWNoXCI7XG4gIHJldHVybiBQb2ludGVyVHlwZXMyO1xufSkoUG9pbnRlclR5cGVzIHx8IHt9KTtcbnZhciBDYW52YXNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovICgoQ2FudmFzQ29udGV4dDIpID0+IHtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCIyRFwiXSA9IDBdID0gXCIyRFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0wyXCJdID0gMl0gPSBcIldlYkdMMlwiO1xuICByZXR1cm4gQ2FudmFzQ29udGV4dDI7XG59KShDYW52YXNDb250ZXh0IHx8IHt9KTtcbnZhciBNZWRpYUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1lZGlhSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGxheVwiXSA9IDBdID0gXCJQbGF5XCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQYXVzZVwiXSA9IDFdID0gXCJQYXVzZVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiU2Vla2VkXCJdID0gMl0gPSBcIlNlZWtlZFwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiVm9sdW1lQ2hhbmdlXCJdID0gM10gPSBcIlZvbHVtZUNoYW5nZVwiO1xuICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUmF0ZUNoYW5nZVwiXSA9IDRdID0gXCJSYXRlQ2hhbmdlXCI7XG4gIHJldHVybiBNZWRpYUludGVyYWN0aW9uczI7XG59KShNZWRpYUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgUmVwbGF5ZXJFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gKChSZXBsYXllckV2ZW50czIpID0+IHtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiU3RhcnRcIl0gPSBcInN0YXJ0XCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIlBhdXNlXCJdID0gXCJwYXVzZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJSZXN1bWVcIl0gPSBcInJlc3VtZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJSZXNpemVcIl0gPSBcInJlc2l6ZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJGaW5pc2hcIl0gPSBcImZpbmlzaFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJGdWxsc25hcHNob3RSZWJ1aWxkZWRcIl0gPSBcImZ1bGxzbmFwc2hvdC1yZWJ1aWxkZWRcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiTG9hZFN0eWxlc2hlZXRTdGFydFwiXSA9IFwibG9hZC1zdHlsZXNoZWV0LXN0YXJ0XCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIkxvYWRTdHlsZXNoZWV0RW5kXCJdID0gXCJsb2FkLXN0eWxlc2hlZXQtZW5kXCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIlNraXBTdGFydFwiXSA9IFwic2tpcC1zdGFydFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJTa2lwRW5kXCJdID0gXCJza2lwLWVuZFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gXCJtb3VzZS1pbnRlcmFjdGlvblwiO1xuICBSZXBsYXllckV2ZW50czJbXCJFdmVudENhc3RcIl0gPSBcImV2ZW50LWNhc3RcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiQ3VzdG9tRXZlbnRcIl0gPSBcImN1c3RvbS1ldmVudFwiO1xuICBSZXBsYXllckV2ZW50czJbXCJGbHVzaFwiXSA9IFwiZmx1c2hcIjtcbiAgUmVwbGF5ZXJFdmVudHMyW1wiU3RhdGVDaGFuZ2VcIl0gPSBcInN0YXRlLWNoYW5nZVwiO1xuICBSZXBsYXllckV2ZW50czJbXCJQbGF5QmFja1wiXSA9IFwicGxheS1iYWNrXCI7XG4gIFJlcGxheWVyRXZlbnRzMltcIkRlc3Ryb3lcIl0gPSBcImRlc3Ryb3lcIjtcbiAgcmV0dXJuIFJlcGxheWVyRXZlbnRzMjtcbn0pKFJlcGxheWVyRXZlbnRzIHx8IHt9KTtcbnZhciBOb2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5vZGVUeXBlMikgPT4ge1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gIHJldHVybiBOb2RlVHlwZTI7XG59KShOb2RlVHlwZSB8fCB7fSk7XG5leHBvcnQge1xuICBDYW52YXNDb250ZXh0LFxuICBFdmVudFR5cGUsXG4gIEluY3JlbWVudGFsU291cmNlLFxuICBNZWRpYUludGVyYWN0aW9ucyxcbiAgTW91c2VJbnRlcmFjdGlvbnMsXG4gIE5vZGVUeXBlLFxuICBQb2ludGVyVHlwZXMsXG4gIFJlcGxheWVyRXZlbnRzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwXG4iLCIvLyBDb25zb2xlLXBvbHlmaWxsLiBNSVQgbGljZW5zZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvY29uc29sZS1wb2x5ZmlsbFxuLy8gTWFrZSBpdCBzYWZlIHRvIGRvIGNvbnNvbGUubG9nKCkgYWx3YXlzLlxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICghZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBnbG9iYWwuY29uc29sZSA9IHt9O1xuICB9XG4gIHZhciBjb24gPSBnbG9iYWwuY29uc29sZTtcbiAgdmFyIHByb3AsIG1ldGhvZDtcbiAgdmFyIGR1bW15ID0gZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHByb3BlcnRpZXMgPSBbJ21lbW9yeSddO1xuICB2YXIgbWV0aG9kcyA9ICgnYXNzZXJ0LGNsZWFyLGNvdW50LGRlYnVnLGRpcixkaXJ4bWwsZXJyb3IsZXhjZXB0aW9uLGdyb3VwLCcgK1xuICAgICAnZ3JvdXBDb2xsYXBzZWQsZ3JvdXBFbmQsaW5mbyxsb2csbWFya1RpbWVsaW5lLHByb2ZpbGUscHJvZmlsZXMscHJvZmlsZUVuZCwnICtcbiAgICAgJ3Nob3csdGFibGUsdGltZSx0aW1lRW5kLHRpbWVsaW5lLHRpbWVsaW5lRW5kLHRpbWVTdGFtcCx0cmFjZSx3YXJuJykuc3BsaXQoJywnKTtcbiAgd2hpbGUgKHByb3AgPSBwcm9wZXJ0aWVzLnBvcCgpKSBpZiAoIWNvbltwcm9wXSkgY29uW3Byb3BdID0ge307XG4gIHdoaWxlIChtZXRob2QgPSBtZXRob2RzLnBvcCgpKSBpZiAoIWNvblttZXRob2RdKSBjb25bbWV0aG9kXSA9IGR1bW15O1xuICAvLyBVc2luZyBgdGhpc2AgZm9yIHdlYiB3b3JrZXJzICYgc3VwcG9ydHMgQnJvd3NlcmlmeSAvIFdlYnBhY2suXG59KSh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiB3aW5kb3cpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnZXJyb3Itc3RhY2stcGFyc2VyJywgWydzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuRXJyb3JTdGFja1BhcnNlciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xuICAgIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcbiAgICB2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVdKT8kLztcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIGV4dHJhY3QgdGhlIG1vc3QgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdGFja0ZyYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrICYmIGVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGdpdmVuIEVycm9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgICAgIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkZXh0cmFjdExvY2F0aW9uKHVybExpa2UpIHtcbiAgICAgICAgICAgIC8vIEZhaWwtZmFzdCBidXQgcmV0dXJuIGxvY2F0aW9ucyBsaWtlIFwiKG5hdGl2ZSlcIlxuICAgICAgICAgICAgaWYgKHVybExpa2UuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlVjhPcklFOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZVY4T3JJRShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csICdldmFsJykucmVwbGFjZSgvKFxcKGV2YWwgYXQgW14oKV0qKXwoXFwpLC4qJCkvZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIGFuZCBwcmVzZXZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIFwiKC9mb28vbXkgYmFyLmpzOjEyOjg3KVwiIGluXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gZnJvbSB0aGUgbGluZSwgaWYgaXQgd2FzIG1hdGNoZWRcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWRMaW5lID0gbG9jYXRpb24gPyBzYW5pdGl6ZWRMaW5lLnJlcGxhY2UobG9jYXRpb25bMF0sICcnKSA6IHNhbml0aXplZExpbmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gc2FuaXRpemVkTGluZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgbG9jYXRpb24gd2FzIG1hdGNoZWQsIHBhc3MgaXQgdG8gZXh0cmFjdExvY2F0aW9uKCkgb3RoZXJ3aXNlIHBvcCB0aGUgbGFzdCB0b2tlblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obG9jYXRpb24gPyBsb2NhdGlvblsxXSA6IHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IFsnZXZhbCcsICc8YW5vbnltb3VzPiddLmluZGV4T2YobG9jYXRpb25QYXJ0c1swXSkgPiAtMSA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uUGFydHNbMF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VGRk9yU2FmYXJpOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZUZGT3JTYWZhcmkoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignID4gZXZhbCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csICc6JDEnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdAJykgPT09IC0xICYmIGxpbmUuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZXZhbCBmcmFtZXMgb25seSBoYXZlIGZ1bmN0aW9uIG5hbWVzIGFuZCBub3RoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lUmVnZXggPSAvKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS87XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChmdW5jdGlvbk5hbWVSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxpbmUucmVwbGFjZShmdW5jdGlvbk5hbWVSZWdleCwgJycpKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYShlKSB7XG4gICAgICAgICAgICBpZiAoIWUuc3RhY2t0cmFjZSB8fCAoZS5tZXNzYWdlLmluZGV4T2YoJ1xcbicpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCA+IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJykubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE5OiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhOShlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTAoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBJbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBtYXRjaFszXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE9wZXJhIDEwLjY1KyBFcnJvci5zdGFjayB2ZXJ5IHNpbWlsYXIgdG8gRkYvU2FmYXJpXG4gICAgICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkgJiYgIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9ICh0b2tlbnMuc2hpZnQoKSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sICckMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXildKlxcKS9nLCAnJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzUmF3O1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGwubWF0Y2goL1xcKChbXildKilcXCkvKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXihdK1xcKChbXildKilcXCkkLywgJyQxJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gKGFyZ3NSYXcgPT09IHVuZGVmaW5lZCB8fCBhcmdzUmF3ID09PSAnW2FyZ3VtZW50cyBub3QgYXZhaWxhYmxlXScpID9cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2tmcmFtZScsIFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrRnJhbWUgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gX2lzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldHRlcihwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3BdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBib29sZWFuUHJvcHMgPSBbJ2lzQ29uc3RydWN0b3InLCAnaXNFdmFsJywgJ2lzTmF0aXZlJywgJ2lzVG9wbGV2ZWwnXTtcbiAgICB2YXIgbnVtZXJpY1Byb3BzID0gWydjb2x1bW5OdW1iZXInLCAnbGluZU51bWJlciddO1xuICAgIHZhciBzdHJpbmdQcm9wcyA9IFsnZmlsZU5hbWUnLCAnZnVuY3Rpb25OYW1lJywgJ3NvdXJjZSddO1xuICAgIHZhciBhcnJheVByb3BzID0gWydhcmdzJ107XG4gICAgdmFyIG9iamVjdFByb3BzID0gWydldmFsT3JpZ2luJ107XG5cbiAgICB2YXIgcHJvcHMgPSBib29sZWFuUHJvcHMuY29uY2F0KG51bWVyaWNQcm9wcywgc3RyaW5nUHJvcHMsIGFycmF5UHJvcHMsIG9iamVjdFByb3BzKTtcblxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XG4gICAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmpbcHJvcHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzWydzZXQnICsgX2NhcGl0YWxpemUocHJvcHNbaV0pXShvYmpbcHJvcHNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgICAgICBnZXRBcmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFyZ3M6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmdzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RXZhbE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsT3JpZ2luO1xuICAgICAgICB9LFxuICAgICAgICBzZXRFdmFsT3JpZ2luOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gbmV3IFN0YWNrRnJhbWUodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V2YWwgT3JpZ2luIG11c3QgYmUgYW4gT2JqZWN0IG9yIFN0YWNrRnJhbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuZ2V0TGluZU51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdldElzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXTonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgJyAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RhY2tGcmFtZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gU3RhY2tGcmFtZSQkZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGFyZ3NTdGFydEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgICAgICAgdmFyIGFyZ3NFbmRJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignKScpO1xuXG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBzdHIuc3Vic3RyaW5nKDAsIGFyZ3NTdGFydEluZGV4KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzdHIuc3Vic3RyaW5nKGFyZ3NTdGFydEluZGV4ICsgMSwgYXJnc0VuZEluZGV4KS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgbG9jYXRpb25TdHJpbmcgPSBzdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCArIDEpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvblN0cmluZy5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9AKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKGxvY2F0aW9uU3RyaW5nLCAnJyk7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gcGFydHNbMl07XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gcGFydHNbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gX2dldHRlcihib29sZWFuUHJvcHNbaV0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IEJvb2xlYW4odik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShib29sZWFuUHJvcHNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtZXJpY1Byb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSBfZ2V0dGVyKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHAgKyAnIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IE51bWJlcih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJpbmdQcm9wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBfZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IFN0cmluZyh2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHN0cmluZ1Byb3BzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pKTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vYXBpVXRpbGl0eScpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhvc3RuYW1lOiAnYXBpLnJvbGxiYXIuY29tJyxcbiAgcGF0aDogJy9hcGkvMS9pdGVtLycsXG4gIHNlYXJjaDogbnVsbCxcbiAgdmVyc2lvbjogJzEnLFxuICBwcm90b2NvbDogJ2h0dHBzOicsXG4gIHBvcnQ6IDQ0Myxcbn07XG5cbnZhciBPVExQRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhvc3RuYW1lOiAnYXBpLnJvbGxiYXIuY29tJyxcbiAgcGF0aDogJy9hcGkvMS9zZXNzaW9uLycsXG4gIHNlYXJjaDogbnVsbCxcbiAgdmVyc2lvbjogJzEnLFxuICBwcm90b2NvbDogJ2h0dHBzOicsXG4gIHBvcnQ6IDQ0Myxcbn07XG5cbi8qKlxuICogQXBpIGlzIGFuIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyBtZXRob2RzIG9mIGNvbW11bmljYXRpbmcgd2l0aFxuICogdGhlIFJvbGxiYXIgQVBJLiAgSXQgaXMgYSBzdGFuZGFyZCBpbnRlcmZhY2Ugd2l0aCBzb21lIHBhcnRzIGltcGxlbWVudGVkXG4gKiBkaWZmZXJlbnRseSBmb3Igc2VydmVyIG9yIGJyb3dzZXIgY29udGV4dHMuICBJdCBpcyBhbiBvYmplY3QgdGhhdCBzaG91bGRcbiAqIGJlIGluc3RhbnRpYXRlZCB3aGVuIHVzZWQgc28gaXQgY2FuIGNvbnRhaW4gbm9uLWdsb2JhbCBvcHRpb25zIHRoYXQgbWF5XG4gKiBiZSBkaWZmZXJlbnQgZm9yIGFub3RoZXIgaW5zdGFuY2Ugb2YgUm9sbGJhckFwaS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7XG4gKiAgICBhY2Nlc3NUb2tlbjogdGhlIGFjY2Vzc1Rva2VuIHRvIHVzZSBmb3IgcG9zdGluZyBpdGVtcyB0byByb2xsYmFyXG4gKiAgICBlbmRwb2ludDogYW4gYWx0ZXJuYXRpdmUgZW5kcG9pbnQgdG8gc2VuZCBlcnJvcnMgdG9cbiAqICAgICAgICBtdXN0IGJlIGEgdmFsaWQsIGZ1bGx5IHF1YWxpZmllZCBVUkwuXG4gKiAgICAgICAgVGhlIGRlZmF1bHQgaXM6IGh0dHBzOi8vYXBpLnJvbGxiYXIuY29tL2FwaS8xL2l0ZW1cbiAqICAgIHByb3h5OiBpZiB5b3Ugd2lzaCB0byBwcm94eSByZXF1ZXN0cyBwcm92aWRlIGFuIG9iamVjdFxuICogICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOlxuICogICAgICAgICAgaG9zdCBvciBob3N0bmFtZSAocmVxdWlyZWQpOiBmb28uZXhhbXBsZS5jb21cbiAqICAgICAgICAgIHBvcnQgKG9wdGlvbmFsKTogMTIzXG4gKiAgICAgICAgICBwcm90b2NvbCAob3B0aW9uYWwpOiBodHRwc1xuICogfVxuICovXG5mdW5jdGlvbiBBcGkob3B0aW9ucywgdHJhbnNwb3J0LCB1cmxsaWIsIHRydW5jYXRpb24pIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMudXJsID0gdXJsbGliO1xuICB0aGlzLnRydW5jYXRpb24gPSB0cnVuY2F0aW9uO1xuICB0aGlzLmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gX2dldFRyYW5zcG9ydChvcHRpb25zLCB1cmxsaWIpO1xuICB0aGlzLk9UTFBUcmFuc3BvcnRPcHRpb25zID0gX2dldE9UTFBUcmFuc3BvcnQob3B0aW9ucywgdXJsbGliKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0cmFuc3BvcnQucG9zdCBpbiBhIFByb21pc2UgdG8gc3VwcG9ydCBhc3luYy9hd2FpdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEFQSSByZXF1ZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hY2Nlc3NUb2tlbiAtIFRoZSBhY2Nlc3MgdG9rZW4gZm9yIGF1dGhlbnRpY2F0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHRyYW5zcG9ydFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucGF5bG9hZCAtIFRoZSBkYXRhIHBheWxvYWQgdG8gc2VuZFxuICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuQXBpLnByb3RvdHlwZS5fcG9zdFByb21pc2UgPSBmdW5jdGlvbih7IGFjY2Vzc1Rva2VuLCB0cmFuc3BvcnRPcHRpb25zLCBwYXlsb2FkIH0pIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2VsZi50cmFuc3BvcnQucG9zdChhY2Nlc3NUb2tlbiwgdHJhbnNwb3J0T3B0aW9ucywgcGF5bG9hZCwgKGVyciwgcmVzcCkgPT5cbiAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXNwKVxuICAgICk7XG4gIH0pO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5BcGkucHJvdG90eXBlLnBvc3RJdGVtID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuc3BvcnRPcHRpb25zID0gaGVscGVycy50cmFuc3BvcnRPcHRpb25zKFxuICAgIHRoaXMudHJhbnNwb3J0T3B0aW9ucyxcbiAgICAnUE9TVCcsXG4gICk7XG4gIHZhciBwYXlsb2FkID0gaGVscGVycy5idWlsZFBheWxvYWQoZGF0YSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBlbnN1cmUgdGhlIG5ldHdvcmsgcmVxdWVzdCBpcyBzY2hlZHVsZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgdGljay5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi50cmFuc3BvcnQucG9zdChzZWxmLmFjY2Vzc1Rva2VuLCB0cmFuc3BvcnRPcHRpb25zLCBwYXlsb2FkLCBjYWxsYmFjayk7XG4gIH0sIDApO1xufTtcblxuLyoqXG4gKiBQb3N0cyBzcGFucyB0byB0aGUgUm9sbGJhciBBUEkgdXNpbmcgdGhlIHNlc3Npb24gZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXlsb2FkIC0gVGhlIHNwYW5zIHRvIHNlbmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEFQSSByZXNwb25zZVxuICovXG5BcGkucHJvdG90eXBlLnBvc3RTcGFucyA9IGFzeW5jIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gIGNvbnN0IHRyYW5zcG9ydE9wdGlvbnMgPSBoZWxwZXJzLnRyYW5zcG9ydE9wdGlvbnMoXG4gICAgdGhpcy5PVExQVHJhbnNwb3J0T3B0aW9ucyxcbiAgICAnUE9TVCcsXG4gICk7XG5cbiAgcmV0dXJuIGF3YWl0IHRoaXMuX3Bvc3RQcm9taXNlKHtcbiAgICBhY2Nlc3NUb2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcbiAgICB0cmFuc3BvcnRPcHRpb25zLFxuICAgIHBheWxvYWRcbiAgfSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkFwaS5wcm90b3R5cGUuYnVpbGRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgcGF5bG9hZCA9IGhlbHBlcnMuYnVpbGRQYXlsb2FkKGRhdGEpO1xuXG4gIHZhciBzdHJpbmdpZnlSZXN1bHQ7XG4gIGlmICh0aGlzLnRydW5jYXRpb24pIHtcbiAgICBzdHJpbmdpZnlSZXN1bHQgPSB0aGlzLnRydW5jYXRpb24udHJ1bmNhdGUocGF5bG9hZCk7XG4gIH0gZWxzZSB7XG4gICAgc3RyaW5naWZ5UmVzdWx0ID0gXy5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIH1cblxuICBpZiAoc3RyaW5naWZ5UmVzdWx0LmVycm9yKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhzdHJpbmdpZnlSZXN1bHQuZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnlSZXN1bHQudmFsdWU7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ganNvblBheWxvYWRcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5BcGkucHJvdG90eXBlLnBvc3RKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChqc29uUGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgdmFyIHRyYW5zcG9ydE9wdGlvbnMgPSBoZWxwZXJzLnRyYW5zcG9ydE9wdGlvbnMoXG4gICAgdGhpcy50cmFuc3BvcnRPcHRpb25zLFxuICAgICdQT1NUJyxcbiAgKTtcbiAgdGhpcy50cmFuc3BvcnQucG9zdEpzb25QYXlsb2FkKFxuICAgIHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgdHJhbnNwb3J0T3B0aW9ucyxcbiAgICBqc29uUGF5bG9hZCxcbiAgICBjYWxsYmFjayxcbiAgKTtcbn07XG5cbkFwaS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9sZE9wdGlvbnM7XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob2xkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IF9nZXRUcmFuc3BvcnQodGhpcy5vcHRpb25zLCB0aGlzLnVybCk7XG4gIHRoaXMuT1RMUFRyYW5zcG9ydE9wdGlvbnMgPSBfZ2V0T1RMUFRyYW5zcG9ydCh0aGlzLm9wdGlvbnMsIHRoaXMudXJsKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRUcmFuc3BvcnQob3B0aW9ucywgdXJsKSB7XG4gIHJldHVybiBoZWxwZXJzLmdldFRyYW5zcG9ydEZyb21PcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zLCB1cmwpO1xufVxuXG5mdW5jdGlvbiBfZ2V0T1RMUFRyYW5zcG9ydChvcHRpb25zLCB1cmwpIHtcbiAgb3B0aW9ucyA9IHsuLi5vcHRpb25zLCBlbmRwb2ludDogb3B0aW9ucy50cmFjaW5nPy5lbmRwb2ludH07XG4gIHJldHVybiBoZWxwZXJzLmdldFRyYW5zcG9ydEZyb21PcHRpb25zKG9wdGlvbnMsIE9UTFBEZWZhdWx0T3B0aW9ucywgdXJsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBcGk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xuXG5mdW5jdGlvbiBidWlsZFBheWxvYWQoZGF0YSkge1xuICBpZiAoIV8uaXNUeXBlKGRhdGEuY29udGV4dCwgJ3N0cmluZycpKSB7XG4gICAgdmFyIGNvbnRleHRSZXN1bHQgPSBfLnN0cmluZ2lmeShkYXRhLmNvbnRleHQpO1xuICAgIGlmIChjb250ZXh0UmVzdWx0LmVycm9yKSB7XG4gICAgICBkYXRhLmNvbnRleHQgPSBcIkVycm9yOiBjb3VsZCBub3Qgc2VyaWFsaXplICdjb250ZXh0J1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmNvbnRleHQgPSBjb250ZXh0UmVzdWx0LnZhbHVlIHx8ICcnO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0Lmxlbmd0aCA+IDI1NSkge1xuICAgICAgZGF0YS5jb250ZXh0ID0gZGF0YS5jb250ZXh0LnN1YnN0cigwLCAyNTUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IGRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zcG9ydEZyb21PcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzLCB1cmwpIHtcbiAgdmFyIGhvc3RuYW1lID0gZGVmYXVsdHMuaG9zdG5hbWU7XG4gIHZhciBwcm90b2NvbCA9IGRlZmF1bHRzLnByb3RvY29sO1xuICB2YXIgcG9ydCA9IGRlZmF1bHRzLnBvcnQ7XG4gIHZhciBwYXRoID0gZGVmYXVsdHMucGF0aDtcbiAgdmFyIHNlYXJjaCA9IGRlZmF1bHRzLnNlYXJjaDtcbiAgdmFyIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gIHZhciB0cmFuc3BvcnQgPSBkZXRlY3RUcmFuc3BvcnQob3B0aW9ucyk7XG5cbiAgdmFyIHByb3h5ID0gb3B0aW9ucy5wcm94eTtcbiAgaWYgKG9wdGlvbnMuZW5kcG9pbnQpIHtcbiAgICB2YXIgb3B0cyA9IHVybC5wYXJzZShvcHRpb25zLmVuZHBvaW50KTtcbiAgICBob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gICAgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sO1xuICAgIHBvcnQgPSBvcHRzLnBvcnQ7XG4gICAgcGF0aCA9IG9wdHMucGF0aG5hbWU7XG4gICAgc2VhcmNoID0gb3B0cy5zZWFyY2g7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIGhvc3RuYW1lOiBob3N0bmFtZSxcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgcG9ydDogcG9ydCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIHByb3h5OiBwcm94eSxcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHJhbnNwb3J0KG9wdGlvbnMpIHtcbiAgdmFyIGdXaW5kb3cgPVxuICAgICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHxcbiAgICAodHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZik7XG4gIHZhciB0cmFuc3BvcnQgPSBvcHRpb25zLmRlZmF1bHRUcmFuc3BvcnQgfHwgJ3hocic7XG4gIGlmICh0eXBlb2YgZ1dpbmRvdy5mZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHRyYW5zcG9ydCA9ICd4aHInO1xuICBpZiAodHlwZW9mIGdXaW5kb3cuWE1MSHR0cFJlcXVlc3QgPT09ICd1bmRlZmluZWQnKSB0cmFuc3BvcnQgPSAnZmV0Y2gnO1xuICByZXR1cm4gdHJhbnNwb3J0O1xufVxuXG5mdW5jdGlvbiB0cmFuc3BvcnRPcHRpb25zKHRyYW5zcG9ydCwgbWV0aG9kKSB7XG4gIHZhciBwcm90b2NvbCA9IHRyYW5zcG9ydC5wcm90b2NvbCB8fCAnaHR0cHM6JztcbiAgdmFyIHBvcnQgPVxuICAgIHRyYW5zcG9ydC5wb3J0IHx8XG4gICAgKHByb3RvY29sID09PSAnaHR0cDonID8gODAgOiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiB1bmRlZmluZWQpO1xuICB2YXIgaG9zdG5hbWUgPSB0cmFuc3BvcnQuaG9zdG5hbWU7XG4gIHZhciBwYXRoID0gdHJhbnNwb3J0LnBhdGg7XG4gIHZhciB0aW1lb3V0ID0gdHJhbnNwb3J0LnRpbWVvdXQ7XG4gIHZhciB0cmFuc3BvcnRBUEkgPSB0cmFuc3BvcnQudHJhbnNwb3J0O1xuICBpZiAodHJhbnNwb3J0LnNlYXJjaCkge1xuICAgIHBhdGggPSBwYXRoICsgdHJhbnNwb3J0LnNlYXJjaDtcbiAgfVxuICBpZiAodHJhbnNwb3J0LnByb3h5KSB7XG4gICAgcGF0aCA9IHByb3RvY29sICsgJy8vJyArIGhvc3RuYW1lICsgcGF0aDtcbiAgICBob3N0bmFtZSA9IHRyYW5zcG9ydC5wcm94eS5ob3N0IHx8IHRyYW5zcG9ydC5wcm94eS5ob3N0bmFtZTtcbiAgICBwb3J0ID0gdHJhbnNwb3J0LnByb3h5LnBvcnQ7XG4gICAgcHJvdG9jb2wgPSB0cmFuc3BvcnQucHJveHkucHJvdG9jb2wgfHwgcHJvdG9jb2w7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBob3N0bmFtZTogaG9zdG5hbWUsXG4gICAgcGF0aDogcGF0aCxcbiAgICBwb3J0OiBwb3J0LFxuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0QVBJLFxuICB9O1xufVxuXG5mdW5jdGlvbiBhcHBlbmRQYXRoVG9QYXRoKGJhc2UsIHBhdGgpIHtcbiAgdmFyIGJhc2VUcmFpbGluZ1NsYXNoID0gL1xcLyQvLnRlc3QoYmFzZSk7XG4gIHZhciBwYXRoQmVnaW5uaW5nU2xhc2ggPSAvXlxcLy8udGVzdChwYXRoKTtcblxuICBpZiAoYmFzZVRyYWlsaW5nU2xhc2ggJiYgcGF0aEJlZ2lubmluZ1NsYXNoKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDEpO1xuICB9IGVsc2UgaWYgKCFiYXNlVHJhaWxpbmdTbGFzaCAmJiAhcGF0aEJlZ2lubmluZ1NsYXNoKSB7XG4gICAgcGF0aCA9ICcvJyArIHBhdGg7XG4gIH1cblxuICByZXR1cm4gYmFzZSArIHBhdGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFBheWxvYWQ6IGJ1aWxkUGF5bG9hZCxcbiAgZ2V0VHJhbnNwb3J0RnJvbU9wdGlvbnM6IGdldFRyYW5zcG9ydEZyb21PcHRpb25zLFxuICB0cmFuc3BvcnRPcHRpb25zOiB0cmFuc3BvcnRPcHRpb25zLFxuICBhcHBlbmRQYXRoVG9QYXRoOiBhcHBlbmRQYXRoVG9QYXRoLFxufTtcbiIsInZhciBDbGllbnQgPSByZXF1aXJlKCcuLi9yb2xsYmFyJyk7XG52YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWxpdHknKTtcbnZhciBBUEkgPSByZXF1aXJlKCcuLi9hcGknKTtcbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbFNldHVwJyk7XG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xudmFyIHVybGxpYiA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbnZhciB0cmFuc2Zvcm1zID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1zJyk7XG52YXIgc2hhcmVkVHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMnKTtcbnZhciBwcmVkaWNhdGVzID0gcmVxdWlyZSgnLi9wcmVkaWNhdGVzJyk7XG52YXIgc2hhcmVkUHJlZGljYXRlcyA9IHJlcXVpcmUoJy4uL3ByZWRpY2F0ZXMnKTtcbnZhciBlcnJvclBhcnNlciA9IHJlcXVpcmUoJy4uL2Vycm9yUGFyc2VyJyk7XG5jb25zdCByZWNvcmRlckRlZmF1bHRzID0gcmVxdWlyZSgnLi9yZXBsYXkvZGVmYXVsdHMnKTtcbmNvbnN0IHRyYWNpbmdEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3RyYWNpbmcvZGVmYXVsdHMnKTtcbmNvbnN0IFJlcGxheU1hcCA9IHJlcXVpcmUoJy4vcmVwbGF5L3JlcGxheU1hcCcpLmRlZmF1bHQ7XG5cbmZ1bmN0aW9uIFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSB7XG4gIHRoaXMub3B0aW9ucyA9IF8uaGFuZGxlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucywgbnVsbCwgbG9nZ2VyKTtcbiAgdGhpcy5vcHRpb25zLl9jb25maWd1cmVkT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IFRlbGVtZXRlciA9IHRoaXMuY29tcG9uZW50cy50ZWxlbWV0ZXI7XG4gIGNvbnN0IEluc3RydW1lbnRlciA9IHRoaXMuY29tcG9uZW50cy5pbnN0cnVtZW50ZXI7XG4gIGNvbnN0IHBvbHlmaWxsSlNPTiA9IHRoaXMuY29tcG9uZW50cy5wb2x5ZmlsbEpTT047XG4gIHRoaXMud3JhcEdsb2JhbHMgPSB0aGlzLmNvbXBvbmVudHMud3JhcEdsb2JhbHM7XG4gIHRoaXMuc2NydWIgPSB0aGlzLmNvbXBvbmVudHMuc2NydWI7XG4gIGNvbnN0IHRydW5jYXRpb24gPSB0aGlzLmNvbXBvbmVudHMudHJ1bmNhdGlvbjtcbiAgY29uc3QgVHJhY2luZyA9IHRoaXMuY29tcG9uZW50cy50cmFjaW5nO1xuICBjb25zdCBSZWNvcmRlciA9IHRoaXMuY29tcG9uZW50cy5yZWNvcmRlcjtcblxuICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0KHRydW5jYXRpb24pO1xuICBjb25zdCBhcGkgPSBuZXcgQVBJKHRoaXMub3B0aW9ucywgdHJhbnNwb3J0LCB1cmxsaWIsIHRydW5jYXRpb24pO1xuICBpZiAoVHJhY2luZykge1xuICAgIHRoaXMudHJhY2luZyA9IG5ldyBUcmFjaW5nKF9nV2luZG93KCksIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy50cmFjaW5nLmluaXRTZXNzaW9uKCk7XG4gIH1cblxuICBpZiAoUmVjb3JkZXIgJiYgXy5pc0Jyb3dzZXIoKSkge1xuICAgIGNvbnN0IHJlY29yZGVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5yZWNvcmRlcjtcbiAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKHJlY29yZGVyT3B0aW9ucyk7XG4gICAgdGhpcy5yZXBsYXlNYXAgPSBuZXcgUmVwbGF5TWFwKHtcbiAgICAgIHJlY29yZGVyOiB0aGlzLnJlY29yZGVyLFxuICAgICAgYXBpOiBhcGksXG4gICAgICB0cmFjaW5nOiB0aGlzLnRyYWNpbmdcbiAgICB9KTtcblxuICAgIGlmIChyZWNvcmRlck9wdGlvbnMuZW5hYmxlZCAmJiByZWNvcmRlck9wdGlvbnMuYXV0b1N0YXJ0KSB7XG4gICAgICB0aGlzLnJlY29yZGVyLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKFRlbGVtZXRlcikge1xuICAgIHRoaXMudGVsZW1ldGVyID0gbmV3IFRlbGVtZXRlcih0aGlzLm9wdGlvbnMsIHRoaXMudHJhY2luZyk7XG4gIH1cbiAgdGhpcy5jbGllbnQgPVxuICAgIGNsaWVudCB8fCBuZXcgQ2xpZW50KHRoaXMub3B0aW9ucywgYXBpLCBsb2dnZXIsIHRoaXMudGVsZW1ldGVyLCB0aGlzLnRyYWNpbmcsIHRoaXMucmVwbGF5TWFwLCAnYnJvd3NlcicpO1xuICB2YXIgZ1dpbmRvdyA9IF9nV2luZG93KCk7XG4gIHZhciBnRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQ7XG4gIHRoaXMuaXNDaHJvbWUgPSBnV2luZG93LmNocm9tZSAmJiBnV2luZG93LmNocm9tZS5ydW50aW1lOyAvLyBjaGVjayAucnVudGltZSB0byBhdm9pZCBFZGdlIGJyb3dzZXJzXG4gIHRoaXMuYW5vbnltb3VzRXJyb3JzUGVuZGluZyA9IDA7XG4gIGFkZFRyYW5zZm9ybXNUb05vdGlmaWVyKHRoaXMuY2xpZW50Lm5vdGlmaWVyLCB0aGlzLCBnV2luZG93KTtcbiAgYWRkUHJlZGljYXRlc1RvUXVldWUodGhpcy5jbGllbnQucXVldWUpO1xuICB0aGlzLnNldHVwVW5oYW5kbGVkQ2FwdHVyZSgpO1xuICBpZiAoSW5zdHJ1bWVudGVyKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50ZXIgPSBuZXcgSW5zdHJ1bWVudGVyKFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5jbGllbnQudGVsZW1ldGVyLFxuICAgICAgdGhpcyxcbiAgICAgIGdXaW5kb3csXG4gICAgICBnRG9jdW1lbnQsXG4gICAgKTtcbiAgICB0aGlzLmluc3RydW1lbnRlci5pbnN0cnVtZW50KCk7XG4gIH1cbiAgXy5zZXR1cEpTT04ocG9seWZpbGxKU09OKTtcblxuICAvLyBVc2VkIHdpdGggcm9sbGJhci1yZWFjdCBmb3Igcm9sbGJhci1yZWFjdC1uYXRpdmUgY29tcGF0aWJpbGl0eS5cbiAgdGhpcy5yb2xsYmFyID0gdGhpcztcbn1cblxudmFyIF9pbnN0YW5jZSA9IG51bGw7XG5Sb2xsYmFyLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2xpZW50KSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmdsb2JhbChvcHRpb25zKS5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgX2luc3RhbmNlID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KTtcbiAgcmV0dXJuIF9pbnN0YW5jZTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmNvbXBvbmVudHMgPSB7fTtcblxuUm9sbGJhci5zZXRDb21wb25lbnRzID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcbiAgUm9sbGJhci5wcm90b3R5cGUuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnUm9sbGJhciBpcyBub3QgaW5pdGlhbGl6ZWQnO1xuICBsb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gIGlmIChtYXliZUNhbGxiYWNrKSB7XG4gICAgbWF5YmVDYWxsYmFjayhuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG59XG5cblJvbGxiYXIucHJvdG90eXBlLmdsb2JhbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHRoaXMuY2xpZW50Lmdsb2JhbChvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuUm9sbGJhci5nbG9iYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5nbG9iYWwob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZCgpO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGF5bG9hZERhdGEpIHtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBwYXlsb2FkID0ge307XG4gIGlmIChwYXlsb2FkRGF0YSkge1xuICAgIHBheWxvYWQgPSB7IHBheWxvYWQ6IHBheWxvYWREYXRhIH07XG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBfLmhhbmRsZU9wdGlvbnMob2xkT3B0aW9ucywgb3B0aW9ucywgcGF5bG9hZCwgbG9nZ2VyKTtcbiAgdGhpcy5vcHRpb25zLl9jb25maWd1cmVkT3B0aW9ucyA9IF8uaGFuZGxlT3B0aW9ucyhcbiAgICBvbGRPcHRpb25zLl9jb25maWd1cmVkT3B0aW9ucyxcbiAgICBvcHRpb25zLFxuICAgIHBheWxvYWQsXG4gICk7XG5cbiAgdGhpcy5yZWNvcmRlcj8uY29uZmlndXJlKHRoaXMub3B0aW9ucyk7XG4gIHRoaXMuY2xpZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMsIHBheWxvYWREYXRhKTtcbiAgdGhpcy5pbnN0cnVtZW50ZXIgJiYgdGhpcy5pbnN0cnVtZW50ZXIuY29uZmlndXJlKHRoaXMub3B0aW9ucyk7XG4gIHRoaXMuc2V0dXBVbmhhbmRsZWRDYXB0dXJlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblJvbGxiYXIuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBheWxvYWREYXRhKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmNvbmZpZ3VyZShvcHRpb25zLCBwYXlsb2FkRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZCgpO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5sYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5sYXN0RXJyb3I7XG59O1xuUm9sbGJhci5sYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmxhc3RFcnJvcigpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oYXJndW1lbnRzKTtcbiAgdmFyIHV1aWQgPSBpdGVtLnV1aWQ7XG4gIHRoaXMuY2xpZW50LmxvZyhpdGVtKTtcbiAgcmV0dXJuIHsgdXVpZDogdXVpZCB9O1xufTtcblJvbGxiYXIubG9nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5sb2cuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXliZUNhbGxiYWNrID0gX2dldEZpcnN0RnVuY3Rpb24oYXJndW1lbnRzKTtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC5kZWJ1ZyhpdGVtKTtcbiAgcmV0dXJuIHsgdXVpZDogdXVpZCB9O1xufTtcblJvbGxiYXIuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLmRlYnVnLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC5pbmZvKGl0ZW0pO1xuICByZXR1cm4geyB1dWlkOiB1dWlkIH07XG59O1xuUm9sbGJhci5pbmZvID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5pbmZvLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC53YXJuKGl0ZW0pO1xuICByZXR1cm4geyB1dWlkOiB1dWlkIH07XG59O1xuUm9sbGJhci53YXJuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS53YXJuLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG4gIHZhciB1dWlkID0gaXRlbS51dWlkO1xuICB0aGlzLmNsaWVudC53YXJuaW5nKGl0ZW0pO1xuICByZXR1cm4geyB1dWlkOiB1dWlkIH07XG59O1xuUm9sbGJhci53YXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS53YXJuaW5nLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF5YmVDYWxsYmFjayA9IF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3VtZW50cyk7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZChtYXliZUNhbGxiYWNrKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcbiAgdGhpcy5jbGllbnQuZXJyb3IoaXRlbSk7XG4gIHJldHVybiB7IHV1aWQ6IHV1aWQgfTtcbn07XG5Sb2xsYmFyLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5lcnJvci5hcHBseShfaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heWJlQ2FsbGJhY2sgPSBfZ2V0Rmlyc3RGdW5jdGlvbihhcmd1bWVudHMpO1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQobWF5YmVDYWxsYmFjayk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmNyaXRpY2FsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oYXJndW1lbnRzKTtcbiAgdmFyIHV1aWQgPSBpdGVtLnV1aWQ7XG4gIHRoaXMuY2xpZW50LmNyaXRpY2FsKGl0ZW0pO1xuICByZXR1cm4geyB1dWlkOiB1dWlkIH07XG59O1xuUm9sbGJhci5jcml0aWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2UuY3JpdGljYWwuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXliZUNhbGxiYWNrID0gX2dldEZpcnN0RnVuY3Rpb24oYXJndW1lbnRzKTtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKG1heWJlQ2FsbGJhY2spO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5idWlsZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xpZW50LmJ1aWxkSnNvblBheWxvYWQoaXRlbSk7XG59O1xuUm9sbGJhci5idWlsZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5idWlsZEpzb25QYXlsb2FkLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKCk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLnNlbmRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uIChqc29uUGF5bG9hZCkge1xuICByZXR1cm4gdGhpcy5jbGllbnQuc2VuZEpzb25QYXlsb2FkKGpzb25QYXlsb2FkKTtcbn07XG5Sb2xsYmFyLnNlbmRKc29uUGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pbnN0YW5jZSkge1xuICAgIHJldHVybiBfaW5zdGFuY2Uuc2VuZEpzb25QYXlsb2FkLmFwcGx5KF9pbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVVbmluaXRpYWxpemVkKCk7XG4gIH1cbn07XG5cblJvbGxiYXIucHJvdG90eXBlLnNldHVwVW5oYW5kbGVkQ2FwdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdXaW5kb3cgPSBfZ1dpbmRvdygpO1xuXG4gIGlmICghdGhpcy51bmhhbmRsZWRFeGNlcHRpb25zSW5pdGlhbGl6ZWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNhcHR1cmVVbmNhdWdodCB8fCB0aGlzLm9wdGlvbnMuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zKSB7XG4gICAgICBnbG9iYWxzLmNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMoZ1dpbmRvdywgdGhpcyk7XG4gICAgICBpZiAodGhpcy53cmFwR2xvYmFscyAmJiB0aGlzLm9wdGlvbnMud3JhcEdsb2JhbEV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy53cmFwR2xvYmFscyhnV2luZG93LCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5oYW5kbGVkRXhjZXB0aW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCF0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNJbml0aWFsaXplZCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5jYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucyB8fFxuICAgICAgdGhpcy5vcHRpb25zLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbnNcbiAgICApIHtcbiAgICAgIGdsb2JhbHMuY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMoZ1dpbmRvdywgdGhpcyk7XG4gICAgICB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChcbiAgbWVzc2FnZSxcbiAgdXJsLFxuICBsaW5lbm8sXG4gIGNvbG5vLFxuICBlcnJvcixcbiAgY29udGV4dCxcbikge1xuICBpZiAoIXRoaXMub3B0aW9ucy5jYXB0dXJlVW5jYXVnaHQgJiYgIXRoaXMub3B0aW9ucy5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaHJvbWUgd2lsbCBhbHdheXMgc2VuZCA1KyBhcmd1bWVudHMgYW5kIGVycm9yIHdpbGwgYmUgdmFsaWQgb3IgbnVsbCwgbm90IHVuZGVmaW5lZC5cbiAgLy8gSWYgZXJyb3IgaXMgdW5kZWZpbmVkLCB3ZSBoYXZlIGEgZGlmZmVyZW50IGNhbGxlci5cbiAgLy8gQ2hyb21lIGFsc28gc2VuZHMgZXJyb3JzIGZyb20gd2ViIHdvcmtlcnMgd2l0aCBudWxsIGVycm9yLCBidXQgZG9lcyBub3QgaW52b2tlXG4gIC8vIHByZXBhcmVTdGFja1RyYWNlKCkgZm9yIHRoZXNlLiBUZXN0IGZvciBlbXB0eSB1cmwgdG8gc2tpcCB0aGVtLlxuICBpZiAoXG4gICAgdGhpcy5vcHRpb25zLmluc3BlY3RBbm9ueW1vdXNFcnJvcnMgJiZcbiAgICB0aGlzLmlzQ2hyb21lICYmXG4gICAgZXJyb3IgPT09IG51bGwgJiZcbiAgICB1cmwgPT09ICcnXG4gICkge1xuICAgIHJldHVybiAnYW5vbnltb3VzJztcbiAgfVxuXG4gIHZhciBpdGVtO1xuICB2YXIgc3RhY2tJbmZvID0gXy5tYWtlVW5oYW5kbGVkU3RhY2tJbmZvKFxuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIGxpbmVubyxcbiAgICBjb2xubyxcbiAgICBlcnJvcixcbiAgICAnb25lcnJvcicsXG4gICAgJ3VuY2F1Z2h0IGV4Y2VwdGlvbicsXG4gICAgZXJyb3JQYXJzZXIsXG4gICk7XG4gIGlmIChfLmlzRXJyb3IoZXJyb3IpKSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIGVycm9yLCBjb250ZXh0XSk7XG4gICAgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvID0gc3RhY2tJbmZvO1xuICB9IGVsc2UgaWYgKF8uaXNFcnJvcih1cmwpKSB7XG4gICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIHVybCwgY29udGV4dF0pO1xuICAgIGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mbyA9IHN0YWNrSW5mbztcbiAgfSBlbHNlIHtcbiAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShbbWVzc2FnZSwgY29udGV4dF0pO1xuICAgIGl0ZW0uc3RhY2tJbmZvID0gc3RhY2tJbmZvO1xuICB9XG4gIGl0ZW0ubGV2ZWwgPSB0aGlzLm9wdGlvbnMudW5jYXVnaHRFcnJvckxldmVsO1xuICBpdGVtLl9pc1VuY2F1Z2h0ID0gdHJ1ZTtcbiAgdGhpcy5jbGllbnQubG9nKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBDaHJvbWUgb25seS4gT3RoZXIgYnJvd3NlcnMgd2lsbCBpZ25vcmUuXG4gKlxuICogVXNlIEVycm9yLnByZXBhcmVTdGFja1RyYWNlIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gYWJvdXQgZXJyb3JzIHRoYXRcbiAqIGRvIG5vdCBoYXZlIGEgdmFsaWQgZXJyb3Igb2JqZWN0IGluIG9uZXJyb3IoKS5cbiAqXG4gKiBJbiB0ZXN0ZWQgdmVyc2lvbiBvZiBDaHJvbWUsIG9uZXJyb3IgaXMgY2FsbGVkIGZpcnN0IGJ1dCBoYXMgbm8gd2F5XG4gKiB0byBjb21tdW5pY2F0ZSB3aXRoIHByZXBhcmVTdGFja1RyYWNlLiBVc2UgYSBjb3VudGVyIHRvIGxldCB0aGlzXG4gKiBoYW5kbGVyIGtub3cgd2hpY2ggZXJyb3JzIHRvIHNlbmQgdG8gUm9sbGJhci5cbiAqXG4gKiBJbiBjb25maWcgb3B0aW9ucywgc2V0IGluc3BlY3RBbm9ueW1vdXNFcnJvcnMgdG8gZW5hYmxlLlxuICovXG5Sb2xsYmFyLnByb3RvdHlwZS5oYW5kbGVBbm9ueW1vdXNFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmluc3BlY3RBbm9ueW1vdXNFcnJvcnMgfHwgIXRoaXMuaXNDaHJvbWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgciA9IHRoaXM7XG4gIGZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBfc3RhY2spIHtcbiAgICBpZiAoci5vcHRpb25zLmluc3BlY3RBbm9ueW1vdXNFcnJvcnMpIHtcbiAgICAgIGlmIChyLmFub255bW91c0Vycm9yc1BlbmRpbmcpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBrbm93biB3YXkgdG8gZGV0ZWN0IHRoYXQgb25lcnJvciBzYXcgYW4gYW5vbnltb3VzIGVycm9yLlxuICAgICAgICAvLyBJdCBkZXBlbmRzIG9uIG9uZXJyb3IgcmVsaWFibHkgYmVpbmcgY2FsbGVkIGJlZm9yZSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSxcbiAgICAgICAgLy8gd2hpY2ggc28gZmFyIGhvbGRzIHRydWUgb24gdGVzdGVkIHZlcnNpb25zIG9mIENocm9tZS4gSWYgdmVyc2lvbnMgb2YgQ2hyb21lXG4gICAgICAgIC8vIGFyZSB0ZXN0ZWQgdGhhdCBiZWhhdmUgZGlmZmVyZW50bHksIHRoaXMgbG9naWMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgLy8gYWNjb3JkaW5nbHkuXG4gICAgICAgIHIuYW5vbnltb3VzRXJyb3JzUGVuZGluZyAtPSAxO1xuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAvLyBOb3QgbGlrZWx5IHRvIGdldCBoZXJlLCBidXQgY2FsbGluZyBoYW5kbGVVbmNhdWdodEV4Y2VwdGlvbiBmcm9tIGhlcmVcbiAgICAgICAgICAvLyB3aXRob3V0IGFuIGVycm9yIG9iamVjdCB3b3VsZCB0aHJvdyBvZmYgdGhlIGFub255bW91c0Vycm9yc1BlbmRpbmcgY291bnRlcixcbiAgICAgICAgICAvLyBzbyByZXR1cm4gbm93LlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IHRoaXMgdG8gYmUgdHJhY2tlZCBsYXRlci5cbiAgICAgICAgZXJyb3IuX2lzQW5vbnltb3VzID0gdHJ1ZTtcblxuICAgICAgICAvLyB1cmwsIGxpbmVubywgY29sbm8gc2hvdWxkbid0IGJlIG5lZWRlZCBmb3IgdGhlc2UgZXJyb3JzLlxuICAgICAgICAvLyBJZiB0aGF0IGNoYW5nZXMsIHVwZGF0ZSB0aGlzIGFjY29yZGluZ2x5LCB1c2luZyB0aGUgdW51c2VkXG4gICAgICAgIC8vIF9zdGFjayBwYXJhbSBhcyBuZWVkZWQgKHJhdGhlciB0aGFuIHBhcnNlIGVycm9yLnRvU3RyaW5nKCkpLlxuICAgICAgICByLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UsIG51bGwsIG51bGwsIG51bGwsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JrYXJvdW5kIHRvIGVuc3VyZSBzdGFjayBpcyBwcmVzZXJ2ZWQgZm9yIG5vcm1hbCBlcnJvcnMuXG4gICAgcmV0dXJuIGVycm9yLnN0YWNrO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbiAgdHJ5IHtcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXBhcmVTdGFja1RyYWNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vcHRpb25zLmluc3BlY3RBbm9ueW1vdXNFcnJvcnMgPSBmYWxzZTtcbiAgICB0aGlzLmVycm9yKCdhbm9ueW1vdXMgZXJyb3IgaGFuZGxlciBmYWlsZWQnLCBlKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKHJlYXNvbiwgcHJvbWlzZSkge1xuICBpZiAoXG4gICAgIXRoaXMub3B0aW9ucy5jYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucyAmJlxuICAgICF0aGlzLm9wdGlvbnMuaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uc1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9ICd1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcyBudWxsIG9yIHVuZGVmaW5lZCEnO1xuICBpZiAocmVhc29uKSB7XG4gICAgaWYgKHJlYXNvbi5tZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gcmVhc29uLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZWFzb25SZXN1bHQgPSBfLnN0cmluZ2lmeShyZWFzb24pO1xuICAgICAgaWYgKHJlYXNvblJlc3VsdC52YWx1ZSkge1xuICAgICAgICBtZXNzYWdlID0gcmVhc29uUmVzdWx0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgY29udGV4dCA9XG4gICAgKHJlYXNvbiAmJiByZWFzb24uX3JvbGxiYXJDb250ZXh0KSB8fCAocHJvbWlzZSAmJiBwcm9taXNlLl9yb2xsYmFyQ29udGV4dCk7XG5cbiAgdmFyIGl0ZW07XG4gIGlmIChfLmlzRXJyb3IocmVhc29uKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKFttZXNzYWdlLCByZWFzb24sIGNvbnRleHRdKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShbbWVzc2FnZSwgcmVhc29uLCBjb250ZXh0XSk7XG4gICAgaXRlbS5zdGFja0luZm8gPSBfLm1ha2VVbmhhbmRsZWRTdGFja0luZm8oXG4gICAgICBtZXNzYWdlLFxuICAgICAgJycsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG51bGwsXG4gICAgICAndW5oYW5kbGVkcmVqZWN0aW9uJyxcbiAgICAgICcnLFxuICAgICAgZXJyb3JQYXJzZXIsXG4gICAgKTtcbiAgfVxuICBpdGVtLmxldmVsID0gdGhpcy5vcHRpb25zLnVuY2F1Z2h0RXJyb3JMZXZlbDtcbiAgaXRlbS5faXNVbmNhdWdodCA9IHRydWU7XG4gIGl0ZW0uX29yaWdpbmFsQXJncyA9IGl0ZW0uX29yaWdpbmFsQXJncyB8fCBbXTtcbiAgaXRlbS5fb3JpZ2luYWxBcmdzLnB1c2gocHJvbWlzZSk7XG4gIHRoaXMuY2xpZW50LmxvZyhpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoZiwgY29udGV4dCwgX2JlZm9yZSkge1xuICB0cnkge1xuICAgIHZhciBjdHhGbjtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICBjdHhGbiA9IGNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eEZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dCB8fCB7fTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZikpIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIGlmIChmLl9pc1dyYXApIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIGlmICghZi5fcm9sbGJhcl93cmFwcGVkKSB7XG4gICAgICBmLl9yb2xsYmFyX3dyYXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfYmVmb3JlICYmIF8uaXNGdW5jdGlvbihfYmVmb3JlKSkge1xuICAgICAgICAgIF9iZWZvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgIHZhciBlID0gZXhjO1xuICAgICAgICAgIGlmIChlICYmIHdpbmRvdy5fcm9sbGJhcldyYXBwZWRFcnJvciAhPT0gZSkge1xuICAgICAgICAgICAgaWYgKF8uaXNUeXBlKGUsICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBlID0gbmV3IFN0cmluZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuX3JvbGxiYXJDb250ZXh0ID0gY3R4Rm4oKSB8fCB7fTtcbiAgICAgICAgICAgIGUuX3JvbGxiYXJDb250ZXh0Ll93cmFwcGVkU291cmNlID0gZi50b1N0cmluZygpO1xuXG4gICAgICAgICAgICB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmLl9yb2xsYmFyX3dyYXBwZWQuX2lzV3JhcCA9IHRydWU7XG5cbiAgICAgIGlmIChmLmhhc093blByb3BlcnR5KSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZikge1xuICAgICAgICAgIGlmIChmLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgIT09ICdfcm9sbGJhcl93cmFwcGVkJykge1xuICAgICAgICAgICAgZi5fcm9sbGJhcl93cmFwcGVkW3Byb3BdID0gZltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZi5fcm9sbGJhcl93cmFwcGVkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpZiB0aGUgd3JhcCBmYWlscy5cbiAgICByZXR1cm4gZjtcbiAgfVxufTtcblJvbGxiYXIud3JhcCA9IGZ1bmN0aW9uIChmLCBjb250ZXh0KSB7XG4gIGlmIChfaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gX2luc3RhbmNlLndyYXAoZiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlVW5pbml0aWFsaXplZCgpO1xuICB9XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBldmVudCA9IF8uY3JlYXRlVGVsZW1ldHJ5RXZlbnQoYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXMuY2xpZW50LmNhcHR1cmVFdmVudChldmVudC50eXBlLCBldmVudC5tZXRhZGF0YSwgZXZlbnQubGV2ZWwpO1xufTtcblJvbGxiYXIuY2FwdHVyZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luc3RhbmNlKSB7XG4gICAgcmV0dXJuIF9pbnN0YW5jZS5jYXB0dXJlRXZlbnQuYXBwbHkoX2luc3RhbmNlLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVVuaW5pdGlhbGl6ZWQoKTtcbiAgfVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyB0d28gbWV0aG9kcyBhcmUgdXNlZCBpbnRlcm5hbGx5IGFuZCBhcmUgbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlRG9tQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uIChlLCB0cykge1xuICBpZiAoIXRzKSB7XG4gICAgdHMgPSBuZXcgRGF0ZSgpO1xuICB9XG4gIHJldHVybiB0aGlzLmNsaWVudC5jYXB0dXJlRG9tQ29udGVudExvYWRlZCh0cyk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jYXB0dXJlTG9hZCA9IGZ1bmN0aW9uIChlLCB0cykge1xuICBpZiAoIXRzKSB7XG4gICAgdHMgPSBuZXcgRGF0ZSgpO1xuICB9XG4gIHJldHVybiB0aGlzLmNsaWVudC5jYXB0dXJlTG9hZCh0cyk7XG59O1xuXG4vKiBJbnRlcm5hbCAqL1xuXG5mdW5jdGlvbiBhZGRUcmFuc2Zvcm1zVG9Ob3RpZmllcihub3RpZmllciwgcm9sbGJhciwgZ1dpbmRvdykge1xuICBub3RpZmllclxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5oYW5kbGVEb21FeGNlcHRpb24pXG4gICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmhhbmRsZUl0ZW1XaXRoRXJyb3IpXG4gICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheSlcbiAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkQmFzZUluZm8pXG4gICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmFkZFJlcXVlc3RJbmZvKGdXaW5kb3cpKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRDbGllbnRJbmZvKGdXaW5kb3cpKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRQbHVnaW5JbmZvKGdXaW5kb3cpKVxuICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRCb2R5KVxuICAgIC5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5hZGRNZXNzYWdlV2l0aEVycm9yKVxuICAgIC5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5hZGRUZWxlbWV0cnlEYXRhKVxuICAgIC5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5hZGRDb25maWdUb1BheWxvYWQpXG4gICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmFkZFNjcnViYmVyKHJvbGxiYXIuc2NydWIpKVxuICAgIC5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5hZGRQYXlsb2FkT3B0aW9ucylcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMudXNlclRyYW5zZm9ybShsb2dnZXIpKVxuICAgIC5hZGRUcmFuc2Zvcm0oc2hhcmVkVHJhbnNmb3Jtcy5hZGRDb25maWd1cmVkT3B0aW9ucylcbiAgICAuYWRkVHJhbnNmb3JtKHNoYXJlZFRyYW5zZm9ybXMuYWRkRGlhZ25vc3RpY0tleXMpXG4gICAgLmFkZFRyYW5zZm9ybShzaGFyZWRUcmFuc2Zvcm1zLml0ZW1Ub1BheWxvYWQpO1xufVxuXG5mdW5jdGlvbiBhZGRQcmVkaWNhdGVzVG9RdWV1ZShxdWV1ZSkge1xuICBxdWV1ZVxuICAgIC5hZGRQcmVkaWNhdGUoc2hhcmVkUHJlZGljYXRlcy5jaGVja0xldmVsKVxuICAgIC5hZGRQcmVkaWNhdGUocHJlZGljYXRlcy5jaGVja0lnbm9yZSlcbiAgICAuYWRkUHJlZGljYXRlKHNoYXJlZFByZWRpY2F0ZXMudXNlckNoZWNrSWdub3JlKGxvZ2dlcikpXG4gICAgLmFkZFByZWRpY2F0ZShzaGFyZWRQcmVkaWNhdGVzLnVybElzTm90QmxvY2tMaXN0ZWQobG9nZ2VyKSlcbiAgICAuYWRkUHJlZGljYXRlKHNoYXJlZFByZWRpY2F0ZXMudXJsSXNTYWZlTGlzdGVkKGxvZ2dlcikpXG4gICAgLmFkZFByZWRpY2F0ZShzaGFyZWRQcmVkaWNhdGVzLm1lc3NhZ2VJc0lnbm9yZWQobG9nZ2VyKSk7XG59XG5cblJvbGxiYXIucHJvdG90eXBlLmxvYWRGdWxsID0gZnVuY3Rpb24gKCkge1xuICBsb2dnZXIuaW5mbyhcbiAgICAnVW5leHBlY3RlZCBSb2xsYmFyLmxvYWRGdWxsKCkgY2FsbGVkIG9uIGEgTm90aWZpZXIgaW5zdGFuY2UuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIFJvbGxiYXIgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLicsXG4gICk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5fY3JlYXRlSXRlbSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHJldHVybiBfLmNyZWF0ZUl0ZW0oYXJncywgbG9nZ2VyLCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIF9nZXRGaXJzdEZ1bmN0aW9uKGFyZ3MpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3NbaV0pKSB7XG4gICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX2dXaW5kb3coKSB7XG4gIHJldHVybiAoXG4gICAgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93KSB8fFxuICAgICh0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmKVxuICApO1xufVxuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIHNjcnViRmllbGRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cy9zY3J1YkZpZWxkcycpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHZlcnNpb246IGRlZmF1bHRzLnZlcnNpb24sXG4gIHNjcnViRmllbGRzOiBzY3J1YkZpZWxkcy5zY3J1YkZpZWxkcyxcbiAgbG9nTGV2ZWw6IGRlZmF1bHRzLmxvZ0xldmVsLFxuICByZXBvcnRMZXZlbDogZGVmYXVsdHMucmVwb3J0TGV2ZWwsXG4gIHVuY2F1Z2h0RXJyb3JMZXZlbDogZGVmYXVsdHMudW5jYXVnaHRFcnJvckxldmVsLFxuICBlbmRwb2ludDogZGVmYXVsdHMuZW5kcG9pbnQsXG4gIHZlcmJvc2U6IGZhbHNlLFxuICBlbmFibGVkOiB0cnVlLFxuICB0cmFuc21pdDogdHJ1ZSxcbiAgc2VuZENvbmZpZzogZmFsc2UsXG4gIGluY2x1ZGVJdGVtc0luVGVsZW1ldHJ5OiB0cnVlLFxuICBjYXB0dXJlSXA6IHRydWUsXG4gIGluc3BlY3RBbm9ueW1vdXNFcnJvcnM6IHRydWUsXG4gIGlnbm9yZUR1cGxpY2F0ZUVycm9yczogdHJ1ZSxcbiAgd3JhcEdsb2JhbEV2ZW50SGFuZGxlcnM6IGZhbHNlLFxuICByZWNvcmRlcjogcmVjb3JkZXJEZWZhdWx0cyxcbiAgdHJhY2luZzogdHJhY2luZ0RlZmF1bHRzLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb2xsYmFyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNjcnViRmllbGRzOiBbXG4gICAgJ3B3JyxcbiAgICAncGFzcycsXG4gICAgJ3Bhc3N3ZCcsXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAnc2VjcmV0JyxcbiAgICAnY29uZmlybV9wYXNzd29yZCcsXG4gICAgJ2NvbmZpcm1QYXNzd29yZCcsXG4gICAgJ3Bhc3N3b3JkX2NvbmZpcm1hdGlvbicsXG4gICAgJ3Bhc3N3b3JkQ29uZmlybWF0aW9uJyxcbiAgICAnYWNjZXNzX3Rva2VuJyxcbiAgICAnYWNjZXNzVG9rZW4nLFxuICAgICdYLVJvbGxiYXItQWNjZXNzLVRva2VuJyxcbiAgICAnc2VjcmV0X2tleScsXG4gICAgJ3NlY3JldEtleScsXG4gICAgJ3NlY3JldFRva2VuJyxcbiAgICAnY2MtbnVtYmVyJyxcbiAgICAnY2FyZCBudW1iZXInLFxuICAgICdjYXJkbnVtYmVyJyxcbiAgICAnY2FyZG51bScsXG4gICAgJ2NjbnVtJyxcbiAgICAnY2NudW1iZXInLFxuICAgICdjYyBudW0nLFxuICAgICdjcmVkaXRjYXJkbnVtYmVyJyxcbiAgICAnY3JlZGl0IGNhcmQgbnVtYmVyJyxcbiAgICAnbmV3Y3JlZGl0Y2FyZG51bWJlcicsXG4gICAgJ25ldyBjcmVkaXQgY2FyZCcsXG4gICAgJ2NyZWRpdGNhcmRubycsXG4gICAgJ2NyZWRpdCBjYXJkIG5vJyxcbiAgICAnY2FyZCMnLFxuICAgICdjYXJkICMnLFxuICAgICdjYy1jc2MnLFxuICAgICdjdmMnLFxuICAgICdjdmMyJyxcbiAgICAnY3Z2MicsXG4gICAgJ2NjdjInLFxuICAgICdzZWN1cml0eSBjb2RlJyxcbiAgICAnY2FyZCB2ZXJpZmljYXRpb24nLFxuICAgICduYW1lIG9uIGNyZWRpdCBjYXJkJyxcbiAgICAnbmFtZSBvbiBjYXJkJyxcbiAgICAnbmFtZW9uY2FyZCcsXG4gICAgJ2NhcmRob2xkZXInLFxuICAgICdjYXJkIGhvbGRlcicsXG4gICAgJ25hbWUgZGVzIGthcnRlbmluaGFiZXJzJyxcbiAgICAnY2NuYW1lJyxcbiAgICAnY2FyZCB0eXBlJyxcbiAgICAnY2FyZHR5cGUnLFxuICAgICdjYyB0eXBlJyxcbiAgICAnY2N0eXBlJyxcbiAgICAncGF5bWVudCB0eXBlJyxcbiAgICAnZXhwaXJhdGlvbiBkYXRlJyxcbiAgICAnZXhwaXJhdGlvbmRhdGUnLFxuICAgICdleHBkYXRlJyxcbiAgICAnY2MtZXhwJyxcbiAgICAnY2Ntb250aCcsXG4gICAgJ2NjeWVhcicsXG4gIF0sXG59O1xuIiwiLy8gVGhpcyBkZXRlY3Rpb24uanMgbW9kdWxlIGlzIHVzZWQgdG8gZW5jYXBzdWxhdGUgYW55IHVnbHkgYnJvd3Nlci9mZWF0dXJlXG4vLyBkZXRlY3Rpb24gd2UgbWF5IG5lZWQgdG8gZG8uXG5cbi8vIEZpZ3VyZSBvdXQgd2hpY2ggdmVyc2lvbiBvZiBJRSB3ZSdyZSB1c2luZywgaWYgYW55LlxuLy8gVGhpcyBpcyBnbGVhbmVkIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTc0ODQyL2Jlc3Qtd2F5LXRvLWNoZWNrLWZvci1pZS1sZXNzLXRoYW4tOS1pbi1qYXZhc2NyaXB0LXdpdGhvdXQtbGlicmFyeVxuLy8gV2lsbCByZXR1cm4gYW4gaW50ZWdlciBvbiBJRSAoaS5lLiA4KVxuLy8gV2lsbCByZXR1cm4gdW5kZWZpbmVkIG90aGVyd2lzZVxuZnVuY3Rpb24gZ2V0SUVWZXJzaW9uKCkge1xuICB2YXIgdW5kZWY7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHVuZGVmO1xuICB9XG5cbiAgdmFyIHYgPSAzLFxuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuXG4gIHdoaWxlIChcbiAgICAoKGRpdi5pbm5lckhUTUwgPSAnPCEtLVtpZiBndCBJRSAnICsgKyt2ICsgJ10+PGk+PC9pPjwhW2VuZGlmXS0tPicpLCBhbGxbMF0pXG4gICk7XG5cbiAgcmV0dXJuIHYgPiA0ID8gdiA6IHVuZGVmO1xufVxuXG52YXIgRGV0ZWN0aW9uID0ge1xuICBpZVZlcnNpb246IGdldElFVmVyc2lvbixcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGV0ZWN0aW9uO1xuIiwiZnVuY3Rpb24gZ2V0RWxlbWVudFR5cGUoZSkge1xuICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKCd0eXBlJykgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIGlzRGVzY3JpYmVkRWxlbWVudChlbGVtZW50LCB0eXBlLCBzdWJ0eXBlcykge1xuICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXN1YnR5cGVzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxlbWVudCA9IGdldEVsZW1lbnRUeXBlKGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN1YnR5cGVzW2ldID09PSBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50RnJvbUV2ZW50KGV2dCwgZG9jKSB7XG4gIGlmIChldnQudGFyZ2V0KSB7XG4gICAgcmV0dXJuIGV2dC50YXJnZXQ7XG4gIH1cbiAgaWYgKGRvYyAmJiBkb2MuZWxlbWVudEZyb21Qb2ludCkge1xuICAgIHJldHVybiBkb2MuZWxlbWVudEZyb21Qb2ludChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHRyZWVUb0FycmF5KGVsZW0pIHtcbiAgdmFyIE1BWF9IRUlHSFQgPSA1O1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBuZXh0RGVzY3JpcHRpb247XG4gIGZvciAodmFyIGhlaWdodCA9IDA7IGVsZW0gJiYgaGVpZ2h0IDwgTUFYX0hFSUdIVDsgaGVpZ2h0KyspIHtcbiAgICBuZXh0RGVzY3JpcHRpb24gPSBkZXNjcmliZUVsZW1lbnQoZWxlbSk7XG4gICAgaWYgKG5leHREZXNjcmlwdGlvbi50YWdOYW1lID09PSAnaHRtbCcpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdXQudW5zaGlmdChuZXh0RGVzY3JpcHRpb24pO1xuICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZWxlbWVudEFycmF5VG9TdHJpbmcoYSkge1xuICB2YXIgTUFYX0xFTkdUSCA9IDgwO1xuICB2YXIgc2VwYXJhdG9yID0gJyA+ICcsXG4gICAgc2VwYXJhdG9yTGVuZ3RoID0gc2VwYXJhdG9yLmxlbmd0aDtcbiAgdmFyIG91dCA9IFtdLFxuICAgIGxlbiA9IDAsXG4gICAgbmV4dFN0cixcbiAgICB0b3RhbExlbmd0aDtcblxuICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG5leHRTdHIgPSBkZXNjcmlwdGlvblRvU3RyaW5nKGFbaV0pO1xuICAgIHRvdGFsTGVuZ3RoID0gbGVuICsgb3V0Lmxlbmd0aCAqIHNlcGFyYXRvckxlbmd0aCArIG5leHRTdHIubGVuZ3RoO1xuICAgIGlmIChpIDwgYS5sZW5ndGggLSAxICYmIHRvdGFsTGVuZ3RoID49IE1BWF9MRU5HVEggKyAzKSB7XG4gICAgICBvdXQudW5zaGlmdCgnLi4uJyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3V0LnVuc2hpZnQobmV4dFN0cik7XG4gICAgbGVuICs9IG5leHRTdHIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBvdXQuam9pbihzZXBhcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmlwdGlvblRvU3RyaW5nKGRlc2MpIHtcbiAgaWYgKCFkZXNjIHx8ICFkZXNjLnRhZ05hbWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIG91dCA9IFtkZXNjLnRhZ05hbWVdO1xuICBpZiAoZGVzYy5pZCkge1xuICAgIG91dC5wdXNoKCcjJyArIGRlc2MuaWQpO1xuICB9XG4gIGlmIChkZXNjLmNsYXNzZXMpIHtcbiAgICBvdXQucHVzaCgnLicgKyBkZXNjLmNsYXNzZXMuam9pbignLicpKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2MuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIG91dC5wdXNoKFxuICAgICAgJ1snICsgZGVzYy5hdHRyaWJ1dGVzW2ldLmtleSArICc9XCInICsgZGVzYy5hdHRyaWJ1dGVzW2ldLnZhbHVlICsgJ1wiXScsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBvdXQuam9pbignJyk7XG59XG5cbi8qKlxuICogSW5wdXQ6IGEgZG9tIGVsZW1lbnRcbiAqIE91dHB1dDogbnVsbCBpZiB0YWdOYW1lIGlzIGZhbHNleSBvciBpbnB1dCBpcyBmYWxzZXksIGVsc2VcbiAqICB7XG4gKiAgICB0YWdOYW1lOiBTdHJpbmcsXG4gKiAgICBpZDogU3RyaW5nIHwgdW5kZWZpbmVkLFxuICogICAgY2xhc3NlczogW1N0cmluZ10gfCB1bmRlZmluZWQsXG4gKiAgICBhdHRyaWJ1dGVzOiBbXG4gKiAgICAgIHtcbiAqICAgICAgICBrZXk6IE9uZU9mKHR5cGUsIG5hbWUsIHRpdGxlLCBhbHQpLFxuICogICAgICAgIHZhbHVlOiBTdHJpbmdcbiAqICAgICAgfVxuICogICAgXVxuICogIH1cbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50KGVsZW0pIHtcbiAgaWYgKCFlbGVtIHx8ICFlbGVtLnRhZ05hbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgb3V0ID0ge30sXG4gICAgY2xhc3NOYW1lLFxuICAgIGtleSxcbiAgICBhdHRyLFxuICAgIGk7XG4gIG91dC50YWdOYW1lID0gZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChlbGVtLmlkKSB7XG4gICAgb3V0LmlkID0gZWxlbS5pZDtcbiAgfVxuICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZTtcbiAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgIG91dC5jbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG4gIH1cbiAgdmFyIGF0dHJpYnV0ZXMgPSBbJ3R5cGUnLCAnbmFtZScsICd0aXRsZScsICdhbHQnXTtcbiAgb3V0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBhdHRyaWJ1dGVzW2ldO1xuICAgIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBvdXQuYXR0cmlidXRlcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiBhdHRyIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzY3JpYmVFbGVtZW50OiBkZXNjcmliZUVsZW1lbnQsXG4gIGRlc2NyaXB0aW9uVG9TdHJpbmc6IGRlc2NyaXB0aW9uVG9TdHJpbmcsXG4gIGVsZW1lbnRBcnJheVRvU3RyaW5nOiBlbGVtZW50QXJyYXlUb1N0cmluZyxcbiAgdHJlZVRvQXJyYXk6IHRyZWVUb0FycmF5LFxuICBnZXRFbGVtZW50RnJvbUV2ZW50OiBnZXRFbGVtZW50RnJvbUV2ZW50LFxuICBpc0Rlc2NyaWJlZEVsZW1lbnQ6IGlzRGVzY3JpYmVkRWxlbWVudCxcbiAgZ2V0RWxlbWVudFR5cGU6IGdldEVsZW1lbnRUeXBlLFxufTtcbiIsImZ1bmN0aW9uIGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvbGRPbkVycm9yO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5fcm9sbGJhck9sZE9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbGRPbkVycm9yID0gaGFuZGxlci5fcm9sbGJhck9sZE9uRXJyb3I7XG4gIH0gZWxzZSBpZiAod2luZG93Lm9uZXJyb3IpIHtcbiAgICBvbGRPbkVycm9yID0gd2luZG93Lm9uZXJyb3I7XG4gICAgd2hpbGUgKG9sZE9uRXJyb3IuX3JvbGxiYXJPbGRPbkVycm9yKSB7XG4gICAgICBvbGRPbkVycm9yID0gb2xkT25FcnJvci5fcm9sbGJhck9sZE9uRXJyb3I7XG4gICAgfVxuICAgIGhhbmRsZXIuX3JvbGxiYXJPbGRPbkVycm9yID0gb2xkT25FcnJvcjtcbiAgfVxuXG4gIGhhbmRsZXIuaGFuZGxlQW5vbnltb3VzRXJyb3JzKCk7XG5cbiAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICBfcm9sbGJhcldpbmRvd09uRXJyb3Iod2luZG93LCBoYW5kbGVyLCBvbGRPbkVycm9yLCBhcmdzKTtcbiAgfTtcbiAgaWYgKHNoaW0pIHtcbiAgICBmbi5fcm9sbGJhck9sZE9uRXJyb3IgPSBvbGRPbkVycm9yO1xuICB9XG4gIHdpbmRvdy5vbmVycm9yID0gZm47XG59XG5cbmZ1bmN0aW9uIF9yb2xsYmFyV2luZG93T25FcnJvcih3aW5kb3csIHIsIG9sZCwgYXJncykge1xuICBpZiAod2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yKSB7XG4gICAgaWYgKCFhcmdzWzRdKSB7XG4gICAgICBhcmdzWzRdID0gd2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yO1xuICAgIH1cbiAgICBpZiAoIWFyZ3NbNV0pIHtcbiAgICAgIGFyZ3NbNV0gPSB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IuX3JvbGxiYXJDb250ZXh0O1xuICAgIH1cbiAgICB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IgPSBudWxsO1xuICB9XG5cbiAgdmFyIHJldCA9IHIuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24uYXBwbHkociwgYXJncyk7XG5cbiAgaWYgKG9sZCkge1xuICAgIG9sZC5hcHBseSh3aW5kb3csIGFyZ3MpO1xuICB9XG5cbiAgLy8gTGV0IG90aGVyIGNoYWluZWQgb25lcnJvciBoYW5kbGVycyBhYm92ZSBydW4gYmVmb3JlIHNldHRpbmcgdGhpcy5cbiAgLy8gSWYgYW4gZXJyb3IgaXMgdGhyb3duIGFuZCBjYXVnaHQgd2l0aGluIGEgY2hhaW5lZCBvbmVycm9yIGhhbmRsZXIsXG4gIC8vIEVycm9yLnByZXBhcmVTdGFja1RyYWNlKCkgd2lsbCBzZWUgdGhhdCBvbmUgYmVmb3JlIHRoZSBvbmUgd2Ugd2FudC5cbiAgaWYgKHJldCA9PT0gJ2Fub255bW91cycpIHtcbiAgICByLmFub255bW91c0Vycm9yc1BlbmRpbmcgKz0gMTsgLy8gU2VlIFJvbGxiYXIucHJvdG90eXBlLmhhbmRsZUFub255bW91c0Vycm9ycygpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cuX3JvbGxiYXJVUkggPT09ICdmdW5jdGlvbicgJiZcbiAgICB3aW5kb3cuX3JvbGxiYXJVUkguYmVsb25nc1RvU2hpbVxuICApIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgd2luZG93Ll9yb2xsYmFyVVJIKTtcbiAgfVxuXG4gIHZhciByZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciByZWFzb24sIHByb21pc2UsIGRldGFpbDtcbiAgICB0cnkge1xuICAgICAgcmVhc29uID0gZXZ0LnJlYXNvbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWFzb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZXZ0LnByb21pc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcHJvbWlzZSA9ICdbdW5oYW5kbGVkcmVqZWN0aW9uXSBlcnJvciBnZXR0aW5nIGBwcm9taXNlYCBmcm9tIGV2ZW50JztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRldGFpbCA9IGV2dC5kZXRhaWw7XG4gICAgICBpZiAoIXJlYXNvbiAmJiBkZXRhaWwpIHtcbiAgICAgICAgcmVhc29uID0gZGV0YWlsLnJlYXNvbjtcbiAgICAgICAgcHJvbWlzZSA9IGRldGFpbC5wcm9taXNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgIH1cbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgcmVhc29uID0gJ1t1bmhhbmRsZWRyZWplY3Rpb25dIGVycm9yIGdldHRpbmcgYHJlYXNvbmAgZnJvbSBldmVudCc7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5oYW5kbGVVbmhhbmRsZWRSZWplY3Rpb24pIHtcbiAgICAgIGhhbmRsZXIuaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uKHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgfVxuICB9O1xuICByZWplY3Rpb25IYW5kbGVyLmJlbG9uZ3NUb1NoaW0gPSBzaGltO1xuICB3aW5kb3cuX3JvbGxiYXJVUkggPSByZWplY3Rpb25IYW5kbGVyO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgcmVqZWN0aW9uSGFuZGxlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYXB0dXJlVW5jYXVnaHRFeGNlcHRpb25zOiBjYXB0dXJlVW5jYXVnaHRFeGNlcHRpb25zLFxuICBjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9uczogY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMsXG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xucmVxdWlyZSgnY29uc29sZS1wb2x5ZmlsbCcpO1xudmFyIGRldGVjdGlvbiA9IHJlcXVpcmUoJy4vZGV0ZWN0aW9uJyk7XG52YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWxpdHknKTtcblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgYXJncy51bnNoaWZ0KCdSb2xsYmFyOicpO1xuICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcbiAgICBjb25zb2xlLmVycm9yKF8uZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgYXJncy51bnNoaWZ0KCdSb2xsYmFyOicpO1xuICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcbiAgICBjb25zb2xlLmluZm8oXy5mb3JtYXRBcmdzQXNTdHJpbmcoYXJncykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgYXJncy51bnNoaWZ0KCdSb2xsYmFyOicpO1xuICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcbiAgICBjb25zb2xlLmxvZyhfLmZvcm1hdEFyZ3NBc1N0cmluZyhhcmdzKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIH1cbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlcnJvcjogZXJyb3IsXG4gIGluZm86IGluZm8sXG4gIGxvZzogbG9nLFxufTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbGl0eScpO1xuXG5mdW5jdGlvbiBjaGVja0lnbm9yZShpdGVtLCBzZXR0aW5ncykge1xuICBpZiAoXy5nZXQoc2V0dGluZ3MsICdwbHVnaW5zLmpxdWVyeS5pZ25vcmVBamF4RXJyb3JzJykpIHtcbiAgICByZXR1cm4gIV8uZ2V0KGl0ZW0sICdib2R5Lm1lc3NhZ2UuZXh0cmEuaXNBamF4Jyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja0lnbm9yZTogY2hlY2tJZ25vcmUsXG59O1xuIiwiLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBycndlYiByZWNvcmRlclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ycndlYi1pby9ycndlYi9ibG9iL21hc3Rlci9ndWlkZS5tZCNvcHRpb25zIGZvciBkZXRhaWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW5hYmxlZDogZmFsc2UsIC8vIFdoZXRoZXIgcmVjb3JkaW5nIGlzIGVuYWJsZWRcbiAgYXV0b1N0YXJ0OiB0cnVlLCAvLyBTdGFydCByZWNvcmRpbmcgYXV0b21hdGljYWxseSB3aGVuIFJvbGxiYXIgaW5pdGlhbGl6ZXNcbiAgZGVidWc6IHtcbiAgICBsb2dFbWl0czogZmFsc2UsIC8vIFdoZXRoZXIgdG8gbG9nIGVtaXR0ZWQgZXZlbnRzXG4gIH0sXG5cbiAgLy8gUmVjb3JkaW5nIG9wdGlvbnNcbiAgaW5saW5lU3R5bGVzaGVldDogdHJ1ZSwgLy8gV2hldGhlciB0byBpbmxpbmUgc3R5bGVzaGVldHMgdG8gaW1wcm92ZSByZXBsYXkgYWNjdXJhY3lcbiAgaW5saW5lSW1hZ2VzOiBmYWxzZSwgLy8gV2hldGhlciB0byByZWNvcmQgdGhlIGltYWdlIGNvbnRlbnRcbiAgY29sbGVjdEZvbnRzOiB0cnVlLCAvLyBXaGV0aGVyIHRvIGNvbGxlY3QgZm9udHMgaW4gdGhlIHdlYnNpdGVcblxuICAvLyBQcml2YWN5IG9wdGlvbnNcbiAgLy8gRmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB3aGljaCBpbnB1dCB0eXBlcyB0byBtYXNrXG4gIC8vIEJ5IGRlZmF1bHQgb25seSBwYXNzd29yZCBpbnB1dHMgYXJlIG1hc2tlZCBpZiBtYXNrSW5wdXRzIGlzIHRydWVcbiAgbWFza0lucHV0T3B0aW9uczoge1xuICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgIGVtYWlsOiBmYWxzZSxcbiAgICB0ZWw6IGZhbHNlLFxuICAgIHRleHQ6IGZhbHNlLFxuICAgIGNvbG9yOiBmYWxzZSxcbiAgICBkYXRlOiBmYWxzZSxcbiAgICAnZGF0ZXRpbWUtbG9jYWwnOiBmYWxzZSxcbiAgICBtb250aDogZmFsc2UsXG4gICAgbnVtYmVyOiBmYWxzZSxcbiAgICByYW5nZTogZmFsc2UsXG4gICAgc2VhcmNoOiBmYWxzZSxcbiAgICB0aW1lOiBmYWxzZSxcbiAgICB1cmw6IGZhbHNlLFxuICAgIHdlZWs6IGZhbHNlLFxuICB9LFxuXG4gIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBwYXJ0cyBvZiB0aGUgRE9NXG4gIC8vIEJ5IGRlZmF1bHQgYWxsIHJlbW92YWJsZSBlbGVtZW50cyBhcmUgcmVtb3ZlZFxuICBzbGltRE9NT3B0aW9uczoge1xuICAgIHNjcmlwdDogdHJ1ZSwgLy8gUmVtb3ZlIHNjcmlwdCBlbGVtZW50c1xuICAgIGNvbW1lbnQ6IHRydWUsIC8vIFJlbW92ZSBjb21tZW50c1xuICAgIGhlYWRGYXZpY29uOiB0cnVlLCAvLyBSZW1vdmUgZmF2aWNvbnMgaW4gdGhlIGhlYWRcbiAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSwgLy8gUmVtb3ZlIHdoaXRlc3BhY2UgaW4gaGVhZFxuICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiB0cnVlLCAvLyBSZW1vdmUgbWV0YSBkZXNjcmlwdGlvbiBhbmQga2V5d29yZHNcbiAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSwgLy8gUmVtb3ZlIHNvY2lhbCBtZWRpYSBtZXRhIHRhZ3NcbiAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSwgLy8gUmVtb3ZlIHJvYm90cyBtZXRhIGRpcmVjdGl2ZXNcbiAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSwgLy8gUmVtb3ZlIGh0dHAtZXF1aXYgbWV0YSBkaXJlY3RpdmVzXG4gICAgaGVhZE1ldGFBdXRob3JzaGlwOiB0cnVlLCAvLyBSZW1vdmUgYXV0aG9yc2hpcCBtZXRhIGRpcmVjdGl2ZXNcbiAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZSwgLy8gUmVtb3ZlIHZlcmlmaWNhdGlvbiBtZXRhIGRpcmVjdGl2ZXNcbiAgfSxcblxuICAvLyBDdXN0b20gY2FsbGJhY2tzIGZvciBhZHZhbmNlZCB1c2UgY2FzZXNcbiAgLy8gVGhlc2UgYXJlIHVuZGVmaW5lZCBieSBkZWZhdWx0IGFuZCBjYW4gYmUgc2V0IHByb2dyYW1tYXRpY2FsbHlcbiAgLy8gbWFza0lucHV0Rm46IHVuZGVmaW5lZCwgICAgICAvLyBDdXN0b20gZnVuY3Rpb24gdG8gbWFzayBpbnB1dCB2YWx1ZXNcbiAgLy8gbWFza1RleHRGbjogdW5kZWZpbmVkLCAgICAgICAvLyBDdXN0b20gZnVuY3Rpb24gdG8gbWFzayB0ZXh0IGNvbnRlbnRcbiAgLy8gZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsICAgICAvLyBDdXN0b20gZXJyb3IgaGFuZGxlciBmb3IgcmVjb3JkaW5nIGVycm9yc1xuXG4gIC8vIFBsdWdpbiBzeXN0ZW1cbiAgLy8gcGx1Z2luczogW10gICAgICAgICAgICAgICAgICAvLyBMaXN0IG9mIHBsdWdpbnMgdG8gdXNlIChtdXN0IGJlIHNldCBwcm9ncmFtbWF0aWNhbGx5KVxufTtcbiIsImltcG9ydCB7IHJlY29yZCBhcyBycndlYlJlY29yZEZuIH0gZnJvbSAnQHJyd2ViL3JlY29yZCc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICdAcnJ3ZWIvdHlwZXMnO1xuXG5pbXBvcnQgaHJ0aW1lIGZyb20gJy4uLy4uL3RyYWNpbmcvaHJ0aW1lLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkZXIge1xuICAjb3B0aW9ucztcbiAgI3N0b3BGbiA9IG51bGw7XG4gICNyZWNvcmRGbjtcbiAgI2V2ZW50cyA9IHtcbiAgICBwcmV2aW91czogW10sXG4gICAgY3VycmVudDogW10sXG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmVjb3JkZXIgaW5zdGFuY2UgZm9yIGNhcHR1cmluZyBET00gZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcmVjb3JkZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlY29yZEZuPXJyd2ViUmVjb3JkRm5dIC0gVGhlIHJlY29yZGluZyBmdW5jdGlvbiB0byB1c2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlY29yZEZuID0gcnJ3ZWJSZWNvcmRGbikge1xuICAgIGlmICghcmVjb3JkRm4pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAncmVjb3JkRm4nIHRvIGJlIHByb3ZpZGVkXCIpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlcjogSW5pdGlhbGl6aW5nLi4uJyk7XG4gICAgY29uc29sZS5sb2coJ29wdGlvbnMnLCBvcHRpb25zKTtcblxuICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuICAgIHRoaXMuI3JlY29yZEZuID0gcmVjb3JkRm47XG4gIH1cblxuICBnZXQgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3BGbiAhPT0gbnVsbDtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMobmV3T3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlndXJlKG5ld09wdGlvbnMpO1xuICB9XG5cbiAgY29uZmlndXJlKG5ld09wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5pc1JlY29yZGluZyAmJiBuZXdPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLiNvcHRpb25zID0gbmV3T3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyByZWNvcmRlZCBldmVudHMgaW50byBhIGZvcm1hdHRlZCBwYXlsb2FkIHJlYWR5IGZvciB0cmFuc3BvcnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIHRoZSByZWNvcmRlcidzIHN0b3JlZCBldmVudHMsIGNyZWF0ZXMgYSBuZXcgc3BhbiB3aXRoIHRoZVxuICAgKiBwcm92aWRlZCB0cmFjaW5nIGNvbnRleHQsIGF0dGFjaGVzIGFsbCBldmVudHMgd2l0aCB0aGVpciB0aW1lc3RhbXBzIGFzIHNwYW5cbiAgICogZXZlbnRzLCBhbmQgdGhlbiByZXR1cm5zIGEgcGF5bG9hZCByZWFkeSBmb3IgdHJhbnNwb3J0IHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFjaW5nIC0gVGhlIHRyYWNpbmcgc3lzdGVtIGluc3RhbmNlIHRvIGNyZWF0ZSBzcGFuc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBVbmlxdWUgaWRlbnRpZmllciB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIHJlcGxheSByZWNvcmRpbmdcbiAgICogQHJldHVybnMge09iamVjdHxudWxsfSBBIGZvcm1hdHRlZCBwYXlsb2FkIGNvbnRhaW5pbmcgc3BhbnMgZGF0YSBpbiBPVExQIGZvcm1hdCwgb3IgbnVsbCBpZiBubyBldmVudHMgZXhpc3RcbiAgICovXG4gIGR1bXAodHJhY2luZywgcmVwbGF5SWQsIG9jY3VycmVuY2VVdWlkKSB7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy4jZXZlbnRzLnByZXZpb3VzLmNvbmNhdCh0aGlzLiNldmVudHMuY3VycmVudCk7XG5cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgUmVjb3JkZXIuZHVtcDogTWluIDIgZXZlbnRzIHJlcS4gRm91bmQgJHtldmVudHMubGVuZ3RofWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFJlY29yZGVyLmR1bXA6IER1bXBpbmcgJHtldmVudHMubGVuZ3RofSBldmVudHNgKTtcblxuICAgIGNvbnN0IHJlY29yZGluZ1NwYW4gPSB0cmFjaW5nLnN0YXJ0U3BhbigncnJ3ZWItcmVwbGF5LXJlY29yZGluZycsIHt9KTtcblxuICAgIHJlY29yZGluZ1NwYW4uc2V0QXR0cmlidXRlKCdyb2xsYmFyLnJlcGxheS5pZCcsIHJlcGxheUlkKTtcblxuICAgIGlmIChvY2N1cnJlbmNlVXVpZCkge1xuICAgICAgcmVjb3JkaW5nU3Bhbi5zZXRBdHRyaWJ1dGUoJ3JvbGxiYXIub2NjdXJyZW5jZS51dWlkJywgb2NjdXJyZW5jZVV1aWQpO1xuICAgIH1cblxuICAgIGNvbnN0IGVhcmxpZXN0RXZlbnQgPSBldmVudHMucmVkdWNlKChlYXJsaWVzdEV2ZW50LCBldmVudCkgPT5cbiAgICAgIGV2ZW50LnRpbWVzdGFtcCA8IGVhcmxpZXN0RXZlbnQudGltZXN0YW1wID8gZXZlbnQgOiBlYXJsaWVzdEV2ZW50LFxuICAgICk7XG5cbiAgICByZWNvcmRpbmdTcGFuLnNwYW4uc3RhcnRUaW1lID0gaHJ0aW1lLmZyb21NaWxsaXMoZWFybGllc3RFdmVudC50aW1lc3RhbXApO1xuXG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHJlY29yZGluZ1NwYW4uYWRkRXZlbnQoXG4gICAgICAgICdycndlYi1yZXBsYXktZXZlbnRzJyxcbiAgICAgICAge1xuICAgICAgICAgIGV2ZW50VHlwZTogZXZlbnQudHlwZSxcbiAgICAgICAgICBqc29uOiBKU09OLnN0cmluZ2lmeShldmVudC5kYXRhKSxcbiAgICAgICAgICAncm9sbGJhci5yZXBsYXkuaWQnOiByZXBsYXlJZCxcbiAgICAgICAgfSxcbiAgICAgICAgaHJ0aW1lLmZyb21NaWxsaXMoZXZlbnQudGltZXN0YW1wKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVjb3JkaW5nU3Bhbi5lbmQoKTtcblxuICAgIHJldHVybiB0cmFjaW5nLmV4cG9ydGVyLnRvUGF5bG9hZCgpO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcgfHwgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAodGhpcy5pc1JlY29yZGluZykge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IEFscmVhZHkgc3RhcnRlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBEaXNhYmxlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlcjogU3RhcnRpbmcuLi4nKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuI3N0b3BGbiA9IHRoaXMuI3JlY29yZEZuKHtcbiAgICAgIGVtaXQ6IChldmVudCwgaXNDaGVja291dCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnPy5sb2dFbWl0cykge1xuICAgICAgICAgIHRoaXMuX2xvZ0V2ZW50KGV2ZW50LCBpc0NoZWNrb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NoZWNrb3V0ICYmIGV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5NZXRhKSB7XG4gICAgICAgICAgdGhpcy4jZXZlbnRzLnByZXZpb3VzID0gdGhpcy4jZXZlbnRzLmN1cnJlbnQ7XG4gICAgICAgICAgdGhpcy4jZXZlbnRzLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI2V2ZW50cy5jdXJyZW50LnB1c2goZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrb3V0RXZlcnlObXM6IDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlc1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ1JlY29yZGVyOiBTdGFydGVkJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IEFscmVhZHkgc3RvcHBlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlcjogU3RvcHBpbmcuLi4nKTtcblxuICAgIHRoaXMuI3N0b3BGbigpO1xuICAgIHRoaXMuI3N0b3BGbiA9IG51bGw7XG5cbiAgICBjb25zb2xlLmxvZygnUmVjb3JkZXI6IFN0b3BwZWQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4jZXZlbnRzID0ge1xuICAgICAgcHJldmlvdXM6IFtdLFxuICAgICAgY3VycmVudDogW10sXG4gICAgfTtcbiAgfVxuXG4gIF9sb2dFdmVudChldmVudCwgaXNDaGVja291dCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFJlY29yZGVyOiAke2lzQ2hlY2tvdXQgPyAnY2hlY2tvdXQnIDogJyd9IGV2ZW50XFxuYCxcbiAgICAgICgoZSkgPT4ge1xuICAgICAgICBjb25zdCBzZWVuID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGUsXG4gICAgICAgICAgKF8sIHYpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXModikpIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgICAgICAgIHNlZW4uYWRkKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAyLFxuICAgICAgICApO1xuICAgICAgfSkoZXZlbnQpLFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBpZCBmcm9tICcuLi8uLi90cmFjaW5nL2lkLmpzJztcblxuLyoqXG4gKiBSZXBsYXlNYXAgLSBNYW5hZ2VzIHRoZSBtYXBwaW5nIGJldHdlZW4gZXJyb3Igb2NjdXJyZW5jZXMgYW5kIHRoZWlyIGFzc29jaWF0ZWRcbiAqIHNlc3Npb24gcmVjb3JkaW5ncy4gVGhpcyBjbGFzcyBoYW5kbGVzIHRoZSBjb29yZGluYXRpb24gYmV0d2VlbiB3aGVuIHJlY29yZGluZ3NcbiAqIGFyZSBkdW1wZWQgYW5kIHdoZW4gdGhleSBhcmUgZXZlbnR1YWxseSBzZW50IHRvIHRoZSBiYWNrZW5kLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXBsYXlNYXAge1xuICAjbWFwO1xuICAjcmVjb3JkZXI7XG4gICNhcGk7XG4gICN0cmFjaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJlcGxheU1hcCBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBDb25maWd1cmF0aW9uIHByb3BzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5yZWNvcmRlciAtIFRoZSByZWNvcmRlciBpbnN0YW5jZSB0aGF0IGR1bXBzIHJlcGxheSBkYXRhIGludG8gc3BhbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzLmFwaSAtIFRoZSBBUEkgaW5zdGFuY2UgdXNlZCB0byBzZW5kIHJlcGxheSBwYXlsb2FkcyB0byB0aGUgYmFja2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMudHJhY2luZyAtIFRoZSB0cmFjaW5nIGluc3RhbmNlIHVzZWQgdG8gY3JlYXRlIHNwYW5zIGFuZCBtYW5hZ2UgY29udGV4dFxuICAgKi9cbiAgY29uc3RydWN0b3IoeyByZWNvcmRlciwgYXBpLCB0cmFjaW5nIH0pIHtcbiAgICBpZiAoIXJlY29yZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgJ3JlY29yZGVyJyB0byBiZSBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWFwaSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdhcGknIHRvIGJlIHByb3ZpZGVkXCIpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2luZykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICd0cmFjaW5nJyB0byBiZSBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLiNtYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy4jcmVjb3JkZXIgPSByZWNvcmRlcjtcbiAgICB0aGlzLiNhcGkgPSBhcGk7XG4gICAgdGhpcy4jdHJhY2luZyA9IHRyYWNpbmc7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgcmVwbGF5IGJ5IGNvbnZlcnRpbmcgcmVjb3JkZXIgZXZlbnRzIGludG8gYSB0cmFuc3BvcnQtcmVhZHkgcGF5bG9hZC5cbiAgICpcbiAgICogQ2FsbHMgcmVjb3JkZXIuZHVtcCgpIHRvIGNhcHR1cmUgZXZlbnRzIGFzIHNwYW5zLCBmb3JtYXRzIHRoZW0gaW50byBhIHByb3BlciBwYXlsb2FkLFxuICAgKiBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIG1hcCB1c2luZyByZXBsYXlJZCBhcyB0aGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBUaGUgdW5pcXVlIElEIGZvciB0aGlzIHJlcGxheVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBwcm9jZXNzZWQgcmVwbGF5SWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9wcm9jZXNzUmVwbGF5KHJlcGxheUlkLCBvY2N1cnJlbmNlVXVpZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy4jcmVjb3JkZXIuZHVtcCh0aGlzLiN0cmFjaW5nLCByZXBsYXlJZCwgb2NjdXJyZW5jZVV1aWQpO1xuXG4gICAgICB0aGlzLiNtYXAuc2V0KHJlcGxheUlkLCBwYXlsb2FkKTtcbiAgICB9IGNhdGNoICh0cmFuc2Zvcm1FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHJhbnNmb3JtaW5nIHNwYW5zOicsIHRyYW5zZm9ybUVycm9yKTtcblxuICAgICAgdGhpcy4jbWFwLnNldChyZXBsYXlJZCwgbnVsbCk7IC8vIFRPRE8obWF0dXgpOiBFcnJvciBzcGFuP1xuICAgIH1cblxuICAgIHJldHVybiByZXBsYXlJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcmVwbGF5IHRvIHRoZSBtYXAgYW5kIHJldHVybnMgYSB1bmlxdWVseSBnZW5lcmF0ZWQgcmVwbGF5IElELlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIHRoZSByZXBsYXlJZCBhbmQgYXN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzXG4gICAqIHRoZSByZXBsYXkgZGF0YSBpbiB0aGUgYmFja2dyb3VuZC4gVGhlIHByb2Nlc3NpbmcgaW52b2x2ZXMgY29udmVydGluZ1xuICAgKiByZWNvcmRlciBldmVudHMgaW50byBhIHBheWxvYWQgZm9ybWF0IGFuZCBzdG9yaW5nIGl0IGluIHRoZSBtYXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgcmVwbGF5XG4gICAqL1xuICBhZGQob2NjdXJyZW5jZVV1aWQpIHtcbiAgICBjb25zdCByZXBsYXlJZCA9IGlkLmdlbig4KTtcblxuICAgIHRoaXMuX3Byb2Nlc3NSZXBsYXkocmVwbGF5SWQsIG9jY3VycmVuY2VVdWlkKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHJlcGxheTonLCBlcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVwbGF5SWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIHJlcGxheSBwYXlsb2FkIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVwbGF5SWQgdG8gdGhlIGJhY2tlbmRcbiAgICogYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgbWFwLlxuICAgKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHBheWxvYWQgZnJvbSB0aGUgbWFwLCBjaGVja3MgaWYgaXQncyB2YWxpZCwgdGhlbiBzZW5kcyBpdFxuICAgKiB0byB0aGUgQVBJIGVuZHBvaW50IGZvciBwcm9jZXNzaW5nLiBUaGUgcGF5bG9hZCBjYW4gYmUgZWl0aGVyIGEgc3BhbnMgYXJyYXlcbiAgICogb3IgYSBmb3JtYXR0ZWQgT1RMUCBwYXlsb2FkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIElEIG9mIHRoZSByZXBsYXkgdG8gc2VuZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgcGF5bG9hZCB3YXMgZm91bmQgYW5kIHNlbnQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgYXN5bmMgc2VuZChyZXBsYXlJZCkge1xuICAgIGlmICghcmVwbGF5SWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignUmVwbGF5TWFwLnNlbmQ6IE5vIHJlcGxheUlkIHByb3ZpZGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNtYXAuaGFzKHJlcGxheUlkKSkge1xuICAgICAgY29uc29sZS53YXJuKGBSZXBsYXlNYXAuc2VuZDogTm8gcmVwbGF5IGZvdW5kIGZvciByZXBsYXlJZDogJHtyZXBsYXlJZH1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkID0gdGhpcy4jbWFwLmdldChyZXBsYXlJZCk7XG4gICAgdGhpcy4jbWFwLmRlbGV0ZShyZXBsYXlJZCk7XG5cbiAgICAvLyBDaGVjayBpZiBwYXlsb2FkIGlzIGVtcHR5IChjb3VsZCBiZSByYXcgc3BhbnMgYXJyYXkgb3IgT1RMUCBwYXlsb2FkKVxuICAgIGNvbnN0IGlzRW1wdHkgPVxuICAgICAgIXBheWxvYWQgfHxcbiAgICAgIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAwKSB8fFxuICAgICAgKHBheWxvYWQucmVzb3VyY2VTcGFucyAmJiBwYXlsb2FkLnJlc291cmNlU3BhbnMubGVuZ3RoID09PSAwKTtcblxuICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBSZXBsYXlNYXAuc2VuZDogTm8gcGF5bG9hZCBmb3VuZCBmb3IgcmVwbGF5SWQ6ICR7cmVwbGF5SWR9YCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuI2FwaS5wb3N0U3BhbnMocGF5bG9hZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VuZGluZyByZXBsYXk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyB0aGUgcmVwbGF5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVwbGF5IElEIGJ5IHJlbW92aW5nXG4gICAqIGl0IGZyb20gdGhlIG1hcCB3aXRob3V0IHNlbmRpbmcgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYXlJZCAtIFRoZSBJRCBvZiB0aGUgcmVwbGF5IHRvIGRpc2NhcmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYSByZXBsYXkgd2FzIGZvdW5kIGFuZCBkaXNjYXJkZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgZGlzY2FyZChyZXBsYXlJZCkge1xuICAgIGlmICghcmVwbGF5SWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignUmVwbGF5TWFwLmRpc2NhcmQ6IE5vIHJlcGxheUlkIHByb3ZpZGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNtYXAuaGFzKHJlcGxheUlkKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgUmVwbGF5TWFwLmRpc2NhcmQ6IE5vIHJlcGxheSBmb3VuZCBmb3IgcmVwbGF5SWQ6ICR7cmVwbGF5SWR9YCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy4jbWFwLmRlbGV0ZShyZXBsYXlJZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBzcGFucyBmb3IgdGhlIGdpdmVuIHJlcGxheSBJRFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbGF5SWQgLSBUaGUgSUQgdG8gcmV0cmlldmUgc3BhbnMgZm9yXG4gICAqIEByZXR1cm5zIHtBcnJheXxudWxsfSBUaGUgc3BhbnMgYXJyYXkgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICovXG4gIGdldFNwYW5zKHJlcGxheUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5nZXQocmVwbGF5SWQpID8/IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBzcGFucyBmb3IgYSBnaXZlbiByZXBsYXkgSURcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxheUlkIC0gVGhlIElEIHRvIHNldCBzcGFucyBmb3JcbiAgICogQHBhcmFtIHtBcnJheX0gc3BhbnMgLSBUaGUgc3BhbnMgdG8gc2V0XG4gICAqL1xuICBzZXRTcGFucyhyZXBsYXlJZCwgc3BhbnMpIHtcbiAgICB0aGlzLiNtYXAuc2V0KHJlcGxheUlkLCBzcGFucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgbWFwIChudW1iZXIgb2Ygc3RvcmVkIHJlcGxheXMpXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcmVwbGF5cyBjdXJyZW50bHkgc3RvcmVkXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBzdG9yZWQgcmVwbGF5cyB3aXRob3V0IHNlbmRpbmcgdGhlbVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4jbWFwLmNsZWFyKCk7XG4gIH1cbn1cbiIsImNvbnN0IFJvbGxiYXIgPSByZXF1aXJlKCcuL2NvcmUnKTtcbmNvbnN0IHRlbGVtZXRlciA9IHJlcXVpcmUoJy4uL3RlbGVtZXRyeScpO1xuY29uc3QgaW5zdHJ1bWVudGVyID0gcmVxdWlyZSgnLi90ZWxlbWV0cnknKTtcbmNvbnN0IHBvbHlmaWxsSlNPTiA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvcG9seWZpbGxKU09OJyk7XG5jb25zdCB3cmFwR2xvYmFscyA9IHJlcXVpcmUoJy4vd3JhcEdsb2JhbHMnKTtcbmNvbnN0IHNjcnViID0gcmVxdWlyZSgnLi4vc2NydWInKTtcbmNvbnN0IHRydW5jYXRpb24gPSByZXF1aXJlKCcuLi90cnVuY2F0aW9uJyk7XG5jb25zdCBUcmFjaW5nID0gcmVxdWlyZSgnLi4vdHJhY2luZy90cmFjaW5nJyk7XG5jb25zdCBSZWNvcmRlciA9IHJlcXVpcmUoJy4vcmVwbGF5L3JlY29yZGVyJyk7XG5cblJvbGxiYXIuc2V0Q29tcG9uZW50cyh7XG4gIHRlbGVtZXRlcjogdGVsZW1ldGVyLFxuICBpbnN0cnVtZW50ZXI6IGluc3RydW1lbnRlcixcbiAgcG9seWZpbGxKU09OOiBwb2x5ZmlsbEpTT04sXG4gIHdyYXBHbG9iYWxzOiB3cmFwR2xvYmFscyxcbiAgc2NydWI6IHNjcnViLFxuICB0cnVuY2F0aW9uOiB0cnVuY2F0aW9uLFxuICB0cmFjaW5nOiBUcmFjaW5nLmRlZmF1bHQsXG4gIHJlY29yZGVyOiBSZWNvcmRlci5kZWZhdWx0LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm9sbGJhcjtcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbGl0eScpO1xudmFyIGhlYWRlcnMgPSByZXF1aXJlKCcuLi91dGlsaXR5L2hlYWRlcnMnKTtcbnZhciByZXBsYWNlID0gcmVxdWlyZSgnLi4vdXRpbGl0eS9yZXBsYWNlJyk7XG52YXIgc2NydWIgPSByZXF1aXJlKCcuLi9zY3J1YicpO1xudmFyIHVybHBhcnNlciA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgZG9tVXRpbCA9IHJlcXVpcmUoJy4vZG9tVXRpbGl0eScpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIG5ldHdvcms6IHRydWUsXG4gIG5ldHdvcmtSZXNwb25zZUhlYWRlcnM6IGZhbHNlLFxuICBuZXR3b3JrUmVzcG9uc2VCb2R5OiBmYWxzZSxcbiAgbmV0d29ya1JlcXVlc3RIZWFkZXJzOiBmYWxzZSxcbiAgbmV0d29ya1JlcXVlc3RCb2R5OiBmYWxzZSxcbiAgbmV0d29ya0Vycm9yT25IdHRwNXh4OiBmYWxzZSxcbiAgbmV0d29ya0Vycm9yT25IdHRwNHh4OiBmYWxzZSxcbiAgbmV0d29ya0Vycm9yT25IdHRwMDogZmFsc2UsXG4gIGxvZzogdHJ1ZSxcbiAgZG9tOiB0cnVlLFxuICBuYXZpZ2F0aW9uOiB0cnVlLFxuICBjb25uZWN0aXZpdHk6IHRydWUsXG4gIGNvbnRlbnRTZWN1cml0eVBvbGljeTogdHJ1ZSxcbiAgZXJyb3JPbkNvbnRlbnRTZWN1cml0eVBvbGljeTogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiByZXN0b3JlKHJlcGxhY2VtZW50cywgdHlwZSkge1xuICB2YXIgYjtcbiAgd2hpbGUgKHJlcGxhY2VtZW50c1t0eXBlXS5sZW5ndGgpIHtcbiAgICBiID0gcmVwbGFjZW1lbnRzW3R5cGVdLnNoaWZ0KCk7XG4gICAgYlswXVtiWzFdXSA9IGJbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gbmFtZUZyb21EZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGF0dHJzID0gZGVzY3JpcHRpb24uYXR0cmlidXRlcztcbiAgZm9yICh2YXIgYSA9IDA7IGEgPCBhdHRycy5sZW5ndGg7ICsrYSkge1xuICAgIGlmIChhdHRyc1thXS5rZXkgPT09ICduYW1lJykge1xuICAgICAgcmV0dXJuIGF0dHJzW2FdLnZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlU2NydWJiZXIoc2NydWJGaWVsZHMpIHtcbiAgdmFyIHBhdHRlcm5zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NydWJGaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBwYXR0ZXJucy5wdXNoKG5ldyBSZWdFeHAoc2NydWJGaWVsZHNbaV0sICdpJykpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVGcm9tRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocGF0dGVybnNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBJbnN0cnVtZW50ZXIob3B0aW9ucywgdGVsZW1ldGVyLCByb2xsYmFyLCBfd2luZG93LCBfZG9jdW1lbnQpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGF1dG9JbnN0cnVtZW50ID0gb3B0aW9ucy5hdXRvSW5zdHJ1bWVudDtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UgfHwgYXV0b0luc3RydW1lbnQgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIGlmICghXy5pc1R5cGUoYXV0b0luc3RydW1lbnQsICdvYmplY3QnKSkge1xuICAgICAgYXV0b0luc3RydW1lbnQgPSBkZWZhdWx0cztcbiAgICB9XG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudCA9IF8ubWVyZ2UoZGVmYXVsdHMsIGF1dG9JbnN0cnVtZW50KTtcbiAgfVxuICB0aGlzLnNjcnViVGVsZW1ldHJ5SW5wdXRzID0gISFvcHRpb25zLnNjcnViVGVsZW1ldHJ5SW5wdXRzO1xuICB0aGlzLnRlbGVtZXRyeVNjcnViYmVyID0gb3B0aW9ucy50ZWxlbWV0cnlTY3J1YmJlcjtcbiAgdGhpcy5kZWZhdWx0VmFsdWVTY3J1YmJlciA9IGRlZmF1bHRWYWx1ZVNjcnViYmVyKG9wdGlvbnMuc2NydWJGaWVsZHMpO1xuICB0aGlzLnRlbGVtZXRlciA9IHRlbGVtZXRlcjtcbiAgdGhpcy5yb2xsYmFyID0gcm9sbGJhcjtcbiAgdGhpcy5kaWFnbm9zdGljID0gcm9sbGJhci5jbGllbnQubm90aWZpZXIuZGlhZ25vc3RpYztcbiAgdGhpcy5fd2luZG93ID0gX3dpbmRvdyB8fCB7fTtcbiAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQgfHwge307XG4gIHRoaXMucmVwbGFjZW1lbnRzID0ge1xuICAgIG5ldHdvcms6IFtdLFxuICAgIGxvZzogW10sXG4gICAgbmF2aWdhdGlvbjogW10sXG4gICAgY29ubmVjdGl2aXR5OiBbXSxcbiAgfTtcbiAgdGhpcy5ldmVudFJlbW92ZXJzID0ge1xuICAgIGRvbTogW10sXG4gICAgY29ubmVjdGl2aXR5OiBbXSxcbiAgICBjb250ZW50c2VjdXJpdHlwb2xpY3k6IFtdLFxuICB9O1xuXG4gIHRoaXMuX2xvY2F0aW9uID0gdGhpcy5fd2luZG93LmxvY2F0aW9uO1xuICB0aGlzLl9sYXN0SHJlZiA9IHRoaXMuX2xvY2F0aW9uICYmIHRoaXMuX2xvY2F0aW9uLmhyZWY7XG59XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB2YXIgYXV0b0luc3RydW1lbnQgPSBvcHRpb25zLmF1dG9JbnN0cnVtZW50O1xuICB2YXIgb2xkU2V0dGluZ3MgPSBfLm1lcmdlKHRoaXMuYXV0b0luc3RydW1lbnQpO1xuICBpZiAob3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSB8fCBhdXRvSW5zdHJ1bWVudCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50ID0ge307XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFfLmlzVHlwZShhdXRvSW5zdHJ1bWVudCwgJ29iamVjdCcpKSB7XG4gICAgICBhdXRvSW5zdHJ1bWVudCA9IGRlZmF1bHRzO1xuICAgIH1cbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50ID0gXy5tZXJnZShkZWZhdWx0cywgYXV0b0luc3RydW1lbnQpO1xuICB9XG4gIHRoaXMuaW5zdHJ1bWVudChvbGRTZXR0aW5ncyk7XG4gIGlmIChvcHRpb25zLnNjcnViVGVsZW1ldHJ5SW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNjcnViVGVsZW1ldHJ5SW5wdXRzID0gISFvcHRpb25zLnNjcnViVGVsZW1ldHJ5SW5wdXRzO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbGVtZXRyeVNjcnViYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRlbGVtZXRyeVNjcnViYmVyID0gb3B0aW9ucy50ZWxlbWV0cnlTY3J1YmJlcjtcbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudCA9IGZ1bmN0aW9uIChvbGRTZXR0aW5ncykge1xuICBpZiAodGhpcy5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrICYmICEob2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MubmV0d29yaykpIHtcbiAgICB0aGlzLmluc3RydW1lbnROZXR3b3JrKCk7XG4gIH0gZWxzZSBpZiAoXG4gICAgIXRoaXMuYXV0b0luc3RydW1lbnQubmV0d29yayAmJlxuICAgIG9sZFNldHRpbmdzICYmXG4gICAgb2xkU2V0dGluZ3MubmV0d29ya1xuICApIHtcbiAgICB0aGlzLmRlaW5zdHJ1bWVudE5ldHdvcmsoKTtcbiAgfVxuXG4gIGlmICh0aGlzLmF1dG9JbnN0cnVtZW50LmxvZyAmJiAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmxvZykpIHtcbiAgICB0aGlzLmluc3RydW1lbnRDb25zb2xlKCk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuYXV0b0luc3RydW1lbnQubG9nICYmIG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmxvZykge1xuICAgIHRoaXMuZGVpbnN0cnVtZW50Q29uc29sZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMuYXV0b0luc3RydW1lbnQuZG9tICYmICEob2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MuZG9tKSkge1xuICAgIHRoaXMuaW5zdHJ1bWVudERvbSgpO1xuICB9IGVsc2UgaWYgKCF0aGlzLmF1dG9JbnN0cnVtZW50LmRvbSAmJiBvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy5kb20pIHtcbiAgICB0aGlzLmRlaW5zdHJ1bWVudERvbSgpO1xuICB9XG5cbiAgaWYgKFxuICAgIHRoaXMuYXV0b0luc3RydW1lbnQubmF2aWdhdGlvbiAmJlxuICAgICEob2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MubmF2aWdhdGlvbilcbiAgKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50TmF2aWdhdGlvbigpO1xuICB9IGVsc2UgaWYgKFxuICAgICF0aGlzLmF1dG9JbnN0cnVtZW50Lm5hdmlnYXRpb24gJiZcbiAgICBvbGRTZXR0aW5ncyAmJlxuICAgIG9sZFNldHRpbmdzLm5hdmlnYXRpb25cbiAgKSB7XG4gICAgdGhpcy5kZWluc3RydW1lbnROYXZpZ2F0aW9uKCk7XG4gIH1cblxuICBpZiAoXG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudC5jb25uZWN0aXZpdHkgJiZcbiAgICAhKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLmNvbm5lY3Rpdml0eSlcbiAgKSB7XG4gICAgdGhpcy5pbnN0cnVtZW50Q29ubmVjdGl2aXR5KCk7XG4gIH0gZWxzZSBpZiAoXG4gICAgIXRoaXMuYXV0b0luc3RydW1lbnQuY29ubmVjdGl2aXR5ICYmXG4gICAgb2xkU2V0dGluZ3MgJiZcbiAgICBvbGRTZXR0aW5ncy5jb25uZWN0aXZpdHlcbiAgKSB7XG4gICAgdGhpcy5kZWluc3RydW1lbnRDb25uZWN0aXZpdHkoKTtcbiAgfVxuXG4gIGlmIChcbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50LmNvbnRlbnRTZWN1cml0eVBvbGljeSAmJlxuICAgICEob2xkU2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MuY29udGVudFNlY3VyaXR5UG9saWN5KVxuICApIHtcbiAgICB0aGlzLmluc3RydW1lbnRDb250ZW50U2VjdXJpdHlQb2xpY3koKTtcbiAgfSBlbHNlIGlmIChcbiAgICAhdGhpcy5hdXRvSW5zdHJ1bWVudC5jb250ZW50U2VjdXJpdHlQb2xpY3kgJiZcbiAgICBvbGRTZXR0aW5ncyAmJlxuICAgIG9sZFNldHRpbmdzLmNvbnRlbnRTZWN1cml0eVBvbGljeVxuICApIHtcbiAgICB0aGlzLmRlaW5zdHJ1bWVudENvbnRlbnRTZWN1cml0eVBvbGljeSgpO1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHJlc3RvcmUodGhpcy5yZXBsYWNlbWVudHMsICduZXR3b3JrJyk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmluc3RydW1lbnROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gd3JhcFByb3AocHJvcCwgeGhyKSB7XG4gICAgaWYgKHByb3AgaW4geGhyICYmIF8uaXNGdW5jdGlvbih4aHJbcHJvcF0pKSB7XG4gICAgICByZXBsYWNlKHhociwgcHJvcCwgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucm9sbGJhci53cmFwKG9yaWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCdYTUxIdHRwUmVxdWVzdCcgaW4gdGhpcy5fd2luZG93KSB7XG4gICAgdmFyIHhocnAgPSB0aGlzLl93aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlO1xuICAgIHJlcGxhY2UoXG4gICAgICB4aHJwLFxuICAgICAgJ29wZW4nLFxuICAgICAgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICAgICAgICAgIHZhciBpc1VybE9iamVjdCA9IF9pc1VybE9iamVjdCh1cmwpO1xuICAgICAgICAgIGlmIChfLmlzVHlwZSh1cmwsICdzdHJpbmcnKSB8fCBpc1VybE9iamVjdCkge1xuICAgICAgICAgICAgdXJsID0gaXNVcmxPYmplY3QgPyB1cmwudG9TdHJpbmcoKSA6IHVybDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fcm9sbGJhcl94aHIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLnN0YXR1c19jb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyLnN0YXJ0X3RpbWVfbXMgPSBfLm5vdygpO1xuICAgICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIuZW5kX3RpbWVfbXMgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fX3JvbGxiYXJfeGhyID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHN0YXR1c19jb2RlOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWVfbXM6IF8ubm93KCksXG4gICAgICAgICAgICAgICAgZW5kX3RpbWVfbXM6IG51bGwsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdGhpcy5yZXBsYWNlbWVudHMsXG4gICAgICAnbmV0d29yaycsXG4gICAgKTtcblxuICAgIHJlcGxhY2UoXG4gICAgICB4aHJwLFxuICAgICAgJ3NldFJlcXVlc3RIZWFkZXInLFxuICAgICAgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gSWYgeGhyLm9wZW4gaXMgYXN5bmMsIF9fcm9sbGJhcl94aHIgbWF5IG5vdCBiZSBpbml0aWFsaXplZCB5ZXQuXG4gICAgICAgICAgaWYgKCF0aGlzLl9fcm9sbGJhcl94aHIpIHtcbiAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hociA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXy5pc1R5cGUoaGVhZGVyLCAnc3RyaW5nJykgJiYgXy5pc1R5cGUodmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1JlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fX3JvbGxiYXJfeGhyLnJlcXVlc3RfaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5yZXF1ZXN0X2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9fcm9sbGJhcl94aHIucmVxdWVzdF9oZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIGNvbnRlbnQgdHlwZSBldmVuIGlmIHJlcXVlc3QgaGVhZGVyIHRlbGVtZXRyeSBpcyBvZmYuXG4gICAgICAgICAgICBpZiAoaGVhZGVyLnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX19yb2xsYmFyX3hoci5yZXF1ZXN0X2NvbnRlbnRfdHlwZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRzLFxuICAgICAgJ25ldHdvcmsnLFxuICAgICk7XG5cbiAgICByZXBsYWNlKFxuICAgICAgeGhycCxcbiAgICAgICdzZW5kJyxcbiAgICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICB2YXIgeGhyID0gdGhpcztcblxuICAgICAgICAgIGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoeGhyLl9fcm9sbGJhcl94aHIpIHtcbiAgICAgICAgICAgICAgaWYgKHhoci5fX3JvbGxiYXJfeGhyLnN0YXR1c19jb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIuc3RhdHVzX2NvZGUgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXF1ZXN0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIucmVxdWVzdCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfZXZlbnQgPSBzZWxmLmNhcHR1cmVOZXR3b3JrKFxuICAgICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIsXG4gICAgICAgICAgICAgICAgICAneGhyJyxcbiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICB4aHIuX19yb2xsYmFyX3hoci5zdGFydF90aW1lX21zID0gXy5ub3coKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPiAzKSB7XG4gICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIuZW5kX3RpbWVfbXMgPSBfLm5vdygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnJlc3BvbnNlX2NvbnRlbnRfdHlwZSA9XG4gICAgICAgICAgICAgICAgICB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtSZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzQ29uZmlnID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVzcG9uc2VIZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciwgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNDb25maWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsSGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IGFsbEhlYWRlcnMudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cywgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzID0gYXJyW2ldLnNwbGl0KCc6ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJzogJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZGVyc0NvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gaGVhZGVyc0NvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVyXSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiB3ZSBpZ25vcmUgdGhlIGVycm9ycyBoZXJlIHRoYXQgY291bGQgY29tZSBmcm9tIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgICAgICAgKiBicm93c2VyIGlzc3VlcyB3aXRoIHRoZSB4aHIgbWV0aG9kcyAqL1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlnbm9yZSBlcnJvcnMgZnJvbSByZWFkaW5nIHJlc3BvbnNlVGV4dCAqL1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChib2R5IHx8IGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0pzb25Db250ZW50VHlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnJlc3BvbnNlX2NvbnRlbnRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBzZWxmLnNjcnViSnNvbihib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgeGhyLl9fcm9sbGJhcl94aHIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlID09PSAxMjIzID8gMjA0IDogY29kZTtcbiAgICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnN0YXR1c19jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfZXZlbnQubGV2ZWwgPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRlbGVtZXRlci5sZXZlbEZyb21TdGF0dXMoY29kZSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLmVycm9yT25IdHRwU3RhdHVzKHhoci5fX3JvbGxiYXJfeGhyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgcG9zc2libGUgZXhjZXB0aW9uIGZyb20geGhyLnN0YXR1cyAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdyYXBQcm9wKCdvbmxvYWQnLCB4aHIpO1xuICAgICAgICAgIHdyYXBQcm9wKCdvbmVycm9yJywgeGhyKTtcbiAgICAgICAgICB3cmFwUHJvcCgnb25wcm9ncmVzcycsIHhocik7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiB4aHIgJiZcbiAgICAgICAgICAgIF8uaXNGdW5jdGlvbih4aHIub25yZWFkeXN0YXRlY2hhbmdlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmVwbGFjZSh4aHIsICdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAob3JpZykge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb2xsYmFyLndyYXAoXG4gICAgICAgICAgICAgICAgb3JpZyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlcixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHhoci5fX3JvbGxiYXJfeGhyICYmIHNlbGYudHJhY2tIdHRwRXJyb3JzKCkpIHtcbiAgICAgICAgICAgIHhoci5fX3JvbGxiYXJfeGhyLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdGhpcy5yZXBsYWNlbWVudHMsXG4gICAgICAnbmV0d29yaycsXG4gICAgKTtcbiAgfVxuXG4gIGlmICgnZmV0Y2gnIGluIHRoaXMuX3dpbmRvdykge1xuICAgIHJlcGxhY2UoXG4gICAgICB0aGlzLl93aW5kb3csXG4gICAgICAnZmV0Y2gnLFxuICAgICAgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdCkge1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlucHV0ID0gYXJnc1swXTtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICB2YXIgaXNVcmxPYmplY3QgPSBfaXNVcmxPYmplY3QoaW5wdXQpO1xuICAgICAgICAgIGlmIChfLmlzVHlwZShpbnB1dCwgJ3N0cmluZycpIHx8IGlzVXJsT2JqZWN0KSB7XG4gICAgICAgICAgICB1cmwgPSBpc1VybE9iamVjdCA/IGlucHV0LnRvU3RyaW5nKCkgOiBpbnB1dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB1cmwgPSBpbnB1dC51cmw7XG4gICAgICAgICAgICBpZiAoaW5wdXQubWV0aG9kKSB7XG4gICAgICAgICAgICAgIG1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFyZ3NbMV0gJiYgYXJnc1sxXS5tZXRob2QpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGFyZ3NbMV0ubWV0aG9kO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgc3RhdHVzX2NvZGU6IG51bGwsXG4gICAgICAgICAgICBzdGFydF90aW1lX21zOiBfLm5vdygpLFxuICAgICAgICAgICAgZW5kX3RpbWVfbXM6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoYXJnc1sxXSAmJiBhcmdzWzFdLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIEFyZ3VtZW50IG1heSBiZSBhIEhlYWRlcnMgb2JqZWN0LCBvciBwbGFpbiBvYmplY3QuIEVuc3VyZSBoZXJlIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGFyZSB3b3JraW5nIHdpdGggYSBIZWFkZXJzIG9iamVjdCB3aXRoIGNhc2UtaW5zZW5zaXRpdmUga2V5cy5cbiAgICAgICAgICAgIHZhciByZXFIZWFkZXJzID0gaGVhZGVycyhhcmdzWzFdLmhlYWRlcnMpO1xuXG4gICAgICAgICAgICBtZXRhZGF0YS5yZXF1ZXN0X2NvbnRlbnRfdHlwZSA9IHJlcUhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1JlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhLnJlcXVlc3RfaGVhZGVycyA9IHNlbGYuZmV0Y2hIZWFkZXJzKFxuICAgICAgICAgICAgICAgIHJlcUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1JlcXVlc3RCb2R5KSB7XG4gICAgICAgICAgICBpZiAoYXJnc1sxXSAmJiBhcmdzWzFdLmJvZHkpIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEucmVxdWVzdCA9IGFyZ3NbMV0uYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGFyZ3NbMF0gJiZcbiAgICAgICAgICAgICAgIV8uaXNUeXBlKGFyZ3NbMF0sICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgICBhcmdzWzBdLmJvZHlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBtZXRhZGF0YS5yZXF1ZXN0ID0gYXJnc1swXS5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmNhcHR1cmVOZXR3b3JrKG1ldGFkYXRhLCAnZmV0Y2gnLCB1bmRlZmluZWQpO1xuICAgICAgICAgIGlmIChzZWxmLnRyYWNrSHR0cEVycm9ycygpKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0YXJ0IG91ciBoYW5kbGVyIGJlZm9yZSByZXR1cm5pbmcgdGhlIHByb21pc2UuIFRoaXMgYWxsb3dzIHJlc3AuY2xvbmUoKVxuICAgICAgICAgIC8vIHRvIGV4ZWN1dGUgYmVmb3JlIG90aGVyIGhhbmRsZXJzIHRvdWNoIHRoZSByZXNwb25zZS5cbiAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmdzKS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5lbmRfdGltZV9tcyA9IF8ubm93KCk7XG4gICAgICAgICAgICBtZXRhZGF0YS5zdGF0dXNfY29kZSA9IHJlc3Auc3RhdHVzO1xuICAgICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2VfY29udGVudF90eXBlID0gcmVzcC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnMgPSBzZWxmLmZldGNoSGVhZGVycyhcbiAgICAgICAgICAgICAgICByZXNwLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrUmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0luc3RydW1lbnQubmV0d29ya1Jlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3AudGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlLnRleHQoKSBpcyBub3QgaW1wbGVtZW50ZWQgb24gc29tZSBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzcG9uc2UgbXVzdCBiZSBjbG9uZWQgdG8gcHJldmVudCByZWFkaW5nIChhbmQgbG9ja2luZykgdGhlIG9yaWdpbmFsIHN0cmVhbS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgb3RoZXIgaGFuZGxlcnMgdG91Y2ggdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIGJvZHkgPSByZXNwLmNsb25lKCkudGV4dCgpOyAvL3JldHVybnMgYSBQcm9taXNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXJzIHx8IGJvZHkpIHtcbiAgICAgICAgICAgICAgbWV0YWRhdGEucmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBUZXN0IHRvIGVuc3VyZSBib2R5IGlzIGEgUHJvbWlzZSwgd2hpY2ggaXQgc2hvdWxkIGFsd2F5cyBiZS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgYm9keS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0pzb25Db250ZW50VHlwZShtZXRhZGF0YS5yZXNwb25zZV9jb250ZW50X3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnJlc3BvbnNlLmJvZHkgPSBzZWxmLnNjcnViSnNvbih0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5yZXNwb25zZS5ib2R5ID0gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnJlc3BvbnNlLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVycm9yT25IdHRwU3RhdHVzKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRzLFxuICAgICAgJ25ldHdvcmsnLFxuICAgICk7XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuY2FwdHVyZU5ldHdvcmsgPSBmdW5jdGlvbiAoXG4gIG1ldGFkYXRhLFxuICBzdWJ0eXBlLFxuICByb2xsYmFyVVVJRCxcbikge1xuICBpZiAoXG4gICAgbWV0YWRhdGEucmVxdWVzdCAmJlxuICAgIHRoaXMuaXNKc29uQ29udGVudFR5cGUobWV0YWRhdGEucmVxdWVzdF9jb250ZW50X3R5cGUpXG4gICkge1xuICAgIG1ldGFkYXRhLnJlcXVlc3QgPSB0aGlzLnNjcnViSnNvbihtZXRhZGF0YS5yZXF1ZXN0KTtcbiAgfVxuICByZXR1cm4gdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZU5ldHdvcmsobWV0YWRhdGEsIHN1YnR5cGUsIHJvbGxiYXJVVUlEKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaXNKc29uQ29udGVudFR5cGUgPSBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcbiAgcmV0dXJuIGNvbnRlbnRUeXBlICYmXG4gICAgXy5pc1R5cGUoY29udGVudFR5cGUsICdzdHJpbmcnKSAmJlxuICAgIGNvbnRlbnRUeXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2pzb24nKVxuICAgID8gdHJ1ZVxuICAgIDogZmFsc2U7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLnNjcnViSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzY3J1YihKU09OLnBhcnNlKGpzb24pLCB0aGlzLm9wdGlvbnMuc2NydWJGaWVsZHMpKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuZmV0Y2hIZWFkZXJzID0gZnVuY3Rpb24gKGluSGVhZGVycywgaGVhZGVyc0NvbmZpZykge1xuICB2YXIgb3V0SGVhZGVycyA9IHt9O1xuICB0cnkge1xuICAgIHZhciBpO1xuICAgIGlmIChoZWFkZXJzQ29uZmlnID09PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIGluSGVhZGVycy5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEhlYWRlcnMuZW50cmllcygpIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRVxuICAgICAgICB2YXIgYWxsSGVhZGVycyA9IGluSGVhZGVycy5lbnRyaWVzKCk7XG4gICAgICAgIHZhciBjdXJyZW50SGVhZGVyID0gYWxsSGVhZGVycy5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghY3VycmVudEhlYWRlci5kb25lKSB7XG4gICAgICAgICAgb3V0SGVhZGVyc1tjdXJyZW50SGVhZGVyLnZhbHVlWzBdXSA9IGN1cnJlbnRIZWFkZXIudmFsdWVbMV07XG4gICAgICAgICAgY3VycmVudEhlYWRlciA9IGFsbEhlYWRlcnMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkZXJzQ29uZmlnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBoZWFkZXJzQ29uZmlnW2ldO1xuICAgICAgICBvdXRIZWFkZXJzW2hlYWRlcl0gPSBpbkhlYWRlcnMuZ2V0KGhlYWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaWdub3JlIHByb2JhYmxlIElFIGVycm9ycyAqL1xuICB9XG4gIHJldHVybiBvdXRIZWFkZXJzO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS50cmFja0h0dHBFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrRXJyb3JPbkh0dHA1eHggfHxcbiAgICB0aGlzLmF1dG9JbnN0cnVtZW50Lm5ldHdvcmtFcnJvck9uSHR0cDR4eCB8fFxuICAgIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwMFxuICApO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5lcnJvck9uSHR0cFN0YXR1cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICB2YXIgc3RhdHVzID0gbWV0YWRhdGEuc3RhdHVzX2NvZGU7XG5cbiAgaWYgKFxuICAgIChzdGF0dXMgPj0gNTAwICYmIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwNXh4KSB8fFxuICAgIChzdGF0dXMgPj0gNDAwICYmIHRoaXMuYXV0b0luc3RydW1lbnQubmV0d29ya0Vycm9yT25IdHRwNHh4KSB8fFxuICAgIChzdGF0dXMgPT09IDAgJiYgdGhpcy5hdXRvSW5zdHJ1bWVudC5uZXR3b3JrRXJyb3JPbkh0dHAwKVxuICApIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0hUVFAgcmVxdWVzdCBmYWlsZWQgd2l0aCBTdGF0dXMgJyArIHN0YXR1cyk7XG4gICAgZXJyb3Iuc3RhY2sgPSBtZXRhZGF0YS5zdGFjaztcbiAgICB0aGlzLnJvbGxiYXIuZXJyb3IoZXJyb3IsIHsgc2tpcEZyYW1lczogMSB9KTtcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5kZWluc3RydW1lbnRDb25zb2xlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoISgnY29uc29sZScgaW4gdGhpcy5fd2luZG93ICYmIHRoaXMuX3dpbmRvdy5jb25zb2xlLmxvZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGI7XG4gIHdoaWxlICh0aGlzLnJlcGxhY2VtZW50c1snbG9nJ10ubGVuZ3RoKSB7XG4gICAgYiA9IHRoaXMucmVwbGFjZW1lbnRzWydsb2cnXS5zaGlmdCgpO1xuICAgIHRoaXMuX3dpbmRvdy5jb25zb2xlW2JbMF1dID0gYlsxXTtcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pbnN0cnVtZW50Q29uc29sZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2NvbnNvbGUnIGluIHRoaXMuX3dpbmRvdyAmJiB0aGlzLl93aW5kb3cuY29uc29sZS5sb2cpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYyA9IHRoaXMuX3dpbmRvdy5jb25zb2xlO1xuXG4gIGZ1bmN0aW9uIHdyYXBDb25zb2xlKG1ldGhvZCkge1xuICAgICd1c2Ugc3RyaWN0JzsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsYmFyL3JvbGxiYXIuanMvcHVsbC83NzhcblxuICAgIHZhciBvcmlnID0gY1ttZXRob2RdO1xuICAgIHZhciBvcmlnQ29uc29sZSA9IGM7XG4gICAgdmFyIGxldmVsID0gbWV0aG9kID09PSAnd2FybicgPyAnd2FybmluZycgOiBtZXRob2Q7XG4gICAgY1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfLmZvcm1hdEFyZ3NBc1N0cmluZyhhcmdzKTtcbiAgICAgIHNlbGYudGVsZW1ldGVyLmNhcHR1cmVMb2cobWVzc2FnZSwgbGV2ZWwsIG51bGwsIF8ubm93KCkpO1xuICAgICAgaWYgKG9yaWcpIHtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwob3JpZywgb3JpZ0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5yZXBsYWNlbWVudHNbJ2xvZyddLnB1c2goW21ldGhvZCwgb3JpZ10pO1xuICB9XG4gIHZhciBtZXRob2RzID0gWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InLCAnbG9nJ107XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHdyYXBDb25zb2xlKG1ldGhvZHNbaV0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMuZGlhZ25vc3RpYy5pbnN0cnVtZW50Q29uc29sZSA9IHsgZXJyb3I6IGUubWVzc2FnZSB9O1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYXR0YWNoRXZlbnQnIGluIHRoaXMuX3dpbmRvdykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoJ2RvbScpO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pbnN0cnVtZW50RG9tID0gZnVuY3Rpb24gKCkge1xuICBpZiAoISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gdGhpcy5fd2luZG93IHx8ICdhdHRhY2hFdmVudCcgaW4gdGhpcy5fd2luZG93KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2xpY2tIYW5kbGVyID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpO1xuICB2YXIgYmx1ckhhbmRsZXIgPSB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKTtcbiAgdGhpcy5hZGRMaXN0ZW5lcignZG9tJywgdGhpcy5fd2luZG93LCAnY2xpY2snLCAnb25jbGljaycsIGNsaWNrSGFuZGxlciwgdHJ1ZSk7XG4gIHRoaXMuYWRkTGlzdGVuZXIoXG4gICAgJ2RvbScsXG4gICAgdGhpcy5fd2luZG93LFxuICAgICdibHVyJyxcbiAgICAnb25mb2N1c291dCcsXG4gICAgYmx1ckhhbmRsZXIsXG4gICAgdHJ1ZSxcbiAgKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gIHRyeSB7XG4gICAgdmFyIGUgPSBkb21VdGlsLmdldEVsZW1lbnRGcm9tRXZlbnQoZXZ0LCB0aGlzLl9kb2N1bWVudCk7XG4gICAgdmFyIGhhc1RhZyA9IGUgJiYgZS50YWdOYW1lO1xuICAgIHZhciBhbmNob3JPckJ1dHRvbiA9XG4gICAgICBkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnYScpIHx8XG4gICAgICBkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnYnV0dG9uJyk7XG4gICAgaWYgKFxuICAgICAgaGFzVGFnICYmXG4gICAgICAoYW5jaG9yT3JCdXR0b24gfHxcbiAgICAgICAgZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2lucHV0JywgWydidXR0b24nLCAnc3VibWl0J10pKVxuICAgICkge1xuICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgfSBlbHNlIGlmIChkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAnaW5wdXQnLCBbJ2NoZWNrYm94JywgJ3JhZGlvJ10pKSB7XG4gICAgICB0aGlzLmNhcHR1cmVEb21FdmVudCgnaW5wdXQnLCBlLCBlLnZhbHVlLCBlLmNoZWNrZWQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXhjKSB7XG4gICAgLy8gVE9ETzogTm90IHN1cmUgd2hhdCB0byBkbyBoZXJlXG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZSA9IGRvbVV0aWwuZ2V0RWxlbWVudEZyb21FdmVudChldnQsIHRoaXMuX2RvY3VtZW50KTtcbiAgICBpZiAoZSAmJiBlLnRhZ05hbWUpIHtcbiAgICAgIGlmIChkb21VdGlsLmlzRGVzY3JpYmVkRWxlbWVudChlLCAndGV4dGFyZWEnKSkge1xuICAgICAgICB0aGlzLmNhcHR1cmVEb21FdmVudCgnaW5wdXQnLCBlLCBlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGRvbVV0aWwuaXNEZXNjcmliZWRFbGVtZW50KGUsICdzZWxlY3QnKSAmJlxuICAgICAgICBlLm9wdGlvbnMgJiZcbiAgICAgICAgZS5vcHRpb25zLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0SW5wdXRDaGFuZ2VkKGUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZG9tVXRpbC5pc0Rlc2NyaWJlZEVsZW1lbnQoZSwgJ2lucHV0JykgJiZcbiAgICAgICAgIWRvbVV0aWwuaXNEZXNjcmliZWRFbGVtZW50KGUsICdpbnB1dCcsIFtcbiAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAnaGlkZGVuJyxcbiAgICAgICAgICAnY2hlY2tib3gnLFxuICAgICAgICAgICdyYWRpbycsXG4gICAgICAgIF0pXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2lucHV0JywgZSwgZS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChleGMpIHtcbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSB3aGF0IHRvIGRvIGhlcmVcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RJbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICBpZiAoZWxlbS5tdWx0aXBsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbS5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZWxlbS5vcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZURvbUV2ZW50KCdpbnB1dCcsIGVsZW0sIGVsZW0ub3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsZW0uc2VsZWN0ZWRJbmRleCA+PSAwICYmIGVsZW0ub3B0aW9uc1tlbGVtLnNlbGVjdGVkSW5kZXhdKSB7XG4gICAgdGhpcy5jYXB0dXJlRG9tRXZlbnQoJ2lucHV0JywgZWxlbSwgZWxlbS5vcHRpb25zW2VsZW0uc2VsZWN0ZWRJbmRleF0udmFsdWUpO1xuICB9XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmNhcHR1cmVEb21FdmVudCA9IGZ1bmN0aW9uIChcbiAgc3VidHlwZSxcbiAgZWxlbWVudCxcbiAgdmFsdWUsXG4gIGlzQ2hlY2tlZCxcbikge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuc2NydWJUZWxlbWV0cnlJbnB1dHMgfHxcbiAgICAgIGRvbVV0aWwuZ2V0RWxlbWVudFR5cGUoZWxlbWVudCkgPT09ICdwYXNzd29yZCdcbiAgICApIHtcbiAgICAgIHZhbHVlID0gJ1tzY3J1YmJlZF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSBkb21VdGlsLmRlc2NyaWJlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGlmICh0aGlzLnRlbGVtZXRyeVNjcnViYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRlbGVtZXRyeVNjcnViYmVyKGRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgIHZhbHVlID0gJ1tzY3J1YmJlZF0nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdFZhbHVlU2NydWJiZXIoZGVzY3JpcHRpb24pKSB7XG4gICAgICAgIHZhbHVlID0gJ1tzY3J1YmJlZF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZWxlbWVudFN0cmluZyA9IGRvbVV0aWwuZWxlbWVudEFycmF5VG9TdHJpbmcoXG4gICAgZG9tVXRpbC50cmVlVG9BcnJheShlbGVtZW50KSxcbiAgKTtcbiAgdGhpcy50ZWxlbWV0ZXIuY2FwdHVyZURvbShzdWJ0eXBlLCBlbGVtZW50U3RyaW5nLCB2YWx1ZSwgaXNDaGVja2VkKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuZGVpbnN0cnVtZW50TmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNocm9tZSA9IHRoaXMuX3dpbmRvdy5jaHJvbWU7XG4gIHZhciBjaHJvbWVQYWNrYWdlZEFwcCA9IGNocm9tZSAmJiBjaHJvbWUuYXBwICYmIGNocm9tZS5hcHAucnVudGltZTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8xMzk0NS9maWxlc1xuICB2YXIgaGFzUHVzaFN0YXRlID1cbiAgICAhY2hyb21lUGFja2FnZWRBcHAgJiZcbiAgICB0aGlzLl93aW5kb3cuaGlzdG9yeSAmJlxuICAgIHRoaXMuX3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgaWYgKCFoYXNQdXNoU3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdG9yZSh0aGlzLnJlcGxhY2VtZW50cywgJ25hdmlnYXRpb24nKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHJvbWUgPSB0aGlzLl93aW5kb3cuY2hyb21lO1xuICB2YXIgY2hyb21lUGFja2FnZWRBcHAgPSBjaHJvbWUgJiYgY2hyb21lLmFwcCAmJiBjaHJvbWUuYXBwLnJ1bnRpbWU7XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMTM5NDUvZmlsZXNcbiAgdmFyIGhhc1B1c2hTdGF0ZSA9XG4gICAgIWNocm9tZVBhY2thZ2VkQXBwICYmXG4gICAgdGhpcy5fd2luZG93Lmhpc3RvcnkgJiZcbiAgICB0aGlzLl93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG4gIGlmICghaGFzUHVzaFN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVwbGFjZShcbiAgICB0aGlzLl93aW5kb3csXG4gICAgJ29ucG9wc3RhdGUnLFxuICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHNlbGYuX2xvY2F0aW9uLmhyZWY7XG4gICAgICAgIHNlbGYuaGFuZGxlVXJsQ2hhbmdlKHNlbGYuX2xhc3RIcmVmLCBjdXJyZW50KTtcbiAgICAgICAgaWYgKG9yaWcpIHtcbiAgICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB0aGlzLnJlcGxhY2VtZW50cyxcbiAgICAnbmF2aWdhdGlvbicsXG4gICk7XG5cbiAgcmVwbGFjZShcbiAgICB0aGlzLl93aW5kb3cuaGlzdG9yeSxcbiAgICAncHVzaFN0YXRlJyxcbiAgICBmdW5jdGlvbiAob3JpZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVVcmxDaGFuZ2Uoc2VsZi5fbGFzdEhyZWYsIHVybCArICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHRoaXMucmVwbGFjZW1lbnRzLFxuICAgICduYXZpZ2F0aW9uJyxcbiAgKTtcbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaGFuZGxlVXJsQ2hhbmdlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHZhciBwYXJzZWRIcmVmID0gdXJscGFyc2VyLnBhcnNlKHRoaXMuX2xvY2F0aW9uLmhyZWYpO1xuICB2YXIgcGFyc2VkVG8gPSB1cmxwYXJzZXIucGFyc2UodG8pO1xuICB2YXIgcGFyc2VkRnJvbSA9IHVybHBhcnNlci5wYXJzZShmcm9tKTtcbiAgdGhpcy5fbGFzdEhyZWYgPSB0bztcbiAgaWYgKFxuICAgIHBhcnNlZEhyZWYucHJvdG9jb2wgPT09IHBhcnNlZFRvLnByb3RvY29sICYmXG4gICAgcGFyc2VkSHJlZi5ob3N0ID09PSBwYXJzZWRUby5ob3N0XG4gICkge1xuICAgIHRvID0gcGFyc2VkVG8ucGF0aCArIChwYXJzZWRUby5oYXNoIHx8ICcnKTtcbiAgfVxuICBpZiAoXG4gICAgcGFyc2VkSHJlZi5wcm90b2NvbCA9PT0gcGFyc2VkRnJvbS5wcm90b2NvbCAmJlxuICAgIHBhcnNlZEhyZWYuaG9zdCA9PT0gcGFyc2VkRnJvbS5ob3N0XG4gICkge1xuICAgIGZyb20gPSBwYXJzZWRGcm9tLnBhdGggKyAocGFyc2VkRnJvbS5oYXNoIHx8ICcnKTtcbiAgfVxuICB0aGlzLnRlbGVtZXRlci5jYXB0dXJlTmF2aWdhdGlvbihmcm9tLCB0bywgXy5ub3coKSk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmRlaW5zdHJ1bWVudENvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYm9keScgaW4gdGhpcy5fZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLl93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCdjb25uZWN0aXZpdHknKTtcbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlKHRoaXMucmVwbGFjZW1lbnRzLCAnY29ubmVjdGl2aXR5Jyk7XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuaW5zdHJ1bWVudENvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRoaXMuX3dpbmRvdyB8fCAnYm9keScgaW4gdGhpcy5fZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLl93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHRoaXMuYWRkTGlzdGVuZXIoXG4gICAgICAnY29ubmVjdGl2aXR5JyxcbiAgICAgIHRoaXMuX3dpbmRvdyxcbiAgICAgICdvbmxpbmUnLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRlbGVtZXRlci5jYXB0dXJlQ29ubmVjdGl2aXR5Q2hhbmdlKCdvbmxpbmUnKTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIHRydWUsXG4gICAgKTtcbiAgICB0aGlzLmFkZExpc3RlbmVyKFxuICAgICAgJ2Nvbm5lY3Rpdml0eScsXG4gICAgICB0aGlzLl93aW5kb3csXG4gICAgICAnb2ZmbGluZScsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVDb25uZWN0aXZpdHlDaGFuZ2UoJ29mZmxpbmUnKTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIHRydWUsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVwbGFjZShcbiAgICAgIHRoaXMuX2RvY3VtZW50LmJvZHksXG4gICAgICAnb25vbmxpbmUnLFxuICAgICAgZnVuY3Rpb24gKG9yaWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnRlbGVtZXRlci5jYXB0dXJlQ29ubmVjdGl2aXR5Q2hhbmdlKCdvbmxpbmUnKTtcbiAgICAgICAgICBpZiAob3JpZykge1xuICAgICAgICAgICAgb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlcGxhY2VtZW50cyxcbiAgICAgICdjb25uZWN0aXZpdHknLFxuICAgICk7XG4gICAgcmVwbGFjZShcbiAgICAgIHRoaXMuX2RvY3VtZW50LmJvZHksXG4gICAgICAnb25vZmZsaW5lJyxcbiAgICAgIGZ1bmN0aW9uIChvcmlnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi50ZWxlbWV0ZXIuY2FwdHVyZUNvbm5lY3Rpdml0eUNoYW5nZSgnb2ZmbGluZScpO1xuICAgICAgICAgIGlmIChvcmlnKSB7XG4gICAgICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRzLFxuICAgICAgJ2Nvbm5lY3Rpdml0eScsXG4gICAgKTtcbiAgfVxufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5oYW5kbGVDc3BFdmVudCA9IGZ1bmN0aW9uIChjc3BFdmVudCkge1xuICB2YXIgbWVzc2FnZSA9XG4gICAgJ1NlY3VyaXR5IFBvbGljeSBWaW9sYXRpb246ICcgK1xuICAgICdibG9ja2VkVVJJOiAnICtcbiAgICBjc3BFdmVudC5ibG9ja2VkVVJJICtcbiAgICAnLCAnICtcbiAgICAndmlvbGF0ZWREaXJlY3RpdmU6ICcgK1xuICAgIGNzcEV2ZW50LnZpb2xhdGVkRGlyZWN0aXZlICtcbiAgICAnLCAnICtcbiAgICAnZWZmZWN0aXZlRGlyZWN0aXZlOiAnICtcbiAgICBjc3BFdmVudC5lZmZlY3RpdmVEaXJlY3RpdmUgK1xuICAgICcsICc7XG5cbiAgaWYgKGNzcEV2ZW50LnNvdXJjZUZpbGUpIHtcbiAgICBtZXNzYWdlICs9XG4gICAgICAnbG9jYXRpb246ICcgK1xuICAgICAgY3NwRXZlbnQuc291cmNlRmlsZSArXG4gICAgICAnLCAnICtcbiAgICAgICdsaW5lOiAnICtcbiAgICAgIGNzcEV2ZW50LmxpbmVOdW1iZXIgK1xuICAgICAgJywgJyArXG4gICAgICAnY29sOiAnICtcbiAgICAgIGNzcEV2ZW50LmNvbHVtbk51bWJlciArXG4gICAgICAnLCAnO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnb3JpZ2luYWxQb2xpY3k6ICcgKyBjc3BFdmVudC5vcmlnaW5hbFBvbGljeTtcblxuICB0aGlzLnRlbGVtZXRlci5jYXB0dXJlTG9nKG1lc3NhZ2UsICdlcnJvcicsIG51bGwsIF8ubm93KCkpO1xuICB0aGlzLmhhbmRsZUNzcEVycm9yKG1lc3NhZ2UpO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5oYW5kbGVDc3BFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmF1dG9JbnN0cnVtZW50LmVycm9yT25Db250ZW50U2VjdXJpdHlQb2xpY3kpIHtcbiAgICB0aGlzLnJvbGxiYXIuZXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUuZGVpbnN0cnVtZW50Q29udGVudFNlY3VyaXR5UG9saWN5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gdGhpcy5fZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoJ2NvbnRlbnRzZWN1cml0eXBvbGljeScpO1xufTtcblxuSW5zdHJ1bWVudGVyLnByb3RvdHlwZS5pbnN0cnVtZW50Q29udGVudFNlY3VyaXR5UG9saWN5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gdGhpcy5fZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNzcEhhbmRsZXIgPSB0aGlzLmhhbmRsZUNzcEV2ZW50LmJpbmQodGhpcyk7XG4gIHRoaXMuYWRkTGlzdGVuZXIoXG4gICAgJ2NvbnRlbnRzZWN1cml0eXBvbGljeScsXG4gICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgJ3NlY3VyaXR5cG9saWN5dmlvbGF0aW9uJyxcbiAgICBudWxsLFxuICAgIGNzcEhhbmRsZXIsXG4gICAgZmFsc2UsXG4gICk7XG59O1xuXG5JbnN0cnVtZW50ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKFxuICBzZWN0aW9uLFxuICBvYmosXG4gIHR5cGUsXG4gIGFsdFR5cGUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4pIHtcbiAgaWYgKG9iai5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgdGhpcy5ldmVudFJlbW92ZXJzW3NlY3Rpb25dLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYWx0VHlwZSkge1xuICAgIG9iai5hdHRhY2hFdmVudChhbHRUeXBlLCBoYW5kbGVyKTtcbiAgICB0aGlzLmV2ZW50UmVtb3ZlcnNbc2VjdGlvbl0ucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBvYmouZGV0YWNoRXZlbnQoYWx0VHlwZSwgaGFuZGxlcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbkluc3RydW1lbnRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgdmFyIHI7XG4gIHdoaWxlICh0aGlzLmV2ZW50UmVtb3ZlcnNbc2VjdGlvbl0ubGVuZ3RoKSB7XG4gICAgciA9IHRoaXMuZXZlbnRSZW1vdmVyc1tzZWN0aW9uXS5zaGlmdCgpO1xuICAgIHIoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2lzVXJsT2JqZWN0KGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgVVJMICE9PSAndW5kZWZpbmVkJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFVSTDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnN0cnVtZW50ZXI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWxpdHknKTtcbnZhciBlcnJvclBhcnNlciA9IHJlcXVpcmUoJy4uL2Vycm9yUGFyc2VyJyk7XG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxuZnVuY3Rpb24gaGFuZGxlRG9tRXhjZXB0aW9uKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChpdGVtLmVyciAmJiBlcnJvclBhcnNlci5TdGFjayhpdGVtLmVycikubmFtZSA9PT0gJ0RPTUV4Y2VwdGlvbicpIHtcbiAgICB2YXIgb3JpZ2luYWxFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgIG9yaWdpbmFsRXJyb3IubmFtZSA9IGl0ZW0uZXJyLm5hbWU7XG4gICAgb3JpZ2luYWxFcnJvci5tZXNzYWdlID0gaXRlbS5lcnIubWVzc2FnZTtcbiAgICBvcmlnaW5hbEVycm9yLnN0YWNrID0gaXRlbS5lcnIuc3RhY2s7XG4gICAgb3JpZ2luYWxFcnJvci5uZXN0ZWQgPSBpdGVtLmVycjtcbiAgICBpdGVtLmVyciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUl0ZW1XaXRoRXJyb3IoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaXRlbS5kYXRhID0gaXRlbS5kYXRhIHx8IHt9O1xuICBpZiAoaXRlbS5lcnIpIHtcbiAgICB0cnkge1xuICAgICAgaXRlbS5zdGFja0luZm8gPVxuICAgICAgICBpdGVtLmVyci5fc2F2ZWRTdGFja1RyYWNlIHx8XG4gICAgICAgIGVycm9yUGFyc2VyLnBhcnNlKGl0ZW0uZXJyLCBpdGVtLnNraXBGcmFtZXMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5hZGRFcnJvckNvbnRleHQpIHtcbiAgICAgICAgYWRkRXJyb3JDb250ZXh0KGl0ZW0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgcGFyc2luZyB0aGUgZXJyb3Igb2JqZWN0LicsIGUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaXRlbS5tZXNzYWdlID1cbiAgICAgICAgICBpdGVtLmVyci5tZXNzYWdlIHx8XG4gICAgICAgICAgaXRlbS5lcnIuZGVzY3JpcHRpb24gfHxcbiAgICAgICAgICBpdGVtLm1lc3NhZ2UgfHxcbiAgICAgICAgICBTdHJpbmcoaXRlbS5lcnIpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaXRlbS5tZXNzYWdlID0gU3RyaW5nKGl0ZW0uZXJyKSB8fCBTdHJpbmcoZTIpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGl0ZW0uZXJyO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JDb250ZXh0KGl0ZW0pIHtcbiAgdmFyIGNoYWluID0gW107XG4gIHZhciBlcnIgPSBpdGVtLmVycjtcblxuICBjaGFpbi5wdXNoKGVycik7XG5cbiAgd2hpbGUgKGVyci5uZXN0ZWQgfHwgZXJyLmNhdXNlKSB7XG4gICAgZXJyID0gZXJyLm5lc3RlZCB8fCBlcnIuY2F1c2U7XG4gICAgY2hhaW4ucHVzaChlcnIpO1xuICB9XG5cbiAgXy5hZGRFcnJvckNvbnRleHQoaXRlbSwgY2hhaW4pO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVJdGVtSGFzU29tZXRoaW5nVG9TYXkoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFpdGVtLm1lc3NhZ2UgJiYgIWl0ZW0uc3RhY2tJbmZvICYmICFpdGVtLmN1c3RvbSkge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignTm8gbWVzc2FnZSwgc3RhY2sgaW5mbywgb3IgY3VzdG9tIGRhdGEnKSwgbnVsbCk7XG4gIH1cbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGFkZEJhc2VJbmZvKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBlbnZpcm9ubWVudCA9XG4gICAgKG9wdGlvbnMucGF5bG9hZCAmJiBvcHRpb25zLnBheWxvYWQuZW52aXJvbm1lbnQpIHx8IG9wdGlvbnMuZW52aXJvbm1lbnQ7XG4gIGl0ZW0uZGF0YSA9IF8ubWVyZ2UoaXRlbS5kYXRhLCB7XG4gICAgZW52aXJvbm1lbnQ6IGVudmlyb25tZW50LFxuICAgIGxldmVsOiBpdGVtLmxldmVsLFxuICAgIGVuZHBvaW50OiBvcHRpb25zLmVuZHBvaW50LFxuICAgIHBsYXRmb3JtOiAnYnJvd3NlcicsXG4gICAgZnJhbWV3b3JrOiAnYnJvd3Nlci1qcycsXG4gICAgbGFuZ3VhZ2U6ICdqYXZhc2NyaXB0JyxcbiAgICBzZXJ2ZXI6IHt9LFxuICAgIHV1aWQ6IGl0ZW0udXVpZCxcbiAgICBub3RpZmllcjoge1xuICAgICAgbmFtZTogJ3JvbGxiYXItYnJvd3Nlci1qcycsXG4gICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgfSxcbiAgICBjdXN0b206IGl0ZW0uY3VzdG9tLFxuICB9KTtcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGFkZFJlcXVlc3RJbmZvKHdpbmRvdykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcXVlc3RJbmZvID0ge307XG5cbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgcmVxdWVzdEluZm8udXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICByZXF1ZXN0SW5mby5xdWVyeV9zdHJpbmcgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICAgIH1cblxuICAgIHZhciByZW1vdGVTdHJpbmcgPSAnJHJlbW90ZV9pcCc7XG4gICAgaWYgKCFvcHRpb25zLmNhcHR1cmVJcCkge1xuICAgICAgcmVtb3RlU3RyaW5nID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY2FwdHVyZUlwICE9PSB0cnVlKSB7XG4gICAgICByZW1vdGVTdHJpbmcgKz0gJ19hbm9ueW1pemUnO1xuICAgIH1cbiAgICBpZiAocmVtb3RlU3RyaW5nKSByZXF1ZXN0SW5mby51c2VyX2lwID0gcmVtb3RlU3RyaW5nO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHJlcXVlc3RJbmZvKS5sZW5ndGggPiAwKSB7XG4gICAgICBfLnNldChpdGVtLCAnZGF0YS5yZXF1ZXN0JywgcmVxdWVzdEluZm8pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRDbGllbnRJbmZvKHdpbmRvdykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICB9XG4gICAgdmFyIG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3IgfHwge307XG4gICAgdmFyIHNjciA9IHdpbmRvdy5zY3JlZW4gfHwge307XG4gICAgXy5zZXQoaXRlbSwgJ2RhdGEuY2xpZW50Jywge1xuICAgICAgcnVudGltZV9tczogaXRlbS50aW1lc3RhbXAgLSB3aW5kb3cuX3JvbGxiYXJTdGFydFRpbWUsXG4gICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQoaXRlbS50aW1lc3RhbXAgLyAxMDAwKSxcbiAgICAgIGphdmFzY3JpcHQ6IHtcbiAgICAgICAgYnJvd3NlcjogbmF2LnVzZXJBZ2VudCxcbiAgICAgICAgbGFuZ3VhZ2U6IG5hdi5sYW5ndWFnZSxcbiAgICAgICAgY29va2llX2VuYWJsZWQ6IG5hdi5jb29raWVFbmFibGVkLFxuICAgICAgICBzY3JlZW46IHtcbiAgICAgICAgICB3aWR0aDogc2NyLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc2NyLmhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZFBsdWdpbkluZm8od2luZG93KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93Lm5hdmlnYXRvcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICAgIH1cbiAgICB2YXIgcGx1Z2lucyA9IFtdO1xuICAgIHZhciBuYXZQbHVnaW5zID0gd2luZG93Lm5hdmlnYXRvci5wbHVnaW5zIHx8IFtdO1xuICAgIHZhciBjdXI7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYXZQbHVnaW5zLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgY3VyID0gbmF2UGx1Z2luc1tpXTtcbiAgICAgIHBsdWdpbnMucHVzaCh7IG5hbWU6IGN1ci5uYW1lLCBkZXNjcmlwdGlvbjogY3VyLmRlc2NyaXB0aW9uIH0pO1xuICAgIH1cbiAgICBfLnNldChpdGVtLCAnZGF0YS5jbGllbnQuamF2YXNjcmlwdC5wbHVnaW5zJywgcGx1Z2lucyk7XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZEJvZHkoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGl0ZW0uc3RhY2tJbmZvKSB7XG4gICAgaWYgKGl0ZW0uc3RhY2tJbmZvLnRyYWNlQ2hhaW4pIHtcbiAgICAgIGFkZEJvZHlUcmFjZUNoYWluKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQm9keVRyYWNlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWRkQm9keU1lc3NhZ2UoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEJvZHlNZXNzYWdlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gaXRlbS5tZXNzYWdlO1xuICB2YXIgY3VzdG9tID0gaXRlbS5jdXN0b207XG5cbiAgaWYgKCFtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9ICdJdGVtIHNlbnQgd2l0aCBudWxsIG9yIG1pc3NpbmcgYXJndW1lbnRzLic7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBib2R5OiBtZXNzYWdlLFxuICB9O1xuXG4gIGlmIChjdXN0b20pIHtcbiAgICByZXN1bHQuZXh0cmEgPSBfLm1lcmdlKGN1c3RvbSk7XG4gIH1cblxuICBfLnNldChpdGVtLCAnZGF0YS5ib2R5JywgeyBtZXNzYWdlOiByZXN1bHQgfSk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBzdGFja0Zyb21JdGVtKGl0ZW0pIHtcbiAgLy8gVHJhbnNmb3JtIGEgVHJhY2VLaXQgc3RhY2tJbmZvIG9iamVjdCBpbnRvIGEgUm9sbGJhciB0cmFjZVxuICB2YXIgc3RhY2sgPSBpdGVtLnN0YWNrSW5mby5zdGFjaztcbiAgaWYgKFxuICAgIHN0YWNrICYmXG4gICAgc3RhY2subGVuZ3RoID09PSAwICYmXG4gICAgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvICYmXG4gICAgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvLnN0YWNrXG4gICkge1xuICAgIHN0YWNrID0gaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvLnN0YWNrO1xuICB9XG4gIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gYWRkQm9keVRyYWNlQ2hhaW4oaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHRyYWNlQ2hhaW4gPSBpdGVtLnN0YWNrSW5mby50cmFjZUNoYWluO1xuICB2YXIgdHJhY2VzID0gW107XG5cbiAgdmFyIHRyYWNlQ2hhaW5MZW5ndGggPSB0cmFjZUNoYWluLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZUNoYWluTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHJhY2UgPSBidWlsZFRyYWNlKGl0ZW0sIHRyYWNlQ2hhaW5baV0sIG9wdGlvbnMpO1xuICAgIHRyYWNlcy5wdXNoKHRyYWNlKTtcbiAgfVxuXG4gIF8uc2V0KGl0ZW0sICdkYXRhLmJvZHknLCB7IHRyYWNlX2NoYWluOiB0cmFjZXMgfSk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGRCb2R5VHJhY2UoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHN0YWNrID0gc3RhY2tGcm9tSXRlbShpdGVtKTtcblxuICBpZiAoc3RhY2spIHtcbiAgICB2YXIgdHJhY2UgPSBidWlsZFRyYWNlKGl0ZW0sIGl0ZW0uc3RhY2tJbmZvLCBvcHRpb25zKTtcbiAgICBfLnNldChpdGVtLCAnZGF0YS5ib2R5JywgeyB0cmFjZTogdHJhY2UgfSk7XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YWNrSW5mbyA9IGl0ZW0uc3RhY2tJbmZvO1xuICAgIHZhciBndWVzcyA9IGVycm9yUGFyc2VyLmd1ZXNzRXJyb3JDbGFzcyhzdGFja0luZm8ubWVzc2FnZSk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGVycm9yQ2xhc3Moc3RhY2tJbmZvLCBndWVzc1swXSwgb3B0aW9ucyk7XG4gICAgdmFyIG1lc3NhZ2UgPSBndWVzc1sxXTtcblxuICAgIGl0ZW0ubWVzc2FnZSA9IGNsYXNzTmFtZSArICc6ICcgKyBtZXNzYWdlO1xuICAgIGFkZEJvZHlNZXNzYWdlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFRyYWNlKGl0ZW0sIHN0YWNrSW5mbywgb3B0aW9ucykge1xuICB2YXIgZGVzY3JpcHRpb24gPSBpdGVtICYmIGl0ZW0uZGF0YS5kZXNjcmlwdGlvbjtcbiAgdmFyIGN1c3RvbSA9IGl0ZW0gJiYgaXRlbS5jdXN0b207XG4gIHZhciBzdGFjayA9IHN0YWNrRnJvbUl0ZW0oaXRlbSk7XG5cbiAgdmFyIGd1ZXNzID0gZXJyb3JQYXJzZXIuZ3Vlc3NFcnJvckNsYXNzKHN0YWNrSW5mby5tZXNzYWdlKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGVycm9yQ2xhc3Moc3RhY2tJbmZvLCBndWVzc1swXSwgb3B0aW9ucyk7XG4gIHZhciBtZXNzYWdlID0gZ3Vlc3NbMV07XG4gIHZhciB0cmFjZSA9IHtcbiAgICBleGNlcHRpb246IHtcbiAgICAgIGNsYXNzOiBjbGFzc05hbWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIH0sXG4gIH07XG5cbiAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgdHJhY2UuZXhjZXB0aW9uLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIH1cblxuICBpZiAoc3RhY2spIHtcbiAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0cmFjZS5leGNlcHRpb24uc3RhY2sgPSBzdGFja0luZm8ucmF3U3RhY2s7XG4gICAgICB0cmFjZS5leGNlcHRpb24ucmF3ID0gU3RyaW5nKHN0YWNrSW5mby5yYXdFeGNlcHRpb24pO1xuICAgIH1cbiAgICB2YXIgc3RhY2tGcmFtZTtcbiAgICB2YXIgZnJhbWU7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIHByZTtcbiAgICB2YXIgcG9zdDtcbiAgICB2YXIgY29udGV4dExlbmd0aDtcbiAgICB2YXIgaSwgbWlkO1xuXG4gICAgdHJhY2UuZnJhbWVzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICBzdGFja0ZyYW1lID0gc3RhY2tbaV07XG4gICAgICBmcmFtZSA9IHtcbiAgICAgICAgZmlsZW5hbWU6IHN0YWNrRnJhbWUudXJsID8gXy5zYW5pdGl6ZVVybChzdGFja0ZyYW1lLnVybCkgOiAnKHVua25vd24pJyxcbiAgICAgICAgbGluZW5vOiBzdGFja0ZyYW1lLmxpbmUgfHwgbnVsbCxcbiAgICAgICAgbWV0aG9kOlxuICAgICAgICAgICFzdGFja0ZyYW1lLmZ1bmMgfHwgc3RhY2tGcmFtZS5mdW5jID09PSAnPydcbiAgICAgICAgICAgID8gJ1thbm9ueW1vdXNdJ1xuICAgICAgICAgICAgOiBzdGFja0ZyYW1lLmZ1bmMsXG4gICAgICAgIGNvbG5vOiBzdGFja0ZyYW1lLmNvbHVtbixcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5zZW5kRnJhbWVVcmwpIHtcbiAgICAgICAgZnJhbWUudXJsID0gc3RhY2tGcmFtZS51cmw7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGZyYW1lLm1ldGhvZCAmJlxuICAgICAgICBmcmFtZS5tZXRob2QuZW5kc1dpdGggJiZcbiAgICAgICAgZnJhbWUubWV0aG9kLmVuZHNXaXRoKCdfcm9sbGJhcl93cmFwcGVkJylcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29kZSA9IHByZSA9IHBvc3QgPSBudWxsO1xuICAgICAgY29udGV4dExlbmd0aCA9IHN0YWNrRnJhbWUuY29udGV4dCA/IHN0YWNrRnJhbWUuY29udGV4dC5sZW5ndGggOiAwO1xuICAgICAgaWYgKGNvbnRleHRMZW5ndGgpIHtcbiAgICAgICAgbWlkID0gTWF0aC5mbG9vcihjb250ZXh0TGVuZ3RoIC8gMik7XG4gICAgICAgIHByZSA9IHN0YWNrRnJhbWUuY29udGV4dC5zbGljZSgwLCBtaWQpO1xuICAgICAgICBjb2RlID0gc3RhY2tGcmFtZS5jb250ZXh0W21pZF07XG4gICAgICAgIHBvc3QgPSBzdGFja0ZyYW1lLmNvbnRleHQuc2xpY2UobWlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgZnJhbWUuY29kZSA9IGNvZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmUgfHwgcG9zdCkge1xuICAgICAgICBmcmFtZS5jb250ZXh0ID0ge307XG4gICAgICAgIGlmIChwcmUgJiYgcHJlLmxlbmd0aCkge1xuICAgICAgICAgIGZyYW1lLmNvbnRleHQucHJlID0gcHJlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3N0ICYmIHBvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgZnJhbWUuY29udGV4dC5wb3N0ID0gcG9zdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhY2tGcmFtZS5hcmdzKSB7XG4gICAgICAgIGZyYW1lLmFyZ3MgPSBzdGFja0ZyYW1lLmFyZ3M7XG4gICAgICB9XG5cbiAgICAgIHRyYWNlLmZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFKGNvcnkpOiByZXZlcnNlIHRoZSBmcmFtZXMgc2luY2Ugcm9sbGJhci5jb20gZXhwZWN0cyB0aGUgbW9zdCByZWNlbnQgY2FsbCBsYXN0XG4gICAgdHJhY2UuZnJhbWVzLnJldmVyc2UoKTtcblxuICAgIGlmIChjdXN0b20pIHtcbiAgICAgIHRyYWNlLmV4dHJhID0gXy5tZXJnZShjdXN0b20pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmFjZTtcbn1cblxuZnVuY3Rpb24gZXJyb3JDbGFzcyhzdGFja0luZm8sIGd1ZXNzLCBvcHRpb25zKSB7XG4gIGlmIChzdGFja0luZm8ubmFtZSkge1xuICAgIHJldHVybiBzdGFja0luZm8ubmFtZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmd1ZXNzRXJyb3JDbGFzcykge1xuICAgIHJldHVybiBndWVzcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyh1bmtub3duKSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU2NydWJiZXIoc2NydWJGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNjcnViRm4pIHtcbiAgICAgIHZhciBzY3J1YkZpZWxkcyA9IG9wdGlvbnMuc2NydWJGaWVsZHMgfHwgW107XG4gICAgICB2YXIgc2NydWJQYXRocyA9IG9wdGlvbnMuc2NydWJQYXRocyB8fCBbXTtcbiAgICAgIGl0ZW0uZGF0YSA9IHNjcnViRm4oaXRlbS5kYXRhLCBzY3J1YkZpZWxkcywgc2NydWJQYXRocyk7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGFuZGxlRG9tRXhjZXB0aW9uOiBoYW5kbGVEb21FeGNlcHRpb24sXG4gIGhhbmRsZUl0ZW1XaXRoRXJyb3I6IGhhbmRsZUl0ZW1XaXRoRXJyb3IsXG4gIGVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheTogZW5zdXJlSXRlbUhhc1NvbWV0aGluZ1RvU2F5LFxuICBhZGRCYXNlSW5mbzogYWRkQmFzZUluZm8sXG4gIGFkZFJlcXVlc3RJbmZvOiBhZGRSZXF1ZXN0SW5mbyxcbiAgYWRkQ2xpZW50SW5mbzogYWRkQ2xpZW50SW5mbyxcbiAgYWRkUGx1Z2luSW5mbzogYWRkUGx1Z2luSW5mbyxcbiAgYWRkQm9keTogYWRkQm9keSxcbiAgYWRkU2NydWJiZXI6IGFkZFNjcnViYmVyLFxufTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbGl0eScpO1xudmFyIG1ha2VGZXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9mZXRjaCcpO1xudmFyIG1ha2VYaHJSZXF1ZXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyJyk7XG5cbi8qXG4gKiBhY2Nlc3NUb2tlbiBtYXkgYmUgZW1iZWRkZWQgaW4gcGF5bG9hZCBidXQgdGhhdCBzaG91bGQgbm90XG4gKiAgIGJlIGFzc3VtZWRcbiAqXG4gKiBvcHRpb25zOiB7XG4gKiAgIGhvc3RuYW1lXG4gKiAgIHByb3RvY29sXG4gKiAgIHBhdGhcbiAqICAgcG9ydFxuICogICBtZXRob2RcbiAqICAgdHJhbnNwb3J0ICgneGhyJyB8ICdmZXRjaCcpXG4gKiB9XG4gKlxuICogIHBhcmFtcyBpcyBhbiBvYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMuIFRoZXNlXG4gKiAgICB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBwYXRoIGFzICdrZXk9dmFsdWUma2V5PXZhbHVlJ1xuICpcbiAqIHBheWxvYWQgaXMgYW4gdW5zZXJpYWxpemVkIG9iamVjdFxuICovXG5mdW5jdGlvbiBUcmFuc3BvcnQodHJ1bmNhdGlvbikge1xuICB0aGlzLnRydW5jYXRpb24gPSB0cnVuY2F0aW9uO1xufVxuXG5UcmFuc3BvcnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChcbiAgYWNjZXNzVG9rZW4sXG4gIG9wdGlvbnMsXG4gIHBhcmFtcyxcbiAgY2FsbGJhY2ssXG4gIHJlcXVlc3RGYWN0b3J5LFxuKSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG4gIF8uYWRkUGFyYW1zQW5kQWNjZXNzVG9rZW5Ub1BhdGgoYWNjZXNzVG9rZW4sIG9wdGlvbnMsIHBhcmFtcyk7XG5cbiAgdmFyIG1ldGhvZCA9ICdHRVQnO1xuICB2YXIgdXJsID0gXy5mb3JtYXRVcmwob3B0aW9ucyk7XG4gIHRoaXMuX21ha2Vab25lUmVxdWVzdChcbiAgICBhY2Nlc3NUb2tlbixcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIG51bGwsXG4gICAgY2FsbGJhY2ssXG4gICAgcmVxdWVzdEZhY3RvcnksXG4gICAgb3B0aW9ucy50aW1lb3V0LFxuICAgIG9wdGlvbnMudHJhbnNwb3J0LFxuICApO1xufTtcblxuVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKFxuICBhY2Nlc3NUb2tlbixcbiAgb3B0aW9ucyxcbiAgcGF5bG9hZCxcbiAgY2FsbGJhY2ssXG4gIHJlcXVlc3RGYWN0b3J5LFxuKSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgaWYgKCFwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQ2Fubm90IHNlbmQgZW1wdHkgcmVxdWVzdCcpKTtcbiAgfVxuXG4gIHZhciBzdHJpbmdpZnlSZXN1bHQ7XG4gIGlmICh0aGlzLnRydW5jYXRpb24pIHtcbiAgICBzdHJpbmdpZnlSZXN1bHQgPSB0aGlzLnRydW5jYXRpb24udHJ1bmNhdGUocGF5bG9hZCk7XG4gIH0gZWxzZSB7XG4gICAgc3RyaW5naWZ5UmVzdWx0ID0gXy5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIH1cbiAgaWYgKHN0cmluZ2lmeVJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayhzdHJpbmdpZnlSZXN1bHQuZXJyb3IpO1xuICB9XG5cbiAgdmFyIHdyaXRlRGF0YSA9IHN0cmluZ2lmeVJlc3VsdC52YWx1ZTtcbiAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgdmFyIHVybCA9IF8uZm9ybWF0VXJsKG9wdGlvbnMpO1xuICB0aGlzLl9tYWtlWm9uZVJlcXVlc3QoXG4gICAgYWNjZXNzVG9rZW4sXG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICB3cml0ZURhdGEsXG4gICAgY2FsbGJhY2ssXG4gICAgcmVxdWVzdEZhY3RvcnksXG4gICAgb3B0aW9ucy50aW1lb3V0LFxuICAgIG9wdGlvbnMudHJhbnNwb3J0LFxuICApO1xufTtcblxuVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0SnNvblBheWxvYWQgPSBmdW5jdGlvbiAoXG4gIGFjY2Vzc1Rva2VuLFxuICBvcHRpb25zLFxuICBqc29uUGF5bG9hZCxcbiAgY2FsbGJhY2ssXG4gIHJlcXVlc3RGYWN0b3J5LFxuKSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgdmFyIHVybCA9IF8uZm9ybWF0VXJsKG9wdGlvbnMpO1xuICB0aGlzLl9tYWtlWm9uZVJlcXVlc3QoXG4gICAgYWNjZXNzVG9rZW4sXG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBqc29uUGF5bG9hZCxcbiAgICBjYWxsYmFjayxcbiAgICByZXF1ZXN0RmFjdG9yeSxcbiAgICBvcHRpb25zLnRpbWVvdXQsXG4gICAgb3B0aW9ucy50cmFuc3BvcnQsXG4gICk7XG59O1xuXG4vLyBXcmFwcyBgX21ha2VSZXF1ZXN0YCBpZiB6b25lLmpzIGlzIGJlaW5nIHVzZWQsIGVuc3VyaW5nIHRoYXQgUm9sbGJhclxuLy8gQVBJIGNhbGxzIGFyZSBub3QgaW50ZXJjZXB0ZWQgYnkgYW55IGNoaWxkIGZvcmtlZCB6b25lcy5cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgTmdab25lLnJ1bk91dHNpZGVBbmd1bGFyYCBpbiBBbmd1bGFyLlxuVHJhbnNwb3J0LnByb3RvdHlwZS5fbWFrZVpvbmVSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ1dpbmRvdyA9XG4gICAgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93KSB8fFxuICAgICh0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmKTtcbiAgLy8gV2hlbmV2ZXIgem9uZS5qcyBpcyBsb2FkZWQgYW5kIGBab25lYCBpcyBleHBvc2VkIGdsb2JhbGx5LCBhY2Nlc3NcbiAgLy8gdGhlIHJvb3Qgem9uZSB0byBlbnN1cmUgdGhhdCByZXF1ZXN0cyBhcmUgYWx3YXlzIG1hZGUgd2l0aGluIGl0LlxuICAvLyBUaGlzIGFwcHJvYWNoIGlzIGZyYW1ld29yay1hZ25vc3RpYywgcmVnYXJkbGVzcyBvZiB3aGljaFxuICAvLyBmcmFtZXdvcmsgem9uZS5qcyBpcyB1c2VkIHdpdGguXG4gIHZhciByb290Wm9uZSA9IGdXaW5kb3cgJiYgZ1dpbmRvdy5ab25lICYmIGdXaW5kb3cuWm9uZS5yb290O1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgaWYgKHJvb3Rab25lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJvb3Rab25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9tYWtlUmVxdWVzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21ha2VSZXF1ZXN0LmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH1cbn07XG5cblRyYW5zcG9ydC5wcm90b3R5cGUuX21ha2VSZXF1ZXN0ID0gZnVuY3Rpb24gKFxuICBhY2Nlc3NUb2tlbixcbiAgdXJsLFxuICBtZXRob2QsXG4gIGRhdGEsXG4gIGNhbGxiYWNrLFxuICByZXF1ZXN0RmFjdG9yeSxcbiAgdGltZW91dCxcbiAgdHJhbnNwb3J0LFxuKSB7XG4gIGlmICh0eXBlb2YgUm9sbGJhclByb3h5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBfcHJveHlSZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0cmFuc3BvcnQgPT09ICdmZXRjaCcpIHtcbiAgICBtYWtlRmV0Y2hSZXF1ZXN0KGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIHRpbWVvdXQpO1xuICB9IGVsc2Uge1xuICAgIG1ha2VYaHJSZXF1ZXN0KFxuICAgICAgYWNjZXNzVG9rZW4sXG4gICAgICB1cmwsXG4gICAgICBtZXRob2QsXG4gICAgICBkYXRhLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICByZXF1ZXN0RmFjdG9yeSxcbiAgICAgIHRpbWVvdXQsXG4gICAgKTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIFJvbGxiYXJQcm94eSAqL1xuZnVuY3Rpb24gX3Byb3h5UmVxdWVzdChqc29uLCBjYWxsYmFjaykge1xuICB2YXIgcm9sbGJhclByb3h5ID0gbmV3IFJvbGxiYXJQcm94eSgpO1xuICByb2xsYmFyUHJveHkuc2VuZEpzb25QYXlsb2FkKFxuICAgIGpzb24sXG4gICAgZnVuY3Rpb24gKF9tc2cpIHtcbiAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGVycikpO1xuICAgIH0sXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuIiwidmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xudmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsaXR5Jyk7XG5cbmZ1bmN0aW9uIG1ha2VGZXRjaFJlcXVlc3QoYWNjZXNzVG9rZW4sIHVybCwgbWV0aG9kLCBkYXRhLCBjYWxsYmFjaywgdGltZW91dCkge1xuICB2YXIgY29udHJvbGxlcjtcbiAgdmFyIHRpbWVvdXRJZDtcblxuICBpZiAoXy5pc0Zpbml0ZU51bWJlcih0aW1lb3V0KSkge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ1gtUm9sbGJhci1BY2Nlc3MtVG9rZW4nOiBhY2Nlc3NUb2tlbixcbiAgICAgIHNpZ25hbDogY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICB9LFxuICAgIGJvZHk6IGRhdGEsXG4gIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAodGltZW91dElkKSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZUZldGNoUmVxdWVzdDtcbiIsIi8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0Ki9cblxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi91dGlsaXR5Jyk7XG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIG1ha2VYaHJSZXF1ZXN0KFxuICBhY2Nlc3NUb2tlbixcbiAgdXJsLFxuICBtZXRob2QsXG4gIGRhdGEsXG4gIGNhbGxiYWNrLFxuICByZXF1ZXN0RmFjdG9yeSxcbiAgdGltZW91dCxcbikge1xuICB2YXIgcmVxdWVzdDtcbiAgaWYgKHJlcXVlc3RGYWN0b3J5KSB7XG4gICAgcmVxdWVzdCA9IHJlcXVlc3RGYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IF9jcmVhdGVYTUxIVFRQT2JqZWN0KCk7XG4gIH1cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gR2l2ZSB1cCwgbm8gd2F5IHRvIHNlbmQgcmVxdWVzdHNcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdObyB3YXkgdG8gc2VuZCBhIHJlcXVlc3QnKSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0cnkge1xuICAgICAgdmFyIG9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAob25yZWFkeXN0YXRlY2hhbmdlICYmIHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB2YXIgcGFyc2VSZXNwb25zZSA9IF8uanNvblBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIGlmIChfaXNTdWNjZXNzKHJlcXVlc3QpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHBhcnNlUmVzcG9uc2UuZXJyb3IsIHBhcnNlUmVzcG9uc2UudmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pc05vcm1hbEZhaWx1cmUocmVxdWVzdCkpIHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICAvLyBsaWtlbHkgY2F1c2VkIGJ5IHVzaW5nIGEgc2VydmVyIGFjY2VzcyB0b2tlblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgIHBhcnNlUmVzcG9uc2UudmFsdWUgJiYgcGFyc2VSZXNwb25zZS52YWx1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsaWQgaHR0cCBzdGF0dXMgY29kZXNcbiAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFN0cmluZyhyZXF1ZXN0LnN0YXR1cykpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIElFIHdpbGwgcmV0dXJuIGEgc3RhdHVzIDEyMDAwKyBvbiBzb21lIHNvcnQgb2YgY29ubmVjdGlvbiBmYWlsdXJlLFxuICAgICAgICAgICAgICAvLyBzbyB3ZSByZXR1cm4gYSBibGFuayBlcnJvclxuICAgICAgICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWEzODM3NzAlMjhWUy44NSUyOS5hc3B4XG4gICAgICAgICAgICAgIHZhciBtc2cgPVxuICAgICAgICAgICAgICAgICdYSFIgcmVzcG9uc2UgaGFkIG5vIHN0YXR1cyBjb2RlIChsaWtlbHkgY29ubmVjdGlvbiBmYWlsdXJlKSc7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKF9uZXdSZXRyaWFibGVFcnJvcihtc2cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgLy9qcXVlcnkgc291cmNlIG1lbnRpb25zIGZpcmVmb3ggbWF5IGVycm9yIG91dCB3aGlsZSBhY2Nlc3NpbmcgdGhlXG4gICAgICAgICAgLy9yZXF1ZXN0IG1lbWJlcnMgaWYgdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL2E5MzhkN2IxMjgyZmMwZTVjNTI1MDJjMjI1YWU4ZjBjZWYyMTlmMGEvc3JjL2FqYXgveGhyLmpzI0wxMTFcbiAgICAgICAgICB2YXIgZXhjO1xuICAgICAgICAgIGlmIChleCAmJiBleC5zdGFjaykge1xuICAgICAgICAgICAgZXhjID0gZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4YyA9IG5ldyBFcnJvcihleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKGV4Yyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICBpZiAocmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJvbGxiYXItQWNjZXNzLVRva2VuJywgYWNjZXNzVG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0Zpbml0ZU51bWJlcih0aW1lb3V0KSkge1xuICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG9ucmVhZHlzdGF0ZWNoYW5nZTtcbiAgICAgIHJlcXVlc3Quc2VuZChkYXRhKTtcbiAgICB9IGNhdGNoIChlMSkge1xuICAgICAgLy8gU2VuZGluZyB1c2luZyB0aGUgbm9ybWFsIHhtbGh0dHByZXF1ZXN0IG9iamVjdCBkaWRuJ3Qgd29yaywgdHJ5IFhEb21haW5SZXF1ZXN0XG4gICAgICBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBBc3N1bWUgd2UgYXJlIGluIGEgcmVhbGx5IG9sZCBicm93c2VyIHdoaWNoIGhhcyBhIGJ1bmNoIG9mIGxpbWl0YXRpb25zOlxuICAgICAgICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cbiAgICAgICAgLy8gRXh0cmVtZSBwYXJhbm9pYTogaWYgd2UgaGF2ZSBYRG9tYWluUmVxdWVzdCB0aGVuIHdlIGhhdmUgYSB3aW5kb3csIGJ1dCBqdXN0IGluIGNhc2VcbiAgICAgICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ05vIHdpbmRvdyBhdmFpbGFibGUgZHVyaW5nIHJlcXVlc3QsIHVua25vd24gZW52aXJvbm1lbnQnLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgcGFnZSBpcyBodHRwLCB0cnkgYW5kIHNlbmQgb3ZlciBodHRwXG4gICAgICAgIGlmIChcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZi5zdWJzdHJpbmcoMCwgNSkgPT09ICdodHRwOicgJiZcbiAgICAgICAgICB1cmwuc3Vic3RyaW5nKDAsIDUpID09PSAnaHR0cHMnXG4gICAgICAgICkge1xuICAgICAgICAgIHVybCA9ICdodHRwJyArIHVybC5zdWJzdHJpbmcoNSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeGRvbWFpbnJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB4ZG9tYWlucmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdSZXF1ZXN0IHRpbWVkIG91dCc7XG4gICAgICAgICAgdmFyIGNvZGUgPSAnRVRJTUVET1VUJztcbiAgICAgICAgICBjYWxsYmFjayhfbmV3UmV0cmlhYmxlRXJyb3IobXNnLCBjb2RlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHhkb21haW5yZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdFcnJvciBkdXJpbmcgcmVxdWVzdCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwYXJzZVJlc3BvbnNlID0gXy5qc29uUGFyc2UoeGRvbWFpbnJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhwYXJzZVJlc3BvbnNlLmVycm9yLCBwYXJzZVJlc3BvbnNlLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGRvbWFpbnJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhkb21haW5yZXF1ZXN0LnNlbmQoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgbWV0aG9kIHRvIHRyYW5zcG9ydCBhIHJlcXVlc3QnKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlMikge1xuICAgIGNhbGxiYWNrKGUyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWE1MSFRUUE9iamVjdCgpIHtcbiAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3Q6ZmFsc2UgKi9cblxuICB2YXIgZmFjdG9yaWVzID0gW1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwzLlhNTEhUVFAnKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9LFxuICBdO1xuICB2YXIgeG1saHR0cDtcbiAgdmFyIGk7XG4gIHZhciBudW1GYWN0b3JpZXMgPSBmYWN0b3JpZXMubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtRmFjdG9yaWVzOyBpKyspIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICAgIHRyeSB7XG4gICAgICB4bWxodHRwID0gZmFjdG9yaWVzW2ldKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwYXNzXG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbiAgfVxuICByZXR1cm4geG1saHR0cDtcbn1cblxuZnVuY3Rpb24gX2lzU3VjY2VzcyhyKSB7XG4gIHJldHVybiByICYmIHIuc3RhdHVzICYmIHIuc3RhdHVzID09PSAyMDA7XG59XG5cbmZ1bmN0aW9uIF9pc05vcm1hbEZhaWx1cmUocikge1xuICByZXR1cm4gciAmJiBfLmlzVHlwZShyLnN0YXR1cywgJ251bWJlcicpICYmIHIuc3RhdHVzID49IDQwMCAmJiByLnN0YXR1cyA8IDYwMDtcbn1cblxuZnVuY3Rpb24gX25ld1JldHJpYWJsZUVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb2RlIHx8ICdFTk9URk9VTkQnO1xuICByZXR1cm4gZXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VYaHJSZXF1ZXN0O1xuIiwiLy8gU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvdXJsLmh0bWxcbmZ1bmN0aW9uIHBhcnNlKHVybCkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHByb3RvY29sOiBudWxsLFxuICAgIGF1dGg6IG51bGwsXG4gICAgaG9zdDogbnVsbCxcbiAgICBwYXRoOiBudWxsLFxuICAgIGhhc2g6IG51bGwsXG4gICAgaHJlZjogdXJsLFxuICAgIGhvc3RuYW1lOiBudWxsLFxuICAgIHBvcnQ6IG51bGwsXG4gICAgcGF0aG5hbWU6IG51bGwsXG4gICAgc2VhcmNoOiBudWxsLFxuICAgIHF1ZXJ5OiBudWxsLFxuICB9O1xuXG4gIHZhciBpLCBsYXN0O1xuICBpID0gdXJsLmluZGV4T2YoJy8vJyk7XG4gIGlmIChpICE9PSAtMSkge1xuICAgIHJlc3VsdC5wcm90b2NvbCA9IHVybC5zdWJzdHJpbmcoMCwgaSk7XG4gICAgbGFzdCA9IGkgKyAyO1xuICB9IGVsc2Uge1xuICAgIGxhc3QgPSAwO1xuICB9XG5cbiAgaSA9IHVybC5pbmRleE9mKCdAJywgbGFzdCk7XG4gIGlmIChpICE9PSAtMSkge1xuICAgIHJlc3VsdC5hdXRoID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcbiAgICBsYXN0ID0gaSArIDE7XG4gIH1cblxuICBpID0gdXJsLmluZGV4T2YoJy8nLCBsYXN0KTtcbiAgaWYgKGkgPT09IC0xKSB7XG4gICAgaSA9IHVybC5pbmRleE9mKCc/JywgbGFzdCk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICBpID0gdXJsLmluZGV4T2YoJyMnLCBsYXN0KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXN1bHQuaG9zdCA9IHVybC5zdWJzdHJpbmcobGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuaG9zdCA9IHVybC5zdWJzdHJpbmcobGFzdCwgaSk7XG4gICAgICAgIHJlc3VsdC5oYXNoID0gdXJsLnN1YnN0cmluZyhpKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgICByZXN1bHQucG9ydCA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMV07XG4gICAgICBpZiAocmVzdWx0LnBvcnQpIHtcbiAgICAgICAgcmVzdWx0LnBvcnQgPSBwYXJzZUludChyZXN1bHQucG9ydCwgMTApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3Quc3BsaXQoJzonKVswXTtcbiAgICAgIHJlc3VsdC5wb3J0ID0gcmVzdWx0Lmhvc3Quc3BsaXQoJzonKVsxXTtcbiAgICAgIGlmIChyZXN1bHQucG9ydCkge1xuICAgICAgICByZXN1bHQucG9ydCA9IHBhcnNlSW50KHJlc3VsdC5wb3J0LCAxMCk7XG4gICAgICB9XG4gICAgICBsYXN0ID0gaTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgcmVzdWx0LnBvcnQgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgIGlmIChyZXN1bHQucG9ydCkge1xuICAgICAgcmVzdWx0LnBvcnQgPSBwYXJzZUludChyZXN1bHQucG9ydCwgMTApO1xuICAgIH1cbiAgICBsYXN0ID0gaTtcbiAgfVxuXG4gIGkgPSB1cmwuaW5kZXhPZignIycsIGxhc3QpO1xuICBpZiAoaSA9PT0gLTEpIHtcbiAgICByZXN1bHQucGF0aCA9IHVybC5zdWJzdHJpbmcobGFzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGggPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuICAgIHJlc3VsdC5oYXNoID0gdXJsLnN1YnN0cmluZyhpKTtcbiAgfVxuXG4gIGlmIChyZXN1bHQucGF0aCkge1xuICAgIHZhciBwYXRoUGFydHMgPSByZXN1bHQucGF0aC5zcGxpdCgnPycpO1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHBhdGhQYXJ0c1swXTtcbiAgICByZXN1bHQucXVlcnkgPSBwYXRoUGFydHNbMV07XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlc3VsdC5xdWVyeSA/ICc/JyArIHJlc3VsdC5xdWVyeSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbn07XG4iLCJmdW5jdGlvbiB3cmFwR2xvYmFscyh3aW5kb3csIGhhbmRsZXIsIHNoaW0pIHtcbiAgaWYgKCF3aW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9idWdzbmFnL2J1Z3NuYWctanNcbiAgdmFyIGdsb2JhbHMgPVxuICAgICdFdmVudFRhcmdldCxXaW5kb3csTm9kZSxBcHBsaWNhdGlvbkNhY2hlLEF1ZGlvVHJhY2tMaXN0LENoYW5uZWxNZXJnZXJOb2RlLENyeXB0b09wZXJhdGlvbixFdmVudFNvdXJjZSxGaWxlUmVhZGVyLEhUTUxVbmtub3duRWxlbWVudCxJREJEYXRhYmFzZSxJREJSZXF1ZXN0LElEQlRyYW5zYWN0aW9uLEtleU9wZXJhdGlvbixNZWRpYUNvbnRyb2xsZXIsTWVzc2FnZVBvcnQsTW9kYWxXaW5kb3csTm90aWZpY2F0aW9uLFNWR0VsZW1lbnRJbnN0YW5jZSxTY3JlZW4sVGV4dFRyYWNrLFRleHRUcmFja0N1ZSxUZXh0VHJhY2tMaXN0LFdlYlNvY2tldCxXZWJTb2NrZXRXb3JrZXIsV29ya2VyLFhNTEh0dHBSZXF1ZXN0LFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQsWE1MSHR0cFJlcXVlc3RVcGxvYWQnLnNwbGl0KFxuICAgICAgJywnLFxuICAgICk7XG4gIHZhciBpLCBnbG9iYWw7XG4gIGZvciAoaSA9IDA7IGkgPCBnbG9iYWxzLmxlbmd0aDsgKytpKSB7XG4gICAgZ2xvYmFsID0gZ2xvYmFsc1tpXTtcblxuICAgIGlmICh3aW5kb3dbZ2xvYmFsXSAmJiB3aW5kb3dbZ2xvYmFsXS5wcm90b3R5cGUpIHtcbiAgICAgIF9leHRlbmRMaXN0ZW5lclByb3RvdHlwZShoYW5kbGVyLCB3aW5kb3dbZ2xvYmFsXS5wcm90b3R5cGUsIHNoaW0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfZXh0ZW5kTGlzdGVuZXJQcm90b3R5cGUoaGFuZGxlciwgcHJvdG90eXBlLCBzaGltKSB7XG4gIGlmIChcbiAgICBwcm90b3R5cGUuaGFzT3duUHJvcGVydHkgJiZcbiAgICBwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2FkZEV2ZW50TGlzdGVuZXInKVxuICApIHtcbiAgICB2YXIgb2xkQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuICAgIHdoaWxlIChcbiAgICAgIG9sZEFkZEV2ZW50TGlzdGVuZXIuX3JvbGxiYXJPbGRBZGQgJiZcbiAgICAgIG9sZEFkZEV2ZW50TGlzdGVuZXIuYmVsb25nc1RvU2hpbVxuICAgICkge1xuICAgICAgb2xkQWRkRXZlbnRMaXN0ZW5lciA9IG9sZEFkZEV2ZW50TGlzdGVuZXIuX3JvbGxiYXJPbGRBZGQ7XG4gICAgfVxuICAgIHZhciBhZGRGbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2ssIGJ1YmJsZSkge1xuICAgICAgb2xkQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCBoYW5kbGVyLndyYXAoY2FsbGJhY2spLCBidWJibGUpO1xuICAgIH07XG4gICAgYWRkRm4uX3JvbGxiYXJPbGRBZGQgPSBvbGRBZGRFdmVudExpc3RlbmVyO1xuICAgIGFkZEZuLmJlbG9uZ3NUb1NoaW0gPSBzaGltO1xuICAgIHByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRm47XG5cbiAgICB2YXIgb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHdoaWxlIChcbiAgICAgIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIuX3JvbGxiYXJPbGRSZW1vdmUgJiZcbiAgICAgIG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIuYmVsb25nc1RvU2hpbVxuICAgICkge1xuICAgICAgb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIuX3JvbGxiYXJPbGRSZW1vdmU7XG4gICAgfVxuICAgIHZhciByZW1vdmVGbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2ssIGJ1YmJsZSkge1xuICAgICAgb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICBldmVudCxcbiAgICAgICAgKGNhbGxiYWNrICYmIGNhbGxiYWNrLl9yb2xsYmFyX3dyYXBwZWQpIHx8IGNhbGxiYWNrLFxuICAgICAgICBidWJibGUsXG4gICAgICApO1xuICAgIH07XG4gICAgcmVtb3ZlRm4uX3JvbGxiYXJPbGRSZW1vdmUgPSBvbGRSZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHJlbW92ZUZuLmJlbG9uZ3NUb1NoaW0gPSBzaGltO1xuICAgIHByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwR2xvYmFscztcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJzaW9uOiAnMy4wLjAtYWxwaGEuMCcsXG4gIGVuZHBvaW50OiAnYXBpLnJvbGxiYXIuY29tL2FwaS8xL2l0ZW0vJyxcbiAgbG9nTGV2ZWw6ICdkZWJ1ZycsXG4gIHJlcG9ydExldmVsOiAnZGVidWcnLFxuICB1bmNhdWdodEVycm9yTGV2ZWw6ICdlcnJvcicsXG4gIG1heEl0ZW1zOiAwLFxuICBpdGVtc1Blck1pbjogNjAsXG59O1xuIiwidmFyIEVycm9yU3RhY2tQYXJzZXIgPSByZXF1aXJlKCdlcnJvci1zdGFjay1wYXJzZXInKTtcblxudmFyIFVOS05PV05fRlVOQ1RJT04gPSAnPyc7XG52YXIgRVJSX0NMQVNTX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKChbYS16QS1aMC05LV8kIF0qKTogKik/KFVuY2F1Z2h0ICk/KFthLXpBLVowLTktXyQgXSopOiAnLFxuKTtcblxuZnVuY3Rpb24gZ3Vlc3NGdW5jdGlvbk5hbWUoKSB7XG4gIHJldHVybiBVTktOT1dOX0ZVTkNUSU9OO1xufVxuXG5mdW5jdGlvbiBnYXRoZXJDb250ZXh0KCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gRnJhbWUoc3RhY2tGcmFtZSkge1xuICB2YXIgZGF0YSA9IHt9O1xuXG4gIGRhdGEuX3N0YWNrRnJhbWUgPSBzdGFja0ZyYW1lO1xuXG4gIGRhdGEudXJsID0gc3RhY2tGcmFtZS5maWxlTmFtZTtcbiAgZGF0YS5saW5lID0gc3RhY2tGcmFtZS5saW5lTnVtYmVyO1xuICBkYXRhLmZ1bmMgPSBzdGFja0ZyYW1lLmZ1bmN0aW9uTmFtZTtcbiAgZGF0YS5jb2x1bW4gPSBzdGFja0ZyYW1lLmNvbHVtbk51bWJlcjtcbiAgZGF0YS5hcmdzID0gc3RhY2tGcmFtZS5hcmdzO1xuXG4gIGRhdGEuY29udGV4dCA9IGdhdGhlckNvbnRleHQoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gU3RhY2soZXhjZXB0aW9uLCBza2lwKSB7XG4gIGZ1bmN0aW9uIGdldFN0YWNrKCkge1xuICAgIHZhciBwYXJzZXJTdGFjayA9IFtdO1xuXG4gICAgc2tpcCA9IHNraXAgfHwgMDtcblxuICAgIHRyeSB7XG4gICAgICBwYXJzZXJTdGFjayA9IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXhjZXB0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwYXJzZXJTdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHNraXA7IGkgPCBwYXJzZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhY2sucHVzaChuZXcgRnJhbWUocGFyc2VyU3RhY2tbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YWNrOiBnZXRTdGFjaygpLFxuICAgIG1lc3NhZ2U6IGV4Y2VwdGlvbi5tZXNzYWdlLFxuICAgIG5hbWU6IF9tb3N0U3BlY2lmaWNFcnJvck5hbWUoZXhjZXB0aW9uKSxcbiAgICByYXdTdGFjazogZXhjZXB0aW9uLnN0YWNrLFxuICAgIHJhd0V4Y2VwdGlvbjogZXhjZXB0aW9uLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZShlLCBza2lwKSB7XG4gIHZhciBlcnIgPSBlO1xuXG4gIGlmIChlcnIubmVzdGVkIHx8IGVyci5jYXVzZSkge1xuICAgIHZhciB0cmFjZUNoYWluID0gW107XG4gICAgd2hpbGUgKGVycikge1xuICAgICAgdHJhY2VDaGFpbi5wdXNoKG5ldyBTdGFjayhlcnIsIHNraXApKTtcbiAgICAgIGVyciA9IGVyci5uZXN0ZWQgfHwgZXJyLmNhdXNlO1xuXG4gICAgICBza2lwID0gMDsgLy8gT25seSBhcHBseSBza2lwIHZhbHVlIHRvIHByaW1hcnkgZXJyb3JcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gcHJpbWFyeSBlcnJvciB3aXRoIGZ1bGwgdHJhY2UgY2hhaW4gYXR0YWNoZWQuXG4gICAgdHJhY2VDaGFpblswXS50cmFjZUNoYWluID0gdHJhY2VDaGFpbjtcbiAgICByZXR1cm4gdHJhY2VDaGFpblswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFN0YWNrKGVyciwgc2tpcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ3Vlc3NFcnJvckNsYXNzKGVyck1zZykge1xuICBpZiAoIWVyck1zZyB8fCAhZXJyTXNnLm1hdGNoKSB7XG4gICAgcmV0dXJuIFsnVW5rbm93biBlcnJvci4gVGhlcmUgd2FzIG5vIGVycm9yIG1lc3NhZ2UgdG8gZGlzcGxheS4nLCAnJ107XG4gIH1cbiAgdmFyIGVyckNsYXNzTWF0Y2ggPSBlcnJNc2cubWF0Y2goRVJSX0NMQVNTX1JFR0VYUCk7XG4gIHZhciBlcnJDbGFzcyA9ICcodW5rbm93biknO1xuXG4gIGlmIChlcnJDbGFzc01hdGNoKSB7XG4gICAgZXJyQ2xhc3MgPSBlcnJDbGFzc01hdGNoW2VyckNsYXNzTWF0Y2gubGVuZ3RoIC0gMV07XG4gICAgZXJyTXNnID0gZXJyTXNnLnJlcGxhY2UoXG4gICAgICAoZXJyQ2xhc3NNYXRjaFtlcnJDbGFzc01hdGNoLmxlbmd0aCAtIDJdIHx8ICcnKSArIGVyckNsYXNzICsgJzonLFxuICAgICAgJycsXG4gICAgKTtcbiAgICBlcnJNc2cgPSBlcnJNc2cucmVwbGFjZSgvKF5bXFxzXSt8W1xcc10rJCkvZywgJycpO1xuICB9XG4gIHJldHVybiBbZXJyQ2xhc3MsIGVyck1zZ107XG59XG5cbi8vICogUHJlZmVycyBhbnkgdmFsdWUgb3ZlciBhbiBlbXB0eSBzdHJpbmdcbi8vICogUHJlZmVycyBhbnkgdmFsdWUgb3ZlciAnRXJyb3InIHdoZXJlIHBvc3NpYmxlXG4vLyAqIFByZWZlcnMgbmFtZSBvdmVyIGNvbnN0cnVjdG9yLm5hbWUgd2hlbiBib3RoIGFyZSBtb3JlIHNwZWNpZmljIHRoYW4gJ0Vycm9yJ1xuZnVuY3Rpb24gX21vc3RTcGVjaWZpY0Vycm9yTmFtZShlcnJvcikge1xuICB2YXIgbmFtZSA9IGVycm9yLm5hbWUgJiYgZXJyb3IubmFtZS5sZW5ndGggJiYgZXJyb3IubmFtZTtcbiAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9XG4gICAgZXJyb3IuY29uc3RydWN0b3IubmFtZSAmJlxuICAgIGVycm9yLmNvbnN0cnVjdG9yLm5hbWUubGVuZ3RoICYmXG4gICAgZXJyb3IuY29uc3RydWN0b3IubmFtZTtcblxuICBpZiAoIW5hbWUgfHwgIWNvbnN0cnVjdG9yTmFtZSkge1xuICAgIHJldHVybiBuYW1lIHx8IGNvbnN0cnVjdG9yTmFtZTtcbiAgfVxuXG4gIGlmIChuYW1lID09PSAnRXJyb3InKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGd1ZXNzRnVuY3Rpb25OYW1lOiBndWVzc0Z1bmN0aW9uTmFtZSxcbiAgZ3Vlc3NFcnJvckNsYXNzOiBndWVzc0Vycm9yQ2xhc3MsXG4gIGdhdGhlckNvbnRleHQ6IGdhdGhlckNvbnRleHQsXG4gIHBhcnNlOiBwYXJzZSxcbiAgU3RhY2s6IFN0YWNrLFxuICBGcmFtZTogRnJhbWUsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBoYXNPd25Db25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG4gIHZhciBoYXNJc1Byb3RvdHlwZU9mID1cbiAgICBvYmouY29uc3RydWN0b3IgJiZcbiAgICBvYmouY29uc3RydWN0b3IucHJvdG90eXBlICYmXG4gICAgaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcbiAgLy8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuICAvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgLyoqL1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn07XG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgaSxcbiAgICBzcmMsXG4gICAgY29weSxcbiAgICBjbG9uZSxcbiAgICBuYW1lLFxuICAgIHJlc3VsdCA9IHt9LFxuICAgIGN1cnJlbnQgPSBudWxsLFxuICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKG5hbWUgaW4gY3VycmVudCkge1xuICAgICAgc3JjID0gcmVzdWx0W25hbWVdO1xuICAgICAgY29weSA9IGN1cnJlbnRbbmFtZV07XG4gICAgICBpZiAocmVzdWx0ICE9PSBjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ICYmIGlzUGxhaW5PYmplY3QoY29weSkpIHtcbiAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSBtZXJnZShjbG9uZSwgY29weSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvcHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gY29weTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuLypcbiAqIE5vdGlmaWVyIC0gdGhlIGludGVybmFsIG9iamVjdCByZXNwb25zaWJsZSBmb3IgZGVsZWdhdGluZyBiZXR3ZWVuIHRoZSBjbGllbnQgZXhwb3NlZCBBUEksIHRoZVxuICogY2hhaW4gb2YgdHJhbnNmb3JtcyBuZWNlc3NhcnkgdG8gdHVybiBhbiBpdGVtIGludG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHNlbnQgdG8gUm9sbGJhciwgYW5kIHRoZVxuICogcXVldWUgd2hpY2ggaGFuZGxlcyB0aGUgY29tbXVuY2F0aW9uIHdpdGggdGhlIFJvbGxiYXIgQVBJIHNlcnZlcnMuXG4gKlxuICogQHBhcmFtIHF1ZXVlIC0gYW4gb2JqZWN0IHRoYXQgY29uZm9ybXMgdG8gdGhlIGludGVyZmFjZTogYWRkSXRlbShpdGVtLCBjYWxsYmFjaylcbiAqIEBwYXJhbSBvcHRpb25zIC0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgb3B0aW9ucyB0byBiZSBzZXQgZm9yIHRoaXMgbm90aWZpZXIsIHRoaXMgc2hvdWxkIGhhdmVcbiAqIGFueSBkZWZhdWx0cyBhbHJlYWR5IHNldCBieSB0aGUgY2FsbGVyXG4gKi9cbmZ1bmN0aW9uIE5vdGlmaWVyKHF1ZXVlLCBvcHRpb25zKSB7XG4gIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gIHRoaXMuZGlhZ25vc3RpYyA9IHt9O1xufVxuXG4vKlxuICogY29uZmlndXJlIC0gdXBkYXRlcyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBub3RpZmllciB3aXRoIHRoZSBwYXNzZWQgaW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBhbiBvYmplY3Qgd2hpY2ggZ2V0cyBtZXJnZWQgd2l0aCB0aGUgY3VycmVudCBvcHRpb25zIHNldCBvbiB0aGlzIG5vdGlmaWVyXG4gKiBAcmV0dXJucyB0aGlzXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLnF1ZXVlICYmIHRoaXMucXVldWUuY29uZmlndXJlKG9wdGlvbnMpO1xuICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvbGRPcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKlxuICogYWRkVHJhbnNmb3JtIC0gYWRkcyBhIHRyYW5zZm9ybSBvbnRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlIG9mIHRyYW5zZm9ybXMgZm9yIHRoaXMgbm90aWZpZXJcbiAqXG4gKiBAcGFyYW0gdHJhbnNmb3JtIC0gYSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aHJlZSBhcmd1bWVudHM6XG4gKiAgICAqIGl0ZW06IEFuIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRhdGEgdG8gZXZlbnR1YWxseSBiZSBzZW50IHRvIFJvbGxiYXJcbiAqICAgICogb3B0aW9uczogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG9wdGlvbnMgZm9yIHRoaXMgbm90aWZpZXJcbiAqICAgICogY2FsbGJhY2s6IGZ1bmN0aW9uKGVycjogKE51bGx8RXJyb3IpLCBpdGVtOiAoTnVsbHxPYmplY3QpKSB0aGUgdHJhbnNmb3JtIG11c3QgY2FsbCB0aGlzXG4gKiAgICBjYWxsYmFjayB3aXRoIGEgbnVsbCB2YWx1ZSBmb3IgZXJyb3IgaWYgaXQgd2FudHMgdGhlIHByb2Nlc3NpbmcgY2hhaW4gdG8gY29udGludWUsIG90aGVyd2lzZVxuICogICAgd2l0aCBhbiBlcnJvciB0byB0ZXJtaW5hdGUgdGhlIHByb2Nlc3NpbmcuIFRoZSBpdGVtIHNob3VsZCBiZSB0aGUgdXBkYXRlZCBpdGVtIGFmdGVyIHRoaXNcbiAqICAgIHRyYW5zZm9ybSBpcyBmaW5pc2hlZCBtb2RpZnlpbmcgaXQuXG4gKi9cbk5vdGlmaWVyLnByb3RvdHlwZS5hZGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24odHJhbnNmb3JtKSkge1xuICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKlxuICogbG9nIC0gdGhlIGludGVybmFsIGxvZyBmdW5jdGlvbiB3aGljaCBhcHBsaWVzIHRoZSBjb25maWd1cmVkIHRyYW5zZm9ybXMgYW5kIHRoZW4gcHVzaGVzIG9udG8gdGhlXG4gKiBxdWV1ZSB0byBiZSBzZW50IHRvIHRoZSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKiAgICBtZXNzYWdlIFtTdHJpbmddIC0gQW4gb3B0aW9uYWwgc3RyaW5nIHRvIGJlIHNlbnQgdG8gcm9sbGJhclxuICogICAgZXJyb3IgW0Vycm9yXSAtIEFuIG9wdGlvbmFsIGVycm9yXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmdW5jdGlvbiBvZiB0eXBlIGZ1bmN0aW9uKGVyciwgcmVzcCkgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBleGFjdGx5IG9uZVxuICogbnVsbCBhcmd1bWVudCBhbmQgb25lIG5vbi1udWxsIGFyZ3VtZW50LiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSwgZWl0aGVyIGR1cmluZyB0aGVcbiAqIHRyYW5zZm9ybSBzdGFnZSBpZiBhbiBlcnJvciBvY2N1cnMgaW5zaWRlIGEgdHJhbnNmb3JtLCBvciBpbiByZXNwb25zZSB0byB0aGUgY29tbXVuaWNhdGlvbiB3aXRoXG4gKiB0aGUgYmFja2VuZC4gVGhlIHNlY29uZCBhcmd1bWVudCB3aWxsIGJlIHRoZSByZXNwb25zZSBmcm9tIHRoZSBiYWNrZW5kIGluIGNhc2Ugb2Ygc3VjY2Vzcy5cbiAqL1xuTm90aWZpZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdSb2xsYmFyIGlzIG5vdCBlbmFibGVkJykpO1xuICB9XG5cbiAgdGhpcy5xdWV1ZS5hZGRQZW5kaW5nSXRlbShpdGVtKTtcbiAgdmFyIG9yaWdpbmFsRXJyb3IgPSBpdGVtLmVycjtcbiAgdGhpcy5fYXBwbHlUcmFuc2Zvcm1zKFxuICAgIGl0ZW0sXG4gICAgZnVuY3Rpb24gKGVyciwgaSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLnF1ZXVlLnJlbW92ZVBlbmRpbmdJdGVtKGl0ZW0pO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVldWUuYWRkSXRlbShpLCBjYWxsYmFjaywgb3JpZ2luYWxFcnJvciwgaXRlbSk7XG4gICAgfS5iaW5kKHRoaXMpLFxuICApO1xufTtcblxuLyogSW50ZXJuYWwgKi9cblxuLypcbiAqIF9hcHBseVRyYW5zZm9ybXMgLSBBcHBsaWVzIHRoZSB0cmFuc2Zvcm1zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXMgbm90aWZpZXIgc2VxdWVudGlhbGx5LiBTZWVcbiAqIGBhZGRUcmFuc2Zvcm1gIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gQW4gaXRlbSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmdW5jdGlvbiBvZiB0eXBlIGZ1bmN0aW9uKGVyciwgaXRlbSkgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhIG5vbi1udWxsXG4gKiBlcnJvciBhbmQgYSBudWxsIGl0ZW0gaW4gdGhlIGNhc2Ugb2YgYSB0cmFuc2Zvcm0gZmFpbHVyZSwgb3IgYSBudWxsIGVycm9yIGFuZCBub24tbnVsbCBpdGVtIGFmdGVyXG4gKiBhbGwgdHJhbnNmb3JtcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAqL1xuTm90aWZpZXIucHJvdG90eXBlLl9hcHBseVRyYW5zZm9ybXMgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgdmFyIHRyYW5zZm9ybUluZGV4ID0gLTE7XG4gIHZhciB0cmFuc2Zvcm1zTGVuZ3RoID0gdGhpcy50cmFuc2Zvcm1zLmxlbmd0aDtcbiAgdmFyIHRyYW5zZm9ybXMgPSB0aGlzLnRyYW5zZm9ybXM7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIHZhciBjYiA9IGZ1bmN0aW9uIChlcnIsIGkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybUluZGV4Kys7XG5cbiAgICBpZiAodHJhbnNmb3JtSW5kZXggPT09IHRyYW5zZm9ybXNMZW5ndGgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybXNbdHJhbnNmb3JtSW5kZXhdKGksIG9wdGlvbnMsIGNiKTtcbiAgfTtcblxuICBjYihudWxsLCBpdGVtKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm90aWZpZXI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xuXG5mdW5jdGlvbiBjaGVja0xldmVsKGl0ZW0sIHNldHRpbmdzKSB7XG4gIHZhciBsZXZlbCA9IGl0ZW0ubGV2ZWw7XG4gIHZhciBsZXZlbFZhbCA9IF8uTEVWRUxTW2xldmVsXSB8fCAwO1xuICB2YXIgcmVwb3J0TGV2ZWwgPSBzZXR0aW5ncy5yZXBvcnRMZXZlbDtcbiAgdmFyIHJlcG9ydExldmVsVmFsID0gXy5MRVZFTFNbcmVwb3J0TGV2ZWxdIHx8IDA7XG5cbiAgaWYgKGxldmVsVmFsIDwgcmVwb3J0TGV2ZWxWYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHVzZXJDaGVja0lnbm9yZShsb2dnZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBzZXR0aW5ncykge1xuICAgIHZhciBpc1VuY2F1Z2h0ID0gISFpdGVtLl9pc1VuY2F1Z2h0O1xuICAgIGRlbGV0ZSBpdGVtLl9pc1VuY2F1Z2h0O1xuICAgIHZhciBhcmdzID0gaXRlbS5fb3JpZ2luYWxBcmdzO1xuICAgIGRlbGV0ZSBpdGVtLl9vcmlnaW5hbEFyZ3M7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oc2V0dGluZ3Mub25TZW5kQ2FsbGJhY2spKSB7XG4gICAgICAgIHNldHRpbmdzLm9uU2VuZENhbGxiYWNrKGlzVW5jYXVnaHQsIGFyZ3MsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldHRpbmdzLm9uU2VuZENhbGxiYWNrID0gbnVsbDtcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgY2FsbGluZyBvblNlbmRDYWxsYmFjaywgcmVtb3ZpbmcnLCBlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChcbiAgICAgICAgXy5pc0Z1bmN0aW9uKHNldHRpbmdzLmNoZWNrSWdub3JlKSAmJlxuICAgICAgICBzZXR0aW5ncy5jaGVja0lnbm9yZShpc1VuY2F1Z2h0LCBhcmdzLCBpdGVtKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZXR0aW5ncy5jaGVja0lnbm9yZSA9IG51bGw7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIGNhbGxpbmcgY3VzdG9tIGNoZWNrSWdub3JlKCksIHJlbW92aW5nJywgZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cmxJc05vdEJsb2NrTGlzdGVkKGxvZ2dlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuICF1cmxJc09uQUxpc3QoaXRlbSwgc2V0dGluZ3MsICdibG9ja2xpc3QnLCBsb2dnZXIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cmxJc1NhZmVMaXN0ZWQobG9nZ2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gdXJsSXNPbkFMaXN0KGl0ZW0sIHNldHRpbmdzLCAnc2FmZWxpc3QnLCBsb2dnZXIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYXRjaEZyYW1lcyh0cmFjZSwgbGlzdCwgYmxvY2spIHtcbiAgaWYgKCF0cmFjZSkge1xuICAgIHJldHVybiAhYmxvY2s7XG4gIH1cblxuICB2YXIgZnJhbWVzID0gdHJhY2UuZnJhbWVzO1xuXG4gIGlmICghZnJhbWVzIHx8IGZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gIWJsb2NrO1xuICB9XG5cbiAgdmFyIGZyYW1lLCBmaWxlbmFtZSwgdXJsLCB1cmxSZWdleDtcbiAgdmFyIGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGZyYW1lTGVuZ3RoID0gZnJhbWVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZUxlbmd0aDsgaSsrKSB7XG4gICAgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgZmlsZW5hbWUgPSBmcmFtZS5maWxlbmFtZTtcblxuICAgIGlmICghXy5pc1R5cGUoZmlsZW5hbWUsICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuICFibG9jaztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpc3RMZW5ndGg7IGorKykge1xuICAgICAgdXJsID0gbGlzdFtqXTtcbiAgICAgIHVybFJlZ2V4ID0gbmV3IFJlZ0V4cCh1cmwpO1xuXG4gICAgICBpZiAodXJsUmVnZXgudGVzdChmaWxlbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdXJsSXNPbkFMaXN0KGl0ZW0sIHNldHRpbmdzLCBzYWZlT3JCbG9jaywgbG9nZ2VyKSB7XG4gIC8vIHNhZmVsaXN0IGlzIHRoZSBkZWZhdWx0XG4gIHZhciBibG9jayA9IGZhbHNlO1xuICBpZiAoc2FmZU9yQmxvY2sgPT09ICdibG9ja2xpc3QnKSB7XG4gICAgYmxvY2sgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGxpc3QsIHRyYWNlcztcbiAgdHJ5IHtcbiAgICBsaXN0ID0gYmxvY2sgPyBzZXR0aW5ncy5ob3N0QmxvY2tMaXN0IDogc2V0dGluZ3MuaG9zdFNhZmVMaXN0O1xuICAgIHRyYWNlcyA9IF8uZ2V0KGl0ZW0sICdib2R5LnRyYWNlX2NoYWluJykgfHwgW18uZ2V0KGl0ZW0sICdib2R5LnRyYWNlJyldO1xuXG4gICAgLy8gVGhlc2UgdHdvIGNoZWNrcyBhcmUgaW1wb3J0YW50IHRvIGNvbWUgZmlyc3QgYXMgdGhleSBhcmUgZGVmYXVsdHNcbiAgICAvLyBpbiBjYXNlIHRoZSBsaXN0IGlzIG1pc3Npbmcgb3IgdGhlIHRyYWNlIGlzIG1pc3Npbmcgb3Igbm90IHdlbGwtZm9ybWVkXG4gICAgaWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gIWJsb2NrO1xuICAgIH1cbiAgICBpZiAodHJhY2VzLmxlbmd0aCA9PT0gMCB8fCAhdHJhY2VzWzBdKSB7XG4gICAgICByZXR1cm4gIWJsb2NrO1xuICAgIH1cblxuICAgIHZhciB0cmFjZXNMZW5ndGggPSB0cmFjZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtYXRjaEZyYW1lcyh0cmFjZXNbaV0sIGxpc3QsIGJsb2NrKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKFxuICAgIGVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICApIHtcbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIHNldHRpbmdzLmhvc3RCbG9ja0xpc3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0aW5ncy5ob3N0U2FmZUxpc3QgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbGlzdE5hbWUgPSBibG9jayA/ICdob3N0QmxvY2tMaXN0JyA6ICdob3N0U2FmZUxpc3QnO1xuICAgIGxvZ2dlci5lcnJvcihcbiAgICAgIFwiRXJyb3Igd2hpbGUgcmVhZGluZyB5b3VyIGNvbmZpZ3VyYXRpb24ncyBcIiArXG4gICAgICAgIGxpc3ROYW1lICtcbiAgICAgICAgJyBvcHRpb24uIFJlbW92aW5nIGN1c3RvbSAnICtcbiAgICAgICAgbGlzdE5hbWUgK1xuICAgICAgICAnLicsXG4gICAgICBlLFxuICAgICk7XG4gICAgcmV0dXJuICFibG9jaztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lc3NhZ2VJc0lnbm9yZWQobG9nZ2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgaSwgaiwgaWdub3JlZE1lc3NhZ2VzLCBsZW4sIG1lc3NhZ2VJc0lnbm9yZWQsIHJJZ25vcmVkTWVzc2FnZSwgbWVzc2FnZXM7XG5cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUlzSWdub3JlZCA9IGZhbHNlO1xuICAgICAgaWdub3JlZE1lc3NhZ2VzID0gc2V0dGluZ3MuaWdub3JlZE1lc3NhZ2VzO1xuXG4gICAgICBpZiAoIWlnbm9yZWRNZXNzYWdlcyB8fCBpZ25vcmVkTWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzRnJvbUl0ZW0oaXRlbSk7XG5cbiAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxlbiA9IGlnbm9yZWRNZXNzYWdlcy5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcklnbm9yZWRNZXNzYWdlID0gbmV3IFJlZ0V4cChpZ25vcmVkTWVzc2FnZXNbaV0sICdnaScpO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBtZXNzYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG1lc3NhZ2VJc0lnbm9yZWQgPSBySWdub3JlZE1lc3NhZ2UudGVzdChtZXNzYWdlc1tqXSk7XG5cbiAgICAgICAgICBpZiAobWVzc2FnZUlzSWdub3JlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKFxuICAgICAgZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICApIHtcbiAgICAgIHNldHRpbmdzLmlnbm9yZWRNZXNzYWdlcyA9IG51bGw7XG4gICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiRXJyb3Igd2hpbGUgcmVhZGluZyB5b3VyIGNvbmZpZ3VyYXRpb24ncyBpZ25vcmVkTWVzc2FnZXMgb3B0aW9uLiBSZW1vdmluZyBjdXN0b20gaWdub3JlZE1lc3NhZ2VzLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVzc2FnZXNGcm9tSXRlbShpdGVtKSB7XG4gIHZhciBib2R5ID0gaXRlbS5ib2R5O1xuICB2YXIgbWVzc2FnZXMgPSBbXTtcblxuICAvLyBUaGUgcGF5bG9hZCBzY2hlbWEgb25seSBhbGxvd3Mgb25lIG9mIHRyYWNlX2NoYWluLCBtZXNzYWdlLCBvciB0cmFjZS5cbiAgLy8gSG93ZXZlciwgZXhpc3RpbmcgdGVzdCBjYXNlcyBhcmUgYmFzZWQgb24gaGF2aW5nIGJvdGggdHJhY2UgYW5kIG1lc3NhZ2UgcHJlc2VudC5cbiAgLy8gU28gaGVyZSB3ZSBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBjb2xsZWN0IHN0cmluZ3MgZnJvbSBhbnkgY29tYmluYXRpb24gb2YgdGhlc2Uga2V5cy5cbiAgaWYgKGJvZHkudHJhY2VfY2hhaW4pIHtcbiAgICB2YXIgdHJhY2VDaGFpbiA9IGJvZHkudHJhY2VfY2hhaW47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZUNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2UgPSB0cmFjZUNoYWluW2ldO1xuICAgICAgbWVzc2FnZXMucHVzaChfLmdldCh0cmFjZSwgJ2V4Y2VwdGlvbi5tZXNzYWdlJykpO1xuICAgIH1cbiAgfVxuICBpZiAoYm9keS50cmFjZSkge1xuICAgIG1lc3NhZ2VzLnB1c2goXy5nZXQoYm9keSwgJ3RyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlJykpO1xuICB9XG4gIGlmIChib2R5Lm1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlcy5wdXNoKF8uZ2V0KGJvZHksICdtZXNzYWdlLmJvZHknKSk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hlY2tMZXZlbDogY2hlY2tMZXZlbCxcbiAgdXNlckNoZWNrSWdub3JlOiB1c2VyQ2hlY2tJZ25vcmUsXG4gIHVybElzTm90QmxvY2tMaXN0ZWQ6IHVybElzTm90QmxvY2tMaXN0ZWQsXG4gIHVybElzU2FmZUxpc3RlZDogdXJsSXNTYWZlTGlzdGVkLFxuICBtZXNzYWdlSXNJZ25vcmVkOiBtZXNzYWdlSXNJZ25vcmVkLFxufTtcbiIsInZhciBfID0gcmVxdWlyZSgnLi91dGlsaXR5Jyk7XG5cbi8qXG4gKiBRdWV1ZSAtIGFuIG9iamVjdCB3aGljaCBoYW5kbGVzIHdoaWNoIGhhbmRsZXMgYSBxdWV1ZSBvZiBpdGVtcyB0byBiZSBzZW50IHRvIFJvbGxiYXIuXG4gKiAgIFRoaXMgb2JqZWN0IGhhbmRsZXMgcmF0ZSBsaW1pdGluZyB2aWEgYSBwYXNzZWQgaW4gcmF0ZSBsaW1pdGVyLCByZXRyaWVzIGJhc2VkIG9uIGNvbm5lY3Rpb25cbiAqICAgZXJyb3JzLCBhbmQgZmlsdGVyaW5nIG9mIGl0ZW1zIGJhc2VkIG9uIGEgc2V0IG9mIGNvbmZpZ3VyYWJsZSBwcmVkaWNhdGVzLiBUaGUgY29tbXVuaWNhdGlvbiB0b1xuICogICB0aGUgYmFja2VuZCBpcyBwZXJmb3JtZWQgdmlhIGEgZ2l2ZW4gQVBJIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcmF0ZUxpbWl0ZXIgLSBBbiBvYmplY3Qgd2hpY2ggY29uZm9ybXMgdG8gdGhlIGludGVyZmFjZVxuICogICAgcmF0ZUxpbWl0ZXIuc2hvdWxkU2VuZChpdGVtKSAtPiBib29sXG4gKiBAcGFyYW0gYXBpIC0gQW4gb2JqZWN0IHdoaWNoIGNvbmZvcm1zIHRvIHRoZSBpbnRlcmZhY2VcbiAqICAgIGFwaS5wb3N0SXRlbShwYXlsb2FkLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSlcbiAqIEBwYXJhbSBsb2dnZXIgLSBBbiBvYmplY3QgdXNlZCB0byBsb2cgdmVyYm9zZSBtZXNzYWdlcyBpZiBkZXNpcmVkXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHNlZSBRdWV1ZS5wcm90b3R5cGUuY29uZmlndXJlXG4gKiBAcGFyYW0gcmVwbGF5TWFwIC0gT3B0aW9uYWwgUmVwbGF5TWFwIGZvciBjb29yZGluYXRpbmcgc2Vzc2lvbiByZXBsYXkgd2l0aCBlcnJvciBvY2N1cnJlbmNlc1xuICovXG5mdW5jdGlvbiBRdWV1ZShyYXRlTGltaXRlciwgYXBpLCBsb2dnZXIsIG9wdGlvbnMsIHJlcGxheU1hcCkge1xuICB0aGlzLnJhdGVMaW1pdGVyID0gcmF0ZUxpbWl0ZXI7XG4gIHRoaXMuYXBpID0gYXBpO1xuICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5yZXBsYXlNYXAgPSByZXBsYXlNYXA7XG4gIHRoaXMucHJlZGljYXRlcyA9IFtdO1xuICB0aGlzLnBlbmRpbmdJdGVtcyA9IFtdO1xuICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IFtdO1xuICB0aGlzLnJldHJ5UXVldWUgPSBbXTtcbiAgdGhpcy5yZXRyeUhhbmRsZSA9IG51bGw7XG4gIHRoaXMud2FpdENhbGxiYWNrID0gbnVsbDtcbiAgdGhpcy53YWl0SW50ZXJ2YWxJRCA9IG51bGw7XG59XG5cbi8qXG4gKiBjb25maWd1cmUgLSB1cGRhdGVzIHRoZSBvcHRpb25zIHRoaXMgcXVldWUgdXNlc1xuICpcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0aGlzLmFwaSAmJiB0aGlzLmFwaS5jb25maWd1cmUob3B0aW9ucyk7XG4gIHZhciBvbGRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9sZE9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBhZGRQcmVkaWNhdGUgLSBhZGRzIGEgcHJlZGljYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgcHJlZGljYXRlcyBmb3IgdGhpcyBxdWV1ZVxuICpcbiAqIEBwYXJhbSBwcmVkaWNhdGUgLSBmdW5jdGlvbihpdGVtLCBvcHRpb25zKSAtPiAoYm9vbHx7ZXJyOiBFcnJvcn0pXG4gKiAgUmV0dXJuaW5nIHRydWUgbWVhbnMgdGhhdCB0aGlzIHByZWRpY2F0ZSBwYXNzZXMgYW5kIHRoZSBpdGVtIGlzIG9rYXkgdG8gZ28gb24gdGhlIHF1ZXVlXG4gKiAgUmV0dXJuaW5nIGZhbHNlIG1lYW5zIGRvIG5vdCBhZGQgdGhlIGl0ZW0gdG8gdGhlIHF1ZXVlLCBidXQgaXQgaXMgbm90IGFuIGVycm9yXG4gKiAgUmV0dXJuaW5nIHtlcnI6IEVycm9yfSBtZWFucyBkbyBub3QgYWRkIHRoZSBpdGVtIHRvIHRoZSBxdWV1ZSwgYW5kIHRoZSBnaXZlbiBlcnJvciBleHBsYWlucyB3aHlcbiAqICBSZXR1cm5pbmcge2VycjogdW5kZWZpbmVkfSBpcyBlcXVpdmFsZW50IHRvIHJldHVybmluZyB0cnVlIGJ1dCBkb24ndCBkbyB0aGF0XG4gKi9cblF1ZXVlLnByb3RvdHlwZS5hZGRQcmVkaWNhdGUgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIGlmIChfLmlzRnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgIHRoaXMucHJlZGljYXRlcy5wdXNoKHByZWRpY2F0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuYWRkUGVuZGluZ0l0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLnBlbmRpbmdJdGVtcy5wdXNoKGl0ZW0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLnJlbW92ZVBlbmRpbmdJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkeCA9IHRoaXMucGVuZGluZ0l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgdGhpcy5wZW5kaW5nSXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cbn07XG5cbi8qXG4gKiBhZGRJdGVtIC0gU2VuZCBhbiBpdGVtIHRvIHRoZSBSb2xsYmFyIEFQSSBpZiBhbGwgb2YgdGhlIHByZWRpY2F0ZXMgYXJlIHNhdGlzZmllZFxuICpcbiAqIEBwYXJhbSBpdGVtIC0gVGhlIHBheWxvYWQgdG8gc2VuZCB0byB0aGUgYmFja2VuZFxuICogQHBhcmFtIGNhbGxiYWNrIC0gZnVuY3Rpb24oZXJyb3IsIHJlcHNvbnNlKSB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBBUElcbiAqICBpbiB0aGUgY2FzZSBvZiBhIHN1Y2Nlc3MsIG90aGVyd2lzZSByZXNwb25zZSB3aWxsIGJlIG51bGwgYW5kIGVycm9yIHdpbGwgaGF2ZSBhIHZhbHVlLiBJZiBib3RoXG4gKiAgZXJyb3IgYW5kIHJlc3BvbnNlIGFyZSBudWxsIHRoZW4gdGhlIGl0ZW0gd2FzIHN0b3BwZWQgYnkgYSBwcmVkaWNhdGUgd2hpY2ggZGlkIG5vdCBjb25zaWRlciB0aGlzXG4gKiAgdG8gYmUgYW4gZXJyb3IgY29uZGl0aW9uLCBidXQgbm9uZXRoZWxlc3MgZGlkIG5vdCBzZW5kIHRoZSBpdGVtIHRvIHRoZSBBUEkuXG4gKiAgQHBhcmFtIG9yaWdpbmFsRXJyb3IgLSBUaGUgb3JpZ2luYWwgZXJyb3IgYmVmb3JlIGFueSB0cmFuc2Zvcm1hdGlvbnMgdGhhdCBpcyB0byBiZSBsb2dnZWQgaWYgYW55XG4gKi9cblF1ZXVlLnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKFxuICBpdGVtLFxuICBjYWxsYmFjayxcbiAgb3JpZ2luYWxFcnJvcixcbiAgb3JpZ2luYWxJdGVtLFxuKSB7XG4gIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIHZhciBwcmVkaWNhdGVSZXN1bHQgPSB0aGlzLl9hcHBseVByZWRpY2F0ZXMoaXRlbSk7XG4gIGlmIChwcmVkaWNhdGVSZXN1bHQuc3RvcCkge1xuICAgIHRoaXMucmVtb3ZlUGVuZGluZ0l0ZW0ob3JpZ2luYWxJdGVtKTtcbiAgICBjYWxsYmFjayhwcmVkaWNhdGVSZXN1bHQuZXJyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fbWF5YmVMb2coaXRlbSwgb3JpZ2luYWxFcnJvcik7XG4gIHRoaXMucmVtb3ZlUGVuZGluZ0l0ZW0ob3JpZ2luYWxJdGVtKTtcbiAgaWYgKCF0aGlzLm9wdGlvbnMudHJhbnNtaXQpIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RyYW5zbWl0IGRpc2FibGVkJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLnJlcGxheU1hcCAmJiBpdGVtLmJvZHkpIHtcbiAgICBjb25zdCByZXBsYXlJZCA9IHRoaXMucmVwbGF5TWFwLmFkZChpdGVtLnV1aWQpO1xuICAgIGl0ZW0ucmVwbGF5SWQgPSByZXBsYXlJZDtcbiAgfVxuXG4gIHRoaXMucGVuZGluZ1JlcXVlc3RzLnB1c2goaXRlbSk7XG4gIHRyeSB7XG4gICAgdGhpcy5fbWFrZUFwaVJlcXVlc3QoXG4gICAgICBpdGVtLFxuICAgICAgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuICAgICAgICB0aGlzLl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QoaXRlbSk7XG5cbiAgICAgICAgaWYgKCFlcnIgJiYgcmVzcCAmJiBpdGVtLnJlcGxheUlkKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlUmVwbGF5UmVzcG9uc2UoaXRlbS5yZXBsYXlJZCwgcmVzcCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3ApO1xuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QoaXRlbSk7XG4gICAgY2FsbGJhY2soZSk7XG4gIH1cbn07XG5cbi8qXG4gKiB3YWl0IC0gU3RvcCBhbnkgZnVydGhlciBlcnJvcnMgZnJvbSBiZWluZyBhZGRlZCB0byB0aGUgcXVldWUsIGFuZCBnZXQgY2FsbGVkIGJhY2sgd2hlbiBhbGwgaXRlbXNcbiAqICAgY3VycmVudGx5IHByb2Nlc3NpbmcgaGF2ZSBmaW5pc2hlZCBzZW5kaW5nIHRvIHRoZSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKCkgY2FsbGVkIHdoZW4gYWxsIHBlbmRpbmcgaXRlbXMgaGF2ZSBiZWVuIHNlbnRcbiAqL1xuUXVldWUucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKCFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMud2FpdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIGlmICh0aGlzLl9tYXliZUNhbGxXYWl0KCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRoaXMud2FpdEludGVydmFsSUQpIHtcbiAgICB0aGlzLndhaXRJbnRlcnZhbElEID0gY2xlYXJJbnRlcnZhbCh0aGlzLndhaXRJbnRlcnZhbElEKTtcbiAgfVxuICB0aGlzLndhaXRJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbWF5YmVDYWxsV2FpdCgpO1xuICAgIH0uYmluZCh0aGlzKSxcbiAgICA1MDAsXG4gICk7XG59O1xuXG4vKiBfYXBwbHlQcmVkaWNhdGVzIC0gU2VxdWVudGlhbGx5IGFwcGxpZXMgdGhlIHByZWRpY2F0ZXMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIHF1ZXVlIHRvIHRoZVxuICogICBnaXZlbiBpdGVtIHdpdGggdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBBbiBpdGVtIGluIHRoZSBxdWV1ZVxuICogQHJldHVybnMge3N0b3A6IGJvb2wsIGVycjogKEVycm9yfG51bGwpfSAtIHN0b3AgYmVpbmcgdHJ1ZSBtZWFucyBkbyBub3QgYWRkIGl0ZW0gdG8gdGhlIHF1ZXVlLFxuICogICB0aGUgZXJyb3IgdmFsdWUgc2hvdWxkIGJlIHBhc3NlZCB1cCB0byBhIGNhbGxiYWsgaWYgd2UgYXJlIHN0b3BwaW5nLlxuICovXG5RdWV1ZS5wcm90b3R5cGUuX2FwcGx5UHJlZGljYXRlcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBwID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucHJlZGljYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHAgPSB0aGlzLnByZWRpY2F0ZXNbaV0oaXRlbSwgdGhpcy5vcHRpb25zKTtcbiAgICBpZiAoIXAgfHwgcC5lcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgc3RvcDogdHJ1ZSwgZXJyOiBwLmVyciB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdG9wOiBmYWxzZSwgZXJyOiBudWxsIH07XG59O1xuXG4vKlxuICogX21ha2VBcGlSZXF1ZXN0IC0gU2VuZCBhbiBpdGVtIHRvIFJvbGxiYXIsIGNhbGxiYWNrIHdoZW4gZG9uZSwgaWYgdGhlcmUgaXMgYW4gZXJyb3IgbWFrZSBhblxuICogICBlZmZvcnQgdG8gcmV0cnkgaWYgd2UgYXJlIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBhbiBpdGVtIHJlYWR5IHRvIHNlbmQgdG8gdGhlIGJhY2tlbmRcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fbWFrZUFwaVJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgdmFyIHJhdGVMaW1pdFJlc3BvbnNlID0gdGhpcy5yYXRlTGltaXRlci5zaG91bGRTZW5kKGl0ZW0pO1xuICBpZiAocmF0ZUxpbWl0UmVzcG9uc2Uuc2hvdWxkU2VuZCkge1xuICAgIHRoaXMuYXBpLnBvc3RJdGVtKFxuICAgICAgaXRlbSxcbiAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuX21heWJlUmV0cnkoZXJyLCBpdGVtLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICk7XG4gIH0gZWxzZSBpZiAocmF0ZUxpbWl0UmVzcG9uc2UuZXJyb3IpIHtcbiAgICBjYWxsYmFjayhyYXRlTGltaXRSZXNwb25zZS5lcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hcGkucG9zdEl0ZW0ocmF0ZUxpbWl0UmVzcG9uc2UucGF5bG9hZCwgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyBUaGVzZSBhcmUgZXJyb3JzIGJhc2ljYWxseSBtZWFuIHRoZXJlIGlzIG5vIGludGVybmV0IGNvbm5lY3Rpb25cbnZhciBSRVRSSUFCTEVfRVJST1JTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFTk9URk9VTkQnLFxuICAnRVNPQ0tFVFRJTUVET1VUJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFQ09OTlJFRlVTRUQnLFxuICAnRUhPU1RVTlJFQUNIJyxcbiAgJ0VQSVBFJyxcbiAgJ0VBSV9BR0FJTicsXG5dO1xuXG4vKlxuICogX21heWJlUmV0cnkgLSBHaXZlbiB0aGUgZXJyb3IgcmV0dXJuZWQgYnkgdGhlIEFQSSwgZGVjaWRlIGlmIHdlIHNob3VsZCByZXRyeSBvciBqdXN0IGNhbGxiYWNrXG4gKiAgIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnIgLSBhbiBlcnJvciByZXR1cm5lZCBieSB0aGUgQVBJIHRyYW5zcG9ydFxuICogQHBhcmFtIGl0ZW0gLSB0aGUgaXRlbSB0aGF0IHdhcyB0cnlpbmcgdG8gYmUgc2VudCB3aGVuIHRoaXMgZXJyb3Igb2NjdXJlZFxuICogQHBhcmFtIGNhbGxiYWNrIC0gZnVuY3Rpb24oZXJyLCByZXNwb25zZSlcbiAqL1xuUXVldWUucHJvdG90eXBlLl9tYXliZVJldHJ5ID0gZnVuY3Rpb24gKGVyciwgaXRlbSwgY2FsbGJhY2spIHtcbiAgdmFyIHNob3VsZFJldHJ5ID0gZmFsc2U7XG4gIGlmICh0aGlzLm9wdGlvbnMucmV0cnlJbnRlcnZhbCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBSRVRSSUFCTEVfRVJST1JTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09IFJFVFJJQUJMRV9FUlJPUlNbaV0pIHtcbiAgICAgICAgc2hvdWxkUmV0cnkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFJldHJ5ICYmIF8uaXNGaW5pdGVOdW1iZXIodGhpcy5vcHRpb25zLm1heFJldHJpZXMpKSB7XG4gICAgICBpdGVtLnJldHJpZXMgPSBpdGVtLnJldHJpZXMgPyBpdGVtLnJldHJpZXMgKyAxIDogMTtcbiAgICAgIGlmIChpdGVtLnJldHJpZXMgPiB0aGlzLm9wdGlvbnMubWF4UmV0cmllcykge1xuICAgICAgICBzaG91bGRSZXRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkUmV0cnkpIHtcbiAgICB0aGlzLl9yZXRyeUFwaVJlcXVlc3QoaXRlbSwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cbn07XG5cbi8qXG4gKiBfcmV0cnlBcGlSZXF1ZXN0IC0gQWRkIGFuIGl0ZW0gYW5kIGEgY2FsbGJhY2sgdG8gYSBxdWV1ZSBhbmQgcG9zc2libHkgc3RhcnQgYSB0aW1lciB0byBwcm9jZXNzXG4gKiAgIHRoYXQgcXVldWUgYmFzZWQgb24gdGhlIHJldHJ5SW50ZXJ2YWwgaW4gdGhlIG9wdGlvbnMgZm9yIHRoaXMgcXVldWUuXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBhbiBpdGVtIHRoYXQgZmFpbGVkIHRvIHNlbmQgZHVlIHRvIGFuIGVycm9yIHdlIGRlZW0gcmV0cmlhYmxlXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKVxuICovXG5RdWV1ZS5wcm90b3R5cGUuX3JldHJ5QXBpUmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICB0aGlzLnJldHJ5UXVldWUucHVzaCh7IGl0ZW06IGl0ZW0sIGNhbGxiYWNrOiBjYWxsYmFjayB9KTtcblxuICBpZiAoIXRoaXMucmV0cnlIYW5kbGUpIHtcbiAgICB0aGlzLnJldHJ5SGFuZGxlID0gc2V0SW50ZXJ2YWwoXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJldHJ5UXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHJldHJ5T2JqZWN0ID0gdGhpcy5yZXRyeVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5fbWFrZUFwaVJlcXVlc3QocmV0cnlPYmplY3QuaXRlbSwgcmV0cnlPYmplY3QuY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICB0aGlzLm9wdGlvbnMucmV0cnlJbnRlcnZhbCxcbiAgICApO1xuICB9XG59O1xuXG4vKlxuICogX2RlcXVldWVQZW5kaW5nUmVxdWVzdCAtIFJlbW92ZXMgdGhlIGl0ZW0gZnJvbSB0aGUgcGVuZGluZyByZXF1ZXN0IHF1ZXVlLCB0aGlzIHF1ZXVlIGlzIHVzZWQgdG9cbiAqICAgZW5hYmxlIHRvIGZ1bmN0aW9uYWxpdHkgb2YgcHJvdmlkaW5nIGEgY2FsbGJhY2sgdGhhdCBjbGllbnRzIGNhbiBwYXNzIHRvIGB3YWl0YCB0byBiZSBub3RpZmllZFxuICogICB3aGVuIHRoZSBwZW5kaW5nIHJlcXVlc3QgcXVldWUgaGFzIGJlZW4gZW1wdGllZC4gVGhpcyBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSBBUEkgZmluaXNoZXNcbiAqICAgcHJvY2Vzc2luZyB0aGlzIGl0ZW0uIElmIGEgYHdhaXRgIGNhbGxiYWNrIGlzIGNvbmZpZ3VyZWQsIGl0IGlzIGNhbGxlZCBieSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBpdGVtIC0gdGhlIGl0ZW0gcHJldmlvdXNseSBhZGRlZCB0byB0aGUgcGVuZGluZyByZXF1ZXN0IHF1ZXVlXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5fZGVxdWV1ZVBlbmRpbmdSZXF1ZXN0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkeCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmluZGV4T2YoaXRlbSk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbWF5YmVDYWxsV2FpdCgpO1xuICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX21heWJlTG9nID0gZnVuY3Rpb24gKGRhdGEsIG9yaWdpbmFsRXJyb3IpIHtcbiAgaWYgKHRoaXMubG9nZ2VyICYmIHRoaXMub3B0aW9ucy52ZXJib3NlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBvcmlnaW5hbEVycm9yO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IF8uZ2V0KGRhdGEsICdib2R5LnRyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlJyk7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgXy5nZXQoZGF0YSwgJ2JvZHkudHJhY2VfY2hhaW4uMC5leGNlcHRpb24ubWVzc2FnZScpO1xuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWVzc2FnZSA9IF8uZ2V0KGRhdGEsICdib2R5Lm1lc3NhZ2UuYm9keScpO1xuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2cobWVzc2FnZSk7XG4gICAgfVxuICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX21heWJlQ2FsbFdhaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChcbiAgICBfLmlzRnVuY3Rpb24odGhpcy53YWl0Q2FsbGJhY2spICYmXG4gICAgdGhpcy5wZW5kaW5nSXRlbXMubGVuZ3RoID09PSAwICYmXG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMubGVuZ3RoID09PSAwXG4gICkge1xuICAgIGlmICh0aGlzLndhaXRJbnRlcnZhbElEKSB7XG4gICAgICB0aGlzLndhaXRJbnRlcnZhbElEID0gY2xlYXJJbnRlcnZhbCh0aGlzLndhaXRJbnRlcnZhbElEKTtcbiAgICB9XG4gICAgdGhpcy53YWl0Q2FsbGJhY2soKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIEFQSSByZXNwb25zZSBmb3IgYW4gaXRlbSB3aXRoIGEgcmVwbGF5IElELlxuICogQmFzZWQgb24gdGhlIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBzdGF0dXMgb2YgdGhlIHJlc3BvbnNlLFxuICogaXQgZWl0aGVyIHNlbmRzIG9yIGRpc2NhcmRzIHRoZSBhc3NvY2lhdGVkIHNlc3Npb24gcmVwbGF5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYXlJZCAtIFRoZSBJRCBvZiB0aGUgcmVwbGF5IHRvIGhhbmRsZVxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gVGhlIEFQSSByZXNwb25zZVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgcmVwbGF5IHdhcyBzZW50IHN1Y2Nlc3NmdWxseSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBpZiByZXBsYXkgd2FzIGRpc2NhcmRlZCBvciBhbiBlcnJvciBvY2N1cnJlZFxuICogQHByaXZhdGVcbiAqL1xuUXVldWUucHJvdG90eXBlLl9oYW5kbGVSZXBsYXlSZXNwb25zZSA9IGFzeW5jIGZ1bmN0aW9uIChyZXBsYXlJZCwgcmVzcG9uc2UpIHtcbiAgaWYgKCF0aGlzLnJlcGxheU1hcCkge1xuICAgIGNvbnNvbGUud2FybignUXVldWUuX2hhbmRsZVJlcGxheVJlc3BvbnNlOiBSZXBsYXlNYXAgbm90IGF2YWlsYWJsZScpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghcmVwbGF5SWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1F1ZXVlLl9oYW5kbGVSZXBsYXlSZXNwb25zZTogTm8gcmVwbGF5SWQgcHJvdmlkZWQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFN1Y2Nlc3MgY29uZGl0aW9uIG1pZ2h0IG5lZWQgYWRqdXN0bWVudCBiYXNlZCBvbiBBUEkgcmVzcG9uc2Ugc3RydWN0dXJlXG4gICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmVyciA9PT0gMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXBsYXlNYXAuc2VuZChyZXBsYXlJZCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlcGxheU1hcC5kaXNjYXJkKHJlcGxheUlkKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcgcmVwbGF5IHJlc3BvbnNlOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xuXG4vKlxuICogUmF0ZUxpbWl0ZXIgLSBhbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIGZvciBjb3VudGluZyBpdGVtcyBzZW50IHRvIFJvbGxiYXJcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBzYW1lIG9wdGlvbnMgdGhhdCBhcmUgYWNjZXB0ZWQgYnkgY29uZmlndXJlR2xvYmFsIG9mZmVyZWQgYXMgYSBjb252ZW5pZW5jZVxuICovXG5mdW5jdGlvbiBSYXRlTGltaXRlcihvcHRpb25zKSB7XG4gIHRoaXMuc3RhcnRUaW1lID0gXy5ub3coKTtcbiAgdGhpcy5jb3VudGVyID0gMDtcbiAgdGhpcy5wZXJNaW5Db3VudGVyID0gMDtcbiAgdGhpcy5wbGF0Zm9ybSA9IG51bGw7XG4gIHRoaXMucGxhdGZvcm1PcHRpb25zID0ge307XG4gIHRoaXMuY29uZmlndXJlR2xvYmFsKG9wdGlvbnMpO1xufVxuXG5SYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncyA9IHtcbiAgc3RhcnRUaW1lOiBfLm5vdygpLFxuICBtYXhJdGVtczogdW5kZWZpbmVkLFxuICBpdGVtc1Blck1pbnV0ZTogdW5kZWZpbmVkLFxufTtcblxuLypcbiAqIGNvbmZpZ3VyZUdsb2JhbCAtIHNldCB0aGUgZ2xvYmFsIHJhdGUgbGltaXRlciBvcHRpb25zXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPbmx5IHRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSByZWNvZ25pemVkOlxuICogICAgc3RhcnRUaW1lOiBhIHRpbWVzdGFtcCBvZiB0aGUgZm9ybSByZXR1cm5lZCBieSAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG4gKiAgICBtYXhJdGVtczogdGhlIG1heGltdW0gaXRlbXNcbiAqICAgIGl0ZW1zUGVyTWludXRlOiB0aGUgbWF4IG51bWJlciBvZiBpdGVtcyB0byBzZW5kIGluIGEgZ2l2ZW4gbWludXRlXG4gKi9cblJhdGVMaW1pdGVyLnByb3RvdHlwZS5jb25maWd1cmVHbG9iYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzLnN0YXJ0VGltZSA9IG9wdGlvbnMuc3RhcnRUaW1lO1xuICB9XG4gIGlmIChvcHRpb25zLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5tYXhJdGVtcyA9IG9wdGlvbnMubWF4SXRlbXM7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaXRlbXNQZXJNaW51dGUgIT09IHVuZGVmaW5lZCkge1xuICAgIFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzLml0ZW1zUGVyTWludXRlID0gb3B0aW9ucy5pdGVtc1Blck1pbnV0ZTtcbiAgfVxufTtcblxuLypcbiAqIHNob3VsZFNlbmQgLSBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHNlbmQgYSBnaXZlbiBpdGVtIGJhc2VkIG9uIHJhdGUgbGltaXQgc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIHdlIGFyZSBhYm91dCB0byBzZW5kXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqICBlcnJvcjogKEVycm9yfG51bGwpXG4gKiAgc2hvdWxkU2VuZDogYm9vbFxuICogIHBheWxvYWQ6IChPYmplY3R8bnVsbClcbiAqICBJZiBzaG91bGRTZW5kIGlzIGZhbHNlLCB0aGUgaXRlbSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgc2hvdWxkIG5vdCBiZSBzZW50IHRvIFJvbGxiYXIsIGFuZFxuICogIGV4YWN0bHkgb25lIG9mIGVycm9yIG9yIHBheWxvYWQgd2lsbCBiZSBub24tbnVsbC4gSWYgZXJyb3IgaXMgbm9uLW51bGwsIHRoZSByZXR1cm5lZCBFcnJvciB3aWxsXG4gKiAgZGVzY3JpYmUgdGhlIHNpdHVhdGlvbiwgYnV0IGl0IG1lYW5zIHRoYXQgd2Ugd2VyZSBhbHJlYWR5IG92ZXIgYSByYXRlIGxpbWl0IChlaXRoZXIgZ2xvYmFsbHkgb3JcbiAqICBwZXIgbWludXRlKSB3aGVuIHRoaXMgaXRlbSB3YXMgY2hlY2tlZC4gSWYgZXJyb3IgaXMgbnVsbCwgYW5kIHRoZXJlZm9yZSBwYXlsb2FkIGlzIG5vbi1udWxsLCBpdFxuICogIG1lYW5zIHRoaXMgaXRlbSBwdXQgdXMgb3ZlciB0aGUgZ2xvYmFsIHJhdGUgbGltaXQgYW5kIHRoZSBwYXlsb2FkIHNob3VsZCBiZSBzZW50IHRvIFJvbGxiYXIgaW5cbiAqICBwbGFjZSBvZiB0aGUgcGFzc2VkIGluIGl0ZW0uXG4gKi9cblJhdGVMaW1pdGVyLnByb3RvdHlwZS5zaG91bGRTZW5kID0gZnVuY3Rpb24gKGl0ZW0sIG5vdykge1xuICBub3cgPSBub3cgfHwgXy5ub3coKTtcbiAgdmFyIGVsYXBzZWRUaW1lID0gbm93IC0gdGhpcy5zdGFydFRpbWU7XG4gIGlmIChlbGFwc2VkVGltZSA8IDAgfHwgZWxhcHNlZFRpbWUgPj0gNjAwMDApIHtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG5vdztcbiAgICB0aGlzLnBlck1pbkNvdW50ZXIgPSAwO1xuICB9XG5cbiAgdmFyIGdsb2JhbFJhdGVMaW1pdCA9IFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzLm1heEl0ZW1zO1xuICB2YXIgZ2xvYmFsUmF0ZUxpbWl0UGVyTWluID0gUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3MuaXRlbXNQZXJNaW51dGU7XG5cbiAgaWYgKGNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXQsIHRoaXMuY291bnRlcikpIHtcbiAgICByZXR1cm4gc2hvdWxkU2VuZFZhbHVlKFxuICAgICAgdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHRoaXMucGxhdGZvcm1PcHRpb25zLFxuICAgICAgZ2xvYmFsUmF0ZUxpbWl0ICsgJyBtYXggaXRlbXMgcmVhY2hlZCcsXG4gICAgICBmYWxzZSxcbiAgICApO1xuICB9IGVsc2UgaWYgKGNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXRQZXJNaW4sIHRoaXMucGVyTWluQ291bnRlcikpIHtcbiAgICByZXR1cm4gc2hvdWxkU2VuZFZhbHVlKFxuICAgICAgdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHRoaXMucGxhdGZvcm1PcHRpb25zLFxuICAgICAgZ2xvYmFsUmF0ZUxpbWl0UGVyTWluICsgJyBpdGVtcyBwZXIgbWludXRlIHJlYWNoZWQnLFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgfVxuICB0aGlzLmNvdW50ZXIrKztcbiAgdGhpcy5wZXJNaW5Db3VudGVyKys7XG5cbiAgdmFyIHNob3VsZFNlbmQgPSAhY2hlY2tSYXRlKGl0ZW0sIGdsb2JhbFJhdGVMaW1pdCwgdGhpcy5jb3VudGVyKTtcbiAgdmFyIHBlck1pbnV0ZSA9IHNob3VsZFNlbmQ7XG4gIHNob3VsZFNlbmQgPVxuICAgIHNob3VsZFNlbmQgJiYgIWNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXRQZXJNaW4sIHRoaXMucGVyTWluQ291bnRlcik7XG4gIHJldHVybiBzaG91bGRTZW5kVmFsdWUoXG4gICAgdGhpcy5wbGF0Zm9ybSxcbiAgICB0aGlzLnBsYXRmb3JtT3B0aW9ucyxcbiAgICBudWxsLFxuICAgIHNob3VsZFNlbmQsXG4gICAgZ2xvYmFsUmF0ZUxpbWl0LFxuICAgIGdsb2JhbFJhdGVMaW1pdFBlck1pbixcbiAgICBwZXJNaW51dGUsXG4gICk7XG59O1xuXG5SYXRlTGltaXRlci5wcm90b3R5cGUuc2V0UGxhdGZvcm1PcHRpb25zID0gZnVuY3Rpb24gKHBsYXRmb3JtLCBvcHRpb25zKSB7XG4gIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgdGhpcy5wbGF0Zm9ybU9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuLyogSGVscGVycyAqL1xuXG5mdW5jdGlvbiBjaGVja1JhdGUoaXRlbSwgbGltaXQsIGNvdW50ZXIpIHtcbiAgcmV0dXJuICFpdGVtLmlnbm9yZVJhdGVMaW1pdCAmJiBsaW1pdCA+PSAxICYmIGNvdW50ZXIgPiBsaW1pdDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2VuZFZhbHVlKFxuICBwbGF0Zm9ybSxcbiAgb3B0aW9ucyxcbiAgZXJyb3IsXG4gIHNob3VsZFNlbmQsXG4gIGdsb2JhbFJhdGVMaW1pdCxcbiAgbGltaXRQZXJNaW4sXG4gIHBlck1pbnV0ZSxcbikge1xuICB2YXIgcGF5bG9hZCA9IG51bGw7XG4gIGlmIChlcnJvcikge1xuICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcbiAgfVxuICBpZiAoIWVycm9yICYmICFzaG91bGRTZW5kKSB7XG4gICAgcGF5bG9hZCA9IHJhdGVMaW1pdFBheWxvYWQoXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBnbG9iYWxSYXRlTGltaXQsXG4gICAgICBsaW1pdFBlck1pbixcbiAgICAgIHBlck1pbnV0ZSxcbiAgICApO1xuICB9XG4gIHJldHVybiB7IGVycm9yOiBlcnJvciwgc2hvdWxkU2VuZDogc2hvdWxkU2VuZCwgcGF5bG9hZDogcGF5bG9hZCB9O1xufVxuXG5mdW5jdGlvbiByYXRlTGltaXRQYXlsb2FkKFxuICBwbGF0Zm9ybSxcbiAgb3B0aW9ucyxcbiAgZ2xvYmFsUmF0ZUxpbWl0LFxuICBsaW1pdFBlck1pbixcbiAgcGVyTWludXRlLFxuKSB7XG4gIHZhciBlbnZpcm9ubWVudCA9XG4gICAgb3B0aW9ucy5lbnZpcm9ubWVudCB8fCAob3B0aW9ucy5wYXlsb2FkICYmIG9wdGlvbnMucGF5bG9hZC5lbnZpcm9ubWVudCk7XG4gIHZhciBtc2c7XG4gIGlmIChwZXJNaW51dGUpIHtcbiAgICBtc2cgPSAnaXRlbSBwZXIgbWludXRlIGxpbWl0IHJlYWNoZWQsIGlnbm9yaW5nIGVycm9ycyB1bnRpbCB0aW1lb3V0JztcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSAnbWF4SXRlbXMgaGFzIGJlZW4gaGl0LCBpZ25vcmluZyBlcnJvcnMgdW50aWwgcmVzZXQuJztcbiAgfVxuICB2YXIgaXRlbSA9IHtcbiAgICBib2R5OiB7XG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgIGJvZHk6IG1zZyxcbiAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICBtYXhJdGVtczogZ2xvYmFsUmF0ZUxpbWl0LFxuICAgICAgICAgIGl0ZW1zUGVyTWludXRlOiBsaW1pdFBlck1pbixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBsYW5ndWFnZTogJ2phdmFzY3JpcHQnLFxuICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICBub3RpZmllcjoge1xuICAgICAgdmVyc2lvbjpcbiAgICAgICAgKG9wdGlvbnMubm90aWZpZXIgJiYgb3B0aW9ucy5ub3RpZmllci52ZXJzaW9uKSB8fCBvcHRpb25zLnZlcnNpb24sXG4gICAgfSxcbiAgfTtcbiAgaWYgKHBsYXRmb3JtID09PSAnYnJvd3NlcicpIHtcbiAgICBpdGVtLnBsYXRmb3JtID0gJ2Jyb3dzZXInO1xuICAgIGl0ZW0uZnJhbWV3b3JrID0gJ2Jyb3dzZXItanMnO1xuICAgIGl0ZW0ubm90aWZpZXIubmFtZSA9ICdyb2xsYmFyLWJyb3dzZXItanMnO1xuICB9IGVsc2UgaWYgKHBsYXRmb3JtID09PSAnc2VydmVyJykge1xuICAgIGl0ZW0uZnJhbWV3b3JrID0gb3B0aW9ucy5mcmFtZXdvcmsgfHwgJ25vZGUtanMnO1xuICAgIGl0ZW0ubm90aWZpZXIubmFtZSA9IG9wdGlvbnMubm90aWZpZXIubmFtZTtcbiAgfSBlbHNlIGlmIChwbGF0Zm9ybSA9PT0gJ3JlYWN0LW5hdGl2ZScpIHtcbiAgICBpdGVtLmZyYW1ld29yayA9IG9wdGlvbnMuZnJhbWV3b3JrIHx8ICdyZWFjdC1uYXRpdmUnO1xuICAgIGl0ZW0ubm90aWZpZXIubmFtZSA9IG9wdGlvbnMubm90aWZpZXIubmFtZTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYXRlTGltaXRlcjtcbiIsImNvbnN0IFJhdGVMaW1pdGVyID0gcmVxdWlyZSgnLi9yYXRlTGltaXRlcicpO1xuY29uc3QgUXVldWUgPSByZXF1aXJlKCcuL3F1ZXVlJyk7XG5jb25zdCBOb3RpZmllciA9IHJlcXVpcmUoJy4vbm90aWZpZXInKTtcbmNvbnN0IF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuLypcbiAqIFJvbGxiYXIgLSB0aGUgaW50ZXJmYWNlIHRvIFJvbGxiYXJcbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGFwaVxuICogQHBhcmFtIGxvZ2dlclxuICovXG5mdW5jdGlvbiBSb2xsYmFyKG9wdGlvbnMsIGFwaSwgbG9nZ2VyLCB0ZWxlbWV0ZXIsIHRyYWNpbmcsIHJlcGxheU1hcCwgcGxhdGZvcm0pIHtcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvcHRpb25zKTtcbiAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIFJvbGxiYXIucmF0ZUxpbWl0ZXIuY29uZmlndXJlR2xvYmFsKHRoaXMub3B0aW9ucyk7XG4gIFJvbGxiYXIucmF0ZUxpbWl0ZXIuc2V0UGxhdGZvcm1PcHRpb25zKHBsYXRmb3JtLCB0aGlzLm9wdGlvbnMpO1xuICB0aGlzLmFwaSA9IGFwaTtcbiAgdGhpcy5xdWV1ZSA9IG5ldyBRdWV1ZShSb2xsYmFyLnJhdGVMaW1pdGVyLCBhcGksIGxvZ2dlciwgdGhpcy5vcHRpb25zLCByZXBsYXlNYXApO1xuXG4gIHRoaXMudHJhY2luZyA9IHRyYWNpbmc7XG5cbiAgLy8gTGVnYWN5IE9wZW5UcmFjaW5nIHN1cHBvcnRcbiAgLy8gVGhpcyBtdXN0IGhhcHBlbiBiZWZvcmUgdGhlIE5vdGlmaWVyIGlzIGNyZWF0ZWRcbiAgdmFyIHRyYWNlciA9IHRoaXMub3B0aW9ucy50cmFjZXIgfHwgbnVsbDtcbiAgaWYgKHZhbGlkYXRlVHJhY2VyKHRyYWNlcikpIHtcbiAgICB0aGlzLnRyYWNlciA9IHRyYWNlcjtcbiAgICAvLyBzZXQgdG8gYSBzdHJpbmcgZm9yIGFwaSByZXNwb25zZSBzZXJpYWxpemF0aW9uXG4gICAgdGhpcy5vcHRpb25zLnRyYWNlciA9ICdvcGVudHJhY2luZy10cmFjZXItZW5hYmxlZCc7XG4gICAgdGhpcy5vcHRpb25zLl9jb25maWd1cmVkT3B0aW9ucy50cmFjZXIgPSAnb3BlbnRyYWNpbmctdHJhY2VyLWVuYWJsZWQnO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudHJhY2VyID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMubm90aWZpZXIgPSBuZXcgTm90aWZpZXIodGhpcy5xdWV1ZSwgdGhpcy5vcHRpb25zKTtcbiAgdGhpcy50ZWxlbWV0ZXIgPSB0ZWxlbWV0ZXI7XG4gIHNldFN0YWNrVHJhY2VMaW1pdChvcHRpb25zKTtcbiAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xuICB0aGlzLmxhc3RFcnJvckhhc2ggPSAnbm9uZSc7XG59XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbWF4SXRlbXM6IDAsXG4gIGl0ZW1zUGVyTWludXRlOiA2MCxcbn07XG5cblJvbGxiYXIucmF0ZUxpbWl0ZXIgPSBuZXcgUmF0ZUxpbWl0ZXIoZGVmYXVsdE9wdGlvbnMpO1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBSb2xsYmFyLnJhdGVMaW1pdGVyLmNvbmZpZ3VyZUdsb2JhbChvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGF5bG9hZERhdGEpIHtcbiAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBwYXlsb2FkID0ge307XG4gIGlmIChwYXlsb2FkRGF0YSkge1xuICAgIHBheWxvYWQgPSB7IHBheWxvYWQ6IHBheWxvYWREYXRhIH07XG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBfLm1lcmdlKG9sZE9wdGlvbnMsIG9wdGlvbnMsIHBheWxvYWQpO1xuXG4gIC8vIExlZ2FjeSBPcGVuVHJhY2luZyBzdXBwb3J0XG4gIC8vIFRoaXMgbXVzdCBoYXBwZW4gYmVmb3JlIHRoZSBOb3RpZmllciBpcyBjb25maWd1cmVkXG4gIHZhciB0cmFjZXIgPSB0aGlzLm9wdGlvbnMudHJhY2VyIHx8IG51bGw7XG4gIGlmICh2YWxpZGF0ZVRyYWNlcih0cmFjZXIpKSB7XG4gICAgdGhpcy50cmFjZXIgPSB0cmFjZXI7XG4gICAgLy8gc2V0IHRvIGEgc3RyaW5nIGZvciBhcGkgcmVzcG9uc2Ugc2VyaWFsaXphdGlvblxuICAgIHRoaXMub3B0aW9ucy50cmFjZXIgPSAnb3BlbnRyYWNpbmctdHJhY2VyLWVuYWJsZWQnO1xuICAgIHRoaXMub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMudHJhY2VyID0gJ29wZW50cmFjaW5nLXRyYWNlci1lbmFibGVkJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYWNlciA9IG51bGw7XG4gIH1cblxuICB0aGlzLm5vdGlmaWVyICYmIHRoaXMubm90aWZpZXIuY29uZmlndXJlKHRoaXMub3B0aW9ucyk7XG4gIHRoaXMudGVsZW1ldGVyICYmIHRoaXMudGVsZW1ldGVyLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMpO1xuICBzZXRTdGFja1RyYWNlTGltaXQob3B0aW9ucyk7XG4gIHRoaXMuZ2xvYmFsKHRoaXMub3B0aW9ucyk7XG5cbiAgaWYgKHZhbGlkYXRlVHJhY2VyKG9wdGlvbnMudHJhY2VyKSkge1xuICAgIHRoaXMudHJhY2VyID0gb3B0aW9ucy50cmFjZXI7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2RlZmF1bHRMb2dMZXZlbCgpO1xuICByZXR1cm4gdGhpcy5fbG9nKGxldmVsLCBpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdGhpcy5fbG9nKCdkZWJ1ZycsIGl0ZW0pO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHRoaXMuX2xvZygnaW5mbycsIGl0ZW0pO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHRoaXMuX2xvZygnd2FybmluZycsIGl0ZW0pO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHRoaXMuX2xvZygnd2FybmluZycsIGl0ZW0pO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB0aGlzLl9sb2coJ2Vycm9yJywgaXRlbSk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5jcml0aWNhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHRoaXMuX2xvZygnY3JpdGljYWwnLCBpdGVtKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy5xdWV1ZS53YWl0KGNhbGxiYWNrKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmNhcHR1cmVFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwpIHtcbiAgcmV0dXJuIHRoaXMudGVsZW1ldGVyICYmIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVFdmVudCh0eXBlLCBtZXRhZGF0YSwgbGV2ZWwpO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuY2FwdHVyZURvbUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAodHMpIHtcbiAgcmV0dXJuIHRoaXMudGVsZW1ldGVyICYmIHRoaXMudGVsZW1ldGVyLmNhcHR1cmVEb21Db250ZW50TG9hZGVkKHRzKTtcbn07XG5cblJvbGxiYXIucHJvdG90eXBlLmNhcHR1cmVMb2FkID0gZnVuY3Rpb24gKHRzKSB7XG4gIHJldHVybiB0aGlzLnRlbGVtZXRlciAmJiB0aGlzLnRlbGVtZXRlci5jYXB0dXJlTG9hZCh0cyk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5idWlsZEpzb25QYXlsb2FkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgcmV0dXJuIHRoaXMuYXBpLmJ1aWxkSnNvblBheWxvYWQoaXRlbSk7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5zZW5kSnNvblBheWxvYWQgPSBmdW5jdGlvbiAoanNvblBheWxvYWQpIHtcbiAgdGhpcy5hcGkucG9zdEpzb25QYXlsb2FkKGpzb25QYXlsb2FkKTtcbn07XG5cbi8qIEludGVybmFsICovXG5cblJvbGxiYXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAoZGVmYXVsdExldmVsLCBpdGVtKSB7XG4gIHZhciBjYWxsYmFjaztcbiAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGl0ZW0uY2FsbGJhY2s7XG4gICAgZGVsZXRlIGl0ZW0uY2FsbGJhY2s7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVFcnJvcnMgJiYgdGhpcy5fc2FtZUFzTGFzdEVycm9yKGl0ZW0pKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ2lnbm9yZWQgaWRlbnRpY2FsIGl0ZW0nKTtcbiAgICAgIGVycm9yLml0ZW0gPSBpdGVtO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICB0aGlzLl9hZGRUcmFjaW5nQXR0cmlidXRlcyhpdGVtKTtcblxuICAgIC8vIExlZ2FjeSBPcGVuVHJhY2luZyBzdXBwb3J0XG4gICAgdGhpcy5fYWRkVHJhY2luZ0luZm8oaXRlbSk7XG5cbiAgICBpdGVtLmxldmVsID0gaXRlbS5sZXZlbCB8fCBkZWZhdWx0TGV2ZWw7XG5cblxuICAgIGNvbnN0IHRlbGVtZXRlciA9IHRoaXMudGVsZW1ldGVyO1xuICAgIGlmICh0ZWxlbWV0ZXIpIHtcbiAgICAgIHRlbGVtZXRlci5fY2FwdHVyZVJvbGxiYXJJdGVtKGl0ZW0pO1xuICAgICAgaXRlbS50ZWxlbWV0cnlFdmVudHMgPSB0ZWxlbWV0ZXIuY29weUV2ZW50cygpIHx8IFtdO1xuXG4gICAgICBpZiAodGVsZW1ldGVyLnRlbGVtZXRyeVNwYW4pIHtcbiAgICAgICAgdGVsZW1ldGVyLnRlbGVtZXRyeVNwYW4uZW5kKCk7XG4gICAgICAgIHRlbGVtZXRlci50ZWxlbWV0cnlTcGFuID0gdGVsZW1ldGVyLnRyYWNpbmcuc3RhcnRTcGFuKCdyb2xsYmFyLXRlbGVtZXRyeScsIHt9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmaWVyLmxvZyhpdGVtLCBjYWxsYmFjayk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgfVxufTtcblxuUm9sbGJhci5wcm90b3R5cGUuX2FkZFRyYWNpbmdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgY29uc3Qgc3BhbiA9IHRoaXMudHJhY2luZz8uZ2V0U3BhbigpO1xuICBpZiAoIXNwYW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlcyA9IFtcbiAgICB7a2V5OiAnc2Vzc2lvbl9pZCcsIHZhbHVlOiB0aGlzLnRyYWNpbmcuc2Vzc2lvbklkfSxcbiAgICB7a2V5OiAnc3Bhbl9pZCcsIHZhbHVlOiBzcGFuLnNwYW5JZH0sXG4gICAge2tleTogJ3RyYWNlX2lkJywgdmFsdWU6IHNwYW4udHJhY2VJZH0sXG4gIF07XG4gIF8uYWRkSXRlbUF0dHJpYnV0ZXMoaXRlbSwgYXR0cmlidXRlcyk7XG5cbiAgc3Bhbi5hZGRFdmVudChcbiAgICAncm9sbGJhci5vY2N1cnJlbmNlJyxcbiAgICBbe2tleTogJ3JvbGxiYXIub2NjdXJyZW5jZS51dWlkJywgdmFsdWU6IGl0ZW0udXVpZH1dLFxuICApO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuX2RlZmF1bHRMb2dMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5sb2dMZXZlbCB8fCAnZGVidWcnO1xufTtcblxuUm9sbGJhci5wcm90b3R5cGUuX3NhbWVBc0xhc3RFcnJvciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIGlmICghaXRlbS5faXNVbmNhdWdodCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXRlbUhhc2ggPSBnZW5lcmF0ZUl0ZW1IYXNoKGl0ZW0pO1xuICBpZiAodGhpcy5sYXN0RXJyb3JIYXNoID09PSBpdGVtSGFzaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRoaXMubGFzdEVycm9yID0gaXRlbS5lcnI7XG4gIHRoaXMubGFzdEVycm9ySGFzaCA9IGl0ZW1IYXNoO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Sb2xsYmFyLnByb3RvdHlwZS5fYWRkVHJhY2luZ0luZm8gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAvLyBUcmFjZXIgdmFsaWRhdGlvbiBvY2N1cnMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGluIHRoZSBSb2xsYmFyLnByb3RvdHlwZS5jb25maWd1cmUgbWV0aG9kc1xuICBpZiAodGhpcy50cmFjZXIpIHtcbiAgICAvLyBhZGQgcm9sbGJhciBvY2N1cnJlbmNlIHV1aWQgdG8gc3BhblxuICAgIHZhciBzcGFuID0gdGhpcy50cmFjZXIuc2NvcGUoKS5hY3RpdmUoKTtcblxuICAgIGlmICh2YWxpZGF0ZVNwYW4oc3BhbikpIHtcbiAgICAgIHNwYW4uc2V0VGFnKCdyb2xsYmFyLmVycm9yX3V1aWQnLCBpdGVtLnV1aWQpO1xuICAgICAgc3Bhbi5zZXRUYWcoJ3JvbGxiYXIuaGFzX2Vycm9yJywgdHJ1ZSk7XG4gICAgICBzcGFuLnNldFRhZygnZXJyb3InLCB0cnVlKTtcbiAgICAgIHNwYW4uc2V0VGFnKFxuICAgICAgICAncm9sbGJhci5pdGVtX3VybCcsXG4gICAgICAgIGBodHRwczovL3JvbGxiYXIuY29tL2l0ZW0vdXVpZC8/dXVpZD0ke2l0ZW0udXVpZH1gLFxuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0VGFnKFxuICAgICAgICAncm9sbGJhci5vY2N1cnJlbmNlX3VybCcsXG4gICAgICAgIGBodHRwczovL3JvbGxiYXIuY29tL29jY3VycmVuY2UvdXVpZC8/dXVpZD0ke2l0ZW0udXVpZH1gLFxuICAgICAgKTtcblxuICAgICAgLy8gYWRkIHNwYW4gSUQgJiB0cmFjZSBJRCB0byBvY2N1cnJlbmNlXG4gICAgICB2YXIgb3BlbnRyYWNpbmdTcGFuSWQgPSBzcGFuLmNvbnRleHQoKS50b1NwYW5JZCgpO1xuICAgICAgdmFyIG9wZW50cmFjaW5nVHJhY2VJZCA9IHNwYW4uY29udGV4dCgpLnRvVHJhY2VJZCgpO1xuXG4gICAgICBpZiAoaXRlbS5jdXN0b20pIHtcbiAgICAgICAgaXRlbS5jdXN0b20ub3BlbnRyYWNpbmdfc3Bhbl9pZCA9IG9wZW50cmFjaW5nU3BhbklkO1xuICAgICAgICBpdGVtLmN1c3RvbS5vcGVudHJhY2luZ190cmFjZV9pZCA9IG9wZW50cmFjaW5nVHJhY2VJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0uY3VzdG9tID0ge1xuICAgICAgICAgIG9wZW50cmFjaW5nX3NwYW5faWQ6IG9wZW50cmFjaW5nU3BhbklkLFxuICAgICAgICAgIG9wZW50cmFjaW5nX3RyYWNlX2lkOiBvcGVudHJhY2luZ1RyYWNlSWQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUl0ZW1IYXNoKGl0ZW0pIHtcbiAgdmFyIG1lc3NhZ2UgPSBpdGVtLm1lc3NhZ2UgfHwgJyc7XG4gIHZhciBzdGFjayA9IChpdGVtLmVyciB8fCB7fSkuc3RhY2sgfHwgU3RyaW5nKGl0ZW0uZXJyKTtcbiAgcmV0dXJuIG1lc3NhZ2UgKyAnOjonICsgc3RhY2s7XG59XG5cbi8vIE5vZGUuanMsIENocm9tZSwgU2FmYXJpLCBhbmQgc29tZSBvdGhlciBicm93c2VycyBzdXBwb3J0IHRoaXMgcHJvcGVydHlcbi8vIHdoaWNoIGdsb2JhbGx5IHNldHMgdGhlIG51bWJlciBvZiBzdGFjayBmcmFtZXMgcmV0dXJuZWQgaW4gYW4gRXJyb3Igb2JqZWN0LlxuLy8gSWYgYSBicm93c2VyIGNhbid0IHVzZSBpdCwgbm8gaGFybSBkb25lLlxuZnVuY3Rpb24gc2V0U3RhY2tUcmFjZUxpbWl0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RhY2tUcmFjZUxpbWl0KSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gb3B0aW9ucy5zdGFja1RyYWNlTGltaXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgVHJhY2VyIG9iamVjdCBwcm92aWRlZCB0byB0aGUgQ2xpZW50XG4gKiBpcyB2YWxpZCBmb3Igb3VyIE9wZW50cmFjaW5nIHVzZSBjYXNlLlxuICogQHBhcmFtIHtvcGVudHJhY2VyLlRyYWNlcn0gdHJhY2VyXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHJhY2VyKHRyYWNlcikge1xuICBpZiAoIXRyYWNlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghdHJhY2VyLnNjb3BlIHx8IHR5cGVvZiB0cmFjZXIuc2NvcGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc2NvcGUgPSB0cmFjZXIuc2NvcGUoKTtcblxuICBpZiAoIXNjb3BlIHx8ICFzY29wZS5hY3RpdmUgfHwgdHlwZW9mIHNjb3BlLmFjdGl2ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBTcGFuIG9iamVjdCBwcm92aWRlZFxuICogQHBhcmFtIHtvcGVudHJhY2VyLlNwYW59IHNwYW5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTcGFuKHNwYW4pIHtcbiAgaWYgKCFzcGFuIHx8ICFzcGFuLmNvbnRleHQgfHwgdHlwZW9mIHNwYW4uY29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzcGFuQ29udGV4dCA9IHNwYW4uY29udGV4dCgpO1xuXG4gIGlmIChcbiAgICAhc3BhbkNvbnRleHQgfHxcbiAgICAhc3BhbkNvbnRleHQudG9TcGFuSWQgfHxcbiAgICAhc3BhbkNvbnRleHQudG9UcmFjZUlkIHx8XG4gICAgdHlwZW9mIHNwYW5Db250ZXh0LnRvU3BhbklkICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIHNwYW5Db250ZXh0LnRvVHJhY2VJZCAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSb2xsYmFyO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcbnZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoJy4vdXRpbGl0eS90cmF2ZXJzZScpO1xuXG5mdW5jdGlvbiBzY3J1YihkYXRhLCBzY3J1YkZpZWxkcywgc2NydWJQYXRocykge1xuICBzY3J1YkZpZWxkcyA9IHNjcnViRmllbGRzIHx8IFtdO1xuXG4gIGlmIChzY3J1YlBhdGhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3J1YlBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzY3J1YlBhdGgoZGF0YSwgc2NydWJQYXRoc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcmFtUmVzID0gX2dldFNjcnViRmllbGRSZWdleHMoc2NydWJGaWVsZHMpO1xuICB2YXIgcXVlcnlSZXMgPSBfZ2V0U2NydWJRdWVyeVBhcmFtUmVnZXhzKHNjcnViRmllbGRzKTtcblxuICBmdW5jdGlvbiByZWRhY3RRdWVyeVBhcmFtKGR1bW15MCwgcGFyYW1QYXJ0KSB7XG4gICAgcmV0dXJuIHBhcmFtUGFydCArIF8ucmVkYWN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJhbVNjcnViYmVyKHYpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoXy5pc1R5cGUodiwgJ3N0cmluZycpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcXVlcnlSZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdiA9IHYucmVwbGFjZShxdWVyeVJlc1tpXSwgcmVkYWN0UXVlcnlQYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsU2NydWJiZXIoaywgdikge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbVJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHBhcmFtUmVzW2ldLnRlc3QoaykpIHtcbiAgICAgICAgdiA9IF8ucmVkYWN0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcnViYmVyKGssIHYsIHNlZW4pIHtcbiAgICB2YXIgdG1wViA9IHZhbFNjcnViYmVyKGssIHYpO1xuICAgIGlmICh0bXBWID09PSB2KSB7XG4gICAgICBpZiAoXy5pc1R5cGUodiwgJ29iamVjdCcpIHx8IF8uaXNUeXBlKHYsICdhcnJheScpKSB7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzZSh2LCBzY3J1YmJlciwgc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1TY3J1YmJlcih0bXBWKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRtcFY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlKGRhdGEsIHNjcnViYmVyKTtcbn1cblxuZnVuY3Rpb24gc2NydWJQYXRoKG9iaiwgcGF0aCkge1xuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIGxhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGFzdDsgKytpKSB7XG4gICAgICBpZiAoaSA8IGxhc3QpIHtcbiAgICAgICAgb2JqID0gb2JqW2tleXNbaV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleXNbaV1dID0gXy5yZWRhY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBNaXNzaW5nIGtleSBpcyBPSztcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0U2NydWJGaWVsZFJlZ2V4cyhzY3J1YkZpZWxkcykge1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBwYXQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NydWJGaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBwYXQgPSAnXlxcXFxbPyglNVtiQl0pPycgKyBzY3J1YkZpZWxkc1tpXSArICdcXFxcWz8oJTVbYkJdKT9cXFxcXT8oJTVbZERdKT8kJztcbiAgICByZXQucHVzaChuZXcgUmVnRXhwKHBhdCwgJ2knKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gX2dldFNjcnViUXVlcnlQYXJhbVJlZ2V4cyhzY3J1YkZpZWxkcykge1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBwYXQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NydWJGaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBwYXQgPSAnXFxcXFs/KCU1W2JCXSk/JyArIHNjcnViRmllbGRzW2ldICsgJ1xcXFxbPyglNVtiQl0pP1xcXFxdPyglNVtkRF0pPyc7XG4gICAgcmV0LnB1c2gobmV3IFJlZ0V4cCgnKCcgKyBwYXQgKyAnPSkoW14mXFxcXG5dKyknLCAnaWdtJykpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2NydWI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJy4vdXRpbGl0eScpO1xuXG5jb25zdCBNQVhfRVZFTlRTID0gMTAwO1xuXG4vLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCB3aGlsZSBzb2x2aW5nIGNvbW1vbmpzIC0+IGVzbSBpc3N1ZXMgaW4gTm9kZSAxOCAtIDIwLlxuZnVuY3Rpb24gZnJvbU1pbGxpcyhtaWxsaXMpIHtcbiAgcmV0dXJuIFtNYXRoLnRydW5jKG1pbGxpcyAvIDEwMDApLCBNYXRoLnJvdW5kKChtaWxsaXMgJSAxMDAwKSAqIDFlNildO1xufVxuXG5mdW5jdGlvbiBUZWxlbWV0ZXIob3B0aW9ucywgdHJhY2luZykge1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3B0aW9ucyA9IF8ubWVyZ2Uob3B0aW9ucyk7XG4gIHZhciBtYXhUZWxlbWV0cnlFdmVudHMgPSB0aGlzLm9wdGlvbnMubWF4VGVsZW1ldHJ5RXZlbnRzIHx8IE1BWF9FVkVOVFM7XG4gIHRoaXMubWF4UXVldWVTaXplID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4VGVsZW1ldHJ5RXZlbnRzLCBNQVhfRVZFTlRTKSk7XG4gIHRoaXMudHJhY2luZyA9IHRyYWNpbmc7XG4gIHRoaXMudGVsZW1ldHJ5U3BhbiA9IHRoaXMudHJhY2luZz8uc3RhcnRTcGFuKCdyb2xsYmFyLXRlbGVtZXRyeScsIHt9KTtcbn1cblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdGhpcy5vcHRpb25zID0gXy5tZXJnZShvbGRPcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIG1heFRlbGVtZXRyeUV2ZW50cyA9IHRoaXMub3B0aW9ucy5tYXhUZWxlbWV0cnlFdmVudHMgfHwgTUFYX0VWRU5UUztcbiAgdmFyIG5ld01heEV2ZW50cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heFRlbGVtZXRyeUV2ZW50cywgTUFYX0VWRU5UUykpO1xuICB2YXIgZGVsZXRlQ291bnQgPSAwO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiBuZXdNYXhFdmVudHMpIHtcbiAgICBkZWxldGVDb3VudCA9IHRoaXMucXVldWUubGVuZ3RoIC0gbmV3TWF4RXZlbnRzO1xuICB9XG4gIHRoaXMubWF4UXVldWVTaXplID0gbmV3TWF4RXZlbnRzO1xuICB0aGlzLnF1ZXVlLnNwbGljZSgwLCBkZWxldGVDb3VudCk7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNvcHlFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBldmVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLnF1ZXVlLCAwKTtcbiAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuZmlsdGVyVGVsZW1ldHJ5KSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaSA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyVGVsZW1ldHJ5KGV2ZW50c1tpXSkpIHtcbiAgICAgICAgICBldmVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZpbHRlclRlbGVtZXRyeSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudHM7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbiAoXG4gIHR5cGUsXG4gIG1ldGFkYXRhLFxuICBsZXZlbCxcbiAgcm9sbGJhclVVSUQsXG4gIHRpbWVzdGFtcCxcbikge1xuICB2YXIgZSA9IHtcbiAgICBsZXZlbDogZ2V0TGV2ZWwodHlwZSwgbGV2ZWwpLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZXN0YW1wX21zOiB0aW1lc3RhbXAgfHwgXy5ub3coKSxcbiAgICBib2R5OiBtZXRhZGF0YSxcbiAgICBzb3VyY2U6ICdjbGllbnQnLFxuICB9O1xuICBpZiAocm9sbGJhclVVSUQpIHtcbiAgICBlLnV1aWQgPSByb2xsYmFyVVVJRDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgXy5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5maWx0ZXJUZWxlbWV0cnkpICYmXG4gICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyVGVsZW1ldHJ5KGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoIChleGMpIHtcbiAgICB0aGlzLm9wdGlvbnMuZmlsdGVyVGVsZW1ldHJ5ID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMucHVzaChlKTtcbiAgcmV0dXJuIGU7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVFdmVudCA9IGZ1bmN0aW9uIChcbiAgdHlwZSxcbiAgbWV0YWRhdGEsXG4gIGxldmVsLFxuICByb2xsYmFyVVVJRCxcbikge1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKHR5cGUsIG1ldGFkYXRhLCBsZXZlbCwgcm9sbGJhclVVSUQpO1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlRXJyb3IgPSBmdW5jdGlvbiAoXG4gIGVycixcbiAgbGV2ZWwsXG4gIHJvbGxiYXJVVUlELFxuICB0aW1lc3RhbXAsXG4pIHtcbiAgY29uc3QgbWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8IFN0cmluZyhlcnIpO1xuICB2YXIgbWV0YWRhdGEgPSB7bWVzc2FnZX07XG4gIGlmIChlcnIuc3RhY2spIHtcbiAgICBtZXRhZGF0YS5zdGFjayA9IGVyci5zdGFjaztcbiAgfVxuICB0aGlzLnRlbGVtZXRyeVNwYW4/LmFkZEV2ZW50KFxuICAgICdyb2xsYmFyLW9jY3VycmVuY2UtZXZlbnQnLFxuICAgIHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBsZXZlbCxcbiAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICB1dWlkOiByb2xsYmFyVVVJRCxcbiAgICAgICdvY2N1cnJlbmNlLnR5cGUnOiAnZXJyb3InLCAvLyBkZXByZWNhdGVkXG4gICAgICAnb2NjdXJyZW5jZS51dWlkJzogcm9sbGJhclVVSUQsIC8vIGRlcHJlY2F0ZWRcbiAgICB9LFxuXG4gICAgZnJvbU1pbGxpcyh0aW1lc3RhbXApLFxuICApO1xuXG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ2Vycm9yJywgbWV0YWRhdGEsIGxldmVsLCByb2xsYmFyVVVJRCwgdGltZXN0YW1wKTtcbn07XG5cblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZUxvZyA9IGZ1bmN0aW9uIChcbiAgbWVzc2FnZSxcbiAgbGV2ZWwsXG4gIHJvbGxiYXJVVUlELFxuICB0aW1lc3RhbXAsXG4pIHtcbiAgLy8gSWYgdGhlIHV1aWQgaXMgcHJlc2VudCwgdGhpcyBpcyBhIG1lc3NhZ2Ugb2NjdXJyZW5jZS5cbiAgaWYgKHJvbGxiYXJVVUlEKSB7XG4gICAgdGhpcy50ZWxlbWV0cnlTcGFuPy5hZGRFdmVudChcbiAgICAgICdyb2xsYmFyLW9jY3VycmVuY2UtZXZlbnQnLFxuICAgICAge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgdHlwZTogJ21lc3NhZ2UnLFxuICAgICAgICB1dWlkOiByb2xsYmFyVVVJRCxcbiAgICAgICAgJ29jY3VycmVuY2UudHlwZSc6ICdtZXNzYWdlJywgLy8gZGVwcmVjYXRlZFxuICAgICAgICAnb2NjdXJyZW5jZS51dWlkJzogcm9sbGJhclVVSUQsIC8vIGRlcHJlY2F0ZWRcbiAgICAgIH0sXG4gICAgICBmcm9tTWlsbGlzKHRpbWVzdGFtcCksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRlbGVtZXRyeVNwYW4/LmFkZEV2ZW50KFxuICAgICAgJ2xvZy1ldmVudCcsXG4gICAgICB7bWVzc2FnZSwgbGV2ZWx9LFxuICAgICAgZnJvbU1pbGxpcyh0aW1lc3RhbXApLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jYXB0dXJlKFxuICAgICdsb2cnLFxuICAgIHttZXNzYWdlfSxcbiAgICBsZXZlbCxcbiAgICByb2xsYmFyVVVJRCxcbiAgICB0aW1lc3RhbXAsXG4gICk7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVOZXR3b3JrID0gZnVuY3Rpb24gKFxuICBtZXRhZGF0YSxcbiAgc3VidHlwZSxcbiAgcm9sbGJhclVVSUQsXG4gIHJlcXVlc3REYXRhLFxuKSB7XG4gIHN1YnR5cGUgPSBzdWJ0eXBlIHx8ICd4aHInO1xuICBtZXRhZGF0YS5zdWJ0eXBlID0gbWV0YWRhdGEuc3VidHlwZSB8fCBzdWJ0eXBlO1xuICBpZiAocmVxdWVzdERhdGEpIHtcbiAgICBtZXRhZGF0YS5yZXF1ZXN0ID0gcmVxdWVzdERhdGE7XG4gIH1cbiAgdmFyIGxldmVsID0gdGhpcy5sZXZlbEZyb21TdGF0dXMobWV0YWRhdGEuc3RhdHVzX2NvZGUpO1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKCduZXR3b3JrJywgbWV0YWRhdGEsIGxldmVsLCByb2xsYmFyVVVJRCk7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmxldmVsRnJvbVN0YXR1cyA9IGZ1bmN0aW9uIChzdGF0dXNDb2RlKSB7XG4gIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgcmV0dXJuICdpbmZvJztcbiAgfVxuICBpZiAoc3RhdHVzQ29kZSA9PT0gMCB8fCBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG4gIHJldHVybiAnaW5mbyc7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVEb20gPSBmdW5jdGlvbiAoXG4gIHN1YnR5cGUsXG4gIGVsZW1lbnQsXG4gIHZhbHVlLFxuICBjaGVja2VkLFxuICByb2xsYmFyVVVJRCxcbikge1xuICB2YXIgbWV0YWRhdGEgPSB7XG4gICAgc3VidHlwZTogc3VidHlwZSxcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICB9O1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1ldGFkYXRhLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKGNoZWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIG1ldGFkYXRhLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoJ2RvbScsIG1ldGFkYXRhLCAnaW5mbycsIHJvbGxiYXJVVUlEKTtcbn07XG5cblRlbGVtZXRlci5wcm90b3R5cGUuY2FwdHVyZU5hdmlnYXRpb24gPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHJvbGxiYXJVVUlELCB0aW1lc3RhbXApIHtcbiAgdGhpcy50ZWxlbWV0cnlTcGFuPy5hZGRFdmVudChcbiAgICAnc2Vzc2lvbi1uYXZpZ2F0aW9uLWV2ZW50JyxcbiAgICB7J3ByZXZpb3VzLnVybC5mdWxsJzogZnJvbSwgJ3VybC5mdWxsJzogdG99LFxuICAgIGZyb21NaWxsaXModGltZXN0YW1wKSxcbiAgKTtcblxuICByZXR1cm4gdGhpcy5jYXB0dXJlKFxuICAgICduYXZpZ2F0aW9uJyxcbiAgICB7ZnJvbSwgdG99LFxuICAgICdpbmZvJyxcbiAgICByb2xsYmFyVVVJRCxcbiAgICB0aW1lc3RhbXAsXG4gICk7XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLmNhcHR1cmVEb21Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKHRzKSB7XG4gIHJldHVybiB0aGlzLmNhcHR1cmUoXG4gICAgJ25hdmlnYXRpb24nLFxuICAgIHsgc3VidHlwZTogJ0RPTUNvbnRlbnRMb2FkZWQnIH0sXG4gICAgJ2luZm8nLFxuICAgIHVuZGVmaW5lZCxcbiAgICB0cyAmJiB0cy5nZXRUaW1lKCksXG4gICk7XG4gIC8qKlxuICAgKiBJZiB3ZSBkZWNpZGUgdG8gbWFrZSB0aGlzIGEgZG9tIGV2ZW50IGluc3RlYWQsIHRoZW4gdXNlIHRoZSBsaW5lIGJlbG93OlxuICByZXR1cm4gdGhpcy5jYXB0dXJlKCdkb20nLCB7c3VidHlwZTogJ0RPTUNvbnRlbnRMb2FkZWQnfSwgJ2luZm8nLCB1bmRlZmluZWQsIHRzICYmIHRzLmdldFRpbWUoKSk7XG4gICovXG59O1xuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlTG9hZCA9IGZ1bmN0aW9uICh0cykge1xuICByZXR1cm4gdGhpcy5jYXB0dXJlKFxuICAgICduYXZpZ2F0aW9uJyxcbiAgICB7IHN1YnR5cGU6ICdsb2FkJyB9LFxuICAgICdpbmZvJyxcbiAgICB1bmRlZmluZWQsXG4gICAgdHMgJiYgdHMuZ2V0VGltZSgpLFxuICApO1xuICAvKipcbiAgICogSWYgd2UgZGVjaWRlIHRvIG1ha2UgdGhpcyBhIGRvbSBldmVudCBpbnN0ZWFkLCB0aGVuIHVzZSB0aGUgbGluZSBiZWxvdzpcbiAgcmV0dXJuIHRoaXMuY2FwdHVyZSgnZG9tJywge3N1YnR5cGU6ICdsb2FkJ30sICdpbmZvJywgdW5kZWZpbmVkLCB0cyAmJiB0cy5nZXRUaW1lKCkpO1xuICAqL1xufTtcblxuVGVsZW1ldGVyLnByb3RvdHlwZS5jYXB0dXJlQ29ubmVjdGl2aXR5Q2hhbmdlID0gZnVuY3Rpb24gKHR5cGUsIHJvbGxiYXJVVUlEKSB7XG4gIHJldHVybiB0aGlzLmNhcHR1cmVOZXR3b3JrKHsgY2hhbmdlOiB0eXBlIH0sICdjb25uZWN0aXZpdHknLCByb2xsYmFyVVVJRCk7XG59O1xuXG4vLyBPbmx5IGludGVuZGVkIHRvIGJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgbm90aWZpZXJcblRlbGVtZXRlci5wcm90b3R5cGUuX2NhcHR1cmVSb2xsYmFySXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmluY2x1ZGVJdGVtc0luVGVsZW1ldHJ5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpdGVtLmVycikge1xuICAgIHJldHVybiB0aGlzLmNhcHR1cmVFcnJvcihpdGVtLmVyciwgaXRlbS5sZXZlbCwgaXRlbS51dWlkLCBpdGVtLnRpbWVzdGFtcCk7XG4gIH1cbiAgaWYgKGl0ZW0ubWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLmNhcHR1cmVMb2coaXRlbS5tZXNzYWdlLCBpdGVtLmxldmVsLCBpdGVtLnV1aWQsIGl0ZW0udGltZXN0YW1wKTtcbiAgfVxuICBpZiAoaXRlbS5jdXN0b20pIHtcbiAgICByZXR1cm4gdGhpcy5jYXB0dXJlKFxuICAgICAgJ2xvZycsXG4gICAgICBpdGVtLmN1c3RvbSxcbiAgICAgIGl0ZW0ubGV2ZWwsXG4gICAgICBpdGVtLnV1aWQsXG4gICAgICBpdGVtLnRpbWVzdGFtcCxcbiAgICApO1xuICB9XG59O1xuXG5UZWxlbWV0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZSkge1xuICB0aGlzLnF1ZXVlLnB1c2goZSk7XG4gIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IHRoaXMubWF4UXVldWVTaXplKSB7XG4gICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRMZXZlbCh0eXBlLCBsZXZlbCkge1xuICBpZiAobGV2ZWwpIHtcbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbiAgdmFyIGRlZmF1bHRMZXZlbCA9IHtcbiAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICBtYW51YWw6ICdpbmZvJyxcbiAgfTtcbiAgcmV0dXJuIGRlZmF1bHRMZXZlbFt0eXBlXSB8fCAnaW5mbyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVsZW1ldGVyO1xuIiwiZXhwb3J0IGNsYXNzIENvbnRleHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy5fY3VycmVudENvbnRleHQgPSBwYXJlbnRDb250ZXh0ID8gbmV3IE1hcChwYXJlbnRDb250ZXh0KSA6IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldFZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dC5nZXQoa2V5KTtcbiAgfVxuXG4gIHNldFZhbHVlIChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBDb250ZXh0KHRoaXMuX2N1cnJlbnRDb250ZXh0KTtcbiAgICBjb250ZXh0Ll9jdXJyZW50Q29udGV4dC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBkZWxldGVWYWx1ZShrZXkpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbnRleHQoc2VsZi5fY3VycmVudENvbnRleHQpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRDb250ZXh0LmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBST09UX0NPTlRFWFQgPSBuZXcgQ29udGV4dCgpO1xuXG4iLCJpbXBvcnQgeyBST09UX0NPTlRFWFQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuXG5leHBvcnQgY2xhc3MgQ29udGV4dE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gUk9PVF9DT05URVhUO1xuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0O1xuICB9XG5cbiAgZW50ZXJDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBwcmV2aW91c0NvbnRleHQgPSB0aGlzLmN1cnJlbnRDb250ZXh0O1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjb250ZXh0IHx8IFJPT1RfQ09OVEVYVDtcbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG5cbiAgZXhpdENvbnRleHQoY29udGV4dCkge1xuICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZXh0O1xuICB9XG5cbiAgd2l0aChjb250ZXh0LCBmbiwgdGhpc0FyZywgLi4uYXJncykge1xuICAgIGNvbnN0IHByZXZpb3VzQ29udGV4dCA9IHRoaXMuZW50ZXJDb250ZXh0KGNvbnRleHQpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGlzQXJnLCAuLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0Q29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dEtleShrZXkpIHtcbiAgLy8gVXNlIFN5bWJvbCBmb3IgT3BlblRlbGVtZXRyeSBjb21wYXRpYmlsaXR5LlxuICByZXR1cm4gU3ltYm9sLmZvcihrZXkpO1xufVxuXG4iLCIvKipcbiAqIERlZmF1bHQgdHJhY2luZyBvcHRpb25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIGVuZHBvaW50OiAnYXBpLnJvbGxiYXIuY29tL2FwaS8xL3Nlc3Npb24vJyxcbn1cbiIsImltcG9ydCBocnRpbWUgZnJvbSAnLi9ocnRpbWUnO1xuXG4vKipcbiAqIFNwYW5FeHBvcnRlciBpcyByZXNwb25zaWJsZSBmb3IgZXhwb3J0aW5nIFJlYWRhYmxlU3BhbiBvYmplY3RzXG4gKiBhbmQgdHJhbnNmb3JtaW5nIHRoZW0gaW50byB0aGUgT1RMUC1jb21wYXRpYmxlIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNwYW5FeHBvcnRlciB7XG4gIC8qKlxuICAgKiBFeHBvcnQgc3BhbnMgdG8gdGhlIHNwYW4gZXhwb3J0IHF1ZXVlXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNwYW5zIC0gQXJyYXkgb2YgUmVhZGFibGVTcGFuIG9iamVjdHMgdG8gZXhwb3J0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IF9yZXN1bHRDYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIChub3QgdXNlZClcbiAgICovXG4gIGV4cG9ydChzcGFucywgX3Jlc3VsdENhbGxiYWNrKSB7XG4gICAgY29uc29sZS5sb2coc3BhbnMpOyAvLyBjb25zb2xlIGV4cG9ydGVyLCBUT0RPOiBtYWtlIG9wdGlvbmFsXG4gICAgc3BhbkV4cG9ydFF1ZXVlLnB1c2goLi4uc3BhbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgUmVhZGFibGVTcGFuIG9iamVjdHMgaW50byB0aGUgT1RMUCBmb3JtYXQgcGF5bG9hZFxuICAgKiBjb21wYXRpYmxlIHdpdGggdGhlIFJvbGxiYXIgQVBJLiBUaGlzIGZvbGxvd3MgdGhlIE9wZW5UZWxlbWV0cnkgcHJvdG9jb2xcbiAgICogc3BlY2lmaWNhdGlvbiBmb3IgdHJhY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPVExQIGZvcm1hdCBwYXlsb2FkIGZvciBBUEkgdHJhbnNtaXNzaW9uXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgY29uc3Qgc3BhbnMgPSBzcGFuRXhwb3J0UXVldWUuc2xpY2UoKTtcbiAgICBzcGFuRXhwb3J0UXVldWUubGVuZ3RoID0gMDtcblxuICAgIGlmICghc3BhbnMgfHwgIXNwYW5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgcmVzb3VyY2VTcGFuczogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZSA9IChzcGFuc1swXSAmJiBzcGFuc1swXS5yZXNvdXJjZSkgfHwge307XG5cbiAgICBjb25zdCBzY29wZU1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgICAgY29uc3Qgc2NvcGVLZXkgPSBzcGFuLmluc3RydW1lbnRhdGlvblNjb3BlXG4gICAgICAgID8gYCR7c3Bhbi5pbnN0cnVtZW50YXRpb25TY29wZS5uYW1lfToke3NwYW4uaW5zdHJ1bWVudGF0aW9uU2NvcGUudmVyc2lvbn1gXG4gICAgICAgIDogJ2RlZmF1bHQ6MS4wLjAnO1xuXG4gICAgICBpZiAoIXNjb3BlTWFwLmhhcyhzY29wZUtleSkpIHtcbiAgICAgICAgc2NvcGVNYXAuc2V0KHNjb3BlS2V5LCB7XG4gICAgICAgICAgc2NvcGU6IHNwYW4uaW5zdHJ1bWVudGF0aW9uU2NvcGUgfHwge1xuICAgICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3BhbnM6IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGVNYXAuZ2V0KHNjb3BlS2V5KS5zcGFucy5wdXNoKHRoaXMuX3RyYW5zZm9ybVNwYW4oc3BhbikpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZXNvdXJjZVNwYW5zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvdXJjZTogdGhpcy5fdHJhbnNmb3JtUmVzb3VyY2UocmVzb3VyY2UpLFxuICAgICAgICAgIHNjb3BlU3BhbnM6IEFycmF5LmZyb20oc2NvcGVNYXAudmFsdWVzKCkpLm1hcCgoc2NvcGVEYXRhKSA9PiAoe1xuICAgICAgICAgICAgc2NvcGU6IHRoaXMuX3RyYW5zZm9ybUluc3RydW1lbnRhdGlvblNjb3BlKHNjb3BlRGF0YS5zY29wZSksXG4gICAgICAgICAgICBzcGFuczogc2NvcGVEYXRhLnNwYW5zLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgUmVhZGFibGVTcGFuIGludG8gdGhlIE9UTFAgU3BhbiBmb3JtYXRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNwYW4gLSBSZWFkYWJsZVNwYW4gb2JqZWN0IHRvIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPVExQIFNwYW4gZm9ybWF0XG4gICAqL1xuICBfdHJhbnNmb3JtU3BhbihzcGFuKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcyB8fCB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+ICh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWU6IHRoaXMuX3RyYW5zZm9ybUFueVZhbHVlKHZhbHVlKSxcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdHJhbnNmb3JtRXZlbnRzID0gKGV2ZW50cykgPT4ge1xuICAgICAgcmV0dXJuIChldmVudHMgfHwgW10pLm1hcCgoZXZlbnQpID0+ICh7XG4gICAgICAgIHRpbWVVbml4TmFubzogaHJ0aW1lLnRvTmFub3MoZXZlbnQudGltZSksXG4gICAgICAgIG5hbWU6IGV2ZW50Lm5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRyYW5zZm9ybUF0dHJpYnV0ZXMoZXZlbnQuYXR0cmlidXRlcyksXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB0cmFjZUlkOiBzcGFuLnNwYW5Db250ZXh0LnRyYWNlSWQsXG4gICAgICBzcGFuSWQ6IHNwYW4uc3BhbkNvbnRleHQuc3BhbklkLFxuICAgICAgcGFyZW50U3BhbklkOiBzcGFuLnBhcmVudFNwYW5JZCB8fCAnJyxcbiAgICAgIG5hbWU6IHNwYW4ubmFtZSxcbiAgICAgIGtpbmQ6IHNwYW4ua2luZCB8fCAxLCAvLyBJTlRFUk5BTCBieSBkZWZhdWx0XG4gICAgICBzdGFydFRpbWVVbml4TmFubzogaHJ0aW1lLnRvTmFub3Moc3Bhbi5zdGFydFRpbWUpLFxuICAgICAgZW5kVGltZVVuaXhOYW5vOiBocnRpbWUudG9OYW5vcyhzcGFuLmVuZFRpbWUpLFxuICAgICAgYXR0cmlidXRlczogdHJhbnNmb3JtQXR0cmlidXRlcyhzcGFuLmF0dHJpYnV0ZXMpLFxuICAgICAgZXZlbnRzOiB0cmFuc2Zvcm1FdmVudHMoc3Bhbi5ldmVudHMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIHJlc291cmNlIG9iamVjdCBpbnRvIE9UTFAgUmVzb3VyY2UgZm9ybWF0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNvdXJjZSAtIFJlc291cmNlIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9UTFAgUmVzb3VyY2UgZm9ybWF0XG4gICAqL1xuICBfdHJhbnNmb3JtUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gcmVzb3VyY2UuYXR0cmlidXRlcyB8fCB7fTtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlOiB0aGlzLl90cmFuc2Zvcm1BbnlWYWx1ZSh2YWx1ZSksXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJpYnV0ZXM6IGtleVZhbHVlcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYW4gaW5zdHJ1bWVudGF0aW9uIHNjb3BlIGludG8gT1RMUCBJbnN0cnVtZW50YXRpb25TY29wZSBmb3JtYXRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIC0gSW5zdHJ1bWVudGF0aW9uIHNjb3BlIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9UTFAgSW5zdHJ1bWVudGF0aW9uU2NvcGUgZm9ybWF0XG4gICAqL1xuICBfdHJhbnNmb3JtSW5zdHJ1bWVudGF0aW9uU2NvcGUoc2NvcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogc2NvcGUubmFtZSB8fCAnJyxcbiAgICAgIHZlcnNpb246IHNjb3BlLnZlcnNpb24gfHwgJycsXG4gICAgICBhdHRyaWJ1dGVzOiAoc2NvcGUuYXR0cmlidXRlcyB8fCBbXSkubWFwKChhdHRyKSA9PiAoe1xuICAgICAgICBrZXk6IGF0dHIua2V5LFxuICAgICAgICB2YWx1ZTogdGhpcy5fdHJhbnNmb3JtQW55VmFsdWUoYXR0ci52YWx1ZSksXG4gICAgICB9KSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgSmF2YVNjcmlwdCB2YWx1ZSBpbnRvIGFuIE9UTFAgQW55VmFsdWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVmFsdWUgdG8gdHJhbnNmb3JtXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9UTFAgQW55VmFsdWUgZm9ybWF0XG4gICAqL1xuICBfdHJhbnNmb3JtQW55VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6ICcnIH07XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6IHZhbHVlIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGludFZhbHVlOiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHsgYm9vbFZhbHVlOiB2YWx1ZSB9O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFycmF5VmFsdWU6IHtcbiAgICAgICAgICB2YWx1ZXM6IHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdHJhbnNmb3JtQW55VmFsdWUodikpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrdmxpc3RWYWx1ZToge1xuICAgICAgICAgIHZhbHVlczogT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiAoe1xuICAgICAgICAgICAga2V5OiBrLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3RyYW5zZm9ybUFueVZhbHVlKHYpLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6IFN0cmluZyh2YWx1ZSkgfTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BhbkV4cG9ydFF1ZXVlID0gW107XG4iLCIvKipcbiAqIEBtb2R1bGUgaHJ0aW1lXG4gKlxuICogQGRlc2NyaXB0aW9uIE1ldGhvZHMgZm9yIGhhbmRsaW5nIE9wZW5UZWxlbWV0cnkgaHJ0aW1lLlxuICovXG5cbi8qKlxuICogQ29udmVydCBhIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byBhbiBPcGVuVGVsZW1ldHJ5IGhydGltZSB0dXBsZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIC0gVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXJdfSBBbiBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyBzZWNvbmRzXG4gKiAgIGFuZCB0aGUgc2Vjb25kIGlzIG5hbm9zZWNvbmRzLlxuICovXG5mdW5jdGlvbiBmcm9tTWlsbGlzKG1pbGxpcykge1xuICByZXR1cm4gW01hdGgudHJ1bmMobWlsbGlzIC8gMTAwMCksIE1hdGgucm91bmQoKG1pbGxpcyAlIDEwMDApICogMWU2KV07XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBPcGVuVGVsZW1ldHJ5IGhydGltZSB0dXBsZSBiYWNrIHRvIGEgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gaHJ0aW1lIC0gVGhlIGhydGltZSB0dXBsZSBbc2Vjb25kcywgbmFub3NlY29uZHNdLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gdG9NaWxsaXMoaHJ0aW1lKSB7XG4gIHJldHVybiBocnRpbWVbMF0gKiAxZTMgKyBNYXRoLnJvdW5kKGhydGltZVsxXSAvIDFlNik7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBPcGVuVGVsZW1ldHJ5IGhydGltZSB0dXBsZSBiYWNrIHRvIGEgZHVyYXRpb24gaW4gbmFub3NlY29uZHMuXG4gKlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBocnRpbWUgLSBUaGUgaHJ0aW1lIHR1cGxlIFtzZWNvbmRzLCBuYW5vc2Vjb25kc10uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgZHVyYXRpb24gaW4gbmFub3NlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHRvTmFub3MoaHJ0aW1lKSB7XG4gIHJldHVybiBocnRpbWVbMF0gKiAxZTkgKyBocnRpbWVbMV07XG59XG5cbi8qKlxuICogQWRkcyB0d28gT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGVzLlxuICpcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gYSAtIFRoZSBmaXJzdCBocnRpbWUgdHVwbGUgW3MsIG5zXS5cbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gYiAtIFRoZSBzZWNvbmQgaHJ0aW1lIHR1cGxlIFtzLCBuc10uXG4gKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyXX0gU3VtbWVkIGhydGltZSB0dXBsZSwgbm9ybWFsaXplZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiBbYVswXSArIGJbMF0gKyBNYXRoLnRydW5jKChhWzFdICsgYlsxXSkgLyAxZTkpLCAoYVsxXSArIGJbMV0pICUgMWU5XTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgaGlnaC1yZXNvbHV0aW9uIHRpbWUgYXMgYW4gT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGUuXG4gKlxuICogVXNlcyB0aGUgUGVyZm9ybWFuY2UgQVBJICh0aW1lT3JpZ2luICsgbm93KCkpLlxuICpcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXJdfSBUaGUgY3VycmVudCBocnRpbWUgdHVwbGUgW3MsIG5zXS5cbiAqL1xuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gYWRkKGZyb21NaWxsaXMocGVyZm9ybWFuY2UudGltZU9yaWdpbiksIGZyb21NaWxsaXMocGVyZm9ybWFuY2Uubm93KCkpKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgT3BlblRlbGVtZXRyeSBocnRpbWUgdHVwbGUuXG4gKlxuICogQW4gaHJ0aW1lIHR1cGxlIGlzIGFuIEFycmF5IG9mIGV4YWN0bHkgdHdvIG51bWJlcnM6XG4gKiAgIFtzZWNvbmRzLCBuYW5vc2Vjb25kc11cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIOKAkyBhbnl0aGluZyB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgW251bWJlciwgbnVtYmVyXSBhcnJheSBvZiBsZW5ndGggMlxuICpcbiAqIEBleGFtcGxlXG4gKiBpc0hyVGltZShbIDEsIDUwMCBdKTsgICAgICAgICAvLyB0cnVlXG4gKiBpc0hyVGltZShbIDAsIDFlOSBdKTsgICAgICAgICAvLyB0cnVlXG4gKiBpc0hyVGltZShbICcxJywgNTAwIF0pOyAgICAgICAvLyBmYWxzZVxuICogaXNIclRpbWUoeyAwOiAxLCAxOiA1MDAgfSk7ICAgLy8gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNIclRpbWUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgIHZhbHVlLmxlbmd0aCA9PT0gMiAmJlxuICAgIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgdmFsdWVbMV0gPT09ICdudW1iZXInXG4gICk7XG59XG5cbi8qKlxuICogTWV0aG9kcyBmb3IgaGFuZGxpbmcgaHJ0aW1lLiBPcGVuVGVsZW1ldHJ5IHVzZXMgdGhlIFtzZWNvbmRzLCBuYW5vc2Vjb25kc11cbiAqIGZvcm1hdCBmb3IgaHJ0aW1lIGluIHRoZSBgUmVhZGFibGVTcGFuYCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBocnRpbWUgZnJvbSAnQHRyYWNpbmcvaHJ0aW1lLmpzJztcbiAqXG4gKiBocnRpbWUuZnJvbU1pbGxpcygxMDAwKTtcbiAqIGhydGltZS50b01pbGxpcyhbMCwgMTAwMF0pO1xuICogaHJ0aW1lLmFkZChbMCwgMF0sIFswLCAxMDAwXSk7XG4gKiBocnRpbWUubm93KCk7XG4gKiBocnRpbWUuaXNIclRpbWUoWzAsIDEwMDBdKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgeyBmcm9tTWlsbGlzLCB0b01pbGxpcywgdG9OYW5vcywgYWRkLCBub3csIGlzSHJUaW1lIH07XG4iLCIvKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGhleGFkZWNpbWFsIElEIG9mIHNwZWNpZmllZCBieXRlIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyAtIE51bWJlciBvZiBieXRlcyBmb3IgdGhlIElEIChkZWZhdWx0OiAxNilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gSGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdlbihieXRlcyA9IDE2KSB7XG4gIGxldCByYW5kb21CeXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CeXRlcyk7XG4gIGxldCByYW5kSGV4ID0gQXJyYXkuZnJvbShyYW5kb21CeXRlcywgKGJ5dGUpID0+XG4gICAgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSxcbiAgKS5qb2luKCcnKTtcbiAgcmV0dXJuIHJhbmRIZXg7XG59XG5cbi8qKlxuICogVHJhY2luZyBpZCBnZW5lcmF0aW9uIHV0aWxzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBpZCBmcm9tICcuL2lkLmpzJztcbiAqXG4gKiBjb25zdCBzcGFuSWQgPSBpZC5nZW4oOCk7IC8vID0+IFwiYTFiMmMzZDRlNWY2Li4uXCJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgeyBnZW4gfTtcbiIsImltcG9ydCBpZCBmcm9tICcuL2lkLmpzJztcblxuY29uc3QgU0VTU0lPTl9LRVkgPSAnUm9sbGJhclNlc3Npb24nO1xuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHRyYWNpbmcsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHJhY2luZyA9IHRyYWNpbmc7XG4gICAgdGhpcy53aW5kb3cgPSB0cmFjaW5nLndpbmRvdztcbiAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Vzc2lvbigpIHx8IHRoaXMuY3JlYXRlU2Vzc2lvbigpO1xuICB9XG5cbiAgZ2V0U2Vzc2lvbigpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZFNlc3Npb24gPSB0aGlzLndpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNFU1NJT05fS0VZKTtcblxuICAgICAgaWYgKCFzZXJpYWxpemVkU2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXNzaW9uID0gSlNPTi5wYXJzZShzZXJpYWxpemVkU2Vzc2lvbik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjcmVhdGVTZXNzaW9uKCkge1xuICAgIHRoaXMuc2Vzc2lvbiA9IHtcbiAgICAgIGlkOiBpZC5nZW4oKSxcbiAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0U2Vzc2lvbih0aGlzLnNlc3Npb24pO1xuICB9XG5cbiAgc2V0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgY29uc3Qgc2Vzc2lvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHNlc3Npb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oU0VTU0lPTl9LRVksIHNlc3Npb25TdHJpbmcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbiIsImltcG9ydCBocnRpbWUgZnJvbSAnLi9ocnRpbWUuanMnO1xuXG5leHBvcnQgY2xhc3MgU3BhbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXRSZWFkYWJsZVNwYW4ob3B0aW9ucyk7XG5cbiAgICB0aGlzLnNwYW5Qcm9jZXNzb3IgPSBvcHRpb25zLnNwYW5Qcm9jZXNzb3I7XG4gICAgdGhpcy5zcGFuUHJvY2Vzc29yLm9uU3RhcnQodGhpcywgb3B0aW9ucy5jb250ZXh0KTtcblxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGluaXRSZWFkYWJsZVNwYW4ob3B0aW9ucykge1xuICAgIHRoaXMuc3BhbiA9IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgIGtpbmQ6IG9wdGlvbnMua2luZCxcbiAgICAgIHNwYW5Db250ZXh0OiBvcHRpb25zLnNwYW5Db250ZXh0LFxuICAgICAgcGFyZW50U3BhbklkOiBvcHRpb25zLnBhcmVudFNwYW5JZCxcbiAgICAgIHN0YXJ0VGltZTogb3B0aW9ucy5zdGFydFRpbWUgfHwgaHJ0aW1lLm5vdygpLFxuICAgICAgZW5kVGltZTogWzAsIDBdLFxuICAgICAgc3RhdHVzOiB7IGNvZGU6IDAsIG1lc3NhZ2U6ICcnIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7ICdzZXNzaW9uLmlkJzogb3B0aW9ucy5zZXNzaW9uLmlkIH0sXG4gICAgICBsaW5rczogW10sXG4gICAgICBldmVudHM6IFtdLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICBlbmRlZDogZmFsc2UsXG4gICAgICByZXNvdXJjZTogb3B0aW9ucy5yZXNvdXJjZSxcbiAgICAgIGluc3RydW1lbnRhdGlvblNjb3BlOiBvcHRpb25zLnNjb3BlLFxuICAgICAgZHJvcHBlZEF0dHJpYnV0ZXNDb3VudDogMCxcbiAgICAgIGRyb3BwZWRFdmVudHNDb3VudDogMCxcbiAgICAgIGRyb3BwZWRMaW5rc0NvdW50OiAwLFxuICAgIH07XG4gIH1cblxuICBzcGFuQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLnNwYW5Db250ZXh0O1xuICB9XG5cbiAgZ2V0IHNwYW5JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLnNwYW5Db250ZXh0LnNwYW5JZDtcbiAgfVxuXG4gIGdldCB0cmFjZUlkKCkge1xuICAgIHJldHVybiB0aGlzLnNwYW4uc3BhbkNvbnRleHQudHJhY2VJZDtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdGhpcy5lbmRlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5zcGFuLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZEV2ZW50KG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgdGltZSkge1xuICAgIGlmICh0aGlzLnNwYW4uZW5kZWQpIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5zcGFuLmV2ZW50cy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgdGltZTogdGltZSB8fCBocnRpbWUubm93KCksXG4gICAgICBkcm9wcGVkQXR0cmlidXRlc0NvdW50OiAwLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFuLmVuZGVkID09PSBmYWxzZTtcbiAgfVxuXG4gIGVuZChhdHRyaWJ1dGVzLCB0aW1lKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHRoaXMuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICB0aGlzLnNwYW4uZW5kVGltZSA9IHRpbWUgfHwgaHJ0aW1lLm5vdygpO1xuICAgIHRoaXMuc3Bhbi5lbmRlZCA9IHRydWU7XG4gICAgdGhpcy5zcGFuUHJvY2Vzc29yLm9uRW5kKHRoaXMpO1xuICB9XG5cbiAgZXhwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBTcGFuUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3IoZXhwb3J0ZXIpIHtcbiAgICB0aGlzLmV4cG9ydGVyID0gZXhwb3J0ZXI7XG4gICAgdGhpcy5wZW5kaW5nU3BhbnMgPSBuZXcgTWFwKClcbiAgfVxuXG4gIG9uU3RhcnQoc3BhbiwgX3BhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnBlbmRpbmdTcGFucy5zZXQoc3Bhbi5zcGFuLnNwYW5Db250ZXh0LnNwYW5JZCwgc3Bhbik7XG4gIH1cblxuICBvbkVuZChzcGFuKSB7XG4gICAgdGhpcy5leHBvcnRlci5leHBvcnQoW3NwYW4uZXhwb3J0KCldKVxuICAgIHRoaXMucGVuZGluZ1NwYW5zLmRlbGV0ZShzcGFuLnNwYW4uc3BhbkNvbnRleHQuc3BhbklkKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU3BhbiB9IGZyb20gJy4vc3Bhbi5qcyc7XG5pbXBvcnQgaWQgZnJvbSAnLi9pZC5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFjZXIge1xuICBjb25zdHJ1Y3Rvcih0cmFjaW5nLCBzcGFuUHJvY2Vzc29yKSB7XG4gICAgdGhpcy5zcGFuUHJvY2Vzc29yID0gc3BhblByb2Nlc3NvcjtcbiAgICB0aGlzLnRyYWNpbmcgPSB0cmFjaW5nO1xuICB9XG5cbiAgc3RhcnRTcGFuKFxuICAgIG5hbWUsXG4gICAgb3B0aW9ucyA9IHt9LFxuICAgIGNvbnRleHQgPSB0aGlzLnRyYWNpbmcuY29udGV4dE1hbmFnZXIuYWN0aXZlKClcbiAgKSB7XG4gICAgY29uc3QgcGFyZW50U3BhbiA9IHRoaXMudHJhY2luZy5nZXRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudFNwYW5Db250ZXh0ID0gcGFyZW50U3Bhbj8uc3BhbkNvbnRleHQoKTtcbiAgICBjb25zdCBzcGFuSWQgPSBpZC5nZW4oOCk7XG4gICAgbGV0IHRyYWNlSWQ7XG4gICAgbGV0IHRyYWNlRmxhZ3MgPSAwO1xuICAgIGxldCB0cmFjZVN0YXRlID0gbnVsbDtcbiAgICBsZXQgcGFyZW50U3BhbklkO1xuICAgIGlmIChwYXJlbnRTcGFuQ29udGV4dCkge1xuICAgICAgdHJhY2VJZCA9IHBhcmVudFNwYW5Db250ZXh0LnRyYWNlSWQ7XG4gICAgICB0cmFjZVN0YXRlID0gcGFyZW50U3BhbkNvbnRleHQudHJhY2VTdGF0ZTtcbiAgICAgIHBhcmVudFNwYW5JZCA9IHBhcmVudFNwYW5Db250ZXh0LnNwYW5JZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2VJZCA9IGlkLmdlbigxNik7XG4gICAgfVxuXG4gICAgY29uc3Qga2luZCA9IDA7XG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSB7IHRyYWNlSWQsIHNwYW5JZCwgdHJhY2VGbGFncywgdHJhY2VTdGF0ZSB9O1xuXG4gICAgY29uc3Qgc3BhbiA9IG5ldyBTcGFuKHtcbiAgICAgIHJlc291cmNlOiB0aGlzLnRyYWNpbmcucmVzb3VyY2UsXG4gICAgICBzY29wZTogdGhpcy50cmFjaW5nLnNjb3BlLFxuICAgICAgc2Vzc2lvbjogdGhpcy50cmFjaW5nLnNlc3Npb24uc2Vzc2lvbixcbiAgICAgIGNvbnRleHQsXG4gICAgICBzcGFuQ29udGV4dCxcbiAgICAgIG5hbWUsXG4gICAgICBraW5kLFxuICAgICAgcGFyZW50U3BhbklkLFxuICAgICAgc3BhblByb2Nlc3NvcjogdGhpcy5zcGFuUHJvY2Vzc29yLFxuICAgIH0pO1xuICAgIHJldHVybiBzcGFuO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb250ZXh0TWFuYWdlciwgY3JlYXRlQ29udGV4dEtleSB9IGZyb20gJy4vY29udGV4dE1hbmFnZXIuanMnO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBTcGFuRXhwb3J0ZXIgfSBmcm9tICcuL2V4cG9ydGVyLmpzJztcbmltcG9ydCB7IFNwYW5Qcm9jZXNzb3IgfSBmcm9tICcuL3NwYW5Qcm9jZXNzb3IuanMnO1xuaW1wb3J0IHsgVHJhY2VyIH0gZnJvbSAnLi90cmFjZXIuanMnO1xuXG5jb25zdCBTUEFOX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoJ1JvbGxiYXIgQ29udGV4dCBLZXkgU1BBTicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFjaW5nIHtcbiAgY29uc3RydWN0b3IoZ1dpbmRvdywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53aW5kb3cgPSBnV2luZG93O1xuXG4gICAgdGhpcy5zZXNzaW9uID0gbmV3IFNlc3Npb24odGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5jcmVhdGVUcmFjZXIoKTtcbiAgfVxuXG4gIGluaXRTZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5pbml0KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHNlc3Npb25JZCgpIHtcbiAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnNlc3Npb24uaWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IHJlc291cmNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLih0aGlzLm9wdGlvbnMucmVzb3VyY2UgfHwge30pLFxuICAgICAgICAncm9sbGJhci5lbnZpcm9ubWVudCc6XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnBheWxvYWQ/LmVudmlyb25tZW50ID8/IHRoaXMub3B0aW9ucy5lbnZpcm9ubWVudCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGdldCBzY29wZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ3JvbGxiYXItYnJvd3Nlci1qcycsXG4gICAgICB2ZXJzaW9uOiB0aGlzLm9wdGlvbnMudmVyc2lvbixcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlVHJhY2VyKCkge1xuICAgIHRoaXMuY29udGV4dE1hbmFnZXIgPSBuZXcgQ29udGV4dE1hbmFnZXIoKTtcbiAgICB0aGlzLmV4cG9ydGVyID0gbmV3IFNwYW5FeHBvcnRlcigpO1xuICAgIHRoaXMuc3BhblByb2Nlc3NvciA9IG5ldyBTcGFuUHJvY2Vzc29yKHRoaXMuZXhwb3J0ZXIpO1xuICAgIHRoaXMudHJhY2VyID0gbmV3IFRyYWNlcih0aGlzLCB0aGlzLnNwYW5Qcm9jZXNzb3IpO1xuICB9XG5cbiAgZ2V0VHJhY2VyKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNlcjtcbiAgfVxuXG4gIGdldFNwYW4oY29udGV4dCA9IHRoaXMuY29udGV4dE1hbmFnZXIuYWN0aXZlKCkpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRWYWx1ZShTUEFOX0tFWSk7XG4gIH1cblxuICBzZXRTcGFuKGNvbnRleHQgPSB0aGlzLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpLCBzcGFuKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoU1BBTl9LRVksIHNwYW4pO1xuICB9XG5cbiAgc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMgPSB7fSwgY29udGV4dCA9IHRoaXMuY29udGV4dE1hbmFnZXIuYWN0aXZlKCkpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjZXIuc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQpO1xuICB9XG5cbiAgd2l0aChjb250ZXh0LCBmbiwgdGhpc0FyZywgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRNYW5hZ2VyLndpdGgoY29udGV4dCwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpO1xuICB9XG5cbiAgd2l0aFNwYW4obmFtZSwgb3B0aW9ucywgZm4sIHRoaXNBcmcpIHtcbiAgICBjb25zdCBzcGFuID0gdGhpcy5zdGFydFNwYW4obmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMud2l0aChcbiAgICAgIHRoaXMuc2V0U3Bhbih0aGlzLmNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpLCBzcGFuKSxcbiAgICAgIGZuLFxuICAgICAgdGhpc0FyZyxcbiAgICAgIHNwYW4sXG4gICAgKTtcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcblxuZnVuY3Rpb24gaXRlbVRvUGF5bG9hZChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgZGF0YSA9IGl0ZW0uZGF0YTtcblxuICBpZiAoaXRlbS5faXNVbmNhdWdodCkge1xuICAgIGRhdGEuX2lzVW5jYXVnaHQgPSB0cnVlO1xuICB9XG4gIGlmIChpdGVtLl9vcmlnaW5hbEFyZ3MpIHtcbiAgICBkYXRhLl9vcmlnaW5hbEFyZ3MgPSBpdGVtLl9vcmlnaW5hbEFyZ3M7XG4gIH1cbiAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGFkZFBheWxvYWRPcHRpb25zKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXlsb2FkT3B0aW9ucyA9IG9wdGlvbnMucGF5bG9hZCB8fCB7fTtcbiAgaWYgKHBheWxvYWRPcHRpb25zLmJvZHkpIHtcbiAgICBkZWxldGUgcGF5bG9hZE9wdGlvbnMuYm9keTtcbiAgfVxuXG4gIGl0ZW0uZGF0YSA9IF8ubWVyZ2UoaXRlbS5kYXRhLCBwYXlsb2FkT3B0aW9ucyk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGRUZWxlbWV0cnlEYXRhKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChpdGVtLnRlbGVtZXRyeUV2ZW50cykge1xuICAgIF8uc2V0KGl0ZW0sICdkYXRhLmJvZHkudGVsZW1ldHJ5JywgaXRlbS50ZWxlbWV0cnlFdmVudHMpO1xuICB9XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBhZGRNZXNzYWdlV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghaXRlbS5tZXNzYWdlKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0cmFjZVBhdGggPSAnZGF0YS5ib2R5LnRyYWNlX2NoYWluLjAnO1xuICB2YXIgdHJhY2UgPSBfLmdldChpdGVtLCB0cmFjZVBhdGgpO1xuICBpZiAoIXRyYWNlKSB7XG4gICAgdHJhY2VQYXRoID0gJ2RhdGEuYm9keS50cmFjZSc7XG4gICAgdHJhY2UgPSBfLmdldChpdGVtLCB0cmFjZVBhdGgpO1xuICB9XG4gIGlmICh0cmFjZSkge1xuICAgIGlmICghKHRyYWNlLmV4Y2VwdGlvbiAmJiB0cmFjZS5leGNlcHRpb24uZGVzY3JpcHRpb24pKSB7XG4gICAgICBfLnNldChpdGVtLCB0cmFjZVBhdGggKyAnLmV4Y2VwdGlvbi5kZXNjcmlwdGlvbicsIGl0ZW0ubWVzc2FnZSk7XG4gICAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGV4dHJhID0gXy5nZXQoaXRlbSwgdHJhY2VQYXRoICsgJy5leHRyYScpIHx8IHt9O1xuICAgIHZhciBuZXdFeHRyYSA9IF8ubWVyZ2UoZXh0cmEsIHsgbWVzc2FnZTogaXRlbS5tZXNzYWdlIH0pO1xuICAgIF8uc2V0KGl0ZW0sIHRyYWNlUGF0aCArICcuZXh0cmEnLCBuZXdFeHRyYSk7XG4gIH1cbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIHVzZXJUcmFuc2Zvcm0obG9nZ2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgbmV3SXRlbSA9IF8ubWVyZ2UoaXRlbSk7XG4gICAgdmFyIHJlc3BvbnNlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBvcHRpb25zLnRyYW5zZm9ybShuZXdJdGVtLmRhdGEsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9wdGlvbnMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgJ0Vycm9yIHdoaWxlIGNhbGxpbmcgY3VzdG9tIHRyYW5zZm9ybSgpIGZ1bmN0aW9uLiBSZW1vdmluZyBjdXN0b20gdHJhbnNmb3JtKCkuJyxcbiAgICAgICAgZSxcbiAgICAgICk7XG4gICAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKF8uaXNQcm9taXNlKHJlc3BvbnNlKSkge1xuICAgICAgcmVzcG9uc2UudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKHByb21pc2VkSXRlbSkge1xuICAgICAgICAgIGlmIChwcm9taXNlZEl0ZW0pIHtcbiAgICAgICAgICAgIG5ld0l0ZW0uZGF0YSA9IHByb21pc2VkSXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmV3SXRlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBpdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG5ld0l0ZW0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkQ29uZmlnVG9QYXlsb2FkKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5zZW5kQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICB9XG4gIHZhciBjb25maWdLZXkgPSAnX3JvbGxiYXJDb25maWcnO1xuICB2YXIgY3VzdG9tID0gXy5nZXQoaXRlbSwgJ2RhdGEuY3VzdG9tJykgfHwge307XG4gIGN1c3RvbVtjb25maWdLZXldID0gb3B0aW9ucztcbiAgaXRlbS5kYXRhLmN1c3RvbSA9IGN1c3RvbTtcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGFkZEZ1bmN0aW9uT3B0aW9uKG9wdGlvbnMsIG5hbWUpIHtcbiAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zW25hbWVdKSkge1xuICAgIG9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ29uZmlndXJlZE9wdGlvbnMoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGNvbmZpZ3VyZWRPcHRpb25zID0gb3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnM7XG5cbiAgLy8gVGhlc2UgbXVzdCBiZSBzdHJpbmdpZmllZCBvciB0aGV5J2xsIGdldCBkcm9wcGVkIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICBhZGRGdW5jdGlvbk9wdGlvbihjb25maWd1cmVkT3B0aW9ucywgJ3RyYW5zZm9ybScpO1xuICBhZGRGdW5jdGlvbk9wdGlvbihjb25maWd1cmVkT3B0aW9ucywgJ2NoZWNrSWdub3JlJyk7XG4gIGFkZEZ1bmN0aW9uT3B0aW9uKGNvbmZpZ3VyZWRPcHRpb25zLCAnb25TZW5kQ2FsbGJhY2snKTtcblxuICBkZWxldGUgY29uZmlndXJlZE9wdGlvbnMuYWNjZXNzVG9rZW47XG4gIGl0ZW0uZGF0YS5ub3RpZmllci5jb25maWd1cmVkX29wdGlvbnMgPSBjb25maWd1cmVkT3B0aW9ucztcbiAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpYWdub3N0aWNLZXlzKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBkaWFnbm9zdGljID0gXy5tZXJnZShcbiAgICBpdGVtLm5vdGlmaWVyLmNsaWVudC5ub3RpZmllci5kaWFnbm9zdGljLFxuICAgIGl0ZW0uZGlhZ25vc3RpYyxcbiAgKTtcblxuICBpZiAoXy5nZXQoaXRlbSwgJ2Vyci5faXNBbm9ueW1vdXMnKSkge1xuICAgIGRpYWdub3N0aWMuaXNfYW5vbnltb3VzID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpdGVtLl9pc1VuY2F1Z2h0KSB7XG4gICAgZGlhZ25vc3RpYy5pc191bmNhdWdodCA9IGl0ZW0uX2lzVW5jYXVnaHQ7XG4gIH1cblxuICBpZiAoaXRlbS5lcnIpIHtcbiAgICB0cnkge1xuICAgICAgZGlhZ25vc3RpYy5yYXdfZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6IGl0ZW0uZXJyLm1lc3NhZ2UsXG4gICAgICAgIG5hbWU6IGl0ZW0uZXJyLm5hbWUsXG4gICAgICAgIGNvbnN0cnVjdG9yX25hbWU6IGl0ZW0uZXJyLmNvbnN0cnVjdG9yICYmIGl0ZW0uZXJyLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgIGZpbGVuYW1lOiBpdGVtLmVyci5maWxlTmFtZSxcbiAgICAgICAgbGluZTogaXRlbS5lcnIubGluZU51bWJlcixcbiAgICAgICAgY29sdW1uOiBpdGVtLmVyci5jb2x1bW5OdW1iZXIsXG4gICAgICAgIHN0YWNrOiBpdGVtLmVyci5zdGFjayxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGlhZ25vc3RpYy5yYXdfZXJyb3IgPSB7IGZhaWxlZDogU3RyaW5nKGUpIH07XG4gICAgfVxuICB9XG5cbiAgaXRlbS5kYXRhLm5vdGlmaWVyLmRpYWdub3N0aWMgPSBfLm1lcmdlKFxuICAgIGl0ZW0uZGF0YS5ub3RpZmllci5kaWFnbm9zdGljLFxuICAgIGRpYWdub3N0aWMsXG4gICk7XG4gIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXRlbVRvUGF5bG9hZDogaXRlbVRvUGF5bG9hZCxcbiAgYWRkUGF5bG9hZE9wdGlvbnM6IGFkZFBheWxvYWRPcHRpb25zLFxuICBhZGRUZWxlbWV0cnlEYXRhOiBhZGRUZWxlbWV0cnlEYXRhLFxuICBhZGRNZXNzYWdlV2l0aEVycm9yOiBhZGRNZXNzYWdlV2l0aEVycm9yLFxuICB1c2VyVHJhbnNmb3JtOiB1c2VyVHJhbnNmb3JtLFxuICBhZGRDb25maWdUb1BheWxvYWQ6IGFkZENvbmZpZ1RvUGF5bG9hZCxcbiAgYWRkQ29uZmlndXJlZE9wdGlvbnM6IGFkZENvbmZpZ3VyZWRPcHRpb25zLFxuICBhZGREaWFnbm9zdGljS2V5czogYWRkRGlhZ25vc3RpY0tleXMsXG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCcuL3V0aWxpdHknKTtcbnZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoJy4vdXRpbGl0eS90cmF2ZXJzZScpO1xuXG5mdW5jdGlvbiByYXcocGF5bG9hZCwganNvbkJhY2t1cCkge1xuICByZXR1cm4gW3BheWxvYWQsIF8uc3RyaW5naWZ5KHBheWxvYWQsIGpzb25CYWNrdXApXTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0RnJhbWVzKGZyYW1lcywgcmFuZ2UpIHtcbiAgdmFyIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG4gIGlmIChsZW4gPiByYW5nZSAqIDIpIHtcbiAgICByZXR1cm4gZnJhbWVzLnNsaWNlKDAsIHJhbmdlKS5jb25jYXQoZnJhbWVzLnNsaWNlKGxlbiAtIHJhbmdlKSk7XG4gIH1cbiAgcmV0dXJuIGZyYW1lcztcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGVGcmFtZXMocGF5bG9hZCwganNvbkJhY2t1cCwgcmFuZ2UpIHtcbiAgcmFuZ2UgPSB0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnID8gMzAgOiByYW5nZTtcbiAgdmFyIGJvZHkgPSBwYXlsb2FkLmRhdGEuYm9keTtcbiAgdmFyIGZyYW1lcztcbiAgaWYgKGJvZHkudHJhY2VfY2hhaW4pIHtcbiAgICB2YXIgY2hhaW4gPSBib2R5LnRyYWNlX2NoYWluO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lcyA9IGNoYWluW2ldLmZyYW1lcztcbiAgICAgIGZyYW1lcyA9IHNlbGVjdEZyYW1lcyhmcmFtZXMsIHJhbmdlKTtcbiAgICAgIGNoYWluW2ldLmZyYW1lcyA9IGZyYW1lcztcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm9keS50cmFjZSkge1xuICAgIGZyYW1lcyA9IGJvZHkudHJhY2UuZnJhbWVzO1xuICAgIGZyYW1lcyA9IHNlbGVjdEZyYW1lcyhmcmFtZXMsIHJhbmdlKTtcbiAgICBib2R5LnRyYWNlLmZyYW1lcyA9IGZyYW1lcztcbiAgfVxuICByZXR1cm4gW3BheWxvYWQsIF8uc3RyaW5naWZ5KHBheWxvYWQsIGpzb25CYWNrdXApXTtcbn1cblxuZnVuY3Rpb24gbWF5YmVUcnVuY2F0ZVZhbHVlKGxlbiwgdmFsKSB7XG4gIGlmICghdmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLmxlbmd0aCA+IGxlbikge1xuICAgIHJldHVybiB2YWwuc2xpY2UoMCwgbGVuIC0gMykuY29uY2F0KCcuLi4nKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVN0cmluZ3MobGVuLCBwYXlsb2FkLCBqc29uQmFja3VwKSB7XG4gIGZ1bmN0aW9uIHRydW5jYXRvcihrLCB2LCBzZWVuKSB7XG4gICAgc3dpdGNoIChfLnR5cGVOYW1lKHYpKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gbWF5YmVUcnVuY2F0ZVZhbHVlKGxlbiwgdik7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICByZXR1cm4gdHJhdmVyc2UodiwgdHJ1bmNhdG9yLCBzZWVuKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgfVxuICBwYXlsb2FkID0gdHJhdmVyc2UocGF5bG9hZCwgdHJ1bmNhdG9yKTtcbiAgcmV0dXJuIFtwYXlsb2FkLCBfLnN0cmluZ2lmeShwYXlsb2FkLCBqc29uQmFja3VwKV07XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlVHJhY2VEYXRhKHRyYWNlRGF0YSkge1xuICBpZiAodHJhY2VEYXRhLmV4Y2VwdGlvbikge1xuICAgIGRlbGV0ZSB0cmFjZURhdGEuZXhjZXB0aW9uLmRlc2NyaXB0aW9uO1xuICAgIHRyYWNlRGF0YS5leGNlcHRpb24ubWVzc2FnZSA9IG1heWJlVHJ1bmNhdGVWYWx1ZShcbiAgICAgIDI1NSxcbiAgICAgIHRyYWNlRGF0YS5leGNlcHRpb24ubWVzc2FnZSxcbiAgICApO1xuICB9XG4gIHRyYWNlRGF0YS5mcmFtZXMgPSBzZWxlY3RGcmFtZXModHJhY2VEYXRhLmZyYW1lcywgMSk7XG4gIHJldHVybiB0cmFjZURhdGE7XG59XG5cbmZ1bmN0aW9uIG1pbkJvZHkocGF5bG9hZCwganNvbkJhY2t1cCkge1xuICB2YXIgYm9keSA9IHBheWxvYWQuZGF0YS5ib2R5O1xuICBpZiAoYm9keS50cmFjZV9jaGFpbikge1xuICAgIHZhciBjaGFpbiA9IGJvZHkudHJhY2VfY2hhaW47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhaW5baV0gPSB0cnVuY2F0ZVRyYWNlRGF0YShjaGFpbltpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJvZHkudHJhY2UpIHtcbiAgICBib2R5LnRyYWNlID0gdHJ1bmNhdGVUcmFjZURhdGEoYm9keS50cmFjZSk7XG4gIH1cbiAgcmV0dXJuIFtwYXlsb2FkLCBfLnN0cmluZ2lmeShwYXlsb2FkLCBqc29uQmFja3VwKV07XG59XG5cbmZ1bmN0aW9uIG5lZWRzVHJ1bmNhdGlvbihwYXlsb2FkLCBtYXhTaXplKSB7XG4gIHJldHVybiBfLm1heEJ5dGVTaXplKHBheWxvYWQpID4gbWF4U2l6ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocGF5bG9hZCwganNvbkJhY2t1cCwgbWF4U2l6ZSkge1xuICBtYXhTaXplID0gdHlwZW9mIG1heFNpemUgPT09ICd1bmRlZmluZWQnID8gNTEyICogMTAyNCA6IG1heFNpemU7XG4gIHZhciBzdHJhdGVnaWVzID0gW1xuICAgIHJhdyxcbiAgICB0cnVuY2F0ZUZyYW1lcyxcbiAgICB0cnVuY2F0ZVN0cmluZ3MuYmluZChudWxsLCAxMDI0KSxcbiAgICB0cnVuY2F0ZVN0cmluZ3MuYmluZChudWxsLCA1MTIpLFxuICAgIHRydW5jYXRlU3RyaW5ncy5iaW5kKG51bGwsIDI1NiksXG4gICAgbWluQm9keSxcbiAgXTtcbiAgdmFyIHN0cmF0ZWd5LCByZXN1bHRzLCByZXN1bHQ7XG5cbiAgd2hpbGUgKChzdHJhdGVneSA9IHN0cmF0ZWdpZXMuc2hpZnQoKSkpIHtcbiAgICByZXN1bHRzID0gc3RyYXRlZ3kocGF5bG9hZCwganNvbkJhY2t1cCk7XG4gICAgcGF5bG9hZCA9IHJlc3VsdHNbMF07XG4gICAgcmVzdWx0ID0gcmVzdWx0c1sxXTtcbiAgICBpZiAocmVzdWx0LmVycm9yIHx8ICFuZWVkc1RydW5jYXRpb24ocmVzdWx0LnZhbHVlLCBtYXhTaXplKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRydW5jYXRlOiB0cnVuY2F0ZSxcblxuICAvKiBmb3IgdGVzdGluZyAqL1xuICByYXc6IHJhdyxcbiAgdHJ1bmNhdGVGcmFtZXM6IHRydW5jYXRlRnJhbWVzLFxuICB0cnVuY2F0ZVN0cmluZ3M6IHRydW5jYXRlU3RyaW5ncyxcbiAgbWF5YmVUcnVuY2F0ZVZhbHVlOiBtYXliZVRydW5jYXRlVmFsdWUsXG59O1xuIiwidmFyIG1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZScpO1xuXG52YXIgUm9sbGJhckpTT04gPSB7fTtcbmZ1bmN0aW9uIHNldHVwSlNPTihwb2x5ZmlsbEpTT04pIHtcbiAgaWYgKGlzRnVuY3Rpb24oUm9sbGJhckpTT04uc3RyaW5naWZ5KSAmJiBpc0Z1bmN0aW9uKFJvbGxiYXJKU09OLnBhcnNlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0RlZmluZWQoSlNPTikpIHtcbiAgICAvLyBJZiBwb2x5ZmlsbCBpcyBwcm92aWRlZCwgcHJlZmVyIGl0IG92ZXIgZXhpc3Rpbmcgbm9uLW5hdGl2ZSBzaGltcy5cbiAgICBpZiAocG9seWZpbGxKU09OKSB7XG4gICAgICBpZiAoaXNOYXRpdmVGdW5jdGlvbihKU09OLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgUm9sbGJhckpTT04uc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYXRpdmVGdW5jdGlvbihKU09OLnBhcnNlKSkge1xuICAgICAgICBSb2xsYmFySlNPTi5wYXJzZSA9IEpTT04ucGFyc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsc2UgYWNjZXB0IGFueSBpbnRlcmZhY2UgdGhhdCBpcyBwcmVzZW50LlxuICAgICAgaWYgKGlzRnVuY3Rpb24oSlNPTi5zdHJpbmdpZnkpKSB7XG4gICAgICAgIFJvbGxiYXJKU09OLnN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgICAgfVxuICAgICAgaWYgKGlzRnVuY3Rpb24oSlNPTi5wYXJzZSkpIHtcbiAgICAgICAgUm9sbGJhckpTT04ucGFyc2UgPSBKU09OLnBhcnNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRnVuY3Rpb24oUm9sbGJhckpTT04uc3RyaW5naWZ5KSB8fCAhaXNGdW5jdGlvbihSb2xsYmFySlNPTi5wYXJzZSkpIHtcbiAgICBwb2x5ZmlsbEpTT04gJiYgcG9seWZpbGxKU09OKFJvbGxiYXJKU09OKTtcbiAgfVxufVxuXG4vKlxuICogaXNUeXBlIC0gR2l2ZW4gYSBKYXZhc2NyaXB0IHZhbHVlIGFuZCBhIHN0cmluZywgcmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZVxuICogZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB4IC0gYW55IHZhbHVlXG4gKiBAcGFyYW0gdCAtIGEgbG93ZXJjYXNlIHN0cmluZyBjb250YWluaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIHR5cGUgbmFtZXM6XG4gKiAgICAtIHVuZGVmaW5lZFxuICogICAgLSBudWxsXG4gKiAgICAtIGVycm9yXG4gKiAgICAtIG51bWJlclxuICogICAgLSBib29sZWFuXG4gKiAgICAtIHN0cmluZ1xuICogICAgLSBzeW1ib2xcbiAqICAgIC0gZnVuY3Rpb25cbiAqICAgIC0gb2JqZWN0XG4gKiAgICAtIGFycmF5XG4gKiBAcmV0dXJucyB0cnVlIGlmIHggaXMgb2YgdHlwZSB0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNUeXBlKHgsIHQpIHtcbiAgcmV0dXJuIHQgPT09IHR5cGVOYW1lKHgpO1xufVxuXG4vKlxuICogdHlwZU5hbWUgLSBHaXZlbiBhIEphdmFzY3JpcHQgdmFsdWUsIHJldHVybnMgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCBhcyBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiB0eXBlTmFtZSh4KSB7XG4gIHZhciBuYW1lID0gdHlwZW9mIHg7XG4gIGlmIChuYW1lICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGlmICgheCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbiAgaWYgKHggaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG4gIHJldHVybiB7fS50b1N0cmluZ1xuICAgIC5jYWxsKHgpXG4gICAgLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qIGlzRnVuY3Rpb24gLSBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZiAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBmIGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIGlzVHlwZShmLCAnZnVuY3Rpb24nKTtcbn1cblxuLyogaXNOYXRpdmVGdW5jdGlvbiAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgYSBuYXRpdmUgSlMgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZiAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBmIGlzIGEgbmF0aXZlIEpTIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmVGdW5jdGlvbihmKSB7XG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG4gIHZhciBmdW5jTWF0Y2hTdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KVxuICAgIC5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpO1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jTWF0Y2hTdHJpbmcgKyAnJCcpO1xuICByZXR1cm4gaXNPYmplY3QoZikgJiYgcmVJc05hdGl2ZS50ZXN0KGYpO1xufVxuXG4vKiBpc09iamVjdCAtIENoZWNrcyBpZiB0aGUgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlzIHZhbHVlIGlzIGFuIG9iamVjdCBmdW5jdGlvbiBpcyBhbiBvYmplY3QpXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKiBpc1N0cmluZyAtIENoZWNrcyBpZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogaXNGaW5pdGVOdW1iZXIgLSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG4gLSBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGlzRmluaXRlTnVtYmVyKG4pIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShuKTtcbn1cblxuLypcbiAqIGlzRGVmaW5lZCAtIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB1IC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gaXNEZWZpbmVkKHUpIHtcbiAgcmV0dXJuICFpc1R5cGUodSwgJ3VuZGVmaW5lZCcpO1xufVxuXG4vKlxuICogaXNJdGVyYWJsZSAtIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGNhbiBiZSBpdGVyYXRlZCwgZXNzZW50aWFsbHlcbiAqIHdoZXRoZXIgaXQgaXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBpIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGkgaXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5IGFzIGRldGVybWluZWQgYnkgYHR5cGVOYW1lYFxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGkpIHtcbiAgdmFyIHR5cGUgPSB0eXBlTmFtZShpKTtcbiAgcmV0dXJuIHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdhcnJheSc7XG59XG5cbi8qXG4gKiBpc0Vycm9yIC0gY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgb2YgYW4gZXJyb3IgdHlwZVxuICpcbiAqIEBwYXJhbSBlIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGUgaXMgYW4gZXJyb3JcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIC8vIERldGVjdCBib3RoIEVycm9yIGFuZCBGaXJlZm94IEV4Y2VwdGlvbiB0eXBlXG4gIHJldHVybiBpc1R5cGUoZSwgJ2Vycm9yJykgfHwgaXNUeXBlKGUsICdleGNlcHRpb24nKTtcbn1cblxuLyogaXNQcm9taXNlIC0gYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBpcyBhIHByb21pc2VcbiAqXG4gKiBAcGFyYW0gcCAtIGFueSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiBmIGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UocCkge1xuICByZXR1cm4gaXNPYmplY3QocCkgJiYgaXNUeXBlKHAudGhlbiwgJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogaXNCcm93c2VyIC0gYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgdGhlIGNvZGUgaXMgcnVubmluZyBpbiBhIGJyb3dzZXJcbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjb2RlIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gKi9cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiByZWRhY3QoKSB7XG4gIHJldHVybiAnKioqKioqKionO1xufVxuXG4vLyBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MDk0NzIvMTEzODE5MVxuZnVuY3Rpb24gdXVpZDQoKSB7XG4gIHZhciBkID0gbm93KCk7XG4gIHZhciB1dWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZShcbiAgICAvW3h5XS9nLFxuICAgIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgICByZXR1cm4gKGMgPT09ICd4JyA/IHIgOiAociAmIDB4NykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICB9LFxuICApO1xuICByZXR1cm4gdXVpZDtcbn1cblxudmFyIExFVkVMUyA9IHtcbiAgZGVidWc6IDAsXG4gIGluZm86IDEsXG4gIHdhcm5pbmc6IDIsXG4gIGVycm9yOiAzLFxuICBjcml0aWNhbDogNCxcbn07XG5cbmZ1bmN0aW9uIHNhbml0aXplVXJsKHVybCkge1xuICB2YXIgYmFzZVVybFBhcnRzID0gcGFyc2VVcmkodXJsKTtcbiAgaWYgKCFiYXNlVXJsUGFydHMpIHtcbiAgICByZXR1cm4gJyh1bmtub3duKSc7XG4gIH1cblxuICAvLyByZW1vdmUgYSB0cmFpbGluZyAjIGlmIHRoZXJlIGlzIG5vIGFuY2hvclxuICBpZiAoYmFzZVVybFBhcnRzLmFuY2hvciA9PT0gJycpIHtcbiAgICBiYXNlVXJsUGFydHMuc291cmNlID0gYmFzZVVybFBhcnRzLnNvdXJjZS5yZXBsYWNlKCcjJywgJycpO1xuICB9XG5cbiAgdXJsID0gYmFzZVVybFBhcnRzLnNvdXJjZS5yZXBsYWNlKCc/JyArIGJhc2VVcmxQYXJ0cy5xdWVyeSwgJycpO1xuICByZXR1cm4gdXJsO1xufVxuXG52YXIgcGFyc2VVcmlPcHRpb25zID0ge1xuICBzdHJpY3RNb2RlOiBmYWxzZSxcbiAga2V5OiBbXG4gICAgJ3NvdXJjZScsXG4gICAgJ3Byb3RvY29sJyxcbiAgICAnYXV0aG9yaXR5JyxcbiAgICAndXNlckluZm8nLFxuICAgICd1c2VyJyxcbiAgICAncGFzc3dvcmQnLFxuICAgICdob3N0JyxcbiAgICAncG9ydCcsXG4gICAgJ3JlbGF0aXZlJyxcbiAgICAncGF0aCcsXG4gICAgJ2RpcmVjdG9yeScsXG4gICAgJ2ZpbGUnLFxuICAgICdxdWVyeScsXG4gICAgJ2FuY2hvcicsXG4gIF0sXG4gIHE6IHtcbiAgICBuYW1lOiAncXVlcnlLZXknLFxuICAgIHBhcnNlcjogLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nLFxuICB9LFxuICBwYXJzZXI6IHtcbiAgICBzdHJpY3Q6XG4gICAgICAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCgoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxuICAgIGxvb3NlOlxuICAgICAgL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxuICB9LFxufTtcblxuZnVuY3Rpb24gcGFyc2VVcmkoc3RyKSB7XG4gIGlmICghaXNUeXBlKHN0ciwgJ3N0cmluZycpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBvID0gcGFyc2VVcmlPcHRpb25zO1xuICB2YXIgbSA9IG8ucGFyc2VyW28uc3RyaWN0TW9kZSA/ICdzdHJpY3QnIDogJ2xvb3NlJ10uZXhlYyhzdHIpO1xuICB2YXIgdXJpID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvLmtleS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCAnJztcbiAgfVxuXG4gIHVyaVtvLnEubmFtZV0gPSB7fTtcbiAgdXJpW28ua2V5WzEyXV0ucmVwbGFjZShvLnEucGFyc2VyLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgIGlmICgkMSkge1xuICAgICAgdXJpW28ucS5uYW1lXVskMV0gPSAkMjtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIGFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoKGFjY2Vzc1Rva2VuLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMuYWNjZXNzX3Rva2VuID0gYWNjZXNzVG9rZW47XG4gIHZhciBwYXJhbXNBcnJheSA9IFtdO1xuICB2YXIgaztcbiAgZm9yIChrIGluIHBhcmFtcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBrKSkge1xuICAgICAgcGFyYW1zQXJyYXkucHVzaChbaywgcGFyYW1zW2tdXS5qb2luKCc9JykpO1xuICAgIH1cbiAgfVxuICB2YXIgcXVlcnkgPSAnPycgKyBwYXJhbXNBcnJheS5zb3J0KCkuam9pbignJicpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnBhdGggfHwgJyc7XG4gIHZhciBxcyA9IG9wdGlvbnMucGF0aC5pbmRleE9mKCc/Jyk7XG4gIHZhciBoID0gb3B0aW9ucy5wYXRoLmluZGV4T2YoJyMnKTtcbiAgdmFyIHA7XG4gIGlmIChxcyAhPT0gLTEgJiYgKGggPT09IC0xIHx8IGggPiBxcykpIHtcbiAgICBwID0gb3B0aW9ucy5wYXRoO1xuICAgIG9wdGlvbnMucGF0aCA9IHAuc3Vic3RyaW5nKDAsIHFzKSArIHF1ZXJ5ICsgJyYnICsgcC5zdWJzdHJpbmcocXMgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaCAhPT0gLTEpIHtcbiAgICAgIHAgPSBvcHRpb25zLnBhdGg7XG4gICAgICBvcHRpb25zLnBhdGggPSBwLnN1YnN0cmluZygwLCBoKSArIHF1ZXJ5ICsgcC5zdWJzdHJpbmcoaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMucGF0aCArIHF1ZXJ5O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRVcmwodSwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbCB8fCB1LnByb3RvY29sO1xuICBpZiAoIXByb3RvY29sICYmIHUucG9ydCkge1xuICAgIGlmICh1LnBvcnQgPT09IDgwKSB7XG4gICAgICBwcm90b2NvbCA9ICdodHRwOic7XG4gICAgfSBlbHNlIGlmICh1LnBvcnQgPT09IDQ0Mykge1xuICAgICAgcHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICB9XG4gIH1cbiAgcHJvdG9jb2wgPSBwcm90b2NvbCB8fCAnaHR0cHM6JztcblxuICBpZiAoIXUuaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAnLy8nICsgdS5ob3N0bmFtZTtcbiAgaWYgKHUucG9ydCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCArICc6JyArIHUucG9ydDtcbiAgfVxuICBpZiAodS5wYXRoKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgdS5wYXRoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIGJhY2t1cCkge1xuICB2YXIgdmFsdWUsIGVycm9yO1xuICB0cnkge1xuICAgIHZhbHVlID0gUm9sbGJhckpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gY2F0Y2ggKGpzb25FcnJvcikge1xuICAgIGlmIChiYWNrdXAgJiYgaXNGdW5jdGlvbihiYWNrdXApKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IGJhY2t1cChvYmopO1xuICAgICAgfSBjYXRjaCAoYmFja3VwRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBiYWNrdXBFcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBqc29uRXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGVycm9yOiBlcnJvciwgdmFsdWU6IHZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIG1heEJ5dGVTaXplKHN0cmluZykge1xuICAvLyBUaGUgdHJhbnNwb3J0IHdpbGwgdXNlIHV0Zi04LCBzbyBhc3N1bWUgdXRmLTggZW5jb2RpbmcuXG4gIC8vXG4gIC8vIFRoaXMgbWluaW1hbCBpbXBsZW1lbnRhdGlvbiB3aWxsIGFjY3VyYXRlbHkgY291bnQgYnl0ZXMgZm9yIGFsbCBVQ1MtMiBhbmRcbiAgLy8gc2luZ2xlIGNvZGUgcG9pbnQgVVRGLTE2LiBJZiBwcmVzZW50ZWQgd2l0aCBtdWx0aSBjb2RlIHBvaW50IFVURi0xNixcbiAgLy8gd2hpY2ggc2hvdWxkIGJlIHJhcmUsIGl0IHdpbGwgc2FmZWx5IG92ZXJjb3VudCwgbm90IHVuZGVyY291bnQuXG4gIC8vXG4gIC8vIFdoaWxlIHJvYnVzdCB1dGYtOCBlbmNvZGVycyBleGlzdCwgdGhpcyBpcyBmYXIgc21hbGxlciBhbmQgZmFyIG1vcmUgcGVyZm9ybWFudC5cbiAgLy8gRm9yIHF1aWNrbHkgY291bnRpbmcgcGF5bG9hZCBzaXplIGZvciB0cnVuY2F0aW9uLCBzbWFsbGVyIGlzIGJldHRlci5cblxuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDEyOCkge1xuICAgICAgLy8gdXAgdG8gNyBiaXRzXG4gICAgICBjb3VudCA9IGNvdW50ICsgMTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPCAyMDQ4KSB7XG4gICAgICAvLyB1cCB0byAxMSBiaXRzXG4gICAgICBjb3VudCA9IGNvdW50ICsgMjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPCA2NTUzNikge1xuICAgICAgLy8gdXAgdG8gMTYgYml0c1xuICAgICAgY291bnQgPSBjb3VudCArIDM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5mdW5jdGlvbiBqc29uUGFyc2Uocykge1xuICB2YXIgdmFsdWUsIGVycm9yO1xuICB0cnkge1xuICAgIHZhbHVlID0gUm9sbGJhckpTT04ucGFyc2Uocyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIHsgZXJyb3I6IGVycm9yLCB2YWx1ZTogdmFsdWUgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVVuaGFuZGxlZFN0YWNrSW5mbyhcbiAgbWVzc2FnZSxcbiAgdXJsLFxuICBsaW5lbm8sXG4gIGNvbG5vLFxuICBlcnJvcixcbiAgbW9kZSxcbiAgYmFja3VwTWVzc2FnZSxcbiAgZXJyb3JQYXJzZXIsXG4pIHtcbiAgdmFyIGxvY2F0aW9uID0ge1xuICAgIHVybDogdXJsIHx8ICcnLFxuICAgIGxpbmU6IGxpbmVubyxcbiAgICBjb2x1bW46IGNvbG5vLFxuICB9O1xuICBsb2NhdGlvbi5mdW5jID0gZXJyb3JQYXJzZXIuZ3Vlc3NGdW5jdGlvbk5hbWUobG9jYXRpb24udXJsLCBsb2NhdGlvbi5saW5lKTtcbiAgbG9jYXRpb24uY29udGV4dCA9IGVycm9yUGFyc2VyLmdhdGhlckNvbnRleHQobG9jYXRpb24udXJsLCBsb2NhdGlvbi5saW5lKTtcbiAgdmFyIGhyZWYgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBkb2N1bWVudCAmJlxuICAgIGRvY3VtZW50LmxvY2F0aW9uICYmXG4gICAgZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgdmFyIHVzZXJhZ2VudCA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB3aW5kb3cgJiZcbiAgICB3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHJldHVybiB7XG4gICAgbW9kZTogbW9kZSxcbiAgICBtZXNzYWdlOiBlcnJvciA/IFN0cmluZyhlcnJvcikgOiBtZXNzYWdlIHx8IGJhY2t1cE1lc3NhZ2UsXG4gICAgdXJsOiBocmVmLFxuICAgIHN0YWNrOiBbbG9jYXRpb25dLFxuICAgIHVzZXJhZ2VudDogdXNlcmFnZW50LFxuICB9O1xufVxuXG5mdW5jdGlvbiB3cmFwQ2FsbGJhY2sobG9nZ2VyLCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGYoZXJyLCByZXNwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBub25DaXJjdWxhckNsb25lKG9iaikge1xuICB2YXIgc2VlbiA9IFtvYmpdO1xuXG4gIGZ1bmN0aW9uIGNsb25lKG9iaiwgc2Vlbikge1xuICAgIHZhciB2YWx1ZSxcbiAgICAgIG5hbWUsXG4gICAgICBuZXdTZWVuLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgKGlzVHlwZSh2YWx1ZSwgJ29iamVjdCcpIHx8IGlzVHlwZSh2YWx1ZSwgJ2FycmF5JykpKSB7XG4gICAgICAgICAgaWYgKHNlZW4uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSAnUmVtb3ZlZCBjaXJjdWxhciByZWZlcmVuY2U6ICcgKyB0eXBlTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NlZW4gPSBzZWVuLnNsaWNlKCk7XG4gICAgICAgICAgICBuZXdTZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gY2xvbmUodmFsdWUsIG5ld1NlZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9ICdGYWlsZWQgY2xvbmluZyBjdXN0b20gZGF0YTogJyArIGUubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gY2xvbmUob2JqLCBzZWVuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSXRlbShhcmdzLCBsb2dnZXIsIG5vdGlmaWVyLCByZXF1ZXN0S2V5cywgbGFtYmRhQ29udGV4dCkge1xuICB2YXIgbWVzc2FnZSwgZXJyLCBjdXN0b20sIGNhbGxiYWNrLCByZXF1ZXN0O1xuICB2YXIgYXJnO1xuICB2YXIgZXh0cmFBcmdzID0gW107XG4gIHZhciBkaWFnbm9zdGljID0ge307XG4gIHZhciBhcmdUeXBlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBhcmcgPSBhcmdzW2ldO1xuXG4gICAgdmFyIHR5cCA9IHR5cGVOYW1lKGFyZyk7XG4gICAgYXJnVHlwZXMucHVzaCh0eXApO1xuICAgIHN3aXRjaCAodHlwKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIG1lc3NhZ2UgPyBleHRyYUFyZ3MucHVzaChhcmcpIDogKG1lc3NhZ2UgPSBhcmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgY2FsbGJhY2sgPSB3cmFwQ2FsbGJhY2sobG9nZ2VyLCBhcmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICBleHRyYUFyZ3MucHVzaChhcmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIGNhc2UgJ2RvbWV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdleGNlcHRpb24nOiAvLyBGaXJlZm94IEV4Y2VwdGlvbiB0eXBlXG4gICAgICAgIGVyciA/IGV4dHJhQXJncy5wdXNoKGFyZykgOiAoZXJyID0gYXJnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXJnIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgICAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICBlcnIgPyBleHRyYUFyZ3MucHVzaChhcmcpIDogKGVyciA9IGFyZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RLZXlzICYmIHR5cCA9PT0gJ29iamVjdCcgJiYgIXJlcXVlc3QpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gcmVxdWVzdEtleXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgIGlmIChhcmdbcmVxdWVzdEtleXNbal1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IGFyZztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VzdG9tID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IChjdXN0b20gPSBhcmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhcmcgaW5zdGFuY2VvZiBFcnJvciB8fFxuICAgICAgICAgICh0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBhcmcgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgIGVyciA/IGV4dHJhQXJncy5wdXNoKGFyZykgOiAoZXJyID0gYXJnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBleHRyYUFyZ3MucHVzaChhcmcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGN1c3RvbSBpcyBhbiBhcnJheSB0aGlzIHR1cm5zIGl0IGludG8gYW4gb2JqZWN0IHdpdGggaW50ZWdlciBrZXlzXG4gIGlmIChjdXN0b20pIGN1c3RvbSA9IG5vbkNpcmN1bGFyQ2xvbmUoY3VzdG9tKTtcblxuICBpZiAoZXh0cmFBcmdzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIWN1c3RvbSkgY3VzdG9tID0gbm9uQ2lyY3VsYXJDbG9uZSh7fSk7XG4gICAgY3VzdG9tLmV4dHJhQXJncyA9IG5vbkNpcmN1bGFyQ2xvbmUoZXh0cmFBcmdzKTtcbiAgfVxuXG4gIHZhciBpdGVtID0ge1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgZXJyOiBlcnIsXG4gICAgY3VzdG9tOiBjdXN0b20sXG4gICAgdGltZXN0YW1wOiBub3coKSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgbm90aWZpZXI6IG5vdGlmaWVyLFxuICAgIGRpYWdub3N0aWM6IGRpYWdub3N0aWMsXG4gICAgdXVpZDogdXVpZDQoKSxcbiAgfTtcblxuICBpdGVtLmRhdGEgPSBpdGVtLmRhdGEgfHwge307XG5cbiAgc2V0Q3VzdG9tSXRlbUtleXMoaXRlbSwgY3VzdG9tKTtcblxuICBpZiAocmVxdWVzdEtleXMgJiYgcmVxdWVzdCkge1xuICAgIGl0ZW0ucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIH1cbiAgaWYgKGxhbWJkYUNvbnRleHQpIHtcbiAgICBpdGVtLmxhbWJkYUNvbnRleHQgPSBsYW1iZGFDb250ZXh0O1xuICB9XG4gIGl0ZW0uX29yaWdpbmFsQXJncyA9IGFyZ3M7XG4gIGl0ZW0uZGlhZ25vc3RpYy5vcmlnaW5hbF9hcmdfdHlwZXMgPSBhcmdUeXBlcztcbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIHNldEN1c3RvbUl0ZW1LZXlzKGl0ZW0sIGN1c3RvbSkge1xuICBpZiAoY3VzdG9tICYmIGN1c3RvbS5sZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaXRlbS5sZXZlbCA9IGN1c3RvbS5sZXZlbDtcbiAgICBkZWxldGUgY3VzdG9tLmxldmVsO1xuICB9XG4gIGlmIChjdXN0b20gJiYgY3VzdG9tLnNraXBGcmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGl0ZW0uc2tpcEZyYW1lcyA9IGN1c3RvbS5za2lwRnJhbWVzO1xuICAgIGRlbGV0ZSBjdXN0b20uc2tpcEZyYW1lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFcnJvckNvbnRleHQoaXRlbSwgZXJyb3JzKSB7XG4gIHZhciBjdXN0b20gPSBpdGVtLmRhdGEuY3VzdG9tIHx8IHt9O1xuICB2YXIgY29udGV4dEFkZGVkID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGVycm9yc1tpXS5oYXNPd25Qcm9wZXJ0eSgncm9sbGJhckNvbnRleHQnKSkge1xuICAgICAgICBjdXN0b20gPSBtZXJnZShjdXN0b20sIG5vbkNpcmN1bGFyQ2xvbmUoZXJyb3JzW2ldLnJvbGxiYXJDb250ZXh0KSk7XG4gICAgICAgIGNvbnRleHRBZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYWRkaW5nIGFuIGVtcHR5IG9iamVjdCB0byB0aGUgZGF0YS5cbiAgICBpZiAoY29udGV4dEFkZGVkKSB7XG4gICAgICBpdGVtLmRhdGEuY3VzdG9tID0gY3VzdG9tO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGl0ZW0uZGlhZ25vc3RpYy5lcnJvcl9jb250ZXh0ID0gJ0ZhaWxlZDogJyArIGUubWVzc2FnZTtcbiAgfVxufVxuXG52YXIgVEVMRU1FVFJZX1RZUEVTID0gW1xuICAnbG9nJyxcbiAgJ25ldHdvcmsnLFxuICAnZG9tJyxcbiAgJ25hdmlnYXRpb24nLFxuICAnZXJyb3InLFxuICAnbWFudWFsJyxcbl07XG52YXIgVEVMRU1FVFJZX0xFVkVMUyA9IFsnY3JpdGljYWwnLCAnZXJyb3InLCAnd2FybmluZycsICdpbmZvJywgJ2RlYnVnJ107XG5cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnIubGVuZ3RoOyArK2spIHtcbiAgICBpZiAoYXJyW2tdID09PSB2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGVsZW1ldHJ5RXZlbnQoYXJncykge1xuICB2YXIgdHlwZSwgbWV0YWRhdGEsIGxldmVsO1xuICB2YXIgYXJnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBhcmcgPSBhcmdzW2ldO1xuXG4gICAgdmFyIHR5cCA9IHR5cGVOYW1lKGFyZyk7XG4gICAgc3dpdGNoICh0eXApIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGlmICghdHlwZSAmJiBhcnJheUluY2x1ZGVzKFRFTEVNRVRSWV9UWVBFUywgYXJnKSkge1xuICAgICAgICAgIHR5cGUgPSBhcmc7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxldmVsICYmIGFycmF5SW5jbHVkZXMoVEVMRU1FVFJZX0xFVkVMUywgYXJnKSkge1xuICAgICAgICAgIGxldmVsID0gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgbWV0YWRhdGEgPSBhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBldmVudCA9IHtcbiAgICB0eXBlOiB0eXBlIHx8ICdtYW51YWwnLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YSB8fCB7fSxcbiAgICBsZXZlbDogbGV2ZWwsXG4gIH07XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBhZGRJdGVtQXR0cmlidXRlcyhpdGVtLCBhdHRyaWJ1dGVzKSB7XG4gIGl0ZW0uZGF0YS5hdHRyaWJ1dGVzID0gaXRlbS5kYXRhLmF0dHJpYnV0ZXMgfHwgW107XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaXRlbS5kYXRhLmF0dHJpYnV0ZXMucHVzaCguLi5hdHRyaWJ1dGVzKTtcbiAgfVxufVxuXG4vKlxuICogZ2V0IC0gZ2l2ZW4gYW4gb2JqL2FycmF5IGFuZCBhIGtleXBhdGgsIHJldHVybiB0aGUgdmFsdWUgYXQgdGhhdCBrZXlwYXRoIG9yXG4gKiAgICAgICB1bmRlZmluZWQgaWYgbm90IHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb3IgYXJyYXlcbiAqIEBwYXJhbSBwYXRoIC0gYSBzdHJpbmcgb2Yga2V5cyBzZXBhcmF0ZWQgYnkgJy4nIHN1Y2ggYXMgJ3BsdWdpbi5qcXVlcnkuMC5tZXNzYWdlJ1xuICogICAgd2hpY2ggd291bGQgY29ycmVzcG9uZCB0byA0MiBpbiBge3BsdWdpbjoge2pxdWVyeTogW3ttZXNzYWdlOiA0Mn1dfX1gXG4gKi9cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgcmVzdWx0ID0gb2JqO1xuICB0cnkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRba2V5c1tpXV07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNldChvYmosIHBhdGgsIHZhbHVlKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW4gPCAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChsZW4gPT09IDEpIHtcbiAgICBvYmpba2V5c1swXV0gPSB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgdGVtcCA9IG9ialtrZXlzWzBdXSB8fCB7fTtcbiAgICB2YXIgcmVwbGFjZW1lbnQgPSB0ZW1wO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICB0ZW1wW2tleXNbaV1dID0gdGVtcFtrZXlzW2ldXSB8fCB7fTtcbiAgICAgIHRlbXAgPSB0ZW1wW2tleXNbaV1dO1xuICAgIH1cbiAgICB0ZW1wW2tleXNbbGVuIC0gMV1dID0gdmFsdWU7XG4gICAgb2JqW2tleXNbMF1dID0gcmVwbGFjZW1lbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJnc0FzU3RyaW5nKGFyZ3MpIHtcbiAgdmFyIGksIGxlbiwgYXJnO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAoaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcmcgPSBhcmdzW2ldO1xuICAgIHN3aXRjaCAodHlwZU5hbWUoYXJnKSkge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgYXJnID0gc3RyaW5naWZ5KGFyZyk7XG4gICAgICAgIGFyZyA9IGFyZy5lcnJvciB8fCBhcmcudmFsdWU7XG4gICAgICAgIGlmIChhcmcubGVuZ3RoID4gNTAwKSB7XG4gICAgICAgICAgYXJnID0gYXJnLnN1YnN0cigwLCA0OTcpICsgJy4uLic7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgYXJnID0gJ251bGwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGFyZyA9ICd1bmRlZmluZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIGFyZyA9IGFyZy50b1N0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goYXJnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gbm93KCkge1xuICBpZiAoRGF0ZS5ub3cpIHtcbiAgICByZXR1cm4gK0RhdGUubm93KCk7XG4gIH1cbiAgcmV0dXJuICtuZXcgRGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJJcChyZXF1ZXN0RGF0YSwgY2FwdHVyZUlwKSB7XG4gIGlmICghcmVxdWVzdERhdGEgfHwgIXJlcXVlc3REYXRhWyd1c2VyX2lwJ10gfHwgY2FwdHVyZUlwID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdJcCA9IHJlcXVlc3REYXRhWyd1c2VyX2lwJ107XG4gIGlmICghY2FwdHVyZUlwKSB7XG4gICAgbmV3SXAgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcGFydHM7XG4gICAgICBpZiAobmV3SXAuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICBwYXJ0cyA9IG5ld0lwLnNwbGl0KCcuJyk7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBwYXJ0cy5wdXNoKCcwJyk7XG4gICAgICAgIG5ld0lwID0gcGFydHMuam9pbignLicpO1xuICAgICAgfSBlbHNlIGlmIChuZXdJcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIHBhcnRzID0gbmV3SXAuc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgYmVnaW5uaW5nID0gcGFydHMuc2xpY2UoMCwgMyk7XG4gICAgICAgICAgdmFyIHNsYXNoSWR4ID0gYmVnaW5uaW5nWzJdLmluZGV4T2YoJy8nKTtcbiAgICAgICAgICBpZiAoc2xhc2hJZHggIT09IC0xKSB7XG4gICAgICAgICAgICBiZWdpbm5pbmdbMl0gPSBiZWdpbm5pbmdbMl0uc3Vic3RyaW5nKDAsIHNsYXNoSWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRlcm1pbmFsID0gJzAwMDA6MDAwMDowMDAwOjAwMDA6MDAwMCc7XG4gICAgICAgICAgbmV3SXAgPSBiZWdpbm5pbmcuY29uY2F0KHRlcm1pbmFsKS5qb2luKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0lwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdJcCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlcXVlc3REYXRhWyd1c2VyX2lwJ10gPSBuZXdJcDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3B0aW9ucyhjdXJyZW50LCBpbnB1dCwgcGF5bG9hZCwgbG9nZ2VyKSB7XG4gIHZhciByZXN1bHQgPSBtZXJnZShjdXJyZW50LCBpbnB1dCwgcGF5bG9hZCk7XG4gIHJlc3VsdCA9IHVwZGF0ZURlcHJlY2F0ZWRPcHRpb25zKHJlc3VsdCwgbG9nZ2VyKTtcbiAgaWYgKCFpbnB1dCB8fCBpbnB1dC5vdmVyd3JpdGVTY3J1YkZpZWxkcykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGlucHV0LnNjcnViRmllbGRzKSB7XG4gICAgcmVzdWx0LnNjcnViRmllbGRzID0gKGN1cnJlbnQuc2NydWJGaWVsZHMgfHwgW10pLmNvbmNhdChpbnB1dC5zY3J1YkZpZWxkcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVwcmVjYXRlZE9wdGlvbnMob3B0aW9ucywgbG9nZ2VyKSB7XG4gIGlmIChvcHRpb25zLmhvc3RXaGl0ZUxpc3QgJiYgIW9wdGlvbnMuaG9zdFNhZmVMaXN0KSB7XG4gICAgb3B0aW9ucy5ob3N0U2FmZUxpc3QgPSBvcHRpb25zLmhvc3RXaGl0ZUxpc3Q7XG4gICAgb3B0aW9ucy5ob3N0V2hpdGVMaXN0ID0gdW5kZWZpbmVkO1xuICAgIGxvZ2dlciAmJiBsb2dnZXIubG9nKCdob3N0V2hpdGVMaXN0IGlzIGRlcHJlY2F0ZWQuIFVzZSBob3N0U2FmZUxpc3QuJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaG9zdEJsYWNrTGlzdCAmJiAhb3B0aW9ucy5ob3N0QmxvY2tMaXN0KSB7XG4gICAgb3B0aW9ucy5ob3N0QmxvY2tMaXN0ID0gb3B0aW9ucy5ob3N0QmxhY2tMaXN0O1xuICAgIG9wdGlvbnMuaG9zdEJsYWNrTGlzdCA9IHVuZGVmaW5lZDtcbiAgICBsb2dnZXIgJiYgbG9nZ2VyLmxvZygnaG9zdEJsYWNrTGlzdCBpcyBkZXByZWNhdGVkLiBVc2UgaG9zdEJsb2NrTGlzdC4nKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoOiBhZGRQYXJhbXNBbmRBY2Nlc3NUb2tlblRvUGF0aCxcbiAgY3JlYXRlSXRlbTogY3JlYXRlSXRlbSxcbiAgYWRkRXJyb3JDb250ZXh0OiBhZGRFcnJvckNvbnRleHQsXG4gIGNyZWF0ZVRlbGVtZXRyeUV2ZW50OiBjcmVhdGVUZWxlbWV0cnlFdmVudCxcbiAgYWRkSXRlbUF0dHJpYnV0ZXM6IGFkZEl0ZW1BdHRyaWJ1dGVzLFxuICBmaWx0ZXJJcDogZmlsdGVySXAsXG4gIGZvcm1hdEFyZ3NBc1N0cmluZzogZm9ybWF0QXJnc0FzU3RyaW5nLFxuICBmb3JtYXRVcmw6IGZvcm1hdFVybCxcbiAgZ2V0OiBnZXQsXG4gIGhhbmRsZU9wdGlvbnM6IGhhbmRsZU9wdGlvbnMsXG4gIGlzRXJyb3I6IGlzRXJyb3IsXG4gIGlzRmluaXRlTnVtYmVyOiBpc0Zpbml0ZU51bWJlcixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNJdGVyYWJsZTogaXNJdGVyYWJsZSxcbiAgaXNOYXRpdmVGdW5jdGlvbjogaXNOYXRpdmVGdW5jdGlvbixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzVHlwZTogaXNUeXBlLFxuICBpc1Byb21pc2U6IGlzUHJvbWlzZSxcbiAgaXNCcm93c2VyOiBpc0Jyb3dzZXIsXG4gIGpzb25QYXJzZToganNvblBhcnNlLFxuICBMRVZFTFM6IExFVkVMUyxcbiAgbWFrZVVuaGFuZGxlZFN0YWNrSW5mbzogbWFrZVVuaGFuZGxlZFN0YWNrSW5mbyxcbiAgbWVyZ2U6IG1lcmdlLFxuICBub3c6IG5vdyxcbiAgcmVkYWN0OiByZWRhY3QsXG4gIFJvbGxiYXJKU09OOiBSb2xsYmFySlNPTixcbiAgc2FuaXRpemVVcmw6IHNhbml0aXplVXJsLFxuICBzZXQ6IHNldCxcbiAgc2V0dXBKU09OOiBzZXR1cEpTT04sXG4gIHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuICBtYXhCeXRlU2l6ZTogbWF4Qnl0ZVNpemUsXG4gIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgdXVpZDQ6IHV1aWQ0LFxufTtcbiIsIi8qXG4gKiBoZWFkZXJzIC0gRGV0ZWN0IHdoZW4gZmV0Y2ggSGVhZGVycyBhcmUgdW5kZWZpbmVkIGFuZCB1c2UgYSBwYXJ0aWFsIHBvbHlmaWxsLlxuICpcbiAqIEEgZnVsbCBwb2x5ZmlsbCBpcyBub3QgdXNlZCBpbiBvcmRlciB0byBrZWVwIHBhY2thZ2Ugc2l6ZSBhcyBzbWFsbCBhcyBwb3NzaWJsZS5cbiAqIFNpbmNlIHRoaXMgaXMgb25seSB1c2VkIGludGVybmFsbHkgYW5kIGlzIG5vdCBhZGRlZCB0byB0aGUgd2luZG93IG9iamVjdCxcbiAqIHRoZSBmdWxsIGludGVyZmFjZSBkb2Vzbid0IG5lZWQgdG8gYmUgc3VwcG9ydGVkLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgbW9kaWZpZWQgZnJvbSB3aGF0d2ctZmV0Y2g6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoXG4gKi9cbmZ1bmN0aW9uIGhlYWRlcnMoaGVhZGVycykge1xuICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaEhlYWRlcnMoaGVhZGVycyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIEZldGNoSGVhZGVycyhoZWFkZXJzKSB7XG4gIHRoaXMubWFwID0ge307XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBGZXRjaEhlYWRlcnMpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSk7XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgIH0sIHRoaXMpO1xuICB9XG59XG5cbkZldGNoSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07XG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xufTtcblxuRmV0Y2hIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsO1xufTtcblxuRmV0Y2hIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSk7XG59O1xuXG5GZXRjaEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG5GZXRjaEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhlYWRlcnM7XG4iLCJ2YXIgcG9seWZpbGxKU09OID0gcmVxdWlyZSgnLi4vLi4vdmVuZG9yL0pTT04tanMvanNvbjMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbEpTT047XG4iLCJmdW5jdGlvbiByZXBsYWNlKG9iaiwgbmFtZSwgcmVwbGFjZW1lbnQsIHJlcGxhY2VtZW50cywgdHlwZSkge1xuICB2YXIgb3JpZyA9IG9ialtuYW1lXTtcbiAgb2JqW25hbWVdID0gcmVwbGFjZW1lbnQob3JpZyk7XG4gIGlmIChyZXBsYWNlbWVudHMpIHtcbiAgICByZXBsYWNlbWVudHNbdHlwZV0ucHVzaChbb2JqLCBuYW1lLCBvcmlnXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXBsYWNlO1xuIiwidmFyIF8gPSByZXF1aXJlKCcuLi91dGlsaXR5Jyk7XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKG9iaiwgZnVuYywgc2Vlbikge1xuICB2YXIgaywgdiwgaTtcbiAgdmFyIGlzT2JqID0gXy5pc1R5cGUob2JqLCAnb2JqZWN0Jyk7XG4gIHZhciBpc0FycmF5ID0gXy5pc1R5cGUob2JqLCAnYXJyYXknKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHNlZW5JbmRleDtcblxuICAvLyBCZXN0IG1pZ2h0IGJlIHRvIHVzZSBNYXAgaGVyZSB3aXRoIGBvYmpgIGFzIHRoZSBrZXlzLCBidXQgd2Ugd2FudCB0byBzdXBwb3J0IElFIDwgMTEuXG4gIHNlZW4gPSBzZWVuIHx8IHsgb2JqOiBbXSwgbWFwcGVkOiBbXSB9O1xuXG4gIGlmIChpc09iaikge1xuICAgIHNlZW5JbmRleCA9IHNlZW4ub2JqLmluZGV4T2Yob2JqKTtcblxuICAgIGlmIChpc09iaiAmJiBzZWVuSW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBQcmVmZXIgdGhlIG1hcHBlZCBvYmplY3QgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgcmV0dXJuIHNlZW4ubWFwcGVkW3NlZW5JbmRleF0gfHwgc2Vlbi5vYmpbc2VlbkluZGV4XTtcbiAgICB9XG5cbiAgICBzZWVuLm9iai5wdXNoKG9iaik7XG4gICAgc2VlbkluZGV4ID0gc2Vlbi5vYmoubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGlmIChpc09iaikge1xuICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXlzLnB1c2goaSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGlzT2JqID8ge30gOiBbXTtcbiAgdmFyIHNhbWUgPSB0cnVlO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGsgPSBrZXlzW2ldO1xuICAgIHYgPSBvYmpba107XG4gICAgcmVzdWx0W2tdID0gZnVuYyhrLCB2LCBzZWVuKTtcbiAgICBzYW1lID0gc2FtZSAmJiByZXN1bHRba10gPT09IG9ialtrXTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhc2FtZSkge1xuICAgIHNlZW4ubWFwcGVkW3NlZW5JbmRleF0gPSByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gIXNhbWUgPyByZXN1bHQgOiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2U7XG4iLCIvLyAganNvbjMuanNcbi8vICAyMDE3LTAyLTIxXG4vLyAgUHVibGljIERvbWFpbi5cbi8vICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG4vLyAgU2VlIGh0dHA6Ly93d3cuSlNPTi5vcmcvanMuaHRtbFxuLy8gIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4vLyAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4vLyAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbi8vICBOT1QgQ09OVFJPTC5cblxuLy8gIFRoaXMgZmlsZSBjcmVhdGVzIGEgZ2xvYmFsIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIG1ldGhvZHM6IHN0cmluZ2lmeVxuLy8gIGFuZCBwYXJzZS4gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBFUzUgSlNPTiBjYXBhYmlsaXR5IHRvIEVTMyBzeXN0ZW1zLlxuLy8gIElmIGEgcHJvamVjdCBtaWdodCBydW4gb24gSUU4IG9yIGVhcmxpZXIsIHRoZW4gdGhpcyBmaWxlIHNob3VsZCBiZSBpbmNsdWRlZC5cbi8vICBUaGlzIGZpbGUgZG9lcyBub3RoaW5nIG9uIEVTNSBzeXN0ZW1zLlxuXG4vLyAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4vLyAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4vLyAgICAgICAgICByZXBsYWNlciAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZXRlcm1pbmVzIGhvdyBvYmplY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG4vLyAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuLy8gICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuLy8gICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbi8vICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuLy8gICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4vLyAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgXCJcXHRcIiBvciBcIiZuYnNwO1wiKSxcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG4vLyAgICAgICAgICBUaGlzIG1ldGhvZCBwcm9kdWNlcyBhIEpTT04gdGV4dCBmcm9tIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbi8vICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4vLyAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuLy8gICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuLy8gICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4vLyAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbi8vICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZS5cblxuLy8gICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4vLyAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuLy8gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG4gPCAxMClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiMFwiICsgblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgIDogbjtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgXCJUXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArIFwiOlwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgXCJaXCI7XG4vLyAgICAgICAgICAgICAgfTtcblxuLy8gICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4vLyAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbi8vICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4vLyAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbi8vICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbi8vICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4vLyAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4vLyAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuLy8gICAgICAgICAgc3RyaW5naWZpZWQuXG5cbi8vICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuLy8gICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbi8vICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuLy8gICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG5cbi8vICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbi8vICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4vLyAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4vLyAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuLy8gICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuLy8gICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbi8vICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbXCJlXCIsIHtwbHVyaWJ1czogXCJ1bnVtXCJ9XSk7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0sIG51bGwsIFwiXFx0XCIpO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1xcblxcdFwiZVwiLFxcblxcdHtcXG5cXHRcXHRcInBsdXJpYnVzXCI6IFwidW51bVwiXFxuXFx0fVxcbl0nXG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbbmV3IERhdGUoKV0sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGVcbi8vICAgICAgICAgICAgICAgICAgPyBcIkRhdGUoXCIgKyB0aGlzW2tleV0gKyBcIilcIlxuLy8gICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cbi8vICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuLy8gICAgICAgICAgVGhpcyBoYXMgYmVlbiBtb2RpZmllZCB0byB1c2UgSlNPTi1qcy9qc29uX3BhcnNlX3N0YXRlLmpzIGFzIHRoZVxuLy8gICAgICAgICAgcGFyc2VyIGluc3RlYWQgb2YgdGhlIG9uZSBidWlsdCBhcm91bmQgZXZhbCBmb3VuZCBpbiBKU09OLWpzL2pzb24yLmpzXG5cbi8vICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbi8vICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuLy8gICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbi8vICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbi8vICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuLy8gICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuLy8gICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBhO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgYSA9XG4vLyAgIC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuLy8gICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbi8vICAgICAgICAgICAgICB2YXIgZDtcbi8vICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gXCJEYXRlKFwiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgtMSkgPT09IFwiKVwiKSB7XG4vLyAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuLy8gICAgICAgICAgICAgICAgICBpZiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICBUaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLiBZb3UgYXJlIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBvclxuLy8gIHJlZGlzdHJpYnV0ZS5cblxuLypqc2xpbnRcbiAgZm9yLCB0aGlzXG4gICovXG5cbi8qcHJvcGVydHlcbiAgSlNPTiwgYXBwbHksIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuICAqL1xuXG52YXIgc2V0dXBDdXN0b21KU09OID0gZnVuY3Rpb24oSlNPTikge1xuXG4gIHZhciByeF9vbmUgPSAvXltcXF0sOnt9XFxzXSokLztcbiAgdmFyIHJ4X3R3byA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG4gIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgdmFyIHJ4X2ZvdXIgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG4gIHZhciByeF9lc2NhcGFibGUgPSAvW1xcXFxcIlxcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgZnVuY3Rpb24gZihuKSB7XG4gICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICByZXR1cm4gbiA8IDEwXG4gICAgICA/IFwiMFwiICsgblxuICAgICAgOiBuO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhpc192YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSlcbiAgICAgICAgPyB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXG4gICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4gICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArXG4gICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICsgXCI6XCIgK1xuICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuXG4gICAgQm9vbGVhbi5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICB9XG5cbiAgdmFyIGdhcDtcbiAgdmFyIGluZGVudDtcbiAgdmFyIG1ldGE7XG4gIHZhciByZXA7XG5cblxuICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cblxuICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiByeF9lc2NhcGFibGUudGVzdChzdHJpbmcpXG4gICAgICA/IFwiXFxcIlwiICsgc3RyaW5nLnJlcGxhY2UocnhfZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgID8gY1xuICAgICAgICAgIDogXCJcXFxcdVwiICsgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgfSkgKyBcIlxcXCJcIlxuICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICB2YXIgaTsgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICB2YXIgazsgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgdmFyIGxlbmd0aDtcbiAgICB2YXIgbWluZCA9IGdhcDtcbiAgICB2YXIgcGFydGlhbDtcbiAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4gICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSlcbiAgICAgICAgICA/IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICA6IFwibnVsbFwiO1xuXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcIm51bGxcIjpcblxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgXCJudWxsXCIuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyBcIm9iamVjdFwiLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4gICAgICAgIC8vIG51bGwuXG5cbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcblxuICAgICAgICAvLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbiAgICAgICAgLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG5cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICBwYXJ0aWFsID0gW107XG5cbiAgICAgICAgLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cbiAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8IFwibnVsbFwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4gICAgICAgICAgLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gXCJbXVwiXG4gICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgPyBcIltcXG5cIiArIGdhcCArIHBhcnRpYWwuam9pbihcIixcXG5cIiArIGdhcCkgKyBcIlxcblwiICsgbWluZCArIFwiXVwiXG4gICAgICAgICAgICA6IFwiW1wiICsgcGFydGlhbC5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCI6XCJcbiAgICAgICAgICAgICAgICAgICAgICApICsgdik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgIGdhcFxuICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICA6IGdhcFxuICAgICAgICAgID8gXCJ7XFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIn1cIlxuICAgICAgICAgIDogXCJ7XCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHN0cmluZ2lmeSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gIGlmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICBcIlxcYlwiOiBcIlxcXFxiXCIsXG4gICAgICBcIlxcdFwiOiBcIlxcXFx0XCIsXG4gICAgICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gICAgICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gICAgICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gICAgICBcIlxcXCJcIjogXCJcXFxcXFxcIlwiLFxuICAgICAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxuICAgIH07XG4gICAgSlNPTi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuXG4gICAgICAvLyBUaGUgc3RyaW5naWZ5IG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCByZXBsYWNlciwgYW5kIGFuIG9wdGlvbmFsXG4gICAgICAvLyBzcGFjZSBwYXJhbWV0ZXIsIGFuZCByZXR1cm5zIGEgSlNPTiB0ZXh0LiBUaGUgcmVwbGFjZXIgY2FuIGJlIGEgZnVuY3Rpb25cbiAgICAgIC8vIHRoYXQgY2FuIHJlcGxhY2UgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGtleXMuXG4gICAgICAvLyBBIGRlZmF1bHQgcmVwbGFjZXIgbWV0aG9kIGNhbiBiZSBwcm92aWRlZC4gVXNlIG9mIHRoZSBzcGFjZSBwYXJhbWV0ZXIgY2FuXG4gICAgICAvLyBwcm9kdWNlIHRleHQgdGhhdCBpcyBtb3JlIGVhc2lseSByZWFkYWJsZS5cblxuICAgICAgdmFyIGk7XG4gICAgICBnYXAgPSBcIlwiO1xuICAgICAgaW5kZW50ID0gXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgICAgLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICBpbmRlbnQgKz0gXCIgXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbiAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgfTtcbiAgfVxuXG5cbiAgLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIEpTT04ucGFyc2UgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBKU09OIHBhcnNlIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIHN0YXRlIG1hY2hpbmUgcmF0aGVyXG4gICAgICAvLyB0aGFuIHRoZSBkYW5nZXJvdXMgZXZhbCBmdW5jdGlvbiB0byBwYXJzZSBhIEpTT04gdGV4dC5cblxuICAgICAgdmFyIHN0YXRlOyAgICAgIC8vIFRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLCBvbmUgb2ZcbiAgICAgIC8vICdnbycgICAgICAgICBUaGUgc3RhcnRpbmcgc3RhdGVcbiAgICAgIC8vICdvaycgICAgICAgICBUaGUgZmluYWwsIGFjY2VwdGluZyBzdGF0ZVxuICAgICAgLy8gJ2ZpcnN0b2tleScgIFJlYWR5IGZvciB0aGUgZmlyc3Qga2V5IG9mIHRoZSBvYmplY3Qgb3JcbiAgICAgIC8vICAgICAgICAgICAgICB0aGUgY2xvc2luZyBvZiBhbiBlbXB0eSBvYmplY3RcbiAgICAgIC8vICdva2V5JyAgICAgICBSZWFkeSBmb3IgdGhlIG5leHQga2V5IG9mIHRoZSBvYmplY3RcbiAgICAgIC8vICdjb2xvbicgICAgICBSZWFkeSBmb3IgdGhlIGNvbG9uXG4gICAgICAvLyAnb3ZhbHVlJyAgICAgUmVhZHkgZm9yIHRoZSB2YWx1ZSBoYWxmIG9mIGEga2V5L3ZhbHVlIHBhaXJcbiAgICAgIC8vICdvY29tbWEnICAgICBSZWFkeSBmb3IgYSBjb21tYSBvciBjbG9zaW5nIH1cbiAgICAgIC8vICdmaXJzdGF2YWx1ZScgUmVhZHkgZm9yIHRoZSBmaXJzdCB2YWx1ZSBvZiBhbiBhcnJheSBvclxuICAgICAgLy8gICAgICAgICAgICAgIGFuIGVtcHR5IGFycmF5XG4gICAgICAvLyAnYXZhbHVlJyAgICAgUmVhZHkgZm9yIHRoZSBuZXh0IHZhbHVlIG9mIGFuIGFycmF5XG4gICAgICAvLyAnYWNvbW1hJyAgICAgUmVhZHkgZm9yIGEgY29tbWEgb3IgY2xvc2luZyBdXG4gICAgICB2YXIgc3RhY2s7ICAgICAgLy8gVGhlIHN0YWNrLCBmb3IgY29udHJvbGxpbmcgbmVzdGluZy5cbiAgICAgIHZhciBjb250YWluZXI7ICAvLyBUaGUgY3VycmVudCBjb250YWluZXIgb2JqZWN0IG9yIGFycmF5XG4gICAgICB2YXIga2V5OyAgICAgICAgLy8gVGhlIGN1cnJlbnQga2V5XG4gICAgICB2YXIgdmFsdWU7ICAgICAgLy8gVGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgIHZhciBlc2NhcGVzID0geyAvLyBFc2NhcGVtZW50IHRyYW5zbGF0aW9uIHRhYmxlXG4gICAgICAgIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgICAgICAgXCJcXFwiXCI6IFwiXFxcIlwiLFxuICAgICAgICBcIi9cIjogXCIvXCIsXG4gICAgICAgIFwidFwiOiBcIlxcdFwiLFxuICAgICAgICBcIm5cIjogXCJcXG5cIixcbiAgICAgICAgXCJyXCI6IFwiXFxyXCIsXG4gICAgICAgIFwiZlwiOiBcIlxcZlwiLFxuICAgICAgICBcImJcIjogXCJcXGJcIlxuICAgICAgfTtcbiAgICAgIHZhciBzdHJpbmcgPSB7ICAgLy8gVGhlIGFjdGlvbnMgZm9yIHN0cmluZyB0b2tlbnNcbiAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3Rva2V5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAga2V5ID0gdmFsdWU7XG4gICAgICAgICAgc3RhdGUgPSBcImNvbG9uXCI7XG4gICAgICAgIH0sXG4gICAgICAgIG9rZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBrZXkgPSB2YWx1ZTtcbiAgICAgICAgICBzdGF0ZSA9IFwiY29sb25cIjtcbiAgICAgICAgfSxcbiAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuICAgICAgICB9LFxuICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgfSxcbiAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG51bWJlciA9IHsgICAvLyBUaGUgYWN0aW9ucyBmb3IgbnVtYmVyIHRva2Vuc1xuICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlID0gXCJva1wiO1xuICAgICAgICB9LFxuICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwib2NvbW1hXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICB9LFxuICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgYWN0aW9uID0ge1xuXG4gICAgICAgIC8vIFRoZSBhY3Rpb24gdGFibGUgZGVzY3JpYmVzIHRoZSBiZWhhdmlvciBvZiB0aGUgbWFjaGluZS4gSXQgY29udGFpbnMgYW5cbiAgICAgICAgLy8gb2JqZWN0IGZvciBlYWNoIHRva2VuLiBFYWNoIG9iamVjdCBjb250YWlucyBhIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuXG4gICAgICAgIC8vIGEgdG9rZW4gaXMgbWF0Y2hlZCBpbiBhIHN0YXRlLiBBbiBvYmplY3Qgd2lsbCBsYWNrIGEgbWV0aG9kIGZvciBpbGxlZ2FsXG4gICAgICAgIC8vIHN0YXRlcy5cblxuICAgICAgICBcIntcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtzdGF0ZTogXCJva1wifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSB7fTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdG9rZXlcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcIm9jb21tYVwiLCBrZXk6IGtleX0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0ge307XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSB7fTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdG9rZXlcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSB7fTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdG9rZXlcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwifVwiOiB7XG4gICAgICAgICAgZmlyc3Rva2V5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9wID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcC5jb250YWluZXI7XG4gICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvY29tbWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3AgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lcltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcC5jb250YWluZXI7XG4gICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIltcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtzdGF0ZTogXCJva1wifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtjb250YWluZXI6IGNvbnRhaW5lciwgc3RhdGU6IFwib2NvbW1hXCIsIGtleToga2V5fSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuICAgICAgICAgICAgY29udGFpbmVyID0gW107XG4gICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3RhdmFsdWVcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJdXCI6IHtcbiAgICAgICAgICBmaXJzdGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBwb3AuY29udGFpbmVyO1xuICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcbiAgICAgICAgICAgIHN0YXRlID0gcG9wLnN0YXRlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWNvbW1hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9wID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcC5jb250YWluZXI7XG4gICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIjpcIjoge1xuICAgICAgICAgIGNvbG9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVyLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkR1cGxpY2F0ZSBrZXkgJ1wiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBcIm92YWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIsXCI6IHtcbiAgICAgICAgICBvY29tbWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2tleVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWNvbW1hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiYXZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRydWVcIjoge1xuICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJmYWxzZVwiOiB7XG4gICAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlID0gXCJvY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJudWxsXCI6IHtcbiAgICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUgPSBcIm9rXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlID0gXCJvY29tbWFcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGRlYmFja3NsYXNoaWZ5KHRleHQpIHtcblxuICAgICAgICAvLyBSZW1vdmUgYW5kIHJlcGxhY2UgYW55IGJhY2tzbGFzaCBlc2NhcGVtZW50LlxuXG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcXFwoPzp1KC57NH0pfChbXnVdKSkvZywgZnVuY3Rpb24gKGlnbm9yZSwgYiwgYykge1xuICAgICAgICAgIHJldHVybiBiXG4gICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYiwgMTYpKVxuICAgICAgICAgICAgOiBlc2NhcGVzW2NdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcblxuICAgICAgICAvLyBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyB1c2VkIHRvIGV4dHJhY3QgdG9rZW5zIGZyb20gdGhlIEpTT04gdGV4dC5cbiAgICAgICAgLy8gVGhlIGV4dHJhY3Rpb24gcHJvY2VzcyBpcyBjYXV0aW91cy5cblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdHggPSAvXltcXHUwMDIwXFx0XFxuXFxyXSooPzooWyw6XFxbXFxde31dfHRydWV8ZmFsc2V8bnVsbCl8KC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/KXxcIigoPzpbXlxcclxcblxcdFxcXFxcXFwiXXxcXFxcKD86W1wiXFxcXFxcL3RybmZiXXx1WzAtOWEtZkEtRl17NH0pKSopXCIpLztcblxuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0aW5nIHN0YXRlLlxuXG4gICAgICAgIHN0YXRlID0gXCJnb1wiO1xuXG4gICAgICAgIC8vIFRoZSBzdGFjayByZWNvcmRzIHRoZSBjb250YWluZXIsIGtleSwgYW5kIHN0YXRlIGZvciBlYWNoIG9iamVjdCBvciBhcnJheVxuICAgICAgICAvLyB0aGF0IGNvbnRhaW5zIGFub3RoZXIgb2JqZWN0IG9yIGFycmF5IHdoaWxlIHByb2Nlc3NpbmcgbmVzdGVkIHN0cnVjdHVyZXMuXG5cbiAgICAgICAgc3RhY2sgPSBbXTtcblxuICAgICAgICAvLyBJZiBhbnkgZXJyb3Igb2NjdXJzLCB3ZSB3aWxsIGNhdGNoIGl0IGFuZCB1bHRpbWF0ZWx5IHRocm93IGEgc3ludGF4IGVycm9yLlxuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAvLyBGb3IgZWFjaCB0b2tlbi4uLlxuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHR4LmV4ZWMoc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXN1bHQgaXMgdGhlIHJlc3VsdCBhcnJheSBmcm9tIG1hdGNoaW5nIHRoZSB0b2tlbml6aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgIC8vICByZXN1bHRbMF0gY29udGFpbnMgZXZlcnl0aGluZyB0aGF0IG1hdGNoZWQsIGluY2x1ZGluZyBhbnkgaW5pdGlhbCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgLy8gIHJlc3VsdFsxXSBjb250YWlucyBhbnkgcHVuY3R1YXRpb24gdGhhdCB3YXMgbWF0Y2hlZCwgb3IgdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG4gICAgICAgICAgICAvLyAgcmVzdWx0WzJdIGNvbnRhaW5zIGEgbWF0Y2hlZCBudW1iZXIsIHN0aWxsIGluIHN0cmluZyBmb3JtLlxuICAgICAgICAgICAgLy8gIHJlc3VsdFszXSBjb250YWlucyBhIG1hdGNoZWQgc3RyaW5nLCB3aXRob3V0IHF1b3RlcyBidXQgd2l0aCBlc2NhcGVtZW50LlxuXG4gICAgICAgICAgICBpZiAocmVzdWx0WzFdKSB7XG5cbiAgICAgICAgICAgICAgLy8gVG9rZW46IEV4ZWN1dGUgdGhlIGFjdGlvbiBmb3IgdGhpcyBzdGF0ZSBhbmQgdG9rZW4uXG5cbiAgICAgICAgICAgICAgYWN0aW9uW3Jlc3VsdFsxXV1bc3RhdGVdKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzJdKSB7XG5cbiAgICAgICAgICAgICAgLy8gTnVtYmVyIHRva2VuOiBDb252ZXJ0IHRoZSBudW1iZXIgc3RyaW5nIGludG8gYSBudW1iZXIgdmFsdWUgYW5kIGV4ZWN1dGVcbiAgICAgICAgICAgICAgLy8gdGhlIGFjdGlvbiBmb3IgdGhpcyBzdGF0ZSBhbmQgbnVtYmVyLlxuXG4gICAgICAgICAgICAgIHZhbHVlID0gK3Jlc3VsdFsyXTtcbiAgICAgICAgICAgICAgbnVtYmVyW3N0YXRlXSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvLyBTdHJpbmcgdG9rZW46IFJlcGxhY2UgdGhlIGVzY2FwZW1lbnQgc2VxdWVuY2VzIGFuZCBleGVjdXRlIHRoZSBhY3Rpb24gZm9yXG4gICAgICAgICAgICAgIC8vIHRoaXMgc3RhdGUgYW5kIHN0cmluZy5cblxuICAgICAgICAgICAgICB2YWx1ZSA9IGRlYmFja3NsYXNoaWZ5KHJlc3VsdFszXSk7XG4gICAgICAgICAgICAgIHN0cmluZ1tzdGF0ZV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0b2tlbiBmcm9tIHRoZSBzdHJpbmcuIFRoZSBsb29wIHdpbGwgY29udGludWUgYXMgbG9uZyBhcyB0aGVyZVxuICAgICAgICAgICAgLy8gYXJlIHRva2Vucy4gVGhpcyBpcyBhIHNsb3cgcHJvY2VzcywgYnV0IGl0IGFsbG93cyB0aGUgdXNlIG9mIF4gbWF0Y2hpbmcsXG4gICAgICAgICAgICAvLyB3aGljaCBhc3N1cmVzIHRoYXQgbm8gaWxsZWdhbCB0b2tlbnMgc2xpcCB0aHJvdWdoLlxuXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc2xpY2UocmVzdWx0WzBdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UgZmluZCBhIHN0YXRlL3Rva2VuIGNvbWJpbmF0aW9uIHRoYXQgaXMgaWxsZWdhbCwgdGhlbiB0aGUgYWN0aW9uIHdpbGxcbiAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvci4gV2UgaGFuZGxlIHRoZSBlcnJvciBieSBzaW1wbHkgY2hhbmdpbmcgdGhlIHN0YXRlLlxuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcGFyc2luZyBpcyBmaW5pc2hlZC4gSWYgd2UgYXJlIG5vdCBpbiB0aGUgZmluYWwgXCJva1wiIHN0YXRlLCBvciBpZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHNvdXJjZSBjb250YWlucyBhbnl0aGluZyBleGNlcHQgd2hpdGVzcGFjZSwgdGhlbiB3ZSBkaWQgbm90IGhhdmVcbiAgICAgICAgLy9hIHdlbGwtZm9ybWVkIEpTT04gdGV4dC5cblxuICAgICAgICBpZiAoc3RhdGUgIT09IFwib2tcIiB8fCAoL1teXFx1MDAyMFxcdFxcblxccl0vLnRlc3Qoc291cmNlKSkpIHtcbiAgICAgICAgICB0aHJvdyAoc3RhdGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcilcbiAgICAgICAgICAgID8gc3RhdGVcbiAgICAgICAgICAgIDogbmV3IFN5bnRheEVycm9yKFwiSlNPTlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAgICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgY3VycmVudFxuICAgICAgICAvLyB2YWx1ZSBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm5cbiAgICAgICAgLy8gdGhhdCB2YWx1ZS5cblxuICAgICAgICByZXR1cm4gKHR5cGVvZiByZXZpdmVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICB2YXIgdjtcbiAgICAgICAgICAgIHZhciB2YWwgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwgaykpIHtcbiAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbCwgayk7XG4gICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsKTtcbiAgICAgICAgICB9KHtcIlwiOiB2YWx1ZX0sIFwiXCIpKVxuICAgICAgICA6IHZhbHVlO1xuICAgICAgfTtcbiAgICB9KCkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXBDdXN0b21KU09OO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvKiBnbG9iYWxzIGV4cGVjdCAqL1xuLyogZ2xvYmFscyBkZXNjcmliZSAqL1xuLyogZ2xvYmFscyBpdCAqL1xuLyogZ2xvYmFscyBzaW5vbiAqL1xuXG52YXIgUm9sbGJhciA9IHJlcXVpcmUoJy4uL3NyYy9icm93c2VyL3JvbGxiYXInKTtcblxuY29uc3QgRFVNTVlfVFJBQ0VfSUQgPSAnc29tZS10cmFjZS1pZCc7XG5jb25zdCBEVU1NWV9TUEFOX0lEID0gJ3NvbWUtc3Bhbi1pZCc7XG5cbmNvbnN0IFZhbGlkT3BlblRyYWNpbmdUcmFjZXJTdHViID0ge1xuICBzY29wZTogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZXRUYWc6ICgpID0+IHt9LFxuICAgICAgICAgIGNvbnRleHQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvVHJhY2VJZDogKCkgPT4gRFVNTVlfVFJBQ0VfSUQsXG4gICAgICAgICAgICAgIHRvU3BhbklkOiAoKSA9PiBEVU1NWV9TUEFOX0lELFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgSW52YWxpZE9wZW5UcmFjaW5nVHJhY2VyU3R1YiA9IHtcbiAgZm9vOiAoKSA9PiB7fSxcbn07XG5cbmZ1bmN0aW9uIFRlc3RDbGllbnRHZW4oKSB7XG4gIHZhciBUZXN0Q2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMucHJlZGljYXRlcyA9IFtdO1xuICAgIHRoaXMubm90aWZpZXIgPSB7XG4gICAgICBhZGRUcmFuc2Zvcm06IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmllcjtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICB9O1xuICAgIHRoaXMucXVldWUgPSB7XG4gICAgICBhZGRQcmVkaWNhdGU6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlcy5wdXNoKHApO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICB9O1xuICAgIHRoaXMubG9nQ2FsbHMgPSBbXTtcbiAgICB2YXIgbG9ncyA9ICdsb2csZGVidWcsaW5mbyx3YXJuLHdhcm5pbmcsZXJyb3IsY3JpdGljYWwnLnNwbGl0KCcsJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IGxvZ3NbaV0uc2xpY2UoMCk7XG4gICAgICB0aGlzW2ZuXSA9IGZ1bmN0aW9uIChmbiwgaXRlbSkge1xuICAgICAgICB0aGlzLmxvZ0NhbGxzLnB1c2goeyBmdW5jOiBmbiwgaXRlbTogaXRlbSB9KTtcbiAgICAgIH0uYmluZCh0aGlzLCBmbik7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMucGF5bG9hZERhdGEgPSB7fTtcbiAgICB0aGlzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvLCBwYXlsb2FkRGF0YSkge1xuICAgICAgdGhpcy5vcHRpb25zID0gbztcbiAgICAgIHRoaXMucGF5bG9hZERhdGEgPSBwYXlsb2FkRGF0YTtcbiAgICB9O1xuICAgIHRoaXMudHJhY2VyID0gVmFsaWRPcGVuVHJhY2luZ1RyYWNlclN0dWI7XG4gIH07XG5cbiAgcmV0dXJuIFRlc3RDbGllbnQ7XG59XG5cbmRlc2NyaWJlKCdSb2xsYmFyKCknLCBmdW5jdGlvbiAoKSB7XG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlLCBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlIH0pO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhdmUgYWxsIG9mIHRoZSBleHBlY3RlZCBtZXRob2RzIHdpdGggYSByZWFsIGNsaWVudCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIGV4cGVjdChyb2xsYmFyKS50by5oYXZlLnByb3BlcnR5KCdsb2cnKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnZGVidWcnKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnaW5mbycpO1xuICAgIGV4cGVjdChyb2xsYmFyKS50by5oYXZlLnByb3BlcnR5KCd3YXJuJyk7XG4gICAgZXhwZWN0KHJvbGxiYXIpLnRvLmhhdmUucHJvcGVydHkoJ3dhcm5pbmcnKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnZXJyb3InKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnY3JpdGljYWwnKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYXZlIGFsbCBvZiB0aGUgZXhwZWN0ZWQgbWV0aG9kcycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIGV4cGVjdChyb2xsYmFyKS50by5oYXZlLnByb3BlcnR5KCdsb2cnKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnZGVidWcnKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnaW5mbycpO1xuICAgIGV4cGVjdChyb2xsYmFyKS50by5oYXZlLnByb3BlcnR5KCd3YXJuJyk7XG4gICAgZXhwZWN0KHJvbGxiYXIpLnRvLmhhdmUucHJvcGVydHkoJ3dhcm5pbmcnKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnZXJyb3InKTtcbiAgICBleHBlY3Qocm9sbGJhcikudG8uaGF2ZS5wcm9wZXJ0eSgnY3JpdGljYWwnKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYXZlIHNvbWUgZGVmYXVsdCBvcHRpb25zJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5zY3J1YkZpZWxkcykudG8uY29udGFpbigncGFzc3dvcmQnKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbWVyZ2Ugd2l0aCB0aGUgZGVmYXVsdHMgb3B0aW9ucycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgc2NydWJGaWVsZHM6IFsnZm9vYmFyJ10sXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5zY3J1YkZpZWxkcykudG8uY29udGFpbignZm9vYmFyJyk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5zY3J1YkZpZWxkcykudG8uY29udGFpbigncGFzc3dvcmQnKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgb3ZlcndyaXRlIGRlZmF1bHQgaWYgc3BlY2lmaWVkJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBzY3J1YkZpZWxkczogWydmb29iYXInXSxcbiAgICAgIG92ZXJ3cml0ZVNjcnViRmllbGRzOiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuc2NydWJGaWVsZHMpLnRvLmNvbnRhaW4oJ2Zvb2JhcicpO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuc2NydWJGaWVsZHMpLnRvLm5vdC5jb250YWluKCdwYXNzd29yZCcpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXBsYWNlIGRlcHJlY2F0ZWQgb3B0aW9ucycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdFdoaXRlTGlzdDogWydmb28nXSxcbiAgICAgIGhvc3RCbGFja0xpc3Q6IFsnYmFyJ10sXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5ob3N0V2hpdGVMaXN0KS50by5lcWwodW5kZWZpbmVkKTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLmhvc3RCbGFja0xpc3QpLnRvLmVxbCh1bmRlZmluZWQpO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuaG9zdFNhZmVMaXN0KS50by5jb250YWluKCdmb28nKTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLmhvc3RCbG9ja0xpc3QpLnRvLmNvbnRhaW4oJ2JhcicpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gYSB1dWlkIHdoZW4gbG9nZ2luZycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIHZhciByZXN1bHQgPSByb2xsYmFyLmxvZygnYSBtZXNzYXNnZScsICdhbm90aGVyIG9uZScpO1xuICAgIGV4cGVjdChyZXN1bHQudXVpZCkudG8uYmUub2soKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBwYWNrYWdlIHVwIHRoZSBpbnB1dHMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gcm9sbGJhci5sb2coJ2EgbWVzc2FnZScsICdhbm90aGVyIG9uZScpO1xuICAgIHZhciBsb2dnZWRJdGVtID0gY2xpZW50LmxvZ0NhbGxzWzBdLml0ZW07XG4gICAgZXhwZWN0KGxvZ2dlZEl0ZW0ubWVzc2FnZSkudG8uZXFsKCdhIG1lc3NhZ2UnKTtcbiAgICBleHBlY3QobG9nZ2VkSXRlbS5jdXN0b20pLnRvLmJlLm9rKCk7XG5cbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY2FsbCB0aGUgY2xpZW50IHdpdGggdGhlIHJpZ2h0IG1ldGhvZCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIHZhciBtZXRob2RzID0gJ2xvZyxkZWJ1ZyxpbmZvLHdhcm4sd2FybmluZyxlcnJvcixjcml0aWNhbCcuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtc2cgPSAnbWVzc2FnZTonICsgaTtcbiAgICAgIHJvbGxiYXJbbWV0aG9kc1tpXV0obXNnKTtcbiAgICAgIGV4cGVjdChjbGllbnQubG9nQ2FsbHNbaV0uZnVuYykudG8uZXFsKG1ldGhvZHNbaV0pO1xuICAgICAgZXhwZWN0KGNsaWVudC5sb2dDYWxsc1tpXS5pdGVtLm1lc3NhZ2UpLnRvLmVxbChtc2cpO1xuICAgIH1cblxuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgLy8gTGVnYWN5IE9wZW5UcmFjaW5nIHN1cHBvcnRcbiAgaXQoJ3Nob3VsZCBoYXZlIGEgdHJhY2VyIGlmIHZhbGlkIHRyYWNlciBpcyBwcm92aWRlZCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IHRyYWNlcjogVmFsaWRPcGVuVHJhY2luZ1RyYWNlclN0dWIgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIGV4cGVjdChyb2xsYmFyLmNsaWVudC50cmFjZXIpLnRvLmVxbChWYWxpZE9wZW5UcmFjaW5nVHJhY2VyU3R1Yik7XG5cbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIC8vIExlZ2FjeSBPcGVuVHJhY2luZyBzdXBwb3J0XG4gIGl0KCdzaG91bGQgbm90IGhhdmUgYSB0cmFjZXIgaWYgaW52YWxpZCB0cmFjZXIgaXMgcHJvdmlkZWQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBvcHRpb25zID0geyB0cmFjZXI6IEludmFsaWRPcGVuVHJhY2luZ1RyYWNlclN0dWIgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIGV4cGVjdChyb2xsYmFyLmNsaWVudC50cmFjZXIpLnRvLmVxbChudWxsKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2NvbmZpZ3VyZScsIGZ1bmN0aW9uICgpIHtcbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucm9sbGJhci5jb25maWd1cmUoeyBhdXRvSW5zdHJ1bWVudDogZmFsc2UsIGNhcHR1cmVVbmNhdWdodDogZmFsc2UgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY29uZmlndXJlIGNsaWVudCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBhOiA0MixcbiAgICAgICAgZW52aXJvbm1lbnQ6ICd0ZXN0dGVzdCcsXG4gICAgICB9LFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLnBheWxvYWQuZW52aXJvbm1lbnQpLnRvLmVxbCgndGVzdHRlc3QnKTtcblxuICAgIHJvbGxiYXIuY29uZmlndXJlKHsgcGF5bG9hZDogeyBlbnZpcm9ubWVudDogJ2Jvcmtib3JrJyB9IH0pO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMucGF5bG9hZC5lbnZpcm9ubWVudCkudG8uZXFsKCdib3JrYm9yaycpO1xuICAgIGV4cGVjdChjbGllbnQub3B0aW9ucy5wYXlsb2FkLmVudmlyb25tZW50KS50by5lcWwoJ2Jvcmtib3JrJyk7XG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBhY2NlcHQgYSBzZWNvbmQgcGFyYW1ldGVyIGFuZCB1c2UgaXQgYXMgdGhlIHBheWxvYWQgdmFsdWUnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgYTogNDIsXG4gICAgICAgIGVudmlyb25tZW50OiAndGVzdHRlc3QnLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5wYXlsb2FkLmVudmlyb25tZW50KS50by5lcWwoJ3Rlc3R0ZXN0Jyk7XG5cbiAgICByb2xsYmFyLmNvbmZpZ3VyZSh7IHNvbWVrZXk6ICdib3JrYm9yaycgfSwgeyBiOiA5NyB9KTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLnNvbWVrZXkpLnRvLmVxbCgnYm9ya2JvcmsnKTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLnBheWxvYWQuYikudG8uZXFsKDk3KTtcbiAgICBleHBlY3QoY2xpZW50LnBheWxvYWREYXRhLmIpLnRvLmVxbCg5Nyk7XG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBhY2NlcHQgYSBzZWNvbmQgcGFyYW1ldGVyIGFuZCBvdmVycmlkZSB0aGUgcGF5bG9hZCB3aXRoIGl0JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGE6IDQyLFxuICAgICAgICBlbnZpcm9ubWVudDogJ3Rlc3R0ZXN0JyxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMucGF5bG9hZC5lbnZpcm9ubWVudCkudG8uZXFsKCd0ZXN0dGVzdCcpO1xuXG4gICAgcm9sbGJhci5jb25maWd1cmUoeyBzb21la2V5OiAnYm9ya2JvcmsnLCBwYXlsb2FkOiB7IGI6IDEwMSB9IH0sIHsgYjogOTcgfSk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5zb21la2V5KS50by5lcWwoJ2Jvcmtib3JrJyk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5wYXlsb2FkLmIpLnRvLmVxbCg5Nyk7XG4gICAgZXhwZWN0KGNsaWVudC5wYXlsb2FkRGF0YS5iKS50by5lcWwoOTcpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgcmVwbGFjZSBkZXByZWNhdGVkIG9wdGlvbnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGhvc3RXaGl0ZUxpc3Q6IFsnZm9vJ10sXG4gICAgICBob3N0QmxhY2tMaXN0OiBbJ2JhciddLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihcbiAgICAgIHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlIH0sXG4gICAgICBjbGllbnQsXG4gICAgKSk7XG4gICAgcm9sbGJhci5jb25maWd1cmUob3B0aW9ucyk7XG5cbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLmhvc3RXaGl0ZUxpc3QpLnRvLmVxbCh1bmRlZmluZWQpO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuaG9zdEJsYWNrTGlzdCkudG8uZXFsKHVuZGVmaW5lZCk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5ob3N0U2FmZUxpc3QpLnRvLmNvbnRhaW4oJ2ZvbycpO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuaG9zdEJsb2NrTGlzdCkudG8uY29udGFpbignYmFyJyk7XG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBzdG9yZSBjb25maWd1cmVkIG9wdGlvbnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmVVbmNhdWdodDogdHJ1ZSxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgYTogNDIsXG4gICAgICAgIGVudmlyb25tZW50OiAndGVzdHRlc3QnLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMucGF5bG9hZC5lbnZpcm9ubWVudCkudG8uZXFsKFxuICAgICAgJ3Rlc3R0ZXN0JyxcbiAgICApO1xuICAgIGV4cGVjdChyb2xsYmFyLm9wdGlvbnMuX2NvbmZpZ3VyZWRPcHRpb25zLmNhcHR1cmVVbmNhdWdodCkudG8uZXFsKHRydWUpO1xuXG4gICAgcm9sbGJhci5jb25maWd1cmUoe1xuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiBmYWxzZSxcbiAgICAgIHBheWxvYWQ6IHsgZW52aXJvbm1lbnQ6ICdib3JrYm9yaycgfSxcbiAgICB9KTtcbiAgICBleHBlY3Qocm9sbGJhci5vcHRpb25zLl9jb25maWd1cmVkT3B0aW9ucy5wYXlsb2FkLmVudmlyb25tZW50KS50by5lcWwoXG4gICAgICAnYm9ya2JvcmsnLFxuICAgICk7XG4gICAgZXhwZWN0KHJvbGxiYXIub3B0aW9ucy5fY29uZmlndXJlZE9wdGlvbnMuY2FwdHVyZVVuY2F1Z2h0KS50by5lcWwoZmFsc2UpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ29wdGlvbnMuY2FwdHVyZVVuY2F1Z2h0JywgZnVuY3Rpb24gKCkge1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgLy8gTG9hZCB0aGUgSFRNTCBwYWdlLCBzbyBlcnJvcnMgY2FuIGJlIGdlbmVyYXRlZC5cbiAgICBkb2N1bWVudC53cml0ZSh3aW5kb3cuX19odG1sX19bJ2V4YW1wbGVzL2Vycm9yLmh0bWwnXSk7XG5cbiAgICB3aW5kb3cuc2VydmVyID0gc2lub24uY3JlYXRlRmFrZVNlcnZlcigpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucm9sbGJhci5jb25maWd1cmUoeyBhdXRvSW5zdHJ1bWVudDogZmFsc2UsIGNhcHR1cmVVbmNhdWdodDogZmFsc2UgfSk7XG4gICAgd2luZG93LnNlcnZlci5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHN0dWJSZXNwb25zZShzZXJ2ZXIpIHtcbiAgICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ1BPU1QnLCAnYXBpLzEvaXRlbScsIFtcbiAgICAgIDIwMCxcbiAgICAgIHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgJ3tcImVyclwiOiAwLCBcInJlc3VsdFwiOnsgXCJ1dWlkXCI6IFwiZDRjN2FjZWY1NWJmNGM5ZWE5NWU0ZmU5NDI4YTgyODdcIn19JyxcbiAgICBdKTtcbiAgfVxuXG4gIGl0KCdzaG91bGQgY2FwdHVyZSB3aGVuIGVuYWJsZWQgaW4gY29uc3RydWN0b3InLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJvdy1lcnJvcicpO1xuICAgIGVsZW1lbnQuY2xpY2soKTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgdmFyIGJvZHkgPSBKU09OLnBhcnNlKHNlcnZlci5yZXF1ZXN0c1swXS5yZXF1ZXN0Qm9keSk7XG5cbiAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50cmFjZS5leGNlcHRpb24ubWVzc2FnZSkudG8uZXFsKCd0ZXN0IGVycm9yJyk7XG4gICAgICBleHBlY3QoYm9keS5kYXRhLm5vdGlmaWVyLmRpYWdub3N0aWMucmF3X2Vycm9yLm1lc3NhZ2UpLnRvLmVxbChcbiAgICAgICAgJ3Rlc3QgZXJyb3InLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYy5pc191bmNhdWdodCkudG8uZXFsKHRydWUpO1xuXG4gICAgICAvLyBrYXJtYSBkb2Vzbid0IHVubG9hZCB0aGUgYnJvd3NlciBiZXR3ZWVuIHRlc3RzLCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3aWxsIHJlbWFpbiBpbnN0YWxsZWQuIFVuc2V0IGNhcHR1cmVVbmNhdWdodCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3b24ndCBhZmZlY3Qgb3RoZXIgdGVzdHMuXG4gICAgICByb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGNhcHR1cmVVbmNhdWdodDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlc3BvbmQgdG8gZW5hYmxlL2Rpc2FibGUgaW4gY29uZmlndXJlJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJvdy1lcnJvcicpO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiBmYWxzZSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucykpO1xuXG4gICAgZWxlbWVudC5jbGljaygpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgwKTsgLy8gRGlzYWJsZWQsIG5vIGV2ZW50XG4gICAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgICAgcm9sbGJhci5jb25maWd1cmUoe1xuICAgICAgICBjYXB0dXJlVW5jYXVnaHQ6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5jbGljaygpO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgndGVzdCBlcnJvcicpO1xuICAgICAgICBleHBlY3QoYm9keS5kYXRhLm5vdGlmaWVyLmRpYWdub3N0aWMuaXNfYW5vbnltb3VzKS50by5ub3QuYmUub2soKTtcblxuICAgICAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgICAgICByb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgY2FwdHVyZVVuY2F1Z2h0OiBmYWxzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWxlbWVudC5jbGljaygpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgwKTsgLy8gRGlzYWJsZWQsIG5vIGV2ZW50XG5cbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSwgMSk7XG4gICAgfSwgMSk7XG4gIH0pO1xuXG4gIC8vIFRlc3QgY2FzZSBleHBlY3RzIENocm9tZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIGthcm1hIGpzL2Jyb3dzZXJcbiAgLy8gZW5naW5lIGF0IHRoZSB0aW1lIG9mIHRoaXMgY29tbWVudC4gSG93ZXZlciwga2FybWEncyBDaHJvbWUgYW5kIENocm9tZUhlYWRsZXNzXG4gIC8vIGRvbid0IGFjdHVhbGx5IGJlaGF2ZSBsaWtlIHJlYWwgQ2hyb21lIHNvIHdlIHNldHRsZSBmb3Igc3R1YmJpbmcgc29tZSB0aGluZ3MuXG4gIGl0KCdzaG91bGQgY2FwdHVyZSBleHRlcm5hbCBlcnJvciBkYXRhIHdoZW4gaW5zcGVjdEFub255bW91c0Vycm9ycyBpcyB0cnVlJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIC8vIFdlJ3JlIHN1cHBvc2VkbHkgcnVubmluZyBvbiBDaHJvbWVIZWFkbGVzcywgYnV0IHN0aWxsIG5lZWQgdG8gc3Bvb2YgQ2hyb21lLiA6XFxcbiAgICB3aW5kb3cuY2hyb21lID0geyBydW50aW1lOiB0cnVlIH07XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICBjYXB0dXJlVW5jYXVnaHQ6IHRydWUsXG4gICAgICBpbnNwZWN0QW5vbnltb3VzRXJyb3JzOiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICAvLyBTaW11bGF0ZSByZWNlaXZpbmcgb25lcnJvciB3aXRob3V0IGFuIGVycm9yIG9iamVjdC5cbiAgICByb2xsYmFyLmFub255bW91c0Vycm9yc1BlbmRpbmcgKz0gMTtcblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fub24gZXJyb3InKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZShlKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgnYW5vbiBlcnJvcicpO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ub3RpZmllci5kaWFnbm9zdGljLmlzX2Fub255bW91cykudG8uZXFsKHRydWUpO1xuXG4gICAgICAvLyBrYXJtYSBkb2Vzbid0IHVubG9hZCB0aGUgYnJvd3NlciBiZXR3ZWVuIHRlc3RzLCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3aWxsIHJlbWFpbiBpbnN0YWxsZWQuIFVuc2V0IGNhcHR1cmVVbmNhdWdodCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3b24ndCBhZmZlY3Qgb3RoZXIgdGVzdHMuXG4gICAgICByb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGNhcHR1cmVVbmNhdWdodDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGlnbm9yZSBkdXBsaWNhdGUgZXJyb3JzIGJ5IGRlZmF1bHQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJvdy1lcnJvcicpO1xuXG4gICAgLy8gZ2VuZXJhdGUgc2FtZSBlcnJvciB0d2ljZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7IC8vIHVzZSBmb3IgbG9vcCB0byBlbnN1cmUgdGhlIHN0YWNrIHRyYWNlcyBoYXZlIGlkZW50aWNhbCBsaW5lL2NvbCBpbmZvXG4gICAgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICAvLyB0cmFuc21pdCBvbmx5IG9uY2VcbiAgICAgIGV4cGVjdChzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoKS50by5lcWwoMSk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgndGVzdCBlcnJvcicpO1xuXG4gICAgICAvLyBrYXJtYSBkb2Vzbid0IHVubG9hZCB0aGUgYnJvd3NlciBiZXR3ZWVuIHRlc3RzLCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3aWxsIHJlbWFpbiBpbnN0YWxsZWQuIFVuc2V0IGNhcHR1cmVVbmNhdWdodCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3b24ndCBhZmZlY3Qgb3RoZXIgdGVzdHMuXG4gICAgICByb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGNhcHR1cmVVbmNhdWdodDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHRyYW5zbWl0IGR1cGxpY2F0ZSBlcnJvcnMgd2hlbiBzZXQgaW4gY29uZmlnJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGNhcHR1cmVVbmNhdWdodDogdHJ1ZSxcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZUVycm9yczogZmFsc2UsXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rocm93LWVycm9yJyk7XG5cbiAgICAvLyBnZW5lcmF0ZSBzYW1lIGVycm9yIHR3aWNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGVsZW1lbnQuY2xpY2soKTsgLy8gdXNlIGZvciBsb29wIHRvIGVuc3VyZSB0aGUgc3RhY2sgdHJhY2VzIGhhdmUgaWRlbnRpY2FsIGxpbmUvY29sIGluZm9cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIC8vIHRyYW5zbWl0IGJvdGggZXJyb3JzXG4gICAgICBleHBlY3Qoc2VydmVyLnJlcXVlc3RzLmxlbmd0aCkudG8uZXFsKDIpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoJ3Rlc3QgZXJyb3InKTtcblxuICAgICAgLy8ga2FybWEgZG9lc24ndCB1bmxvYWQgdGhlIGJyb3dzZXIgYmV0d2VlbiB0ZXN0cywgc28gdGhlIG9uZXJyb3IgaGFuZGxlclxuICAgICAgLy8gd2lsbCByZW1haW4gaW5zdGFsbGVkLiBVbnNldCBjYXB0dXJlVW5jYXVnaHQgc28gdGhlIG9uZXJyb3IgaGFuZGxlclxuICAgICAgLy8gd29uJ3QgYWZmZWN0IG90aGVyIHRlc3RzLlxuICAgICAgcm9sbGJhci5jb25maWd1cmUoe1xuICAgICAgICBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgc2VuZCBET01FeGNlcHRpb24gYXMgdHJhY2VfY2hhaW4nLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJvdy1kb20tZXhjZXB0aW9uJyk7XG4gICAgZWxlbWVudC5jbGljaygpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlX2NoYWluWzBdLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoXG4gICAgICAgICd0ZXN0IERPTUV4Y2VwdGlvbicsXG4gICAgICApO1xuXG4gICAgICAvLyBrYXJtYSBkb2Vzbid0IHVubG9hZCB0aGUgYnJvd3NlciBiZXR3ZWVuIHRlc3RzLCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3aWxsIHJlbWFpbiBpbnN0YWxsZWQuIFVuc2V0IGNhcHR1cmVVbmNhdWdodCBzbyB0aGUgb25lcnJvciBoYW5kbGVyXG4gICAgICAvLyB3b24ndCBhZmZlY3Qgb3RoZXIgdGVzdHMuXG4gICAgICByb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGNhcHR1cmVVbmNhdWdodDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGNhcHR1cmUgZXh0YSBmcmFtZXMgd2hlbiBzdGFja1RyYWNlTGltaXQgaXMgc2V0JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvbGRMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICBjYXB0dXJlVW5jYXVnaHQ6IHRydWUsXG4gICAgICBzdGFja1RyYWNlTGltaXQ6IDUwLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJvdy1kZXBwLXN0YWNrLWVycm9yJyk7XG4gICAgZWxlbWVudC5jbGljaygpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoJ2RlZXAgc3RhY2sgZXJyb3InKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50cmFjZS5mcmFtZXMubGVuZ3RoKS50by5iZS5hYm92ZSgyMCk7XG5cbiAgICAgIC8vIGthcm1hIGRvZXNuJ3QgdW5sb2FkIHRoZSBicm93c2VyIGJldHdlZW4gdGVzdHMsIHNvIHRoZSBvbmVycm9yIGhhbmRsZXJcbiAgICAgIC8vIHdpbGwgcmVtYWluIGluc3RhbGxlZC4gVW5zZXQgY2FwdHVyZVVuY2F1Z2h0IHNvIHRoZSBvbmVycm9yIGhhbmRsZXJcbiAgICAgIC8vIHdvbid0IGFmZmVjdCBvdGhlciB0ZXN0cy5cbiAgICAgIHJvbGxiYXIuY29uZmlndXJlKHtcbiAgICAgICAgY2FwdHVyZVVuY2F1Z2h0OiBmYWxzZSxcbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0OiBvbGRMaW1pdCwgLy8gcmVzZXQgdG8gZGVmYXVsdFxuICAgICAgfSk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhZGQgX3dyYXBwZWRTb3VyY2Ugd2hlbiB3cmFwR2xvYmFsRXZlbnRIYW5kbGVycyBpcyBzZXQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICAgICAgd3JhcEdsb2JhbEV2ZW50SGFuZGxlcnM6IHRydWUsXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rocm93LWV2ZW50LWhhbmRsZXItZXJyb3InKTtcbiAgICBlbGVtZW50LmNsaWNrKCk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbChcbiAgICAgICAgJ2V2ZW50IGhhbmRsZXIgZXJyb3InLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50cmFjZS5leHRyYSkudG8uaGF2ZS5wcm9wZXJ0eSgnX3dyYXBwZWRTb3VyY2UnKTtcblxuICAgICAgLy8ga2FybWEgZG9lc24ndCB1bmxvYWQgdGhlIGJyb3dzZXIgYmV0d2VlbiB0ZXN0cywgc28gdGhlIG9uZXJyb3IgaGFuZGxlclxuICAgICAgLy8gd2lsbCByZW1haW4gaW5zdGFsbGVkLiBVbnNldCBjYXB0dXJlVW5jYXVnaHQgc28gdGhlIG9uZXJyb3IgaGFuZGxlclxuICAgICAgLy8gd29uJ3QgYWZmZWN0IG90aGVyIHRlc3RzLlxuICAgICAgcm9sbGJhci5jb25maWd1cmUoe1xuICAgICAgICBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlLFxuICAgICAgICB3cmFwR2xvYmFsRXZlbnRIYW5kbGVyczogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdvcHRpb25zLmNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zJywgZnVuY3Rpb24gKCkge1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgd2luZG93LnNlcnZlciA9IHNpbm9uLmNyZWF0ZUZha2VTZXJ2ZXIoKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlLCBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlIH0pO1xuICAgIHdpbmRvdy5zZXJ2ZXIucmVzdG9yZSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBzdHViUmVzcG9uc2Uoc2VydmVyKSB7XG4gICAgc2VydmVyLnJlc3BvbmRXaXRoKCdQT1NUJywgJ2FwaS8xL2l0ZW0nLCBbXG4gICAgICAyMDAsXG4gICAgICB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICd7XCJlcnJcIjogMCwgXCJyZXN1bHRcIjp7IFwidXVpZFwiOiBcImQ0YzdhY2VmNTViZjRjOWVhOTVlNGZlOTQyOGE4Mjg3XCJ9fScsXG4gICAgXSk7XG4gIH1cblxuICBpdCgnc2hvdWxkIGNhcHR1cmUgd2hlbiBlbmFibGVkIGluIGNvbnN0cnVjdG9yJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zOiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3Rlc3QgcmVqZWN0JykpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoJ3Rlc3QgcmVqZWN0Jyk7XG4gICAgICBleHBlY3QoYm9keS5kYXRhLm5vdGlmaWVyLmRpYWdub3N0aWMuaXNfdW5jYXVnaHQpLnRvLmVxbCh0cnVlKTtcblxuICAgICAgcm9sbGJhci5jb25maWd1cmUoe1xuICAgICAgICBjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9uczogZmFsc2UsXG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCB3aW5kb3cuX3JvbGxiYXJVUkgpO1xuXG4gICAgICBkb25lKCk7XG4gICAgfSwgNTAwKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXNwb25kIHRvIGVuYWJsZSBpbiBjb25maWd1cmUnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IGZhbHNlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICByb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICBjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9uczogdHJ1ZSxcbiAgICB9KTtcblxuICAgIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndGVzdCByZWplY3QnKSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgndGVzdCByZWplY3QnKTtcblxuICAgICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICAgIHJvbGxiYXIuY29uZmlndXJlKHtcbiAgICAgICAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgd2luZG93Ll9yb2xsYmFyVVJIKTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDUwMCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmVzcG9uZCB0byBkaXNhYmxlIGluIGNvbmZpZ3VyZScsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIHNlcnZlciA9IHdpbmRvdy5zZXJ2ZXI7XG4gICAgc3R1YlJlc3BvbnNlKHNlcnZlcik7XG4gICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICBjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9uczogdHJ1ZSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucykpO1xuXG4gICAgcm9sbGJhci5jb25maWd1cmUoe1xuICAgICAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd0ZXN0IHJlamVjdCcpKTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgwKTsgLy8gRGlzYWJsZWQsIG5vIGV2ZW50XG4gICAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHdpbmRvdy5fcm9sbGJhclVSSCk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCA1MDApO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnbG9nJywgZnVuY3Rpb24gKCkge1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgd2luZG93LnNlcnZlciA9IHNpbm9uLmNyZWF0ZUZha2VTZXJ2ZXIoKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlLCBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlIH0pO1xuICAgIHdpbmRvdy5zZXJ2ZXIucmVzdG9yZSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBzdHViUmVzcG9uc2Uoc2VydmVyKSB7XG4gICAgc2VydmVyLnJlc3BvbmRXaXRoKCdQT1NUJywgJ2FwaS8xL2l0ZW0nLCBbXG4gICAgICAyMDAsXG4gICAgICB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICd7XCJlcnJcIjogMCwgXCJyZXN1bHRcIjp7IFwidXVpZFwiOiBcImQ0YzdhY2VmNTViZjRjOWVhOTVlNGZlOTQyOGE4Mjg3XCJ9fScsXG4gICAgXSk7XG4gIH1cblxuICBpdCgnc2hvdWxkIHNlbmQgbWVzc2FnZSB3aGVuIGNhbGxlZCB3aXRoIG1lc3NhZ2UgYW5kIGV4dHJhIGFyZ3MnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICByb2xsYmFyLmxvZygndGVzdCBtZXNzYWdlJywgeyBmb286ICdiYXInIH0pO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5Lm1lc3NhZ2UuYm9keSkudG8uZXFsKCd0ZXN0IG1lc3NhZ2UnKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS5tZXNzYWdlLmV4dHJhKS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ub3RpZmllci5kaWFnbm9zdGljLmlzX3VuY2F1Z2h0KS50by5lcWwodW5kZWZpbmVkKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYy5vcmlnaW5hbF9hcmdfdHlwZXMpLnRvLmVxbChbXG4gICAgICAgICdzdHJpbmcnLFxuICAgICAgICAnb2JqZWN0JyxcbiAgICAgIF0pO1xuXG4gICAgICBkb25lKCk7XG4gICAgfSwgMSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc2VuZCBleGNlcHRpb24gd2hlbiBjYWxsZWQgd2l0aCBlcnJvciBhbmQgZXh0cmEgYXJncycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIHNlcnZlciA9IHdpbmRvdy5zZXJ2ZXI7XG4gICAgc3R1YlJlc3BvbnNlKHNlcnZlcik7XG4gICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHJvbGxiYXIubG9nKG5ldyBFcnJvcigndGVzdCBlcnJvcicpLCB7IGZvbzogJ2JhcicgfSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgndGVzdCBlcnJvcicpO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlLmV4dHJhKS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ub3RpZmllci5kaWFnbm9zdGljLmlzX3VuY2F1Z2h0KS50by5lcWwodW5kZWZpbmVkKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYy5vcmlnaW5hbF9hcmdfdHlwZXMpLnRvLmVxbChbXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgICdvYmplY3QnLFxuICAgICAgXSk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhZGQgY3VzdG9tIGRhdGEgd2hlbiBjYWxsZWQgd2l0aCBlcnJvciBjb250ZXh0JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGFkZEVycm9yQ29udGV4dDogdHJ1ZSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucykpO1xuXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigndGVzdCBlcnJvcicpO1xuICAgIGVyci5yb2xsYmFyQ29udGV4dCA9IHsgZXJyOiAndGVzdCcgfTtcblxuICAgIHJvbGxiYXIuZXJyb3IoZXJyLCB7IGZvbzogJ2JhcicgfSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgndGVzdCBlcnJvcicpO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5jdXN0b20uZm9vKS50by5lcWwoJ2JhcicpO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5jdXN0b20uZXJyKS50by5lcWwoJ3Rlc3QnKTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGFkZCB0cmFjaW5nIGF0dHJpYnV0ZXMgd2hlbiBjYWxsZWQgaW4gYW4gYWN0aXZlIHNwYW4nLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIGNvbnN0IHNlcnZlciA9IHdpbmRvdy5zZXJ2ZXI7XG4gICAgc3R1YlJlc3BvbnNlKHNlcnZlcik7XG4gICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICB9O1xuICAgIGNvbnN0IHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ3Rlc3QgZXJyb3InKTtcblxuICAgIHJvbGxiYXIudHJhY2luZy53aXRoU3BhbigndGVzdCcsIHt9LCAoKSA9PiB7XG4gICAgICByb2xsYmFyLmVycm9yKGVycik7XG4gICAgfSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeXtcbiAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbCgndGVzdCBlcnJvcicpO1xuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmF0dHJpYnV0ZXMpLnRvLmJlLmFuKCdhcnJheScpO1xuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmF0dHJpYnV0ZXMubGVuZ3RoKS50by5lcWwoMyk7XG4gICAgICAgIGV4cGVjdChib2R5LmRhdGEuYXR0cmlidXRlc1swXS5rZXkpLnRvLmVxbCgnc2Vzc2lvbl9pZCcpO1xuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmF0dHJpYnV0ZXNbMF0udmFsdWUpLnRvLm1hdGNoKC9eW2EtZjAtOV17MzJ9JC8pO1xuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmF0dHJpYnV0ZXNbMV0ua2V5KS50by5lcWwoJ3NwYW5faWQnKTtcbiAgICAgICAgZXhwZWN0KGJvZHkuZGF0YS5hdHRyaWJ1dGVzWzFdLnZhbHVlKS50by5tYXRjaCgvXlthLWYwLTldezE2fSQvKTtcbiAgICAgICAgZXhwZWN0KGJvZHkuZGF0YS5hdHRyaWJ1dGVzWzJdLmtleSkudG8uZXFsKCd0cmFjZV9pZCcpO1xuICAgICAgICBleHBlY3QoYm9keS5kYXRhLmF0dHJpYnV0ZXNbMl0udmFsdWUpLnRvLm1hdGNoKC9eW2EtZjAtOV17MzJ9JC8pO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZG9uZShlKTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgfSk7XG5cblxuICBpdCgnc2hvdWxkIHNlbmQgbWVzc2FnZSB3aGVuIGNhbGxlZCB3aXRoIG9ubHkgbnVsbCBhcmd1bWVudHMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IHRydWUsXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHJvbGxiYXIubG9nKG51bGwpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5Lm1lc3NhZ2UuYm9keSkudG8uZXFsKFxuICAgICAgICAnSXRlbSBzZW50IHdpdGggbnVsbCBvciBtaXNzaW5nIGFyZ3VtZW50cy4nLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYy5vcmlnaW5hbF9hcmdfdHlwZXMpLnRvLmVxbChbJ251bGwnXSk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBza2lwRnJhbWVzIHdoZW4gc2V0JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zOiB0cnVlLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ2Vycm9yIHdpdGggc3RhY2snKTtcblxuICAgIHJvbGxiYXIubG9nKGVycm9yKTtcbiAgICByb2xsYmFyLmxvZyhlcnJvciwgeyBza2lwRnJhbWVzOiAxIH0pO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgZnJhbWVzMSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KS5kYXRhLmJvZHkudHJhY2VcbiAgICAgICAgLmZyYW1lcztcbiAgICAgIHZhciBmcmFtZXMyID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMV0ucmVxdWVzdEJvZHkpLmRhdGEuYm9keS50cmFjZVxuICAgICAgICAuZnJhbWVzO1xuXG4gICAgICBleHBlY3QoZnJhbWVzMS5sZW5ndGgpLnRvLmVxbChmcmFtZXMyLmxlbmd0aCArIDEpO1xuICAgICAgZXhwZWN0KGZyYW1lczEuc2xpY2UoMCwgLTEpKS50by5lcWwoZnJhbWVzMik7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBjYWxsIHRoZSBpdGVtIGNhbGxiYWNrIG9uIGVycm9yJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIC8vIENyZWF0ZSBhbiBpbnZhbGlkIHRyYWNlciwgaW4gb3JkZXIgdG8gZm9yY2UgYW4gZXJyb3IgaW4gbm90aWZpZXIuX2xvZygpXG4gICAgdmFyIHRyYWNlciA9IHtcbiAgICAgIHNjb3BlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgdHJhY2VyOiB0cmFjZXIsXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBjYWxsYmFja0NhbGxlZDtcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBjYWxsYmFja0NhbGxlZCA9IGVycjtcbiAgICB9O1xuXG4gICAgcm9sbGJhci5sb2coJ3Rlc3QnLCBjYWxsYmFjayk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIGV4cGVjdChjYWxsYmFja0NhbGxlZC5tZXNzYWdlKS50by5lcWwoJ1Rlc3QgZXJyb3InKTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcbn0pO1xuXG4vLyBUZXN0IGRpcmVjdCBjYWxsIHRvIG9uZXJyb3IsIGFzIHVzZWQgaW4gdmVyaWZpY2F0aW9uIG9mIGJyb3dzZXIganMgaW5zdGFsbC5cbmRlc2NyaWJlKCdvbmVycm9yJywgZnVuY3Rpb24gKCkge1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgd2luZG93LnNlcnZlciA9IHNpbm9uLmNyZWF0ZUZha2VTZXJ2ZXIoKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlLCBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlIH0pO1xuICAgIHdpbmRvdy5zZXJ2ZXIucmVzdG9yZSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBzdHViUmVzcG9uc2Uoc2VydmVyKSB7XG4gICAgc2VydmVyLnJlc3BvbmRXaXRoKCdQT1NUJywgJ2FwaS8xL2l0ZW0nLCBbXG4gICAgICAyMDAsXG4gICAgICB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICd7XCJlcnJcIjogMCwgXCJyZXN1bHRcIjp7IFwidXVpZFwiOiBcImQ0YzdhY2VmNTViZjRjOWVhOTVlNGZlOTQyOGE4Mjg3XCJ9fScsXG4gICAgXSk7XG4gIH1cblxuICBpdCgnc2hvdWxkIHNlbmQgbWVzc2FnZSB3aGVuIGNhbGxpbmcgb25lcnJvciBkaXJlY3RseScsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIHNlcnZlciA9IHdpbmRvdy5zZXJ2ZXI7XG4gICAgc3R1YlJlc3BvbnNlKHNlcnZlcik7XG4gICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICBjYXB0dXJlVW5jYXVnaHQ6IHRydWUsXG4gICAgfTtcbiAgICB3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpO1xuXG4gICAgd2luZG93Lm9uZXJyb3IoXG4gICAgICAnVGVzdFJvbGxiYXJFcnJvcjogdGVzdGluZyB3aW5kb3cub25lcnJvcicsXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICApO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoXG4gICAgICAgICd0ZXN0aW5nIHdpbmRvdy5vbmVycm9yJyxcbiAgICAgICk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2NhbGxiYWNrIG9wdGlvbnMnLCBmdW5jdGlvbiAoKSB7XG4gIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB3aW5kb3cuc2VydmVyID0gc2lub24uY3JlYXRlRmFrZVNlcnZlcigpO1xuICAgIGRvbmUoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucm9sbGJhci5jb25maWd1cmUoeyBhdXRvSW5zdHJ1bWVudDogZmFsc2UsIGNhcHR1cmVVbmNhdWdodDogZmFsc2UgfSk7XG4gICAgd2luZG93LnNlcnZlci5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHN0dWJSZXNwb25zZShzZXJ2ZXIpIHtcbiAgICBzZXJ2ZXIucmVzcG9uZFdpdGgoJ1BPU1QnLCAnYXBpLzEvaXRlbScsIFtcbiAgICAgIDIwMCxcbiAgICAgIHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgJ3tcImVyclwiOiAwLCBcInJlc3VsdFwiOnsgXCJ1dWlkXCI6IFwiZDRjN2FjZWY1NWJmNGM5ZWE5NWU0ZmU5NDI4YTgyODdcIn19JyxcbiAgICBdKTtcbiAgfVxuXG4gIGl0KCdzaG91bGQgdXNlIGNoZWNrSWdub3JlIHdoZW4gc2V0JywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGNoZWNrSWdub3JlOiBmdW5jdGlvbiAoX2lzVW5jYXVnaHQsIF9hcmdzLCBfcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHJvbGxiYXIubG9nKCd0ZXN0Jyk7IC8vIGdlbmVyYXRlIGEgcGF5bG9hZCB0byBpZ25vcmVcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgwKTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlY2VpdmUgdmFsaWQgYXJndW1lbnRzIGF0IGNoZWNrSWdub3JlJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGNoZWNrSWdub3JlOiBmdW5jdGlvbiAoX2lzVW5jYXVnaHQsIGFyZ3MsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKF9pc1VuY2F1Z2h0ID09PSBmYWxzZSAmJiBhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IgJiYgcGF5bG9hZC51dWlkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucykpO1xuXG4gICAgcm9sbGJhci5sb2cobmV3IEVycm9yKCd0ZXN0JykpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICAvLyBTaG91bGQgYmUgaWdub3JlZCBpZiBhbGwgY2hlY2tzIHBhc3MuXG4gICAgICBleHBlY3Qoc2VydmVyLnJlcXVlc3RzLmxlbmd0aCkudG8uZXFsKDApO1xuXG4gICAgICBkb25lKCk7XG4gICAgfSwgMSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmVjZWl2ZSB1bmNhdWdodCBhdCBjaGVja0lnbm9yZScsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIHNlcnZlciA9IHdpbmRvdy5zZXJ2ZXI7XG4gICAgc3R1YlJlc3BvbnNlKHNlcnZlcik7XG4gICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICBjYXB0dXJlVW5jYXVnaHQ6IHRydWUsXG4gICAgICBjaGVja0lnbm9yZTogZnVuY3Rpb24gKGlzVW5jYXVnaHQsIGFyZ3MsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKGlzVW5jYXVnaHQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgIH07XG4gICAgd2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKTtcblxuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rocm93LWVycm9yJyk7XG4gICAgZWxlbWVudC5jbGljaygpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICAvLyBTaG91bGQgYmUgaWdub3JlZCBpZiBjaGVja0lnbm9yZSByZWNlaXZlcyBpc1VuY2F1Z2h0LlxuICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgwKTtcblxuICAgICAgZG9uZSgpO1xuICAgIH0sIDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHNlbmQgd2hlbiBjaGVja0lnbm9yZSByZXR1cm5zIGZhbHNlJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGNoZWNrSWdub3JlOiBmdW5jdGlvbiAoX2lzVW5jYXVnaHQsIF9hcmdzLCBfcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICByb2xsYmFyLmxvZygndGVzdCcpOyAvLyBnZW5lcmF0ZSBhIHBheWxvYWQgdG8gaW5zcGVjdFxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICBleHBlY3Qoc2VydmVyLnJlcXVlc3RzLmxlbmd0aCkudG8uZXFsKDEpO1xuICAgICAgdmFyIGJvZHkgPSBKU09OLnBhcnNlKHNlcnZlci5yZXF1ZXN0c1swXS5yZXF1ZXN0Qm9keSk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGJvZHkuZGF0YS5ub3RpZmllci5jb25maWd1cmVkX29wdGlvbnMuY2hlY2tJZ25vcmUuc3Vic3RyKDAsIDgpLFxuICAgICAgKS50by5lcWwoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB1c2Ugb25TZW5kQ2FsbGJhY2sgd2hlbiBzZXQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgb25TZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uIChfaXNVbmNhdWdodCwgX2FyZ3MsIHBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZC5mb28gPSAnYmFyJztcbiAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHJvbGxiYXIubG9nKCd0ZXN0Jyk7IC8vIGdlbmVyYXRlIGEgcGF5bG9hZCB0byBpbnNwZWN0XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIGV4cGVjdChzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoKS50by5lcWwoMSk7XG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEuZm9vKS50by5lcWwoJ2JhcicpO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBib2R5LmRhdGEubm90aWZpZXIuY29uZmlndXJlZF9vcHRpb25zLm9uU2VuZENhbGxiYWNrLnN1YnN0cigwLCA4KSxcbiAgICAgICkudG8uZXFsKCdmdW5jdGlvbicpO1xuXG4gICAgICBkb25lKCk7XG4gICAgfSwgMSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdXNlIHRyYW5zZm9ybSB3aGVuIHNldCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIHNlcnZlciA9IHdpbmRvdy5zZXJ2ZXI7XG4gICAgc3R1YlJlc3BvbnNlKHNlcnZlcik7XG4gICAgc2VydmVyLnJlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChkYXRhLCBfaXRlbSkge1xuICAgICAgICBkYXRhLmZvbyA9ICdiYXonO1xuICAgICAgfSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucykpO1xuXG4gICAgcm9sbGJhci5sb2coJ3Rlc3QnKTsgLy8gZ2VuZXJhdGUgYSBwYXlsb2FkIHRvIGluc3BlY3RcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgxKTtcbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5mb28pLnRvLmVxbCgnYmF6Jyk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGJvZHkuZGF0YS5ub3RpZmllci5jb25maWd1cmVkX29wdGlvbnMudHJhbnNmb3JtLnN1YnN0cigwLCA4KSxcbiAgICAgICkudG8uZXFsKCdmdW5jdGlvbicpO1xuXG4gICAgICBkb25lKCk7XG4gICAgfSwgMSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdvcHRpb25zLmF1dG9JbnN0cnVtZW50JywgZnVuY3Rpb24gKCkge1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgd2luZG93LnNlcnZlciA9IHNpbm9uLmNyZWF0ZUZha2VTZXJ2ZXIoKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlLCBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlIH0pO1xuICAgIHdpbmRvdy5zZXJ2ZXIucmVzdG9yZSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBzdHViUmVzcG9uc2Uoc2VydmVyKSB7XG4gICAgc2VydmVyLnJlc3BvbmRXaXRoKCdQT1NUJywgJ2FwaS8xL2l0ZW0nLCBbXG4gICAgICAyMDAsXG4gICAgICB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICd7XCJlcnJcIjogMCwgXCJyZXN1bHRcIjp7IFwidXVpZFwiOiBcImQ0YzdhY2VmNTViZjRjOWVhOTVlNGZlOTQyOGE4Mjg3XCJ9fScsXG4gICAgXSk7XG4gIH1cblxuICBkZXNjcmliZSgnb3B0aW9ucy5hdXRvSW5zdHJ1bWVudC5jb250ZW50U2VjdXJpdHlQb2xpY3knLCBmdW5jdGlvbiAoKSB7XG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgICAgIGF1dG9JbnN0cnVtZW50OiB7XG4gICAgICAgICAgbG9nOiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IHRydWUsXG4gICAgICAgICAgZXJyb3JPbkNvbnRlbnRTZWN1cml0eVBvbGljeTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvdy5yb2xsYmFyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGF1dG9JbnN0cnVtZW50OiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZVVuY2F1Z2h0OiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXBvcnQgY29udGVudCBzZWN1cml0eSBwb2xpY3kgZXJyb3JzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHJvbGxiYXIuY2xpZW50Lm5vdGlmaWVyLnF1ZXVlO1xuICAgICAgdmFyIHF1ZXVlU3R1YiA9IHNpbm9uLnN0dWIocXVldWUsICdfbWFrZUFwaVJlcXVlc3QnKTtcblxuICAgICAgLy8gTG9hZCB0aGUgSFRNTCBwYWdlLCBzbyBlcnJvcnMgY2FuIGJlIGdlbmVyYXRlZC5cbiAgICAgIGRvY3VtZW50LndyaXRlKHdpbmRvdy5fX2h0bWxfX1snZXhhbXBsZXMvY3NwLWVycm9ycy5odG1sJ10pO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlU3R1Yi5nZXRDYWxsKDApLmFyZ3NbMF07XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBpdGVtLmJvZHkubWVzc2FnZS5ib2R5O1xuICAgICAgICAgIHZhciB0ZWxlbWV0cnkgPSBpdGVtLmJvZHkudGVsZW1ldHJ5WzBdO1xuXG4gICAgICAgICAgZXhwZWN0KG1lc3NhZ2UpLnRvLm1hdGNoKC9TZWN1cml0eSBQb2xpY3kgVmlvbGF0aW9uLyk7XG4gICAgICAgICAgZXhwZWN0KG1lc3NhZ2UpLnRvLm1hdGNoKC9ibG9ja2VkVVJJOiBodHRwczpcXC9cXC9leGFtcGxlLmNvbVxcL3YzXFwvLyk7XG4gICAgICAgICAgZXhwZWN0KG1lc3NhZ2UpLnRvLm1hdGNoKC92aW9sYXRlZERpcmVjdGl2ZTogc2NyaXB0LXNyYy8pO1xuICAgICAgICAgIGV4cGVjdChtZXNzYWdlKS50by5tYXRjaChcbiAgICAgICAgICAgIC9vcmlnaW5hbFBvbGljeTogZGVmYXVsdC1zcmMgJ3NlbGYnICd1bnNhZmUtaW5saW5lJyAndW5zYWZlLWV2YWwnOy8sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGV4cGVjdCh0ZWxlbWV0cnkubGV2ZWwpLnRvLmVxbCgnZXJyb3InKTtcbiAgICAgICAgICBleHBlY3QodGVsZW1ldHJ5LnR5cGUpLnRvLmVxbCgnbG9nJyk7XG4gICAgICAgICAgZXhwZWN0KHRlbGVtZXRyeS5ib2R5Lm1lc3NhZ2UpLnRvLm1hdGNoKC9TZWN1cml0eSBQb2xpY3kgVmlvbGF0aW9uLyk7XG4gICAgICAgICAgZXhwZWN0KHRlbGVtZXRyeS5ib2R5Lm1lc3NhZ2UpLnRvLm1hdGNoKFxuICAgICAgICAgICAgL2Jsb2NrZWRVUkk6IGh0dHBzOlxcL1xcL2V4YW1wbGUuY29tXFwvdjNcXC8vLFxuICAgICAgICAgICk7XG4gICAgICAgICAgZXhwZWN0KHRlbGVtZXRyeS5ib2R5Lm1lc3NhZ2UpLnRvLm1hdGNoKFxuICAgICAgICAgICAgL3Zpb2xhdGVkRGlyZWN0aXZlOiBzY3JpcHQtc3JjLyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGV4cGVjdCh0ZWxlbWV0cnkuYm9keS5tZXNzYWdlKS50by5tYXRjaChcbiAgICAgICAgICAgIC9vcmlnaW5hbFBvbGljeTogZGVmYXVsdC1zcmMgJ3NlbGYnICd1bnNhZmUtaW5saW5lJyAndW5zYWZlLWV2YWwnOy8sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWRkIHRlbGVtZXRyeSBldmVudHMgd2hlbiBjb25zb2xlLmxvZyBpcyBjYWxsZWQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICBjb25zb2xlLmxvZygnY29uc29sZSB0ZXN0Jyk7IC8vIGdlbmVyYXRlIGEgdGVsZW1ldHJ5IGV2ZW50XG5cbiAgICByb2xsYmFyLmxvZygndGVzdCcpOyAvLyBnZW5lcmF0ZSBhIHBheWxvYWQgdG8gaW5zcGVjdFxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzBdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRlbGVtZXRyeVswXS5ib2R5Lm1lc3NhZ2UpLnRvLmVxbCgnY29uc29sZSB0ZXN0Jyk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaW5pdFJvbGxiYXJGb3JOZXR3b3JrVGVsZW1ldHJ5KCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGF1dG9JbnN0cnVtZW50OiB7XG4gICAgICAgIGxvZzogZmFsc2UsXG4gICAgICAgIG5ldHdvcms6IHRydWUsXG4gICAgICAgIG5ldHdvcmtSZXNwb25zZUhlYWRlcnM6IHRydWUsXG4gICAgICAgIG5ldHdvcmtSZXNwb25zZUJvZHk6IHRydWUsXG4gICAgICAgIG5ldHdvcmtSZXF1ZXN0Qm9keTogdHJ1ZSxcbiAgICAgICAgbmV0d29ya1JlcXVlc3RIZWFkZXJzOiB0cnVlLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUm9sbGJhcihvcHRpb25zKTtcbiAgfVxuXG4gIGl0KCdzaG91bGQgYWRkIHRlbGVtZXRyeSBldmVudHMgZm9yIFBPU1QgeGhyIGNhbGxzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHNlcnZlci5yZXNwb25kV2l0aCgnUE9TVCcsICdodHRwczovL2V4YW1wbGUuY29tL3hoci10ZXN0JywgW1xuICAgICAgMjAwLFxuICAgICAgeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCBQYXNzd29yZDogJzEyMzQ1NicgfSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHsgbmFtZTogJ2ZvbycsIHBhc3N3b3JkOiAnMTIzNDU2JyB9KSxcbiAgICBdKTtcblxuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gaW5pdFJvbGxiYXJGb3JOZXR3b3JrVGVsZW1ldHJ5KCkpO1xuXG4gICAgLy8gZ2VuZXJhdGUgYSB0ZWxlbWV0cnkgZXZlbnRcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ1BPU1QnLCAnaHR0cHM6Ly9leGFtcGxlLmNvbS94aHItdGVzdCcsIHRydWUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdTZWNyZXQnLCAnYWJjZGVmJyk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJvbGxiYXIubG9nKCd0ZXN0Jyk7IC8vIGdlbmVyYXRlIGEgcGF5bG9hZCB0byBpbnNwZWN0XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoKS50by5lcWwoMik7XG4gICAgICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzFdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHJlcXVlc3QgY2FwdHVyZSBhbmQgc2NydWJiaW5nXG4gICAgICAgICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudGVsZW1ldHJ5WzBdLmJvZHkucmVxdWVzdCkudG8uZXFsKFxuICAgICAgICAgICAgICAne1wibmFtZVwiOlwiYmFyXCIsXCJzZWNyZXRcIjpcIioqKioqKioqXCJ9JyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSByZXF1ZXN0IGhlYWRlcnMgY2FwdHVyZSBhbmQgY2FzZS1pbnNlbnNpdGl2ZSBzY3J1YmJpbmdcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXF1ZXN0X2hlYWRlcnMpLnRvLmVxbCh7XG4gICAgICAgICAgICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIFNlY3JldDogJyoqKioqKioqJyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgcmVzcG9uc2UgY2FwdHVyZSBhbmQgc2NydWJiaW5nXG4gICAgICAgICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudGVsZW1ldHJ5WzBdLmJvZHkucmVzcG9uc2UuYm9keSkudG8uZXFsKFxuICAgICAgICAgICAgICAne1wibmFtZVwiOlwiZm9vXCIsXCJwYXNzd29yZFwiOlwiKioqKioqKipcIn0nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgICAgYm9keS5kYXRhLmJvZHkudGVsZW1ldHJ5WzBdLmJvZHkucmVzcG9uc2UuaGVhZGVyc1snUGFzc3dvcmQnXSxcbiAgICAgICAgICAgICkudG8uZXFsKCcqKioqKioqKicpO1xuXG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkb25lKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChKU09OLnN0cmluZ2lmeSh7IG5hbWU6ICdiYXInLCBzZWNyZXQ6ICd4aHIgcG9zdCcgfSkpO1xuICAgIHNlcnZlci5yZXNwb25kKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWRkIHRlbGVtZXRyeSBldmVudHMgZm9yIEdFVCB4aHIgY2FsbHMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgc2VydmVyLnJlc3BvbmRXaXRoKCdHRVQnLCAnaHR0cHM6Ly9leGFtcGxlLmNvbS94aHItdGVzdCcsIFtcbiAgICAgIDIwMCxcbiAgICAgIHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgUGFzc3dvcmQ6ICdhYmNkZWYnIH0sXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IG5hbWU6ICdmb28nLCBwYXNzd29yZDogJzEyMzQ1NicgfSksXG4gICAgXSk7XG5cbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IGluaXRSb2xsYmFyRm9yTmV0d29ya1RlbGVtZXRyeSgpKTtcblxuICAgIC8vIGdlbmVyYXRlIGEgdGVsZW1ldHJ5IGV2ZW50XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCAnaHR0cHM6Ly9leGFtcGxlLmNvbS94aHItdGVzdCcsIHRydWUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdTZWNyZXQnLCAnYWJjZGVmJyk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJvbGxiYXIubG9nKCd0ZXN0Jyk7IC8vIGdlbmVyYXRlIGEgcGF5bG9hZCB0byBpbnNwZWN0XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoKS50by5lcWwoMik7XG4gICAgICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzFdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHJlcXVlc3QgaGVhZGVycyBjYXB0dXJlIGFuZCBjYXNlLWluc2Vuc2l0aXZlIHNjcnViYmluZ1xuICAgICAgICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRlbGVtZXRyeVswXS5ib2R5LnJlcXVlc3RfaGVhZGVycykudG8uZXFsKHtcbiAgICAgICAgICAgICAgU2VjcmV0OiAnKioqKioqKionLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSByZXNwb25zZSBjYXB0dXJlIGFuZCBzY3J1YmJpbmdcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXNwb25zZS5ib2R5KS50by5lcWwoXG4gICAgICAgICAgICAgICd7XCJuYW1lXCI6XCJmb29cIixcInBhc3N3b3JkXCI6XCIqKioqKioqKlwifScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgICBib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXNwb25zZS5oZWFkZXJzWydQYXNzd29yZCddLFxuICAgICAgICAgICAgKS50by5lcWwoJyoqKioqKioqJyk7XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKEpTT04uc3RyaW5naWZ5KHsgbmFtZTogJ2JhcicsIHNlY3JldDogJ3hociBwb3N0JyB9KSk7XG4gICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9uLXN0cmluZyBDb250ZW50LVR5cGUnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgc2VydmVyLnJlc3BvbmRXaXRoKCdHRVQnLCAnaHR0cHM6Ly9leGFtcGxlLmNvbS94aHItdGVzdCcsIFtcbiAgICAgIDIwMCxcbiAgICAgIHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IHt9LCAvLyB1bmV4cGVjdGVkL2ludmFsaWQgKG5vbi1zdHJpbmcpIGNvbnRlbnQgdHlwZVxuICAgICAgICBQYXNzd29yZDogJ2FiY2RlZicsXG4gICAgICB9LFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBuYW1lOiAnZm9vJywgcGFzc3dvcmQ6ICcxMjM0NTYnIH0pLFxuICAgIF0pO1xuXG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBpbml0Um9sbGJhckZvck5ldHdvcmtUZWxlbWV0cnkoKSk7XG5cbiAgICAvLyBnZW5lcmF0ZSBhIHRlbGVtZXRyeSBldmVudFxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgJ2h0dHBzOi8vZXhhbXBsZS5jb20veGhyLXRlc3QnLCB0cnVlKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignU2VjcmV0JywgJ2FiY2RlZicpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb2xsYmFyLmxvZygndGVzdCcpOyAvLyBnZW5lcmF0ZSBhIHBheWxvYWQgdG8gaW5zcGVjdFxuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuXG4gICAgICAgICAgICBleHBlY3Qoc2VydmVyLnJlcXVlc3RzLmxlbmd0aCkudG8uZXFsKDIpO1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBKU09OLnBhcnNlKHNlcnZlci5yZXF1ZXN0c1sxXS5yZXF1ZXN0Qm9keSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSByZXF1ZXN0IGhlYWRlcnMgY2FwdHVyZSBhbmQgY2FzZS1pbnNlbnNpdGl2ZSBzY3J1YmJpbmdcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXF1ZXN0X2hlYWRlcnMpLnRvLmVxbCh7XG4gICAgICAgICAgICAgIFNlY3JldDogJyoqKioqKioqJyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBOb3Qgc2NydWJiZWQgZm9yIHVucmVjb2duaXplZCBjb250ZW50IHR5cGVcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXNwb25zZS5ib2R5KS50by5lcWwoXG4gICAgICAgICAgICAgICd7XCJuYW1lXCI6XCJmb29cIixcInBhc3N3b3JkXCI6XCIxMjM0NTZcIn0nLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgICBib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXNwb25zZS5oZWFkZXJzWydQYXNzd29yZCddLFxuICAgICAgICAgICAgKS50by5lcWwoJyoqKioqKioqJyk7XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKEpTT04uc3RyaW5naWZ5KHsgbmFtZTogJ2JhcicsIHNlY3JldDogJ3hociBwb3N0JyB9KSk7XG4gICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBzZW5kIGVycm9ycyBmb3IgeGhyIGh0dHAgZXJyb3JzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHNlcnZlci5yZXNwb25kV2l0aCgnUE9TVCcsICd4aHItdGVzdCcsIFtcbiAgICAgIDQwNCxcbiAgICAgIHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBmb286ICdiYXInIH0pLFxuICAgIF0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgYXV0b0luc3RydW1lbnQ6IHtcbiAgICAgICAgbG9nOiBmYWxzZSxcbiAgICAgICAgbmV0d29yazogdHJ1ZSxcbiAgICAgICAgbmV0d29ya0Vycm9yT25IdHRwNHh4OiB0cnVlLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucyk7XG5cbiAgICAvLyBnZW5lcmF0ZSBhIHRlbGVtZXRyeSBldmVudFxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignUE9TVCcsICdodHRwczovL2V4YW1wbGUuY29tL3hoci10ZXN0JywgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgICAgICAgICBleHBlY3Qoc2VydmVyLnJlcXVlc3RzLmxlbmd0aCkudG8uZXFsKDIpO1xuICAgICAgICAgICAgICB2YXIgYm9keSA9IEpTT04ucGFyc2Uoc2VydmVyLnJlcXVlc3RzWzFdLnJlcXVlc3RCb2R5KTtcblxuICAgICAgICAgICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UpLnRvLmVxbChcbiAgICAgICAgICAgICAgICAnSFRUUCByZXF1ZXN0IGZhaWxlZCB3aXRoIFN0YXR1cyA0MDQnLFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIC8vIEp1c3Qga25vd2luZyBhIHN0YWNrIGlzIHByZXNlbnQgaXMgZW5vdWdoIGZvciB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50cmFjZS5mcmFtZXMubGVuZ3RoKS50by5iZS5hYm92ZSgxKTtcblxuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkb25lKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChKU09OLnN0cmluZ2lmeSh7IG5hbWU6ICdiYXInLCBzZWNyZXQ6ICd4aHIgcG9zdCcgfSkpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhZGQgdGVsZW1ldHJ5IGV2ZW50cyBmb3IgZmV0Y2ggY2FsbHMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgd2luZG93LmZldGNoU3R1YiA9IHNpbm9uLnN0dWIod2luZG93LCAnZmV0Y2gnKTtcblxuICAgIHZhciByZXNwb25zZUJvZHkgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6ICdmb28nLCBwYXNzd29yZDogJzEyMzQ1NicgfSk7XG4gICAgd2luZG93LmZldGNoLnJldHVybnMoXG4gICAgICBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIG5ldyBSZXNwb25zZShyZXNwb25zZUJvZHksIHtcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgcGFzc3dvcmQ6ICcxMjM0NTYnIH0sXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgYXV0b0luc3RydW1lbnQ6IHtcbiAgICAgICAgbG9nOiBmYWxzZSxcbiAgICAgICAgbmV0d29yazogdHJ1ZSxcbiAgICAgICAgbmV0d29ya1Jlc3BvbnNlSGVhZGVyczogdHJ1ZSxcbiAgICAgICAgbmV0d29ya1Jlc3BvbnNlQm9keTogdHJ1ZSxcbiAgICAgICAgbmV0d29ya1JlcXVlc3RCb2R5OiB0cnVlLFxuICAgICAgICBuZXR3b3JrUmVxdWVzdEhlYWRlcnM6IHRydWUsXG4gICAgICB9LFxuICAgIH07XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zKSk7XG5cbiAgICB2YXIgZmV0Y2hIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmZXRjaEhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGZldGNoSGVhZGVycy5hcHBlbmQoJ1NlY3JldCcsICcxMjM0NTYnKTtcblxuICAgIGNvbnN0IGZldGNoSW5pdCA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBuYW1lOiAnYmFyJywgc2VjcmV0OiAnZmV0Y2ggcG9zdCcgfSksXG4gICAgfTtcbiAgICB2YXIgZmV0Y2hSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHBzOi8vZXhhbXBsZS5jb20vZmV0Y2gtdGVzdCcpO1xuICAgIHdpbmRvd1xuICAgICAgLmZldGNoKGZldGNoUmVxdWVzdCwgZmV0Y2hJbml0KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIEFzc2VydCB0aGF0IHRoZSBvcmlnaW5hbCBzdHJlYW0gcmVhZGVyIGhhc24ndCBiZWVuIHJlYWQuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5ib2R5VXNlZCkudG8uZXFsKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBleHBlY3QodGV4dCkudG8uZXFsKHJlc3BvbnNlQm9keSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb2xsYmFyLmxvZygndGVzdCcpOyAvLyBnZW5lcmF0ZSBhIHBheWxvYWQgdG8gaW5zcGVjdFxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZG9uZShlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgICAgICAgZXhwZWN0KHdpbmRvdy5mZXRjaFN0dWIuY2FsbGVkKS50by5iZS5vaygpO1xuICAgICAgICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgxKTtcbiAgICAgICAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgcmVxdWVzdCBjYXB0dXJlIGFuZCBzY3J1YmJpbmdcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXF1ZXN0KS50by5lcWwoXG4gICAgICAgICAgICAgICd7XCJuYW1lXCI6XCJiYXJcIixcInNlY3JldFwiOlwiKioqKioqKipcIn0nLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHJlcXVlc3QgaGVhZGVycyBjYXB0dXJlIGFuZCBjYXNlLWluc2Vuc2l0aXZlIHNjcnViYmluZ1xuICAgICAgICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRlbGVtZXRyeVswXS5ib2R5LnJlcXVlc3RfaGVhZGVycykudG8uZXFsKHtcbiAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgc2VjcmV0OiAnKioqKioqKionLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSByZXNwb25zZSBjYXB0dXJlIGFuZCBzY3J1YmJpbmdcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXNwb25zZS5ib2R5KS50by5lcWwoXG4gICAgICAgICAgICAgICd7XCJuYW1lXCI6XCJmb29cIixcInBhc3N3b3JkXCI6XCIqKioqKioqKlwifScsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgcmVzcG9uc2UgaGVhZGVycyBjYXB0dXJlIGFuZCBjYXNlLWluc2Vuc2l0aXZlIHNjcnViYmluZ1xuICAgICAgICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRlbGVtZXRyeVswXS5ib2R5LnJlc3BvbnNlLmhlYWRlcnMpLnRvLmVxbCh7XG4gICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIHBhc3N3b3JkOiAnKioqKioqKionLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgd2luZG93LmZldGNoLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkb25lKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMSk7XG4gICAgICB9KTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXBvcnQgZXJyb3IgZm9yIGh0dHAgNHh4IGZldGNoIGNhbGxzLCB3aGVuIGVuYWJsZWQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgd2luZG93LmZldGNoU3R1YiA9IHNpbm9uLnN0dWIod2luZG93LCAnZmV0Y2gnKTtcbiAgICB3aW5kb3cuZmV0Y2gucmV0dXJucyhcbiAgICAgIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgZm9vOiAnYmFyJyB9KSwge1xuICAgICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdOb3QgRm91bmQnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICB9KSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzVG9rZW46ICdQT1NUX0NMSUVOVF9JVEVNX1RPS0VOJyxcbiAgICAgIGF1dG9JbnN0cnVtZW50OiB7XG4gICAgICAgIGxvZzogZmFsc2UsXG4gICAgICAgIG5ldHdvcms6IHRydWUsXG4gICAgICAgIG5ldHdvcmtFcnJvck9uSHR0cDR4eDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpO1xuXG4gICAgdmFyIGZldGNoSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZmV0Y2hIZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblxuICAgIGNvbnN0IGZldGNoSW5pdCA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBmb286ICdiYXInIH0pLFxuICAgIH07XG4gICAgdmFyIGZldGNoUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwczovL2V4YW1wbGUuY29tL3hoci10ZXN0Jyk7XG4gICAgd2luZG93LmZldGNoKGZldGNoUmVxdWVzdCwgZmV0Y2hJbml0KS50aGVuKGZ1bmN0aW9uIChfcmVzcG9uc2UpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgICAgICBleHBlY3Qoc2VydmVyLnJlcXVlc3RzLmxlbmd0aCkudG8uZXFsKDEpO1xuICAgICAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICAgICAgZXhwZWN0KGJvZHkuZGF0YS5ib2R5LnRyYWNlLmV4Y2VwdGlvbi5tZXNzYWdlKS50by5lcWwoXG4gICAgICAgICAgICAnSFRUUCByZXF1ZXN0IGZhaWxlZCB3aXRoIFN0YXR1cyA0MDQnLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBKdXN0IGtub3dpbmcgYSBzdGFjayBpcyBwcmVzZW50IGlzIGVub3VnaCBmb3IgdGhpcyB0ZXN0LlxuICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50cmFjZS5mcmFtZXMubGVuZ3RoKS50by5iZS5hYm92ZSgxKTtcblxuICAgICAgICAgIHJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgIHdpbmRvdy5mZXRjaC5yZXN0b3JlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZG9uZShlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWRkIHRlbGVtZXRyeSBoZWFkZXJzIHdoZW4gZmV0Y2ggSGVhZGVycyBvYmplY3QgaXMgdW5kZWZpbmVkJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgc2VydmVyID0gd2luZG93LnNlcnZlcjtcbiAgICBzdHViUmVzcG9uc2Uoc2VydmVyKTtcbiAgICBzZXJ2ZXIucmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHdpbmRvdy5mZXRjaFN0dWIgPSBzaW5vbi5zdHViKHdpbmRvdywgJ2ZldGNoJyk7XG5cbiAgICB2YXIgcmVhZGFibGVTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoSlNPTi5zdHJpbmdpZnkoeyBuYW1lOiAnZm9vJywgcGFzc3dvcmQ6ICcxMjM0NTYnIH0pKTtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHdpbmRvdy5mZXRjaC5yZXR1cm5zKFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBuZXcgUmVzcG9uc2UocmVhZGFibGVTdHJlYW0sIHtcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgcGFzc3dvcmQ6ICcxMjM0NTYnIH0sXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICAgICAgYXV0b0luc3RydW1lbnQ6IHtcbiAgICAgICAgbG9nOiBmYWxzZSxcbiAgICAgICAgbmV0d29yazogdHJ1ZSxcbiAgICAgICAgbmV0d29ya1Jlc3BvbnNlSGVhZGVyczogdHJ1ZSxcbiAgICAgICAgbmV0d29ya1JlcXVlc3RIZWFkZXJzOiB0cnVlLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucykpO1xuXG4gICAgLy8gUmVtb3ZlIEhlYWRlcnMgZnJvbSB3aW5kb3cgb2JqZWN0XG4gICAgdmFyIG9yaWdpbmFsSGVhZGVycyA9IHdpbmRvdy5IZWFkZXJzO1xuICAgIGRlbGV0ZSB3aW5kb3cuSGVhZGVycztcblxuICAgIGNvbnN0IGZldGNoSW5pdCA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCBTZWNyZXQ6ICcxMjM0NTYnIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5hbWU6ICdiYXInLCBzZWNyZXQ6ICd4aHIgcG9zdCcgfSksXG4gICAgfTtcbiAgICB2YXIgZmV0Y2hSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHBzOi8vZXhhbXBsZS5jb20veGhyLXRlc3QnKTtcbiAgICB3aW5kb3cuZmV0Y2goZmV0Y2hSZXF1ZXN0LCBmZXRjaEluaXQpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByb2xsYmFyLmxvZygndGVzdCcpOyAvLyBnZW5lcmF0ZSBhIHBheWxvYWQgdG8gaW5zcGVjdFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcblxuICAgICAgICAgICAgZXhwZWN0KHNlcnZlci5yZXF1ZXN0cy5sZW5ndGgpLnRvLmVxbCgxKTtcbiAgICAgICAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgcmVxdWVzdCBoZWFkZXJzIGNhcHR1cmUgYW5kIGNhc2UtaW5zZW5zaXRpdmUgc2NydWJiaW5nXG4gICAgICAgICAgICBleHBlY3QoYm9keS5kYXRhLmJvZHkudGVsZW1ldHJ5WzBdLmJvZHkucmVxdWVzdF9oZWFkZXJzKS50by5lcWwoe1xuICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICBzZWNyZXQ6ICcqKioqKioqKicsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHJlc3BvbnNlIGhlYWRlcnMgY2FwdHVyZSBhbmQgY2FzZS1pbnNlbnNpdGl2ZSBzY3J1YmJpbmdcbiAgICAgICAgICAgIGV4cGVjdChib2R5LmRhdGEuYm9keS50ZWxlbWV0cnlbMF0uYm9keS5yZXNwb25zZS5oZWFkZXJzKS50by5lcWwoe1xuICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICBwYXNzd29yZDogJyoqKioqKioqJyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnQgdGhhdCB0aGUgb3JpZ2luYWwgc3RyZWFtIHJlYWRlciBoYXNuJ3QgYmVlbiByZWFkLlxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHlVc2VkKS50by5lcWwoZmFsc2UpO1xuXG4gICAgICAgICAgICByb2xsYmFyLmNvbmZpZ3VyZSh7IGF1dG9JbnN0cnVtZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5mZXRjaC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB3aW5kb3cuSGVhZGVycyA9IG9yaWdpbmFsSGVhZGVycztcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkb25lKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRvbmUoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWRkIGEgZGlhZ25vc3RpYyBtZXNzYWdlIHdoZW4gd3JhcENvbnNvbGUgZmFpbHMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBzZXJ2ZXIgPSB3aW5kb3cuc2VydmVyO1xuICAgIHN0dWJSZXNwb25zZShzZXJ2ZXIpO1xuICAgIHNlcnZlci5yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIG9sZENvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbiAgICB2YXIgbmV3Q29uc29sZSA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdDb25zb2xlLCAnbG9nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgIG9sZENvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KTtcbiAgICB3aW5kb3cuY29uc29sZSA9IG5ld0NvbnNvbGU7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuOiAnUE9TVF9DTElFTlRfSVRFTV9UT0tFTicsXG4gICAgfTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHJvbGxiYXIubG9nKCd0ZXN0Jyk7IC8vIGdlbmVyYXRlIGEgcGF5bG9hZCB0byBpbnNwZWN0XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlcnZlci5yZXNwb25kKCk7XG5cbiAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShzZXJ2ZXIucmVxdWVzdHNbMF0ucmVxdWVzdEJvZHkpO1xuXG4gICAgICB3aW5kb3cuY29uc29sZSA9IG9sZENvbnNvbGU7XG5cbiAgICAgIGV4cGVjdChcbiAgICAgICAgcm9sbGJhci5jbGllbnQubm90aWZpZXIuZGlhZ25vc3RpYy5pbnN0cnVtZW50Q29uc29sZSxcbiAgICAgICkudG8uaGF2ZS5wcm9wZXJ0eSgnZXJyb3InKTtcbiAgICAgIGV4cGVjdChib2R5LmRhdGEubm90aWZpZXIuZGlhZ25vc3RpYy5pbnN0cnVtZW50Q29uc29sZSkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgJ2Vycm9yJyxcbiAgICAgICk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LCAxKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2NhcHR1cmVFdmVudCcsIGZ1bmN0aW9uICgpIHtcbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucm9sbGJhci5jb25maWd1cmUoeyBhdXRvSW5zdHJ1bWVudDogZmFsc2UsIGNhcHR1cmVVbmNhdWdodDogZmFsc2UgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIG1pc3NpbmcvZGVmYXVsdCB0eXBlIGFuZCBsZXZlbCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBldmVudCA9IHJvbGxiYXIuY2FwdHVyZUV2ZW50KHsgZm9vOiAnYmFyJyB9KTtcbiAgICBleHBlY3QoZXZlbnQudHlwZSkudG8uZXFsKCdtYW51YWwnKTtcbiAgICBleHBlY3QoZXZlbnQubGV2ZWwpLnRvLmVxbCgnaW5mbycpO1xuICAgIGV4cGVjdChldmVudC5ib2R5LmZvbykudG8uZXFsKCdiYXInKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIHNwZWNpZmllZCB0eXBlIGFuZCBsZXZlbCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBldmVudCA9IHJvbGxiYXIuY2FwdHVyZUV2ZW50KCdsb2cnLCB7IGZvbzogJ2JhcicgfSwgJ2RlYnVnJyk7XG4gICAgZXhwZWN0KGV2ZW50LnR5cGUpLnRvLmVxbCgnbG9nJyk7XG4gICAgZXhwZWN0KGV2ZW50LmxldmVsKS50by5lcWwoJ2RlYnVnJyk7XG4gICAgZXhwZWN0KGV2ZW50LmJvZHkuZm9vKS50by5lcWwoJ2JhcicpO1xuXG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZXh0cmEgYXJncycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBldmVudCA9IHJvbGxiYXIuY2FwdHVyZUV2ZW50KFxuICAgICAgJ21lYW5pbmdsZXNzJyxcbiAgICAgICdpbmZvJyxcbiAgICAgIHsgZm9vOiAnYmFyJyB9LFxuICAgICAgMjMsXG4gICAgICAnZGVidWcnLFxuICAgICk7XG4gICAgZXhwZWN0KGV2ZW50LnR5cGUpLnRvLmVxbCgnbWFudWFsJyk7XG4gICAgZXhwZWN0KGV2ZW50LmxldmVsKS50by5lcWwoJ2luZm8nKTtcbiAgICBleHBlY3QoZXZlbnQuYm9keS5mb28pLnRvLmVxbCgnYmFyJyk7XG5cbiAgICBkb25lKCk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGhhbmRsZSBsZXZlbCB0aGF0IG1hdGNoZXMgYSB0eXBlIHN0cmluZycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMpKTtcblxuICAgIHZhciBldmVudCA9IHJvbGxiYXIuY2FwdHVyZUV2ZW50KCdsb2cnLCB7IGZvbzogJ2JhcicgfSwgJ2Vycm9yJyk7XG4gICAgLy8gZW5zdXJlIGxldmVsICdlcnJvcicgZG9lc24ndCBvdmVyd3JpdGUgdHlwZSAnbG9nJ1xuICAgIGV4cGVjdChldmVudC50eXBlKS50by5lcWwoJ2xvZycpO1xuICAgIGV4cGVjdChldmVudC5sZXZlbCkudG8uZXFsKCdlcnJvcicpO1xuICAgIGV4cGVjdChldmVudC5ib2R5LmZvbykudG8uZXFsKCdiYXInKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2NyZWF0ZUl0ZW0nLCBmdW5jdGlvbiAoKSB7XG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJvbGxiYXIuY29uZmlndXJlKHsgYXV0b0luc3RydW1lbnQ6IGZhbHNlLCBjYXB0dXJlVW5jYXVnaHQ6IGZhbHNlIH0pO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBzdHJpbmdzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgdmFyIGFyZ3MgPSBbJ2ZpcnN0JywgJ3NlY29uZCddO1xuICAgIHZhciBpdGVtID0gcm9sbGJhci5fY3JlYXRlSXRlbShhcmdzKTtcbiAgICBleHBlY3QoaXRlbS5tZXNzYWdlKS50by5lcWwoJ2ZpcnN0Jyk7XG4gICAgZXhwZWN0KGl0ZW0uY3VzdG9tLmV4dHJhQXJnc1snMCddKS50by5lcWwoJ3NlY29uZCcpO1xuXG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgdmFyIGFyZ3MgPSBbbmV3IEVycm9yKCdXaG9hJyksICdmaXJzdCcsICdzZWNvbmQnXTtcbiAgICB2YXIgaXRlbSA9IHJvbGxiYXIuX2NyZWF0ZUl0ZW0oYXJncyk7XG4gICAgZXhwZWN0KGl0ZW0uZXJyKS50by5lcWwoYXJnc1swXSk7XG4gICAgZXhwZWN0KGl0ZW0ubWVzc2FnZSkudG8uZXFsKCdmaXJzdCcpO1xuICAgIGV4cGVjdChpdGVtLmN1c3RvbS5leHRyYUFyZ3NbJzAnXSkudG8uZXFsKCdzZWNvbmQnKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIGEgY2FsbGJhY2snLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSk7XG5cbiAgICB2YXIgbXlDYWxsYmFja0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciBteUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbXlDYWxsYmFja0NhbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICB2YXIgYXJncyA9IFtuZXcgRXJyb3IoJ1dob2EnKSwgJ2ZpcnN0JywgbXlDYWxsYmFjaywgJ3NlY29uZCddO1xuICAgIHZhciBpdGVtID0gcm9sbGJhci5fY3JlYXRlSXRlbShhcmdzKTtcbiAgICBleHBlY3QoaXRlbS5lcnIpLnRvLmVxbChhcmdzWzBdKTtcbiAgICBleHBlY3QoaXRlbS5tZXNzYWdlKS50by5lcWwoJ2ZpcnN0Jyk7XG4gICAgZXhwZWN0KGl0ZW0uY3VzdG9tLmV4dHJhQXJncykudG8uZXFsKFsnc2Vjb25kJ10pO1xuICAgIGV4cGVjdChpdGVtLmNhbGxiYWNrKS50by5iZS5vaygpO1xuICAgIGl0ZW0uY2FsbGJhY2soKTtcbiAgICBleHBlY3QobXlDYWxsYmFja0NhbGxlZCkudG8uYmUub2soKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIGFycmF5cycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIHZhciBhcmdzID0gW25ldyBFcnJvcignV2hvYScpLCAnZmlyc3QnLCBbMSwgMiwgM10sICdzZWNvbmQnXTtcbiAgICB2YXIgaXRlbSA9IHJvbGxiYXIuX2NyZWF0ZUl0ZW0oYXJncyk7XG4gICAgZXhwZWN0KGl0ZW0uZXJyKS50by5lcWwoYXJnc1swXSk7XG4gICAgZXhwZWN0KGl0ZW0ubWVzc2FnZSkudG8uZXFsKCdmaXJzdCcpO1xuICAgIGV4cGVjdChpdGVtLmN1c3RvbVsnMCddKS50by5lcWwoMSk7XG4gICAgZXhwZWN0KGl0ZW0uY3VzdG9tLmV4dHJhQXJncykudG8uZXFsKFsnc2Vjb25kJ10pO1xuXG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgb2JqZWN0cycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIHZhciBhcmdzID0gW25ldyBFcnJvcignV2hvYScpLCAnZmlyc3QnLCB7IGE6IDEsIGI6IDIgfSwgJ3NlY29uZCddO1xuICAgIHZhciBpdGVtID0gcm9sbGJhci5fY3JlYXRlSXRlbShhcmdzKTtcbiAgICBleHBlY3QoaXRlbS5lcnIpLnRvLmVxbChhcmdzWzBdKTtcbiAgICBleHBlY3QoaXRlbS5tZXNzYWdlKS50by5lcWwoJ2ZpcnN0Jyk7XG4gICAgZXhwZWN0KGl0ZW0uY3VzdG9tLmEpLnRvLmVxbCgxKTtcbiAgICBleHBlY3QoaXRlbS5jdXN0b20uYikudG8uZXFsKDIpO1xuICAgIGV4cGVjdChpdGVtLmN1c3RvbS5leHRyYUFyZ3MpLnRvLmVxbChbJ3NlY29uZCddKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIGN1c3RvbSBhcmd1bWVudHMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSk7XG5cbiAgICB2YXIgYXJncyA9IFtcbiAgICAgIG5ldyBFcnJvcignV2hvYScpLFxuICAgICAgeyBsZXZlbDogJ2luZm8nLCBza2lwRnJhbWVzOiAxLCBmb286ICdiYXInIH0sXG4gICAgXTtcbiAgICB2YXIgaXRlbSA9IHJvbGxiYXIuX2NyZWF0ZUl0ZW0oYXJncyk7XG4gICAgZXhwZWN0KGl0ZW0uZXJyKS50by5lcWwoYXJnc1swXSk7XG4gICAgZXhwZWN0KGl0ZW0ubGV2ZWwpLnRvLmVxbCgnaW5mbycpO1xuICAgIGV4cGVjdChpdGVtLnNraXBGcmFtZXMpLnRvLmVxbCgxKTtcbiAgICBleHBlY3QoaXRlbS5jdXN0b20uZm9vKS50by5lcWwoJ2JhcicpO1xuICAgIGV4cGVjdChpdGVtLmN1c3RvbS5sZXZlbCkudG8ubm90LmJlLm9rKCk7XG4gICAgZXhwZWN0KGl0ZW0uY3VzdG9tLnNraXBGcmFtZXMpLnRvLm5vdC5iZS5vaygpO1xuXG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYXZlIGEgdGltZXN0YW1wJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgdmFyIGFyZ3MgPSBbbmV3IEVycm9yKCdXaG9hJyksICdmaXJzdCcsIHsgYTogMSwgYjogMiB9LCAnc2Vjb25kJ107XG4gICAgdmFyIGl0ZW0gPSByb2xsYmFyLl9jcmVhdGVJdGVtKGFyZ3MpO1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBleHBlY3QoaXRlbS50aW1lc3RhbXApLnRvLmJlLndpdGhpbihub3cgLSAxMDAwLCBub3cgKyAxMDAwKTtcblxuICAgIGRvbmUoKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGF2ZSBhbiB1dWlkJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgdmFyIGFyZ3MgPSBbbmV3IEVycm9yKCdXaG9hJyksICdmaXJzdCcsIHsgYTogMSwgYjogMiB9LCAnc2Vjb25kJ107XG4gICAgdmFyIGl0ZW0gPSByb2xsYmFyLl9jcmVhdGVJdGVtKGFyZ3MpO1xuICAgIGV4cGVjdChpdGVtLnV1aWQpLnRvLmJlLm9rKCk7XG5cbiAgICB2YXIgcGFydHMgPSBpdGVtLnV1aWQuc3BsaXQoJy0nKTtcbiAgICBleHBlY3QocGFydHMubGVuZ3RoKS50by5lcWwoNSk7XG4gICAgLy8gVHlwZSA0IFVVSURcbiAgICBleHBlY3QocGFydHNbMl1bMF0pLnRvLmVxbCgnNCcpO1xuXG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0ZXMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciByb2xsYmFyID0gKHdpbmRvdy5yb2xsYmFyID0gbmV3IFJvbGxiYXIob3B0aW9ucywgY2xpZW50KSk7XG5cbiAgICB2YXIgeTJrID0gbmV3IERhdGUoMjAwMCwgMCwgMSk7XG4gICAgdmFyIGFyZ3MgPSBbbmV3IEVycm9yKCdXaG9hJyksICdmaXJzdCcsIHkyaywgeyBhOiAxLCBiOiAyIH0sICdzZWNvbmQnXTtcbiAgICB2YXIgaXRlbSA9IHJvbGxiYXIuX2NyZWF0ZUl0ZW0oYXJncyk7XG4gICAgZXhwZWN0KGl0ZW0uY3VzdG9tLmV4dHJhQXJncykudG8uZXFsKFt5MmssICdzZWNvbmQnXSk7XG5cbiAgICBkb25lKCk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGhhbmRsZSBudW1iZXJzJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IChUZXN0Q2xpZW50R2VuKCkpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcm9sbGJhciA9ICh3aW5kb3cucm9sbGJhciA9IG5ldyBSb2xsYmFyKG9wdGlvbnMsIGNsaWVudCkpO1xuXG4gICAgdmFyIGFyZ3MgPSBbbmV3IEVycm9yKCdXaG9hJyksICdmaXJzdCcsIDQyLCB7IGE6IDEsIGI6IDIgfSwgJ3NlY29uZCddO1xuICAgIHZhciBpdGVtID0gcm9sbGJhci5fY3JlYXRlSXRlbShhcmdzKTtcbiAgICBleHBlY3QoaXRlbS5jdXN0b20uZXh0cmFBcmdzKS50by5lcWwoWzQyLCAnc2Vjb25kJ10pO1xuXG4gICAgZG9uZSgpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZG9tZXhjZXB0aW9ucycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNsaWVudCA9IG5ldyAoVGVzdENsaWVudEdlbigpKSgpO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHJvbGxiYXIgPSAod2luZG93LnJvbGxiYXIgPSBuZXcgUm9sbGJhcihvcHRpb25zLCBjbGllbnQpKTtcblxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdjpmb28nKTtcbiAgICAgIH0gY2F0Y2ggKGVlKSB7XG4gICAgICAgIGUgPSBlZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gW2UsICdmaXJzdCcsIDQyLCB7IGE6IDEsIGI6IDIgfSwgJ3NlY29uZCddO1xuICAgICAgdmFyIGl0ZW0gPSByb2xsYmFyLl9jcmVhdGVJdGVtKGFyZ3MpO1xuICAgICAgZXhwZWN0KGl0ZW0uZXJyKS50by5iZS5vaygpO1xuICAgIH1cblxuICAgIGRvbmUoKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ3NpbmdsZXRvbicsIGZ1bmN0aW9uICgpIHtcbiAgaXQoJ3Nob3VsZCBwYXNzIHRocm91Z2ggdGhlIHVuZGVybHlpbmcgY2xpZW50IGFmdGVyIGluaXQnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBjbGllbnQgPSBuZXcgKFRlc3RDbGllbnRHZW4oKSkoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciByb2xsYmFyID0gUm9sbGJhci5pbml0KG9wdGlvbnMsIGNsaWVudCk7XG5cbiAgICByb2xsYmFyLmxvZygnaGVsbG8gMScpO1xuICAgIFJvbGxiYXIubG9nKCdoZWxsbyAyJyk7XG5cbiAgICB2YXIgbG9nZ2VkSXRlbURpcmVjdCA9IGNsaWVudC5sb2dDYWxsc1swXS5pdGVtO1xuICAgIHZhciBsb2dnZWRJdGVtU2luZ2xldG9uID0gY2xpZW50LmxvZ0NhbGxzWzFdLml0ZW07XG4gICAgZXhwZWN0KGxvZ2dlZEl0ZW1EaXJlY3QubWVzc2FnZSkudG8uZXFsKCdoZWxsbyAxJyk7XG4gICAgZXhwZWN0KGxvZ2dlZEl0ZW1TaW5nbGV0b24ubWVzc2FnZSkudG8uZXFsKCdoZWxsbyAyJyk7XG5cbiAgICBkb25lKCk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiX3JlZ2VuZXJhdG9yUnVudGltZSIsImUiLCJ0IiwiciIsIk9iamVjdCIsInByb3RvdHlwZSIsIm4iLCJoYXNPd25Qcm9wZXJ0eSIsIm8iLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiaSIsIlN5bWJvbCIsImEiLCJpdGVyYXRvciIsImMiLCJhc3luY0l0ZXJhdG9yIiwidSIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwid3JhcCIsIkdlbmVyYXRvciIsImNyZWF0ZSIsIkNvbnRleHQiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJ0eXBlIiwiYXJnIiwiY2FsbCIsImgiLCJsIiwiZiIsInMiLCJ5IiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsInAiLCJkIiwiZ2V0UHJvdG90eXBlT2YiLCJ2IiwidmFsdWVzIiwiZyIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJfaW52b2tlIiwiQXN5bmNJdGVyYXRvciIsImludm9rZSIsIl90eXBlb2YiLCJyZXNvbHZlIiwiX19hd2FpdCIsInRoZW4iLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsIkVycm9yIiwiZG9uZSIsIm1ldGhvZCIsImRlbGVnYXRlIiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwiVHlwZUVycm9yIiwicmVzdWx0TmFtZSIsIm5leHQiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicHVzaCIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJpc05hTiIsImxlbmd0aCIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm1hcmsiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImF3cmFwIiwiYXN5bmMiLCJQcm9taXNlIiwia2V5cyIsInJldmVyc2UiLCJwb3AiLCJwcmV2IiwiY2hhckF0Iiwic2xpY2UiLCJzdG9wIiwicnZhbCIsImhhbmRsZSIsImNvbXBsZXRlIiwiZmluaXNoIiwiX2NhdGNoIiwiZGVsZWdhdGVZaWVsZCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsIl9hc3luY1RvR2VuZXJhdG9yIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbmV4dCIsIl90aHJvdyIsIl8iLCJyZXF1aXJlIiwiaGVscGVycyIsImRlZmF1bHRPcHRpb25zIiwiaG9zdG5hbWUiLCJwYXRoIiwic2VhcmNoIiwidmVyc2lvbiIsInByb3RvY29sIiwicG9ydCIsIk9UTFBEZWZhdWx0T3B0aW9ucyIsIkFwaSIsIm9wdGlvbnMiLCJ0cmFuc3BvcnQiLCJ1cmxsaWIiLCJ0cnVuY2F0aW9uIiwidXJsIiwiYWNjZXNzVG9rZW4iLCJ0cmFuc3BvcnRPcHRpb25zIiwiX2dldFRyYW5zcG9ydCIsIk9UTFBUcmFuc3BvcnRPcHRpb25zIiwiX2dldE9UTFBUcmFuc3BvcnQiLCJfcG9zdFByb21pc2UiLCJfcmVmIiwicGF5bG9hZCIsInNlbGYiLCJyZWplY3QiLCJwb3N0IiwiZXJyIiwicmVzcCIsInBvc3RJdGVtIiwiZGF0YSIsImNhbGxiYWNrIiwiYnVpbGRQYXlsb2FkIiwic2V0VGltZW91dCIsInBvc3RTcGFucyIsIl9yZWYyIiwiX2NhbGxlZSIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJfeCIsImJ1aWxkSnNvblBheWxvYWQiLCJzdHJpbmdpZnlSZXN1bHQiLCJ0cnVuY2F0ZSIsInN0cmluZ2lmeSIsImVycm9yIiwicG9zdEpzb25QYXlsb2FkIiwianNvblBheWxvYWQiLCJjb25maWd1cmUiLCJvbGRPcHRpb25zIiwibWVyZ2UiLCJ1bmRlZmluZWQiLCJnZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyIsIl9vcHRpb25zJHRyYWNpbmciLCJfb2JqZWN0U3ByZWFkIiwiZW5kcG9pbnQiLCJ0cmFjaW5nIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzVHlwZSIsImNvbnRleHQiLCJjb250ZXh0UmVzdWx0Iiwic3Vic3RyIiwiZGVmYXVsdHMiLCJ0aW1lb3V0IiwiZGV0ZWN0VHJhbnNwb3J0IiwicHJveHkiLCJvcHRzIiwicGFyc2UiLCJwYXRobmFtZSIsImdXaW5kb3ciLCJ3aW5kb3ciLCJkZWZhdWx0VHJhbnNwb3J0IiwiZmV0Y2giLCJYTUxIdHRwUmVxdWVzdCIsInRyYW5zcG9ydEFQSSIsImhvc3QiLCJhcHBlbmRQYXRoVG9QYXRoIiwiYmFzZSIsImJhc2VUcmFpbGluZ1NsYXNoIiwidGVzdCIsInBhdGhCZWdpbm5pbmdTbGFzaCIsInN1YnN0cmluZyIsIkNsaWVudCIsIkFQSSIsImxvZ2dlciIsImdsb2JhbHMiLCJUcmFuc3BvcnQiLCJ0cmFuc2Zvcm1zIiwic2hhcmVkVHJhbnNmb3JtcyIsInByZWRpY2F0ZXMiLCJzaGFyZWRQcmVkaWNhdGVzIiwiZXJyb3JQYXJzZXIiLCJyZWNvcmRlckRlZmF1bHRzIiwidHJhY2luZ0RlZmF1bHRzIiwiUmVwbGF5TWFwIiwiUm9sbGJhciIsImNsaWVudCIsImhhbmRsZU9wdGlvbnMiLCJfY29uZmlndXJlZE9wdGlvbnMiLCJUZWxlbWV0ZXIiLCJjb21wb25lbnRzIiwidGVsZW1ldGVyIiwiSW5zdHJ1bWVudGVyIiwiaW5zdHJ1bWVudGVyIiwicG9seWZpbGxKU09OIiwid3JhcEdsb2JhbHMiLCJzY3J1YiIsIlRyYWNpbmciLCJSZWNvcmRlciIsInJlY29yZGVyIiwiYXBpIiwiX2dXaW5kb3ciLCJpbml0U2Vzc2lvbiIsImlzQnJvd3NlciIsInJlY29yZGVyT3B0aW9ucyIsInJlcGxheU1hcCIsImVuYWJsZWQiLCJhdXRvU3RhcnQiLCJzdGFydCIsImdEb2N1bWVudCIsImRvY3VtZW50IiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJydW50aW1lIiwiYW5vbnltb3VzRXJyb3JzUGVuZGluZyIsImFkZFRyYW5zZm9ybXNUb05vdGlmaWVyIiwibm90aWZpZXIiLCJhZGRQcmVkaWNhdGVzVG9RdWV1ZSIsInF1ZXVlIiwic2V0dXBVbmhhbmRsZWRDYXB0dXJlIiwiaW5zdHJ1bWVudCIsInNldHVwSlNPTiIsInJvbGxiYXIiLCJfaW5zdGFuY2UiLCJpbml0IiwiZ2xvYmFsIiwic2V0Q29tcG9uZW50cyIsImhhbmRsZVVuaW5pdGlhbGl6ZWQiLCJtYXliZUNhbGxiYWNrIiwibWVzc2FnZSIsInBheWxvYWREYXRhIiwiX3RoaXMkcmVjb3JkZXIiLCJsYXN0RXJyb3IiLCJsb2ciLCJpdGVtIiwiX2NyZWF0ZUl0ZW0iLCJ1dWlkIiwiX2dldEZpcnN0RnVuY3Rpb24iLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwid2FybmluZyIsImNyaXRpY2FsIiwic2VuZEpzb25QYXlsb2FkIiwidW5oYW5kbGVkRXhjZXB0aW9uc0luaXRpYWxpemVkIiwiY2FwdHVyZVVuY2F1Z2h0IiwiaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zIiwiY2FwdHVyZVVuY2F1Z2h0RXhjZXB0aW9ucyIsIndyYXBHbG9iYWxFdmVudEhhbmRsZXJzIiwidW5oYW5kbGVkUmVqZWN0aW9uc0luaXRpYWxpemVkIiwiY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnMiLCJoYW5kbGVVbmhhbmRsZWRSZWplY3Rpb25zIiwiaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24iLCJsaW5lbm8iLCJjb2xubyIsImluc3BlY3RBbm9ueW1vdXNFcnJvcnMiLCJzdGFja0luZm8iLCJtYWtlVW5oYW5kbGVkU3RhY2tJbmZvIiwiaXNFcnJvciIsIl91bmhhbmRsZWRTdGFja0luZm8iLCJsZXZlbCIsInVuY2F1Z2h0RXJyb3JMZXZlbCIsIl9pc1VuY2F1Z2h0IiwiaGFuZGxlQW5vbnltb3VzRXJyb3JzIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJfc3RhY2siLCJfaXNBbm9ueW1vdXMiLCJzdGFjayIsImhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbiIsInJlYXNvbiIsInByb21pc2UiLCJyZWFzb25SZXN1bHQiLCJfcm9sbGJhckNvbnRleHQiLCJfb3JpZ2luYWxBcmdzIiwiX2JlZm9yZSIsImN0eEZuIiwiaXNGdW5jdGlvbiIsIl9pc1dyYXAiLCJfcm9sbGJhcl93cmFwcGVkIiwiZXhjIiwiX3JvbGxiYXJXcmFwcGVkRXJyb3IiLCJTdHJpbmciLCJfd3JhcHBlZFNvdXJjZSIsInRvU3RyaW5nIiwicHJvcCIsImNhcHR1cmVFdmVudCIsImV2ZW50IiwiY3JlYXRlVGVsZW1ldHJ5RXZlbnQiLCJtZXRhZGF0YSIsImNhcHR1cmVEb21Db250ZW50TG9hZGVkIiwidHMiLCJEYXRlIiwiY2FwdHVyZUxvYWQiLCJhZGRUcmFuc2Zvcm0iLCJoYW5kbGVEb21FeGNlcHRpb24iLCJoYW5kbGVJdGVtV2l0aEVycm9yIiwiZW5zdXJlSXRlbUhhc1NvbWV0aGluZ1RvU2F5IiwiYWRkQmFzZUluZm8iLCJhZGRSZXF1ZXN0SW5mbyIsImFkZENsaWVudEluZm8iLCJhZGRQbHVnaW5JbmZvIiwiYWRkQm9keSIsImFkZE1lc3NhZ2VXaXRoRXJyb3IiLCJhZGRUZWxlbWV0cnlEYXRhIiwiYWRkQ29uZmlnVG9QYXlsb2FkIiwiYWRkU2NydWJiZXIiLCJhZGRQYXlsb2FkT3B0aW9ucyIsInVzZXJUcmFuc2Zvcm0iLCJhZGRDb25maWd1cmVkT3B0aW9ucyIsImFkZERpYWdub3N0aWNLZXlzIiwiaXRlbVRvUGF5bG9hZCIsImFkZFByZWRpY2F0ZSIsImNoZWNrTGV2ZWwiLCJjaGVja0lnbm9yZSIsInVzZXJDaGVja0lnbm9yZSIsInVybElzTm90QmxvY2tMaXN0ZWQiLCJ1cmxJc1NhZmVMaXN0ZWQiLCJtZXNzYWdlSXNJZ25vcmVkIiwibG9hZEZ1bGwiLCJhcmdzIiwiY3JlYXRlSXRlbSIsImxlbiIsInNjcnViRmllbGRzIiwibG9nTGV2ZWwiLCJyZXBvcnRMZXZlbCIsInZlcmJvc2UiLCJ0cmFuc21pdCIsInNlbmRDb25maWciLCJpbmNsdWRlSXRlbXNJblRlbGVtZXRyeSIsImNhcHR1cmVJcCIsImlnbm9yZUR1cGxpY2F0ZUVycm9ycyIsImdldElFVmVyc2lvbiIsInVuZGVmIiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsImFsbCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5uZXJIVE1MIiwiRGV0ZWN0aW9uIiwiaWVWZXJzaW9uIiwiZ2V0RWxlbWVudFR5cGUiLCJnZXRBdHRyaWJ1dGUiLCJ0b0xvd2VyQ2FzZSIsImlzRGVzY3JpYmVkRWxlbWVudCIsImVsZW1lbnQiLCJzdWJ0eXBlcyIsInRhZ05hbWUiLCJnZXRFbGVtZW50RnJvbUV2ZW50IiwiZXZ0IiwiZG9jIiwidGFyZ2V0IiwiZWxlbWVudEZyb21Qb2ludCIsImNsaWVudFgiLCJjbGllbnRZIiwidHJlZVRvQXJyYXkiLCJlbGVtIiwiTUFYX0hFSUdIVCIsIm91dCIsIm5leHREZXNjcmlwdGlvbiIsImhlaWdodCIsImRlc2NyaWJlRWxlbWVudCIsInVuc2hpZnQiLCJwYXJlbnROb2RlIiwiZWxlbWVudEFycmF5VG9TdHJpbmciLCJNQVhfTEVOR1RIIiwic2VwYXJhdG9yIiwic2VwYXJhdG9yTGVuZ3RoIiwibmV4dFN0ciIsInRvdGFsTGVuZ3RoIiwiZGVzY3JpcHRpb25Ub1N0cmluZyIsImpvaW4iLCJkZXNjIiwiaWQiLCJjbGFzc2VzIiwiYXR0cmlidXRlcyIsImtleSIsImNsYXNzTmFtZSIsImF0dHIiLCJzcGxpdCIsImhhbmRsZXIiLCJzaGltIiwib2xkT25FcnJvciIsIl9yb2xsYmFyT2xkT25FcnJvciIsIm9uZXJyb3IiLCJmbiIsIkFycmF5IiwiX3JvbGxiYXJXaW5kb3dPbkVycm9yIiwib2xkIiwicmV0IiwiX3JvbGxiYXJVUkgiLCJiZWxvbmdzVG9TaGltIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlamVjdGlvbkhhbmRsZXIiLCJkZXRhaWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZGV0ZWN0aW9uIiwiY29uc29sZSIsImZvcm1hdEFyZ3NBc1N0cmluZyIsInNldHRpbmdzIiwiZ2V0IiwibG9nRW1pdHMiLCJpbmxpbmVTdHlsZXNoZWV0IiwiaW5saW5lSW1hZ2VzIiwiY29sbGVjdEZvbnRzIiwibWFza0lucHV0T3B0aW9ucyIsInBhc3N3b3JkIiwiZW1haWwiLCJ0ZWwiLCJ0ZXh0IiwiY29sb3IiLCJkYXRlIiwibW9udGgiLCJudW1iZXIiLCJyYW5nZSIsInRpbWUiLCJ3ZWVrIiwic2xpbURPTU9wdGlvbnMiLCJzY3JpcHQiLCJjb21tZW50IiwiaGVhZEZhdmljb24iLCJoZWFkV2hpdGVzcGFjZSIsImhlYWRNZXRhRGVzY0tleXdvcmRzIiwiaGVhZE1ldGFTb2NpYWwiLCJoZWFkTWV0YVJvYm90cyIsImhlYWRNZXRhSHR0cEVxdWl2IiwiaGVhZE1ldGFBdXRob3JzaGlwIiwiaGVhZE1ldGFWZXJpZmljYXRpb24iLCJyZWNvcmQiLCJycndlYlJlY29yZEZuIiwiRXZlbnRUeXBlIiwiaHJ0aW1lIiwiX29wdGlvbnMiLCJXZWFrTWFwIiwiX3N0b3BGbiIsIl9yZWNvcmRGbiIsIl9ldmVudHMiLCJyZWNvcmRGbiIsIl9jbGFzc0NhbGxDaGVjayIsIl9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjIiwicHJldmlvdXMiLCJjdXJyZW50IiwiX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiX2NyZWF0ZUNsYXNzIiwiX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Iiwic2V0IiwibmV3T3B0aW9ucyIsImlzUmVjb3JkaW5nIiwiZHVtcCIsInJlcGxheUlkIiwib2NjdXJyZW5jZVV1aWQiLCJldmVudHMiLCJjb25jYXQiLCJyZWNvcmRpbmdTcGFuIiwic3RhcnRTcGFuIiwic2V0QXR0cmlidXRlIiwiZWFybGllc3RFdmVudCIsInJlZHVjZSIsInRpbWVzdGFtcCIsInNwYW4iLCJzdGFydFRpbWUiLCJmcm9tTWlsbGlzIiwiX2l0ZXJhdG9yIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJfc3RlcCIsImFkZEV2ZW50IiwiZXZlbnRUeXBlIiwianNvbiIsIkpTT04iLCJlbmQiLCJleHBvcnRlciIsInRvUGF5bG9hZCIsIl90aGlzIiwiY2xlYXIiLCJlbWl0IiwiaXNDaGVja291dCIsIl90aGlzJG9wdGlvbnMkZGVidWciLCJfbG9nRXZlbnQiLCJNZXRhIiwiY2hlY2tvdXRFdmVyeU5tcyIsInNlZW4iLCJXZWFrU2V0IiwiaGFzIiwiYWRkIiwiZGVmYXVsdCIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIk51bWJlciIsIl9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uIiwiX2Fzc2VydENsYXNzQnJhbmQiLCJfbWFwIiwiX3JlY29yZGVyIiwiX2FwaSIsIl90cmFjaW5nIiwiTWFwIiwiX3Byb2Nlc3NSZXBsYXkyIiwidHJhbnNmb3JtRXJyb3IiLCJfcHJvY2Vzc1JlcGxheSIsIl94MiIsImdlbiIsIl9zZW5kIiwiX2NhbGxlZTIiLCJpc0VtcHR5IiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwiaXNBcnJheSIsInJlc291cmNlU3BhbnMiLCJ0MCIsInNlbmQiLCJfeDMiLCJkaXNjYXJkIiwiZ2V0U3BhbnMiLCJfY2xhc3NQcml2YXRlRmllbGRHZXQyIiwic2V0U3BhbnMiLCJzcGFucyIsInNpemUiLCJoZWFkZXJzIiwicmVwbGFjZSIsInVybHBhcnNlciIsImRvbVV0aWwiLCJuZXR3b3JrIiwibmV0d29ya1Jlc3BvbnNlSGVhZGVycyIsIm5ldHdvcmtSZXNwb25zZUJvZHkiLCJuZXR3b3JrUmVxdWVzdEhlYWRlcnMiLCJuZXR3b3JrUmVxdWVzdEJvZHkiLCJuZXR3b3JrRXJyb3JPbkh0dHA1eHgiLCJuZXR3b3JrRXJyb3JPbkh0dHA0eHgiLCJuZXR3b3JrRXJyb3JPbkh0dHAwIiwiZG9tIiwibmF2aWdhdGlvbiIsImNvbm5lY3Rpdml0eSIsImNvbnRlbnRTZWN1cml0eVBvbGljeSIsImVycm9yT25Db250ZW50U2VjdXJpdHlQb2xpY3kiLCJyZXN0b3JlIiwicmVwbGFjZW1lbnRzIiwiYiIsInNoaWZ0IiwibmFtZUZyb21EZXNjcmlwdGlvbiIsImRlc2NyaXB0aW9uIiwiYXR0cnMiLCJkZWZhdWx0VmFsdWVTY3J1YmJlciIsInBhdHRlcm5zIiwiUmVnRXhwIiwiX3dpbmRvdyIsIl9kb2N1bWVudCIsImF1dG9JbnN0cnVtZW50Iiwic2NydWJUZWxlbWV0cnlJbnB1dHMiLCJ0ZWxlbWV0cnlTY3J1YmJlciIsImRpYWdub3N0aWMiLCJldmVudFJlbW92ZXJzIiwiY29udGVudHNlY3VyaXR5cG9saWN5IiwiX2xvY2F0aW9uIiwibG9jYXRpb24iLCJfbGFzdEhyZWYiLCJocmVmIiwib2xkU2V0dGluZ3MiLCJpbnN0cnVtZW50TmV0d29yayIsImRlaW5zdHJ1bWVudE5ldHdvcmsiLCJpbnN0cnVtZW50Q29uc29sZSIsImRlaW5zdHJ1bWVudENvbnNvbGUiLCJpbnN0cnVtZW50RG9tIiwiZGVpbnN0cnVtZW50RG9tIiwiaW5zdHJ1bWVudE5hdmlnYXRpb24iLCJkZWluc3RydW1lbnROYXZpZ2F0aW9uIiwiaW5zdHJ1bWVudENvbm5lY3Rpdml0eSIsImRlaW5zdHJ1bWVudENvbm5lY3Rpdml0eSIsImluc3RydW1lbnRDb250ZW50U2VjdXJpdHlQb2xpY3kiLCJkZWluc3RydW1lbnRDb250ZW50U2VjdXJpdHlQb2xpY3kiLCJ3cmFwUHJvcCIsInhociIsIm9yaWciLCJ4aHJwIiwiaXNVcmxPYmplY3QiLCJfaXNVcmxPYmplY3QiLCJfX3JvbGxiYXJfeGhyIiwic3RhdHVzX2NvZGUiLCJzdGFydF90aW1lX21zIiwibm93IiwiZW5kX3RpbWVfbXMiLCJoZWFkZXIiLCJyZXF1ZXN0X2hlYWRlcnMiLCJyZXF1ZXN0X2NvbnRlbnRfdHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXIiLCJyZXF1ZXN0IiwiX19yb2xsYmFyX2V2ZW50IiwiY2FwdHVyZU5ldHdvcmsiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VfY29udGVudF90eXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJoZWFkZXJzQ29uZmlnIiwiYWxsSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImFyciIsInRyaW0iLCJwYXJ0cyIsImJvZHkiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsImlzSnNvbkNvbnRlbnRUeXBlIiwic2NydWJKc29uIiwiY29kZSIsInN0YXR1cyIsImxldmVsRnJvbVN0YXR1cyIsImVycm9yT25IdHRwU3RhdHVzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwidHJhY2tIdHRwRXJyb3JzIiwiaW5wdXQiLCJyZXFIZWFkZXJzIiwiZmV0Y2hIZWFkZXJzIiwiY2xvbmUiLCJzdWJ0eXBlIiwicm9sbGJhclVVSUQiLCJjb250ZW50VHlwZSIsImluY2x1ZGVzIiwiaW5IZWFkZXJzIiwib3V0SGVhZGVycyIsImVudHJpZXMiLCJjdXJyZW50SGVhZGVyIiwic2tpcEZyYW1lcyIsIndyYXBDb25zb2xlIiwib3JpZ0NvbnNvbGUiLCJjYXB0dXJlTG9nIiwiRnVuY3Rpb24iLCJtZXRob2RzIiwicmVtb3ZlTGlzdGVuZXJzIiwiY2xpY2tIYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJiaW5kIiwiYmx1ckhhbmRsZXIiLCJoYW5kbGVCbHVyIiwiYWRkTGlzdGVuZXIiLCJoYXNUYWciLCJhbmNob3JPckJ1dHRvbiIsImNhcHR1cmVEb21FdmVudCIsImNoZWNrZWQiLCJoYW5kbGVTZWxlY3RJbnB1dENoYW5nZWQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsImlzQ2hlY2tlZCIsImVsZW1lbnRTdHJpbmciLCJjYXB0dXJlRG9tIiwiY2hyb21lUGFja2FnZWRBcHAiLCJhcHAiLCJoYXNQdXNoU3RhdGUiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiaGFuZGxlVXJsQ2hhbmdlIiwiZnJvbSIsInRvIiwicGFyc2VkSHJlZiIsInBhcnNlZFRvIiwicGFyc2VkRnJvbSIsImhhc2giLCJjYXB0dXJlTmF2aWdhdGlvbiIsImNhcHR1cmVDb25uZWN0aXZpdHlDaGFuZ2UiLCJoYW5kbGVDc3BFdmVudCIsImNzcEV2ZW50IiwiYmxvY2tlZFVSSSIsInZpb2xhdGVkRGlyZWN0aXZlIiwiZWZmZWN0aXZlRGlyZWN0aXZlIiwic291cmNlRmlsZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJvcmlnaW5hbFBvbGljeSIsImhhbmRsZUNzcEVycm9yIiwiY3NwSGFuZGxlciIsInNlY3Rpb24iLCJvYmoiLCJhbHRUeXBlIiwiY2FwdHVyZSIsImF0dGFjaEV2ZW50IiwiZGV0YWNoRXZlbnQiLCJVUkwiLCJTdGFjayIsIm9yaWdpbmFsRXJyb3IiLCJuZXN0ZWQiLCJfc2F2ZWRTdGFja1RyYWNlIiwiYWRkRXJyb3JDb250ZXh0IiwiZTIiLCJjaGFpbiIsImNhdXNlIiwiY3VzdG9tIiwiZW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsImZyYW1ld29yayIsImxhbmd1YWdlIiwic2VydmVyIiwicmVxdWVzdEluZm8iLCJxdWVyeV9zdHJpbmciLCJyZW1vdGVTdHJpbmciLCJ1c2VyX2lwIiwibmF2IiwibmF2aWdhdG9yIiwic2NyIiwic2NyZWVuIiwicnVudGltZV9tcyIsIl9yb2xsYmFyU3RhcnRUaW1lIiwiTWF0aCIsInJvdW5kIiwiamF2YXNjcmlwdCIsImJyb3dzZXIiLCJ1c2VyQWdlbnQiLCJjb29raWVfZW5hYmxlZCIsImNvb2tpZUVuYWJsZWQiLCJ3aWR0aCIsInBsdWdpbnMiLCJuYXZQbHVnaW5zIiwiY3VyIiwidHJhY2VDaGFpbiIsImFkZEJvZHlUcmFjZUNoYWluIiwiYWRkQm9keVRyYWNlIiwiYWRkQm9keU1lc3NhZ2UiLCJyZXN1bHQiLCJleHRyYSIsInN0YWNrRnJvbUl0ZW0iLCJ0cmFjZXMiLCJ0cmFjZUNoYWluTGVuZ3RoIiwidHJhY2UiLCJidWlsZFRyYWNlIiwidHJhY2VfY2hhaW4iLCJndWVzcyIsImd1ZXNzRXJyb3JDbGFzcyIsImVycm9yQ2xhc3MiLCJleGNlcHRpb24iLCJyYXdTdGFjayIsInJhdyIsInJhd0V4Y2VwdGlvbiIsInN0YWNrRnJhbWUiLCJmcmFtZSIsInByZSIsImNvbnRleHRMZW5ndGgiLCJtaWQiLCJmcmFtZXMiLCJmaWxlbmFtZSIsInNhbml0aXplVXJsIiwibGluZSIsImZ1bmMiLCJjb2x1bW4iLCJzZW5kRnJhbWVVcmwiLCJlbmRzV2l0aCIsImZsb29yIiwic2NydWJGbiIsInNjcnViUGF0aHMiLCJtYWtlRmV0Y2hSZXF1ZXN0IiwibWFrZVhoclJlcXVlc3QiLCJwYXJhbXMiLCJyZXF1ZXN0RmFjdG9yeSIsImFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoIiwiZm9ybWF0VXJsIiwiX21ha2Vab25lUmVxdWVzdCIsIndyaXRlRGF0YSIsInJvb3Rab25lIiwiWm9uZSIsInJvb3QiLCJydW4iLCJfbWFrZVJlcXVlc3QiLCJSb2xsYmFyUHJveHkiLCJfcHJveHlSZXF1ZXN0Iiwicm9sbGJhclByb3h5IiwiX21zZyIsImNvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJpc0Zpbml0ZU51bWJlciIsIkFib3J0Q29udHJvbGxlciIsImFib3J0Iiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0IiwiX2NyZWF0ZVhNTEhUVFBPYmplY3QiLCJwYXJzZVJlc3BvbnNlIiwianNvblBhcnNlIiwiX2lzU3VjY2VzcyIsIl9pc05vcm1hbEZhaWx1cmUiLCJtc2ciLCJfbmV3UmV0cmlhYmxlRXJyb3IiLCJleCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiZTEiLCJYRG9tYWluUmVxdWVzdCIsInhkb21haW5yZXF1ZXN0Iiwib25wcm9ncmVzcyIsIm9udGltZW91dCIsIm9ubG9hZCIsImZhY3RvcmllcyIsIkFjdGl2ZVhPYmplY3QiLCJ4bWxodHRwIiwibnVtRmFjdG9yaWVzIiwiYXV0aCIsInF1ZXJ5IiwibGFzdCIsImluZGV4T2YiLCJwYXJzZUludCIsInBhdGhQYXJ0cyIsIl9leHRlbmRMaXN0ZW5lclByb3RvdHlwZSIsIm9sZEFkZEV2ZW50TGlzdGVuZXIiLCJfcm9sbGJhck9sZEFkZCIsImFkZEZuIiwiYnViYmxlIiwib2xkUmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9yb2xsYmFyT2xkUmVtb3ZlIiwicmVtb3ZlRm4iLCJtYXhJdGVtcyIsIml0ZW1zUGVyTWluIiwiRXJyb3JTdGFja1BhcnNlciIsIlVOS05PV05fRlVOQ1RJT04iLCJFUlJfQ0xBU1NfUkVHRVhQIiwiZ3Vlc3NGdW5jdGlvbk5hbWUiLCJnYXRoZXJDb250ZXh0IiwiRnJhbWUiLCJfc3RhY2tGcmFtZSIsImZpbGVOYW1lIiwiZnVuY3Rpb25OYW1lIiwic2tpcCIsImdldFN0YWNrIiwicGFyc2VyU3RhY2siLCJfbW9zdFNwZWNpZmljRXJyb3JOYW1lIiwiZXJyTXNnIiwibWF0Y2giLCJlcnJDbGFzc01hdGNoIiwiZXJyQ2xhc3MiLCJjb25zdHJ1Y3Rvck5hbWUiLCJoYXNPd24iLCJ0b1N0ciIsImlzUGxhaW5PYmplY3QiLCJoYXNPd25Db25zdHJ1Y3RvciIsImhhc0lzUHJvdG90eXBlT2YiLCJzcmMiLCJjb3B5IiwiTm90aWZpZXIiLCJ0cmFuc2Zvcm0iLCJhZGRQZW5kaW5nSXRlbSIsIl9hcHBseVRyYW5zZm9ybXMiLCJyZW1vdmVQZW5kaW5nSXRlbSIsImFkZEl0ZW0iLCJ0cmFuc2Zvcm1JbmRleCIsInRyYW5zZm9ybXNMZW5ndGgiLCJjYiIsImxldmVsVmFsIiwiTEVWRUxTIiwicmVwb3J0TGV2ZWxWYWwiLCJpc1VuY2F1Z2h0Iiwib25TZW5kQ2FsbGJhY2siLCJ1cmxJc09uQUxpc3QiLCJtYXRjaEZyYW1lcyIsImxpc3QiLCJibG9jayIsInVybFJlZ2V4IiwibGlzdExlbmd0aCIsImZyYW1lTGVuZ3RoIiwiaiIsInNhZmVPckJsb2NrIiwiaG9zdEJsb2NrTGlzdCIsImhvc3RTYWZlTGlzdCIsInRyYWNlc0xlbmd0aCIsImxpc3ROYW1lIiwiaWdub3JlZE1lc3NhZ2VzIiwicklnbm9yZWRNZXNzYWdlIiwibWVzc2FnZXMiLCJtZXNzYWdlc0Zyb21JdGVtIiwiUXVldWUiLCJyYXRlTGltaXRlciIsInBlbmRpbmdJdGVtcyIsInBlbmRpbmdSZXF1ZXN0cyIsInJldHJ5UXVldWUiLCJyZXRyeUhhbmRsZSIsIndhaXRDYWxsYmFjayIsIndhaXRJbnRlcnZhbElEIiwicHJlZGljYXRlIiwiaWR4Iiwic3BsaWNlIiwib3JpZ2luYWxJdGVtIiwicHJlZGljYXRlUmVzdWx0IiwiX2FwcGx5UHJlZGljYXRlcyIsIl9tYXliZUxvZyIsIl9tYWtlQXBpUmVxdWVzdCIsIl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QiLCJfaGFuZGxlUmVwbGF5UmVzcG9uc2UiLCJ3YWl0IiwiX21heWJlQ2FsbFdhaXQiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJyYXRlTGltaXRSZXNwb25zZSIsInNob3VsZFNlbmQiLCJfbWF5YmVSZXRyeSIsIlJFVFJJQUJMRV9FUlJPUlMiLCJzaG91bGRSZXRyeSIsInJldHJ5SW50ZXJ2YWwiLCJtYXhSZXRyaWVzIiwicmV0cmllcyIsIl9yZXRyeUFwaVJlcXVlc3QiLCJyZXRyeU9iamVjdCIsIlJhdGVMaW1pdGVyIiwiY291bnRlciIsInBlck1pbkNvdW50ZXIiLCJwbGF0Zm9ybU9wdGlvbnMiLCJjb25maWd1cmVHbG9iYWwiLCJnbG9iYWxTZXR0aW5ncyIsIml0ZW1zUGVyTWludXRlIiwiZWxhcHNlZFRpbWUiLCJnbG9iYWxSYXRlTGltaXQiLCJnbG9iYWxSYXRlTGltaXRQZXJNaW4iLCJjaGVja1JhdGUiLCJzaG91bGRTZW5kVmFsdWUiLCJwZXJNaW51dGUiLCJzZXRQbGF0Zm9ybU9wdGlvbnMiLCJsaW1pdCIsImlnbm9yZVJhdGVMaW1pdCIsImxpbWl0UGVyTWluIiwicmF0ZUxpbWl0UGF5bG9hZCIsInRyYWNlciIsInZhbGlkYXRlVHJhY2VyIiwic2V0U3RhY2tUcmFjZUxpbWl0IiwibGFzdEVycm9ySGFzaCIsIl9kZWZhdWx0TG9nTGV2ZWwiLCJfbG9nIiwiZGVmYXVsdExldmVsIiwiX3NhbWVBc0xhc3RFcnJvciIsIl9hZGRUcmFjaW5nQXR0cmlidXRlcyIsIl9hZGRUcmFjaW5nSW5mbyIsIl9jYXB0dXJlUm9sbGJhckl0ZW0iLCJ0ZWxlbWV0cnlFdmVudHMiLCJjb3B5RXZlbnRzIiwidGVsZW1ldHJ5U3BhbiIsIl90aGlzJHRyYWNpbmciLCJnZXRTcGFuIiwic2Vzc2lvbklkIiwic3BhbklkIiwidHJhY2VJZCIsImFkZEl0ZW1BdHRyaWJ1dGVzIiwiaXRlbUhhc2giLCJnZW5lcmF0ZUl0ZW1IYXNoIiwic2NvcGUiLCJhY3RpdmUiLCJ2YWxpZGF0ZVNwYW4iLCJzZXRUYWciLCJvcGVudHJhY2luZ1NwYW5JZCIsInRvU3BhbklkIiwib3BlbnRyYWNpbmdUcmFjZUlkIiwidG9UcmFjZUlkIiwib3BlbnRyYWNpbmdfc3Bhbl9pZCIsIm9wZW50cmFjaW5nX3RyYWNlX2lkIiwic3RhY2tUcmFjZUxpbWl0Iiwic3BhbkNvbnRleHQiLCJ0cmF2ZXJzZSIsInNjcnViUGF0aCIsInBhcmFtUmVzIiwiX2dldFNjcnViRmllbGRSZWdleHMiLCJxdWVyeVJlcyIsIl9nZXRTY3J1YlF1ZXJ5UGFyYW1SZWdleHMiLCJyZWRhY3RRdWVyeVBhcmFtIiwiZHVtbXkwIiwicGFyYW1QYXJ0IiwicmVkYWN0IiwicGFyYW1TY3J1YmJlciIsInZhbFNjcnViYmVyIiwiayIsInNjcnViYmVyIiwidG1wViIsInBhdCIsIk1BWF9FVkVOVFMiLCJtaWxsaXMiLCJ0cnVuYyIsIm1heFRlbGVtZXRyeUV2ZW50cyIsIm1heFF1ZXVlU2l6ZSIsIm1heCIsIm1pbiIsIm5ld01heEV2ZW50cyIsImRlbGV0ZUNvdW50IiwiZmlsdGVyVGVsZW1ldHJ5IiwiZ2V0TGV2ZWwiLCJ0aW1lc3RhbXBfbXMiLCJzb3VyY2UiLCJjYXB0dXJlRXJyb3IiLCJfdGhpcyR0ZWxlbWV0cnlTcGFuIiwiX3RoaXMkdGVsZW1ldHJ5U3BhbjIiLCJfdGhpcyR0ZWxlbWV0cnlTcGFuMyIsInJlcXVlc3REYXRhIiwic3RhdHVzQ29kZSIsIl90aGlzJHRlbGVtZXRyeVNwYW40IiwiZ2V0VGltZSIsImNoYW5nZSIsIm1hbnVhbCIsInBhcmVudENvbnRleHQiLCJfY3VycmVudENvbnRleHQiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwiZGVsZXRlVmFsdWUiLCJST09UX0NPTlRFWFQiLCJDb250ZXh0TWFuYWdlciIsImN1cnJlbnRDb250ZXh0IiwiZW50ZXJDb250ZXh0IiwicHJldmlvdXNDb250ZXh0IiwiZXhpdENvbnRleHQiLCJ3aXRoIiwidGhpc0FyZyIsIl9sZW4iLCJfa2V5IiwiY3JlYXRlQ29udGV4dEtleSIsIlNwYW5FeHBvcnRlciIsImV4cG9ydCIsIl9yZXN1bHRDYWxsYmFjayIsInNwYW5FeHBvcnRRdWV1ZSIsIl90b0NvbnN1bWFibGVBcnJheSIsInJlc291cmNlIiwic2NvcGVNYXAiLCJzY29wZUtleSIsImluc3RydW1lbnRhdGlvblNjb3BlIiwiX3RyYW5zZm9ybVNwYW4iLCJfdHJhbnNmb3JtUmVzb3VyY2UiLCJzY29wZVNwYW5zIiwibWFwIiwic2NvcGVEYXRhIiwiX3RyYW5zZm9ybUluc3RydW1lbnRhdGlvblNjb3BlIiwiX3RoaXMyIiwidHJhbnNmb3JtQXR0cmlidXRlcyIsIl9zbGljZWRUb0FycmF5IiwiX3RyYW5zZm9ybUFueVZhbHVlIiwidHJhbnNmb3JtRXZlbnRzIiwidGltZVVuaXhOYW5vIiwidG9OYW5vcyIsInBhcmVudFNwYW5JZCIsImtpbmQiLCJzdGFydFRpbWVVbml4TmFubyIsImVuZFRpbWVVbml4TmFubyIsImVuZFRpbWUiLCJfdGhpczMiLCJrZXlWYWx1ZXMiLCJfcmVmMyIsIl9yZWY0IiwiX3RoaXM0IiwiX3RoaXM1Iiwic3RyaW5nVmFsdWUiLCJpc0ludGVnZXIiLCJpbnRWYWx1ZSIsImRvdWJsZVZhbHVlIiwiYm9vbFZhbHVlIiwiYXJyYXlWYWx1ZSIsImt2bGlzdFZhbHVlIiwiX3JlZjUiLCJfcmVmNiIsInRvTWlsbGlzIiwicGVyZm9ybWFuY2UiLCJ0aW1lT3JpZ2luIiwiaXNIclRpbWUiLCJieXRlcyIsInJhbmRvbUJ5dGVzIiwiVWludDhBcnJheSIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRIZXgiLCJieXRlIiwicGFkU3RhcnQiLCJTRVNTSU9OX0tFWSIsIlNlc3Npb24iLCJzZXNzaW9uIiwiZ2V0U2Vzc2lvbiIsImNyZWF0ZVNlc3Npb24iLCJzZXJpYWxpemVkU2Vzc2lvbiIsInNlc3Npb25TdG9yYWdlIiwiZ2V0SXRlbSIsIl91bnVzZWQiLCJjcmVhdGVkQXQiLCJzZXRTZXNzaW9uIiwic2Vzc2lvblN0cmluZyIsInNldEl0ZW0iLCJfdW51c2VkMiIsIlNwYW4iLCJpbml0UmVhZGFibGVTcGFuIiwic3BhblByb2Nlc3NvciIsIm9uU3RhcnQiLCJzZXRBdHRyaWJ1dGVzIiwibGlua3MiLCJkdXJhdGlvbiIsImVuZGVkIiwiZHJvcHBlZEF0dHJpYnV0ZXNDb3VudCIsImRyb3BwZWRFdmVudHNDb3VudCIsImRyb3BwZWRMaW5rc0NvdW50IiwiX2kiLCJfT2JqZWN0JGVudHJpZXMiLCJfT2JqZWN0JGVudHJpZXMkX2kiLCJvbkVuZCIsIlNwYW5Qcm9jZXNzb3IiLCJwZW5kaW5nU3BhbnMiLCJfcGFyZW50Q29udGV4dCIsIlRyYWNlciIsImNvbnRleHRNYW5hZ2VyIiwicGFyZW50U3BhbiIsInBhcmVudFNwYW5Db250ZXh0IiwidHJhY2VGbGFncyIsInRyYWNlU3RhdGUiLCJTUEFOX0tFWSIsImNyZWF0ZVRyYWNlciIsIl90aGlzJG9wdGlvbnMkcGF5bG9hZCIsIl90aGlzJG9wdGlvbnMkcGF5bG9hZDIiLCJnZXRUcmFjZXIiLCJzZXRTcGFuIiwiX3RoaXMkY29udGV4dE1hbmFnZXIiLCJ3aXRoU3BhbiIsInBheWxvYWRPcHRpb25zIiwidHJhY2VQYXRoIiwibmV3RXh0cmEiLCJuZXdJdGVtIiwiaXNQcm9taXNlIiwicHJvbWlzZWRJdGVtIiwiY29uZmlnS2V5IiwiYWRkRnVuY3Rpb25PcHRpb24iLCJjb25maWd1cmVkT3B0aW9ucyIsImNvbmZpZ3VyZWRfb3B0aW9ucyIsImlzX2Fub255bW91cyIsImlzX3VuY2F1Z2h0IiwicmF3X2Vycm9yIiwiY29uc3RydWN0b3JfbmFtZSIsImZhaWxlZCIsImpzb25CYWNrdXAiLCJzZWxlY3RGcmFtZXMiLCJ0cnVuY2F0ZUZyYW1lcyIsIm1heWJlVHJ1bmNhdGVWYWx1ZSIsInZhbCIsInRydW5jYXRlU3RyaW5ncyIsInRydW5jYXRvciIsInR5cGVOYW1lIiwidHJ1bmNhdGVUcmFjZURhdGEiLCJ0cmFjZURhdGEiLCJtaW5Cb2R5IiwibmVlZHNUcnVuY2F0aW9uIiwibWF4U2l6ZSIsIm1heEJ5dGVTaXplIiwic3RyYXRlZ2llcyIsInN0cmF0ZWd5IiwicmVzdWx0cyIsIlJvbGxiYXJKU09OIiwiaXNEZWZpbmVkIiwiaXNOYXRpdmVGdW5jdGlvbiIsIngiLCJyZVJlZ0V4cENoYXIiLCJmdW5jTWF0Y2hTdHJpbmciLCJyZUlzTmF0aXZlIiwiaXNPYmplY3QiLCJpc1N0cmluZyIsImlzRmluaXRlIiwiaXNJdGVyYWJsZSIsInV1aWQ0IiwicmFuZG9tIiwiYmFzZVVybFBhcnRzIiwicGFyc2VVcmkiLCJhbmNob3IiLCJwYXJzZVVyaU9wdGlvbnMiLCJzdHJpY3RNb2RlIiwicSIsInBhcnNlciIsInN0cmljdCIsImxvb3NlIiwic3RyIiwibSIsImV4ZWMiLCJ1cmkiLCIkMCIsIiQxIiwiJDIiLCJhY2Nlc3NfdG9rZW4iLCJwYXJhbXNBcnJheSIsInNvcnQiLCJxcyIsImJhY2t1cCIsImpzb25FcnJvciIsImJhY2t1cEVycm9yIiwic3RyaW5nIiwiY291bnQiLCJjaGFyQ29kZUF0IiwibW9kZSIsImJhY2t1cE1lc3NhZ2UiLCJ1c2VyYWdlbnQiLCJ3cmFwQ2FsbGJhY2siLCJub25DaXJjdWxhckNsb25lIiwibmV3U2VlbiIsInJlcXVlc3RLZXlzIiwibGFtYmRhQ29udGV4dCIsImV4dHJhQXJncyIsImFyZ1R5cGVzIiwidHlwIiwiRE9NRXhjZXB0aW9uIiwic2V0Q3VzdG9tSXRlbUtleXMiLCJvcmlnaW5hbF9hcmdfdHlwZXMiLCJlcnJvcnMiLCJjb250ZXh0QWRkZWQiLCJyb2xsYmFyQ29udGV4dCIsImVycm9yX2NvbnRleHQiLCJURUxFTUVUUllfVFlQRVMiLCJURUxFTUVUUllfTEVWRUxTIiwiYXJyYXlJbmNsdWRlcyIsIl9pdGVtJGRhdGEkYXR0cmlidXRlcyIsInRlbXAiLCJyZXBsYWNlbWVudCIsImZpbHRlcklwIiwibmV3SXAiLCJiZWdpbm5pbmciLCJzbGFzaElkeCIsInRlcm1pbmFsIiwidXBkYXRlRGVwcmVjYXRlZE9wdGlvbnMiLCJvdmVyd3JpdGVTY3J1YkZpZWxkcyIsImhvc3RXaGl0ZUxpc3QiLCJob3N0QmxhY2tMaXN0IiwiSGVhZGVycyIsIkZldGNoSGVhZGVycyIsIm5vcm1hbGl6ZU5hbWUiLCJub3JtYWxpemVWYWx1ZSIsIml0ZXJhdG9yRm9yIiwiaXRlbXMiLCJhcHBlbmQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2xkVmFsdWUiLCJpc09iaiIsInNlZW5JbmRleCIsIm1hcHBlZCIsInNhbWUiXSwic291cmNlUm9vdCI6IiJ9