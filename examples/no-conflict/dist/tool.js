(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["tool"] = factory();
	else
		root["tool"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n// Use noconflict so we can embed rollbar.js in this library\nvar Rollbar = __webpack_require__(1);\n\nvar rollbar = new Rollbar({\n  //accessToken: 'POST_CLIENT_ITEM_TOKEN',\n  accessToken: '12c99de67a444c229fca100e0967486f',\n  captureUncaught: true,\n  captureUnhandledRejections: true\n});\n\nmodule.exports = function tool(x) {\n  rollbar.log('foobar got data', { x: x });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi90b29sLmpzPzQ4ZDEiXSwibmFtZXMiOlsiUm9sbGJhciIsInJlcXVpcmUiLCJyb2xsYmFyIiwiYWNjZXNzVG9rZW4iLCJjYXB0dXJlVW5jYXVnaHQiLCJjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucyIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0b29sIiwieCIsImxvZyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBLElBQU1DLFVBQVUsSUFBSUYsT0FBSixDQUFZO0FBQzFCO0FBQ0FHLGVBQWEsa0NBRmE7QUFHMUJDLG1CQUFpQixJQUhTO0FBSTFCQyw4QkFBNEI7QUFKRixDQUFaLENBQWhCOztBQU9BQyxPQUFPQyxPQUFQLEdBQWlCLFNBQVNDLElBQVQsQ0FBY0MsQ0FBZCxFQUFpQjtBQUNoQ1AsVUFBUVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLEVBQUNELElBQUQsRUFBL0I7QUFDRCxDQUZEIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVc2Ugbm9jb25mbGljdCBzbyB3ZSBjYW4gZW1iZWQgcm9sbGJhci5qcyBpbiB0aGlzIGxpYnJhcnlcbnZhciBSb2xsYmFyID0gcmVxdWlyZSgncm9sbGJhci9kaXN0L3JvbGxiYXIubm9jb25mbGljdC51bWQnKTtcblxuY29uc3Qgcm9sbGJhciA9IG5ldyBSb2xsYmFyKHtcbiAgLy9hY2Nlc3NUb2tlbjogJ1BPU1RfQ0xJRU5UX0lURU1fVE9LRU4nLFxuICBhY2Nlc3NUb2tlbjogJzEyYzk5ZGU2N2E0NDRjMjI5ZmNhMTAwZTA5Njc0ODZmJyxcbiAgY2FwdHVyZVVuY2F1Z2h0OiB0cnVlLFxuICBjYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9uczogdHJ1ZVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b29sKHgpIHtcbiAgcm9sbGJhci5sb2coJ2Zvb2JhciBnb3QgZGF0YScsIHt4fSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Rvb2wuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar rollbar = __webpack_require__(2);\n\t\n\tif (window && !window._rollbarStartTime) {\n\t  window._rollbarStartTime = (new Date()).getTime();\n\t}\n\t\n\tmodule.exports = rollbar;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Client = __webpack_require__(3);\n\tvar _ = __webpack_require__(6);\n\tvar API = __webpack_require__(10);\n\tvar logger = __webpack_require__(12);\n\tvar globals = __webpack_require__(15);\n\t\n\tvar transport = __webpack_require__(16);\n\tvar urllib = __webpack_require__(17);\n\t\n\tvar transforms = __webpack_require__(18);\n\tvar predicates = __webpack_require__(22);\n\tvar errorParser = __webpack_require__(19);\n\t\n\tfunction Rollbar(options, client) {\n\t  this.options = _.extend(true, defaultOptions, options);\n\t  var api = new API(this.options, transport, urllib);\n\t  this.client = client || new Client(this.options, api, logger);\n\t  addTransformsToNotifier(this.client.notifier);\n\t  addPredicatesToQueue(this.client.queue);\n\t  if (this.options.captureUncaught) {\n\t    globals.captureUncaughtExceptions(window, this);\n\t    globals.wrapGlobals(window, this);\n\t  }\n\t  if (this.options.captureUnhandledRejections) {\n\t    globals.captureUnhandledRejections(window, this);\n\t  }\n\t}\n\t\n\tRollbar.prototype.global = function(options) {\n\t  this.client.global(options);\n\t  return this;\n\t};\n\t\n\tRollbar.prototype.configure = function(options) {\n\t  var oldOptions = this.options;\n\t  this.options = _.extend(true, {}, oldOptions, options);\n\t  this.client.configure(options);\n\t  return this;\n\t};\n\t\n\tRollbar.prototype.log = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.log(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.debug = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.debug(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.info = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.info(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.warn = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.warn(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.warning = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.warning(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.error = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.error(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.critical = function() {\n\t  var item = this._createItem(arguments);\n\t  var uuid = item.uuid;\n\t  this.client.critical(item);\n\t  return {uuid: uuid};\n\t};\n\t\n\tRollbar.prototype.handleUncaughtException = function(message, url, lineno, colno, error, context) {\n\t  var item;\n\t  var stackInfo = _.makeUnhandledStackInfo(\n\t    message,\n\t    url,\n\t    lineno,\n\t    colno,\n\t    error,\n\t    'onerror',\n\t    'uncaught exception',\n\t    errorParser\n\t  );\n\t  if (_.isError(error)) {\n\t    item = this._createItem([message, error, context]);\n\t    item._unhandledStackInfo = stackInfo;\n\t  } else if (_.isError(url)) {\n\t    item = this._createItem([message, url, context]);\n\t    item._unhandledStackInfo = stackInfo;\n\t  } else {\n\t    item = this._createItem([message, context]);\n\t    item.stackInfo = stackInfo;\n\t  }\n\t  item.level = this.options.uncaughtErrorLevel;\n\t  item._isUncaught = true;\n\t  this.client.log(item);\n\t};\n\t\n\tRollbar.prototype.handleUnhandledRejection = function(reason, promise) {\n\t  var message = 'unhandled rejection was null or undefined!';\n\t  message = reason ? (reason.message || String(reason)) : message;\n\t  var context = (reason && reason._rollbarContext) || (promise && promise._rollbarContext);\n\t\n\t  var item;\n\t  if (_.isError(reason)) {\n\t    item = this._createItem([message, reason, context]);\n\t  } else {\n\t    item = this._createItem([message, context]);\n\t    item.stackInfo = _.makeUnhandledStackInfo(\n\t      message,\n\t      '',\n\t      0,\n\t      0,\n\t      null,\n\t      'unhandledrejection',\n\t      '',\n\t      errorParser\n\t    );\n\t  }\n\t  item.level = this.options.uncaughtErrorLevel;\n\t  item._isUncaught = true;\n\t  this.client.log(item);\n\t};\n\t\n\tRollbar.prototype.wrap = function(f, context) {\n\t  try {\n\t    var ctxFn;\n\t    if(_.isFunction(context)) {\n\t      ctxFn = context;\n\t    } else {\n\t      ctxFn = function() { return context || {}; };\n\t    }\n\t\n\t    if (!_.isFunction(f)) {\n\t      return f;\n\t    }\n\t\n\t    if (f._isWrap) {\n\t      return f;\n\t    }\n\t\n\t    if (!f._wrapped) {\n\t      f._wrapped = function () {\n\t        try {\n\t          return f.apply(this, arguments);\n\t        } catch(exc) {\n\t          var e = exc;\n\t          if (_.isType(e, 'string')) {\n\t            e = new String(e);\n\t          }\n\t          e._rollbarContext = ctxFn() || {};\n\t          e._rollbarContext._wrappedSource = f.toString();\n\t\n\t          window._rollbarWrappedError = e;\n\t          throw e;\n\t        }\n\t      };\n\t\n\t      f._wrapped._isWrap = true;\n\t\n\t      if (f.hasOwnProperty) {\n\t        for (var prop in f) {\n\t          if (f.hasOwnProperty(prop)) {\n\t            f._wrapped[prop] = f[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    return f._wrapped;\n\t  } catch (e) {\n\t    // Return the original function if the wrap fails.\n\t    return f;\n\t  }\n\t};\n\t\n\t/* Internal */\n\t\n\tfunction addTransformsToNotifier(notifier) {\n\t  notifier\n\t    .addTransform(transforms.handleItemWithError)\n\t    .addTransform(transforms.ensureItemHasSomethingToSay)\n\t    .addTransform(transforms.addBaseInfo)\n\t    .addTransform(transforms.addRequestInfo(window))\n\t    .addTransform(transforms.addClientInfo(window))\n\t    .addTransform(transforms.addPluginInfo(window))\n\t    .addTransform(transforms.addBody)\n\t    .addTransform(transforms.scrubPayload)\n\t    .addTransform(transforms.userTransform)\n\t    .addTransform(transforms.itemToPayload);\n\t}\n\t\n\tfunction addPredicatesToQueue(queue) {\n\t  queue\n\t    .addPredicate(predicates.checkIgnore)\n\t    .addPredicate(predicates.userCheckIgnore)\n\t    .addPredicate(predicates.urlIsWhitelisted)\n\t    .addPredicate(predicates.messageIsIgnored);\n\t}\n\t\n\tRollbar.prototype._createItem = function(args) {\n\t  var message, err, custom, callback;\n\t  var arg;\n\t  var extraArgs = [];\n\t\n\t  for (var i = 0, l = args.length; i < l; ++i) {\n\t    arg = args[i];\n\t\n\t    switch (_.typeName(arg)) {\n\t      case 'undefined':\n\t        break;\n\t      case 'string':\n\t        message ? extraArgs.push(arg) : message = arg;\n\t        break;\n\t      case 'function':\n\t        callback = _.wrapRollbarFunction(logger, arg, this);\n\t        break;\n\t      case 'date':\n\t        extraArgs.push(arg);\n\t        break;\n\t      case 'error':\n\t      case 'domexception':\n\t        err ? extraArgs.push(arg) : err = arg;\n\t        break;\n\t      case 'object':\n\t      case 'array':\n\t        if (arg instanceof Error || (typeof DOMException !== 'undefined' && arg instanceof DOMException)) {\n\t          err ? extraArgs.push(arg) : err = arg;\n\t          break;\n\t        }\n\t        custom ? extraArgs.push(arg) : custom = arg;\n\t        break;\n\t      default:\n\t        if (arg instanceof Error || (typeof DOMException !== 'undefined' && arg instanceof DOMException)) {\n\t          err ? extraArgs.push(arg) : err = arg;\n\t          break;\n\t        }\n\t        extraArgs.push(arg);\n\t    }\n\t  }\n\t\n\t  if (extraArgs.length > 0) {\n\t    // if custom is an array this turns it into an object with integer keys\n\t    custom = _.extend(true, {}, custom);\n\t    custom.extraArgs = extraArgs;\n\t  }\n\t\n\t  var item = {\n\t    message: message,\n\t    err: err,\n\t    custom: custom,\n\t    timestamp: (new Date()).getTime(),\n\t    callback: callback,\n\t    uuid: _.uuid4()\n\t  };\n\t  item._originalArgs = args;\n\t  return item;\n\t};\n\t\n\t/* global __NOTIFIER_VERSION__:false */\n\t/* global __DEFAULT_BROWSER_SCRUB_FIELDS__:false */\n\t/* global __DEFAULT_LOG_LEVEL__:false */\n\t/* global __DEFAULT_REPORT_LEVEL__:false */\n\t/* global __DEFAULT_UNCAUGHT_ERROR_LEVEL:false */\n\t/* global __DEFAULT_ENDPOINT__:false */\n\t\n\tvar defaultOptions = {\n\t  version: (\"2.0.3\"),\n\t  scrubFields: ([\"pw\",\"pass\",\"passwd\",\"password\",\"secret\",\"confirm_password\",\"confirmPassword\",\"password_confirmation\",\"passwordConfirmation\",\"access_token\",\"accessToken\",\"secret_key\",\"secretKey\",\"secretToken\"]),\n\t  logLevel: (\"debug\"),\n\t  reportLevel: (\"debug\"),\n\t  uncaughtErrorLevel: (\"error\"),\n\t  endpoint: (\"api.rollbar.com/api/1/\"),\n\t  enabled: true\n\t};\n\t\n\tmodule.exports = Rollbar;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar RateLimiter = __webpack_require__(4);\n\tvar Queue = __webpack_require__(5);\n\tvar Notifier = __webpack_require__(9);\n\tvar _ = __webpack_require__(6);\n\t\n\t/*\n\t * Rollbar - the interface to Rollbar\n\t *\n\t * @param options\n\t * @param api\n\t * @param logger\n\t */\n\tfunction Rollbar(options, api, logger) {\n\t  this.options = _.extend(true, {}, options);\n\t  this.logger = logger;\n\t  this.queue = new Queue(Rollbar.rateLimiter, api, this.options);\n\t  this.notifier = new Notifier(this.queue, this.options);\n\t}\n\t\n\tvar defaultOptions = {\n\t  maxItems: 0,\n\t  itemsPerMinute: 60\n\t};\n\t\n\tRollbar.rateLimiter = new RateLimiter(defaultOptions);\n\t\n\tRollbar.prototype.global = function(options) {\n\t  Rollbar.rateLimiter.configureGlobal(options);\n\t  return this;\n\t};\n\t\n\tRollbar.prototype.configure = function(options) {\n\t  this.notifier && this.notifier.configure(options);\n\t  var oldOptions = this.options;\n\t  this.options = _.extend(true, {}, oldOptions, options);\n\t  return this;\n\t};\n\t\n\tRollbar.prototype.log = function(item) {\n\t  var level = this._defaultLogLevel();\n\t  return this._log(level, item);\n\t};\n\t\n\tRollbar.prototype.debug = function(item) {\n\t  this._log('debug', item);\n\t};\n\t\n\tRollbar.prototype.info = function(item) {\n\t  this._log('info', item);\n\t};\n\t\n\tRollbar.prototype.warn = function(item) {\n\t  this._log('warning', item);\n\t};\n\t\n\tRollbar.prototype.warning = function(item) {\n\t  this._log('warning', item);\n\t};\n\t\n\tRollbar.prototype.error = function(item) {\n\t  this._log('error', item);\n\t};\n\t\n\tRollbar.prototype.critical = function(item) {\n\t  this._log('critical', item);\n\t};\n\t\n\tRollbar.prototype.wait = function(callback) {\n\t  this.queue.wait(callback);\n\t};\n\t\n\t/* Internal */\n\t\n\tRollbar.prototype._log = function(defaultLevel, item) {\n\t  _.wrapRollbarFunction(this.logger, function() {\n\t    var callback = null;\n\t    if (item.callback) {\n\t      callback = item.callback;\n\t      delete item.callback;\n\t    }\n\t    item.level = item.level || defaultLevel;\n\t    this.notifier.log(item, callback);\n\t  }, this)();\n\t};\n\t\n\tRollbar.prototype._defaultLogLevel = function() {\n\t  return this.options.logLevel || 'debug';\n\t};\n\t\n\tmodule.exports = Rollbar;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t * RateLimiter - an object that encapsulates the logic for counting items sent to Rollbar\n\t *\n\t * @param options - the same options that are accepted by configureGlobal offered as a convenience\n\t */\n\tfunction RateLimiter(options) {\n\t  this.startTime = (new Date()).getTime();\n\t  this.counter = 0;\n\t  this.perMinCounter = 0;\n\t  this.configureGlobal(options);\n\t}\n\t\n\tRateLimiter.globalSettings = {\n\t  startTime: (new Date()).getTime(),\n\t  maxItems: undefined,\n\t  itemsPerMinute: undefined\n\t};\n\t\n\t/*\n\t * configureGlobal - set the global rate limiter options\n\t *\n\t * @param options - Only the following values are recognized:\n\t *    startTime: a timestamp of the form returned by (new Date()).getTime()\n\t *    maxItems: the maximum items\n\t *    itemsPerMinute: the max number of items to send in a given minute\n\t */\n\tRateLimiter.prototype.configureGlobal = function(options) {\n\t  if (options.startTime !== undefined) {\n\t    RateLimiter.globalSettings.startTime = options.startTime;\n\t  }\n\t  if (options.maxItems !== undefined) {\n\t    RateLimiter.globalSettings.maxItems = options.maxItems;\n\t  }\n\t  if (options.itemsPerMinute !== undefined) {\n\t    RateLimiter.globalSettings.itemsPerMinute = options.itemsPerMinute;\n\t  }\n\t};\n\t\n\t/*\n\t * shouldSend - determine if we should send a given item based on rate limit settings\n\t *\n\t * @param item - the item we are about to send\n\t * @returns An object with the following structure:\n\t *  error: (Error|null)\n\t *  shouldSend: bool\n\t *  payload: (Object|null)\n\t *  If shouldSend is false, the item passed as a parameter should not be sent to Rollbar, and\n\t *  exactly one of error or payload will be non-null. If error is non-null, the returned Error will\n\t *  describe the situation, but it means that we were already over a rate limit (either globally or\n\t *  per minute) when this item was checked. If error is null, and therefore payload is non-null, it\n\t *  means this item put us over the global rate limit and the payload should be sent to Rollbar in\n\t *  place of the passed in item.\n\t */\n\tRateLimiter.prototype.shouldSend = function(item, now) {\n\t  now = now || (new Date()).getTime();\n\t  if (now - this.startTime >= 60000) {\n\t    this.startTime = now;\n\t    this.perMinCounter = 0;\n\t  }\n\t\n\t  var globalRateLimit = RateLimiter.globalSettings.maxItems;\n\t  var globalRateLimitPerMin = RateLimiter.globalSettings.itemsPerMinute;\n\t\n\t  if (checkRate(item, globalRateLimit, this.counter)) {\n\t    return shouldSendValue(globalRateLimit + ' max items reached', false);\n\t  } else if (checkRate(item, globalRateLimitPerMin, this.perMinCounter)) {\n\t    return shouldSendValue(globalRateLimitPerMin + ' items per minute reached', false);\n\t  }\n\t  this.counter++;\n\t  this.perMinCounter++;\n\t\n\t  var shouldSend = !checkRate(item, globalRateLimit, this.counter);\n\t  return shouldSendValue(null, shouldSend, globalRateLimit);\n\t};\n\t\n\t/* Helpers */\n\t\n\tfunction checkRate(item, limit, counter) {\n\t  return !item.ignoreRateLimit && limit >= 1 && counter >= limit;\n\t}\n\t\n\tfunction shouldSendValue(error, shouldSend, globalRateLimit) {\n\t  var payload = null;\n\t  if (error) {\n\t    error = new Error(error);\n\t  }\n\t  if (!error && !shouldSend) {\n\t    payload = rateLimitPayload(globalRateLimit);\n\t  }\n\t  return {error: error, shouldSend: shouldSend, payload: payload};\n\t}\n\t\n\tfunction rateLimitPayload(globalRateLimit) {\n\t  return {\n\t    message: 'maxItems has been hit. Ignoring errors until reset.',\n\t    err: null,\n\t    custom: {\n\t      maxItems: globalRateLimit\n\t    }\n\t  };\n\t}\n\t\n\tmodule.exports = RateLimiter;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\t\n\t/*\n\t * Queue - an object which handles which handles a queue of items to be sent to Rollbar.\n\t *   This object handles rate limiting via a passed in rate limiter, retries based on connection\n\t *   errors, and filtering of items based on a set of configurable predicates. The communication to\n\t *   the backend is performed via a given API object.\n\t *\n\t * @param rateLimiter - An object which conforms to the interface\n\t *    rateLimiter.shouldSend(item) -> bool\n\t * @param api - An object which conforms to the interface\n\t *    api.postItem(payload, function(err, response))\n\t * @param options - see Queue.prototype.configure\n\t */\n\tfunction Queue(rateLimiter, api, options) {\n\t  this.rateLimiter = rateLimiter;\n\t  this.api = api;\n\t  this.options = options;\n\t  this.predicates = [];\n\t  this.pendingRequests = [];\n\t  this.retryQueue = [];\n\t  this.retryHandle = null;\n\t  this.waitCallback = null;\n\t}\n\t\n\t/*\n\t * configure - updates the options this queue uses\n\t *\n\t * @param options\n\t */\n\tQueue.prototype.configure = function(options) {\n\t  this.api && this.api.configure(options);\n\t  var oldOptions = this.options;\n\t  this.options = _.extend(true, {}, oldOptions, options);\n\t  return this;\n\t};\n\t\n\t/*\n\t * addPredicate - adds a predicate to the end of the list of predicates for this queue\n\t * \n\t * @param predicate - function(item, options) -> (bool|{err: Error})\n\t *  Returning true means that this predicate passes and the item is okay to go on the queue\n\t *  Returning false means do not add the item to the queue, but it is not an error\n\t *  Returning {err: Error} means do not add the item to the queue, and the given error explains why\n\t *  Returning {err: undefined} is equivalent to returning true but don't do that\n\t */\n\tQueue.prototype.addPredicate = function(predicate) {\n\t  if (_.isFunction(predicate)) {\n\t    this.predicates.push(predicate);\n\t  }\n\t  return this;\n\t};\n\t\n\t/*\n\t * addItem - Send an item to the Rollbar API if all of the predicates are satisfied\n\t *\n\t * @param item - The payload to send to the backend\n\t * @param callback - function(error, repsonse) which will be called with the response from the API\n\t *  in the case of a success, otherwise response will be null and error will have a value. If both\n\t *  error and response are null then the item was stopped by a predicate which did not consider this\n\t *  to be an error condition, but nonetheless did not send the item to the API.\n\t */\n\tQueue.prototype.addItem = function(item, callback) {\n\t  if (!callback || !_.isFunction(callback)) {\n\t    callback = function() { return; };\n\t  }\n\t  var predicateResult = this._applyPredicates(item);\n\t  if (predicateResult.stop) {\n\t    callback(predicateResult.err);\n\t    return;\n\t  }\n\t  if (this.waitCallback) {\n\t    callback();\n\t    return;\n\t  }\n\t  this.pendingRequests.push(item);\n\t  try {\n\t    this._makeApiRequest(item, function(err, resp) {\n\t      this._dequeuePendingRequest(item);\n\t      callback(err, resp);\n\t    }.bind(this));\n\t  } catch (e) {\n\t    this._dequeuePendingRequest(item);\n\t    callback(e);\n\t  }\n\t};\n\t\n\t/*\n\t * wait - Stop any further errors from being added to the queue, and get called back when all items\n\t *   currently processing have finished sending to the backend.\n\t *\n\t * @param callback - function() called when all pending items have been sent\n\t */\n\tQueue.prototype.wait = function(callback) {\n\t  if (!_.isFunction(callback)) {\n\t    return;\n\t  }\n\t  this.waitCallback = callback;\n\t  if (this.pendingRequests.length == 0) {\n\t    this.waitCallback();\n\t  }\n\t};\n\t\n\t/* _applyPredicates - Sequentially applies the predicates that have been added to the queue to the\n\t *   given item with the currently configured options.\n\t *\n\t * @param item - An item in the queue\n\t * @returns {stop: bool, err: (Error|null)} - stop being true means do not add item to the queue,\n\t *   the error value should be passed up to a callbak if we are stopping.\n\t */\n\tQueue.prototype._applyPredicates = function(item) {\n\t  var p = null;\n\t  for (var i = 0, len = this.predicates.length; i < len; i++) {\n\t    p = this.predicates[i](item, this.options);\n\t    if (!p || p.err !== undefined) {\n\t      return {stop: true, err: p.err};\n\t    }\n\t  }\n\t  return {stop: false, err: null};\n\t};\n\t\n\t/*\n\t * _makeApiRequest - Send an item to Rollbar, callback when done, if there is an error make an\n\t *   effort to retry if we are configured to do so.\n\t *\n\t * @param item - an item ready to send to the backend\n\t * @param callback - function(err, response)\n\t */\n\tQueue.prototype._makeApiRequest = function(item, callback) {\n\t  var rateLimitResponse = this.rateLimiter.shouldSend(item);\n\t  if (rateLimitResponse.shouldSend) {\n\t    this.api.postItem(item, function(err, resp) {\n\t      if (err) {\n\t        this._maybeRetry(err, item, callback);\n\t      } else {\n\t        callback(err, resp);\n\t      }\n\t    }.bind(this));\n\t  } else if (rateLimitResponse.error) {\n\t    callback(rateLimitResponse.error);\n\t  } else {\n\t    this.api.postItem(rateLimitResponse.payload, callback);\n\t  }\n\t};\n\t\n\t// These are errors basically mean there is no internet connection\n\tvar RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE', 'EAI_AGAIN'];\n\t\n\t/*\n\t * _maybeRetry - Given the error returned by the API, decide if we should retry or just callback\n\t *   with the error.\n\t *\n\t * @param err - an error returned by the API transport\n\t * @param item - the item that was trying to be sent when this error occured\n\t * @param callback - function(err, response)\n\t */\n\tQueue.prototype._maybeRetry = function(err, item, callback) {\n\t  var shouldRetry = false;\n\t  if (this.options.retryInterval) {\n\t    for (var i = 0, len = RETRIABLE_ERRORS.length; i < len; i++) {\n\t      if (err.code === RETRIABLE_ERRORS[i]) {\n\t        shouldRetry = true;\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  if (shouldRetry) {\n\t    this._retryApiRequest(item, callback);\n\t  } else {\n\t    callback(err);\n\t  }\n\t};\n\t\n\t/*\n\t * _retryApiRequest - Add an item and a callback to a queue and possibly start a timer to process\n\t *   that queue based on the retryInterval in the options for this queue.\n\t *\n\t * @param item - an item that failed to send due to an error we deem retriable\n\t * @param callback - function(err, response)\n\t */\n\tQueue.prototype._retryApiRequest = function(item, callback) {\n\t  this.retryQueue.push({item: item, callback: callback});\n\t\n\t  if (!this.retryHandle) {\n\t    this.retryHandle = setInterval(function() {\n\t      while (this.retryQueue.length) {\n\t        var retryObject = this.retryQueue.shift();\n\t        this._makeApiRequest(retryObject.item, retryObject.callback);\n\t      }\n\t    }.bind(this), this.options.retryInterval);\n\t  }\n\t};\n\t\n\t/*\n\t * _dequeuePendingRequest - Removes the item from the pending request queue, this queue is used to\n\t *   enable to functionality of providing a callback that clients can pass to `wait` to be notified\n\t *   when the pending request queue has been emptied. This must be called when the API finishes\n\t *   processing this item. If a `wait` callback is configured, it is called by this function.\n\t *\n\t * @param item - the item previously added to the pending request queue\n\t */\n\tQueue.prototype._dequeuePendingRequest = function(item) {\n\t  var shouldCallWaitOnRemove = this.pendingRequests.length == 1;\n\t  for (var i = this.pendingRequests.length; i >= 0; i--) {\n\t    if (this.pendingRequests[i] == item) {\n\t      this.pendingRequests.splice(i, 1);\n\t      if (shouldCallWaitOnRemove && _.isFunction(this.waitCallback)) {\n\t        this.waitCallback();\n\t      }\n\t      return;\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = Queue;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar extend = __webpack_require__(7);\n\t\n\tvar RollbarJSON = {};\n\tvar __initRollbarJSON = false;\n\tfunction setupJSON() {\n\t  if (__initRollbarJSON) {\n\t    return;\n\t  }\n\t  __initRollbarJSON = true;\n\t\n\t  if (isDefined(JSON)) {\n\t    if (isFunction(JSON.stringify)) {\n\t      RollbarJSON.stringify = JSON.stringify;\n\t    }\n\t    if (isFunction(JSON.parse)) {\n\t      RollbarJSON.parse = JSON.parse;\n\t    }\n\t  }\n\t  if (!isFunction(RollbarJSON.stringify) || !isFunction(RollbarJSON.parse)) {\n\t    var setupCustomJSON = __webpack_require__(8);\n\t    setupCustomJSON(RollbarJSON);\n\t  }\n\t}\n\tsetupJSON();\n\t\n\t/*\n\t * isType - Given a Javascript value and a string, returns true if the type of the value matches the\n\t * given string.\n\t *\n\t * @param x - any value\n\t * @param t - a lowercase string containing one of the following type names:\n\t *    - undefined\n\t *    - null\n\t *    - error\n\t *    - number\n\t *    - boolean\n\t *    - string\n\t *    - symbol\n\t *    - function\n\t *    - object\n\t *    - array\n\t * @returns true if x is of type t, otherwise false\n\t */\n\tfunction isType(x, t) {\n\t  return t === typeName(x);\n\t}\n\t\n\t/*\n\t * typeName - Given a Javascript value, returns the type of the object as a string\n\t */\n\tfunction typeName(x) {\n\t  var name = typeof x;\n\t  if (name !== 'object') {\n\t    return name;\n\t  }\n\t  if (!x) {\n\t    return 'null';\n\t  }\n\t  if (x instanceof Error) {\n\t    return 'error';\n\t  }\n\t  return ({}).toString.call(x).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n\t}\n\t\n\t/* isFunction - a convenience function for checking if a value is a function\n\t *\n\t * @param f - any value\n\t * @returns true if f is a function, otherwise false\n\t */\n\tfunction isFunction(f) {\n\t  return isType(f, 'function');\n\t}\n\t\n\t/*\n\t * isDefined - a convenience function for checking if a value is not equal to undefined\n\t *\n\t * @param u - any value\n\t * @returns true if u is anything other than undefined\n\t */\n\tfunction isDefined(u) {\n\t  return !isType(u, 'undefined');\n\t}\n\t\n\t/*\n\t * isIterable - convenience function for checking if a value can be iterated, essentially\n\t * whether it is an object or an array.\n\t *\n\t * @param i - any value\n\t * @returns true if i is an object or an array as determined by `typeName`\n\t */\n\tfunction isIterable(i) {\n\t  var type = typeName(i);\n\t  return (type === 'object' || type === 'array');\n\t}\n\t\n\t/*\n\t * isError - convenience function for checking if a value is of an error type\n\t *\n\t * @param e - any value\n\t * @returns true if e is an error\n\t */\n\tfunction isError(e) {\n\t  return isType(e, 'error');\n\t}\n\t\n\t/* wrapRollbarFunction - puts a try/catch around a function, logs caught exceptions to console.error\n\t *\n\t * @param f - a function\n\t * @param ctx - an optional context to bind the function to\n\t */\n\tfunction wrapRollbarFunction(logger, f, ctx) {\n\t  return function() {\n\t    var self = ctx || this;\n\t    try {\n\t      return f.apply(self, arguments);\n\t    } catch (e) {\n\t      logger.error(e);\n\t    }\n\t  };\n\t}\n\t\n\tfunction traverse(obj, func) {\n\t  var k;\n\t  var v;\n\t  var i;\n\t  var isObj = isType(obj, 'object');\n\t  var isArray = isType(obj, 'array');\n\t  var keys = [];\n\t\n\t  if (isObj) {\n\t    for (k in obj) {\n\t      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n\t        keys.push(k);\n\t      }\n\t    }\n\t  } else if (isArray) {\n\t    for (i = 0; i < obj.length; ++i) {\n\t      keys.push(i);\n\t    }\n\t  }\n\t\n\t  for (i = 0; i < keys.length; ++i) {\n\t    k = keys[i];\n\t    v = obj[k];\n\t    obj[k] = func(k, v);\n\t  }\n\t\n\t  return obj;\n\t}\n\t\n\tfunction redact() {\n\t  return '********';\n\t}\n\t\n\t// from http://stackoverflow.com/a/8809472/1138191\n\tfunction uuid4() {\n\t  var d = new Date().getTime();\n\t  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t    var r = (d + Math.random() * 16) % 16 | 0;\n\t    d = Math.floor(d / 16);\n\t    return (c === 'x' ? r : (r & 0x7 | 0x8)).toString(16);\n\t  });\n\t  return uuid;\n\t}\n\t\n\tvar LEVELS = {\n\t  debug: 0,\n\t  info: 1,\n\t  warning: 2,\n\t  error: 3,\n\t  critical: 4\n\t};\n\t\n\tfunction sanitizeUrl(url) {\n\t  var baseUrlParts = parseUri(url);\n\t  // remove a trailing # if there is no anchor\n\t  if (baseUrlParts.anchor === '') {\n\t    baseUrlParts.source = baseUrlParts.source.replace('#', '');\n\t  }\n\t\n\t  url = baseUrlParts.source.replace('?' + baseUrlParts.query, '');\n\t  return url;\n\t}\n\t\n\tvar parseUriOptions = {\n\t  strictMode: false,\n\t  key: [\n\t    'source',\n\t    'protocol',\n\t    'authority',\n\t    'userInfo',\n\t    'user',\n\t    'password',\n\t    'host',\n\t    'port',\n\t    'relative',\n\t    'path',\n\t    'directory',\n\t    'file',\n\t    'query',\n\t    'anchor'\n\t  ],\n\t  q: {\n\t    name: 'queryKey',\n\t    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n\t  },\n\t  parser: {\n\t    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n\t    loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n\t  }\n\t};\n\t\n\tfunction parseUri(str) {\n\t  if (!isType(str, 'string')) {\n\t    throw new Error('received invalid input');\n\t  }\n\t\n\t  var o = parseUriOptions;\n\t  var m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str);\n\t  var uri = {};\n\t  var i = o.key.length;\n\t\n\t  while (i--) {\n\t    uri[o.key[i]] = m[i] || '';\n\t  }\n\t\n\t  uri[o.q.name] = {};\n\t  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[o.q.name][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\tfunction addParamsAndAccessTokenToPath(accessToken, options, params) {\n\t  params = params || {};\n\t  params.access_token = accessToken;\n\t  var paramsArray = [];\n\t  var k;\n\t  for (k in params) {\n\t    if (Object.prototype.hasOwnProperty.call(params, k)) {\n\t      paramsArray.push([k, params[k]].join('='));\n\t    }\n\t  }\n\t  var query = '?' + paramsArray.sort().join('&');\n\t\n\t  options = options || {};\n\t  options.path = options.path || '';\n\t  var qs = options.path.indexOf('?');\n\t  var h = options.path.indexOf('#');\n\t  var p;\n\t  if (qs !== -1 && (h === -1 || h > qs)) {\n\t    p = options.path;\n\t    options.path = p.substring(0,qs) + query + '&' + p.substring(qs+1);\n\t  } else {\n\t    if (h !== -1) {\n\t      p = options.path;\n\t      options.path = p.substring(0,h) + query + p.substring(h);\n\t    } else {\n\t      options.path = options.path + query;\n\t    }\n\t  }\n\t}\n\t\n\tfunction formatUrl(u, protocol) {\n\t  protocol = protocol || u.protocol;\n\t  if (!protocol && u.port) {\n\t    if (u.port === 80) {\n\t      protocol = 'http:';\n\t    } else if (u.port === 443) {\n\t      protocol = 'https:';\n\t    }\n\t  }\n\t  protocol = protocol || 'https:';\n\t\n\t  if (!u.hostname) {\n\t    return null;\n\t  }\n\t  var result = protocol + '//' + u.hostname;\n\t  if (u.port) {\n\t    result = result + ':' + u.port;\n\t  }\n\t  if (u.path) {\n\t    result = result + u.path;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction stringify(obj, backup) {\n\t  var value, error;\n\t  try {\n\t    value = RollbarJSON.stringify(obj);\n\t  } catch (jsonError) {\n\t    if (backup && isFunction(backup)) {\n\t      try {\n\t        value = backup(obj);\n\t      } catch (backupError) {\n\t        error = backupError;\n\t      }\n\t    } else {\n\t      error = jsonError;\n\t    }\n\t  }\n\t  return {error: error, value: value};\n\t}\n\t\n\tfunction jsonParse(s) {\n\t  var value, error;\n\t  try {\n\t    value = RollbarJSON.parse(s);\n\t  } catch (e) {\n\t    error = e;\n\t  }\n\t  return {error: error, value: value};\n\t}\n\t\n\tfunction makeUnhandledStackInfo(\n\t  message,\n\t  url,\n\t  lineno,\n\t  colno,\n\t  error,\n\t  mode,\n\t  backupMessage,\n\t  errorParser\n\t) {\n\t  var location = {\n\t    url: url || '',\n\t    line: lineno,\n\t    column: colno\n\t  };\n\t  location.func = errorParser.guessFunctionName(location.url, location.line);\n\t  location.context = errorParser.gatherContext(location.url, location.line);\n\t  var href = document && document.location && document.location.href;\n\t  var useragent = window && window.navigator && window.navigator.userAgent;\n\t  return {\n\t    'mode': mode,\n\t    'message': error ? String(error) : (message || backupMessage),\n\t    'url': href,\n\t    'stack': [location],\n\t    'useragent': useragent\n\t  };\n\t}\n\t\n\t/*\n\t * get - given an obj/array and a keypath, return the value at that keypath or\n\t *       undefined if not possible.\n\t *\n\t * @param obj - an object or array\n\t * @param path - a string of keys separated by '.' such as 'plugin.jquery.0.message'\n\t *    which would correspond to 42 in `{plugin: {jquery: [{message: 42}]}}`\n\t */\n\tfunction get(obj, path) {\n\t  if (!obj) {\n\t    return undefined;\n\t  }\n\t  var keys = path.split('.');\n\t  var result = obj;\n\t  try {\n\t    for (var i = 0, len = keys.length; i < len; ++i) {\n\t      result = result[keys[i]];\n\t    }\n\t  } catch (e) {\n\t    result = undefined;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction set(obj, path, value) {\n\t  if (!obj) {\n\t    return;\n\t  }\n\t  var keys = path.split('.');\n\t  var len = keys.length;\n\t  if (len < 1) {\n\t    return;\n\t  }\n\t  if (len === 1) {\n\t    obj[keys[0]] = value;\n\t    return;\n\t  }\n\t  try {\n\t    var temp = obj[keys[0]] || {};\n\t    var replacement = temp;\n\t    for (var i = 1; i < len-1; i++) {\n\t      temp[keys[i]] = temp[keys[i]] || {};\n\t      temp = temp[keys[i]];\n\t    }\n\t    temp[keys[len-1]] = value;\n\t    obj[keys[0]] = replacement;\n\t  } catch (e) {\n\t    return;\n\t  }\n\t}\n\t\n\tfunction scrub(data, scrubFields) {\n\t  scrubFields = scrubFields || [];\n\t  var paramRes = _getScrubFieldRegexs(scrubFields);\n\t  var queryRes = _getScrubQueryParamRegexs(scrubFields);\n\t\n\t  function redactQueryParam(dummy0, paramPart, dummy1, dummy2, dummy3, valPart) {\n\t    return paramPart + redact(valPart);\n\t  }\n\t\n\t  function paramScrubber(v) {\n\t    var i;\n\t    if (isType(v, 'string')) {\n\t      for (i = 0; i < queryRes.length; ++i) {\n\t        v = v.replace(queryRes[i], redactQueryParam);\n\t      }\n\t    }\n\t    return v;\n\t  }\n\t\n\t  function valScrubber(k, v) {\n\t    var i;\n\t    for (i = 0; i < paramRes.length; ++i) {\n\t      if (paramRes[i].test(k)) {\n\t        v = redact(v);\n\t        break;\n\t      }\n\t    }\n\t    return v;\n\t  }\n\t\n\t  function scrubber(k, v) {\n\t    var tmpV = valScrubber(k, v);\n\t    if (tmpV === v) {\n\t      if (isType(v, 'object') || isType(v, 'array')) {\n\t        return traverse(v, scrubber);\n\t      }\n\t      return paramScrubber(tmpV);\n\t    } else {\n\t      return tmpV;\n\t    }\n\t  }\n\t\n\t  traverse(data, scrubber);\n\t  return data;\n\t}\n\t\n\tfunction _getScrubFieldRegexs(scrubFields) {\n\t  var ret = [];\n\t  var pat;\n\t  for (var i = 0; i < scrubFields.length; ++i) {\n\t    pat = '\\\\[?(%5[bB])?' + scrubFields[i] + '\\\\[?(%5[bB])?\\\\]?(%5[dD])?';\n\t    ret.push(new RegExp(pat, 'i'));\n\t  }\n\t  return ret;\n\t}\n\t\n\t\n\tfunction _getScrubQueryParamRegexs(scrubFields) {\n\t  var ret = [];\n\t  var pat;\n\t  for (var i = 0; i < scrubFields.length; ++i) {\n\t    pat = '\\\\[?(%5[bB])?' + scrubFields[i] + '\\\\[?(%5[bB])?\\\\]?(%5[dD])?';\n\t    ret.push(new RegExp('(' + pat + '=)([^&\\\\n]+)', 'igm'));\n\t  }\n\t  return ret;\n\t}\n\t\n\tmodule.exports = {\n\t  isType: isType,\n\t  typeName: typeName,\n\t  isFunction: isFunction,\n\t  isIterable: isIterable,\n\t  isError: isError,\n\t  extend: extend,\n\t  traverse: traverse,\n\t  redact: redact,\n\t  uuid4: uuid4,\n\t  wrapRollbarFunction: wrapRollbarFunction,\n\t  LEVELS: LEVELS,\n\t  sanitizeUrl: sanitizeUrl,\n\t  addParamsAndAccessTokenToPath: addParamsAndAccessTokenToPath,\n\t  formatUrl: formatUrl,\n\t  stringify: stringify,\n\t  jsonParse: jsonParse,\n\t  makeUnhandledStackInfo: makeUnhandledStackInfo,\n\t  get: get,\n\t  set: set,\n\t  scrub: scrub\n\t};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) {/**/}\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0],\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t//  json3.js\n\t//  2017-02-21\n\t//  Public Domain.\n\t//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\t//  See http://www.JSON.org/js.html\n\t//  This code should be minified before deployment.\n\t//  See http://javascript.crockford.com/jsmin.html\n\t\n\t//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n\t//  NOT CONTROL.\n\t\n\t//  This file creates a global JSON object containing two methods: stringify\n\t//  and parse. This file provides the ES5 JSON capability to ES3 systems.\n\t//  If a project might run on IE8 or earlier, then this file should be included.\n\t//  This file does nothing on ES5 systems.\n\t\n\t//      JSON.stringify(value, replacer, space)\n\t//          value       any JavaScript value, usually an object or array.\n\t//          replacer    an optional parameter that determines how object\n\t//                      values are stringified for objects. It can be a\n\t//                      function or an array of strings.\n\t//          space       an optional parameter that specifies the indentation\n\t//                      of nested structures. If it is omitted, the text will\n\t//                      be packed without extra whitespace. If it is a number,\n\t//                      it will specify the number of spaces to indent at each\n\t//                      level. If it is a string (such as \"\\t\" or \"&nbsp;\"),\n\t//                      it contains the characters used to indent at each level.\n\t//          This method produces a JSON text from a JavaScript value.\n\t//          When an object value is found, if the object contains a toJSON\n\t//          method, its toJSON method will be called and the result will be\n\t//          stringified. A toJSON method does not serialize: it returns the\n\t//          value represented by the name/value pair that should be serialized,\n\t//          or undefined if nothing should be serialized. The toJSON method\n\t//          will be passed the key associated with the value, and this will be\n\t//          bound to the value.\n\t\n\t//          For example, this would serialize Dates as ISO strings.\n\t\n\t//              Date.prototype.toJSON = function (key) {\n\t//                  function f(n) {\n\t//                      // Format integers to have at least two digits.\n\t//                      return (n < 10)\n\t//                          ? \"0\" + n\n\t//                          : n;\n\t//                  }\n\t//                  return this.getUTCFullYear()   + \"-\" +\n\t//                       f(this.getUTCMonth() + 1) + \"-\" +\n\t//                       f(this.getUTCDate())      + \"T\" +\n\t//                       f(this.getUTCHours())     + \":\" +\n\t//                       f(this.getUTCMinutes())   + \":\" +\n\t//                       f(this.getUTCSeconds())   + \"Z\";\n\t//              };\n\t\n\t//          You can provide an optional replacer method. It will be passed the\n\t//          key and value of each member, with this bound to the containing\n\t//          object. The value that is returned from your method will be\n\t//          serialized. If your method returns undefined, then the member will\n\t//          be excluded from the serialization.\n\t\n\t//          If the replacer parameter is an array of strings, then it will be\n\t//          used to select the members to be serialized. It filters the results\n\t//          such that only members with keys listed in the replacer array are\n\t//          stringified.\n\t\n\t//          Values that do not have JSON representations, such as undefined or\n\t//          functions, will not be serialized. Such values in objects will be\n\t//          dropped; in arrays they will be replaced with null. You can use\n\t//          a replacer function to replace those with JSON values.\n\t\n\t//          JSON.stringify(undefined) returns undefined.\n\t\n\t//          The optional space parameter produces a stringification of the\n\t//          value that is filled with line breaks and indentation to make it\n\t//          easier to read.\n\t\n\t//          If the space parameter is a non-empty string, then that string will\n\t//          be used for indentation. If the space parameter is a number, then\n\t//          the indentation will be that many spaces.\n\t\n\t//          Example:\n\t\n\t//          text = JSON.stringify([\"e\", {pluribus: \"unum\"}]);\n\t//          // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\t\n\t//          text = JSON.stringify([\"e\", {pluribus: \"unum\"}], null, \"\\t\");\n\t//          // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\t\n\t//          text = JSON.stringify([new Date()], function (key, value) {\n\t//              return this[key] instanceof Date\n\t//                  ? \"Date(\" + this[key] + \")\"\n\t//                  : value;\n\t//          });\n\t//          // text is '[\"Date(---current time---)\"]'\n\t\n\t//      JSON.parse(text, reviver)\n\t//          This method parses a JSON text to produce an object or array.\n\t//          It can throw a SyntaxError exception.\n\t//          This has been modified to use JSON-js/json_parse_state.js as the\n\t//          parser instead of the one built around eval found in JSON-js/json2.js\n\t\n\t//          The optional reviver parameter is a function that can filter and\n\t//          transform the results. It receives each of the keys and values,\n\t//          and its return value is used instead of the original value.\n\t//          If it returns what it received, then the structure is not modified.\n\t//          If it returns undefined then the member is deleted.\n\t\n\t//          Example:\n\t\n\t//          // Parse the text. Values that look like ISO date strings will\n\t//          // be converted to Date objects.\n\t\n\t//          myData = JSON.parse(text, function (key, value) {\n\t//              var a;\n\t//              if (typeof value === \"string\") {\n\t//                  a =\n\t//   /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n\t//                  if (a) {\n\t//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n\t//                          +a[5], +a[6]));\n\t//                  }\n\t//              }\n\t//              return value;\n\t//          });\n\t\n\t//          myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n\t//              var d;\n\t//              if (typeof value === \"string\" &&\n\t//                      value.slice(0, 5) === \"Date(\" &&\n\t//                      value.slice(-1) === \")\") {\n\t//                  d = new Date(value.slice(5, -1));\n\t//                  if (d) {\n\t//                      return d;\n\t//                  }\n\t//              }\n\t//              return value;\n\t//          });\n\t\n\t//  This is a reference implementation. You are free to copy, modify, or\n\t//  redistribute.\n\t\n\t/*jslint\n\t  for, this\n\t  */\n\t\n\t/*property\n\t  JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n\t  getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n\t  lastIndex, length, parse, prototype, push, replace, slice, stringify,\n\t  test, toJSON, toString, valueOf\n\t  */\n\t\n\tvar setupCustomJSON = function(JSON) {\n\t\n\t  var rx_one = /^[\\],:{}\\s]*$/;\n\t  var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\n\t  var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n\t  var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n\t  var rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\t  var rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\t\n\t  function f(n) {\n\t    // Format integers to have at least two digits.\n\t    return n < 10\n\t      ? \"0\" + n\n\t      : n;\n\t  }\n\t\n\t  function this_value() {\n\t    return this.valueOf();\n\t  }\n\t\n\t  if (typeof Date.prototype.toJSON !== \"function\") {\n\t\n\t    Date.prototype.toJSON = function () {\n\t\n\t      return isFinite(this.valueOf())\n\t        ? this.getUTCFullYear() + \"-\" +\n\t        f(this.getUTCMonth() + 1) + \"-\" +\n\t        f(this.getUTCDate()) + \"T\" +\n\t        f(this.getUTCHours()) + \":\" +\n\t        f(this.getUTCMinutes()) + \":\" +\n\t        f(this.getUTCSeconds()) + \"Z\"\n\t        : null;\n\t    };\n\t\n\t    Boolean.prototype.toJSON = this_value;\n\t    Number.prototype.toJSON = this_value;\n\t    String.prototype.toJSON = this_value;\n\t  }\n\t\n\t  var gap;\n\t  var indent;\n\t  var meta;\n\t  var rep;\n\t\n\t\n\t  function quote(string) {\n\t\n\t    // If the string contains no control characters, no quote characters, and no\n\t    // backslash characters, then we can safely slap some quotes around it.\n\t    // Otherwise we must also replace the offending characters with safe escape\n\t    // sequences.\n\t\n\t    rx_escapable.lastIndex = 0;\n\t    return rx_escapable.test(string)\n\t      ? \"\\\"\" + string.replace(rx_escapable, function (a) {\n\t        var c = meta[a];\n\t        return typeof c === \"string\"\n\t          ? c\n\t          : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n\t      }) + \"\\\"\"\n\t    : \"\\\"\" + string + \"\\\"\";\n\t  }\n\t\n\t\n\t  function str(key, holder) {\n\t\n\t    // Produce a string from holder[key].\n\t\n\t    var i;          // The loop counter.\n\t    var k;          // The member key.\n\t    var v;          // The member value.\n\t    var length;\n\t    var mind = gap;\n\t    var partial;\n\t    var value = holder[key];\n\t\n\t    // If the value has a toJSON method, call it to obtain a replacement value.\n\t\n\t    if (value && typeof value === \"object\" &&\n\t        typeof value.toJSON === \"function\") {\n\t      value = value.toJSON(key);\n\t    }\n\t\n\t    // If we were called with a replacer function, then call the replacer to\n\t    // obtain a replacement value.\n\t\n\t    if (typeof rep === \"function\") {\n\t      value = rep.call(holder, key, value);\n\t    }\n\t\n\t    // What happens next depends on the value's type.\n\t\n\t    switch (typeof value) {\n\t      case \"string\":\n\t        return quote(value);\n\t\n\t      case \"number\":\n\t\n\t        // JSON numbers must be finite. Encode non-finite numbers as null.\n\t\n\t        return isFinite(value)\n\t          ? String(value)\n\t          : \"null\";\n\t\n\t      case \"boolean\":\n\t      case \"null\":\n\t\n\t        // If the value is a boolean or null, convert it to a string. Note:\n\t        // typeof null does not produce \"null\". The case is included here in\n\t        // the remote chance that this gets fixed someday.\n\t\n\t        return String(value);\n\t\n\t        // If the type is \"object\", we might be dealing with an object or an array or\n\t        // null.\n\t\n\t      case \"object\":\n\t\n\t        // Due to a specification blunder in ECMAScript, typeof null is \"object\",\n\t        // so watch out for that case.\n\t\n\t        if (!value) {\n\t          return \"null\";\n\t        }\n\t\n\t        // Make an array to hold the partial results of stringifying this object value.\n\t\n\t        gap += indent;\n\t        partial = [];\n\t\n\t        // Is the value an array?\n\t\n\t        if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n\t\n\t          // The value is an array. Stringify every element. Use null as a placeholder\n\t          // for non-JSON values.\n\t\n\t          length = value.length;\n\t          for (i = 0; i < length; i += 1) {\n\t            partial[i] = str(i, value) || \"null\";\n\t          }\n\t\n\t          // Join all of the elements together, separated with commas, and wrap them in\n\t          // brackets.\n\t\n\t          v = partial.length === 0\n\t            ? \"[]\"\n\t            : gap\n\t            ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\"\n\t            : \"[\" + partial.join(\",\") + \"]\";\n\t          gap = mind;\n\t          return v;\n\t        }\n\t\n\t        // If the replacer is an array, use it to select the members to be stringified.\n\t\n\t        if (rep && typeof rep === \"object\") {\n\t          length = rep.length;\n\t          for (i = 0; i < length; i += 1) {\n\t            if (typeof rep[i] === \"string\") {\n\t              k = rep[i];\n\t              v = str(k, value);\n\t              if (v) {\n\t                partial.push(quote(k) + (\n\t                      gap\n\t                      ? \": \"\n\t                      : \":\"\n\t                      ) + v);\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t\n\t          // Otherwise, iterate through all of the keys in the object.\n\t\n\t          for (k in value) {\n\t            if (Object.prototype.hasOwnProperty.call(value, k)) {\n\t              v = str(k, value);\n\t              if (v) {\n\t                partial.push(quote(k) + (\n\t                      gap\n\t                      ? \": \"\n\t                      : \":\"\n\t                      ) + v);\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        // Join all of the member texts together, separated with commas,\n\t        // and wrap them in braces.\n\t\n\t        v = partial.length === 0\n\t          ? \"{}\"\n\t          : gap\n\t          ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\"\n\t          : \"{\" + partial.join(\",\") + \"}\";\n\t        gap = mind;\n\t        return v;\n\t    }\n\t  }\n\t\n\t  // If the JSON object does not yet have a stringify method, give it one.\n\t\n\t  if (typeof JSON.stringify !== \"function\") {\n\t    meta = {    // table of character substitutions\n\t      \"\\b\": \"\\\\b\",\n\t      \"\\t\": \"\\\\t\",\n\t      \"\\n\": \"\\\\n\",\n\t      \"\\f\": \"\\\\f\",\n\t      \"\\r\": \"\\\\r\",\n\t      \"\\\"\": \"\\\\\\\"\",\n\t      \"\\\\\": \"\\\\\\\\\"\n\t    };\n\t    JSON.stringify = function (value, replacer, space) {\n\t\n\t      // The stringify method takes a value and an optional replacer, and an optional\n\t      // space parameter, and returns a JSON text. The replacer can be a function\n\t      // that can replace values, or an array of strings that will select the keys.\n\t      // A default replacer method can be provided. Use of the space parameter can\n\t      // produce text that is more easily readable.\n\t\n\t      var i;\n\t      gap = \"\";\n\t      indent = \"\";\n\t\n\t      // If the space parameter is a number, make an indent string containing that\n\t      // many spaces.\n\t\n\t      if (typeof space === \"number\") {\n\t        for (i = 0; i < space; i += 1) {\n\t          indent += \" \";\n\t        }\n\t\n\t        // If the space parameter is a string, it will be used as the indent string.\n\t\n\t      } else if (typeof space === \"string\") {\n\t        indent = space;\n\t      }\n\t\n\t      // If there is a replacer, it must be a function or an array.\n\t      // Otherwise, throw an error.\n\t\n\t      rep = replacer;\n\t      if (replacer && typeof replacer !== \"function\" &&\n\t          (typeof replacer !== \"object\" ||\n\t           typeof replacer.length !== \"number\")) {\n\t        throw new Error(\"JSON.stringify\");\n\t      }\n\t\n\t      // Make a fake root object containing our value under the key of \"\".\n\t      // Return the result of stringifying the value.\n\t\n\t      return str(\"\", {\"\": value});\n\t    };\n\t  }\n\t\n\t\n\t  // If the JSON object does not yet have a parse method, give it one.\n\t\n\t  if (typeof JSON.parse !== \"function\") {\n\t    JSON.parse = (function () {\n\t\n\t      // This function creates a JSON parse function that uses a state machine rather\n\t      // than the dangerous eval function to parse a JSON text.\n\t\n\t      var state;      // The state of the parser, one of\n\t      // 'go'         The starting state\n\t      // 'ok'         The final, accepting state\n\t      // 'firstokey'  Ready for the first key of the object or\n\t      //              the closing of an empty object\n\t      // 'okey'       Ready for the next key of the object\n\t      // 'colon'      Ready for the colon\n\t      // 'ovalue'     Ready for the value half of a key/value pair\n\t      // 'ocomma'     Ready for a comma or closing }\n\t      // 'firstavalue' Ready for the first value of an array or\n\t      //              an empty array\n\t      // 'avalue'     Ready for the next value of an array\n\t      // 'acomma'     Ready for a comma or closing ]\n\t      var stack;      // The stack, for controlling nesting.\n\t      var container;  // The current container object or array\n\t      var key;        // The current key\n\t      var value;      // The current value\n\t      var escapes = { // Escapement translation table\n\t        \"\\\\\": \"\\\\\",\n\t        \"\\\"\": \"\\\"\",\n\t        \"/\": \"/\",\n\t        \"t\": \"\\t\",\n\t        \"n\": \"\\n\",\n\t        \"r\": \"\\r\",\n\t        \"f\": \"\\f\",\n\t        \"b\": \"\\b\"\n\t      };\n\t      var string = {   // The actions for string tokens\n\t        go: function () {\n\t          state = \"ok\";\n\t        },\n\t        firstokey: function () {\n\t          key = value;\n\t          state = \"colon\";\n\t        },\n\t        okey: function () {\n\t          key = value;\n\t          state = \"colon\";\n\t        },\n\t        ovalue: function () {\n\t          state = \"ocomma\";\n\t        },\n\t        firstavalue: function () {\n\t          state = \"acomma\";\n\t        },\n\t        avalue: function () {\n\t          state = \"acomma\";\n\t        }\n\t      };\n\t      var number = {   // The actions for number tokens\n\t        go: function () {\n\t          state = \"ok\";\n\t        },\n\t        ovalue: function () {\n\t          state = \"ocomma\";\n\t        },\n\t        firstavalue: function () {\n\t          state = \"acomma\";\n\t        },\n\t        avalue: function () {\n\t          state = \"acomma\";\n\t        }\n\t      };\n\t      var action = {\n\t\n\t        // The action table describes the behavior of the machine. It contains an\n\t        // object for each token. Each object contains a method that is called when\n\t        // a token is matched in a state. An object will lack a method for illegal\n\t        // states.\n\t\n\t        \"{\": {\n\t          go: function () {\n\t            stack.push({state: \"ok\"});\n\t            container = {};\n\t            state = \"firstokey\";\n\t          },\n\t          ovalue: function () {\n\t            stack.push({container: container, state: \"ocomma\", key: key});\n\t            container = {};\n\t            state = \"firstokey\";\n\t          },\n\t          firstavalue: function () {\n\t            stack.push({container: container, state: \"acomma\"});\n\t            container = {};\n\t            state = \"firstokey\";\n\t          },\n\t          avalue: function () {\n\t            stack.push({container: container, state: \"acomma\"});\n\t            container = {};\n\t            state = \"firstokey\";\n\t          }\n\t        },\n\t        \"}\": {\n\t          firstokey: function () {\n\t            var pop = stack.pop();\n\t            value = container;\n\t            container = pop.container;\n\t            key = pop.key;\n\t            state = pop.state;\n\t          },\n\t          ocomma: function () {\n\t            var pop = stack.pop();\n\t            container[key] = value;\n\t            value = container;\n\t            container = pop.container;\n\t            key = pop.key;\n\t            state = pop.state;\n\t          }\n\t        },\n\t        \"[\": {\n\t          go: function () {\n\t            stack.push({state: \"ok\"});\n\t            container = [];\n\t            state = \"firstavalue\";\n\t          },\n\t          ovalue: function () {\n\t            stack.push({container: container, state: \"ocomma\", key: key});\n\t            container = [];\n\t            state = \"firstavalue\";\n\t          },\n\t          firstavalue: function () {\n\t            stack.push({container: container, state: \"acomma\"});\n\t            container = [];\n\t            state = \"firstavalue\";\n\t          },\n\t          avalue: function () {\n\t            stack.push({container: container, state: \"acomma\"});\n\t            container = [];\n\t            state = \"firstavalue\";\n\t          }\n\t        },\n\t        \"]\": {\n\t          firstavalue: function () {\n\t            var pop = stack.pop();\n\t            value = container;\n\t            container = pop.container;\n\t            key = pop.key;\n\t            state = pop.state;\n\t          },\n\t          acomma: function () {\n\t            var pop = stack.pop();\n\t            container.push(value);\n\t            value = container;\n\t            container = pop.container;\n\t            key = pop.key;\n\t            state = pop.state;\n\t          }\n\t        },\n\t        \":\": {\n\t          colon: function () {\n\t            if (Object.hasOwnProperty.call(container, key)) {\n\t              throw new SyntaxError(\"Duplicate key '\" + key + \"\\\"\");\n\t            }\n\t            state = \"ovalue\";\n\t          }\n\t        },\n\t        \",\": {\n\t          ocomma: function () {\n\t            container[key] = value;\n\t            state = \"okey\";\n\t          },\n\t          acomma: function () {\n\t            container.push(value);\n\t            state = \"avalue\";\n\t          }\n\t        },\n\t        \"true\": {\n\t          go: function () {\n\t            value = true;\n\t            state = \"ok\";\n\t          },\n\t          ovalue: function () {\n\t            value = true;\n\t            state = \"ocomma\";\n\t          },\n\t          firstavalue: function () {\n\t            value = true;\n\t            state = \"acomma\";\n\t          },\n\t          avalue: function () {\n\t            value = true;\n\t            state = \"acomma\";\n\t          }\n\t        },\n\t        \"false\": {\n\t          go: function () {\n\t            value = false;\n\t            state = \"ok\";\n\t          },\n\t          ovalue: function () {\n\t            value = false;\n\t            state = \"ocomma\";\n\t          },\n\t          firstavalue: function () {\n\t            value = false;\n\t            state = \"acomma\";\n\t          },\n\t          avalue: function () {\n\t            value = false;\n\t            state = \"acomma\";\n\t          }\n\t        },\n\t        \"null\": {\n\t          go: function () {\n\t            value = null;\n\t            state = \"ok\";\n\t          },\n\t          ovalue: function () {\n\t            value = null;\n\t            state = \"ocomma\";\n\t          },\n\t          firstavalue: function () {\n\t            value = null;\n\t            state = \"acomma\";\n\t          },\n\t          avalue: function () {\n\t            value = null;\n\t            state = \"acomma\";\n\t          }\n\t        }\n\t      };\n\t\n\t      function debackslashify(text) {\n\t\n\t        // Remove and replace any backslash escapement.\n\t\n\t        return text.replace(/\\\\(?:u(.{4})|([^u]))/g, function (ignore, b, c) {\n\t          return b\n\t            ? String.fromCharCode(parseInt(b, 16))\n\t            : escapes[c];\n\t        });\n\t      }\n\t\n\t      return function (source, reviver) {\n\t\n\t        // A regular expression is used to extract tokens from the JSON text.\n\t        // The extraction process is cautious.\n\t\n\t        var result;\n\t        var tx = /^[\\u0020\\t\\n\\r]*(?:([,:\\[\\]{}]|true|false|null)|(-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)|\"((?:[^\\r\\n\\t\\\\\\\"]|\\\\(?:[\"\\\\\\/trnfb]|u[0-9a-fA-F]{4}))*)\")/;\n\t\n\t        // Set the starting state.\n\t\n\t        state = \"go\";\n\t\n\t        // The stack records the container, key, and state for each object or array\n\t        // that contains another object or array while processing nested structures.\n\t\n\t        stack = [];\n\t\n\t        // If any error occurs, we will catch it and ultimately throw a syntax error.\n\t\n\t        try {\n\t\n\t          // For each token...\n\t\n\t          while (true) {\n\t            result = tx.exec(source);\n\t            if (!result) {\n\t              break;\n\t            }\n\t\n\t            // result is the result array from matching the tokenizing regular expression.\n\t            //  result[0] contains everything that matched, including any initial whitespace.\n\t            //  result[1] contains any punctuation that was matched, or true, false, or null.\n\t            //  result[2] contains a matched number, still in string form.\n\t            //  result[3] contains a matched string, without quotes but with escapement.\n\t\n\t            if (result[1]) {\n\t\n\t              // Token: Execute the action for this state and token.\n\t\n\t              action[result[1]][state]();\n\t\n\t            } else if (result[2]) {\n\t\n\t              // Number token: Convert the number string into a number value and execute\n\t              // the action for this state and number.\n\t\n\t              value = +result[2];\n\t              number[state]();\n\t            } else {\n\t\n\t              // String token: Replace the escapement sequences and execute the action for\n\t              // this state and string.\n\t\n\t              value = debackslashify(result[3]);\n\t              string[state]();\n\t            }\n\t\n\t            // Remove the token from the string. The loop will continue as long as there\n\t            // are tokens. This is a slow process, but it allows the use of ^ matching,\n\t            // which assures that no illegal tokens slip through.\n\t\n\t            source = source.slice(result[0].length);\n\t          }\n\t\n\t          // If we find a state/token combination that is illegal, then the action will\n\t          // cause an error. We handle the error by simply changing the state.\n\t\n\t        } catch (e) {\n\t          state = e;\n\t        }\n\t\n\t        // The parsing is finished. If we are not in the final \"ok\" state, or if the\n\t        // remaining source contains anything except whitespace, then we did not have\n\t        //a well-formed JSON text.\n\t\n\t        if (state !== \"ok\" || (/[^\\u0020\\t\\n\\r]/.test(source))) {\n\t          throw (state instanceof SyntaxError)\n\t            ? state\n\t            : new SyntaxError(\"JSON\");\n\t        }\n\t\n\t        // If there is a reviver function, we recursively walk the new structure,\n\t        // passing each name/value pair to the reviver function for possible\n\t        // transformation, starting with a temporary root object that holds the current\n\t        // value in an empty key. If there is not a reviver function, we simply return\n\t        // that value.\n\t\n\t        return (typeof reviver === \"function\")\n\t          ? (function walk(holder, key) {\n\t            var k;\n\t            var v;\n\t            var val = holder[key];\n\t            if (val && typeof val === \"object\") {\n\t              for (k in value) {\n\t                if (Object.prototype.hasOwnProperty.call(val, k)) {\n\t                  v = walk(val, k);\n\t                  if (v !== undefined) {\n\t                    val[k] = v;\n\t                  } else {\n\t                    delete val[k];\n\t                  }\n\t                }\n\t              }\n\t            }\n\t            return reviver.call(holder, key, val);\n\t          }({\"\": value}, \"\"))\n\t        : value;\n\t      };\n\t    }());\n\t  }\n\t}\n\t\n\tmodule.exports = setupCustomJSON;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\t\n\t/*\n\t * Notifier - the internal object responsible for delegating between the client exposed API, the\n\t * chain of transforms necessary to turn an item into something that can be sent to Rollbar, and the\n\t * queue which handles the communcation with the Rollbar API servers.\n\t *\n\t * @param queue - an object that conforms to the interface: addItem(item, callback)\n\t * @param options - an object representing the options to be set for this notifier, this should have\n\t * any defaults already set by the caller\n\t */\n\tfunction Notifier(queue, options) {\n\t  this.queue = queue;\n\t  this.options = options;\n\t  this.transforms = [];\n\t}\n\t\n\t/*\n\t * configure - updates the options for this notifier with the passed in object\n\t *\n\t * @param options - an object which gets merged with the current options set on this notifier\n\t * @returns this\n\t */\n\tNotifier.prototype.configure = function(options) {\n\t  this.queue && this.queue.configure(options);\n\t  var oldOptions = this.options;\n\t  this.options = _.extend(true, {}, oldOptions, options);\n\t  return this;\n\t};\n\t\n\t/*\n\t * addTransform - adds a transform onto the end of the queue of transforms for this notifier\n\t *\n\t * @param transform - a function which takes three arguments:\n\t *    * item: An Object representing the data to eventually be sent to Rollbar\n\t *    * options: The current value of the options for this notifier\n\t *    * callback: function(err: (Null|Error), item: (Null|Object)) the transform must call this\n\t *    callback with a null value for error if it wants the processing chain to continue, otherwise\n\t *    with an error to terminate the processing. The item should be the updated item after this\n\t *    transform is finished modifying it.\n\t */\n\tNotifier.prototype.addTransform = function(transform) {\n\t  if (_.isFunction(transform)) {\n\t    this.transforms.push(transform);\n\t  }\n\t  return this;\n\t};\n\t\n\t/*\n\t * log - the internal log function which applies the configured transforms and then pushes onto the\n\t * queue to be sent to the backend.\n\t *\n\t * @param item - An object with the following structure:\n\t *    message [String] - An optional string to be sent to rollbar\n\t *    error [Error] - An optional error\n\t *\n\t * @param callback - A function of type function(err, resp) which will be called with exactly one\n\t * null argument and one non-null argument. The callback will be called once, either during the\n\t * transform stage if an error occurs inside a transform, or in response to the communication with\n\t * the backend. The second argument will be the response from the backend in case of success.\n\t */\n\tNotifier.prototype.log = function(item, callback) {\n\t  if (!callback || !_.isFunction(callback)) {\n\t    callback = function() {};\n\t  }\n\t\n\t  if (!this.options.enabled) {\n\t    return callback(new Error('Rollbar is not enabled'));\n\t  }\n\t\n\t  this._applyTransforms(item, function(err, i) {\n\t    if (err) {\n\t      return callback(err, null);\n\t    }\n\t    this.queue.addItem(i, callback);\n\t  }.bind(this));\n\t};\n\t\n\t/* Internal */\n\t\n\t/*\n\t * _applyTransforms - Applies the transforms that have been added to this notifier sequentially. See\n\t * `addTransform` for more information.\n\t *\n\t * @param item - An item to be transformed\n\t * @param callback - A function of type function(err, item) which will be called with a non-null\n\t * error and a null item in the case of a transform failure, or a null error and non-null item after\n\t * all transforms have been applied.\n\t */\n\tNotifier.prototype._applyTransforms = function(item, callback) {\n\t  var transformIndex = -1;\n\t  var transformsLength = this.transforms.length;\n\t  var transforms = this.transforms;\n\t  var options = this.options;\n\t\n\t  var cb = function(err, i) {\n\t    if (err) {\n\t      callback(err, null);\n\t      return;\n\t    }\n\t\n\t    transformIndex++;\n\t\n\t    if (transformIndex === transformsLength) {\n\t      callback(null, i);\n\t      return;\n\t    }\n\t\n\t    transforms[transformIndex](i, options, cb);\n\t  };\n\t  \n\t  cb(null, item);\n\t};\n\t\n\tmodule.exports = Notifier;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\tvar helpers = __webpack_require__(11);\n\t\n\tvar defaultOptions = {\n\t  hostname: 'api.rollbar.com',\n\t  path: '/api/1',\n\t  search: null,\n\t  version: '1',\n\t  protocol: 'https:',\n\t  port: 443\n\t};\n\t\n\t/**\n\t * Api is an object that encapsulates methods of communicating with\n\t * the Rollbar API.  It is a standard interface with some parts implemented\n\t * differently for server or browser contexts.  It is an object that should\n\t * be instantiated when used so it can contain non-global options that may\n\t * be different for another instance of RollbarApi.\n\t *\n\t * @param options {\n\t *    accessToken: the accessToken to use for posting items to rollbar\n\t *    endpoint: an alternative endpoint to send errors to\n\t *        must be a valid, fully qualified URL.\n\t *        The default is: https://api.rollbar.com/api/1\n\t *    proxy: if you wish to proxy requests provide an object\n\t *        with the following keys:\n\t *          host or hostname (required): foo.example.com\n\t *          port (optional): 123\n\t *          protocol (optional): https\n\t * }\n\t */\n\tfunction Api(options, t, u, j) {\n\t  this.options = options;\n\t  this.transport = t;\n\t  this.url = u;\n\t  this.jsonBackup = j;\n\t  this.accessToken = options.accessToken;\n\t  this.transportOptions = _getTransport(options, u);\n\t}\n\t\n\t/**\n\t *\n\t * @param data\n\t * @param callback\n\t */\n\tApi.prototype.postItem = function(data, callback) {\n\t  var transportOptions = helpers.transportOptions(this.transportOptions, '/item/', 'POST');\n\t  var payload = helpers.buildPayload(this.accessToken, data, this.jsonBackup);\n\t  this.transport.post(this.accessToken, transportOptions, payload, callback);\n\t};\n\t\n\tApi.prototype.configure = function(options) {\n\t  var oldOptions = this.oldOptions;\n\t  this.options = _.extend(true, {}, oldOptions, options);\n\t  this.transportOptions = _getTransport(this.options, this.url);\n\t  if (this.options.accessToken !== undefined) {\n\t    this.accessToken = this.options.accessToken;\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction _getTransport(options, url) {\n\t  return helpers.getTransportFromOptions(options, defaultOptions, url);\n\t}\n\t\n\tmodule.exports = Api;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\t\n\tfunction buildPayload(accessToken, data, jsonBackup) {\n\t  if (_.isType(data.context, 'object')) {\n\t    var contextResult = _.stringify(data.context, jsonBackup);\n\t    if (contextResult.error) {\n\t      data.context = 'Error: could not serialize \\'context\\'';\n\t    } else {\n\t      data.context = contextResult.value || '';\n\t    }\n\t    if (data.context.length > 255) {\n\t      data.context = data.context.substr(0, 255);\n\t    }\n\t  }\n\t  return {\n\t    access_token: accessToken,\n\t    data: data\n\t  };\n\t}\n\t\n\tfunction getTransportFromOptions(options, defaults, url) {\n\t  var hostname = defaults.hostname;\n\t  var protocol = defaults.protocol;\n\t  var port = defaults.port;\n\t  var path = defaults.path;\n\t  var search = defaults.search;\n\t\n\t  var proxy = options.proxy;\n\t  if (options.endpoint) {\n\t    var opts = url.parse(options.endpoint);\n\t    hostname = opts.hostname;\n\t    protocol = opts.protocol;\n\t    port = opts.port;\n\t    path = opts.pathname;\n\t    search = opts.search;\n\t  }\n\t  return {\n\t    hostname: hostname,\n\t    protocol: protocol,\n\t    port: port,\n\t    path: path,\n\t    search: search,\n\t    proxy: proxy\n\t  };\n\t}\n\t\n\tfunction transportOptions(transport, path, method) {\n\t  var protocol = transport.protocol || 'https:';\n\t  var port = transport.port || (protocol === 'http:' ? 80 : protocol === 'https:' ? 443 : undefined);\n\t  var hostname = transport.hostname;\n\t  path = appendPathToPath(transport.path, path);\n\t  if (transport.search) {\n\t    path = path + transport.search;\n\t  }\n\t  if (transport.proxy) {\n\t    path = protocol + '//' + hostname + path;\n\t    hostname = transport.proxy.host || transport.proxy.hostname;\n\t    port = transport.proxy.port;\n\t    protocol = transport.proxy.protocol || protocol;\n\t  }\n\t  return {\n\t    protocol: protocol,\n\t    hostname: hostname,\n\t    path: path,\n\t    port: port,\n\t    method: method\n\t  };\n\t}\n\t\n\tfunction appendPathToPath(base, path) {\n\t  var baseTrailingSlash = /\\/$/.test(base);\n\t  var pathBeginningSlash = /^\\//.test(path);\n\t\n\t  if (baseTrailingSlash && pathBeginningSlash) {\n\t    path = path.substring(1);\n\t  } else if (!baseTrailingSlash && !pathBeginningSlash) {\n\t    path = '/' + path;\n\t  }\n\t\n\t  return base + path;\n\t}\n\t\n\tmodule.exports = {\n\t  buildPayload: buildPayload,\n\t  getTransportFromOptions: getTransportFromOptions,\n\t  transportOptions: transportOptions,\n\t  appendPathToPath: appendPathToPath\n\t};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* eslint-disable no-console */\n\t\n\t__webpack_require__(13);\n\tvar detection = __webpack_require__(14);\n\tvar _ = __webpack_require__(6);\n\t\n\tfunction error() {\n\t  var args = Array.prototype.slice.call(arguments, 0);\n\t  args.unshift('Rollbar:');\n\t  if (detection.ieVersion() <= 8) {\n\t    console.error(formatArgsAsString.apply(null, args));\n\t  } else {\n\t    console.error.apply(console, args);\n\t  }\n\t}\n\t\n\tfunction info() {\n\t  var args = Array.prototype.slice.call(arguments, 0);\n\t  args.unshift('Rollbar:');\n\t  if (detection.ieVersion() <= 8) {\n\t    console.info(formatArgsAsString.apply(null, args));\n\t  } else {\n\t    console.info.apply(console, args);\n\t  }\n\t}\n\t\n\tfunction log() {\n\t  var args = Array.prototype.slice.call(arguments, 0);\n\t  args.unshift('Rollbar:');\n\t  if (detection.ieVersion() <= 8) {\n\t    console.log(formatArgsAsString.apply(null, args));\n\t  } else {\n\t    console.log.apply(console, args);\n\t  }\n\t}\n\t\n\t// IE8 logs objects as [object Object].  This is a wrapper that makes it a bit\n\t// more convenient by logging the JSON of the object.  But only do that in IE8 and below\n\t// because other browsers are smarter and handle it properly.\n\tfunction formatArgsAsString() {\n\t  var args = [];\n\t  for (var i=0; i < arguments.length; i++) {\n\t    var arg = arguments[i];\n\t    if (typeof arg === 'object') {\n\t      arg = _.stringify(arg);\n\t      arg = arg.error || arg.value;\n\t      if (arg.length > 500)\n\t        arg = arg.substr(0,500)+'...';\n\t    } else if (typeof arg === 'undefined') {\n\t      arg = 'undefined';\n\t    }\n\t    args.push(arg);\n\t  }\n\t  return args.join(' ');\n\t}\n\t\n\t/* eslint-enable no-console */\n\t\n\tmodule.exports = {\n\t  error: error,\n\t  info: info,\n\t  log: log\n\t};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t// Console-polyfill. MIT license.\n\t// https://github.com/paulmillr/console-polyfill\n\t// Make it safe to do console.log() always.\n\t(function(global) {\n\t  'use strict';\n\t  if (!global.console) {\n\t    global.console = {};\n\t  }\n\t  var con = global.console;\n\t  var prop, method;\n\t  var dummy = function() {};\n\t  var properties = ['memory'];\n\t  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +\n\t     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +\n\t     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');\n\t  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};\n\t  while (method = methods.pop()) if (!con[method]) con[method] = dummy;\n\t  // Using `this` for web workers & supports Browserify / Webpack.\n\t})(typeof window === 'undefined' ? this : window);\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t// This detection.js module is used to encapsulate any ugly browser/feature\n\t// detection we may need to do.\n\t\n\t// Figure out which version of IE we're using, if any.\n\t// This is gleaned from http://stackoverflow.com/questions/5574842/best-way-to-check-for-ie-less-than-9-in-javascript-without-library\n\t// Will return an integer on IE (i.e. 8)\n\t// Will return undefined otherwise\n\tfunction getIEVersion() {\n\t\tvar undef;\n\t\tif (!document) {\n\t\t\treturn undef;\n\t\t}\n\t\n\t  var v = 3,\n\t    div = document.createElement('div'),\n\t    all = div.getElementsByTagName('i');\n\t\n\t  while (\n\t    div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',\n\t      all[0]\n\t    );\n\t\n\t  return v > 4 ? v : undef;\n\t}\n\t\n\tvar Detection = {\n\t  ieVersion: getIEVersion\n\t};\n\t\n\tmodule.exports = Detection;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction captureUncaughtExceptions(window, handler, shim) {\n\t  if (!window) { return; }\n\t  var oldOnError;\n\t\n\t  if (typeof handler._rollbarOldOnError === 'function') {\n\t    oldOnError = handler._rollbarOldOnError;\n\t  } else if (window.onerror && !window.onerror.belongsToShim) {\n\t    oldOnError = window.onerror;\n\t    handler._rollbarOldOnError = oldOnError;\n\t  }\n\t\n\t  var fn = function() {\n\t    var args = Array.prototype.slice.call(arguments, 0);\n\t    _rollbarWindowOnError(window, handler, oldOnError, args);\n\t  };\n\t  fn.belongsToShim = shim;\n\t  window.onerror = fn;\n\t}\n\t\n\tfunction _rollbarWindowOnError(window, r, old, args) {\n\t  if (window._rollbarWrappedError) {\n\t    if (!args[4]) {\n\t      args[4] = window._rollbarWrappedError;\n\t    }\n\t    if (!args[5]) {\n\t      args[5] = window._rollbarWrappedError._rollbarContext;\n\t    }\n\t    window._rollbarWrappedError = null;\n\t  }\n\t\n\t  r.handleUncaughtException.apply(r, args);\n\t  if (old) {\n\t    old.apply(window, args);\n\t  }\n\t}\n\t\n\tfunction captureUnhandledRejections(window, handler, shim) {\n\t  if (!window) { return; }\n\t\n\t  if (typeof window._rollbarURH === 'function' && window._rollbarURH.belongsToShim) {\n\t    window.removeEventListener('unhandledrejection', window._rollbarURH);\n\t  }\n\t\n\t  var rejectionHandler = function (event) {\n\t    var reason = event.reason;\n\t    var promise = event.promise;\n\t    var detail = event.detail;\n\t\n\t    if (!reason && detail) {\n\t      reason = detail.reason;\n\t      promise = detail.promise;\n\t    }\n\t\n\t    if (handler && handler.handleUnhandledRejection) {\n\t      handler.handleUnhandledRejection(reason, promise);\n\t    }\n\t  };\n\t  rejectionHandler.belongsToShim = shim;\n\t  window._rollbarURH = rejectionHandler;\n\t  window.addEventListener('unhandledrejection', rejectionHandler);\n\t}\n\t\n\tfunction wrapGlobals(window, handler, shim) {\n\t  if (!window) { return; }\n\t  // Adapted from https://github.com/bugsnag/bugsnag-js\n\t  var globals = 'EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload'.split(',');\n\t  var i, global;\n\t  for (i = 0; i < globals.length; ++i) {\n\t    global = globals[i];\n\t\n\t    if (window[global] && window[global].prototype) {\n\t      _extendListenerPrototype(handler, window[global].prototype, shim);\n\t    }\n\t  }\n\t}\n\t\n\tfunction _extendListenerPrototype(handler, prototype, shim) {\n\t  if (prototype.hasOwnProperty && prototype.hasOwnProperty('addEventListener')) {\n\t    var oldAddEventListener = prototype.addEventListener;\n\t    while (oldAddEventListener._rollbarOldAdd && oldAddEventListener.belongsToShim) {\n\t      oldAddEventListener = oldAddEventListener._rollbarOldAdd;\n\t    }\n\t    var addFn = function(event, callback, bubble) {\n\t      oldAddEventListener.call(this, event, handler.wrap(callback), bubble);\n\t    };\n\t    addFn._rollbarOldAdd = oldAddEventListener;\n\t    addFn.belongsToShim = shim;\n\t    prototype.addEventListener = addFn;\n\t\n\t    var oldRemoveEventListener = prototype.removeEventListener;\n\t    while (oldRemoveEventListener._rollbarOldRemove && oldRemoveEventListener.belongsToShim) {\n\t      oldRemoveEventListener = oldRemoveEventListener._rollbarOldRemove;\n\t    }\n\t    var removeFn = function(event, callback, bubble) {\n\t      oldRemoveEventListener.call(this, event, callback && callback._wrapped || callback, bubble);\n\t    };\n\t    removeFn._rollbarOldRemove = oldRemoveEventListener;\n\t    removeFn.belongsToShim = shim;\n\t    prototype.removeEventListener = removeFn;\n\t  }\n\t}\n\t\n\tmodule.exports = {\n\t  captureUncaughtExceptions: captureUncaughtExceptions,\n\t  captureUnhandledRejections: captureUnhandledRejections,\n\t  wrapGlobals: wrapGlobals\n\t};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\tvar logger = __webpack_require__(12);\n\t\n\t/*\n\t * accessToken may be embedded in payload but that should not\n\t *   be assumed\n\t *\n\t * options: {\n\t *   hostname\n\t *   protocol\n\t *   path\n\t *   port\n\t *   method\n\t * }\n\t *\n\t *  params is an object containing key/value pairs. These\n\t *    will be appended to the path as 'key=value&key=value'\n\t *\n\t * payload is an unserialized object\n\t */\n\t\n\tfunction get(accessToken, options, params, callback, requestFactory) {\n\t  if (!callback || !_.isFunction(callback)) {\n\t    callback = function() {};\n\t  }\n\t  _.addParamsAndAccessTokenToPath(accessToken, options, params);\n\t\n\t  var method = 'GET';\n\t  var url = _.formatUrl(options);\n\t  _makeRequest(accessToken, url, method, null, callback, requestFactory);\n\t}\n\t\n\tfunction post(accessToken, options, payload, callback, requestFactory) {\n\t  if (!callback || !_.isFunction(callback)) {\n\t    callback = function() {};\n\t  }\n\t\n\t  if (!payload) {\n\t    return callback(new Error('Cannot send empty request'));\n\t  }\n\t\n\t  var stringifyResult = _.stringify(payload);\n\t  if (stringifyResult.error) {\n\t    return callback(stringifyResult.error);\n\t  }\n\t\n\t  var writeData = stringifyResult.value;\n\t  var method = 'POST';\n\t  var url = _.formatUrl(options);\n\t  _makeRequest(accessToken, url, method, writeData, callback, requestFactory);\n\t}\n\t\n\tfunction _makeRequest(accessToken, url, method, data, callback, requestFactory) {\n\t  var request;\n\t  if (requestFactory) {\n\t    request = requestFactory();\n\t  } else {\n\t    request = _createXMLHTTPObject();\n\t  }\n\t  if (!request) {\n\t    // Give up, no way to send requests\n\t    return callback(new Error('No way to send a request'));\n\t  }\n\t  try {\n\t    try {\n\t      var onreadystatechange = function() {\n\t        try {\n\t          if (onreadystatechange && request.readyState === 4) {\n\t            onreadystatechange = undefined;\n\t\n\t            var parseResponse = _.jsonParse(request.responseText);\n\t            if (_isSuccess(request)) {\n\t              callback(parseResponse.error, parseResponse.value);\n\t              return;\n\t            } else if (_isNormalFailure(request)) {\n\t              if (request.status === 403) {\n\t                // likely caused by using a server access token\n\t                var message = parseResponse.value && parseResponse.value.message;\n\t                logger.error(message);\n\t              }\n\t              // return valid http status codes\n\t              callback(new Error(String(request.status)));\n\t            } else {\n\t              // IE will return a status 12000+ on some sort of connection failure,\n\t              // so we return a blank error\n\t              // http://msdn.microsoft.com/en-us/library/aa383770%28VS.85%29.aspx\n\t              var msg = 'XHR response had no status code (likely connection failure)';\n\t              callback(_newRetriableError(msg));\n\t            }\n\t          }\n\t        } catch (ex) {\n\t          //jquery source mentions firefox may error out while accessing the\n\t          //request members if there is a network error\n\t          //https://github.com/jquery/jquery/blob/a938d7b1282fc0e5c52502c225ae8f0cef219f0a/src/ajax/xhr.js#L111\n\t          var exc;\n\t          if (ex && ex.stack) {\n\t            exc = ex;\n\t          } else {\n\t            exc = new Error(ex);\n\t          }\n\t          callback(exc);\n\t        }\n\t      };\n\t\n\t      request.open(method, url, true);\n\t      if (request.setRequestHeader) {\n\t        request.setRequestHeader('Content-Type', 'application/json');\n\t        request.setRequestHeader('X-Rollbar-Access-Token', accessToken);\n\t      }\n\t      request.onreadystatechange = onreadystatechange;\n\t      request.send(data);\n\t    } catch (e1) {\n\t      // Sending using the normal xmlhttprequest object didn't work, try XDomainRequest\n\t      if (typeof XDomainRequest !== 'undefined') {\n\t\n\t        // Assume we are in a really old browser which has a bunch of limitations:\n\t        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n\t\n\t        // Extreme paranoia: if we have XDomainRequest then we have a window, but just in case\n\t        if (!window || !window.location) {\n\t          return callback(new Error('No window available during request, unknown environment'));\n\t        }\n\t\n\t        // If the current page is http, try and send over http\n\t        if (window.location.href.substring(0, 5) === 'http:' && url.substring(0, 5) === 'https') {\n\t          url = 'http' + url.substring(5);\n\t        }\n\t\n\t        var xdomainrequest = new XDomainRequest();\n\t        xdomainrequest.onprogress = function() {};\n\t        xdomainrequest.ontimeout = function() {\n\t          var msg = 'Request timed out';\n\t          var code = 'ETIMEDOUT';\n\t          callback(_newRetriableError(msg, code));\n\t        };\n\t        xdomainrequest.onerror = function() {\n\t          callback(new Error('Error during request'));\n\t        };\n\t        xdomainrequest.onload = function() {\n\t          var parseResponse = _.jsonParse(xdomainrequest.responseText);\n\t          callback(parseResponse.error, parseResponse.value);\n\t        };\n\t        xdomainrequest.open(method, url, true);\n\t        xdomainrequest.send(data);\n\t      } else {\n\t        callback(new Error('Cannot find a method to transport a request'));\n\t      }\n\t    }\n\t  } catch (e2) {\n\t    callback(e2);\n\t  }\n\t}\n\t\n\tfunction _createXMLHTTPObject() {\n\t  /* global ActiveXObject:false */\n\t\n\t  var factories = [\n\t    function () {\n\t      return new XMLHttpRequest();\n\t    },\n\t    function () {\n\t      return new ActiveXObject('Msxml2.XMLHTTP');\n\t    },\n\t    function () {\n\t      return new ActiveXObject('Msxml3.XMLHTTP');\n\t    },\n\t    function () {\n\t      return new ActiveXObject('Microsoft.XMLHTTP');\n\t    }\n\t  ];\n\t  var xmlhttp;\n\t  var i;\n\t  var numFactories = factories.length;\n\t  for (i = 0; i < numFactories; i++) {\n\t    /* eslint-disable no-empty */\n\t    try {\n\t      xmlhttp = factories[i]();\n\t      break;\n\t    } catch (e) {\n\t      // pass\n\t    }\n\t    /* eslint-enable no-empty */\n\t  }\n\t  return xmlhttp;\n\t}\n\t\n\tfunction _isSuccess(r) {\n\t  return r && r.status && r.status === 200;\n\t}\n\t\n\tfunction _isNormalFailure(r) {\n\t  return r && _.isType(r.status, 'number') && r.status >= 400 && r.status < 600;\n\t}\n\t\n\tfunction _newRetriableError(message, code) {\n\t  var err = new Error(message);\n\t  err.code = code || 'ENOTFOUND';\n\t  return err;\n\t}\n\t\n\tmodule.exports = {\n\t  get: get,\n\t  post: post\n\t};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t// See https://nodejs.org/docs/latest/api/url.html\n\tfunction parse(url) {\n\t  var result = {\n\t    protocol: null, auth: null, host: null, path: null,\n\t    hash: null, href: url, hostname: null, port: null,\n\t    pathname: null, search: null, query: null\n\t  };\n\t\n\t  var i, last;\n\t  i = url.indexOf('//');\n\t  if (i !== -1) {\n\t    result.protocol = url.substring(0,i);\n\t    last = i+2;\n\t  } else {\n\t    last = 0;\n\t  }\n\t  \n\t  i = url.indexOf('@', last);\n\t  if (i !== -1) {\n\t    result.auth = url.substring(last, i);\n\t    last = i+1;\n\t  }\n\t\n\t  i = url.indexOf('/', last);\n\t  if (i === -1) {\n\t    i = url.indexOf('?', last);\n\t    if (i === -1) {\n\t      i = url.indexOf('#', last);\n\t      if (i === -1) {\n\t        result.host = url.substring(last);\n\t      } else {\n\t        result.host = url.substring(last, i);\n\t        result.hash = url.substring(i);\n\t      }\n\t      result.hostname = result.host.split(':')[0];\n\t      result.port = result.host.split(':')[1];\n\t      if (result.port) {\n\t        result.port = parseInt(result.port, 10);\n\t      }\n\t      return result;\n\t    } else {\n\t      result.host = url.substring(last, i);\n\t      result.hostname = result.host.split(':')[0];\n\t      result.port = result.host.split(':')[1];\n\t      if (result.port) {\n\t        result.port = parseInt(result.port, 10);\n\t      }\n\t      last = i;\n\t    }\n\t  } else {\n\t    result.host = url.substring(last, i);\n\t    result.hostname = result.host.split(':')[0];\n\t    result.port = result.host.split(':')[1];\n\t    if (result.port) {\n\t      result.port = parseInt(result.port, 10);\n\t    }\n\t    last = i;\n\t  }\n\t\n\t  i = url.indexOf('#', last);\n\t  if (i === -1) {\n\t    result.path = url.substring(last);\n\t  } else {\n\t    result.path = url.substring(last, i);\n\t    result.hash = url.substring(i);\n\t  }\n\t\n\t  if (result.path) {\n\t    var pathParts = result.path.split('?');\n\t    result.pathname = pathParts[0];\n\t    result.query = pathParts[1];\n\t    result.search = result.query ? '?' + result.query : null;\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = {\n\t  parse: parse\n\t};\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\tvar errorParser = __webpack_require__(19);\n\tvar logger = __webpack_require__(12);\n\t\n\tfunction handleItemWithError(item, options, callback) {\n\t  item.data = item.data || {};\n\t  if (item.err) {\n\t    try {\n\t      item.stackInfo = item.err._savedStackTrace || errorParser.parse(item.err);\n\t    } catch (e)\n\t    /* istanbul ignore next */\n\t    {\n\t      logger.error('Error while parsing the error object.', e);\n\t      item.message = item.err.message || item.err.description || item.message || String(item.err);\n\t      delete item.err;\n\t    }\n\t  }\n\t  callback(null, item);\n\t}\n\t\n\tfunction ensureItemHasSomethingToSay(item, options, callback) {\n\t  if (!item.message && !item.stackInfo && !item.custom) {\n\t    callback(new Error('No message, stack info, or custom data'), null);\n\t  }\n\t  callback(null, item);\n\t}\n\t\n\tfunction addBaseInfo(item, options, callback) {\n\t  var environment = options.environment || (options.payload && options.payload.environment);\n\t  item.data = _.extend(true, {}, item.data, {\n\t    environment: environment,\n\t    level: item.level,\n\t    endpoint: options.endpoint,\n\t    platform: 'browser',\n\t    framework: 'browser-js',\n\t    language: 'javascript',\n\t    server: {},\n\t    notifier: {\n\t      name: 'rollbar-browser-js',\n\t      version: options.version\n\t    }\n\t  });\n\t  callback(null, item);\n\t}\n\t\n\tfunction addRequestInfo(window) {\n\t  return function(item, options, callback) {\n\t    if (!window || !window.location) {\n\t      return callback(null, item);\n\t    }\n\t    _.set(item, 'data.request', {\n\t      url: window.location.href,\n\t      query_string: window.location.search,\n\t      user_ip: '$remote_ip'\n\t    });\n\t    callback(null, item);\n\t  };\n\t}\n\t\n\tfunction addClientInfo(window) {\n\t  return function(item, options, callback) {\n\t    if (!window) {\n\t      return callback(null, item);\n\t    }\n\t    _.set(item, 'data.client', {\n\t      runtime_ms: item.timestamp - window._rollbarStartTime,\n\t      timestamp: Math.round(item.timestamp / 1000),\n\t      javascript: {\n\t        browser: window.navigator.userAgent,\n\t        language: window.navigator.language,\n\t        cookie_enabled: window.navigator.cookieEnabled,\n\t        screen: {\n\t          width: window.screen.width,\n\t          height: window.screen.height\n\t        }\n\t      }\n\t    });\n\t    callback(null, item);\n\t  };\n\t}\n\t\n\tfunction addPluginInfo(window) {\n\t  return function(item, options, callback) {\n\t    if (!window || !window.navigator) {\n\t      return callback(null, item);\n\t    }\n\t    var plugins = [];\n\t    var navPlugins = window.navigator.plugins || [];\n\t    var cur;\n\t    for (var i=0, l=navPlugins.length; i < l; ++i) {\n\t      cur = navPlugins[i];\n\t      plugins.push({name: cur.name, description: cur.description});\n\t    }\n\t    _.set(item, 'data.client.javascript.plugins', plugins);\n\t    callback(null, item);\n\t  };\n\t}\n\t\n\tfunction addBody(item, options, callback) {\n\t  if (item.stackInfo) {\n\t    addBodyTrace(item, options, callback);\n\t  } else {\n\t    addBodyMessage(item, options, callback);\n\t  }\n\t}\n\t\n\tfunction addBodyMessage(item, options, callback) {\n\t  var message = item.message;\n\t  var custom = item.custom;\n\t\n\t  if (!message) {\n\t    if (custom) {\n\t      var scrubFields = options.scrubFields;\n\t      var messageResult = _.stringify(_.scrub(custom, scrubFields));\n\t      message = messageResult.error || messageResult.value || '';\n\t    } else {\n\t      message = '';\n\t    }\n\t  }\n\t  var result = {\n\t    body: message\n\t  };\n\t\n\t  if (custom) {\n\t    result.extra = _.extend(true, {}, custom);\n\t  }\n\t\n\t  _.set(item, 'data.body', {message: result});\n\t  callback(null, item);\n\t}\n\t\n\t\n\tfunction addBodyTrace(item, options, callback) {\n\t  var description = item.data.description;\n\t  var stackInfo = item.stackInfo;\n\t  var custom = item.custom;\n\t\n\t  var guess = errorParser.guessErrorClass(stackInfo.message);\n\t  var className = stackInfo.name || guess[0];\n\t  var message = guess[1];\n\t  var trace = {\n\t    exception: {\n\t      'class': className,\n\t      message: message\n\t    }\n\t  };\n\t\n\t  if (description) {\n\t    trace.exception.description = description || 'uncaught exception';\n\t  }\n\t\n\t  // Transform a TraceKit stackInfo object into a Rollbar trace\n\t  var stack = stackInfo.stack;\n\t  if (stack && stack.length === 0 && item._unhandledStackInfo && item._unhandledStackInfo.stack) {\n\t    stack = item._unhandledStackInfo.stack;\n\t  }\n\t  if (stack) {\n\t    var stackFrame;\n\t    var frame;\n\t    var code;\n\t    var pre;\n\t    var post;\n\t    var contextLength;\n\t    var i, mid;\n\t\n\t    trace.frames = [];\n\t    for (i = 0; i < stack.length; ++i) {\n\t      stackFrame = stack[i];\n\t      frame = {\n\t        filename: stackFrame.url ? _.sanitizeUrl(stackFrame.url) : '(unknown)',\n\t        lineno: stackFrame.line || null,\n\t        method: (!stackFrame.func || stackFrame.func === '?') ? '[anonymous]' : stackFrame.func,\n\t        colno: stackFrame.column\n\t      };\n\t\n\t      code = pre = post = null;\n\t      contextLength = stackFrame.context ? stackFrame.context.length : 0;\n\t      if (contextLength) {\n\t        mid = Math.floor(contextLength / 2);\n\t        pre = stackFrame.context.slice(0, mid);\n\t        code = stackFrame.context[mid];\n\t        post = stackFrame.context.slice(mid);\n\t      }\n\t\n\t      if (code) {\n\t        frame.code = code;\n\t      }\n\t\n\t      if (pre || post) {\n\t        frame.context = {};\n\t        if (pre && pre.length) {\n\t          frame.context.pre = pre;\n\t        }\n\t        if (post && post.length) {\n\t          frame.context.post = post;\n\t        }\n\t      }\n\t\n\t      if (stackFrame.args) {\n\t        frame.args = stackFrame.args;\n\t      }\n\t\n\t      trace.frames.push(frame);\n\t    }\n\t\n\t    // NOTE(cory): reverse the frames since rollbar.com expects the most recent call last\n\t    trace.frames.reverse();\n\t\n\t    if (custom) {\n\t      trace.extra = _.extend(true, {}, custom);\n\t    }\n\t    _.set(item, 'data.body', {trace: trace});\n\t    callback(null, item);\n\t  } else {\n\t    item.message = className + ': ' + message;\n\t    addBodyMessage(item, options, callback);\n\t  }\n\t}\n\t\n\tfunction scrubPayload(item, options, callback) {\n\t  var scrubFields = options.scrubFields;\n\t  _.scrub(item.data, scrubFields);\n\t  callback(null, item);\n\t}\n\t\n\tfunction userTransform(item, options, callback) {\n\t  var newItem = _.extend(true, {}, item);\n\t  try {\n\t    if (_.isFunction(options.transform)) {\n\t      options.transform(newItem.data);\n\t    }\n\t  } catch (e) {\n\t    options.transform = null;\n\t    logger.error('Error while calling custom transform() function. Removing custom transform().', e);\n\t    callback(null, item);\n\t    return;\n\t  }\n\t  callback(null, newItem);\n\t}\n\t\n\tfunction itemToPayload(item, options, callback) {\n\t  var payloadOptions = options.payload || {};\n\t  if (payloadOptions.body) {\n\t    delete payloadOptions.body;\n\t  }\n\t\n\t  var data = _.extend(true, {}, item.data, payloadOptions);\n\t  if (item._isUncaught) {\n\t    data._isUncaught = true;\n\t  }\n\t  callback(null, data);\n\t}\n\t\n\tmodule.exports = {\n\t  handleItemWithError: handleItemWithError,\n\t  ensureItemHasSomethingToSay: ensureItemHasSomethingToSay,\n\t  addBaseInfo: addBaseInfo,\n\t  addRequestInfo: addRequestInfo,\n\t  addClientInfo: addClientInfo,\n\t  addPluginInfo: addPluginInfo,\n\t  addBody: addBody,\n\t  scrubPayload: scrubPayload,\n\t  userTransform: userTransform,\n\t  itemToPayload: itemToPayload\n\t};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar ErrorStackParser = __webpack_require__(20);\n\t\n\tvar UNKNOWN_FUNCTION = '?';\n\tvar ERR_CLASS_REGEXP = new RegExp('^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ');\n\t\n\tfunction guessFunctionName() {\n\t  return UNKNOWN_FUNCTION;\n\t}\n\t\n\t\n\tfunction gatherContext() {\n\t  return null;\n\t}\n\t\n\t\n\tfunction Frame(stackFrame) {\n\t  var data = {};\n\t\n\t  data._stackFrame = stackFrame;\n\t\n\t  data.url = stackFrame.fileName;\n\t  data.line = stackFrame.lineNumber;\n\t  data.func = stackFrame.functionName;\n\t  data.column = stackFrame.columnNumber;\n\t  data.args = stackFrame.args;\n\t\n\t  data.context = gatherContext(data.url, data.line);\n\t\n\t  return data;\n\t}\n\t\n\t\n\tfunction Stack(exception) {\n\t  function getStack() {\n\t    var parserStack = [];\n\t\n\t    try {\n\t      parserStack = ErrorStackParser.parse(exception);\n\t    } catch(e) {\n\t      parserStack = [];\n\t    }\n\t\n\t    var stack = [];\n\t\n\t    for (var i = 0; i < parserStack.length; i++) {\n\t      stack.push(new Frame(parserStack[i]));\n\t    }\n\t\n\t    return stack;\n\t  }\n\t\n\t  return {\n\t    stack: getStack(),\n\t    message: exception.message,\n\t    name: exception.name\n\t  };\n\t}\n\t\n\t\n\tfunction parse(e) {\n\t  return new Stack(e);\n\t}\n\t\n\t\n\tfunction guessErrorClass(errMsg) {\n\t  if (!errMsg) {\n\t    return ['Unknown error. There was no error message to display.', ''];\n\t  }\n\t  var errClassMatch = errMsg.match(ERR_CLASS_REGEXP);\n\t  var errClass = '(unknown)';\n\t\n\t  if (errClassMatch) {\n\t    errClass = errClassMatch[errClassMatch.length - 1];\n\t    errMsg = errMsg.replace((errClassMatch[errClassMatch.length - 2] || '') + errClass + ':', '');\n\t    errMsg = errMsg.replace(/(^[\\s]+|[\\s]+$)/g, '');\n\t  }\n\t  return [errClass, errMsg];\n\t}\n\t\n\t\n\tmodule.exports = {\n\t  guessFunctionName: guessFunctionName,\n\t  guessErrorClass: guessErrorClass,\n\t  gatherContext: gatherContext,\n\t  parse: parse,\n\t  Stack: Stack,\n\t  Frame: Frame\n\t};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(21)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.ErrorStackParser = factory(root.StackFrame);\n\t    }\n\t}(this, function ErrorStackParser(StackFrame) {\n\t    'use strict';\n\t\n\t    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n\t    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n\t    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\t\n\t    function _map(array, fn, thisArg) {\n\t        if (typeof Array.prototype.map === 'function') {\n\t            return array.map(fn, thisArg);\n\t        } else {\n\t            var output = new Array(array.length);\n\t            for (var i = 0; i < array.length; i++) {\n\t                output[i] = fn.call(thisArg, array[i]);\n\t            }\n\t            return output;\n\t        }\n\t    }\n\t\n\t    function _filter(array, fn, thisArg) {\n\t        if (typeof Array.prototype.filter === 'function') {\n\t            return array.filter(fn, thisArg);\n\t        } else {\n\t            var output = [];\n\t            for (var i = 0; i < array.length; i++) {\n\t                if (fn.call(thisArg, array[i])) {\n\t                    output.push(array[i]);\n\t                }\n\t            }\n\t            return output;\n\t        }\n\t    }\n\t\n\t    return {\n\t        /**\n\t         * Given an Error object, extract the most information from it.\n\t         * @param error {Error}\n\t         * @return Array[StackFrame]\n\t         */\n\t        parse: function ErrorStackParser$$parse(error) {\n\t            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n\t                return this.parseOpera(error);\n\t            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n\t                return this.parseV8OrIE(error);\n\t            } else if (error.stack) {\n\t                return this.parseFFOrSafari(error);\n\t            } else {\n\t                throw new Error('Cannot parse given Error object');\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Separate line and column numbers from a URL-like string.\n\t         * @param urlLike String\n\t         * @return Array[String]\n\t         */\n\t        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n\t            // Fail-fast but return locations like \"(native)\"\n\t            if (urlLike.indexOf(':') === -1) {\n\t                return [urlLike];\n\t            }\n\t\n\t            var locationParts = urlLike.replace(/[\\(\\)\\s]/g, '').split(':');\n\t            var lastNumber = locationParts.pop();\n\t            var possibleNumber = locationParts[locationParts.length - 1];\n\t            if (!isNaN(parseFloat(possibleNumber)) && isFinite(possibleNumber)) {\n\t                var lineNumber = locationParts.pop();\n\t                return [locationParts.join(':'), lineNumber, lastNumber];\n\t            } else {\n\t                return [locationParts.join(':'), lastNumber, undefined];\n\t            }\n\t        },\n\t\n\t        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function (line) {\n\t                return !!line.match(CHROME_IE_STACK_REGEXP);\n\t            }, this);\n\t\n\t            return _map(filtered, function (line) {\n\t                if (line.indexOf('(eval ') > -1) {\n\t                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n\t                }\n\t                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionName = tokens.join(' ') || undefined;\n\t                var fileName = locationParts[0] === 'eval' ? undefined : locationParts[0];\n\t\n\t                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n\t            }, this);\n\t        },\n\t\n\t        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function (line) {\n\t                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n\t            }, this);\n\t\n\t            return _map(filtered, function (line) {\n\t                // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                if (line.indexOf(' > eval') > -1) {\n\t                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n\t                }\n\t\n\t                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n\t                    // Safari eval frames only have function names and nothing else\n\t                    return new StackFrame(line);\n\t                } else {\n\t                    var tokens = line.split('@');\n\t                    var locationParts = this.extractLocation(tokens.pop());\n\t                    var functionName = tokens.shift() || undefined;\n\t                    return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2], line);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        parseOpera: function ErrorStackParser$$parseOpera(e) {\n\t            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n\t                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n\t                return this.parseOpera9(e);\n\t            } else if (!e.stack) {\n\t                return this.parseOpera10(e);\n\t            } else {\n\t                return this.parseOpera11(e);\n\t            }\n\t        },\n\t\n\t        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t            var lines = e.message.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 2, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t            var lines = e.stacktrace.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(new StackFrame(match[3] || undefined, undefined, match[2], match[1], undefined, lines[i]));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Opera 10.65+ Error.stack very similar to FF/Safari\n\t        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function (line) {\n\t                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n\t                    !line.match(/^Error created at/);\n\t            }, this);\n\t\n\t            return _map(filtered, function (line) {\n\t                var tokens = line.split('@');\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionCall = (tokens.shift() || '');\n\t                var functionName = functionCall\n\t                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n\t                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n\t                var argsRaw;\n\t                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n\t                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n\t                }\n\t                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ? undefined : argsRaw.split(',');\n\t                return new StackFrame(functionName, args, locationParts[0], locationParts[1], locationParts[2], line);\n\t            }, this);\n\t        }\n\t    };\n\t}));\n\t\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.StackFrame = factory();\n\t    }\n\t}(this, function () {\n\t    'use strict';\n\t    function _isNumber(n) {\n\t        return !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n\t        if (functionName !== undefined) {\n\t            this.setFunctionName(functionName);\n\t        }\n\t        if (args !== undefined) {\n\t            this.setArgs(args);\n\t        }\n\t        if (fileName !== undefined) {\n\t            this.setFileName(fileName);\n\t        }\n\t        if (lineNumber !== undefined) {\n\t            this.setLineNumber(lineNumber);\n\t        }\n\t        if (columnNumber !== undefined) {\n\t            this.setColumnNumber(columnNumber);\n\t        }\n\t        if (source !== undefined) {\n\t            this.setSource(source);\n\t        }\n\t    }\n\t\n\t    StackFrame.prototype = {\n\t        getFunctionName: function () {\n\t            return this.functionName;\n\t        },\n\t        setFunctionName: function (v) {\n\t            this.functionName = String(v);\n\t        },\n\t\n\t        getArgs: function () {\n\t            return this.args;\n\t        },\n\t        setArgs: function (v) {\n\t            if (Object.prototype.toString.call(v) !== '[object Array]') {\n\t                throw new TypeError('Args must be an Array');\n\t            }\n\t            this.args = v;\n\t        },\n\t\n\t        // NOTE: Property name may be misleading as it includes the path,\n\t        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n\t        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n\t        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n\t        getFileName: function () {\n\t            return this.fileName;\n\t        },\n\t        setFileName: function (v) {\n\t            this.fileName = String(v);\n\t        },\n\t\n\t        getLineNumber: function () {\n\t            return this.lineNumber;\n\t        },\n\t        setLineNumber: function (v) {\n\t            if (!_isNumber(v)) {\n\t                throw new TypeError('Line Number must be a Number');\n\t            }\n\t            this.lineNumber = Number(v);\n\t        },\n\t\n\t        getColumnNumber: function () {\n\t            return this.columnNumber;\n\t        },\n\t        setColumnNumber: function (v) {\n\t            if (!_isNumber(v)) {\n\t                throw new TypeError('Column Number must be a Number');\n\t            }\n\t            this.columnNumber = Number(v);\n\t        },\n\t\n\t        getSource: function () {\n\t            return this.source;\n\t        },\n\t        setSource: function (v) {\n\t            this.source = String(v);\n\t        },\n\t\n\t        toString: function() {\n\t            var functionName = this.getFunctionName() || '{anonymous}';\n\t            var args = '(' + (this.getArgs() || []).join(',') + ')';\n\t            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n\t            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n\t            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n\t            return functionName + args + fileName + lineNumber + columnNumber;\n\t        }\n\t    };\n\t\n\t    return StackFrame;\n\t}));\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ = __webpack_require__(6);\n\tvar logger = __webpack_require__(12);\n\t\n\tfunction checkIgnore(item, settings) {\n\t  var level = item.level;\n\t  var levelVal = _.LEVELS[level] || 0;\n\t  var reportLevel = _.LEVELS[settings.reportLevel] || 0;\n\t\n\t  if (levelVal < reportLevel) {\n\t    return false;\n\t  }\n\t\n\t  if (_.get(settings, 'plugins.jquery.ignoreAjaxErrors')) {\n\t    return !_.get(item, 'body.message.extra.isAjax');\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction userCheckIgnore(item, settings) {\n\t  var isUncaught = !!item._isUncaught;\n\t  delete item._isUncaught;\n\t  var args = item._originalArgs;\n\t  delete item._originalArgs;\n\t  try {\n\t    if (_.isFunction(settings.checkIgnore) && settings.checkIgnore(isUncaught, args, item)) {\n\t      return false;\n\t    }\n\t  } catch (e) {\n\t    settings.checkIgnore = null;\n\t    logger.error('Error while calling custom checkIgnore(), removing', e);\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction urlIsWhitelisted(item, settings) {\n\t  var whitelist, trace, frame, filename, frameLength, url, listLength, urlRegex;\n\t  var i, j;\n\t\n\t  try {\n\t    whitelist = settings.hostWhiteList;\n\t    listLength = whitelist && whitelist.length;\n\t    trace = _.get(item, 'body.trace');\n\t\n\t    if (!whitelist || listLength === 0) {\n\t      return true;\n\t    }\n\t    if (!trace || !trace.frames) {\n\t      return true;\n\t    }\n\t\n\t    frameLength = trace.frames.length;\n\t    for (i = 0; i < frameLength; i++) {\n\t      frame = trace.frames[i];\n\t      filename = frame.filename;\n\t\n\t      if (!_.isType(filename, 'string')) {\n\t        return true;\n\t      }\n\t\n\t      for (j = 0; j < listLength; j++) {\n\t        url = whitelist[j];\n\t        urlRegex = new RegExp(url);\n\t\n\t        if (urlRegex.test(filename)){\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t  } catch (e)\n\t  /* istanbul ignore next */\n\t  {\n\t    settings.hostWhiteList = null;\n\t    logger.error('Error while reading your configuration\\'s hostWhiteList option. Removing custom hostWhiteList.', e);\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction messageIsIgnored(item, settings) {\n\t  var exceptionMessage, i, ignoredMessages,\n\t      len, messageIsIgnored, rIgnoredMessage,\n\t      body, traceMessage, bodyMessage;\n\t\n\t  try {\n\t    messageIsIgnored = false;\n\t    ignoredMessages = settings.ignoredMessages;\n\t    \n\t    if (!ignoredMessages || ignoredMessages.length === 0) {\n\t      return true;\n\t    }\n\t\n\t    body = item.body;\n\t    traceMessage = _.get(body, 'trace.exception.message');\n\t    bodyMessage = _.get(body, 'message.body');\n\t\n\t    exceptionMessage = traceMessage || bodyMessage;\n\t\n\t    if (!exceptionMessage){\n\t      return true;\n\t    }\n\t\n\t    len = ignoredMessages.length;\n\t    for (i = 0; i < len; i++) {\n\t      rIgnoredMessage = new RegExp(ignoredMessages[i], 'gi');\n\t      messageIsIgnored = rIgnoredMessage.test(exceptionMessage);\n\t\n\t      if (messageIsIgnored) {\n\t        break;\n\t      }\n\t    }\n\t  } catch(e)\n\t  /* istanbul ignore next */\n\t  {\n\t    settings.ignoredMessages = null;\n\t    logger.error('Error while reading your configuration\\'s ignoredMessages option. Removing custom ignoredMessages.');\n\t  }\n\t\n\t  return !messageIsIgnored;\n\t}\n\t\n\tmodule.exports = {\n\t  checkIgnore: checkIgnore,\n\t  userCheckIgnore: userCheckIgnore,\n\t  urlIsWhitelisted: urlIsWhitelisted,\n\t  messageIsIgnored: messageIsIgnored\n\t};\n\t\n\n\n/***/ })\n/******/ ])\n});\n;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JvbGxiYXIvZGlzdC9yb2xsYmFyLm5vY29uZmxpY3QudW1kLmpzP2Q0MmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLHNCQUFzQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxPQUFPO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0I7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsVUFBVSxZQUFZLEdBQUc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsaUJBQWlCO0FBQzNELCtCQUErQixrQkFBa0I7O0FBRWpELDBDQUEwQyxpQkFBaUI7QUFDM0QsdUNBQXVDLDZCQUE2Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekIsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZUFBZSx3REFBd0Q7QUFDdkUsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixnREFBZ0Q7QUFDekU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixnREFBZ0Q7QUFDekU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELHlHQUF5RyxFQUFFOztBQUUzSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLFVBQVU7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0EscUJBQXFCLDZDQUE2QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpR0FBaUc7QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRixPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpR0FBaUc7QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLDREQUE0RCxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgcm9sbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHRpZiAod2luZG93ICYmICF3aW5kb3cuX3JvbGxiYXJTdGFydFRpbWUpIHtcblx0ICB3aW5kb3cuX3JvbGxiYXJTdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHJvbGxiYXI7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIENsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIEFQSSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBnbG9iYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgdHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdHZhciB1cmxsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0XG5cdHZhciB0cmFuc2Zvcm1zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdHZhciBwcmVkaWNhdGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdHZhciBlcnJvclBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHRcblx0ZnVuY3Rpb24gUm9sbGJhcihvcHRpb25zLCBjbGllbnQpIHtcblx0ICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0cnVlLCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgdmFyIGFwaSA9IG5ldyBBUEkodGhpcy5vcHRpb25zLCB0cmFuc3BvcnQsIHVybGxpYik7XG5cdCAgdGhpcy5jbGllbnQgPSBjbGllbnQgfHwgbmV3IENsaWVudCh0aGlzLm9wdGlvbnMsIGFwaSwgbG9nZ2VyKTtcblx0ICBhZGRUcmFuc2Zvcm1zVG9Ob3RpZmllcih0aGlzLmNsaWVudC5ub3RpZmllcik7XG5cdCAgYWRkUHJlZGljYXRlc1RvUXVldWUodGhpcy5jbGllbnQucXVldWUpO1xuXHQgIGlmICh0aGlzLm9wdGlvbnMuY2FwdHVyZVVuY2F1Z2h0KSB7XG5cdCAgICBnbG9iYWxzLmNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMod2luZG93LCB0aGlzKTtcblx0ICAgIGdsb2JhbHMud3JhcEdsb2JhbHMod2luZG93LCB0aGlzKTtcblx0ICB9XG5cdCAgaWYgKHRoaXMub3B0aW9ucy5jYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuXHQgICAgZ2xvYmFscy5jYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucyh3aW5kb3csIHRoaXMpO1xuXHQgIH1cblx0fVxuXHRcblx0Um9sbGJhci5wcm90b3R5cGUuZ2xvYmFsID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgIHRoaXMuY2xpZW50Lmdsb2JhbChvcHRpb25zKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0ICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0cnVlLCB7fSwgb2xkT3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgdGhpcy5jbGllbnQuY29uZmlndXJlKG9wdGlvbnMpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um9sbGJhci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG5cdCAgdmFyIHV1aWQgPSBpdGVtLnV1aWQ7XG5cdCAgdGhpcy5jbGllbnQubG9nKGl0ZW0pO1xuXHQgIHJldHVybiB7dXVpZDogdXVpZH07XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuXHQgIHZhciB1dWlkID0gaXRlbS51dWlkO1xuXHQgIHRoaXMuY2xpZW50LmRlYnVnKGl0ZW0pO1xuXHQgIHJldHVybiB7dXVpZDogdXVpZH07XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGl0ZW0gPSB0aGlzLl9jcmVhdGVJdGVtKGFyZ3VtZW50cyk7XG5cdCAgdmFyIHV1aWQgPSBpdGVtLnV1aWQ7XG5cdCAgdGhpcy5jbGllbnQuaW5mbyhpdGVtKTtcblx0ICByZXR1cm4ge3V1aWQ6IHV1aWR9O1xuXHR9O1xuXHRcblx0Um9sbGJhci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuXHQgIHZhciB1dWlkID0gaXRlbS51dWlkO1xuXHQgIHRoaXMuY2xpZW50Lndhcm4oaXRlbSk7XG5cdCAgcmV0dXJuIHt1dWlkOiB1dWlkfTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oYXJndW1lbnRzKTtcblx0ICB2YXIgdXVpZCA9IGl0ZW0udXVpZDtcblx0ICB0aGlzLmNsaWVudC53YXJuaW5nKGl0ZW0pO1xuXHQgIHJldHVybiB7dXVpZDogdXVpZH07XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuXHQgIHZhciB1dWlkID0gaXRlbS51dWlkO1xuXHQgIHRoaXMuY2xpZW50LmVycm9yKGl0ZW0pO1xuXHQgIHJldHVybiB7dXVpZDogdXVpZH07XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS5jcml0aWNhbCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShhcmd1bWVudHMpO1xuXHQgIHZhciB1dWlkID0gaXRlbS51dWlkO1xuXHQgIHRoaXMuY2xpZW50LmNyaXRpY2FsKGl0ZW0pO1xuXHQgIHJldHVybiB7dXVpZDogdXVpZH07XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHVybCwgbGluZW5vLCBjb2xubywgZXJyb3IsIGNvbnRleHQpIHtcblx0ICB2YXIgaXRlbTtcblx0ICB2YXIgc3RhY2tJbmZvID0gXy5tYWtlVW5oYW5kbGVkU3RhY2tJbmZvKFxuXHQgICAgbWVzc2FnZSxcblx0ICAgIHVybCxcblx0ICAgIGxpbmVubyxcblx0ICAgIGNvbG5vLFxuXHQgICAgZXJyb3IsXG5cdCAgICAnb25lcnJvcicsXG5cdCAgICAndW5jYXVnaHQgZXhjZXB0aW9uJyxcblx0ICAgIGVycm9yUGFyc2VyXG5cdCAgKTtcblx0ICBpZiAoXy5pc0Vycm9yKGVycm9yKSkge1xuXHQgICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIGVycm9yLCBjb250ZXh0XSk7XG5cdCAgICBpdGVtLl91bmhhbmRsZWRTdGFja0luZm8gPSBzdGFja0luZm87XG5cdCAgfSBlbHNlIGlmIChfLmlzRXJyb3IodXJsKSkge1xuXHQgICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIHVybCwgY29udGV4dF0pO1xuXHQgICAgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvID0gc3RhY2tJbmZvO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShbbWVzc2FnZSwgY29udGV4dF0pO1xuXHQgICAgaXRlbS5zdGFja0luZm8gPSBzdGFja0luZm87XG5cdCAgfVxuXHQgIGl0ZW0ubGV2ZWwgPSB0aGlzLm9wdGlvbnMudW5jYXVnaHRFcnJvckxldmVsO1xuXHQgIGl0ZW0uX2lzVW5jYXVnaHQgPSB0cnVlO1xuXHQgIHRoaXMuY2xpZW50LmxvZyhpdGVtKTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uKHJlYXNvbiwgcHJvbWlzZSkge1xuXHQgIHZhciBtZXNzYWdlID0gJ3VuaGFuZGxlZCByZWplY3Rpb24gd2FzIG51bGwgb3IgdW5kZWZpbmVkISc7XG5cdCAgbWVzc2FnZSA9IHJlYXNvbiA/IChyZWFzb24ubWVzc2FnZSB8fCBTdHJpbmcocmVhc29uKSkgOiBtZXNzYWdlO1xuXHQgIHZhciBjb250ZXh0ID0gKHJlYXNvbiAmJiByZWFzb24uX3JvbGxiYXJDb250ZXh0KSB8fCAocHJvbWlzZSAmJiBwcm9taXNlLl9yb2xsYmFyQ29udGV4dCk7XG5cdFxuXHQgIHZhciBpdGVtO1xuXHQgIGlmIChfLmlzRXJyb3IocmVhc29uKSkge1xuXHQgICAgaXRlbSA9IHRoaXMuX2NyZWF0ZUl0ZW0oW21lc3NhZ2UsIHJlYXNvbiwgY29udGV4dF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShbbWVzc2FnZSwgY29udGV4dF0pO1xuXHQgICAgaXRlbS5zdGFja0luZm8gPSBfLm1ha2VVbmhhbmRsZWRTdGFja0luZm8oXG5cdCAgICAgIG1lc3NhZ2UsXG5cdCAgICAgICcnLFxuXHQgICAgICAwLFxuXHQgICAgICAwLFxuXHQgICAgICBudWxsLFxuXHQgICAgICAndW5oYW5kbGVkcmVqZWN0aW9uJyxcblx0ICAgICAgJycsXG5cdCAgICAgIGVycm9yUGFyc2VyXG5cdCAgICApO1xuXHQgIH1cblx0ICBpdGVtLmxldmVsID0gdGhpcy5vcHRpb25zLnVuY2F1Z2h0RXJyb3JMZXZlbDtcblx0ICBpdGVtLl9pc1VuY2F1Z2h0ID0gdHJ1ZTtcblx0ICB0aGlzLmNsaWVudC5sb2coaXRlbSk7XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oZiwgY29udGV4dCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgY3R4Rm47XG5cdCAgICBpZihfLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcblx0ICAgICAgY3R4Rm4gPSBjb250ZXh0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY3R4Rm4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnRleHQgfHwge307IH07XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKCFfLmlzRnVuY3Rpb24oZikpIHtcblx0ICAgICAgcmV0dXJuIGY7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKGYuX2lzV3JhcCkge1xuXHQgICAgICByZXR1cm4gZjtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoIWYuX3dyYXBwZWQpIHtcblx0ICAgICAgZi5fd3JhcHBlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9IGNhdGNoKGV4Yykge1xuXHQgICAgICAgICAgdmFyIGUgPSBleGM7XG5cdCAgICAgICAgICBpZiAoXy5pc1R5cGUoZSwgJ3N0cmluZycpKSB7XG5cdCAgICAgICAgICAgIGUgPSBuZXcgU3RyaW5nKGUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgZS5fcm9sbGJhckNvbnRleHQgPSBjdHhGbigpIHx8IHt9O1xuXHQgICAgICAgICAgZS5fcm9sbGJhckNvbnRleHQuX3dyYXBwZWRTb3VyY2UgPSBmLnRvU3RyaW5nKCk7XG5cdFxuXHQgICAgICAgICAgd2luZG93Ll9yb2xsYmFyV3JhcHBlZEVycm9yID0gZTtcblx0ICAgICAgICAgIHRocm93IGU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgZi5fd3JhcHBlZC5faXNXcmFwID0gdHJ1ZTtcblx0XG5cdCAgICAgIGlmIChmLmhhc093blByb3BlcnR5KSB7XG5cdCAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmKSB7XG5cdCAgICAgICAgICBpZiAoZi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHQgICAgICAgICAgICBmLl93cmFwcGVkW3Byb3BdID0gZltwcm9wXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gZi5fd3JhcHBlZDtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICAvLyBSZXR1cm4gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGlmIHRoZSB3cmFwIGZhaWxzLlxuXHQgICAgcmV0dXJuIGY7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyogSW50ZXJuYWwgKi9cblx0XG5cdGZ1bmN0aW9uIGFkZFRyYW5zZm9ybXNUb05vdGlmaWVyKG5vdGlmaWVyKSB7XG5cdCAgbm90aWZpZXJcblx0ICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5oYW5kbGVJdGVtV2l0aEVycm9yKVxuXHQgICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheSlcblx0ICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRCYXNlSW5mbylcblx0ICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRSZXF1ZXN0SW5mbyh3aW5kb3cpKVxuXHQgICAgLmFkZFRyYW5zZm9ybSh0cmFuc2Zvcm1zLmFkZENsaWVudEluZm8od2luZG93KSlcblx0ICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5hZGRQbHVnaW5JbmZvKHdpbmRvdykpXG5cdCAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMuYWRkQm9keSlcblx0ICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5zY3J1YlBheWxvYWQpXG5cdCAgICAuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybXMudXNlclRyYW5zZm9ybSlcblx0ICAgIC5hZGRUcmFuc2Zvcm0odHJhbnNmb3Jtcy5pdGVtVG9QYXlsb2FkKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkUHJlZGljYXRlc1RvUXVldWUocXVldWUpIHtcblx0ICBxdWV1ZVxuXHQgICAgLmFkZFByZWRpY2F0ZShwcmVkaWNhdGVzLmNoZWNrSWdub3JlKVxuXHQgICAgLmFkZFByZWRpY2F0ZShwcmVkaWNhdGVzLnVzZXJDaGVja0lnbm9yZSlcblx0ICAgIC5hZGRQcmVkaWNhdGUocHJlZGljYXRlcy51cmxJc1doaXRlbGlzdGVkKVxuXHQgICAgLmFkZFByZWRpY2F0ZShwcmVkaWNhdGVzLm1lc3NhZ2VJc0lnbm9yZWQpO1xuXHR9XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS5fY3JlYXRlSXRlbSA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0ICB2YXIgbWVzc2FnZSwgZXJyLCBjdXN0b20sIGNhbGxiYWNrO1xuXHQgIHZhciBhcmc7XG5cdCAgdmFyIGV4dHJhQXJncyA9IFtdO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdCAgICBhcmcgPSBhcmdzW2ldO1xuXHRcblx0ICAgIHN3aXRjaCAoXy50eXBlTmFtZShhcmcpKSB7XG5cdCAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgJ3N0cmluZyc6XG5cdCAgICAgICAgbWVzc2FnZSA/IGV4dHJhQXJncy5wdXNoKGFyZykgOiBtZXNzYWdlID0gYXJnO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdmdW5jdGlvbic6XG5cdCAgICAgICAgY2FsbGJhY2sgPSBfLndyYXBSb2xsYmFyRnVuY3Rpb24obG9nZ2VyLCBhcmcsIHRoaXMpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdkYXRlJzpcblx0ICAgICAgICBleHRyYUFyZ3MucHVzaChhcmcpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdlcnJvcic6XG5cdCAgICAgIGNhc2UgJ2RvbWV4Y2VwdGlvbic6XG5cdCAgICAgICAgZXJyID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IGVyciA9IGFyZztcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSAnb2JqZWN0Jzpcblx0ICAgICAgY2FzZSAnYXJyYXknOlxuXHQgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvciB8fCAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSkge1xuXHQgICAgICAgICAgZXJyID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IGVyciA9IGFyZztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjdXN0b20gPyBleHRyYUFyZ3MucHVzaChhcmcpIDogY3VzdG9tID0gYXJnO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvciB8fCAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSkge1xuXHQgICAgICAgICAgZXJyID8gZXh0cmFBcmdzLnB1c2goYXJnKSA6IGVyciA9IGFyZztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBleHRyYUFyZ3MucHVzaChhcmcpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgaWYgKGV4dHJhQXJncy5sZW5ndGggPiAwKSB7XG5cdCAgICAvLyBpZiBjdXN0b20gaXMgYW4gYXJyYXkgdGhpcyB0dXJucyBpdCBpbnRvIGFuIG9iamVjdCB3aXRoIGludGVnZXIga2V5c1xuXHQgICAgY3VzdG9tID0gXy5leHRlbmQodHJ1ZSwge30sIGN1c3RvbSk7XG5cdCAgICBjdXN0b20uZXh0cmFBcmdzID0gZXh0cmFBcmdzO1xuXHQgIH1cblx0XG5cdCAgdmFyIGl0ZW0gPSB7XG5cdCAgICBtZXNzYWdlOiBtZXNzYWdlLFxuXHQgICAgZXJyOiBlcnIsXG5cdCAgICBjdXN0b206IGN1c3RvbSxcblx0ICAgIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcblx0ICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcblx0ICAgIHV1aWQ6IF8udXVpZDQoKVxuXHQgIH07XG5cdCAgaXRlbS5fb3JpZ2luYWxBcmdzID0gYXJncztcblx0ICByZXR1cm4gaXRlbTtcblx0fTtcblx0XG5cdC8qIGdsb2JhbCBfX05PVElGSUVSX1ZFUlNJT05fXzpmYWxzZSAqL1xuXHQvKiBnbG9iYWwgX19ERUZBVUxUX0JST1dTRVJfU0NSVUJfRklFTERTX186ZmFsc2UgKi9cblx0LyogZ2xvYmFsIF9fREVGQVVMVF9MT0dfTEVWRUxfXzpmYWxzZSAqL1xuXHQvKiBnbG9iYWwgX19ERUZBVUxUX1JFUE9SVF9MRVZFTF9fOmZhbHNlICovXG5cdC8qIGdsb2JhbCBfX0RFRkFVTFRfVU5DQVVHSFRfRVJST1JfTEVWRUw6ZmFsc2UgKi9cblx0LyogZ2xvYmFsIF9fREVGQVVMVF9FTkRQT0lOVF9fOmZhbHNlICovXG5cdFxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgdmVyc2lvbjogKFwiMi4wLjNcIiksXG5cdCAgc2NydWJGaWVsZHM6IChbXCJwd1wiLFwicGFzc1wiLFwicGFzc3dkXCIsXCJwYXNzd29yZFwiLFwic2VjcmV0XCIsXCJjb25maXJtX3Bhc3N3b3JkXCIsXCJjb25maXJtUGFzc3dvcmRcIixcInBhc3N3b3JkX2NvbmZpcm1hdGlvblwiLFwicGFzc3dvcmRDb25maXJtYXRpb25cIixcImFjY2Vzc190b2tlblwiLFwiYWNjZXNzVG9rZW5cIixcInNlY3JldF9rZXlcIixcInNlY3JldEtleVwiLFwic2VjcmV0VG9rZW5cIl0pLFxuXHQgIGxvZ0xldmVsOiAoXCJkZWJ1Z1wiKSxcblx0ICByZXBvcnRMZXZlbDogKFwiZGVidWdcIiksXG5cdCAgdW5jYXVnaHRFcnJvckxldmVsOiAoXCJlcnJvclwiKSxcblx0ICBlbmRwb2ludDogKFwiYXBpLnJvbGxiYXIuY29tL2FwaS8xL1wiKSxcblx0ICBlbmFibGVkOiB0cnVlXG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IFJvbGxiYXI7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIFJhdGVMaW1pdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIFF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIE5vdGlmaWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0Lypcblx0ICogUm9sbGJhciAtIHRoZSBpbnRlcmZhY2UgdG8gUm9sbGJhclxuXHQgKlxuXHQgKiBAcGFyYW0gb3B0aW9uc1xuXHQgKiBAcGFyYW0gYXBpXG5cdCAqIEBwYXJhbSBsb2dnZXJcblx0ICovXG5cdGZ1bmN0aW9uIFJvbGxiYXIob3B0aW9ucywgYXBpLCBsb2dnZXIpIHtcblx0ICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XG5cdCAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG5cdCAgdGhpcy5xdWV1ZSA9IG5ldyBRdWV1ZShSb2xsYmFyLnJhdGVMaW1pdGVyLCBhcGksIHRoaXMub3B0aW9ucyk7XG5cdCAgdGhpcy5ub3RpZmllciA9IG5ldyBOb3RpZmllcih0aGlzLnF1ZXVlLCB0aGlzLm9wdGlvbnMpO1xuXHR9XG5cdFxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgbWF4SXRlbXM6IDAsXG5cdCAgaXRlbXNQZXJNaW51dGU6IDYwXG5cdH07XG5cdFxuXHRSb2xsYmFyLnJhdGVMaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyKGRlZmF1bHRPcHRpb25zKTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmdsb2JhbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICBSb2xsYmFyLnJhdGVMaW1pdGVyLmNvbmZpZ3VyZUdsb2JhbChvcHRpb25zKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICB0aGlzLm5vdGlmaWVyICYmIHRoaXMubm90aWZpZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuXHQgIHZhciBvbGRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHQgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRydWUsIHt9LCBvbGRPcHRpb25zLCBvcHRpb25zKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICB2YXIgbGV2ZWwgPSB0aGlzLl9kZWZhdWx0TG9nTGV2ZWwoKTtcblx0ICByZXR1cm4gdGhpcy5fbG9nKGxldmVsLCBpdGVtKTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oaXRlbSkge1xuXHQgIHRoaXMuX2xvZygnZGVidWcnLCBpdGVtKTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihpdGVtKSB7XG5cdCAgdGhpcy5fbG9nKCdpbmZvJywgaXRlbSk7XG5cdH07XG5cdFxuXHRSb2xsYmFyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24oaXRlbSkge1xuXHQgIHRoaXMuX2xvZygnd2FybmluZycsIGl0ZW0pO1xuXHR9O1xuXHRcblx0Um9sbGJhci5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICB0aGlzLl9sb2coJ3dhcm5pbmcnLCBpdGVtKTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oaXRlbSkge1xuXHQgIHRoaXMuX2xvZygnZXJyb3InLCBpdGVtKTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLmNyaXRpY2FsID0gZnVuY3Rpb24oaXRlbSkge1xuXHQgIHRoaXMuX2xvZygnY3JpdGljYWwnLCBpdGVtKTtcblx0fTtcblx0XG5cdFJvbGxiYXIucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHQgIHRoaXMucXVldWUud2FpdChjYWxsYmFjayk7XG5cdH07XG5cdFxuXHQvKiBJbnRlcm5hbCAqL1xuXHRcblx0Um9sbGJhci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uKGRlZmF1bHRMZXZlbCwgaXRlbSkge1xuXHQgIF8ud3JhcFJvbGxiYXJGdW5jdGlvbih0aGlzLmxvZ2dlciwgZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcblx0ICAgICAgY2FsbGJhY2sgPSBpdGVtLmNhbGxiYWNrO1xuXHQgICAgICBkZWxldGUgaXRlbS5jYWxsYmFjaztcblx0ICAgIH1cblx0ICAgIGl0ZW0ubGV2ZWwgPSBpdGVtLmxldmVsIHx8IGRlZmF1bHRMZXZlbDtcblx0ICAgIHRoaXMubm90aWZpZXIubG9nKGl0ZW0sIGNhbGxiYWNrKTtcblx0ICB9LCB0aGlzKSgpO1xuXHR9O1xuXHRcblx0Um9sbGJhci5wcm90b3R5cGUuX2RlZmF1bHRMb2dMZXZlbCA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiB0aGlzLm9wdGlvbnMubG9nTGV2ZWwgfHwgJ2RlYnVnJztcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gUm9sbGJhcjtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKlxuXHQgKiBSYXRlTGltaXRlciAtIGFuIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgZm9yIGNvdW50aW5nIGl0ZW1zIHNlbnQgdG8gUm9sbGJhclxuXHQgKlxuXHQgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBzYW1lIG9wdGlvbnMgdGhhdCBhcmUgYWNjZXB0ZWQgYnkgY29uZmlndXJlR2xvYmFsIG9mZmVyZWQgYXMgYSBjb252ZW5pZW5jZVxuXHQgKi9cblx0ZnVuY3Rpb24gUmF0ZUxpbWl0ZXIob3B0aW9ucykge1xuXHQgIHRoaXMuc3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0ICB0aGlzLmNvdW50ZXIgPSAwO1xuXHQgIHRoaXMucGVyTWluQ291bnRlciA9IDA7XG5cdCAgdGhpcy5jb25maWd1cmVHbG9iYWwob3B0aW9ucyk7XG5cdH1cblx0XG5cdFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzID0ge1xuXHQgIHN0YXJ0VGltZTogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcblx0ICBtYXhJdGVtczogdW5kZWZpbmVkLFxuXHQgIGl0ZW1zUGVyTWludXRlOiB1bmRlZmluZWRcblx0fTtcblx0XG5cdC8qXG5cdCAqIGNvbmZpZ3VyZUdsb2JhbCAtIHNldCB0aGUgZ2xvYmFsIHJhdGUgbGltaXRlciBvcHRpb25zXG5cdCAqXG5cdCAqIEBwYXJhbSBvcHRpb25zIC0gT25seSB0aGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgcmVjb2duaXplZDpcblx0ICogICAgc3RhcnRUaW1lOiBhIHRpbWVzdGFtcCBvZiB0aGUgZm9ybSByZXR1cm5lZCBieSAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG5cdCAqICAgIG1heEl0ZW1zOiB0aGUgbWF4aW11bSBpdGVtc1xuXHQgKiAgICBpdGVtc1Blck1pbnV0ZTogdGhlIG1heCBudW1iZXIgb2YgaXRlbXMgdG8gc2VuZCBpbiBhIGdpdmVuIG1pbnV0ZVxuXHQgKi9cblx0UmF0ZUxpbWl0ZXIucHJvdG90eXBlLmNvbmZpZ3VyZUdsb2JhbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICBpZiAob3B0aW9ucy5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3Muc3RhcnRUaW1lID0gb3B0aW9ucy5zdGFydFRpbWU7XG5cdCAgfVxuXHQgIGlmIChvcHRpb25zLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzLm1heEl0ZW1zID0gb3B0aW9ucy5tYXhJdGVtcztcblx0ICB9XG5cdCAgaWYgKG9wdGlvbnMuaXRlbXNQZXJNaW51dGUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgUmF0ZUxpbWl0ZXIuZ2xvYmFsU2V0dGluZ3MuaXRlbXNQZXJNaW51dGUgPSBvcHRpb25zLml0ZW1zUGVyTWludXRlO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qXG5cdCAqIHNob3VsZFNlbmQgLSBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHNlbmQgYSBnaXZlbiBpdGVtIGJhc2VkIG9uIHJhdGUgbGltaXQgc2V0dGluZ3Ncblx0ICpcblx0ICogQHBhcmFtIGl0ZW0gLSB0aGUgaXRlbSB3ZSBhcmUgYWJvdXQgdG8gc2VuZFxuXHQgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblx0ICogIGVycm9yOiAoRXJyb3J8bnVsbClcblx0ICogIHNob3VsZFNlbmQ6IGJvb2xcblx0ICogIHBheWxvYWQ6IChPYmplY3R8bnVsbClcblx0ICogIElmIHNob3VsZFNlbmQgaXMgZmFsc2UsIHRoZSBpdGVtIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBzaG91bGQgbm90IGJlIHNlbnQgdG8gUm9sbGJhciwgYW5kXG5cdCAqICBleGFjdGx5IG9uZSBvZiBlcnJvciBvciBwYXlsb2FkIHdpbGwgYmUgbm9uLW51bGwuIElmIGVycm9yIGlzIG5vbi1udWxsLCB0aGUgcmV0dXJuZWQgRXJyb3Igd2lsbFxuXHQgKiAgZGVzY3JpYmUgdGhlIHNpdHVhdGlvbiwgYnV0IGl0IG1lYW5zIHRoYXQgd2Ugd2VyZSBhbHJlYWR5IG92ZXIgYSByYXRlIGxpbWl0IChlaXRoZXIgZ2xvYmFsbHkgb3Jcblx0ICogIHBlciBtaW51dGUpIHdoZW4gdGhpcyBpdGVtIHdhcyBjaGVja2VkLiBJZiBlcnJvciBpcyBudWxsLCBhbmQgdGhlcmVmb3JlIHBheWxvYWQgaXMgbm9uLW51bGwsIGl0XG5cdCAqICBtZWFucyB0aGlzIGl0ZW0gcHV0IHVzIG92ZXIgdGhlIGdsb2JhbCByYXRlIGxpbWl0IGFuZCB0aGUgcGF5bG9hZCBzaG91bGQgYmUgc2VudCB0byBSb2xsYmFyIGluXG5cdCAqICBwbGFjZSBvZiB0aGUgcGFzc2VkIGluIGl0ZW0uXG5cdCAqL1xuXHRSYXRlTGltaXRlci5wcm90b3R5cGUuc2hvdWxkU2VuZCA9IGZ1bmN0aW9uKGl0ZW0sIG5vdykge1xuXHQgIG5vdyA9IG5vdyB8fCAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHQgIGlmIChub3cgLSB0aGlzLnN0YXJ0VGltZSA+PSA2MDAwMCkge1xuXHQgICAgdGhpcy5zdGFydFRpbWUgPSBub3c7XG5cdCAgICB0aGlzLnBlck1pbkNvdW50ZXIgPSAwO1xuXHQgIH1cblx0XG5cdCAgdmFyIGdsb2JhbFJhdGVMaW1pdCA9IFJhdGVMaW1pdGVyLmdsb2JhbFNldHRpbmdzLm1heEl0ZW1zO1xuXHQgIHZhciBnbG9iYWxSYXRlTGltaXRQZXJNaW4gPSBSYXRlTGltaXRlci5nbG9iYWxTZXR0aW5ncy5pdGVtc1Blck1pbnV0ZTtcblx0XG5cdCAgaWYgKGNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXQsIHRoaXMuY291bnRlcikpIHtcblx0ICAgIHJldHVybiBzaG91bGRTZW5kVmFsdWUoZ2xvYmFsUmF0ZUxpbWl0ICsgJyBtYXggaXRlbXMgcmVhY2hlZCcsIGZhbHNlKTtcblx0ICB9IGVsc2UgaWYgKGNoZWNrUmF0ZShpdGVtLCBnbG9iYWxSYXRlTGltaXRQZXJNaW4sIHRoaXMucGVyTWluQ291bnRlcikpIHtcblx0ICAgIHJldHVybiBzaG91bGRTZW5kVmFsdWUoZ2xvYmFsUmF0ZUxpbWl0UGVyTWluICsgJyBpdGVtcyBwZXIgbWludXRlIHJlYWNoZWQnLCBmYWxzZSk7XG5cdCAgfVxuXHQgIHRoaXMuY291bnRlcisrO1xuXHQgIHRoaXMucGVyTWluQ291bnRlcisrO1xuXHRcblx0ICB2YXIgc2hvdWxkU2VuZCA9ICFjaGVja1JhdGUoaXRlbSwgZ2xvYmFsUmF0ZUxpbWl0LCB0aGlzLmNvdW50ZXIpO1xuXHQgIHJldHVybiBzaG91bGRTZW5kVmFsdWUobnVsbCwgc2hvdWxkU2VuZCwgZ2xvYmFsUmF0ZUxpbWl0KTtcblx0fTtcblx0XG5cdC8qIEhlbHBlcnMgKi9cblx0XG5cdGZ1bmN0aW9uIGNoZWNrUmF0ZShpdGVtLCBsaW1pdCwgY291bnRlcikge1xuXHQgIHJldHVybiAhaXRlbS5pZ25vcmVSYXRlTGltaXQgJiYgbGltaXQgPj0gMSAmJiBjb3VudGVyID49IGxpbWl0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzaG91bGRTZW5kVmFsdWUoZXJyb3IsIHNob3VsZFNlbmQsIGdsb2JhbFJhdGVMaW1pdCkge1xuXHQgIHZhciBwYXlsb2FkID0gbnVsbDtcblx0ICBpZiAoZXJyb3IpIHtcblx0ICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcblx0ICB9XG5cdCAgaWYgKCFlcnJvciAmJiAhc2hvdWxkU2VuZCkge1xuXHQgICAgcGF5bG9hZCA9IHJhdGVMaW1pdFBheWxvYWQoZ2xvYmFsUmF0ZUxpbWl0KTtcblx0ICB9XG5cdCAgcmV0dXJuIHtlcnJvcjogZXJyb3IsIHNob3VsZFNlbmQ6IHNob3VsZFNlbmQsIHBheWxvYWQ6IHBheWxvYWR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiByYXRlTGltaXRQYXlsb2FkKGdsb2JhbFJhdGVMaW1pdCkge1xuXHQgIHJldHVybiB7XG5cdCAgICBtZXNzYWdlOiAnbWF4SXRlbXMgaGFzIGJlZW4gaGl0LiBJZ25vcmluZyBlcnJvcnMgdW50aWwgcmVzZXQuJyxcblx0ICAgIGVycjogbnVsbCxcblx0ICAgIGN1c3RvbToge1xuXHQgICAgICBtYXhJdGVtczogZ2xvYmFsUmF0ZUxpbWl0XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBSYXRlTGltaXRlcjtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHQvKlxuXHQgKiBRdWV1ZSAtIGFuIG9iamVjdCB3aGljaCBoYW5kbGVzIHdoaWNoIGhhbmRsZXMgYSBxdWV1ZSBvZiBpdGVtcyB0byBiZSBzZW50IHRvIFJvbGxiYXIuXG5cdCAqICAgVGhpcyBvYmplY3QgaGFuZGxlcyByYXRlIGxpbWl0aW5nIHZpYSBhIHBhc3NlZCBpbiByYXRlIGxpbWl0ZXIsIHJldHJpZXMgYmFzZWQgb24gY29ubmVjdGlvblxuXHQgKiAgIGVycm9ycywgYW5kIGZpbHRlcmluZyBvZiBpdGVtcyBiYXNlZCBvbiBhIHNldCBvZiBjb25maWd1cmFibGUgcHJlZGljYXRlcy4gVGhlIGNvbW11bmljYXRpb24gdG9cblx0ICogICB0aGUgYmFja2VuZCBpcyBwZXJmb3JtZWQgdmlhIGEgZ2l2ZW4gQVBJIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHJhdGVMaW1pdGVyIC0gQW4gb2JqZWN0IHdoaWNoIGNvbmZvcm1zIHRvIHRoZSBpbnRlcmZhY2Vcblx0ICogICAgcmF0ZUxpbWl0ZXIuc2hvdWxkU2VuZChpdGVtKSAtPiBib29sXG5cdCAqIEBwYXJhbSBhcGkgLSBBbiBvYmplY3Qgd2hpY2ggY29uZm9ybXMgdG8gdGhlIGludGVyZmFjZVxuXHQgKiAgICBhcGkucG9zdEl0ZW0ocGF5bG9hZCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkpXG5cdCAqIEBwYXJhbSBvcHRpb25zIC0gc2VlIFF1ZXVlLnByb3RvdHlwZS5jb25maWd1cmVcblx0ICovXG5cdGZ1bmN0aW9uIFF1ZXVlKHJhdGVMaW1pdGVyLCBhcGksIG9wdGlvbnMpIHtcblx0ICB0aGlzLnJhdGVMaW1pdGVyID0gcmF0ZUxpbWl0ZXI7XG5cdCAgdGhpcy5hcGkgPSBhcGk7XG5cdCAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0ICB0aGlzLnByZWRpY2F0ZXMgPSBbXTtcblx0ICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IFtdO1xuXHQgIHRoaXMucmV0cnlRdWV1ZSA9IFtdO1xuXHQgIHRoaXMucmV0cnlIYW5kbGUgPSBudWxsO1xuXHQgIHRoaXMud2FpdENhbGxiYWNrID0gbnVsbDtcblx0fVxuXHRcblx0Lypcblx0ICogY29uZmlndXJlIC0gdXBkYXRlcyB0aGUgb3B0aW9ucyB0aGlzIHF1ZXVlIHVzZXNcblx0ICpcblx0ICogQHBhcmFtIG9wdGlvbnNcblx0ICovXG5cdFF1ZXVlLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgdGhpcy5hcGkgJiYgdGhpcy5hcGkuY29uZmlndXJlKG9wdGlvbnMpO1xuXHQgIHZhciBvbGRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHQgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRydWUsIHt9LCBvbGRPcHRpb25zLCBvcHRpb25zKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdCAqIGFkZFByZWRpY2F0ZSAtIGFkZHMgYSBwcmVkaWNhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBwcmVkaWNhdGVzIGZvciB0aGlzIHF1ZXVlXG5cdCAqIFxuXHQgKiBAcGFyYW0gcHJlZGljYXRlIC0gZnVuY3Rpb24oaXRlbSwgb3B0aW9ucykgLT4gKGJvb2x8e2VycjogRXJyb3J9KVxuXHQgKiAgUmV0dXJuaW5nIHRydWUgbWVhbnMgdGhhdCB0aGlzIHByZWRpY2F0ZSBwYXNzZXMgYW5kIHRoZSBpdGVtIGlzIG9rYXkgdG8gZ28gb24gdGhlIHF1ZXVlXG5cdCAqICBSZXR1cm5pbmcgZmFsc2UgbWVhbnMgZG8gbm90IGFkZCB0aGUgaXRlbSB0byB0aGUgcXVldWUsIGJ1dCBpdCBpcyBub3QgYW4gZXJyb3Jcblx0ICogIFJldHVybmluZyB7ZXJyOiBFcnJvcn0gbWVhbnMgZG8gbm90IGFkZCB0aGUgaXRlbSB0byB0aGUgcXVldWUsIGFuZCB0aGUgZ2l2ZW4gZXJyb3IgZXhwbGFpbnMgd2h5XG5cdCAqICBSZXR1cm5pbmcge2VycjogdW5kZWZpbmVkfSBpcyBlcXVpdmFsZW50IHRvIHJldHVybmluZyB0cnVlIGJ1dCBkb24ndCBkbyB0aGF0XG5cdCAqL1xuXHRRdWV1ZS5wcm90b3R5cGUuYWRkUHJlZGljYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG5cdCAgaWYgKF8uaXNGdW5jdGlvbihwcmVkaWNhdGUpKSB7XG5cdCAgICB0aGlzLnByZWRpY2F0ZXMucHVzaChwcmVkaWNhdGUpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdCAqIGFkZEl0ZW0gLSBTZW5kIGFuIGl0ZW0gdG8gdGhlIFJvbGxiYXIgQVBJIGlmIGFsbCBvZiB0aGUgcHJlZGljYXRlcyBhcmUgc2F0aXNmaWVkXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVtIC0gVGhlIHBheWxvYWQgdG8gc2VuZCB0byB0aGUgYmFja2VuZFxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbihlcnJvciwgcmVwc29uc2UpIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSVxuXHQgKiAgaW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzLCBvdGhlcndpc2UgcmVzcG9uc2Ugd2lsbCBiZSBudWxsIGFuZCBlcnJvciB3aWxsIGhhdmUgYSB2YWx1ZS4gSWYgYm90aFxuXHQgKiAgZXJyb3IgYW5kIHJlc3BvbnNlIGFyZSBudWxsIHRoZW4gdGhlIGl0ZW0gd2FzIHN0b3BwZWQgYnkgYSBwcmVkaWNhdGUgd2hpY2ggZGlkIG5vdCBjb25zaWRlciB0aGlzXG5cdCAqICB0byBiZSBhbiBlcnJvciBjb25kaXRpb24sIGJ1dCBub25ldGhlbGVzcyBkaWQgbm90IHNlbmQgdGhlIGl0ZW0gdG8gdGhlIEFQSS5cblx0ICovXG5cdFF1ZXVlLnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdCAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyByZXR1cm47IH07XG5cdCAgfVxuXHQgIHZhciBwcmVkaWNhdGVSZXN1bHQgPSB0aGlzLl9hcHBseVByZWRpY2F0ZXMoaXRlbSk7XG5cdCAgaWYgKHByZWRpY2F0ZVJlc3VsdC5zdG9wKSB7XG5cdCAgICBjYWxsYmFjayhwcmVkaWNhdGVSZXN1bHQuZXJyKTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKHRoaXMud2FpdENhbGxiYWNrKSB7XG5cdCAgICBjYWxsYmFjaygpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5wdXNoKGl0ZW0pO1xuXHQgIHRyeSB7XG5cdCAgICB0aGlzLl9tYWtlQXBpUmVxdWVzdChpdGVtLCBmdW5jdGlvbihlcnIsIHJlc3ApIHtcblx0ICAgICAgdGhpcy5fZGVxdWV1ZVBlbmRpbmdSZXF1ZXN0KGl0ZW0pO1xuXHQgICAgICBjYWxsYmFjayhlcnIsIHJlc3ApO1xuXHQgICAgfS5iaW5kKHRoaXMpKTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0aGlzLl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QoaXRlbSk7XG5cdCAgICBjYWxsYmFjayhlKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKlxuXHQgKiB3YWl0IC0gU3RvcCBhbnkgZnVydGhlciBlcnJvcnMgZnJvbSBiZWluZyBhZGRlZCB0byB0aGUgcXVldWUsIGFuZCBnZXQgY2FsbGVkIGJhY2sgd2hlbiBhbGwgaXRlbXNcblx0ICogICBjdXJyZW50bHkgcHJvY2Vzc2luZyBoYXZlIGZpbmlzaGVkIHNlbmRpbmcgdG8gdGhlIGJhY2tlbmQuXG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKCkgY2FsbGVkIHdoZW4gYWxsIHBlbmRpbmcgaXRlbXMgaGF2ZSBiZWVuIHNlbnRcblx0ICovXG5cdFF1ZXVlLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0ICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdGhpcy53YWl0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblx0ICBpZiAodGhpcy5wZW5kaW5nUmVxdWVzdHMubGVuZ3RoID09IDApIHtcblx0ICAgIHRoaXMud2FpdENhbGxiYWNrKCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyogX2FwcGx5UHJlZGljYXRlcyAtIFNlcXVlbnRpYWxseSBhcHBsaWVzIHRoZSBwcmVkaWNhdGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBxdWV1ZSB0byB0aGVcblx0ICogICBnaXZlbiBpdGVtIHdpdGggdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIG9wdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVtIC0gQW4gaXRlbSBpbiB0aGUgcXVldWVcblx0ICogQHJldHVybnMge3N0b3A6IGJvb2wsIGVycjogKEVycm9yfG51bGwpfSAtIHN0b3AgYmVpbmcgdHJ1ZSBtZWFucyBkbyBub3QgYWRkIGl0ZW0gdG8gdGhlIHF1ZXVlLFxuXHQgKiAgIHRoZSBlcnJvciB2YWx1ZSBzaG91bGQgYmUgcGFzc2VkIHVwIHRvIGEgY2FsbGJhayBpZiB3ZSBhcmUgc3RvcHBpbmcuXG5cdCAqL1xuXHRRdWV1ZS5wcm90b3R5cGUuX2FwcGx5UHJlZGljYXRlcyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICB2YXIgcCA9IG51bGw7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucHJlZGljYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgcCA9IHRoaXMucHJlZGljYXRlc1tpXShpdGVtLCB0aGlzLm9wdGlvbnMpO1xuXHQgICAgaWYgKCFwIHx8IHAuZXJyICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmV0dXJuIHtzdG9wOiB0cnVlLCBlcnI6IHAuZXJyfTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHtzdG9wOiBmYWxzZSwgZXJyOiBudWxsfTtcblx0fTtcblx0XG5cdC8qXG5cdCAqIF9tYWtlQXBpUmVxdWVzdCAtIFNlbmQgYW4gaXRlbSB0byBSb2xsYmFyLCBjYWxsYmFjayB3aGVuIGRvbmUsIGlmIHRoZXJlIGlzIGFuIGVycm9yIG1ha2UgYW5cblx0ICogICBlZmZvcnQgdG8gcmV0cnkgaWYgd2UgYXJlIGNvbmZpZ3VyZWQgdG8gZG8gc28uXG5cdCAqXG5cdCAqIEBwYXJhbSBpdGVtIC0gYW4gaXRlbSByZWFkeSB0byBzZW5kIHRvIHRoZSBiYWNrZW5kXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpXG5cdCAqL1xuXHRRdWV1ZS5wcm90b3R5cGUuX21ha2VBcGlSZXF1ZXN0ID0gZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcblx0ICB2YXIgcmF0ZUxpbWl0UmVzcG9uc2UgPSB0aGlzLnJhdGVMaW1pdGVyLnNob3VsZFNlbmQoaXRlbSk7XG5cdCAgaWYgKHJhdGVMaW1pdFJlc3BvbnNlLnNob3VsZFNlbmQpIHtcblx0ICAgIHRoaXMuYXBpLnBvc3RJdGVtKGl0ZW0sIGZ1bmN0aW9uKGVyciwgcmVzcCkge1xuXHQgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgdGhpcy5fbWF5YmVSZXRyeShlcnIsIGl0ZW0sIGNhbGxiYWNrKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3ApO1xuXHQgICAgICB9XG5cdCAgICB9LmJpbmQodGhpcykpO1xuXHQgIH0gZWxzZSBpZiAocmF0ZUxpbWl0UmVzcG9uc2UuZXJyb3IpIHtcblx0ICAgIGNhbGxiYWNrKHJhdGVMaW1pdFJlc3BvbnNlLmVycm9yKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5hcGkucG9zdEl0ZW0ocmF0ZUxpbWl0UmVzcG9uc2UucGF5bG9hZCwgY2FsbGJhY2spO1xuXHQgIH1cblx0fTtcblx0XG5cdC8vIFRoZXNlIGFyZSBlcnJvcnMgYmFzaWNhbGx5IG1lYW4gdGhlcmUgaXMgbm8gaW50ZXJuZXQgY29ubmVjdGlvblxuXHR2YXIgUkVUUklBQkxFX0VSUk9SUyA9IFsnRUNPTk5SRVNFVCcsICdFTk9URk9VTkQnLCAnRVNPQ0tFVFRJTUVET1VUJywgJ0VUSU1FRE9VVCcsICdFQ09OTlJFRlVTRUQnLCAnRUhPU1RVTlJFQUNIJywgJ0VQSVBFJywgJ0VBSV9BR0FJTiddO1xuXHRcblx0Lypcblx0ICogX21heWJlUmV0cnkgLSBHaXZlbiB0aGUgZXJyb3IgcmV0dXJuZWQgYnkgdGhlIEFQSSwgZGVjaWRlIGlmIHdlIHNob3VsZCByZXRyeSBvciBqdXN0IGNhbGxiYWNrXG5cdCAqICAgd2l0aCB0aGUgZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSBlcnIgLSBhbiBlcnJvciByZXR1cm5lZCBieSB0aGUgQVBJIHRyYW5zcG9ydFxuXHQgKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIHRoYXQgd2FzIHRyeWluZyB0byBiZSBzZW50IHdoZW4gdGhpcyBlcnJvciBvY2N1cmVkXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpXG5cdCAqL1xuXHRRdWV1ZS5wcm90b3R5cGUuX21heWJlUmV0cnkgPSBmdW5jdGlvbihlcnIsIGl0ZW0sIGNhbGxiYWNrKSB7XG5cdCAgdmFyIHNob3VsZFJldHJ5ID0gZmFsc2U7XG5cdCAgaWYgKHRoaXMub3B0aW9ucy5yZXRyeUludGVydmFsKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gUkVUUklBQkxFX0VSUk9SUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBpZiAoZXJyLmNvZGUgPT09IFJFVFJJQUJMRV9FUlJPUlNbaV0pIHtcblx0ICAgICAgICBzaG91bGRSZXRyeSA9IHRydWU7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKHNob3VsZFJldHJ5KSB7XG5cdCAgICB0aGlzLl9yZXRyeUFwaVJlcXVlc3QoaXRlbSwgY2FsbGJhY2spO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjYWxsYmFjayhlcnIpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qXG5cdCAqIF9yZXRyeUFwaVJlcXVlc3QgLSBBZGQgYW4gaXRlbSBhbmQgYSBjYWxsYmFjayB0byBhIHF1ZXVlIGFuZCBwb3NzaWJseSBzdGFydCBhIHRpbWVyIHRvIHByb2Nlc3Ncblx0ICogICB0aGF0IHF1ZXVlIGJhc2VkIG9uIHRoZSByZXRyeUludGVydmFsIGluIHRoZSBvcHRpb25zIGZvciB0aGlzIHF1ZXVlLlxuXHQgKlxuXHQgKiBAcGFyYW0gaXRlbSAtIGFuIGl0ZW0gdGhhdCBmYWlsZWQgdG8gc2VuZCBkdWUgdG8gYW4gZXJyb3Igd2UgZGVlbSByZXRyaWFibGVcblx0ICogQHBhcmFtIGNhbGxiYWNrIC0gZnVuY3Rpb24oZXJyLCByZXNwb25zZSlcblx0ICovXG5cdFF1ZXVlLnByb3RvdHlwZS5fcmV0cnlBcGlSZXF1ZXN0ID0gZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcblx0ICB0aGlzLnJldHJ5UXVldWUucHVzaCh7aXRlbTogaXRlbSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG5cdFxuXHQgIGlmICghdGhpcy5yZXRyeUhhbmRsZSkge1xuXHQgICAgdGhpcy5yZXRyeUhhbmRsZSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHQgICAgICB3aGlsZSAodGhpcy5yZXRyeVF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciByZXRyeU9iamVjdCA9IHRoaXMucmV0cnlRdWV1ZS5zaGlmdCgpO1xuXHQgICAgICAgIHRoaXMuX21ha2VBcGlSZXF1ZXN0KHJldHJ5T2JqZWN0Lml0ZW0sIHJldHJ5T2JqZWN0LmNhbGxiYWNrKTtcblx0ICAgICAgfVxuXHQgICAgfS5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMucmV0cnlJbnRlcnZhbCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0Lypcblx0ICogX2RlcXVldWVQZW5kaW5nUmVxdWVzdCAtIFJlbW92ZXMgdGhlIGl0ZW0gZnJvbSB0aGUgcGVuZGluZyByZXF1ZXN0IHF1ZXVlLCB0aGlzIHF1ZXVlIGlzIHVzZWQgdG9cblx0ICogICBlbmFibGUgdG8gZnVuY3Rpb25hbGl0eSBvZiBwcm92aWRpbmcgYSBjYWxsYmFjayB0aGF0IGNsaWVudHMgY2FuIHBhc3MgdG8gYHdhaXRgIHRvIGJlIG5vdGlmaWVkXG5cdCAqICAgd2hlbiB0aGUgcGVuZGluZyByZXF1ZXN0IHF1ZXVlIGhhcyBiZWVuIGVtcHRpZWQuIFRoaXMgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgQVBJIGZpbmlzaGVzXG5cdCAqICAgcHJvY2Vzc2luZyB0aGlzIGl0ZW0uIElmIGEgYHdhaXRgIGNhbGxiYWNrIGlzIGNvbmZpZ3VyZWQsIGl0IGlzIGNhbGxlZCBieSB0aGlzIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIHByZXZpb3VzbHkgYWRkZWQgdG8gdGhlIHBlbmRpbmcgcmVxdWVzdCBxdWV1ZVxuXHQgKi9cblx0UXVldWUucHJvdG90eXBlLl9kZXF1ZXVlUGVuZGluZ1JlcXVlc3QgPSBmdW5jdGlvbihpdGVtKSB7XG5cdCAgdmFyIHNob3VsZENhbGxXYWl0T25SZW1vdmUgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5sZW5ndGggPT0gMTtcblx0ICBmb3IgKHZhciBpID0gdGhpcy5wZW5kaW5nUmVxdWVzdHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuXHQgICAgaWYgKHRoaXMucGVuZGluZ1JlcXVlc3RzW2ldID09IGl0ZW0pIHtcblx0ICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuc3BsaWNlKGksIDEpO1xuXHQgICAgICBpZiAoc2hvdWxkQ2FsbFdhaXRPblJlbW92ZSAmJiBfLmlzRnVuY3Rpb24odGhpcy53YWl0Q2FsbGJhY2spKSB7XG5cdCAgICAgICAgdGhpcy53YWl0Q2FsbGJhY2soKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBSb2xsYmFySlNPTiA9IHt9O1xuXHR2YXIgX19pbml0Um9sbGJhckpTT04gPSBmYWxzZTtcblx0ZnVuY3Rpb24gc2V0dXBKU09OKCkge1xuXHQgIGlmIChfX2luaXRSb2xsYmFySlNPTikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBfX2luaXRSb2xsYmFySlNPTiA9IHRydWU7XG5cdFxuXHQgIGlmIChpc0RlZmluZWQoSlNPTikpIHtcblx0ICAgIGlmIChpc0Z1bmN0aW9uKEpTT04uc3RyaW5naWZ5KSkge1xuXHQgICAgICBSb2xsYmFySlNPTi5zdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0Z1bmN0aW9uKEpTT04ucGFyc2UpKSB7XG5cdCAgICAgIFJvbGxiYXJKU09OLnBhcnNlID0gSlNPTi5wYXJzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKCFpc0Z1bmN0aW9uKFJvbGxiYXJKU09OLnN0cmluZ2lmeSkgfHwgIWlzRnVuY3Rpb24oUm9sbGJhckpTT04ucGFyc2UpKSB7XG5cdCAgICB2YXIgc2V0dXBDdXN0b21KU09OID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICAgIHNldHVwQ3VzdG9tSlNPTihSb2xsYmFySlNPTik7XG5cdCAgfVxuXHR9XG5cdHNldHVwSlNPTigpO1xuXHRcblx0Lypcblx0ICogaXNUeXBlIC0gR2l2ZW4gYSBKYXZhc2NyaXB0IHZhbHVlIGFuZCBhIHN0cmluZywgcmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZVxuXHQgKiBnaXZlbiBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB4IC0gYW55IHZhbHVlXG5cdCAqIEBwYXJhbSB0IC0gYSBsb3dlcmNhc2Ugc3RyaW5nIGNvbnRhaW5pbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgdHlwZSBuYW1lczpcblx0ICogICAgLSB1bmRlZmluZWRcblx0ICogICAgLSBudWxsXG5cdCAqICAgIC0gZXJyb3Jcblx0ICogICAgLSBudW1iZXJcblx0ICogICAgLSBib29sZWFuXG5cdCAqICAgIC0gc3RyaW5nXG5cdCAqICAgIC0gc3ltYm9sXG5cdCAqICAgIC0gZnVuY3Rpb25cblx0ICogICAgLSBvYmplY3Rcblx0ICogICAgLSBhcnJheVxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIHggaXMgb2YgdHlwZSB0LCBvdGhlcndpc2UgZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzVHlwZSh4LCB0KSB7XG5cdCAgcmV0dXJuIHQgPT09IHR5cGVOYW1lKHgpO1xuXHR9XG5cdFxuXHQvKlxuXHQgKiB0eXBlTmFtZSAtIEdpdmVuIGEgSmF2YXNjcmlwdCB2YWx1ZSwgcmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IGFzIGEgc3RyaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiB0eXBlTmFtZSh4KSB7XG5cdCAgdmFyIG5hbWUgPSB0eXBlb2YgeDtcblx0ICBpZiAobmFtZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgIHJldHVybiBuYW1lO1xuXHQgIH1cblx0ICBpZiAoIXgpIHtcblx0ICAgIHJldHVybiAnbnVsbCc7XG5cdCAgfVxuXHQgIGlmICh4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiAnZXJyb3InO1xuXHQgIH1cblx0ICByZXR1cm4gKHt9KS50b1N0cmluZy5jYWxsKHgpLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0XG5cdC8qIGlzRnVuY3Rpb24gLSBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIHZhbHVlIGlzIGEgZnVuY3Rpb25cblx0ICpcblx0ICogQHBhcmFtIGYgLSBhbnkgdmFsdWVcblx0ICogQHJldHVybnMgdHJ1ZSBpZiBmIGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbihmKSB7XG5cdCAgcmV0dXJuIGlzVHlwZShmLCAnZnVuY3Rpb24nKTtcblx0fVxuXHRcblx0Lypcblx0ICogaXNEZWZpbmVkIC0gYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdW5kZWZpbmVkXG5cdCAqXG5cdCAqIEBwYXJhbSB1IC0gYW55IHZhbHVlXG5cdCAqIEByZXR1cm5zIHRydWUgaWYgdSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIHVuZGVmaW5lZFxuXHQgKi9cblx0ZnVuY3Rpb24gaXNEZWZpbmVkKHUpIHtcblx0ICByZXR1cm4gIWlzVHlwZSh1LCAndW5kZWZpbmVkJyk7XG5cdH1cblx0XG5cdC8qXG5cdCAqIGlzSXRlcmFibGUgLSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSB2YWx1ZSBjYW4gYmUgaXRlcmF0ZWQsIGVzc2VudGlhbGx5XG5cdCAqIHdoZXRoZXIgaXQgaXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0gaSAtIGFueSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGkgaXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5IGFzIGRldGVybWluZWQgYnkgYHR5cGVOYW1lYFxuXHQgKi9cblx0ZnVuY3Rpb24gaXNJdGVyYWJsZShpKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlTmFtZShpKTtcblx0ICByZXR1cm4gKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdhcnJheScpO1xuXHR9XG5cdFxuXHQvKlxuXHQgKiBpc0Vycm9yIC0gY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEgdmFsdWUgaXMgb2YgYW4gZXJyb3IgdHlwZVxuXHQgKlxuXHQgKiBAcGFyYW0gZSAtIGFueSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGUgaXMgYW4gZXJyb3Jcblx0ICovXG5cdGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuXHQgIHJldHVybiBpc1R5cGUoZSwgJ2Vycm9yJyk7XG5cdH1cblx0XG5cdC8qIHdyYXBSb2xsYmFyRnVuY3Rpb24gLSBwdXRzIGEgdHJ5L2NhdGNoIGFyb3VuZCBhIGZ1bmN0aW9uLCBsb2dzIGNhdWdodCBleGNlcHRpb25zIHRvIGNvbnNvbGUuZXJyb3Jcblx0ICpcblx0ICogQHBhcmFtIGYgLSBhIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSBjdHggLSBhbiBvcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdGhlIGZ1bmN0aW9uIHRvXG5cdCAqL1xuXHRmdW5jdGlvbiB3cmFwUm9sbGJhckZ1bmN0aW9uKGxvZ2dlciwgZiwgY3R4KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHNlbGYgPSBjdHggfHwgdGhpcztcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiBmLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIGxvZ2dlci5lcnJvcihlKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiB0cmF2ZXJzZShvYmosIGZ1bmMpIHtcblx0ICB2YXIgaztcblx0ICB2YXIgdjtcblx0ICB2YXIgaTtcblx0ICB2YXIgaXNPYmogPSBpc1R5cGUob2JqLCAnb2JqZWN0Jyk7XG5cdCAgdmFyIGlzQXJyYXkgPSBpc1R5cGUob2JqLCAnYXJyYXknKTtcblx0ICB2YXIga2V5cyA9IFtdO1xuXHRcblx0ICBpZiAoaXNPYmopIHtcblx0ICAgIGZvciAoayBpbiBvYmopIHtcblx0ICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG5cdCAgICAgICAga2V5cy5wdXNoKGspO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmIChpc0FycmF5KSB7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgIGtleXMucHVzaChpKTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICBrID0ga2V5c1tpXTtcblx0ICAgIHYgPSBvYmpba107XG5cdCAgICBvYmpba10gPSBmdW5jKGssIHYpO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcmVkYWN0KCkge1xuXHQgIHJldHVybiAnKioqKioqKionO1xuXHR9XG5cdFxuXHQvLyBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MDk0NzIvMTEzODE5MVxuXHRmdW5jdGlvbiB1dWlkNCgpIHtcblx0ICB2YXIgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHQgIHZhciB1dWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG5cdCAgICB2YXIgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcblx0ICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG5cdCAgICByZXR1cm4gKGMgPT09ICd4JyA/IHIgOiAociAmIDB4NyB8IDB4OCkpLnRvU3RyaW5nKDE2KTtcblx0ICB9KTtcblx0ICByZXR1cm4gdXVpZDtcblx0fVxuXHRcblx0dmFyIExFVkVMUyA9IHtcblx0ICBkZWJ1ZzogMCxcblx0ICBpbmZvOiAxLFxuXHQgIHdhcm5pbmc6IDIsXG5cdCAgZXJyb3I6IDMsXG5cdCAgY3JpdGljYWw6IDRcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHNhbml0aXplVXJsKHVybCkge1xuXHQgIHZhciBiYXNlVXJsUGFydHMgPSBwYXJzZVVyaSh1cmwpO1xuXHQgIC8vIHJlbW92ZSBhIHRyYWlsaW5nICMgaWYgdGhlcmUgaXMgbm8gYW5jaG9yXG5cdCAgaWYgKGJhc2VVcmxQYXJ0cy5hbmNob3IgPT09ICcnKSB7XG5cdCAgICBiYXNlVXJsUGFydHMuc291cmNlID0gYmFzZVVybFBhcnRzLnNvdXJjZS5yZXBsYWNlKCcjJywgJycpO1xuXHQgIH1cblx0XG5cdCAgdXJsID0gYmFzZVVybFBhcnRzLnNvdXJjZS5yZXBsYWNlKCc/JyArIGJhc2VVcmxQYXJ0cy5xdWVyeSwgJycpO1xuXHQgIHJldHVybiB1cmw7XG5cdH1cblx0XG5cdHZhciBwYXJzZVVyaU9wdGlvbnMgPSB7XG5cdCAgc3RyaWN0TW9kZTogZmFsc2UsXG5cdCAga2V5OiBbXG5cdCAgICAnc291cmNlJyxcblx0ICAgICdwcm90b2NvbCcsXG5cdCAgICAnYXV0aG9yaXR5Jyxcblx0ICAgICd1c2VySW5mbycsXG5cdCAgICAndXNlcicsXG5cdCAgICAncGFzc3dvcmQnLFxuXHQgICAgJ2hvc3QnLFxuXHQgICAgJ3BvcnQnLFxuXHQgICAgJ3JlbGF0aXZlJyxcblx0ICAgICdwYXRoJyxcblx0ICAgICdkaXJlY3RvcnknLFxuXHQgICAgJ2ZpbGUnLFxuXHQgICAgJ3F1ZXJ5Jyxcblx0ICAgICdhbmNob3InXG5cdCAgXSxcblx0ICBxOiB7XG5cdCAgICBuYW1lOiAncXVlcnlLZXknLFxuXHQgICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcblx0ICB9LFxuXHQgIHBhcnNlcjoge1xuXHQgICAgc3RyaWN0OiAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCgoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxuXHQgICAgbG9vc2U6IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL1xuXHQgIH1cblx0fTtcblx0XG5cdGZ1bmN0aW9uIHBhcnNlVXJpKHN0cikge1xuXHQgIGlmICghaXNUeXBlKHN0ciwgJ3N0cmluZycpKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2VpdmVkIGludmFsaWQgaW5wdXQnKTtcblx0ICB9XG5cdFxuXHQgIHZhciBvID0gcGFyc2VVcmlPcHRpb25zO1xuXHQgIHZhciBtID0gby5wYXJzZXJbby5zdHJpY3RNb2RlID8gJ3N0cmljdCcgOiAnbG9vc2UnXS5leGVjKHN0cik7XG5cdCAgdmFyIHVyaSA9IHt9O1xuXHQgIHZhciBpID0gby5rZXkubGVuZ3RoO1xuXHRcblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCAnJztcblx0ICB9XG5cdFxuXHQgIHVyaVtvLnEubmFtZV0gPSB7fTtcblx0ICB1cmlbby5rZXlbMTJdXS5yZXBsYWNlKG8ucS5wYXJzZXIsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG5cdCAgICBpZiAoJDEpIHtcblx0ICAgICAgdXJpW28ucS5uYW1lXVskMV0gPSAkMjtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgcmV0dXJuIHVyaTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkUGFyYW1zQW5kQWNjZXNzVG9rZW5Ub1BhdGgoYWNjZXNzVG9rZW4sIG9wdGlvbnMsIHBhcmFtcykge1xuXHQgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0ICBwYXJhbXMuYWNjZXNzX3Rva2VuID0gYWNjZXNzVG9rZW47XG5cdCAgdmFyIHBhcmFtc0FycmF5ID0gW107XG5cdCAgdmFyIGs7XG5cdCAgZm9yIChrIGluIHBhcmFtcykge1xuXHQgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIGspKSB7XG5cdCAgICAgIHBhcmFtc0FycmF5LnB1c2goW2ssIHBhcmFtc1trXV0uam9pbignPScpKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgdmFyIHF1ZXJ5ID0gJz8nICsgcGFyYW1zQXJyYXkuc29ydCgpLmpvaW4oJyYnKTtcblx0XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8ICcnO1xuXHQgIHZhciBxcyA9IG9wdGlvbnMucGF0aC5pbmRleE9mKCc/Jyk7XG5cdCAgdmFyIGggPSBvcHRpb25zLnBhdGguaW5kZXhPZignIycpO1xuXHQgIHZhciBwO1xuXHQgIGlmIChxcyAhPT0gLTEgJiYgKGggPT09IC0xIHx8IGggPiBxcykpIHtcblx0ICAgIHAgPSBvcHRpb25zLnBhdGg7XG5cdCAgICBvcHRpb25zLnBhdGggPSBwLnN1YnN0cmluZygwLHFzKSArIHF1ZXJ5ICsgJyYnICsgcC5zdWJzdHJpbmcocXMrMSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChoICE9PSAtMSkge1xuXHQgICAgICBwID0gb3B0aW9ucy5wYXRoO1xuXHQgICAgICBvcHRpb25zLnBhdGggPSBwLnN1YnN0cmluZygwLGgpICsgcXVlcnkgKyBwLnN1YnN0cmluZyhoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMucGF0aCArIHF1ZXJ5O1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gZm9ybWF0VXJsKHUsIHByb3RvY29sKSB7XG5cdCAgcHJvdG9jb2wgPSBwcm90b2NvbCB8fCB1LnByb3RvY29sO1xuXHQgIGlmICghcHJvdG9jb2wgJiYgdS5wb3J0KSB7XG5cdCAgICBpZiAodS5wb3J0ID09PSA4MCkge1xuXHQgICAgICBwcm90b2NvbCA9ICdodHRwOic7XG5cdCAgICB9IGVsc2UgaWYgKHUucG9ydCA9PT0gNDQzKSB7XG5cdCAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHByb3RvY29sID0gcHJvdG9jb2wgfHwgJ2h0dHBzOic7XG5cdFxuXHQgIGlmICghdS5ob3N0bmFtZSkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSBwcm90b2NvbCArICcvLycgKyB1Lmhvc3RuYW1lO1xuXHQgIGlmICh1LnBvcnQpIHtcblx0ICAgIHJlc3VsdCA9IHJlc3VsdCArICc6JyArIHUucG9ydDtcblx0ICB9XG5cdCAgaWYgKHUucGF0aCkge1xuXHQgICAgcmVzdWx0ID0gcmVzdWx0ICsgdS5wYXRoO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBiYWNrdXApIHtcblx0ICB2YXIgdmFsdWUsIGVycm9yO1xuXHQgIHRyeSB7XG5cdCAgICB2YWx1ZSA9IFJvbGxiYXJKU09OLnN0cmluZ2lmeShvYmopO1xuXHQgIH0gY2F0Y2ggKGpzb25FcnJvcikge1xuXHQgICAgaWYgKGJhY2t1cCAmJiBpc0Z1bmN0aW9uKGJhY2t1cCkpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB2YWx1ZSA9IGJhY2t1cChvYmopO1xuXHQgICAgICB9IGNhdGNoIChiYWNrdXBFcnJvcikge1xuXHQgICAgICAgIGVycm9yID0gYmFja3VwRXJyb3I7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVycm9yID0ganNvbkVycm9yO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4ge2Vycm9yOiBlcnJvciwgdmFsdWU6IHZhbHVlfTtcblx0fVxuXHRcblx0ZnVuY3Rpb24ganNvblBhcnNlKHMpIHtcblx0ICB2YXIgdmFsdWUsIGVycm9yO1xuXHQgIHRyeSB7XG5cdCAgICB2YWx1ZSA9IFJvbGxiYXJKU09OLnBhcnNlKHMpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIGVycm9yID0gZTtcblx0ICB9XG5cdCAgcmV0dXJuIHtlcnJvcjogZXJyb3IsIHZhbHVlOiB2YWx1ZX07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG1ha2VVbmhhbmRsZWRTdGFja0luZm8oXG5cdCAgbWVzc2FnZSxcblx0ICB1cmwsXG5cdCAgbGluZW5vLFxuXHQgIGNvbG5vLFxuXHQgIGVycm9yLFxuXHQgIG1vZGUsXG5cdCAgYmFja3VwTWVzc2FnZSxcblx0ICBlcnJvclBhcnNlclxuXHQpIHtcblx0ICB2YXIgbG9jYXRpb24gPSB7XG5cdCAgICB1cmw6IHVybCB8fCAnJyxcblx0ICAgIGxpbmU6IGxpbmVubyxcblx0ICAgIGNvbHVtbjogY29sbm9cblx0ICB9O1xuXHQgIGxvY2F0aW9uLmZ1bmMgPSBlcnJvclBhcnNlci5ndWVzc0Z1bmN0aW9uTmFtZShsb2NhdGlvbi51cmwsIGxvY2F0aW9uLmxpbmUpO1xuXHQgIGxvY2F0aW9uLmNvbnRleHQgPSBlcnJvclBhcnNlci5nYXRoZXJDb250ZXh0KGxvY2F0aW9uLnVybCwgbG9jYXRpb24ubGluZSk7XG5cdCAgdmFyIGhyZWYgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5sb2NhdGlvbiAmJiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHQgIHZhciB1c2VyYWdlbnQgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0ICByZXR1cm4ge1xuXHQgICAgJ21vZGUnOiBtb2RlLFxuXHQgICAgJ21lc3NhZ2UnOiBlcnJvciA/IFN0cmluZyhlcnJvcikgOiAobWVzc2FnZSB8fCBiYWNrdXBNZXNzYWdlKSxcblx0ICAgICd1cmwnOiBocmVmLFxuXHQgICAgJ3N0YWNrJzogW2xvY2F0aW9uXSxcblx0ICAgICd1c2VyYWdlbnQnOiB1c2VyYWdlbnRcblx0ICB9O1xuXHR9XG5cdFxuXHQvKlxuXHQgKiBnZXQgLSBnaXZlbiBhbiBvYmovYXJyYXkgYW5kIGEga2V5cGF0aCwgcmV0dXJuIHRoZSB2YWx1ZSBhdCB0aGF0IGtleXBhdGggb3Jcblx0ICogICAgICAgdW5kZWZpbmVkIGlmIG5vdCBwb3NzaWJsZS5cblx0ICpcblx0ICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvciBhcnJheVxuXHQgKiBAcGFyYW0gcGF0aCAtIGEgc3RyaW5nIG9mIGtleXMgc2VwYXJhdGVkIGJ5ICcuJyBzdWNoIGFzICdwbHVnaW4uanF1ZXJ5LjAubWVzc2FnZSdcblx0ICogICAgd2hpY2ggd291bGQgY29ycmVzcG9uZCB0byA0MiBpbiBge3BsdWdpbjoge2pxdWVyeTogW3ttZXNzYWdlOiA0Mn1dfX1gXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG5cdCAgaWYgKCFvYmopIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xuXHQgIHZhciByZXN1bHQgPSBvYmo7XG5cdCAgdHJ5IHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICAgIHJlc3VsdCA9IHJlc3VsdFtrZXlzW2ldXTtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNldChvYmosIHBhdGgsIHZhbHVlKSB7XG5cdCAgaWYgKCFvYmopIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG5cdCAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuXHQgIGlmIChsZW4gPCAxKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmIChsZW4gPT09IDEpIHtcblx0ICAgIG9ialtrZXlzWzBdXSA9IHZhbHVlO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB0cnkge1xuXHQgICAgdmFyIHRlbXAgPSBvYmpba2V5c1swXV0gfHwge307XG5cdCAgICB2YXIgcmVwbGFjZW1lbnQgPSB0ZW1wO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW4tMTsgaSsrKSB7XG5cdCAgICAgIHRlbXBba2V5c1tpXV0gPSB0ZW1wW2tleXNbaV1dIHx8IHt9O1xuXHQgICAgICB0ZW1wID0gdGVtcFtrZXlzW2ldXTtcblx0ICAgIH1cblx0ICAgIHRlbXBba2V5c1tsZW4tMV1dID0gdmFsdWU7XG5cdCAgICBvYmpba2V5c1swXV0gPSByZXBsYWNlbWVudDtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBzY3J1YihkYXRhLCBzY3J1YkZpZWxkcykge1xuXHQgIHNjcnViRmllbGRzID0gc2NydWJGaWVsZHMgfHwgW107XG5cdCAgdmFyIHBhcmFtUmVzID0gX2dldFNjcnViRmllbGRSZWdleHMoc2NydWJGaWVsZHMpO1xuXHQgIHZhciBxdWVyeVJlcyA9IF9nZXRTY3J1YlF1ZXJ5UGFyYW1SZWdleHMoc2NydWJGaWVsZHMpO1xuXHRcblx0ICBmdW5jdGlvbiByZWRhY3RRdWVyeVBhcmFtKGR1bW15MCwgcGFyYW1QYXJ0LCBkdW1teTEsIGR1bW15MiwgZHVtbXkzLCB2YWxQYXJ0KSB7XG5cdCAgICByZXR1cm4gcGFyYW1QYXJ0ICsgcmVkYWN0KHZhbFBhcnQpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gcGFyYW1TY3J1YmJlcih2KSB7XG5cdCAgICB2YXIgaTtcblx0ICAgIGlmIChpc1R5cGUodiwgJ3N0cmluZycpKSB7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBxdWVyeVJlcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIHYgPSB2LnJlcGxhY2UocXVlcnlSZXNbaV0sIHJlZGFjdFF1ZXJ5UGFyYW0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdjtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIHZhbFNjcnViYmVyKGssIHYpIHtcblx0ICAgIHZhciBpO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtUmVzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgIGlmIChwYXJhbVJlc1tpXS50ZXN0KGspKSB7XG5cdCAgICAgICAgdiA9IHJlZGFjdCh2KTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHY7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBzY3J1YmJlcihrLCB2KSB7XG5cdCAgICB2YXIgdG1wViA9IHZhbFNjcnViYmVyKGssIHYpO1xuXHQgICAgaWYgKHRtcFYgPT09IHYpIHtcblx0ICAgICAgaWYgKGlzVHlwZSh2LCAnb2JqZWN0JykgfHwgaXNUeXBlKHYsICdhcnJheScpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHYsIHNjcnViYmVyKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcGFyYW1TY3J1YmJlcih0bXBWKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0bXBWO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgdHJhdmVyc2UoZGF0YSwgc2NydWJiZXIpO1xuXHQgIHJldHVybiBkYXRhO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfZ2V0U2NydWJGaWVsZFJlZ2V4cyhzY3J1YkZpZWxkcykge1xuXHQgIHZhciByZXQgPSBbXTtcblx0ICB2YXIgcGF0O1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NydWJGaWVsZHMubGVuZ3RoOyArK2kpIHtcblx0ICAgIHBhdCA9ICdcXFxcWz8oJTVbYkJdKT8nICsgc2NydWJGaWVsZHNbaV0gKyAnXFxcXFs/KCU1W2JCXSk/XFxcXF0/KCU1W2REXSk/Jztcblx0ICAgIHJldC5wdXNoKG5ldyBSZWdFeHAocGF0LCAnaScpKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJldDtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9nZXRTY3J1YlF1ZXJ5UGFyYW1SZWdleHMoc2NydWJGaWVsZHMpIHtcblx0ICB2YXIgcmV0ID0gW107XG5cdCAgdmFyIHBhdDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcnViRmllbGRzLmxlbmd0aDsgKytpKSB7XG5cdCAgICBwYXQgPSAnXFxcXFs/KCU1W2JCXSk/JyArIHNjcnViRmllbGRzW2ldICsgJ1xcXFxbPyglNVtiQl0pP1xcXFxdPyglNVtkRF0pPyc7XG5cdCAgICByZXQucHVzaChuZXcgUmVnRXhwKCcoJyArIHBhdCArICc9KShbXiZcXFxcbl0rKScsICdpZ20nKSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXQ7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGlzVHlwZTogaXNUeXBlLFxuXHQgIHR5cGVOYW1lOiB0eXBlTmFtZSxcblx0ICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuXHQgIGlzSXRlcmFibGU6IGlzSXRlcmFibGUsXG5cdCAgaXNFcnJvcjogaXNFcnJvcixcblx0ICBleHRlbmQ6IGV4dGVuZCxcblx0ICB0cmF2ZXJzZTogdHJhdmVyc2UsXG5cdCAgcmVkYWN0OiByZWRhY3QsXG5cdCAgdXVpZDQ6IHV1aWQ0LFxuXHQgIHdyYXBSb2xsYmFyRnVuY3Rpb246IHdyYXBSb2xsYmFyRnVuY3Rpb24sXG5cdCAgTEVWRUxTOiBMRVZFTFMsXG5cdCAgc2FuaXRpemVVcmw6IHNhbml0aXplVXJsLFxuXHQgIGFkZFBhcmFtc0FuZEFjY2Vzc1Rva2VuVG9QYXRoOiBhZGRQYXJhbXNBbmRBY2Nlc3NUb2tlblRvUGF0aCxcblx0ICBmb3JtYXRVcmw6IGZvcm1hdFVybCxcblx0ICBzdHJpbmdpZnk6IHN0cmluZ2lmeSxcblx0ICBqc29uUGFyc2U6IGpzb25QYXJzZSxcblx0ICBtYWtlVW5oYW5kbGVkU3RhY2tJbmZvOiBtYWtlVW5oYW5kbGVkU3RhY2tJbmZvLFxuXHQgIGdldDogZ2V0LFxuXHQgIHNldDogc2V0LFxuXHQgIHNjcnViOiBzY3J1YlxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcblx0dmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuXHRcdGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cdFxuXHR2YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG5cdFx0aWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XG5cdFx0dmFyIGhhc093bkNvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcblx0XHR2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlICYmIGhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG5cdFx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRcdGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc093bkNvbnN0cnVjdG9yICYmICFoYXNJc1Byb3RvdHlwZU9mKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0XHR2YXIga2V5O1xuXHRcdGZvciAoa2V5IGluIG9iaikgey8qKi99XG5cdFxuXHRcdHJldHVybiB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0sXG5cdFx0XHRpID0gMSxcblx0XHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRkZWVwID0gZmFsc2U7XG5cdFxuXHRcdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0XHRpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRkZWVwID0gdGFyZ2V0O1xuXHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdFx0aSA9IDI7XG5cdFx0fSBlbHNlIGlmICgodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykgfHwgdGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdHRhcmdldCA9IHt9O1xuXHRcdH1cblx0XG5cdFx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdGlmIChvcHRpb25zICE9IG51bGwpIHtcblx0XHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFtuYW1lXTtcblx0XHRcdFx0XHRjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblx0XG5cdFx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRcdGlmICh0YXJnZXQgIT09IGNvcHkpIHtcblx0XHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBpc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGNvcHlJc0FycmF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gY29weTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblx0XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gIGpzb24zLmpzXG5cdC8vICAyMDE3LTAyLTIxXG5cdC8vICBQdWJsaWMgRG9tYWluLlxuXHQvLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuXHQvLyAgU2VlIGh0dHA6Ly93d3cuSlNPTi5vcmcvanMuaHRtbFxuXHQvLyAgVGhpcyBjb2RlIHNob3VsZCBiZSBtaW5pZmllZCBiZWZvcmUgZGVwbG95bWVudC5cblx0Ly8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblx0XG5cdC8vICBVU0UgWU9VUiBPV04gQ09QWS4gSVQgSVMgRVhUUkVNRUxZIFVOV0lTRSBUTyBMT0FEIENPREUgRlJPTSBTRVJWRVJTIFlPVSBET1xuXHQvLyAgTk9UIENPTlRST0wuXG5cdFxuXHQvLyAgVGhpcyBmaWxlIGNyZWF0ZXMgYSBnbG9iYWwgSlNPTiBvYmplY3QgY29udGFpbmluZyB0d28gbWV0aG9kczogc3RyaW5naWZ5XG5cdC8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cblx0Ly8gIElmIGEgcHJvamVjdCBtaWdodCBydW4gb24gSUU4IG9yIGVhcmxpZXIsIHRoZW4gdGhpcyBmaWxlIHNob3VsZCBiZSBpbmNsdWRlZC5cblx0Ly8gIFRoaXMgZmlsZSBkb2VzIG5vdGhpbmcgb24gRVM1IHN5c3RlbXMuXG5cdFxuXHQvLyAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG5cdC8vICAgICAgICAgIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cblx0Ly8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG5cdC8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG5cdC8vICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG5cdC8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cblx0Ly8gICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgYmUgcGFja2VkIHdpdGhvdXQgZXh0cmEgd2hpdGVzcGFjZS4gSWYgaXQgaXMgYSBudW1iZXIsXG5cdC8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuXHQvLyAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgXCJcXHRcIiBvciBcIiZuYnNwO1wiKSxcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cblx0Ly8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG5cdC8vICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG5cdC8vICAgICAgICAgIG1ldGhvZCwgaXRzIHRvSlNPTiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuXHQvLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcblx0Ly8gICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuXHQvLyAgICAgICAgICBvciB1bmRlZmluZWQgaWYgbm90aGluZyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIHRvSlNPTiBtZXRob2Rcblx0Ly8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG5cdC8vICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZS5cblx0XG5cdC8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblx0XG5cdC8vICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdC8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG5cdC8vICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG5cdC8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobiA8IDEwKVxuXHQvLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cblx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgIDogbjtcblx0Ly8gICAgICAgICAgICAgICAgICB9XG5cdC8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuXHQvLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyBcIlRcIiArXG5cdC8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuXHQvLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArIFwiOlwiICtcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyBcIlpcIjtcblx0Ly8gICAgICAgICAgICAgIH07XG5cdFxuXHQvLyAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcblx0Ly8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG5cdC8vICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG5cdC8vICAgICAgICAgIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuXHQvLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXHRcblx0Ly8gICAgICAgICAgSWYgdGhlIHJlcGxhY2VyIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB0aGVuIGl0IHdpbGwgYmVcblx0Ly8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuXHQvLyAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuXHQvLyAgICAgICAgICBzdHJpbmdpZmllZC5cblx0XG5cdC8vICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuXHQvLyAgICAgICAgICBmdW5jdGlvbnMsIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuIFN1Y2ggdmFsdWVzIGluIG9iamVjdHMgd2lsbCBiZVxuXHQvLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcblx0Ly8gICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG5cdFxuXHQvLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXHRcblx0Ly8gICAgICAgICAgVGhlIG9wdGlvbmFsIHNwYWNlIHBhcmFtZXRlciBwcm9kdWNlcyBhIHN0cmluZ2lmaWNhdGlvbiBvZiB0aGVcblx0Ly8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuXHQvLyAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblx0XG5cdC8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcblx0Ly8gICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cblx0Ly8gICAgICAgICAgdGhlIGluZGVudGF0aW9uIHdpbGwgYmUgdGhhdCBtYW55IHNwYWNlcy5cblx0XG5cdC8vICAgICAgICAgIEV4YW1wbGU6XG5cdFxuXHQvLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuXHQvLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXHRcblx0Ly8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcblx0Ly8gICAgICAgICAgLy8gdGV4dCBpcyAnW1xcblxcdFwiZVwiLFxcblxcdHtcXG5cXHRcXHRcInBsdXJpYnVzXCI6IFwidW51bVwiXFxuXFx0fVxcbl0nXG5cdFxuXHQvLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQvLyAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGVcblx0Ly8gICAgICAgICAgICAgICAgICA/IFwiRGF0ZShcIiArIHRoaXNba2V5XSArIFwiKVwiXG5cdC8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcblx0Ly8gICAgICAgICAgfSk7XG5cdC8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcIkRhdGUoLS0tY3VycmVudCB0aW1lLS0tKVwiXSdcblx0XG5cdC8vICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuXHQvLyAgICAgICAgICBUaGlzIG1ldGhvZCBwYXJzZXMgYSBKU09OIHRleHQgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb3IgYXJyYXkuXG5cdC8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblx0Ly8gICAgICAgICAgVGhpcyBoYXMgYmVlbiBtb2RpZmllZCB0byB1c2UgSlNPTi1qcy9qc29uX3BhcnNlX3N0YXRlLmpzIGFzIHRoZVxuXHQvLyAgICAgICAgICBwYXJzZXIgaW5zdGVhZCBvZiB0aGUgb25lIGJ1aWx0IGFyb3VuZCBldmFsIGZvdW5kIGluIEpTT04tanMvanNvbjIuanNcblx0XG5cdC8vICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcblx0Ly8gICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG5cdC8vICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG5cdC8vICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cblx0Ly8gICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cdFxuXHQvLyAgICAgICAgICBFeGFtcGxlOlxuXHRcblx0Ly8gICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcblx0Ly8gICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblx0XG5cdC8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0Ly8gICAgICAgICAgICAgIHZhciBhO1xuXHQvLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuXHQvLyAgICAgICAgICAgICAgICAgIGEgPVxuXHQvLyAgIC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG5cdC8vICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKCthWzFdLCArYVsyXSAtIDEsICthWzNdLCArYVs0XSxcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuXHQvLyAgICAgICAgICAgICAgICAgIH1cblx0Ly8gICAgICAgICAgICAgIH1cblx0Ly8gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0Ly8gICAgICAgICAgfSk7XG5cdFxuXHQvLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0Ly8gICAgICAgICAgICAgIHZhciBkO1xuXHQvLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHQvLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gXCJEYXRlKFwiICYmXG5cdC8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIpXCIpIHtcblx0Ly8gICAgICAgICAgICAgICAgICBkID0gbmV3IERhdGUodmFsdWUuc2xpY2UoNSwgLTEpKTtcblx0Ly8gICAgICAgICAgICAgICAgICBpZiAoZCkge1xuXHQvLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcblx0Ly8gICAgICAgICAgICAgICAgICB9XG5cdC8vICAgICAgICAgICAgICB9XG5cdC8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdC8vICAgICAgICAgIH0pO1xuXHRcblx0Ly8gIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG5cdC8vICByZWRpc3RyaWJ1dGUuXG5cdFxuXHQvKmpzbGludFxuXHQgIGZvciwgdGhpc1xuXHQgICovXG5cdFxuXHQvKnByb3BlcnR5XG5cdCAgSlNPTiwgYXBwbHksIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3Vycyxcblx0ICBnZXRVVENNaW51dGVzLCBnZXRVVENNb250aCwgZ2V0VVRDU2Vjb25kcywgaGFzT3duUHJvcGVydHksIGpvaW4sXG5cdCAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG5cdCAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuXHQgICovXG5cdFxuXHR2YXIgc2V0dXBDdXN0b21KU09OID0gZnVuY3Rpb24oSlNPTikge1xuXHRcblx0ICB2YXIgcnhfb25lID0gL15bXFxdLDp7fVxcc10qJC87XG5cdCAgdmFyIHJ4X3R3byA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG5cdCAgdmFyIHJ4X3RocmVlID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xuXHQgIHZhciByeF9mb3VyID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xuXHQgIHZhciByeF9lc2NhcGFibGUgPSAvW1xcXFxcIlxcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuXHQgIHZhciByeF9kYW5nZXJvdXMgPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcblx0XG5cdCAgZnVuY3Rpb24gZihuKSB7XG5cdCAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuXHQgICAgcmV0dXJuIG4gPCAxMFxuXHQgICAgICA/IFwiMFwiICsgblxuXHQgICAgICA6IG47XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiB0aGlzX3ZhbHVlKCkge1xuXHQgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHQgIH1cblx0XG5cdCAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXHRcblx0ICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSlcblx0ICAgICAgICA/IHRoaXMuZ2V0VVRDRnVsbFllYXIoKSArIFwiLVwiICtcblx0ICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgK1xuXHQgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuXHQgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSArIFwiOlwiICtcblx0ICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICtcblx0ICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG5cdCAgICAgICAgOiBudWxsO1xuXHQgICAgfTtcblx0XG5cdCAgICBCb29sZWFuLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuXHQgICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuXHQgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuXHQgIH1cblx0XG5cdCAgdmFyIGdhcDtcblx0ICB2YXIgaW5kZW50O1xuXHQgIHZhciBtZXRhO1xuXHQgIHZhciByZXA7XG5cdFxuXHRcblx0ICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblx0XG5cdCAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG5cdCAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuXHQgICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG5cdCAgICAvLyBzZXF1ZW5jZXMuXG5cdFxuXHQgICAgcnhfZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG5cdCAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuXHQgICAgICA/IFwiXFxcIlwiICsgc3RyaW5nLnJlcGxhY2UocnhfZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuXHQgICAgICAgIHZhciBjID0gbWV0YVthXTtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCJcblx0ICAgICAgICAgID8gY1xuXHQgICAgICAgICAgOiBcIlxcXFx1XCIgKyAoXCIwMDAwXCIgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG5cdCAgICAgIH0pICsgXCJcXFwiXCJcblx0ICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcblx0ICB9XG5cdFxuXHRcblx0ICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblx0XG5cdCAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cdFxuXHQgICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG5cdCAgICB2YXIgazsgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG5cdCAgICB2YXIgdjsgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cblx0ICAgIHZhciBsZW5ndGg7XG5cdCAgICB2YXIgbWluZCA9IGdhcDtcblx0ICAgIHZhciBwYXJ0aWFsO1xuXHQgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cdFxuXHQgICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cdFxuXHQgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHQgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuXHQgICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cdFxuXHQgICAgaWYgKHR5cGVvZiByZXAgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXHRcblx0ICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG5cdCAgICAgIGNhc2UgXCJzdHJpbmdcIjpcblx0ICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXHRcblx0ICAgICAgY2FzZSBcIm51bWJlclwiOlxuXHRcblx0ICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblx0XG5cdCAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuXHQgICAgICAgICAgPyBTdHJpbmcodmFsdWUpXG5cdCAgICAgICAgICA6IFwibnVsbFwiO1xuXHRcblx0ICAgICAgY2FzZSBcImJvb2xlYW5cIjpcblx0ICAgICAgY2FzZSBcIm51bGxcIjpcblx0XG5cdCAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuXHQgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgXCJudWxsXCIuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cblx0ICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXHRcblx0ICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblx0XG5cdCAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgXCJvYmplY3RcIiwgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuXHQgICAgICAgIC8vIG51bGwuXG5cdFxuXHQgICAgICBjYXNlIFwib2JqZWN0XCI6XG5cdFxuXHQgICAgICAgIC8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLFxuXHQgICAgICAgIC8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXHRcblx0ICAgICAgICBpZiAoIXZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cdFxuXHQgICAgICAgIGdhcCArPSBpbmRlbnQ7XG5cdCAgICAgICAgcGFydGlhbCA9IFtdO1xuXHRcblx0ICAgICAgICAvLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cdFxuXHQgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFxuXHQgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuXHQgICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblx0XG5cdCAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgXCJudWxsXCI7XG5cdCAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cblx0ICAgICAgICAgIC8vIGJyYWNrZXRzLlxuXHRcblx0ICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMFxuXHQgICAgICAgICAgICA/IFwiW11cIlxuXHQgICAgICAgICAgICA6IGdhcFxuXHQgICAgICAgICAgICA/IFwiW1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJdXCJcblx0ICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcblx0ICAgICAgICAgIGdhcCA9IG1pbmQ7XG5cdCAgICAgICAgICByZXR1cm4gdjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzdHJpbmdpZmllZC5cblx0XG5cdCAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuXHQgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgayA9IHJlcFtpXTtcblx0ICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcblx0ICAgICAgICAgICAgICBpZiAodikge1xuXHQgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuXHQgICAgICAgICAgICAgICAgICAgICAgZ2FwXG5cdCAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cdFxuXHQgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG5cdCAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgaWYgKHYpIHtcblx0ICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcblx0ICAgICAgICAgICAgICAgICAgICAgIGdhcFxuXHQgICAgICAgICAgICAgICAgICAgICAgPyBcIjogXCJcblx0ICAgICAgICAgICAgICAgICAgICAgIDogXCI6XCJcblx0ICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcblx0ICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblx0XG5cdCAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG5cdCAgICAgICAgICA/IFwie31cIlxuXHQgICAgICAgICAgOiBnYXBcblx0ICAgICAgICAgID8gXCJ7XFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIn1cIlxuXHQgICAgICAgICAgOiBcIntcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIn1cIjtcblx0ICAgICAgICBnYXAgPSBtaW5kO1xuXHQgICAgICAgIHJldHVybiB2O1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cdFxuXHQgIGlmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcblx0ICAgICAgXCJcXGJcIjogXCJcXFxcYlwiLFxuXHQgICAgICBcIlxcdFwiOiBcIlxcXFx0XCIsXG5cdCAgICAgIFwiXFxuXCI6IFwiXFxcXG5cIixcblx0ICAgICAgXCJcXGZcIjogXCJcXFxcZlwiLFxuXHQgICAgICBcIlxcclwiOiBcIlxcXFxyXCIsXG5cdCAgICAgIFwiXFxcIlwiOiBcIlxcXFxcXFwiXCIsXG5cdCAgICAgIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCJcblx0ICAgIH07XG5cdCAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cdFxuXHQgICAgICAvLyBUaGUgc3RyaW5naWZ5IG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCByZXBsYWNlciwgYW5kIGFuIG9wdGlvbmFsXG5cdCAgICAgIC8vIHNwYWNlIHBhcmFtZXRlciwgYW5kIHJldHVybnMgYSBKU09OIHRleHQuIFRoZSByZXBsYWNlciBjYW4gYmUgYSBmdW5jdGlvblxuXHQgICAgICAvLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuXHQgICAgICAvLyBBIGRlZmF1bHQgcmVwbGFjZXIgbWV0aG9kIGNhbiBiZSBwcm92aWRlZC4gVXNlIG9mIHRoZSBzcGFjZSBwYXJhbWV0ZXIgY2FuXG5cdCAgICAgIC8vIHByb2R1Y2UgdGV4dCB0aGF0IGlzIG1vcmUgZWFzaWx5IHJlYWRhYmxlLlxuXHRcblx0ICAgICAgdmFyIGk7XG5cdCAgICAgIGdhcCA9IFwiXCI7XG5cdCAgICAgIGluZGVudCA9IFwiXCI7XG5cdFxuXHQgICAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG5cdCAgICAgIC8vIG1hbnkgc3BhY2VzLlxuXHRcblx0ICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG5cdCAgICAgICAgICBpbmRlbnQgKz0gXCIgXCI7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cdFxuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGluZGVudCA9IHNwYWNlO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG5cdCAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cdFxuXHQgICAgICByZXAgPSByZXBsYWNlcjtcblx0ICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gXCJmdW5jdGlvblwiICYmXG5cdCAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG5cdCAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gXCJudW1iZXJcIikpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OLnN0cmluZ2lmeVwiKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiBcIlwiLlxuXHQgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXHRcblx0ICAgICAgcmV0dXJuIHN0cihcIlwiLCB7XCJcIjogdmFsdWV9KTtcblx0ICAgIH07XG5cdCAgfVxuXHRcblx0XG5cdCAgLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblx0XG5cdCAgaWYgKHR5cGVvZiBKU09OLnBhcnNlICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgIEpTT04ucGFyc2UgPSAoZnVuY3Rpb24gKCkge1xuXHRcblx0ICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgSlNPTiBwYXJzZSBmdW5jdGlvbiB0aGF0IHVzZXMgYSBzdGF0ZSBtYWNoaW5lIHJhdGhlclxuXHQgICAgICAvLyB0aGFuIHRoZSBkYW5nZXJvdXMgZXZhbCBmdW5jdGlvbiB0byBwYXJzZSBhIEpTT04gdGV4dC5cblx0XG5cdCAgICAgIHZhciBzdGF0ZTsgICAgICAvLyBUaGUgc3RhdGUgb2YgdGhlIHBhcnNlciwgb25lIG9mXG5cdCAgICAgIC8vICdnbycgICAgICAgICBUaGUgc3RhcnRpbmcgc3RhdGVcblx0ICAgICAgLy8gJ29rJyAgICAgICAgIFRoZSBmaW5hbCwgYWNjZXB0aW5nIHN0YXRlXG5cdCAgICAgIC8vICdmaXJzdG9rZXknICBSZWFkeSBmb3IgdGhlIGZpcnN0IGtleSBvZiB0aGUgb2JqZWN0IG9yXG5cdCAgICAgIC8vICAgICAgICAgICAgICB0aGUgY2xvc2luZyBvZiBhbiBlbXB0eSBvYmplY3Rcblx0ICAgICAgLy8gJ29rZXknICAgICAgIFJlYWR5IGZvciB0aGUgbmV4dCBrZXkgb2YgdGhlIG9iamVjdFxuXHQgICAgICAvLyAnY29sb24nICAgICAgUmVhZHkgZm9yIHRoZSBjb2xvblxuXHQgICAgICAvLyAnb3ZhbHVlJyAgICAgUmVhZHkgZm9yIHRoZSB2YWx1ZSBoYWxmIG9mIGEga2V5L3ZhbHVlIHBhaXJcblx0ICAgICAgLy8gJ29jb21tYScgICAgIFJlYWR5IGZvciBhIGNvbW1hIG9yIGNsb3NpbmcgfVxuXHQgICAgICAvLyAnZmlyc3RhdmFsdWUnIFJlYWR5IGZvciB0aGUgZmlyc3QgdmFsdWUgb2YgYW4gYXJyYXkgb3Jcblx0ICAgICAgLy8gICAgICAgICAgICAgIGFuIGVtcHR5IGFycmF5XG5cdCAgICAgIC8vICdhdmFsdWUnICAgICBSZWFkeSBmb3IgdGhlIG5leHQgdmFsdWUgb2YgYW4gYXJyYXlcblx0ICAgICAgLy8gJ2Fjb21tYScgICAgIFJlYWR5IGZvciBhIGNvbW1hIG9yIGNsb3NpbmcgXVxuXHQgICAgICB2YXIgc3RhY2s7ICAgICAgLy8gVGhlIHN0YWNrLCBmb3IgY29udHJvbGxpbmcgbmVzdGluZy5cblx0ICAgICAgdmFyIGNvbnRhaW5lcjsgIC8vIFRoZSBjdXJyZW50IGNvbnRhaW5lciBvYmplY3Qgb3IgYXJyYXlcblx0ICAgICAgdmFyIGtleTsgICAgICAgIC8vIFRoZSBjdXJyZW50IGtleVxuXHQgICAgICB2YXIgdmFsdWU7ICAgICAgLy8gVGhlIGN1cnJlbnQgdmFsdWVcblx0ICAgICAgdmFyIGVzY2FwZXMgPSB7IC8vIEVzY2FwZW1lbnQgdHJhbnNsYXRpb24gdGFibGVcblx0ICAgICAgICBcIlxcXFxcIjogXCJcXFxcXCIsXG5cdCAgICAgICAgXCJcXFwiXCI6IFwiXFxcIlwiLFxuXHQgICAgICAgIFwiL1wiOiBcIi9cIixcblx0ICAgICAgICBcInRcIjogXCJcXHRcIixcblx0ICAgICAgICBcIm5cIjogXCJcXG5cIixcblx0ICAgICAgICBcInJcIjogXCJcXHJcIixcblx0ICAgICAgICBcImZcIjogXCJcXGZcIixcblx0ICAgICAgICBcImJcIjogXCJcXGJcIlxuXHQgICAgICB9O1xuXHQgICAgICB2YXIgc3RyaW5nID0geyAgIC8vIFRoZSBhY3Rpb25zIGZvciBzdHJpbmcgdG9rZW5zXG5cdCAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHN0YXRlID0gXCJva1wiO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmlyc3Rva2V5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBrZXkgPSB2YWx1ZTtcblx0ICAgICAgICAgIHN0YXRlID0gXCJjb2xvblwiO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb2tleTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAga2V5ID0gdmFsdWU7XG5cdCAgICAgICAgICBzdGF0ZSA9IFwiY29sb25cIjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgdmFyIG51bWJlciA9IHsgICAvLyBUaGUgYWN0aW9ucyBmb3IgbnVtYmVyIHRva2Vuc1xuXHQgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgdmFyIGFjdGlvbiA9IHtcblx0XG5cdCAgICAgICAgLy8gVGhlIGFjdGlvbiB0YWJsZSBkZXNjcmliZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBtYWNoaW5lLiBJdCBjb250YWlucyBhblxuXHQgICAgICAgIC8vIG9iamVjdCBmb3IgZWFjaCB0b2tlbi4gRWFjaCBvYmplY3QgY29udGFpbnMgYSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlblxuXHQgICAgICAgIC8vIGEgdG9rZW4gaXMgbWF0Y2hlZCBpbiBhIHN0YXRlLiBBbiBvYmplY3Qgd2lsbCBsYWNrIGEgbWV0aG9kIGZvciBpbGxlZ2FsXG5cdCAgICAgICAgLy8gc3RhdGVzLlxuXHRcblx0ICAgICAgICBcIntcIjoge1xuXHQgICAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc3RhY2sucHVzaCh7c3RhdGU6IFwib2tcIn0pO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSB7fTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0b2tleVwiO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIG92YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBzdGFjay5wdXNoKHtjb250YWluZXI6IGNvbnRhaW5lciwgc3RhdGU6IFwib2NvbW1hXCIsIGtleToga2V5fSk7XG5cdCAgICAgICAgICAgIGNvbnRhaW5lciA9IHt9O1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc3RhY2sucHVzaCh7Y29udGFpbmVyOiBjb250YWluZXIsIHN0YXRlOiBcImFjb21tYVwifSk7XG5cdCAgICAgICAgICAgIGNvbnRhaW5lciA9IHt9O1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwiZmlyc3Rva2V5XCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSB7fTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0b2tleVwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCJ9XCI6IHtcblx0ICAgICAgICAgIGZpcnN0b2tleTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcG9wID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgIHZhbHVlID0gY29udGFpbmVyO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSBwb3AuY29udGFpbmVyO1xuXHQgICAgICAgICAgICBrZXkgPSBwb3Aua2V5O1xuXHQgICAgICAgICAgICBzdGF0ZSA9IHBvcC5zdGF0ZTtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBvY29tbWE6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBvcCA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICBjb250YWluZXJba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcblx0ICAgICAgICAgICAgY29udGFpbmVyID0gcG9wLmNvbnRhaW5lcjtcblx0ICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcIltcIjoge1xuXHQgICAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc3RhY2sucHVzaCh7c3RhdGU6IFwib2tcIn0pO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSBbXTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0YXZhbHVlXCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJvY29tbWFcIiwga2V5OiBrZXl9KTtcblx0ICAgICAgICAgICAgY29udGFpbmVyID0gW107XG5cdCAgICAgICAgICAgIHN0YXRlID0gXCJmaXJzdGF2YWx1ZVwiO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSBbXTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0YXZhbHVlXCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHN0YWNrLnB1c2goe2NvbnRhaW5lcjogY29udGFpbmVyLCBzdGF0ZTogXCJhY29tbWFcIn0pO1xuXHQgICAgICAgICAgICBjb250YWluZXIgPSBbXTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImZpcnN0YXZhbHVlXCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcIl1cIjoge1xuXHQgICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBvcCA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcblx0ICAgICAgICAgICAgY29udGFpbmVyID0gcG9wLmNvbnRhaW5lcjtcblx0ICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgYWNvbW1hOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwb3AgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgY29udGFpbmVyLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcjtcblx0ICAgICAgICAgICAgY29udGFpbmVyID0gcG9wLmNvbnRhaW5lcjtcblx0ICAgICAgICAgICAga2V5ID0gcG9wLmtleTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBwb3Auc3RhdGU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcIjpcIjoge1xuXHQgICAgICAgICAgY29sb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lciwga2V5KSkge1xuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkR1cGxpY2F0ZSBrZXkgJ1wiICsga2V5ICsgXCJcXFwiXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHN0YXRlID0gXCJvdmFsdWVcIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwiLFwiOiB7XG5cdCAgICAgICAgICBvY29tbWE6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgY29udGFpbmVyW2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcIm9rZXlcIjtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBhY29tbWE6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgY29udGFpbmVyLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwiYXZhbHVlXCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcInRydWVcIjoge1xuXHQgICAgICAgICAgZ286IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwib2NvbW1hXCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZmlyc3RhdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwiYWNvbW1hXCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgYXZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCJmYWxzZVwiOiB7XG5cdCAgICAgICAgICBnbzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICBzdGF0ZSA9IFwib2tcIjtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBvdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBhdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCJudWxsXCI6IHtcblx0ICAgICAgICAgIGdvOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcIm9rXCI7XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgb3ZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcIm9jb21tYVwiO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGZpcnN0YXZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICAgICAgc3RhdGUgPSBcImFjb21tYVwiO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIGF2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHN0YXRlID0gXCJhY29tbWFcIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICBmdW5jdGlvbiBkZWJhY2tzbGFzaGlmeSh0ZXh0KSB7XG5cdFxuXHQgICAgICAgIC8vIFJlbW92ZSBhbmQgcmVwbGFjZSBhbnkgYmFja3NsYXNoIGVzY2FwZW1lbnQuXG5cdFxuXHQgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcXFwoPzp1KC57NH0pfChbXnVdKSkvZywgZnVuY3Rpb24gKGlnbm9yZSwgYiwgYykge1xuXHQgICAgICAgICAgcmV0dXJuIGJcblx0ICAgICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGIsIDE2KSlcblx0ICAgICAgICAgICAgOiBlc2NhcGVzW2NdO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuXHRcblx0ICAgICAgICAvLyBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyB1c2VkIHRvIGV4dHJhY3QgdG9rZW5zIGZyb20gdGhlIEpTT04gdGV4dC5cblx0ICAgICAgICAvLyBUaGUgZXh0cmFjdGlvbiBwcm9jZXNzIGlzIGNhdXRpb3VzLlxuXHRcblx0ICAgICAgICB2YXIgcmVzdWx0O1xuXHQgICAgICAgIHZhciB0eCA9IC9eW1xcdTAwMjBcXHRcXG5cXHJdKig/OihbLDpcXFtcXF17fV18dHJ1ZXxmYWxzZXxudWxsKXwoLT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8pfFwiKCg/OlteXFxyXFxuXFx0XFxcXFxcXCJdfFxcXFwoPzpbXCJcXFxcXFwvdHJuZmJdfHVbMC05YS1mQS1GXXs0fSkpKilcIikvO1xuXHRcblx0ICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0aW5nIHN0YXRlLlxuXHRcblx0ICAgICAgICBzdGF0ZSA9IFwiZ29cIjtcblx0XG5cdCAgICAgICAgLy8gVGhlIHN0YWNrIHJlY29yZHMgdGhlIGNvbnRhaW5lciwga2V5LCBhbmQgc3RhdGUgZm9yIGVhY2ggb2JqZWN0IG9yIGFycmF5XG5cdCAgICAgICAgLy8gdGhhdCBjb250YWlucyBhbm90aGVyIG9iamVjdCBvciBhcnJheSB3aGlsZSBwcm9jZXNzaW5nIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuXHRcblx0ICAgICAgICBzdGFjayA9IFtdO1xuXHRcblx0ICAgICAgICAvLyBJZiBhbnkgZXJyb3Igb2NjdXJzLCB3ZSB3aWxsIGNhdGNoIGl0IGFuZCB1bHRpbWF0ZWx5IHRocm93IGEgc3ludGF4IGVycm9yLlxuXHRcblx0ICAgICAgICB0cnkge1xuXHRcblx0ICAgICAgICAgIC8vIEZvciBlYWNoIHRva2VuLi4uXG5cdFxuXHQgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gdHguZXhlYyhzb3VyY2UpO1xuXHQgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAvLyByZXN1bHQgaXMgdGhlIHJlc3VsdCBhcnJheSBmcm9tIG1hdGNoaW5nIHRoZSB0b2tlbml6aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbi5cblx0ICAgICAgICAgICAgLy8gIHJlc3VsdFswXSBjb250YWlucyBldmVyeXRoaW5nIHRoYXQgbWF0Y2hlZCwgaW5jbHVkaW5nIGFueSBpbml0aWFsIHdoaXRlc3BhY2UuXG5cdCAgICAgICAgICAgIC8vICByZXN1bHRbMV0gY29udGFpbnMgYW55IHB1bmN0dWF0aW9uIHRoYXQgd2FzIG1hdGNoZWQsIG9yIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXHQgICAgICAgICAgICAvLyAgcmVzdWx0WzJdIGNvbnRhaW5zIGEgbWF0Y2hlZCBudW1iZXIsIHN0aWxsIGluIHN0cmluZyBmb3JtLlxuXHQgICAgICAgICAgICAvLyAgcmVzdWx0WzNdIGNvbnRhaW5zIGEgbWF0Y2hlZCBzdHJpbmcsIHdpdGhvdXQgcXVvdGVzIGJ1dCB3aXRoIGVzY2FwZW1lbnQuXG5cdFxuXHQgICAgICAgICAgICBpZiAocmVzdWx0WzFdKSB7XG5cdFxuXHQgICAgICAgICAgICAgIC8vIFRva2VuOiBFeGVjdXRlIHRoZSBhY3Rpb24gZm9yIHRoaXMgc3RhdGUgYW5kIHRva2VuLlxuXHRcblx0ICAgICAgICAgICAgICBhY3Rpb25bcmVzdWx0WzFdXVtzdGF0ZV0oKTtcblx0XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzJdKSB7XG5cdFxuXHQgICAgICAgICAgICAgIC8vIE51bWJlciB0b2tlbjogQ29udmVydCB0aGUgbnVtYmVyIHN0cmluZyBpbnRvIGEgbnVtYmVyIHZhbHVlIGFuZCBleGVjdXRlXG5cdCAgICAgICAgICAgICAgLy8gdGhlIGFjdGlvbiBmb3IgdGhpcyBzdGF0ZSBhbmQgbnVtYmVyLlxuXHRcblx0ICAgICAgICAgICAgICB2YWx1ZSA9ICtyZXN1bHRbMl07XG5cdCAgICAgICAgICAgICAgbnVtYmVyW3N0YXRlXSgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHRcblx0ICAgICAgICAgICAgICAvLyBTdHJpbmcgdG9rZW46IFJlcGxhY2UgdGhlIGVzY2FwZW1lbnQgc2VxdWVuY2VzIGFuZCBleGVjdXRlIHRoZSBhY3Rpb24gZm9yXG5cdCAgICAgICAgICAgICAgLy8gdGhpcyBzdGF0ZSBhbmQgc3RyaW5nLlxuXHRcblx0ICAgICAgICAgICAgICB2YWx1ZSA9IGRlYmFja3NsYXNoaWZ5KHJlc3VsdFszXSk7XG5cdCAgICAgICAgICAgICAgc3RyaW5nW3N0YXRlXSgpO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRva2VuIGZyb20gdGhlIHN0cmluZy4gVGhlIGxvb3Agd2lsbCBjb250aW51ZSBhcyBsb25nIGFzIHRoZXJlXG5cdCAgICAgICAgICAgIC8vIGFyZSB0b2tlbnMuIFRoaXMgaXMgYSBzbG93IHByb2Nlc3MsIGJ1dCBpdCBhbGxvd3MgdGhlIHVzZSBvZiBeIG1hdGNoaW5nLFxuXHQgICAgICAgICAgICAvLyB3aGljaCBhc3N1cmVzIHRoYXQgbm8gaWxsZWdhbCB0b2tlbnMgc2xpcCB0aHJvdWdoLlxuXHRcblx0ICAgICAgICAgICAgc291cmNlID0gc291cmNlLnNsaWNlKHJlc3VsdFswXS5sZW5ndGgpO1xuXHQgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgIC8vIElmIHdlIGZpbmQgYSBzdGF0ZS90b2tlbiBjb21iaW5hdGlvbiB0aGF0IGlzIGlsbGVnYWwsIHRoZW4gdGhlIGFjdGlvbiB3aWxsXG5cdCAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvci4gV2UgaGFuZGxlIHRoZSBlcnJvciBieSBzaW1wbHkgY2hhbmdpbmcgdGhlIHN0YXRlLlxuXHRcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICBzdGF0ZSA9IGU7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBUaGUgcGFyc2luZyBpcyBmaW5pc2hlZC4gSWYgd2UgYXJlIG5vdCBpbiB0aGUgZmluYWwgXCJva1wiIHN0YXRlLCBvciBpZiB0aGVcblx0ICAgICAgICAvLyByZW1haW5pbmcgc291cmNlIGNvbnRhaW5zIGFueXRoaW5nIGV4Y2VwdCB3aGl0ZXNwYWNlLCB0aGVuIHdlIGRpZCBub3QgaGF2ZVxuXHQgICAgICAgIC8vYSB3ZWxsLWZvcm1lZCBKU09OIHRleHQuXG5cdFxuXHQgICAgICAgIGlmIChzdGF0ZSAhPT0gXCJva1wiIHx8ICgvW15cXHUwMDIwXFx0XFxuXFxyXS8udGVzdChzb3VyY2UpKSkge1xuXHQgICAgICAgICAgdGhyb3cgKHN0YXRlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpXG5cdCAgICAgICAgICAgID8gc3RhdGVcblx0ICAgICAgICAgICAgOiBuZXcgU3ludGF4RXJyb3IoXCJKU09OXCIpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuXHQgICAgICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG5cdCAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgY3VycmVudFxuXHQgICAgICAgIC8vIHZhbHVlIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVyblxuXHQgICAgICAgIC8vIHRoYXQgdmFsdWUuXG5cdFxuXHQgICAgICAgIHJldHVybiAodHlwZW9mIHJldml2ZXIgPT09IFwiZnVuY3Rpb25cIilcblx0ICAgICAgICAgID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcblx0ICAgICAgICAgICAgdmFyIGs7XG5cdCAgICAgICAgICAgIHZhciB2O1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gaG9sZGVyW2tleV07XG5cdCAgICAgICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGspKSB7XG5cdCAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbCwgayk7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWxba10gPSB2O1xuXHQgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxba107XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsKTtcblx0ICAgICAgICAgIH0oe1wiXCI6IHZhbHVlfSwgXCJcIikpXG5cdCAgICAgICAgOiB2YWx1ZTtcblx0ICAgICAgfTtcblx0ICAgIH0oKSk7XG5cdCAgfVxuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHNldHVwQ3VzdG9tSlNPTjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHQvKlxuXHQgKiBOb3RpZmllciAtIHRoZSBpbnRlcm5hbCBvYmplY3QgcmVzcG9uc2libGUgZm9yIGRlbGVnYXRpbmcgYmV0d2VlbiB0aGUgY2xpZW50IGV4cG9zZWQgQVBJLCB0aGVcblx0ICogY2hhaW4gb2YgdHJhbnNmb3JtcyBuZWNlc3NhcnkgdG8gdHVybiBhbiBpdGVtIGludG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHNlbnQgdG8gUm9sbGJhciwgYW5kIHRoZVxuXHQgKiBxdWV1ZSB3aGljaCBoYW5kbGVzIHRoZSBjb21tdW5jYXRpb24gd2l0aCB0aGUgUm9sbGJhciBBUEkgc2VydmVycy5cblx0ICpcblx0ICogQHBhcmFtIHF1ZXVlIC0gYW4gb2JqZWN0IHRoYXQgY29uZm9ybXMgdG8gdGhlIGludGVyZmFjZTogYWRkSXRlbShpdGVtLCBjYWxsYmFjaylcblx0ICogQHBhcmFtIG9wdGlvbnMgLSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBvcHRpb25zIHRvIGJlIHNldCBmb3IgdGhpcyBub3RpZmllciwgdGhpcyBzaG91bGQgaGF2ZVxuXHQgKiBhbnkgZGVmYXVsdHMgYWxyZWFkeSBzZXQgYnkgdGhlIGNhbGxlclxuXHQgKi9cblx0ZnVuY3Rpb24gTm90aWZpZXIocXVldWUsIG9wdGlvbnMpIHtcblx0ICB0aGlzLnF1ZXVlID0gcXVldWU7XG5cdCAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0ICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcblx0fVxuXHRcblx0Lypcblx0ICogY29uZmlndXJlIC0gdXBkYXRlcyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBub3RpZmllciB3aXRoIHRoZSBwYXNzZWQgaW4gb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSBvcHRpb25zIC0gYW4gb2JqZWN0IHdoaWNoIGdldHMgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgb3B0aW9ucyBzZXQgb24gdGhpcyBub3RpZmllclxuXHQgKiBAcmV0dXJucyB0aGlzXG5cdCAqL1xuXHROb3RpZmllci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgIHRoaXMucXVldWUgJiYgdGhpcy5xdWV1ZS5jb25maWd1cmUob3B0aW9ucyk7XG5cdCAgdmFyIG9sZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdCAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodHJ1ZSwge30sIG9sZE9wdGlvbnMsIG9wdGlvbnMpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0ICogYWRkVHJhbnNmb3JtIC0gYWRkcyBhIHRyYW5zZm9ybSBvbnRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlIG9mIHRyYW5zZm9ybXMgZm9yIHRoaXMgbm90aWZpZXJcblx0ICpcblx0ICogQHBhcmFtIHRyYW5zZm9ybSAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhyZWUgYXJndW1lbnRzOlxuXHQgKiAgICAqIGl0ZW06IEFuIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRhdGEgdG8gZXZlbnR1YWxseSBiZSBzZW50IHRvIFJvbGxiYXJcblx0ICogICAgKiBvcHRpb25zOiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgb3B0aW9ucyBmb3IgdGhpcyBub3RpZmllclxuXHQgKiAgICAqIGNhbGxiYWNrOiBmdW5jdGlvbihlcnI6IChOdWxsfEVycm9yKSwgaXRlbTogKE51bGx8T2JqZWN0KSkgdGhlIHRyYW5zZm9ybSBtdXN0IGNhbGwgdGhpc1xuXHQgKiAgICBjYWxsYmFjayB3aXRoIGEgbnVsbCB2YWx1ZSBmb3IgZXJyb3IgaWYgaXQgd2FudHMgdGhlIHByb2Nlc3NpbmcgY2hhaW4gdG8gY29udGludWUsIG90aGVyd2lzZVxuXHQgKiAgICB3aXRoIGFuIGVycm9yIHRvIHRlcm1pbmF0ZSB0aGUgcHJvY2Vzc2luZy4gVGhlIGl0ZW0gc2hvdWxkIGJlIHRoZSB1cGRhdGVkIGl0ZW0gYWZ0ZXIgdGhpc1xuXHQgKiAgICB0cmFuc2Zvcm0gaXMgZmluaXNoZWQgbW9kaWZ5aW5nIGl0LlxuXHQgKi9cblx0Tm90aWZpZXIucHJvdG90eXBlLmFkZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuXHQgIGlmIChfLmlzRnVuY3Rpb24odHJhbnNmb3JtKSkge1xuXHQgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcblx0ICB9XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHQgKiBsb2cgLSB0aGUgaW50ZXJuYWwgbG9nIGZ1bmN0aW9uIHdoaWNoIGFwcGxpZXMgdGhlIGNvbmZpZ3VyZWQgdHJhbnNmb3JtcyBhbmQgdGhlbiBwdXNoZXMgb250byB0aGVcblx0ICogcXVldWUgdG8gYmUgc2VudCB0byB0aGUgYmFja2VuZC5cblx0ICpcblx0ICogQHBhcmFtIGl0ZW0gLSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblx0ICogICAgbWVzc2FnZSBbU3RyaW5nXSAtIEFuIG9wdGlvbmFsIHN0cmluZyB0byBiZSBzZW50IHRvIHJvbGxiYXJcblx0ICogICAgZXJyb3IgW0Vycm9yXSAtIEFuIG9wdGlvbmFsIGVycm9yXG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gb2YgdHlwZSBmdW5jdGlvbihlcnIsIHJlc3ApIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggZXhhY3RseSBvbmVcblx0ICogbnVsbCBhcmd1bWVudCBhbmQgb25lIG5vbi1udWxsIGFyZ3VtZW50LiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSwgZWl0aGVyIGR1cmluZyB0aGVcblx0ICogdHJhbnNmb3JtIHN0YWdlIGlmIGFuIGVycm9yIG9jY3VycyBpbnNpZGUgYSB0cmFuc2Zvcm0sIG9yIGluIHJlc3BvbnNlIHRvIHRoZSBjb21tdW5pY2F0aW9uIHdpdGhcblx0ICogdGhlIGJhY2tlbmQuIFRoZSBzZWNvbmQgYXJndW1lbnQgd2lsbCBiZSB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgYmFja2VuZCBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG5cdCAqL1xuXHROb3RpZmllci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdCAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG5cdCAgfVxuXHRcblx0ICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdSb2xsYmFyIGlzIG5vdCBlbmFibGVkJykpO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5fYXBwbHlUcmFuc2Zvcm1zKGl0ZW0sIGZ1bmN0aW9uKGVyciwgaSkge1xuXHQgICAgaWYgKGVycikge1xuXHQgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcblx0ICAgIH1cblx0ICAgIHRoaXMucXVldWUuYWRkSXRlbShpLCBjYWxsYmFjayk7XG5cdCAgfS5iaW5kKHRoaXMpKTtcblx0fTtcblx0XG5cdC8qIEludGVybmFsICovXG5cdFxuXHQvKlxuXHQgKiBfYXBwbHlUcmFuc2Zvcm1zIC0gQXBwbGllcyB0aGUgdHJhbnNmb3JtcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIG5vdGlmaWVyIHNlcXVlbnRpYWxseS4gU2VlXG5cdCAqIGBhZGRUcmFuc2Zvcm1gIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0gaXRlbSAtIEFuIGl0ZW0gdG8gYmUgdHJhbnNmb3JtZWRcblx0ICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmdW5jdGlvbiBvZiB0eXBlIGZ1bmN0aW9uKGVyciwgaXRlbSkgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhIG5vbi1udWxsXG5cdCAqIGVycm9yIGFuZCBhIG51bGwgaXRlbSBpbiB0aGUgY2FzZSBvZiBhIHRyYW5zZm9ybSBmYWlsdXJlLCBvciBhIG51bGwgZXJyb3IgYW5kIG5vbi1udWxsIGl0ZW0gYWZ0ZXJcblx0ICogYWxsIHRyYW5zZm9ybXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5cdCAqL1xuXHROb3RpZmllci5wcm90b3R5cGUuX2FwcGx5VHJhbnNmb3JtcyA9IGZ1bmN0aW9uKGl0ZW0sIGNhbGxiYWNrKSB7XG5cdCAgdmFyIHRyYW5zZm9ybUluZGV4ID0gLTE7XG5cdCAgdmFyIHRyYW5zZm9ybXNMZW5ndGggPSB0aGlzLnRyYW5zZm9ybXMubGVuZ3RoO1xuXHQgIHZhciB0cmFuc2Zvcm1zID0gdGhpcy50cmFuc2Zvcm1zO1xuXHQgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcblx0ICB2YXIgY2IgPSBmdW5jdGlvbihlcnIsIGkpIHtcblx0ICAgIGlmIChlcnIpIHtcblx0ICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHRcblx0ICAgIHRyYW5zZm9ybUluZGV4Kys7XG5cdFxuXHQgICAgaWYgKHRyYW5zZm9ybUluZGV4ID09PSB0cmFuc2Zvcm1zTGVuZ3RoKSB7XG5cdCAgICAgIGNhbGxiYWNrKG51bGwsIGkpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdFxuXHQgICAgdHJhbnNmb3Jtc1t0cmFuc2Zvcm1JbmRleF0oaSwgb3B0aW9ucywgY2IpO1xuXHQgIH07XG5cdCAgXG5cdCAgY2IobnVsbCwgaXRlbSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IE5vdGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBoZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgaG9zdG5hbWU6ICdhcGkucm9sbGJhci5jb20nLFxuXHQgIHBhdGg6ICcvYXBpLzEnLFxuXHQgIHNlYXJjaDogbnVsbCxcblx0ICB2ZXJzaW9uOiAnMScsXG5cdCAgcHJvdG9jb2w6ICdodHRwczonLFxuXHQgIHBvcnQ6IDQ0M1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFwaSBpcyBhbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgbWV0aG9kcyBvZiBjb21tdW5pY2F0aW5nIHdpdGhcblx0ICogdGhlIFJvbGxiYXIgQVBJLiAgSXQgaXMgYSBzdGFuZGFyZCBpbnRlcmZhY2Ugd2l0aCBzb21lIHBhcnRzIGltcGxlbWVudGVkXG5cdCAqIGRpZmZlcmVudGx5IGZvciBzZXJ2ZXIgb3IgYnJvd3NlciBjb250ZXh0cy4gIEl0IGlzIGFuIG9iamVjdCB0aGF0IHNob3VsZFxuXHQgKiBiZSBpbnN0YW50aWF0ZWQgd2hlbiB1c2VkIHNvIGl0IGNhbiBjb250YWluIG5vbi1nbG9iYWwgb3B0aW9ucyB0aGF0IG1heVxuXHQgKiBiZSBkaWZmZXJlbnQgZm9yIGFub3RoZXIgaW5zdGFuY2Ugb2YgUm9sbGJhckFwaS5cblx0ICpcblx0ICogQHBhcmFtIG9wdGlvbnMge1xuXHQgKiAgICBhY2Nlc3NUb2tlbjogdGhlIGFjY2Vzc1Rva2VuIHRvIHVzZSBmb3IgcG9zdGluZyBpdGVtcyB0byByb2xsYmFyXG5cdCAqICAgIGVuZHBvaW50OiBhbiBhbHRlcm5hdGl2ZSBlbmRwb2ludCB0byBzZW5kIGVycm9ycyB0b1xuXHQgKiAgICAgICAgbXVzdCBiZSBhIHZhbGlkLCBmdWxseSBxdWFsaWZpZWQgVVJMLlxuXHQgKiAgICAgICAgVGhlIGRlZmF1bHQgaXM6IGh0dHBzOi8vYXBpLnJvbGxiYXIuY29tL2FwaS8xXG5cdCAqICAgIHByb3h5OiBpZiB5b3Ugd2lzaCB0byBwcm94eSByZXF1ZXN0cyBwcm92aWRlIGFuIG9iamVjdFxuXHQgKiAgICAgICAgd2l0aCB0aGUgZm9sbG93aW5nIGtleXM6XG5cdCAqICAgICAgICAgIGhvc3Qgb3IgaG9zdG5hbWUgKHJlcXVpcmVkKTogZm9vLmV4YW1wbGUuY29tXG5cdCAqICAgICAgICAgIHBvcnQgKG9wdGlvbmFsKTogMTIzXG5cdCAqICAgICAgICAgIHByb3RvY29sIChvcHRpb25hbCk6IGh0dHBzXG5cdCAqIH1cblx0ICovXG5cdGZ1bmN0aW9uIEFwaShvcHRpb25zLCB0LCB1LCBqKSB7XG5cdCAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0ICB0aGlzLnRyYW5zcG9ydCA9IHQ7XG5cdCAgdGhpcy51cmwgPSB1O1xuXHQgIHRoaXMuanNvbkJhY2t1cCA9IGo7XG5cdCAgdGhpcy5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuYWNjZXNzVG9rZW47XG5cdCAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gX2dldFRyYW5zcG9ydChvcHRpb25zLCB1KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBkYXRhXG5cdCAqIEBwYXJhbSBjYWxsYmFja1xuXHQgKi9cblx0QXBpLnByb3RvdHlwZS5wb3N0SXRlbSA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cdCAgdmFyIHRyYW5zcG9ydE9wdGlvbnMgPSBoZWxwZXJzLnRyYW5zcG9ydE9wdGlvbnModGhpcy50cmFuc3BvcnRPcHRpb25zLCAnL2l0ZW0vJywgJ1BPU1QnKTtcblx0ICB2YXIgcGF5bG9hZCA9IGhlbHBlcnMuYnVpbGRQYXlsb2FkKHRoaXMuYWNjZXNzVG9rZW4sIGRhdGEsIHRoaXMuanNvbkJhY2t1cCk7XG5cdCAgdGhpcy50cmFuc3BvcnQucG9zdCh0aGlzLmFjY2Vzc1Rva2VuLCB0cmFuc3BvcnRPcHRpb25zLCBwYXlsb2FkLCBjYWxsYmFjayk7XG5cdH07XG5cdFxuXHRBcGkucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICB2YXIgb2xkT3B0aW9ucyA9IHRoaXMub2xkT3B0aW9ucztcblx0ICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0cnVlLCB7fSwgb2xkT3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gX2dldFRyYW5zcG9ydCh0aGlzLm9wdGlvbnMsIHRoaXMudXJsKTtcblx0ICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc1Rva2VuICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW47XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gX2dldFRyYW5zcG9ydChvcHRpb25zLCB1cmwpIHtcblx0ICByZXR1cm4gaGVscGVycy5nZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucywgdXJsKTtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBBcGk7XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XG5cdGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZChhY2Nlc3NUb2tlbiwgZGF0YSwganNvbkJhY2t1cCkge1xuXHQgIGlmIChfLmlzVHlwZShkYXRhLmNvbnRleHQsICdvYmplY3QnKSkge1xuXHQgICAgdmFyIGNvbnRleHRSZXN1bHQgPSBfLnN0cmluZ2lmeShkYXRhLmNvbnRleHQsIGpzb25CYWNrdXApO1xuXHQgICAgaWYgKGNvbnRleHRSZXN1bHQuZXJyb3IpIHtcblx0ICAgICAgZGF0YS5jb250ZXh0ID0gJ0Vycm9yOiBjb3VsZCBub3Qgc2VyaWFsaXplIFxcJ2NvbnRleHRcXCcnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGF0YS5jb250ZXh0ID0gY29udGV4dFJlc3VsdC52YWx1ZSB8fCAnJztcblx0ICAgIH1cblx0ICAgIGlmIChkYXRhLmNvbnRleHQubGVuZ3RoID4gMjU1KSB7XG5cdCAgICAgIGRhdGEuY29udGV4dCA9IGRhdGEuY29udGV4dC5zdWJzdHIoMCwgMjU1KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4sXG5cdCAgICBkYXRhOiBkYXRhXG5cdCAgfTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0VHJhbnNwb3J0RnJvbU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMsIHVybCkge1xuXHQgIHZhciBob3N0bmFtZSA9IGRlZmF1bHRzLmhvc3RuYW1lO1xuXHQgIHZhciBwcm90b2NvbCA9IGRlZmF1bHRzLnByb3RvY29sO1xuXHQgIHZhciBwb3J0ID0gZGVmYXVsdHMucG9ydDtcblx0ICB2YXIgcGF0aCA9IGRlZmF1bHRzLnBhdGg7XG5cdCAgdmFyIHNlYXJjaCA9IGRlZmF1bHRzLnNlYXJjaDtcblx0XG5cdCAgdmFyIHByb3h5ID0gb3B0aW9ucy5wcm94eTtcblx0ICBpZiAob3B0aW9ucy5lbmRwb2ludCkge1xuXHQgICAgdmFyIG9wdHMgPSB1cmwucGFyc2Uob3B0aW9ucy5lbmRwb2ludCk7XG5cdCAgICBob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG5cdCAgICBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2w7XG5cdCAgICBwb3J0ID0gb3B0cy5wb3J0O1xuXHQgICAgcGF0aCA9IG9wdHMucGF0aG5hbWU7XG5cdCAgICBzZWFyY2ggPSBvcHRzLnNlYXJjaDtcblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIGhvc3RuYW1lOiBob3N0bmFtZSxcblx0ICAgIHByb3RvY29sOiBwcm90b2NvbCxcblx0ICAgIHBvcnQ6IHBvcnQsXG5cdCAgICBwYXRoOiBwYXRoLFxuXHQgICAgc2VhcmNoOiBzZWFyY2gsXG5cdCAgICBwcm94eTogcHJveHlcblx0ICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiB0cmFuc3BvcnRPcHRpb25zKHRyYW5zcG9ydCwgcGF0aCwgbWV0aG9kKSB7XG5cdCAgdmFyIHByb3RvY29sID0gdHJhbnNwb3J0LnByb3RvY29sIHx8ICdodHRwczonO1xuXHQgIHZhciBwb3J0ID0gdHJhbnNwb3J0LnBvcnQgfHwgKHByb3RvY29sID09PSAnaHR0cDonID8gODAgOiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiB1bmRlZmluZWQpO1xuXHQgIHZhciBob3N0bmFtZSA9IHRyYW5zcG9ydC5ob3N0bmFtZTtcblx0ICBwYXRoID0gYXBwZW5kUGF0aFRvUGF0aCh0cmFuc3BvcnQucGF0aCwgcGF0aCk7XG5cdCAgaWYgKHRyYW5zcG9ydC5zZWFyY2gpIHtcblx0ICAgIHBhdGggPSBwYXRoICsgdHJhbnNwb3J0LnNlYXJjaDtcblx0ICB9XG5cdCAgaWYgKHRyYW5zcG9ydC5wcm94eSkge1xuXHQgICAgcGF0aCA9IHByb3RvY29sICsgJy8vJyArIGhvc3RuYW1lICsgcGF0aDtcblx0ICAgIGhvc3RuYW1lID0gdHJhbnNwb3J0LnByb3h5Lmhvc3QgfHwgdHJhbnNwb3J0LnByb3h5Lmhvc3RuYW1lO1xuXHQgICAgcG9ydCA9IHRyYW5zcG9ydC5wcm94eS5wb3J0O1xuXHQgICAgcHJvdG9jb2wgPSB0cmFuc3BvcnQucHJveHkucHJvdG9jb2wgfHwgcHJvdG9jb2w7XG5cdCAgfVxuXHQgIHJldHVybiB7XG5cdCAgICBwcm90b2NvbDogcHJvdG9jb2wsXG5cdCAgICBob3N0bmFtZTogaG9zdG5hbWUsXG5cdCAgICBwYXRoOiBwYXRoLFxuXHQgICAgcG9ydDogcG9ydCxcblx0ICAgIG1ldGhvZDogbWV0aG9kXG5cdCAgfTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYXBwZW5kUGF0aFRvUGF0aChiYXNlLCBwYXRoKSB7XG5cdCAgdmFyIGJhc2VUcmFpbGluZ1NsYXNoID0gL1xcLyQvLnRlc3QoYmFzZSk7XG5cdCAgdmFyIHBhdGhCZWdpbm5pbmdTbGFzaCA9IC9eXFwvLy50ZXN0KHBhdGgpO1xuXHRcblx0ICBpZiAoYmFzZVRyYWlsaW5nU2xhc2ggJiYgcGF0aEJlZ2lubmluZ1NsYXNoKSB7XG5cdCAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XG5cdCAgfSBlbHNlIGlmICghYmFzZVRyYWlsaW5nU2xhc2ggJiYgIXBhdGhCZWdpbm5pbmdTbGFzaCkge1xuXHQgICAgcGF0aCA9ICcvJyArIHBhdGg7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gYmFzZSArIHBhdGg7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGJ1aWxkUGF5bG9hZDogYnVpbGRQYXlsb2FkLFxuXHQgIGdldFRyYW5zcG9ydEZyb21PcHRpb25zOiBnZXRUcmFuc3BvcnRGcm9tT3B0aW9ucyxcblx0ICB0cmFuc3BvcnRPcHRpb25zOiB0cmFuc3BvcnRPcHRpb25zLFxuXHQgIGFwcGVuZFBhdGhUb1BhdGg6IGFwcGVuZFBhdGhUb1BhdGhcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXHRcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdHZhciBkZXRlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0ZnVuY3Rpb24gZXJyb3IoKSB7XG5cdCAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHQgIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcblx0ICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcblx0ICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0QXJnc0FzU3RyaW5nLmFwcGx5KG51bGwsIGFyZ3MpKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGluZm8oKSB7XG5cdCAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHQgIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcblx0ICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcblx0ICAgIGNvbnNvbGUuaW5mbyhmb3JtYXRBcmdzQXNTdHJpbmcuYXBwbHkobnVsbCwgYXJncykpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJncyk7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBsb2coKSB7XG5cdCAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHQgIGFyZ3MudW5zaGlmdCgnUm9sbGJhcjonKTtcblx0ICBpZiAoZGV0ZWN0aW9uLmllVmVyc2lvbigpIDw9IDgpIHtcblx0ICAgIGNvbnNvbGUubG9nKGZvcm1hdEFyZ3NBc1N0cmluZy5hcHBseShudWxsLCBhcmdzKSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuXHQgIH1cblx0fVxuXHRcblx0Ly8gSUU4IGxvZ3Mgb2JqZWN0cyBhcyBbb2JqZWN0IE9iamVjdF0uICBUaGlzIGlzIGEgd3JhcHBlciB0aGF0IG1ha2VzIGl0IGEgYml0XG5cdC8vIG1vcmUgY29udmVuaWVudCBieSBsb2dnaW5nIHRoZSBKU09OIG9mIHRoZSBvYmplY3QuICBCdXQgb25seSBkbyB0aGF0IGluIElFOCBhbmQgYmVsb3dcblx0Ly8gYmVjYXVzZSBvdGhlciBicm93c2VycyBhcmUgc21hcnRlciBhbmQgaGFuZGxlIGl0IHByb3Blcmx5LlxuXHRmdW5jdGlvbiBmb3JtYXRBcmdzQXNTdHJpbmcoKSB7XG5cdCAgdmFyIGFyZ3MgPSBbXTtcblx0ICBmb3IgKHZhciBpPTA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdCAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgYXJnID0gXy5zdHJpbmdpZnkoYXJnKTtcblx0ICAgICAgYXJnID0gYXJnLmVycm9yIHx8IGFyZy52YWx1ZTtcblx0ICAgICAgaWYgKGFyZy5sZW5ndGggPiA1MDApXG5cdCAgICAgICAgYXJnID0gYXJnLnN1YnN0cigwLDUwMCkrJy4uLic7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIGFyZyA9ICd1bmRlZmluZWQnO1xuXHQgICAgfVxuXHQgICAgYXJncy5wdXNoKGFyZyk7XG5cdCAgfVxuXHQgIHJldHVybiBhcmdzLmpvaW4oJyAnKTtcblx0fVxuXHRcblx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBlcnJvcjogZXJyb3IsXG5cdCAgaW5mbzogaW5mbyxcblx0ICBsb2c6IGxvZ1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBDb25zb2xlLXBvbHlmaWxsLiBNSVQgbGljZW5zZS5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9jb25zb2xlLXBvbHlmaWxsXG5cdC8vIE1ha2UgaXQgc2FmZSB0byBkbyBjb25zb2xlLmxvZygpIGFsd2F5cy5cblx0KGZ1bmN0aW9uKGdsb2JhbCkge1xuXHQgICd1c2Ugc3RyaWN0Jztcblx0ICBpZiAoIWdsb2JhbC5jb25zb2xlKSB7XG5cdCAgICBnbG9iYWwuY29uc29sZSA9IHt9O1xuXHQgIH1cblx0ICB2YXIgY29uID0gZ2xvYmFsLmNvbnNvbGU7XG5cdCAgdmFyIHByb3AsIG1ldGhvZDtcblx0ICB2YXIgZHVtbXkgPSBmdW5jdGlvbigpIHt9O1xuXHQgIHZhciBwcm9wZXJ0aWVzID0gWydtZW1vcnknXTtcblx0ICB2YXIgbWV0aG9kcyA9ICgnYXNzZXJ0LGNsZWFyLGNvdW50LGRlYnVnLGRpcixkaXJ4bWwsZXJyb3IsZXhjZXB0aW9uLGdyb3VwLCcgK1xuXHQgICAgICdncm91cENvbGxhcHNlZCxncm91cEVuZCxpbmZvLGxvZyxtYXJrVGltZWxpbmUscHJvZmlsZSxwcm9maWxlcyxwcm9maWxlRW5kLCcgK1xuXHQgICAgICdzaG93LHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSx0aW1lbGluZUVuZCx0aW1lU3RhbXAsdHJhY2Usd2FybicpLnNwbGl0KCcsJyk7XG5cdCAgd2hpbGUgKHByb3AgPSBwcm9wZXJ0aWVzLnBvcCgpKSBpZiAoIWNvbltwcm9wXSkgY29uW3Byb3BdID0ge307XG5cdCAgd2hpbGUgKG1ldGhvZCA9IG1ldGhvZHMucG9wKCkpIGlmICghY29uW21ldGhvZF0pIGNvblttZXRob2RdID0gZHVtbXk7XG5cdCAgLy8gVXNpbmcgYHRoaXNgIGZvciB3ZWIgd29ya2VycyAmIHN1cHBvcnRzIEJyb3dzZXJpZnkgLyBXZWJwYWNrLlxuXHR9KSh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiB3aW5kb3cpO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvLyBUaGlzIGRldGVjdGlvbi5qcyBtb2R1bGUgaXMgdXNlZCB0byBlbmNhcHN1bGF0ZSBhbnkgdWdseSBicm93c2VyL2ZlYXR1cmVcblx0Ly8gZGV0ZWN0aW9uIHdlIG1heSBuZWVkIHRvIGRvLlxuXHRcblx0Ly8gRmlndXJlIG91dCB3aGljaCB2ZXJzaW9uIG9mIElFIHdlJ3JlIHVzaW5nLCBpZiBhbnkuXG5cdC8vIFRoaXMgaXMgZ2xlYW5lZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTU3NDg0Mi9iZXN0LXdheS10by1jaGVjay1mb3ItaWUtbGVzcy10aGFuLTktaW4tamF2YXNjcmlwdC13aXRob3V0LWxpYnJhcnlcblx0Ly8gV2lsbCByZXR1cm4gYW4gaW50ZWdlciBvbiBJRSAoaS5lLiA4KVxuXHQvLyBXaWxsIHJldHVybiB1bmRlZmluZWQgb3RoZXJ3aXNlXG5cdGZ1bmN0aW9uIGdldElFVmVyc2lvbigpIHtcblx0XHR2YXIgdW5kZWY7XG5cdFx0aWYgKCFkb2N1bWVudCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmO1xuXHRcdH1cblx0XG5cdCAgdmFyIHYgPSAzLFxuXHQgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdCAgICBhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2knKTtcblx0XG5cdCAgd2hpbGUgKFxuXHQgICAgZGl2LmlubmVySFRNTCA9ICc8IS0tW2lmIGd0IElFICcgKyAoKyt2KSArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nLFxuXHQgICAgICBhbGxbMF1cblx0ICAgICk7XG5cdFxuXHQgIHJldHVybiB2ID4gNCA/IHYgOiB1bmRlZjtcblx0fVxuXHRcblx0dmFyIERldGVjdGlvbiA9IHtcblx0ICBpZVZlcnNpb246IGdldElFVmVyc2lvblxuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBEZXRlY3Rpb247XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGZ1bmN0aW9uIGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG5cdCAgaWYgKCF3aW5kb3cpIHsgcmV0dXJuOyB9XG5cdCAgdmFyIG9sZE9uRXJyb3I7XG5cdFxuXHQgIGlmICh0eXBlb2YgaGFuZGxlci5fcm9sbGJhck9sZE9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIG9sZE9uRXJyb3IgPSBoYW5kbGVyLl9yb2xsYmFyT2xkT25FcnJvcjtcblx0ICB9IGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yICYmICF3aW5kb3cub25lcnJvci5iZWxvbmdzVG9TaGltKSB7XG5cdCAgICBvbGRPbkVycm9yID0gd2luZG93Lm9uZXJyb3I7XG5cdCAgICBoYW5kbGVyLl9yb2xsYmFyT2xkT25FcnJvciA9IG9sZE9uRXJyb3I7XG5cdCAgfVxuXHRcblx0ICB2YXIgZm4gPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0ICAgIF9yb2xsYmFyV2luZG93T25FcnJvcih3aW5kb3csIGhhbmRsZXIsIG9sZE9uRXJyb3IsIGFyZ3MpO1xuXHQgIH07XG5cdCAgZm4uYmVsb25nc1RvU2hpbSA9IHNoaW07XG5cdCAgd2luZG93Lm9uZXJyb3IgPSBmbjtcblx0fVxuXHRcblx0ZnVuY3Rpb24gX3JvbGxiYXJXaW5kb3dPbkVycm9yKHdpbmRvdywgciwgb2xkLCBhcmdzKSB7XG5cdCAgaWYgKHdpbmRvdy5fcm9sbGJhcldyYXBwZWRFcnJvcikge1xuXHQgICAgaWYgKCFhcmdzWzRdKSB7XG5cdCAgICAgIGFyZ3NbNF0gPSB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3I7XG5cdCAgICB9XG5cdCAgICBpZiAoIWFyZ3NbNV0pIHtcblx0ICAgICAgYXJnc1s1XSA9IHdpbmRvdy5fcm9sbGJhcldyYXBwZWRFcnJvci5fcm9sbGJhckNvbnRleHQ7XG5cdCAgICB9XG5cdCAgICB3aW5kb3cuX3JvbGxiYXJXcmFwcGVkRXJyb3IgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgci5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbi5hcHBseShyLCBhcmdzKTtcblx0ICBpZiAob2xkKSB7XG5cdCAgICBvbGQuYXBwbHkod2luZG93LCBhcmdzKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zKHdpbmRvdywgaGFuZGxlciwgc2hpbSkge1xuXHQgIGlmICghd2luZG93KSB7IHJldHVybjsgfVxuXHRcblx0ICBpZiAodHlwZW9mIHdpbmRvdy5fcm9sbGJhclVSSCA9PT0gJ2Z1bmN0aW9uJyAmJiB3aW5kb3cuX3JvbGxiYXJVUkguYmVsb25nc1RvU2hpbSkge1xuXHQgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHdpbmRvdy5fcm9sbGJhclVSSCk7XG5cdCAgfVxuXHRcblx0ICB2YXIgcmVqZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgdmFyIHJlYXNvbiA9IGV2ZW50LnJlYXNvbjtcblx0ICAgIHZhciBwcm9taXNlID0gZXZlbnQucHJvbWlzZTtcblx0ICAgIHZhciBkZXRhaWwgPSBldmVudC5kZXRhaWw7XG5cdFxuXHQgICAgaWYgKCFyZWFzb24gJiYgZGV0YWlsKSB7XG5cdCAgICAgIHJlYXNvbiA9IGRldGFpbC5yZWFzb247XG5cdCAgICAgIHByb21pc2UgPSBkZXRhaWwucHJvbWlzZTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbikge1xuXHQgICAgICBoYW5kbGVyLmhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbihyZWFzb24sIHByb21pc2UpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgcmVqZWN0aW9uSGFuZGxlci5iZWxvbmdzVG9TaGltID0gc2hpbTtcblx0ICB3aW5kb3cuX3JvbGxiYXJVUkggPSByZWplY3Rpb25IYW5kbGVyO1xuXHQgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCByZWplY3Rpb25IYW5kbGVyKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gd3JhcEdsb2JhbHMod2luZG93LCBoYW5kbGVyLCBzaGltKSB7XG5cdCAgaWYgKCF3aW5kb3cpIHsgcmV0dXJuOyB9XG5cdCAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9idWdzbmFnL2J1Z3NuYWctanNcblx0ICB2YXIgZ2xvYmFscyA9ICdFdmVudFRhcmdldCxXaW5kb3csTm9kZSxBcHBsaWNhdGlvbkNhY2hlLEF1ZGlvVHJhY2tMaXN0LENoYW5uZWxNZXJnZXJOb2RlLENyeXB0b09wZXJhdGlvbixFdmVudFNvdXJjZSxGaWxlUmVhZGVyLEhUTUxVbmtub3duRWxlbWVudCxJREJEYXRhYmFzZSxJREJSZXF1ZXN0LElEQlRyYW5zYWN0aW9uLEtleU9wZXJhdGlvbixNZWRpYUNvbnRyb2xsZXIsTWVzc2FnZVBvcnQsTW9kYWxXaW5kb3csTm90aWZpY2F0aW9uLFNWR0VsZW1lbnRJbnN0YW5jZSxTY3JlZW4sVGV4dFRyYWNrLFRleHRUcmFja0N1ZSxUZXh0VHJhY2tMaXN0LFdlYlNvY2tldCxXZWJTb2NrZXRXb3JrZXIsV29ya2VyLFhNTEh0dHBSZXF1ZXN0LFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQsWE1MSHR0cFJlcXVlc3RVcGxvYWQnLnNwbGl0KCcsJyk7XG5cdCAgdmFyIGksIGdsb2JhbDtcblx0ICBmb3IgKGkgPSAwOyBpIDwgZ2xvYmFscy5sZW5ndGg7ICsraSkge1xuXHQgICAgZ2xvYmFsID0gZ2xvYmFsc1tpXTtcblx0XG5cdCAgICBpZiAod2luZG93W2dsb2JhbF0gJiYgd2luZG93W2dsb2JhbF0ucHJvdG90eXBlKSB7XG5cdCAgICAgIF9leHRlbmRMaXN0ZW5lclByb3RvdHlwZShoYW5kbGVyLCB3aW5kb3dbZ2xvYmFsXS5wcm90b3R5cGUsIHNoaW0pO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gX2V4dGVuZExpc3RlbmVyUHJvdG90eXBlKGhhbmRsZXIsIHByb3RvdHlwZSwgc2hpbSkge1xuXHQgIGlmIChwcm90b3R5cGUuaGFzT3duUHJvcGVydHkgJiYgcHJvdG90eXBlLmhhc093blByb3BlcnR5KCdhZGRFdmVudExpc3RlbmVyJykpIHtcblx0ICAgIHZhciBvbGRBZGRFdmVudExpc3RlbmVyID0gcHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cdCAgICB3aGlsZSAob2xkQWRkRXZlbnRMaXN0ZW5lci5fcm9sbGJhck9sZEFkZCAmJiBvbGRBZGRFdmVudExpc3RlbmVyLmJlbG9uZ3NUb1NoaW0pIHtcblx0ICAgICAgb2xkQWRkRXZlbnRMaXN0ZW5lciA9IG9sZEFkZEV2ZW50TGlzdGVuZXIuX3JvbGxiYXJPbGRBZGQ7XG5cdCAgICB9XG5cdCAgICB2YXIgYWRkRm4gPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2ssIGJ1YmJsZSkge1xuXHQgICAgICBvbGRBZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIGhhbmRsZXIud3JhcChjYWxsYmFjayksIGJ1YmJsZSk7XG5cdCAgICB9O1xuXHQgICAgYWRkRm4uX3JvbGxiYXJPbGRBZGQgPSBvbGRBZGRFdmVudExpc3RlbmVyO1xuXHQgICAgYWRkRm4uYmVsb25nc1RvU2hpbSA9IHNoaW07XG5cdCAgICBwcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEZuO1xuXHRcblx0ICAgIHZhciBvbGRSZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdCAgICB3aGlsZSAob2xkUmVtb3ZlRXZlbnRMaXN0ZW5lci5fcm9sbGJhck9sZFJlbW92ZSAmJiBvbGRSZW1vdmVFdmVudExpc3RlbmVyLmJlbG9uZ3NUb1NoaW0pIHtcblx0ICAgICAgb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IG9sZFJlbW92ZUV2ZW50TGlzdGVuZXIuX3JvbGxiYXJPbGRSZW1vdmU7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVtb3ZlRm4gPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2ssIGJ1YmJsZSkge1xuXHQgICAgICBvbGRSZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIGNhbGxiYWNrICYmIGNhbGxiYWNrLl93cmFwcGVkIHx8IGNhbGxiYWNrLCBidWJibGUpO1xuXHQgICAgfTtcblx0ICAgIHJlbW92ZUZuLl9yb2xsYmFyT2xkUmVtb3ZlID0gb2xkUmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0ICAgIHJlbW92ZUZuLmJlbG9uZ3NUb1NoaW0gPSBzaGltO1xuXHQgICAgcHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVGbjtcblx0ICB9XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnM6IGNhcHR1cmVVbmNhdWdodEV4Y2VwdGlvbnMsXG5cdCAgY2FwdHVyZVVuaGFuZGxlZFJlamVjdGlvbnM6IGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zLFxuXHQgIHdyYXBHbG9iYWxzOiB3cmFwR2xvYmFsc1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0XG5cdC8qXG5cdCAqIGFjY2Vzc1Rva2VuIG1heSBiZSBlbWJlZGRlZCBpbiBwYXlsb2FkIGJ1dCB0aGF0IHNob3VsZCBub3Rcblx0ICogICBiZSBhc3N1bWVkXG5cdCAqXG5cdCAqIG9wdGlvbnM6IHtcblx0ICogICBob3N0bmFtZVxuXHQgKiAgIHByb3RvY29sXG5cdCAqICAgcGF0aFxuXHQgKiAgIHBvcnRcblx0ICogICBtZXRob2Rcblx0ICogfVxuXHQgKlxuXHQgKiAgcGFyYW1zIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlycy4gVGhlc2Vcblx0ICogICAgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcGF0aCBhcyAna2V5PXZhbHVlJmtleT12YWx1ZSdcblx0ICpcblx0ICogcGF5bG9hZCBpcyBhbiB1bnNlcmlhbGl6ZWQgb2JqZWN0XG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gZ2V0KGFjY2Vzc1Rva2VuLCBvcHRpb25zLCBwYXJhbXMsIGNhbGxiYWNrLCByZXF1ZXN0RmFjdG9yeSkge1xuXHQgIGlmICghY2FsbGJhY2sgfHwgIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0ICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcblx0ICB9XG5cdCAgXy5hZGRQYXJhbXNBbmRBY2Nlc3NUb2tlblRvUGF0aChhY2Nlc3NUb2tlbiwgb3B0aW9ucywgcGFyYW1zKTtcblx0XG5cdCAgdmFyIG1ldGhvZCA9ICdHRVQnO1xuXHQgIHZhciB1cmwgPSBfLmZvcm1hdFVybChvcHRpb25zKTtcblx0ICBfbWFrZVJlcXVlc3QoYWNjZXNzVG9rZW4sIHVybCwgbWV0aG9kLCBudWxsLCBjYWxsYmFjaywgcmVxdWVzdEZhY3RvcnkpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwb3N0KGFjY2Vzc1Rva2VuLCBvcHRpb25zLCBwYXlsb2FkLCBjYWxsYmFjaywgcmVxdWVzdEZhY3RvcnkpIHtcblx0ICBpZiAoIWNhbGxiYWNrIHx8ICFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdCAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG5cdCAgfVxuXHRcblx0ICBpZiAoIXBheWxvYWQpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nhbm5vdCBzZW5kIGVtcHR5IHJlcXVlc3QnKSk7XG5cdCAgfVxuXHRcblx0ICB2YXIgc3RyaW5naWZ5UmVzdWx0ID0gXy5zdHJpbmdpZnkocGF5bG9hZCk7XG5cdCAgaWYgKHN0cmluZ2lmeVJlc3VsdC5lcnJvcikge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKHN0cmluZ2lmeVJlc3VsdC5lcnJvcik7XG5cdCAgfVxuXHRcblx0ICB2YXIgd3JpdGVEYXRhID0gc3RyaW5naWZ5UmVzdWx0LnZhbHVlO1xuXHQgIHZhciBtZXRob2QgPSAnUE9TVCc7XG5cdCAgdmFyIHVybCA9IF8uZm9ybWF0VXJsKG9wdGlvbnMpO1xuXHQgIF9tYWtlUmVxdWVzdChhY2Nlc3NUb2tlbiwgdXJsLCBtZXRob2QsIHdyaXRlRGF0YSwgY2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gX21ha2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCB1cmwsIG1ldGhvZCwgZGF0YSwgY2FsbGJhY2ssIHJlcXVlc3RGYWN0b3J5KSB7XG5cdCAgdmFyIHJlcXVlc3Q7XG5cdCAgaWYgKHJlcXVlc3RGYWN0b3J5KSB7XG5cdCAgICByZXF1ZXN0ID0gcmVxdWVzdEZhY3RvcnkoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmVxdWVzdCA9IF9jcmVhdGVYTUxIVFRQT2JqZWN0KCk7XG5cdCAgfVxuXHQgIGlmICghcmVxdWVzdCkge1xuXHQgICAgLy8gR2l2ZSB1cCwgbm8gd2F5IHRvIHNlbmQgcmVxdWVzdHNcblx0ICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIHdheSB0byBzZW5kIGEgcmVxdWVzdCcpKTtcblx0ICB9XG5cdCAgdHJ5IHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHZhciBvbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgaWYgKG9ucmVhZHlzdGF0ZWNoYW5nZSAmJiByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcblx0ICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICAgICAgdmFyIHBhcnNlUmVzcG9uc2UgPSBfLmpzb25QYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cdCAgICAgICAgICAgIGlmIChfaXNTdWNjZXNzKHJlcXVlc3QpKSB7XG5cdCAgICAgICAgICAgICAgY2FsbGJhY2socGFyc2VSZXNwb25zZS5lcnJvciwgcGFyc2VSZXNwb25zZS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKF9pc05vcm1hbEZhaWx1cmUocmVxdWVzdCkpIHtcblx0ICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwMykge1xuXHQgICAgICAgICAgICAgICAgLy8gbGlrZWx5IGNhdXNlZCBieSB1c2luZyBhIHNlcnZlciBhY2Nlc3MgdG9rZW5cblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcGFyc2VSZXNwb25zZS52YWx1ZSAmJiBwYXJzZVJlc3BvbnNlLnZhbHVlLm1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIC8vIHJldHVybiB2YWxpZCBodHRwIHN0YXR1cyBjb2Rlc1xuXHQgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihTdHJpbmcocmVxdWVzdC5zdGF0dXMpKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgLy8gSUUgd2lsbCByZXR1cm4gYSBzdGF0dXMgMTIwMDArIG9uIHNvbWUgc29ydCBvZiBjb25uZWN0aW9uIGZhaWx1cmUsXG5cdCAgICAgICAgICAgICAgLy8gc28gd2UgcmV0dXJuIGEgYmxhbmsgZXJyb3Jcblx0ICAgICAgICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWEzODM3NzAlMjhWUy44NSUyOS5hc3B4XG5cdCAgICAgICAgICAgICAgdmFyIG1zZyA9ICdYSFIgcmVzcG9uc2UgaGFkIG5vIHN0YXR1cyBjb2RlIChsaWtlbHkgY29ubmVjdGlvbiBmYWlsdXJlKSc7XG5cdCAgICAgICAgICAgICAgY2FsbGJhY2soX25ld1JldHJpYWJsZUVycm9yKG1zZykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgIC8vanF1ZXJ5IHNvdXJjZSBtZW50aW9ucyBmaXJlZm94IG1heSBlcnJvciBvdXQgd2hpbGUgYWNjZXNzaW5nIHRoZVxuXHQgICAgICAgICAgLy9yZXF1ZXN0IG1lbWJlcnMgaWYgdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yXG5cdCAgICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvYTkzOGQ3YjEyODJmYzBlNWM1MjUwMmMyMjVhZThmMGNlZjIxOWYwYS9zcmMvYWpheC94aHIuanMjTDExMVxuXHQgICAgICAgICAgdmFyIGV4Yztcblx0ICAgICAgICAgIGlmIChleCAmJiBleC5zdGFjaykge1xuXHQgICAgICAgICAgICBleGMgPSBleDtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGV4YyA9IG5ldyBFcnJvcihleCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBjYWxsYmFjayhleGMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0XG5cdCAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cdCAgICAgIGlmIChyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIpIHtcblx0ICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdCAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJvbGxiYXItQWNjZXNzLVRva2VuJywgYWNjZXNzVG9rZW4pO1xuXHQgICAgICB9XG5cdCAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gb25yZWFkeXN0YXRlY2hhbmdlO1xuXHQgICAgICByZXF1ZXN0LnNlbmQoZGF0YSk7XG5cdCAgICB9IGNhdGNoIChlMSkge1xuXHQgICAgICAvLyBTZW5kaW5nIHVzaW5nIHRoZSBub3JtYWwgeG1saHR0cHJlcXVlc3Qgb2JqZWN0IGRpZG4ndCB3b3JrLCB0cnkgWERvbWFpblJlcXVlc3Rcblx0ICAgICAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XG5cdCAgICAgICAgLy8gQXNzdW1lIHdlIGFyZSBpbiBhIHJlYWxseSBvbGQgYnJvd3NlciB3aGljaCBoYXMgYSBidW5jaCBvZiBsaW1pdGF0aW9uczpcblx0ICAgICAgICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cdFxuXHQgICAgICAgIC8vIEV4dHJlbWUgcGFyYW5vaWE6IGlmIHdlIGhhdmUgWERvbWFpblJlcXVlc3QgdGhlbiB3ZSBoYXZlIGEgd2luZG93LCBidXQganVzdCBpbiBjYXNlXG5cdCAgICAgICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5sb2NhdGlvbikge1xuXHQgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm8gd2luZG93IGF2YWlsYWJsZSBkdXJpbmcgcmVxdWVzdCwgdW5rbm93biBlbnZpcm9ubWVudCcpKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHBhZ2UgaXMgaHR0cCwgdHJ5IGFuZCBzZW5kIG92ZXIgaHR0cFxuXHQgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5zdWJzdHJpbmcoMCwgNSkgPT09ICdodHRwOicgJiYgdXJsLnN1YnN0cmluZygwLCA1KSA9PT0gJ2h0dHBzJykge1xuXHQgICAgICAgICAgdXJsID0gJ2h0dHAnICsgdXJsLnN1YnN0cmluZyg1KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciB4ZG9tYWlucmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHQgICAgICAgIHhkb21haW5yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9O1xuXHQgICAgICAgIHhkb21haW5yZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgdmFyIG1zZyA9ICdSZXF1ZXN0IHRpbWVkIG91dCc7XG5cdCAgICAgICAgICB2YXIgY29kZSA9ICdFVElNRURPVVQnO1xuXHQgICAgICAgICAgY2FsbGJhY2soX25ld1JldHJpYWJsZUVycm9yKG1zZywgY29kZSkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgeGRvbWFpbnJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdFcnJvciBkdXJpbmcgcmVxdWVzdCcpKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHhkb21haW5yZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgdmFyIHBhcnNlUmVzcG9uc2UgPSBfLmpzb25QYXJzZSh4ZG9tYWlucmVxdWVzdC5yZXNwb25zZVRleHQpO1xuXHQgICAgICAgICAgY2FsbGJhY2socGFyc2VSZXNwb25zZS5lcnJvciwgcGFyc2VSZXNwb25zZS52YWx1ZSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB4ZG9tYWlucmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblx0ICAgICAgICB4ZG9tYWlucmVxdWVzdC5zZW5kKGRhdGEpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBtZXRob2QgdG8gdHJhbnNwb3J0IGEgcmVxdWVzdCcpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUyKSB7XG5cdCAgICBjYWxsYmFjayhlMik7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBfY3JlYXRlWE1MSFRUUE9iamVjdCgpIHtcblx0ICAvKiBnbG9iYWwgQWN0aXZlWE9iamVjdDpmYWxzZSAqL1xuXHRcblx0ICB2YXIgZmFjdG9yaWVzID0gW1xuXHQgICAgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICB9LFxuXHQgICAgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7XG5cdCAgICB9LFxuXHQgICAgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMy5YTUxIVFRQJyk7XG5cdCAgICB9LFxuXHQgICAgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdCAgICB9XG5cdCAgXTtcblx0ICB2YXIgeG1saHR0cDtcblx0ICB2YXIgaTtcblx0ICB2YXIgbnVtRmFjdG9yaWVzID0gZmFjdG9yaWVzLmxlbmd0aDtcblx0ICBmb3IgKGkgPSAwOyBpIDwgbnVtRmFjdG9yaWVzOyBpKyspIHtcblx0ICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cdCAgICB0cnkge1xuXHQgICAgICB4bWxodHRwID0gZmFjdG9yaWVzW2ldKCk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAvLyBwYXNzXG5cdCAgICB9XG5cdCAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cdCAgfVxuXHQgIHJldHVybiB4bWxodHRwO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfaXNTdWNjZXNzKHIpIHtcblx0ICByZXR1cm4gciAmJiByLnN0YXR1cyAmJiByLnN0YXR1cyA9PT0gMjAwO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBfaXNOb3JtYWxGYWlsdXJlKHIpIHtcblx0ICByZXR1cm4gciAmJiBfLmlzVHlwZShyLnN0YXR1cywgJ251bWJlcicpICYmIHIuc3RhdHVzID49IDQwMCAmJiByLnN0YXR1cyA8IDYwMDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gX25ld1JldHJpYWJsZUVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcblx0ICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHQgIGVyci5jb2RlID0gY29kZSB8fCAnRU5PVEZPVU5EJztcblx0ICByZXR1cm4gZXJyO1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBnZXQ6IGdldCxcblx0ICBwb3N0OiBwb3N0XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8vIFNlZSBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL3VybC5odG1sXG5cdGZ1bmN0aW9uIHBhcnNlKHVybCkge1xuXHQgIHZhciByZXN1bHQgPSB7XG5cdCAgICBwcm90b2NvbDogbnVsbCwgYXV0aDogbnVsbCwgaG9zdDogbnVsbCwgcGF0aDogbnVsbCxcblx0ICAgIGhhc2g6IG51bGwsIGhyZWY6IHVybCwgaG9zdG5hbWU6IG51bGwsIHBvcnQ6IG51bGwsXG5cdCAgICBwYXRobmFtZTogbnVsbCwgc2VhcmNoOiBudWxsLCBxdWVyeTogbnVsbFxuXHQgIH07XG5cdFxuXHQgIHZhciBpLCBsYXN0O1xuXHQgIGkgPSB1cmwuaW5kZXhPZignLy8nKTtcblx0ICBpZiAoaSAhPT0gLTEpIHtcblx0ICAgIHJlc3VsdC5wcm90b2NvbCA9IHVybC5zdWJzdHJpbmcoMCxpKTtcblx0ICAgIGxhc3QgPSBpKzI7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGxhc3QgPSAwO1xuXHQgIH1cblx0ICBcblx0ICBpID0gdXJsLmluZGV4T2YoJ0AnLCBsYXN0KTtcblx0ICBpZiAoaSAhPT0gLTEpIHtcblx0ICAgIHJlc3VsdC5hdXRoID0gdXJsLnN1YnN0cmluZyhsYXN0LCBpKTtcblx0ICAgIGxhc3QgPSBpKzE7XG5cdCAgfVxuXHRcblx0ICBpID0gdXJsLmluZGV4T2YoJy8nLCBsYXN0KTtcblx0ICBpZiAoaSA9PT0gLTEpIHtcblx0ICAgIGkgPSB1cmwuaW5kZXhPZignPycsIGxhc3QpO1xuXHQgICAgaWYgKGkgPT09IC0xKSB7XG5cdCAgICAgIGkgPSB1cmwuaW5kZXhPZignIycsIGxhc3QpO1xuXHQgICAgICBpZiAoaSA9PT0gLTEpIHtcblx0ICAgICAgICByZXN1bHQuaG9zdCA9IHVybC5zdWJzdHJpbmcobGFzdCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuXHQgICAgICAgIHJlc3VsdC5oYXNoID0gdXJsLnN1YnN0cmluZyhpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzBdO1xuXHQgICAgICByZXN1bHQucG9ydCA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMV07XG5cdCAgICAgIGlmIChyZXN1bHQucG9ydCkge1xuXHQgICAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VJbnQocmVzdWx0LnBvcnQsIDEwKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuXHQgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdC5zcGxpdCgnOicpWzBdO1xuXHQgICAgICByZXN1bHQucG9ydCA9IHJlc3VsdC5ob3N0LnNwbGl0KCc6JylbMV07XG5cdCAgICAgIGlmIChyZXN1bHQucG9ydCkge1xuXHQgICAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VJbnQocmVzdWx0LnBvcnQsIDEwKTtcblx0ICAgICAgfVxuXHQgICAgICBsYXN0ID0gaTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgcmVzdWx0Lmhvc3QgPSB1cmwuc3Vic3RyaW5nKGxhc3QsIGkpO1xuXHQgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3Quc3BsaXQoJzonKVswXTtcblx0ICAgIHJlc3VsdC5wb3J0ID0gcmVzdWx0Lmhvc3Quc3BsaXQoJzonKVsxXTtcblx0ICAgIGlmIChyZXN1bHQucG9ydCkge1xuXHQgICAgICByZXN1bHQucG9ydCA9IHBhcnNlSW50KHJlc3VsdC5wb3J0LCAxMCk7XG5cdCAgICB9XG5cdCAgICBsYXN0ID0gaTtcblx0ICB9XG5cdFxuXHQgIGkgPSB1cmwuaW5kZXhPZignIycsIGxhc3QpO1xuXHQgIGlmIChpID09PSAtMSkge1xuXHQgICAgcmVzdWx0LnBhdGggPSB1cmwuc3Vic3RyaW5nKGxhc3QpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXN1bHQucGF0aCA9IHVybC5zdWJzdHJpbmcobGFzdCwgaSk7XG5cdCAgICByZXN1bHQuaGFzaCA9IHVybC5zdWJzdHJpbmcoaSk7XG5cdCAgfVxuXHRcblx0ICBpZiAocmVzdWx0LnBhdGgpIHtcblx0ICAgIHZhciBwYXRoUGFydHMgPSByZXN1bHQucGF0aC5zcGxpdCgnPycpO1xuXHQgICAgcmVzdWx0LnBhdGhuYW1lID0gcGF0aFBhcnRzWzBdO1xuXHQgICAgcmVzdWx0LnF1ZXJ5ID0gcGF0aFBhcnRzWzFdO1xuXHQgICAgcmVzdWx0LnNlYXJjaCA9IHJlc3VsdC5xdWVyeSA/ICc/JyArIHJlc3VsdC5xdWVyeSA6IG51bGw7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIHBhcnNlOiBwYXJzZVxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBlcnJvclBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHRmdW5jdGlvbiBoYW5kbGVJdGVtV2l0aEVycm9yKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgaXRlbS5kYXRhID0gaXRlbS5kYXRhIHx8IHt9O1xuXHQgIGlmIChpdGVtLmVycikge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgaXRlbS5zdGFja0luZm8gPSBpdGVtLmVyci5fc2F2ZWRTdGFja1RyYWNlIHx8IGVycm9yUGFyc2VyLnBhcnNlKGl0ZW0uZXJyKTtcblx0ICAgIH0gY2F0Y2ggKGUpXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAge1xuXHQgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHdoaWxlIHBhcnNpbmcgdGhlIGVycm9yIG9iamVjdC4nLCBlKTtcblx0ICAgICAgaXRlbS5tZXNzYWdlID0gaXRlbS5lcnIubWVzc2FnZSB8fCBpdGVtLmVyci5kZXNjcmlwdGlvbiB8fCBpdGVtLm1lc3NhZ2UgfHwgU3RyaW5nKGl0ZW0uZXJyKTtcblx0ICAgICAgZGVsZXRlIGl0ZW0uZXJyO1xuXHQgICAgfVxuXHQgIH1cblx0ICBjYWxsYmFjayhudWxsLCBpdGVtKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZW5zdXJlSXRlbUhhc1NvbWV0aGluZ1RvU2F5KGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFpdGVtLm1lc3NhZ2UgJiYgIWl0ZW0uc3RhY2tJbmZvICYmICFpdGVtLmN1c3RvbSkge1xuXHQgICAgY2FsbGJhY2sobmV3IEVycm9yKCdObyBtZXNzYWdlLCBzdGFjayBpbmZvLCBvciBjdXN0b20gZGF0YScpLCBudWxsKTtcblx0ICB9XG5cdCAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGFkZEJhc2VJbmZvKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgdmFyIGVudmlyb25tZW50ID0gb3B0aW9ucy5lbnZpcm9ubWVudCB8fCAob3B0aW9ucy5wYXlsb2FkICYmIG9wdGlvbnMucGF5bG9hZC5lbnZpcm9ubWVudCk7XG5cdCAgaXRlbS5kYXRhID0gXy5leHRlbmQodHJ1ZSwge30sIGl0ZW0uZGF0YSwge1xuXHQgICAgZW52aXJvbm1lbnQ6IGVudmlyb25tZW50LFxuXHQgICAgbGV2ZWw6IGl0ZW0ubGV2ZWwsXG5cdCAgICBlbmRwb2ludDogb3B0aW9ucy5lbmRwb2ludCxcblx0ICAgIHBsYXRmb3JtOiAnYnJvd3NlcicsXG5cdCAgICBmcmFtZXdvcms6ICdicm93c2VyLWpzJyxcblx0ICAgIGxhbmd1YWdlOiAnamF2YXNjcmlwdCcsXG5cdCAgICBzZXJ2ZXI6IHt9LFxuXHQgICAgbm90aWZpZXI6IHtcblx0ICAgICAgbmFtZTogJ3JvbGxiYXItYnJvd3Nlci1qcycsXG5cdCAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvblxuXHQgICAgfVxuXHQgIH0pO1xuXHQgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhZGRSZXF1ZXN0SW5mbyh3aW5kb3cpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24oaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0ICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cubG9jYXRpb24pIHtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuXHQgICAgfVxuXHQgICAgXy5zZXQoaXRlbSwgJ2RhdGEucmVxdWVzdCcsIHtcblx0ICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcblx0ICAgICAgcXVlcnlfc3RyaW5nOiB3aW5kb3cubG9jYXRpb24uc2VhcmNoLFxuXHQgICAgICB1c2VyX2lwOiAnJHJlbW90ZV9pcCdcblx0ICAgIH0pO1xuXHQgICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG5cdCAgfTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkQ2xpZW50SW5mbyh3aW5kb3cpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24oaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0ICAgIGlmICghd2luZG93KSB7XG5cdCAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpdGVtKTtcblx0ICAgIH1cblx0ICAgIF8uc2V0KGl0ZW0sICdkYXRhLmNsaWVudCcsIHtcblx0ICAgICAgcnVudGltZV9tczogaXRlbS50aW1lc3RhbXAgLSB3aW5kb3cuX3JvbGxiYXJTdGFydFRpbWUsXG5cdCAgICAgIHRpbWVzdGFtcDogTWF0aC5yb3VuZChpdGVtLnRpbWVzdGFtcCAvIDEwMDApLFxuXHQgICAgICBqYXZhc2NyaXB0OiB7XG5cdCAgICAgICAgYnJvd3Nlcjogd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQsXG5cdCAgICAgICAgbGFuZ3VhZ2U6IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UsXG5cdCAgICAgICAgY29va2llX2VuYWJsZWQ6IHdpbmRvdy5uYXZpZ2F0b3IuY29va2llRW5hYmxlZCxcblx0ICAgICAgICBzY3JlZW46IHtcblx0ICAgICAgICAgIHdpZHRoOiB3aW5kb3cuc2NyZWVuLndpZHRoLFxuXHQgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuc2NyZWVuLmhlaWdodFxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcblx0ICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhZGRQbHVnaW5JbmZvKHdpbmRvdykge1xuXHQgIHJldHVybiBmdW5jdGlvbihpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5uYXZpZ2F0b3IpIHtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuXHQgICAgfVxuXHQgICAgdmFyIHBsdWdpbnMgPSBbXTtcblx0ICAgIHZhciBuYXZQbHVnaW5zID0gd2luZG93Lm5hdmlnYXRvci5wbHVnaW5zIHx8IFtdO1xuXHQgICAgdmFyIGN1cjtcblx0ICAgIGZvciAodmFyIGk9MCwgbD1uYXZQbHVnaW5zLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQgICAgICBjdXIgPSBuYXZQbHVnaW5zW2ldO1xuXHQgICAgICBwbHVnaW5zLnB1c2goe25hbWU6IGN1ci5uYW1lLCBkZXNjcmlwdGlvbjogY3VyLmRlc2NyaXB0aW9ufSk7XG5cdCAgICB9XG5cdCAgICBfLnNldChpdGVtLCAnZGF0YS5jbGllbnQuamF2YXNjcmlwdC5wbHVnaW5zJywgcGx1Z2lucyk7XG5cdCAgICBjYWxsYmFjayhudWxsLCBpdGVtKTtcblx0ICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhZGRCb2R5KGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKGl0ZW0uc3RhY2tJbmZvKSB7XG5cdCAgICBhZGRCb2R5VHJhY2UoaXRlbSwgb3B0aW9ucywgY2FsbGJhY2spO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBhZGRCb2R5TWVzc2FnZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBhZGRCb2R5TWVzc2FnZShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgIHZhciBtZXNzYWdlID0gaXRlbS5tZXNzYWdlO1xuXHQgIHZhciBjdXN0b20gPSBpdGVtLmN1c3RvbTtcblx0XG5cdCAgaWYgKCFtZXNzYWdlKSB7XG5cdCAgICBpZiAoY3VzdG9tKSB7XG5cdCAgICAgIHZhciBzY3J1YkZpZWxkcyA9IG9wdGlvbnMuc2NydWJGaWVsZHM7XG5cdCAgICAgIHZhciBtZXNzYWdlUmVzdWx0ID0gXy5zdHJpbmdpZnkoXy5zY3J1YihjdXN0b20sIHNjcnViRmllbGRzKSk7XG5cdCAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlUmVzdWx0LmVycm9yIHx8IG1lc3NhZ2VSZXN1bHQudmFsdWUgfHwgJyc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtZXNzYWdlID0gJyc7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSB7XG5cdCAgICBib2R5OiBtZXNzYWdlXG5cdCAgfTtcblx0XG5cdCAgaWYgKGN1c3RvbSkge1xuXHQgICAgcmVzdWx0LmV4dHJhID0gXy5leHRlbmQodHJ1ZSwge30sIGN1c3RvbSk7XG5cdCAgfVxuXHRcblx0ICBfLnNldChpdGVtLCAnZGF0YS5ib2R5Jywge21lc3NhZ2U6IHJlc3VsdH0pO1xuXHQgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gYWRkQm9keVRyYWNlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgdmFyIGRlc2NyaXB0aW9uID0gaXRlbS5kYXRhLmRlc2NyaXB0aW9uO1xuXHQgIHZhciBzdGFja0luZm8gPSBpdGVtLnN0YWNrSW5mbztcblx0ICB2YXIgY3VzdG9tID0gaXRlbS5jdXN0b207XG5cdFxuXHQgIHZhciBndWVzcyA9IGVycm9yUGFyc2VyLmd1ZXNzRXJyb3JDbGFzcyhzdGFja0luZm8ubWVzc2FnZSk7XG5cdCAgdmFyIGNsYXNzTmFtZSA9IHN0YWNrSW5mby5uYW1lIHx8IGd1ZXNzWzBdO1xuXHQgIHZhciBtZXNzYWdlID0gZ3Vlc3NbMV07XG5cdCAgdmFyIHRyYWNlID0ge1xuXHQgICAgZXhjZXB0aW9uOiB7XG5cdCAgICAgICdjbGFzcyc6IGNsYXNzTmFtZSxcblx0ICAgICAgbWVzc2FnZTogbWVzc2FnZVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIGlmIChkZXNjcmlwdGlvbikge1xuXHQgICAgdHJhY2UuZXhjZXB0aW9uLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gfHwgJ3VuY2F1Z2h0IGV4Y2VwdGlvbic7XG5cdCAgfVxuXHRcblx0ICAvLyBUcmFuc2Zvcm0gYSBUcmFjZUtpdCBzdGFja0luZm8gb2JqZWN0IGludG8gYSBSb2xsYmFyIHRyYWNlXG5cdCAgdmFyIHN0YWNrID0gc3RhY2tJbmZvLnN0YWNrO1xuXHQgIGlmIChzdGFjayAmJiBzdGFjay5sZW5ndGggPT09IDAgJiYgaXRlbS5fdW5oYW5kbGVkU3RhY2tJbmZvICYmIGl0ZW0uX3VuaGFuZGxlZFN0YWNrSW5mby5zdGFjaykge1xuXHQgICAgc3RhY2sgPSBpdGVtLl91bmhhbmRsZWRTdGFja0luZm8uc3RhY2s7XG5cdCAgfVxuXHQgIGlmIChzdGFjaykge1xuXHQgICAgdmFyIHN0YWNrRnJhbWU7XG5cdCAgICB2YXIgZnJhbWU7XG5cdCAgICB2YXIgY29kZTtcblx0ICAgIHZhciBwcmU7XG5cdCAgICB2YXIgcG9zdDtcblx0ICAgIHZhciBjb250ZXh0TGVuZ3RoO1xuXHQgICAgdmFyIGksIG1pZDtcblx0XG5cdCAgICB0cmFjZS5mcmFtZXMgPSBbXTtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuXHQgICAgICBzdGFja0ZyYW1lID0gc3RhY2tbaV07XG5cdCAgICAgIGZyYW1lID0ge1xuXHQgICAgICAgIGZpbGVuYW1lOiBzdGFja0ZyYW1lLnVybCA/IF8uc2FuaXRpemVVcmwoc3RhY2tGcmFtZS51cmwpIDogJyh1bmtub3duKScsXG5cdCAgICAgICAgbGluZW5vOiBzdGFja0ZyYW1lLmxpbmUgfHwgbnVsbCxcblx0ICAgICAgICBtZXRob2Q6ICghc3RhY2tGcmFtZS5mdW5jIHx8IHN0YWNrRnJhbWUuZnVuYyA9PT0gJz8nKSA/ICdbYW5vbnltb3VzXScgOiBzdGFja0ZyYW1lLmZ1bmMsXG5cdCAgICAgICAgY29sbm86IHN0YWNrRnJhbWUuY29sdW1uXG5cdCAgICAgIH07XG5cdFxuXHQgICAgICBjb2RlID0gcHJlID0gcG9zdCA9IG51bGw7XG5cdCAgICAgIGNvbnRleHRMZW5ndGggPSBzdGFja0ZyYW1lLmNvbnRleHQgPyBzdGFja0ZyYW1lLmNvbnRleHQubGVuZ3RoIDogMDtcblx0ICAgICAgaWYgKGNvbnRleHRMZW5ndGgpIHtcblx0ICAgICAgICBtaWQgPSBNYXRoLmZsb29yKGNvbnRleHRMZW5ndGggLyAyKTtcblx0ICAgICAgICBwcmUgPSBzdGFja0ZyYW1lLmNvbnRleHQuc2xpY2UoMCwgbWlkKTtcblx0ICAgICAgICBjb2RlID0gc3RhY2tGcmFtZS5jb250ZXh0W21pZF07XG5cdCAgICAgICAgcG9zdCA9IHN0YWNrRnJhbWUuY29udGV4dC5zbGljZShtaWQpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoY29kZSkge1xuXHQgICAgICAgIGZyYW1lLmNvZGUgPSBjb2RlO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAocHJlIHx8IHBvc3QpIHtcblx0ICAgICAgICBmcmFtZS5jb250ZXh0ID0ge307XG5cdCAgICAgICAgaWYgKHByZSAmJiBwcmUubGVuZ3RoKSB7XG5cdCAgICAgICAgICBmcmFtZS5jb250ZXh0LnByZSA9IHByZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHBvc3QgJiYgcG9zdC5sZW5ndGgpIHtcblx0ICAgICAgICAgIGZyYW1lLmNvbnRleHQucG9zdCA9IHBvc3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoc3RhY2tGcmFtZS5hcmdzKSB7XG5cdCAgICAgICAgZnJhbWUuYXJncyA9IHN0YWNrRnJhbWUuYXJncztcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdHJhY2UuZnJhbWVzLnB1c2goZnJhbWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIE5PVEUoY29yeSk6IHJldmVyc2UgdGhlIGZyYW1lcyBzaW5jZSByb2xsYmFyLmNvbSBleHBlY3RzIHRoZSBtb3N0IHJlY2VudCBjYWxsIGxhc3Rcblx0ICAgIHRyYWNlLmZyYW1lcy5yZXZlcnNlKCk7XG5cdFxuXHQgICAgaWYgKGN1c3RvbSkge1xuXHQgICAgICB0cmFjZS5leHRyYSA9IF8uZXh0ZW5kKHRydWUsIHt9LCBjdXN0b20pO1xuXHQgICAgfVxuXHQgICAgXy5zZXQoaXRlbSwgJ2RhdGEuYm9keScsIHt0cmFjZTogdHJhY2V9KTtcblx0ICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpdGVtLm1lc3NhZ2UgPSBjbGFzc05hbWUgKyAnOiAnICsgbWVzc2FnZTtcblx0ICAgIGFkZEJvZHlNZXNzYWdlKGl0ZW0sIG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNjcnViUGF5bG9hZChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgIHZhciBzY3J1YkZpZWxkcyA9IG9wdGlvbnMuc2NydWJGaWVsZHM7XG5cdCAgXy5zY3J1YihpdGVtLmRhdGEsIHNjcnViRmllbGRzKTtcblx0ICBjYWxsYmFjayhudWxsLCBpdGVtKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gdXNlclRyYW5zZm9ybShpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgIHZhciBuZXdJdGVtID0gXy5leHRlbmQodHJ1ZSwge30sIGl0ZW0pO1xuXHQgIHRyeSB7XG5cdCAgICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMudHJhbnNmb3JtKSkge1xuXHQgICAgICBvcHRpb25zLnRyYW5zZm9ybShuZXdJdGVtLmRhdGEpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIG9wdGlvbnMudHJhbnNmb3JtID0gbnVsbDtcblx0ICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgY2FsbGluZyBjdXN0b20gdHJhbnNmb3JtKCkgZnVuY3Rpb24uIFJlbW92aW5nIGN1c3RvbSB0cmFuc2Zvcm0oKS4nLCBlKTtcblx0ICAgIGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBjYWxsYmFjayhudWxsLCBuZXdJdGVtKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXRlbVRvUGF5bG9hZChpdGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgIHZhciBwYXlsb2FkT3B0aW9ucyA9IG9wdGlvbnMucGF5bG9hZCB8fCB7fTtcblx0ICBpZiAocGF5bG9hZE9wdGlvbnMuYm9keSkge1xuXHQgICAgZGVsZXRlIHBheWxvYWRPcHRpb25zLmJvZHk7XG5cdCAgfVxuXHRcblx0ICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHRydWUsIHt9LCBpdGVtLmRhdGEsIHBheWxvYWRPcHRpb25zKTtcblx0ICBpZiAoaXRlbS5faXNVbmNhdWdodCkge1xuXHQgICAgZGF0YS5faXNVbmNhdWdodCA9IHRydWU7XG5cdCAgfVxuXHQgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBoYW5kbGVJdGVtV2l0aEVycm9yOiBoYW5kbGVJdGVtV2l0aEVycm9yLFxuXHQgIGVuc3VyZUl0ZW1IYXNTb21ldGhpbmdUb1NheTogZW5zdXJlSXRlbUhhc1NvbWV0aGluZ1RvU2F5LFxuXHQgIGFkZEJhc2VJbmZvOiBhZGRCYXNlSW5mbyxcblx0ICBhZGRSZXF1ZXN0SW5mbzogYWRkUmVxdWVzdEluZm8sXG5cdCAgYWRkQ2xpZW50SW5mbzogYWRkQ2xpZW50SW5mbyxcblx0ICBhZGRQbHVnaW5JbmZvOiBhZGRQbHVnaW5JbmZvLFxuXHQgIGFkZEJvZHk6IGFkZEJvZHksXG5cdCAgc2NydWJQYXlsb2FkOiBzY3J1YlBheWxvYWQsXG5cdCAgdXNlclRyYW5zZm9ybTogdXNlclRyYW5zZm9ybSxcblx0ICBpdGVtVG9QYXlsb2FkOiBpdGVtVG9QYXlsb2FkXG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBFcnJvclN0YWNrUGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHR2YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc/Jztcblx0dmFyIEVSUl9DTEFTU19SRUdFWFAgPSBuZXcgUmVnRXhwKCdeKChbYS16QS1aMC05LV8kIF0qKTogKik/KFVuY2F1Z2h0ICk/KFthLXpBLVowLTktXyQgXSopOiAnKTtcblx0XG5cdGZ1bmN0aW9uIGd1ZXNzRnVuY3Rpb25OYW1lKCkge1xuXHQgIHJldHVybiBVTktOT1dOX0ZVTkNUSU9OO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZ2F0aGVyQ29udGV4dCgpIHtcblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIEZyYW1lKHN0YWNrRnJhbWUpIHtcblx0ICB2YXIgZGF0YSA9IHt9O1xuXHRcblx0ICBkYXRhLl9zdGFja0ZyYW1lID0gc3RhY2tGcmFtZTtcblx0XG5cdCAgZGF0YS51cmwgPSBzdGFja0ZyYW1lLmZpbGVOYW1lO1xuXHQgIGRhdGEubGluZSA9IHN0YWNrRnJhbWUubGluZU51bWJlcjtcblx0ICBkYXRhLmZ1bmMgPSBzdGFja0ZyYW1lLmZ1bmN0aW9uTmFtZTtcblx0ICBkYXRhLmNvbHVtbiA9IHN0YWNrRnJhbWUuY29sdW1uTnVtYmVyO1xuXHQgIGRhdGEuYXJncyA9IHN0YWNrRnJhbWUuYXJncztcblx0XG5cdCAgZGF0YS5jb250ZXh0ID0gZ2F0aGVyQ29udGV4dChkYXRhLnVybCwgZGF0YS5saW5lKTtcblx0XG5cdCAgcmV0dXJuIGRhdGE7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBTdGFjayhleGNlcHRpb24pIHtcblx0ICBmdW5jdGlvbiBnZXRTdGFjaygpIHtcblx0ICAgIHZhciBwYXJzZXJTdGFjayA9IFtdO1xuXHRcblx0ICAgIHRyeSB7XG5cdCAgICAgIHBhcnNlclN0YWNrID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShleGNlcHRpb24pO1xuXHQgICAgfSBjYXRjaChlKSB7XG5cdCAgICAgIHBhcnNlclN0YWNrID0gW107XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIHN0YWNrID0gW107XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZXJTdGFjay5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdGFjay5wdXNoKG5ldyBGcmFtZShwYXJzZXJTdGFja1tpXSkpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBzdGFjaztcblx0ICB9XG5cdFxuXHQgIHJldHVybiB7XG5cdCAgICBzdGFjazogZ2V0U3RhY2soKSxcblx0ICAgIG1lc3NhZ2U6IGV4Y2VwdGlvbi5tZXNzYWdlLFxuXHQgICAgbmFtZTogZXhjZXB0aW9uLm5hbWVcblx0ICB9O1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gcGFyc2UoZSkge1xuXHQgIHJldHVybiBuZXcgU3RhY2soZSk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBndWVzc0Vycm9yQ2xhc3MoZXJyTXNnKSB7XG5cdCAgaWYgKCFlcnJNc2cpIHtcblx0ICAgIHJldHVybiBbJ1Vua25vd24gZXJyb3IuIFRoZXJlIHdhcyBubyBlcnJvciBtZXNzYWdlIHRvIGRpc3BsYXkuJywgJyddO1xuXHQgIH1cblx0ICB2YXIgZXJyQ2xhc3NNYXRjaCA9IGVyck1zZy5tYXRjaChFUlJfQ0xBU1NfUkVHRVhQKTtcblx0ICB2YXIgZXJyQ2xhc3MgPSAnKHVua25vd24pJztcblx0XG5cdCAgaWYgKGVyckNsYXNzTWF0Y2gpIHtcblx0ICAgIGVyckNsYXNzID0gZXJyQ2xhc3NNYXRjaFtlcnJDbGFzc01hdGNoLmxlbmd0aCAtIDFdO1xuXHQgICAgZXJyTXNnID0gZXJyTXNnLnJlcGxhY2UoKGVyckNsYXNzTWF0Y2hbZXJyQ2xhc3NNYXRjaC5sZW5ndGggLSAyXSB8fCAnJykgKyBlcnJDbGFzcyArICc6JywgJycpO1xuXHQgICAgZXJyTXNnID0gZXJyTXNnLnJlcGxhY2UoLyheW1xcc10rfFtcXHNdKyQpL2csICcnKTtcblx0ICB9XG5cdCAgcmV0dXJuIFtlcnJDbGFzcywgZXJyTXNnXTtcblx0fVxuXHRcblx0XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIGd1ZXNzRnVuY3Rpb25OYW1lOiBndWVzc0Z1bmN0aW9uTmFtZSxcblx0ICBndWVzc0Vycm9yQ2xhc3M6IGd1ZXNzRXJyb3JDbGFzcyxcblx0ICBnYXRoZXJDb250ZXh0OiBnYXRoZXJDb250ZXh0LFxuXHQgIHBhcnNlOiBwYXJzZSxcblx0ICBTdGFjazogU3RhY2ssXG5cdCAgRnJhbWU6IEZyYW1lXG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHQgICAgJ3VzZSBzdHJpY3QnO1xuXHQgICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXHRcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgICBpZiAodHJ1ZSkge1xuXHQgICAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcm9vdC5FcnJvclN0YWNrUGFyc2VyID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuXHQgICAgfVxuXHR9KHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuXHQgICAgJ3VzZSBzdHJpY3QnO1xuXHRcblx0ICAgIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrXFw6XFxkKy87XG5cdCAgICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUytcXDpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcblx0ICAgIHZhciBTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQID0gL14oZXZhbEApPyhcXFtuYXRpdmUgY29kZVxcXSk/JC87XG5cdFxuXHQgICAgZnVuY3Rpb24gX21hcChhcnJheSwgZm4sIHRoaXNBcmcpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmbiwgdGhpc0FyZyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBmbi5jYWxsKHRoaXNBcmcsIGFycmF5W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBfZmlsdGVyKGFycmF5LCBmbiwgdGhpc0FyZykge1xuXHQgICAgICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZuLCB0aGlzQXJnKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXNBcmcsIGFycmF5W2ldKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGFycmF5W2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuXHQgICAgICAgICAqIEBwYXJhbSBlcnJvciB7RXJyb3J9XG5cdCAgICAgICAgICogQHJldHVybiBBcnJheVtTdGFja0ZyYW1lXVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZShlcnJvcikge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhKGVycm9yKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZ2l2ZW4gRXJyb3Igb2JqZWN0Jyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXBhcmF0ZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBmcm9tIGEgVVJMLWxpa2Ugc3RyaW5nLlxuXHQgICAgICAgICAqIEBwYXJhbSB1cmxMaWtlIFN0cmluZ1xuXHQgICAgICAgICAqIEByZXR1cm4gQXJyYXlbU3RyaW5nXVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkZXh0cmFjdExvY2F0aW9uKHVybExpa2UpIHtcblx0ICAgICAgICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG5cdCAgICAgICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbdXJsTGlrZV07XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdXJsTGlrZS5yZXBsYWNlKC9bXFwoXFwpXFxzXS9nLCAnJykuc3BsaXQoJzonKTtcblx0ICAgICAgICAgICAgdmFyIGxhc3ROdW1iZXIgPSBsb2NhdGlvblBhcnRzLnBvcCgpO1xuXHQgICAgICAgICAgICB2YXIgcG9zc2libGVOdW1iZXIgPSBsb2NhdGlvblBhcnRzW2xvY2F0aW9uUGFydHMubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChwb3NzaWJsZU51bWJlcikpICYmIGlzRmluaXRlKHBvc3NpYmxlTnVtYmVyKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBsb2NhdGlvblBhcnRzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtsb2NhdGlvblBhcnRzLmpvaW4oJzonKSwgbGluZU51bWJlciwgbGFzdE51bWJlcl07XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW2xvY2F0aW9uUGFydHMuam9pbignOicpLCBsYXN0TnVtYmVyLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0XG5cdCAgICAgICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IF9maWx0ZXIoZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAobGluZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcblx0ICAgICAgICAgICAgfSwgdGhpcyk7XG5cdFxuXHQgICAgICAgICAgICByZXR1cm4gX21hcChmaWx0ZXJlZCwgZnVuY3Rpb24gKGxpbmUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyhldmFsICcpID4gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG5cdCAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csICdldmFsJykucmVwbGFjZSgvKFxcKGV2YWwgYXQgW15cXCgpXSopfChcXClcXCwuKiQpL2csICcnKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCAnKCcpLnNwbGl0KC9cXHMrLykuc2xpY2UoMSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJyAnKSB8fCB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBsb2NhdGlvblBhcnRzWzBdID09PSAnZXZhbCcgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuXHRcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZShmdW5jdGlvbk5hbWUsIHVuZGVmaW5lZCwgZmlsZU5hbWUsIGxvY2F0aW9uUGFydHNbMV0sIGxvY2F0aW9uUGFydHNbMl0sIGxpbmUpO1xuXHQgICAgICAgICAgICB9LCB0aGlzKTtcblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICBwYXJzZUZGT3JTYWZhcmk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlRkZPclNhZmFyaShlcnJvcikge1xuXHQgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBfZmlsdGVyKGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gKGxpbmUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcblx0ICAgICAgICAgICAgfSwgdGhpcyk7XG5cdFxuXHQgICAgICAgICAgICByZXR1cm4gX21hcChmaWx0ZXJlZCwgZnVuY3Rpb24gKGxpbmUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcblx0ICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWxcXDpcXGQrXFw6XFxkKy9nLCAnOiQxJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZXZhbCBmcmFtZXMgb25seSBoYXZlIGZ1bmN0aW9uIG5hbWVzIGFuZCBub3RoaW5nIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUobGluZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuc2hpZnQoKSB8fCB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKGZ1bmN0aW9uTmFtZSwgdW5kZWZpbmVkLCBsb2NhdGlvblBhcnRzWzBdLCBsb2NhdGlvblBhcnRzWzFdLCBsb2NhdGlvblBhcnRzWzJdLCBsaW5lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgdGhpcyk7XG5cdCAgICAgICAgfSxcblx0XG5cdCAgICAgICAgcGFyc2VPcGVyYTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYShlKSB7XG5cdCAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlIHx8IChlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJlxuXHQgICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCFlLnN0YWNrKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTEoZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuXHQgICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcblx0ICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG5cdCAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWF0Y2hbMl0sIG1hdGNoWzFdLCB1bmRlZmluZWQsIGxpbmVzW2ldKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblx0XG5cdCAgICAgICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTAoZSkge1xuXHQgICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuXHQgICAgICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcblx0ICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKG1hdGNoWzNdIHx8IHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtYXRjaFsyXSwgbWF0Y2hbMV0sIHVuZGVmaW5lZCwgbGluZXNbaV0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuXHQgICAgICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IF9maWx0ZXIoZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAobGluZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmXG5cdCAgICAgICAgICAgICAgICAgICAgIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG5cdCAgICAgICAgICAgIH0sIHRoaXMpO1xuXHRcblx0ICAgICAgICAgICAgcmV0dXJuIF9tYXAoZmlsdGVyZWQsIGZ1bmN0aW9uIChsaW5lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9ICh0b2tlbnMuc2hpZnQoKSB8fCAnJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uKDogKFxcdyspKT8+LywgJyQyJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKFteXFwpXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgIHZhciBhcmdzUmF3O1xuXHQgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteXFwpXSopXFwpLykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXlxcKF0rXFwoKFteXFwpXSopXFwpJC8sICckMScpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAoYXJnc1JhdyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3NSYXcgPT09ICdbYXJndW1lbnRzIG5vdCBhdmFpbGFibGVdJykgPyB1bmRlZmluZWQgOiBhcmdzUmF3LnNwbGl0KCcsJyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoZnVuY3Rpb25OYW1lLCBhcmdzLCBsb2NhdGlvblBhcnRzWzBdLCBsb2NhdGlvblBhcnRzWzFdLCBsb2NhdGlvblBhcnRzWzJdLCBsaW5lKTtcblx0ICAgICAgICAgICAgfSwgdGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fSkpO1xuXHRcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdCAgICAndXNlIHN0cmljdCc7XG5cdCAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cdFxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgIGlmICh0cnVlKSB7XG5cdCAgICAgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcm9vdC5TdGFja0ZyYW1lID0gZmFjdG9yeSgpO1xuXHQgICAgfVxuXHR9KHRoaXMsIGZ1bmN0aW9uICgpIHtcblx0ICAgICd1c2Ugc3RyaWN0Jztcblx0ICAgIGZ1bmN0aW9uIF9pc051bWJlcihuKSB7XG5cdCAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBTdGFja0ZyYW1lKGZ1bmN0aW9uTmFtZSwgYXJncywgZmlsZU5hbWUsIGxpbmVOdW1iZXIsIGNvbHVtbk51bWJlciwgc291cmNlKSB7XG5cdCAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uTmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChhcmdzICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5zZXRBcmdzKGFyZ3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZmlsZU5hbWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB0aGlzLnNldEZpbGVOYW1lKGZpbGVOYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB0aGlzLnNldExpbmVOdW1iZXIobGluZU51bWJlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb2x1bW5OdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB0aGlzLnNldENvbHVtbk51bWJlcihjb2x1bW5OdW1iZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG5cdCAgICAgICAgZ2V0RnVuY3Rpb25OYW1lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTmFtZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldEZ1bmN0aW9uTmFtZTogZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWUgPSBTdHJpbmcodik7XG5cdCAgICAgICAgfSxcblx0XG5cdCAgICAgICAgZ2V0QXJnczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0QXJnczogZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5hcmdzID0gdjtcblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICAvLyBOT1RFOiBQcm9wZXJ0eSBuYW1lIG1heSBiZSBtaXNsZWFkaW5nIGFzIGl0IGluY2x1ZGVzIHRoZSBwYXRoLFxuXHQgICAgICAgIC8vIGJ1dCBpdCBzb21ld2hhdCBtaXJyb3JzIFY4J3MgSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGlcblx0ICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGkgYW5kIEdlY2tvJ3Ncblx0ICAgICAgICAvLyBodHRwOi8vbXhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UveHBjb20vYmFzZS9uc0lFeGNlcHRpb24uaWRsIzE0XG5cdCAgICAgICAgZ2V0RmlsZU5hbWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXRGaWxlTmFtZTogZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IFN0cmluZyh2KTtcblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVOdW1iZXI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXRMaW5lTnVtYmVyOiBmdW5jdGlvbiAodikge1xuXHQgICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBOdW1iZXIgbXVzdCBiZSBhIE51bWJlcicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMubGluZU51bWJlciA9IE51bWJlcih2KTtcblx0ICAgICAgICB9LFxuXHRcblx0ICAgICAgICBnZXRDb2x1bW5OdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTnVtYmVyO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0Q29sdW1uTnVtYmVyOiBmdW5jdGlvbiAodikge1xuXHQgICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIE51bWJlciBtdXN0IGJlIGEgTnVtYmVyJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5jb2x1bW5OdW1iZXIgPSBOdW1iZXIodik7XG5cdCAgICAgICAgfSxcblx0XG5cdCAgICAgICAgZ2V0U291cmNlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldFNvdXJjZTogZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBTdHJpbmcodik7XG5cdCAgICAgICAgfSxcblx0XG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAne2Fub255bW91c30nO1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9ICcoJyArICh0aGlzLmdldEFyZ3MoKSB8fCBbXSkuam9pbignLCcpICsgJyknO1xuXHQgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgPyAoJ0AnICsgdGhpcy5nZXRGaWxlTmFtZSgpKSA6ICcnO1xuXHQgICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IF9pc051bWJlcih0aGlzLmdldExpbmVOdW1iZXIoKSkgPyAoJzonICsgdGhpcy5nZXRMaW5lTnVtYmVyKCkpIDogJyc7XG5cdCAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBfaXNOdW1iZXIodGhpcy5nZXRDb2x1bW5OdW1iZXIoKSkgPyAoJzonICsgdGhpcy5nZXRDb2x1bW5OdW1iZXIoKSkgOiAnJztcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArIGFyZ3MgKyBmaWxlTmFtZSArIGxpbmVOdW1iZXIgKyBjb2x1bW5OdW1iZXI7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gU3RhY2tGcmFtZTtcblx0fSkpO1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0XG5cdGZ1bmN0aW9uIGNoZWNrSWdub3JlKGl0ZW0sIHNldHRpbmdzKSB7XG5cdCAgdmFyIGxldmVsID0gaXRlbS5sZXZlbDtcblx0ICB2YXIgbGV2ZWxWYWwgPSBfLkxFVkVMU1tsZXZlbF0gfHwgMDtcblx0ICB2YXIgcmVwb3J0TGV2ZWwgPSBfLkxFVkVMU1tzZXR0aW5ncy5yZXBvcnRMZXZlbF0gfHwgMDtcblx0XG5cdCAgaWYgKGxldmVsVmFsIDwgcmVwb3J0TGV2ZWwpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdFxuXHQgIGlmIChfLmdldChzZXR0aW5ncywgJ3BsdWdpbnMuanF1ZXJ5Lmlnbm9yZUFqYXhFcnJvcnMnKSkge1xuXHQgICAgcmV0dXJuICFfLmdldChpdGVtLCAnYm9keS5tZXNzYWdlLmV4dHJhLmlzQWpheCcpO1xuXHQgIH1cblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gdXNlckNoZWNrSWdub3JlKGl0ZW0sIHNldHRpbmdzKSB7XG5cdCAgdmFyIGlzVW5jYXVnaHQgPSAhIWl0ZW0uX2lzVW5jYXVnaHQ7XG5cdCAgZGVsZXRlIGl0ZW0uX2lzVW5jYXVnaHQ7XG5cdCAgdmFyIGFyZ3MgPSBpdGVtLl9vcmlnaW5hbEFyZ3M7XG5cdCAgZGVsZXRlIGl0ZW0uX29yaWdpbmFsQXJncztcblx0ICB0cnkge1xuXHQgICAgaWYgKF8uaXNGdW5jdGlvbihzZXR0aW5ncy5jaGVja0lnbm9yZSkgJiYgc2V0dGluZ3MuY2hlY2tJZ25vcmUoaXNVbmNhdWdodCwgYXJncywgaXRlbSkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHNldHRpbmdzLmNoZWNrSWdub3JlID0gbnVsbDtcblx0ICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgY2FsbGluZyBjdXN0b20gY2hlY2tJZ25vcmUoKSwgcmVtb3ZpbmcnLCBlKTtcblx0ICB9XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHVybElzV2hpdGVsaXN0ZWQoaXRlbSwgc2V0dGluZ3MpIHtcblx0ICB2YXIgd2hpdGVsaXN0LCB0cmFjZSwgZnJhbWUsIGZpbGVuYW1lLCBmcmFtZUxlbmd0aCwgdXJsLCBsaXN0TGVuZ3RoLCB1cmxSZWdleDtcblx0ICB2YXIgaSwgajtcblx0XG5cdCAgdHJ5IHtcblx0ICAgIHdoaXRlbGlzdCA9IHNldHRpbmdzLmhvc3RXaGl0ZUxpc3Q7XG5cdCAgICBsaXN0TGVuZ3RoID0gd2hpdGVsaXN0ICYmIHdoaXRlbGlzdC5sZW5ndGg7XG5cdCAgICB0cmFjZSA9IF8uZ2V0KGl0ZW0sICdib2R5LnRyYWNlJyk7XG5cdFxuXHQgICAgaWYgKCF3aGl0ZWxpc3QgfHwgbGlzdExlbmd0aCA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICghdHJhY2UgfHwgIXRyYWNlLmZyYW1lcykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICBmcmFtZUxlbmd0aCA9IHRyYWNlLmZyYW1lcy5sZW5ndGg7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVMZW5ndGg7IGkrKykge1xuXHQgICAgICBmcmFtZSA9IHRyYWNlLmZyYW1lc1tpXTtcblx0ICAgICAgZmlsZW5hbWUgPSBmcmFtZS5maWxlbmFtZTtcblx0XG5cdCAgICAgIGlmICghXy5pc1R5cGUoZmlsZW5hbWUsICdzdHJpbmcnKSkge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBmb3IgKGogPSAwOyBqIDwgbGlzdExlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgdXJsID0gd2hpdGVsaXN0W2pdO1xuXHQgICAgICAgIHVybFJlZ2V4ID0gbmV3IFJlZ0V4cCh1cmwpO1xuXHRcblx0ICAgICAgICBpZiAodXJsUmVnZXgudGVzdChmaWxlbmFtZSkpe1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoZSlcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgIHtcblx0ICAgIHNldHRpbmdzLmhvc3RXaGl0ZUxpc3QgPSBudWxsO1xuXHQgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIHlvdXIgY29uZmlndXJhdGlvblxcJ3MgaG9zdFdoaXRlTGlzdCBvcHRpb24uIFJlbW92aW5nIGN1c3RvbSBob3N0V2hpdGVMaXN0LicsIGUpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWVzc2FnZUlzSWdub3JlZChpdGVtLCBzZXR0aW5ncykge1xuXHQgIHZhciBleGNlcHRpb25NZXNzYWdlLCBpLCBpZ25vcmVkTWVzc2FnZXMsXG5cdCAgICAgIGxlbiwgbWVzc2FnZUlzSWdub3JlZCwgcklnbm9yZWRNZXNzYWdlLFxuXHQgICAgICBib2R5LCB0cmFjZU1lc3NhZ2UsIGJvZHlNZXNzYWdlO1xuXHRcblx0ICB0cnkge1xuXHQgICAgbWVzc2FnZUlzSWdub3JlZCA9IGZhbHNlO1xuXHQgICAgaWdub3JlZE1lc3NhZ2VzID0gc2V0dGluZ3MuaWdub3JlZE1lc3NhZ2VzO1xuXHQgICAgXG5cdCAgICBpZiAoIWlnbm9yZWRNZXNzYWdlcyB8fCBpZ25vcmVkTWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIGJvZHkgPSBpdGVtLmJvZHk7XG5cdCAgICB0cmFjZU1lc3NhZ2UgPSBfLmdldChib2R5LCAndHJhY2UuZXhjZXB0aW9uLm1lc3NhZ2UnKTtcblx0ICAgIGJvZHlNZXNzYWdlID0gXy5nZXQoYm9keSwgJ21lc3NhZ2UuYm9keScpO1xuXHRcblx0ICAgIGV4Y2VwdGlvbk1lc3NhZ2UgPSB0cmFjZU1lc3NhZ2UgfHwgYm9keU1lc3NhZ2U7XG5cdFxuXHQgICAgaWYgKCFleGNlcHRpb25NZXNzYWdlKXtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgbGVuID0gaWdub3JlZE1lc3NhZ2VzLmxlbmd0aDtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBySWdub3JlZE1lc3NhZ2UgPSBuZXcgUmVnRXhwKGlnbm9yZWRNZXNzYWdlc1tpXSwgJ2dpJyk7XG5cdCAgICAgIG1lc3NhZ2VJc0lnbm9yZWQgPSBySWdub3JlZE1lc3NhZ2UudGVzdChleGNlcHRpb25NZXNzYWdlKTtcblx0XG5cdCAgICAgIGlmIChtZXNzYWdlSXNJZ25vcmVkKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGNhdGNoKGUpXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICB7XG5cdCAgICBzZXR0aW5ncy5pZ25vcmVkTWVzc2FnZXMgPSBudWxsO1xuXHQgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIHlvdXIgY29uZmlndXJhdGlvblxcJ3MgaWdub3JlZE1lc3NhZ2VzIG9wdGlvbi4gUmVtb3ZpbmcgY3VzdG9tIGlnbm9yZWRNZXNzYWdlcy4nKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiAhbWVzc2FnZUlzSWdub3JlZDtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgY2hlY2tJZ25vcmU6IGNoZWNrSWdub3JlLFxuXHQgIHVzZXJDaGVja0lnbm9yZTogdXNlckNoZWNrSWdub3JlLFxuXHQgIHVybElzV2hpdGVsaXN0ZWQ6IHVybElzV2hpdGVsaXN0ZWQsXG5cdCAgbWVzc2FnZUlzSWdub3JlZDogbWVzc2FnZUlzSWdub3JlZFxuXHR9O1xuXHRcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yb2xsYmFyL2Rpc3Qvcm9sbGJhci5ub2NvbmZsaWN0LnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ])
});
;