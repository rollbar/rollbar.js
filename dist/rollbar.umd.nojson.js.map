{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 6c48d2f70b572a13aa16","webpack:///./src/bundles/rollbar.js","webpack:///./src/globalnotifier.js","webpack:///./src/notifier.js","webpack:///./src/error_parser.js","webpack:///./~/error-stack-parser/error-stack-parser.js","webpack:///./~/stackframe/stackframe.js","webpack:///./src/util.js","webpack:///./src/xhr.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oDAAmD;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;;;;;;;AC1CA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,oBAAoB;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,MAAK;AACL,6CAA4C;AAC5C,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,UAAU,2BAA2B,kBAAkB;AACrE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ,IAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B;AACA,qBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAA+C,aAAa;AAC5D,kBAAiB,aAAa;;AAE9B;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA,0CAAyC,aAAa;AACtD,kBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,qBAAoB,oBAAoB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA0D,cAAc;AACxE,iBAAgB,cAAc;AAC9B;;AAEA;AACA,aAAY,SAAS;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,sBAAsB;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB,iBAAiB,oCAAoC;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,qBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH,qBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,2BAA0B,sBAAsB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,gGAAgG;AACvI,8CAA6C,kHAAkH;;AAE/J;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,0BAA0B;AACrC;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACv9BA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA,oBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA,gDAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA,gDAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,EAAC;;;;;;;;ACrLD;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,4DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC9FD;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA,gBAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;;;;;;AC1LA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,6BAA6B;AAChD,oBAAmB,4CAA4C;AAC/D,oBAAmB,4CAA4C;AAC/D,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"rollbar.umd.nojson.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6c48d2f70b572a13aa16\n **/","/* globals __USE_JSON__ */\n/* globals JSON */\n\n\"use strict\";\n\nvar globalnotifier = require('../globalnotifier');\nvar notifier = require('../notifier');\n\nfunction setupJSON() {\n  var JSONObject = typeof JSON === 'undefined' ? {} : JSON;\n\n  if (__USE_JSON__) {\n    // This adds the script to this context. We need it since this library\n    // is not a CommonJs or AMD module.\n    var setupCustomJSON = require(\"../../vendor/JSON-js/json2.js\");\n\n    var customJSON = {};\n    setupCustomJSON(customJSON);\n\n    JSONObject = customJSON;\n  }\n\n  globalnotifier.setupJSON(JSONObject);\n}\n\nsetupJSON();\n\nvar config = window._rollbarConfig;\nvar alias = config && config.globalAlias || 'Rollbar';\nvar shimRunning = window[alias] && typeof window[alias].shimId !== 'undefined';\n\n/* We must not initialize the full notifier here if the\n * shim is loaded, snippet_callback will do that for us\n */\nif (!shimRunning && config) {\n  globalnotifier.wrapper.init(config);\n} else {\n  window.Rollbar = globalnotifier.wrapper;\n  // We need to expose Notifier for the snippet\n  window.RollbarNotifier = notifier.Notifier;\n}\n\nmodule.exports = globalnotifier.wrapper;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/bundles/rollbar.js\n ** module id = 1\n ** module chunks = 0\n **/","\"use strict\";\n\nvar notifier = require('./notifier');\n\nvar Notifier = notifier.Notifier;\n// Stub out the wrapped error which is set \nwindow._rollbarWrappedError = null;\n\nfunction setupJSON(JSON) {\n  notifier.setupJSON(JSON);\n}\n\n// Global window.onerror handler\nfunction _rollbarWindowOnError(client, old, args) {\n  if (!args[4] && window._rollbarWrappedError) {\n    args[4] = window._rollbarWrappedError;\n    window._rollbarWrappedError = null;\n  }\n\n  client.uncaughtError.apply(client, args);\n  if (old) {\n    old.apply(window, args);\n  }\n}\n\nfunction _extendListenerPrototype(client, prototype) {\n  if (prototype.hasOwnProperty && prototype.hasOwnProperty('addEventListener')) {\n    var oldAddEventListener = prototype.addEventListener;\n    prototype.addEventListener = function(event, callback, bubble) {\n      oldAddEventListener.call(this, event, client.wrap(callback), bubble);\n    };\n\n    var oldRemoveEventListener = prototype.removeEventListener;\n    prototype.removeEventListener = function(event, callback, bubble) {\n      oldRemoveEventListener.call(this, event, callback && callback._wrapped || callback, bubble);\n    };\n  }\n}\n\n// Add an init() method to do the same things that the shim would do\nvar wrapper = {};\nwrapper.init = function(config, parent) {\n  var notifier = new Notifier(parent);\n  notifier.configure(config);\n\n  if (config.captureUncaught) {\n    // Set the global onerror handler\n    var oldOnError;\n\n    // If the parent, probably a shim, stores a oldOnError, use that so we don't\n    // send reports twice.\n    if (parent && typeof parent._rollbarOldOnError !== 'undefined') {\n      oldOnError = parent._rollbarOldOnError;\n    } else {\n      oldOnError = window.onerror;\n    }\n\n    window.onerror = function() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      _rollbarWindowOnError(notifier, oldOnError, args);\n    };\n\n    // Adapted from https://github.com/bugsnag/bugsnag-js\n    var globals = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource',\n     'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController',\n     'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue',\n     'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget',\n     'XMLHttpRequestUpload'];\n\n    var i;\n    var global;\n    for (i = 0; i < globals.length; ++i) {\n      global = globals[i];\n\n      if (window[global] && window[global].prototype) {\n        _extendListenerPrototype(notifier, window[global].prototype);\n      }\n    }\n  }\n\n  window.Rollbar = notifier;\n  // Finally, start processing payloads using the global notifier\n  Notifier.processPayloads();\n  return notifier;\n};\n\n\nmodule.exports = {\n  wrapper: wrapper,\n  setupJSON: setupJSON\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/globalnotifier.js\n ** module id = 2\n ** module chunks = 0\n **/","/* globals __NOTIFIER_VERSION__ */\n/* globals __DEFAULT_ENDPOINT__ */\n/* globals __DEFAULT_SCRUB_FIELDS__ */\n/* globals __DEFAULT_LOG_LEVEL__ */\n/* globals __DEFAULT_REPORT_LEVEL__ */\n/* globals __DEFAULT_UNCAUGHT_ERROR_LEVEL */\n/* globals __DEFAULT_ITEMS_PER_MIN__ */\n/* globals __DEFAULT_MAX_ITEMS__ */\n/* globals DOMException */\n\n\"use strict\";\n\nvar error_parser = require('./error_parser');\nvar Util = require('./util');\nvar xhr = require('./xhr');\n\nvar XHR = xhr.XHR;\nvar RollbarJSON = null;\n\nfunction setupJSON(JSON) {\n  RollbarJSON = JSON;\n  xhr.setupJSON(JSON);\n}\n\n// Updated by the build process to match package.json\nNotifier.NOTIFIER_VERSION = __NOTIFIER_VERSION__;\nNotifier.DEFAULT_ENDPOINT = __DEFAULT_ENDPOINT__;\nNotifier.DEFAULT_SCRUB_FIELDS = __DEFAULT_SCRUB_FIELDS__;\nNotifier.DEFAULT_LOG_LEVEL = __DEFAULT_LOG_LEVEL__;\nNotifier.DEFAULT_REPORT_LEVEL = __DEFAULT_REPORT_LEVEL__;\nNotifier.DEFAULT_UNCAUGHT_ERROR_LEVEL = __DEFAULT_UNCAUGHT_ERROR_LEVEL;\nNotifier.DEFAULT_ITEMS_PER_MIN = __DEFAULT_ITEMS_PER_MIN__;\nNotifier.DEFAULT_MAX_ITEMS = __DEFAULT_MAX_ITEMS__;\n\nNotifier.LEVELS = {\n  debug: 0,\n  info: 1,\n  warning: 2,\n  error: 3,\n  critical: 4\n};\n\n// This is the global queue where all notifiers will put their\n// payloads to be sent to Rollbar.\nwindow._rollbarPayloadQueue = [];\n\n// This contains global options for all Rollbar notifiers.\nwindow._globalRollbarOptions = {\n  startTime: (new Date()).getTime(),\n  maxItems: Notifier.DEFAULT_MAX_ITEMS,\n  itemsPerMinute: Notifier.DEFAULT_ITEMS_PER_MIN\n};\n\nvar _topLevelNotifier;\n\nfunction topLevelNotifier() {\n  return _topLevelNotifier;\n}\n\nfunction Notifier(parentNotifier) {\n  // Save the first notifier so we can use it to send system messages like\n  // when the rate limit is reached.\n  _topLevelNotifier = _topLevelNotifier || this;\n\n  var protocol = window.location.protocol;\n  if (protocol.indexOf('http') !== 0) {\n    protocol = 'https:';\n  }\n  var endpoint = protocol + '//' + Notifier.DEFAULT_ENDPOINT;\n  this.options = {\n    enabled: true,\n    endpoint: endpoint,\n    environment: 'production',\n    scrubFields: Util.copy(Notifier.DEFAULT_SCRUB_FIELDS),\n    checkIgnore: null,\n    logLevel: Notifier.DEFAULT_LOG_LEVEL,\n    reportLevel: Notifier.DEFAULT_REPORT_LEVEL,\n    uncaughtErrorLevel: Notifier.DEFAULT_UNCAUGHT_ERROR_LEVEL,\n    payload: {}\n  };\n\n  this.lastError = null;\n  this.plugins = {};\n  this.parentNotifier = parentNotifier;\n  this.logger = function() {\n    var console = window.console;\n    if (console && typeof console.log === 'function') {\n      var message = (['Rollbar:'].concat(Array.prototype.slice.call(arguments, 0))).join(' ');\n      console.log.apply(console, [message]);\n    }\n  };\n\n  if (parentNotifier) {\n    // If the parent notifier has the shimId\n    // property it means that it's a Rollbar shim.\n    if (parentNotifier.hasOwnProperty('shimId')) {\n      // After we set this, the shim is just a proxy to this\n      // Notifier instance.\n      parentNotifier.notifier = this;\n    } else {\n      this.logger = parentNotifier.logger;\n      this.configure(parentNotifier.options);\n    }\n  }\n}\n\n\nNotifier._generateLogFn = function(level) {\n  return _wrapNotifierFn(function _logFn() {\n    var args = this._getLogArgs(arguments);\n\n    return this._log(level || args.level || this.options.logLevel || Notifier.DEFAULT_LOG_LEVEL,\n        args.message, args.err, args.custom, args.callback);\n  });\n};\n\n\n/*\n * Returns an Object with keys:\n * {\n *  message: String,\n *  err: Error,\n *  custom: Object\n * }\n */\nNotifier.prototype._getLogArgs = function(args) {\n  var level = this.options.logLevel || Notifier.DEFAULT_LOG_LEVEL;\n  var ts;\n  var message;\n  var err;\n  var custom;\n  var callback;\n\n  var argT;\n  var arg;\n  for (var i = 0; i < args.length; ++i) {\n    arg = args[i];\n    argT = typeof arg;\n    if (argT === 'string') {\n      message = arg;\n    } else if (argT === 'function') {\n      callback = _wrapNotifierFn(arg, this);  // wrap the callback in a try/catch block\n    } else if (arg && argT === 'object') {\n      if (arg.constructor.name === 'Date') {\n        ts = arg;\n      } else if (arg instanceof Error ||\n          arg.prototype === Error.prototype ||\n          arg.hasOwnProperty('stack') ||\n          (typeof DOMException !== \"undefined\" && arg instanceof DOMException)) {\n        err = arg;\n      } else {\n        custom = arg;\n      }\n    }\n  }\n\n  // TODO(cory): somehow pass in timestamp too...\n\n  return {\n    level: level,\n    message: message,\n    err: err,\n    custom: custom,\n    callback: callback\n  };\n};\n\n\nNotifier.prototype._route = function(path) {\n  var endpoint = this.options.endpoint;\n\n  var endpointTrailingSlash = /\\/$/.test(endpoint);\n  var pathBeginningSlash = /^\\//.test(path);\n\n  if (endpointTrailingSlash && pathBeginningSlash) {\n    path = path.substring(1);\n  } else if (!endpointTrailingSlash && !pathBeginningSlash) {\n    path = '/' + path;\n  }\n\n  return endpoint + path;\n};\n\n\n/*\n * Given a queue containing each call to the shim, call the\n * corresponding method on this instance.\n *\n * shim queue contains:\n *\n * {shim: Rollbar, method: 'info', args: ['hello world', exc], ts: Date}\n */\nNotifier.prototype._processShimQueue = function(shimQueue) {\n  // implement me\n  var shim;\n  var obj;\n  var tmp;\n  var method;\n  var args;\n  var shimToNotifier = {};\n  var parentShim;\n  var parentNotifier;\n  var notifier;\n\n  // For each of the messages in the shimQueue we need to:\n  // 1. get/create the notifier for that shim\n  // 2. apply the message to the notifier\n  while ((obj = shimQueue.shift())) {\n    shim = obj.shim;\n    method = obj.method;\n    args = obj.args;\n    parentShim = shim.parentShim;\n\n    // Get the current notifier based on the shimId\n    notifier = shimToNotifier[shim.shimId];\n    if (!notifier) {\n\n      // If there is no notifier associated with the shimId\n      // Check to see if there's a parent shim\n      if (parentShim) {\n\n        // If there is a parent shim, get the parent notifier\n        // and create a new notifier for the current shim.\n        parentNotifier = shimToNotifier[parentShim.shimId];\n\n        // Create a new Notifier which will process all of the shim's\n        // messages\n        notifier = new Notifier(parentNotifier);\n      } else {\n        // If there is no parent, assume the shim is the top\n        // level shim and thus, should use this as the notifier.\n        notifier = this;\n      }\n\n      // Save off the shimId->notifier mapping\n      shimToNotifier[shim.shimId] = notifier;\n    }\n\n    if (notifier[method] && typeof notifier[method] === 'function') {\n      notifier[method].apply(notifier, args);\n    }\n  }\n};\n\n\n/*\n * Builds and returns an Object that will be enqueued onto the\n * window._rollbarPayloadQueue array to be sent to Rollbar.\n */\nNotifier.prototype._buildPayload = function(ts, level, message, stackInfo, custom) {\n  var accessToken = this.options.accessToken;\n\n  // NOTE(cory): DEPRECATED\n  // Pass in {payload: {environment: 'production'}} instead of just {environment: 'production'}\n  var environment = this.options.environment;\n\n  var notifierOptions = Util.copy(this.options.payload);\n  var uuid = Util.uuid4();\n\n  if (Notifier.LEVELS[level] === undefined) {\n    throw new Error('Invalid level');\n  }\n\n  if (!message && !stackInfo && !custom) {\n    throw new Error('No message, stack info or custom data');\n  }\n\n  var payloadData = {\n    environment: environment,\n    endpoint: this.options.endpoint,\n    uuid: uuid,\n    level: level,\n    platform: 'browser',\n    framework: 'browser-js',\n    language: 'javascript',\n    body: this._buildBody(message, stackInfo, custom),\n    request: {\n      url: window.location.href,\n      query_string: window.location.search,\n      user_ip: \"$remote_ip\"\n    },\n    client: {\n      runtime_ms: ts.getTime() - window._globalRollbarOptions.startTime,\n      timestamp: Math.round(ts.getTime() / 1000),\n      javascript: {\n        browser: window.navigator.userAgent,\n        language: window.navigator.language,\n        cookie_enabled: window.navigator.cookieEnabled,\n        screen: {\n          width: window.screen.width,\n          height: window.screen.height\n        },\n        plugins: this._getBrowserPlugins()\n      }\n    },\n    server: {},\n    notifier: {\n      name: 'rollbar-browser-js',\n      version: Notifier.NOTIFIER_VERSION\n    }\n  };\n\n  if (notifierOptions.body) {\n    delete notifierOptions.body;\n  }\n\n  // Overwrite the options from configure() with the payload\n  // data.\n  var payload = {\n    access_token: accessToken,\n    data: Util.merge(payloadData, notifierOptions)\n  };\n\n  // Only scrub the data section since we never want to scrub \"access_token\"\n  // even if it's in the scrub fields\n  this._scrub(payload.data);\n\n  return payload;\n};\n\n\nNotifier.prototype._buildBody = function(message, stackInfo, custom) {\n  var body;\n  if (stackInfo) {\n    body = this._buildPayloadBodyTrace(message, stackInfo, custom);\n  } else {\n    body = this._buildPayloadBodyMessage(message, custom);\n  }\n  return body;\n};\n\n\nNotifier.prototype._buildPayloadBodyMessage = function(message, custom) {\n  if (!message) {\n    if (custom) {\n      message = RollbarJSON.stringify(custom);\n    } else {\n      message = '';\n    }\n  }\n  var result = {\n    body: message\n  };\n\n  if (custom) {\n    result.extra = Util.copy(custom);\n  }\n\n  return {\n    message: result\n  };\n};\n\n\nNotifier.prototype._buildPayloadBodyTrace = function(description, stackInfo, custom) {\n  var guess = _guessErrorClass(stackInfo.message);\n  var className = stackInfo.name || guess[0];\n  var message = guess[1];\n  var trace = {\n    exception: {\n      'class': className,\n      message: message\n    }\n  };\n\n  if (description) {\n    trace.exception.description = description || 'uncaught exception';\n  }\n\n  // Transform a TraceKit stackInfo object into a Rollbar trace\n  if (stackInfo.stack) {\n    var stackFrame;\n    var frame;\n    var code;\n    var pre;\n    var post;\n    var contextLength;\n    var i, j, mid;\n\n    trace.frames = [];\n    for (i = 0; i < stackInfo.stack.length; ++i) {\n      stackFrame = stackInfo.stack[i];\n      frame = {\n        filename: stackFrame.url ? Util.sanitizeUrl(stackFrame.url) : '(unknown)',\n        lineno: stackFrame.line || null,\n        method: (!stackFrame.func || stackFrame.func === '?') ? '[anonymous]' : stackFrame.func,\n        colno: stackFrame.column\n      };\n\n      code = pre = post = null;\n      contextLength = stackFrame.context ? stackFrame.context.length : 0;\n      if (contextLength) {\n        mid = Math.floor(contextLength / 2);\n        pre = stackFrame.context.slice(0, mid);\n        code = stackFrame.context[mid];\n        post = stackFrame.context.slice(mid);\n      }\n\n      if (code) {\n        frame.code = code;\n      }\n\n      if (pre || post) {\n        frame.context = {};\n        if (pre && pre.length) {\n          frame.context.pre = pre;\n        }\n        if (post && post.length) {\n          frame.context.post = post;\n        }\n      }\n\n      if (stackFrame.args) {\n        frame.args = stackFrame.args;\n      }\n\n      trace.frames.push(frame);\n    }\n\n    // NOTE(cory): reverse the frames since rollbar.com expects the most recent call last\n    trace.frames.reverse();\n\n    if (custom) {\n      trace.extra = Util.copy(custom);\n    }\n    return {trace: trace};\n  } else {\n    // no frames - not useful as a trace. just report as a message.\n    return this._buildPayloadBodyMessage(className + ': ' + message, custom);\n  }\n};\n\n\nNotifier.prototype._getBrowserPlugins = function() {\n  if (!this._browserPlugins) {\n    var navPlugins = window.navigator.plugins || [];\n    var cur;\n    var numPlugins = navPlugins.length;\n    var plugins = [];\n    var i;\n    for (i = 0; i < numPlugins; ++i) {\n      cur = navPlugins[i];\n      plugins.push({name: cur.name, description: cur.description});\n    }\n    this._browserPlugins = plugins;\n  }\n  return this._browserPlugins;\n};\n\n\n/*\n * Does an in-place modification of obj such that:\n * 1. All keys that match the notifier's options.scrubFields\n *    list will be normalized into all '*'\n * 2. Any query string params that match the same criteria will have\n *    their values normalized as well.\n */\nNotifier.prototype._scrub = function(obj) {\n  function redactQueryParam(match, paramPart, dummy1,\n      dummy2, dummy3, valPart, offset, string) {\n    return paramPart + Util.redact(valPart);\n  }\n\n  function paramScrubber(v) {\n    var i;\n    if (typeof v === 'string') {\n      for (i = 0; i < queryRes.length; ++i) {\n        v = v.replace(queryRes[i], redactQueryParam);\n      }\n    }\n    return v;\n  }\n\n  function valScrubber(k, v) {\n    var i;\n    for (i = 0; i < paramRes.length; ++i) {\n      if (paramRes[i].test(k)) {\n        v = Util.redact(v);\n        break;\n      }\n    }\n    return v;\n  }\n\n  function scrubber(k, v) {\n    var tmpV = valScrubber(k, v);\n    if (tmpV === v) {\n      return paramScrubber(tmpV);\n    } else {\n      return tmpV;\n    }\n  }\n\n  var scrubFields = this.options.scrubFields;\n  var paramRes = this._getScrubFieldRegexs(scrubFields);\n  var queryRes = this._getScrubQueryParamRegexs(scrubFields);\n\n  Util.traverse(obj, scrubber);\n  return obj;\n};\n\n\nNotifier.prototype._getScrubFieldRegexs = function(scrubFields) {\n  var ret = [];\n  var pat;\n  for (var i = 0; i < scrubFields.length; ++i) {\n    pat = '\\\\[?(%5[bB])?' + scrubFields[i] + '\\\\[?(%5[bB])?\\\\]?(%5[dD])?';\n    ret.push(new RegExp(pat, 'i'));\n  }\n  return ret;\n};\n\n\nNotifier.prototype._getScrubQueryParamRegexs = function(scrubFields) {\n  var ret = [];\n  var pat;\n  for (var i = 0; i < scrubFields.length; ++i) {\n    pat = '\\\\[?(%5[bB])?' + scrubFields[i] + '\\\\[?(%5[bB])?\\\\]?(%5[dD])?';\n    ret.push(new RegExp('(' + pat + '=)([^&\\\\n]+)', 'igm'));\n  }\n  return ret;\n};\n\nNotifier.prototype._urlIsWhitelisted = function(payload){\n  var whitelist, trace, frame, filename, frameLength, url, listLength, urlRegex;\n  var i, j;\n\n  try {\n    whitelist = this.options.hostWhiteList;\n    trace = payload.data.body.trace;\n\n    if (!whitelist || whitelist.length === 0) { return true; }\n    if (!trace) { return true; }\n\n    listLength = whitelist.length;\n    frameLength = trace.frames.length;\n    for (i = 0; i < frameLength; i++) {\n      frame = trace.frames[i];\n      filename = frame.filename;\n      if (typeof filename !== \"string\") { return true; }\n      for (j = 0; j < listLength; j++) {\n        url = whitelist[j];\n        urlRegex = new RegExp(url);\n\n        if (urlRegex.test(filename)){\n          return true;\n        }\n      }\n    }\n  } catch (e) {\n    this.configure({hostWhiteList: null});\n    this.error(\"Error while reading your configuration's hostWhiteList option. Removing custom hostWhiteList.\", e);\n    return true;\n  }\n\n  return false;\n};\n\nNotifier.prototype._messageIsIgnored = function(payload){\n  var exceptionMessage, i, ignoredMessages, len, messageIsIgnored, rIgnoredMessage, trace;\n  try {\n    messageIsIgnored = false;\n    ignoredMessages = this.options.ignoredMessages;\n    trace = payload.data.body.trace;\n\n    if(!ignoredMessages || ignoredMessages.length === 0) { return false; }\n    if(!trace) { return false; }\n    exceptionMessage = trace.exception.message;\n\n    len = ignoredMessages.length;\n    for(i=0; i < len; i++) {\n      rIgnoredMessage = new RegExp(ignoredMessages[i], \"gi\");\n      messageIsIgnored = rIgnoredMessage.test(exceptionMessage);\n\n      if(messageIsIgnored){\n        break;\n      }\n    }\n  }\n  catch(e) {\n    this.configure({ignoredMessages: null});\n    this.error(\"Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.\");\n  }\n\n  return messageIsIgnored;\n};\n\nNotifier.prototype._enqueuePayload = function(payload, isUncaught, callerArgs, callback) {\n\n  var payloadToSend = {\n    callback: callback,\n    accessToken: this.options.accessToken,\n    endpointUrl: this._route('item/'),\n    payload: payload\n  };\n\n  var ignoredCallback = function() {\n    if (callback) {\n      // If the item was ignored call the callback anyway\n      var msg = 'This item was not sent to Rollbar because it was ignored. ' +\n                'This can happen if a custom checkIgnore() function was used ' +\n                'or if the item\\'s level was less than the notifier\\' reportLevel. ' +\n                'See https://rollbar.com/docs/notifier/rollbar.js/configuration for more details.';\n\n      callback(null, {err: 0, result: {id: null, uuid: null, message: msg}});\n    }\n  };\n\n  // Internal checkIgnore will check the level against the minimum\n  // report level from this.options\n  if (this._internalCheckIgnore(isUncaught, callerArgs, payload)) {\n    ignoredCallback();\n    return;\n  }\n\n  // Users can set their own ignore criteria using this.options.checkIgnore()\n  try {\n    if (this.options.checkIgnore &&\n        typeof this.options.checkIgnore === 'function' &&\n        this.options.checkIgnore(isUncaught, callerArgs, payload)) {\n      ignoredCallback();\n      return;\n    }\n  } catch (e) {\n    // Disable the custom checkIgnore and report errors in the checkIgnore function\n    this.configure({checkIgnore: null});\n    this.error('Error while calling custom checkIgnore() function. Removing custom checkIgnore().', e);\n  }\n\n  if (!this._urlIsWhitelisted(payload)) {\n    return;\n  }\n\n  if (this._messageIsIgnored(payload)) {\n    return;\n  }\n\n  if (this.options.verbose) {\n    if (payload.data && payload.data.body && payload.data.body.trace) {\n      var trace = payload.data.body.trace;\n      var exceptionMessage = trace.exception.message;\n      this.logger(exceptionMessage);\n    }\n\n    // FIXME: Some browsers do not output objects as json to the console, and\n    // instead write [object Object], so let's write the message first to ensure that is logged.\n    this.logger('Sending payload -', payloadToSend);\n  }\n\n  if (typeof this.options.logFunction === \"function\") {\n    this.options.logFunction(payloadToSend);\n  }\n\n  try {\n    if (typeof this.options.transform === 'function') {\n      this.options.transform(payload);\n    }\n  } catch (e) {\n    this.configure({transform: null});\n    this.error('Error while calling custom transform() function. Removing custom transform().', e);\n  }\n\n  if (!!this.options.enabled) {\n    window._rollbarPayloadQueue.push(payloadToSend);\n\n    _notifyPayloadAvailable();\n  }\n};\n\n\nNotifier.prototype._internalCheckIgnore = function(isUncaught, callerArgs, payload) {\n  var level = callerArgs[0];\n  var levelVal = Notifier.LEVELS[level] || 0;\n  var reportLevel = Notifier.LEVELS[this.options.reportLevel] || 0;\n\n  if (levelVal < reportLevel) {\n    return true;\n  }\n\n  var plugins = this.options ? this.options.plugins : {};\n  if (plugins && plugins.jquery && plugins.jquery.ignoreAjaxErrors &&\n        payload.body.message) {\n    return payload.body.messagejquery_ajax_error;\n  }\n\n  return false;\n};\n\n\n/*\n * Logs stuff to Rollbar using the default\n * logging level.\n *\n * Can be called with the following, (order doesn't matter but type does):\n * - message: String\n * - err: Error object, must have a .stack property or it will be\n *   treated as custom data\n * - custom: Object containing custom data to be sent along with\n *   the item\n * - callback: Function to call once the item is reported to Rollbar\n * - isUncaught: True if this error originated from an uncaught exception handler\n * - ignoreRateLimit: True if this item should be allowed despite rate limit checks\n */\nNotifier.prototype._log = function(level, message, err, custom, callback, isUncaught, ignoreRateLimit) {\n  var stackInfo = null;\n  if (err) {\n    // If we've already calculated the stack trace for the error, use it.\n    // This can happen for wrapped errors that don't have a \"stack\" property.\n    stackInfo = err._savedStackTrace ? err._savedStackTrace : error_parser.parse(err);\n\n    // Don't report the same error more than once\n    if (err === this.lastError) {\n      return;\n    }\n\n    this.lastError = err;\n  }\n\n  var payload = this._buildPayload(new Date(), level, message, stackInfo, custom);\n  if (ignoreRateLimit) {\n    payload.ignoreRateLimit = true;\n  }\n  this._enqueuePayload(payload, isUncaught ? true : false, [level, message, err, custom], callback);\n};\n\nNotifier.prototype.log = Notifier._generateLogFn();\nNotifier.prototype.debug = Notifier._generateLogFn('debug');\nNotifier.prototype.info = Notifier._generateLogFn('info');\nNotifier.prototype.warn = Notifier._generateLogFn('warning'); // for console.warn() compatibility\nNotifier.prototype.warning = Notifier._generateLogFn('warning');\nNotifier.prototype.error = Notifier._generateLogFn('error');\nNotifier.prototype.critical = Notifier._generateLogFn('critical');\n\n// Adapted from tracekit.js\nNotifier.prototype.uncaughtError = _wrapNotifierFn(function(message, url, lineNo, colNo, err, context) {\n  context = context || null;\n  if (err && err.stack) {\n    this._log(this.options.uncaughtErrorLevel, message, err, context, null, true);\n    return;\n  }\n\n  // NOTE(cory): sometimes users will trigger an \"error\" event\n  // on the window object directly which will result in errMsg\n  // being an Object instead of a string.\n  //\n  if (url && url.stack) {\n    this._log(this.options.uncaughtErrorLevel, message, url, context, null, true);\n    return;\n  }\n\n  var location = {\n    'url': url || '',\n    'line': lineNo\n  };\n  location.func = error_parser.guessFunctionName(location.url, location.line);\n  location.context = error_parser.gatherContext(location.url, location.line);\n  var stack = {\n    'mode': 'onerror',\n    'message': message || 'uncaught exception',\n    'url': document.location.href,\n    'stack': [location],\n    'useragent': navigator.userAgent\n  };\n  if (err) {\n    stack = err._savedStackTrace || error_parser.parse(err);\n  }\n\n  var payload = this._buildPayload(new Date(), this.options.uncaughtErrorLevel, message, stack);\n  this._enqueuePayload(payload, true, [this.options.uncaughtErrorLevel, message, url, lineNo, colNo, err]);\n});\n\n\nNotifier.prototype.global = _wrapNotifierFn(function(options) {\n  options = options || {};\n\n  Util.merge(window._globalRollbarOptions, options);\n\n  if (options.maxItems !== undefined) {\n    rateLimitCounter = 0;\n  }\n\n  if (options.itemsPerMinute !== undefined) {\n    rateLimitPerMinCounter = 0;\n  }\n});\n\n\nNotifier.prototype.configure = _wrapNotifierFn(function(options) {\n  // TODO(cory): only allow non-payload keys that we understand\n\n  // Make a copy of the options object for this notifier\n  Util.merge(this.options, options);\n  this.global(options);\n});\n\n/*\n * Create a new Notifier instance which has the same options\n * as the current notifier + options to override them.\n */\nNotifier.prototype.scope = _wrapNotifierFn(function(payloadOptions) {\n  var scopedNotifier = new Notifier(this);\n  Util.merge(scopedNotifier.options.payload, payloadOptions);\n  return scopedNotifier;\n});\n\nNotifier.prototype.wrap = function(f, context) {\n  try {\n    var _this = this;\n    var ctxFn;\n    if (typeof context === 'function') {\n      ctxFn = context;\n    } else {\n      ctxFn = function() { return context || {}; };\n    }\n\n    if (typeof f !== 'function') {\n      return f;\n    }\n\n    // If the given function is already a wrapped function, just\n    // return it instead of wrapping twice\n    if (f._isWrap) {\n      return f;\n    }\n\n    if (!f._wrapped) {\n      f._wrapped = function () {\n        try {\n          return f.apply(this, arguments);\n        } catch(e) {\n          if (!e.stack) {\n            e._savedStackTrace = error_parser.parse(e);\n          }\n          e._rollbarContext = ctxFn() || {};\n          e._rollbarContext._wrappedSource = f.toString();\n\n          window._rollbarWrappedError = e;\n          throw e;\n        }\n      };\n\n      f._wrapped._isWrap = true;\n\n      for (var prop in f) {\n        if (f.hasOwnProperty(prop)) {\n          f._wrapped[prop] = f[prop];\n        }\n      }\n    }\n\n    return f._wrapped;\n  } catch (e) {\n    // Try-catch here is to work around issue where wrap() fails when used inside Selenium.\n    // Return the original function if the wrap fails.\n    return f;\n  }\n};\n\n/***** Misc *****/\n\nfunction _wrapNotifierFn(fn, ctx) {\n  return function() {\n    var self = ctx || this;\n    try {\n      return fn.apply(self, arguments);\n    } catch (e) {\n      if (self) {\n        self.logger(e);\n      }\n    }\n  };\n}\n\n\nvar ERR_CLASS_REGEXP = new RegExp('^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ');\nfunction _guessErrorClass(errMsg) {\n  if (!errMsg) {\n    return [\"Unknown error. There was no error message to display.\", \"\"];\n  }\n  var errClassMatch = errMsg.match(ERR_CLASS_REGEXP);\n  var errClass = '(unknown)';\n\n  if (errClassMatch) {\n    errClass = errClassMatch[errClassMatch.length - 1];\n    errMsg = errMsg.replace((errClassMatch[errClassMatch.length - 2] || '') + errClass + ':', '');\n    errMsg = errMsg.replace(/(^[\\s]+|[\\s]+$)/g, '');\n  }\n  return [errClass, errMsg];\n}\n\n/***** Payload processor *****/\n\nvar payloadProcessorTimeout;\nNotifier.processPayloads = function(immediate) {\n  if (immediate) {\n    _deferredPayloadProcess();\n\n    return;\n  }\n\n  _notifyPayloadAvailable();\n};\n\nfunction _notifyPayloadAvailable() {\n  if (!payloadProcessorTimeout) {\n    payloadProcessorTimeout = setTimeout(_deferredPayloadProcess, 1000);\n  }\n}\n\nfunction _deferredPayloadProcess() {\n  var payloadObj;\n\n  try {\n    while ((payloadObj = window._rollbarPayloadQueue.shift())) {\n      _processPayload(payloadObj.endpointUrl, payloadObj.accessToken, payloadObj.payload, payloadObj.callback);\n    }\n  } finally {\n    payloadProcessorTimeout = undefined;\n  }\n}\n\n\nvar rateLimitStartTime = new Date().getTime();\nvar rateLimitCounter = 0;\nvar rateLimitPerMinCounter = 0;\nfunction _processPayload(url, accessToken, payload, callback) {\n  callback = callback || function cb() {};\n  var now = new Date().getTime();\n  if (now - rateLimitStartTime >= 60000) {\n    rateLimitStartTime = now;\n    rateLimitPerMinCounter = 0;\n  }\n\n  // Check to see if we have a rate limit set or if\n  // the rate limit has been met/exceeded.\n  var globalRateLimit = window._globalRollbarOptions.maxItems;\n  var globalRateLimitPerMin = window._globalRollbarOptions.itemsPerMinute;\n  var checkOverRateLimit = function() { return !payload.ignoreRateLimit && globalRateLimit >= 1 && rateLimitCounter >= globalRateLimit; };\n  var checkOverRateLimitPerMin = function() { return !payload.ignoreRateLimit && globalRateLimitPerMin >= 1 && rateLimitPerMinCounter >= globalRateLimitPerMin; };\n\n  if (checkOverRateLimit()) {\n    callback(new Error(globalRateLimit + ' max items reached'));\n    return;\n  } else if (checkOverRateLimitPerMin()) {\n    callback(new Error(globalRateLimitPerMin + ' items per minute reached'));\n    return;\n  } else {\n    rateLimitCounter++;\n    rateLimitPerMinCounter++;\n\n    // Check to see if we have just reached the rate limit. If so, notify the customer.\n    if (checkOverRateLimit()) {\n      _topLevelNotifier._log(_topLevelNotifier.options.uncaughtErrorLevel, //level\n          'maxItems has been hit. Ignoring errors for the remainder of the current page load.', // message\n          null, // err\n          {maxItems: globalRateLimit}, // custom\n          null,  // callback\n          false, // isUncaught\n          true); // ignoreRateLimit\n    }\n    // remove this key since it's only used for internal notifier logic\n    if (payload.ignoreRateLimit) {\n      delete payload.ignoreRateLimit;\n    }\n  }\n\n  // There's either no rate limit or we haven't met it yet so\n  // go ahead and send it.\n  XHR.post(url, accessToken, payload, function xhrCallback(err, resp) {\n    if (err) {\n      return callback(err);\n    }\n\n    // TODO(cory): parse resp as JSON\n    return callback(null, resp);\n  });\n\n}\n\nmodule.exports = {\n  Notifier: Notifier,\n  setupJSON: setupJSON,\n  topLevelNotifier: topLevelNotifier\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/notifier.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\n\nvar ErrorStackParser = require('error-stack-parser');\n\nvar UNKNOWN_FUNCTION = '?';\n\n\nfunction guessFunctionName(url, line) {\n  return UNKNOWN_FUNCTION;\n}\n\nfunction gatherContext(url, line) {\n  return null;\n}\n\nfunction Frame(stackFrame) {\n  var data = {};\n\n  data._stackFrame = stackFrame;\n\n  data.url = stackFrame.fileName;\n  data.line = stackFrame.lineNumber;\n  data.func = stackFrame.functionName;\n  data.column = stackFrame.columnNumber;\n  data.args = stackFrame.args;\n\n  data.context = gatherContext(data.url, data.line);\n\n  return data;\n}\n\nfunction Stack(exception) {\n  function getStack() {\n    var parserStack = [];\n\n    try {\n      parserStack = ErrorStackParser.parse(exception);\n    } catch(e) {\n      parserStack = [];\n    }\n\n    var stack = [];\n\n    for (var i = 0; i < parserStack.length; i++) {\n      stack.push(new Frame(parserStack[i]));\n    }\n\n    return stack;\n  }\n\n  return {\n    stack: getStack(),\n    message: exception.message,\n    name: exception.name\n  };\n}\n\nfunction parse(e) {\n  return new Stack(e);\n}\n\nmodule.exports = {\n  guessFunctionName: guessFunctionName,\n  gatherContext: gatherContext,\n  parse: parse,\n  Stack: Stack,\n  Frame: Frame\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/error_parser.js\n ** module id = 4\n ** module chunks = 0\n **/","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /\\s+at /;\n    var map, filter;\n\n    if (Array.prototype.map) {\n        map = function (arr, fn) {\n            return arr.map(fn);\n        };\n    } else {\n        map = function (arr, fn) {\n            var i;\n            var len = arr.length;\n            var ret = [];\n\n            for (i = 0; i < len; ++i) {\n                ret.push(fn(arr[i]));\n            }\n            return ret;\n        };\n    }\n\n    if (Array.prototype.filter) {\n        filter = function (arr, fn) {\n            return arr.filter(fn);\n        };\n    } else {\n        filter = function (arr, fn) {\n            var i;\n            var len = arr.length;\n            var ret = [];\n            for (i = 0; i < len; ++i) {\n                if (fn(arr[i])) {\n                    ret.push(arr[i]);\n                }\n            }\n            return ret;\n        };\n    }\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         * @param error {Error}\n         * @return Array[StackFrame]\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack && error.stack.match(FIREFOX_SAFARI_STACK_REGEXP)) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        /**\n         * Separate line and column numbers from a URL-like string.\n         * @param urlLike String\n         * @return Array[String]\n         */\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var locationParts = urlLike.replace(/[\\(\\)\\s]/g, '').split(':');\n            var lastNumber = locationParts.pop();\n            var possibleNumber = locationParts[locationParts.length - 1];\n            if (!isNaN(parseFloat(possibleNumber)) && isFinite(possibleNumber)) {\n                var lineNumber = locationParts.pop();\n                return [locationParts.join(':'), lineNumber, lastNumber];\n            } else {\n                return [locationParts.join(':'), lastNumber, undefined];\n            }\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var extractLocation = this.extractLocation;\n            var mapped = map(error.stack.split('\\n').slice(1), function (line) {\n                var tokens = line.replace(/^\\s+/, '').split(/\\s+/).slice(1);\n                var locationParts = extractLocation(tokens.pop());\n                var functionName = (!tokens[0] || tokens[0] === 'Anonymous') ? undefined : tokens[0];\n                return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2]);\n            });\n            return mapped;\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = filter(error.stack.split('\\n'), function (line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP);\n            });\n            var extractLocation = this.extractLocation;\n            var mapped = map(filtered, function (line) {\n                var tokens = line.split('@');\n                var locationParts = extractLocation(tokens.pop());\n                var functionName = tokens.shift() || undefined;\n                return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2]);\n            });\n            return mapped;\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(undefined, undefined, match[2], match[1]));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(match[3] || undefined, undefined, match[2], match[1]));\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = filter(error.stack.split('\\n'), function (line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            });\n            var extractLocation = this.extractLocation;\n            var mapped = map(filtered, function (line) {\n                var tokens = line.split('@');\n                var locationParts = extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ? undefined : argsRaw.split(',');\n                return new StackFrame(functionName, args, locationParts[0], locationParts[1], locationParts[2]);\n            });\n            return mapped;\n        }\n    };\n}));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/error-stack-parser/error-stack-parser.js\n ** module id = 5\n ** module chunks = 0\n **/","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function () {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function StackFrame(functionName, args, fileName, lineNumber, columnNumber) {\n        if (functionName !== undefined) {\n            this.setFunctionName(functionName);\n        }\n        if (args !== undefined) {\n            this.setArgs(args);\n        }\n        if (fileName !== undefined) {\n            this.setFileName(fileName);\n        }\n        if (lineNumber !== undefined) {\n            this.setLineNumber(lineNumber);\n        }\n        if (columnNumber !== undefined) {\n            this.setColumnNumber(columnNumber);\n        }\n    }\n\n    StackFrame.prototype = {\n        getFunctionName: function () {\n            return this.functionName;\n        },\n        setFunctionName: function (v) {\n            this.functionName = String(v);\n        },\n\n        getArgs: function () {\n            return this.args;\n        },\n        setArgs: function (v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        // NOTE: Property name may be misleading as it includes the path,\n        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n        getFileName: function () {\n            return this.fileName;\n        },\n        setFileName: function (v) {\n            this.fileName = String(v);\n        },\n\n        getLineNumber: function () {\n            return this.lineNumber;\n        },\n        setLineNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Line Number must be a Number');\n            }\n            this.lineNumber = Number(v);\n        },\n\n        getColumnNumber: function () {\n            return this.columnNumber;\n        },\n        setColumnNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Column Number must be a Number');\n            }\n            this.columnNumber = Number(v);\n        },\n\n        toString: function() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    return StackFrame;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stackframe/stackframe.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\n\nvar Util = {\n  // modified from https://github.com/jquery/jquery/blob/master/src/core.js#L127\n  merge: function() {\n    var options, name, src, copy, copyIsArray, clone,\n      target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = true;\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if (typeof target !== \"object\" && typeof target !== 'function') {\n      target = {};\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) !== null) {\n        // Extend the base object\n        for (name in options) {\n          // IE8 will iterate over properties of objects like \"indexOf\"\n          if (!options.hasOwnProperty(name)) {\n            continue;\n          }\n\n          src = target[name];\n          copy = options[name];\n\n          // Prevent never-ending loop\n          if (target === copy) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (copy.constructor === Object || (copyIsArray = (copy.constructor === Array)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              // Overwrite the source with a copy of the array to merge in\n              clone = [];\n            } else {\n              clone = src && src.constructor === Object ? src : {};\n            }\n\n            // Never move original objects, clone them\n            target[name] = Util.merge(clone, copy);\n\n          // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n\n    // Return the modified object\n    return target;\n  },\n\n  copy: function(obj) {\n    var dest;\n    if (typeof obj === 'object') {\n      if (obj.constructor === Object) {\n        dest = {};\n      } else if (obj.constructor === Array) {\n        dest = [];\n      }\n    }\n\n    Util.merge(dest, obj);\n    return dest;\n  },\n\n  parseUriOptions: {\n    strictMode: false,\n    key: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n    q:   {\n      name:   \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  },\n\n  parseUri: function(str) {\n    if (!str || (typeof str !== 'string' && !(str instanceof String))) {\n      throw new Error('Util.parseUri() received invalid input');\n    }\n\n    var o = Util.parseUriOptions;\n    var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n    var uri = {};\n    var i = 14;\n\n    while (i--) {\n      uri[o.key[i]] = m[i] || \"\";\n    }\n\n    uri[o.q.name] = {};\n    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n      if ($1) {\n        uri[o.q.name][$1] = $2;\n      }\n    });\n\n    return uri;\n  },\n\n  sanitizeUrl: function(url) {\n    if (!url || (typeof url !== 'string' && !(url instanceof String))) {\n      throw new Error('Util.sanitizeUrl() received invalid input');\n    }\n\n    var baseUrlParts = Util.parseUri(url);\n    // remove a trailing # if there is no anchor\n    if (baseUrlParts.anchor === '') {\n      baseUrlParts.source = baseUrlParts.source.replace('#', '');\n    }\n\n    url = baseUrlParts.source.replace('?' + baseUrlParts.query, '');\n    return url;\n  },\n\n  traverse: function(obj, func) {\n    var k;\n    var v;\n    var i;\n    var isObj = typeof obj === 'object';\n    var keys = [];\n\n    if (isObj) {\n      if (obj.constructor === Object) {\n        for (k in obj) {\n          if (obj.hasOwnProperty(k)) {\n            keys.push(k);\n          }\n        }\n      } else if (obj.constructor === Array) {\n        for (i = 0; i < obj.length; ++i) {\n          keys.push(i);\n        }\n      }\n    }\n\n    for (i = 0; i < keys.length; ++i) {\n      k = keys[i];\n      v = obj[k];\n      isObj = typeof v === 'object';\n      if (isObj) {\n        if (v === null) {\n          obj[k] = func(k, v);\n        } else if (v.constructor === Object) {\n          obj[k] = Util.traverse(v, func);\n        } else if (v.constructor === Array) {\n          obj[k] = Util.traverse(v, func);\n        } else {\n          obj[k] = func(k, v);\n        }\n      } else {\n        obj[k] = func(k, v);\n      }\n    }\n\n    return obj;\n\n  },\n\n  redact: function(val) {\n    val = String(val);\n    return new Array(val.length + 1).join('*');\n  },\n\n  // from http://stackoverflow.com/a/8809472/1138191\n  uuid4: function() {\n    var d = new Date().getTime();\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c === 'x' ? r : (r & 0x7 | 0x8)).toString(16);\n    });\n    return uuid;\n  }\n};\n\nmodule.exports = Util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util.js\n ** module id = 7\n ** module chunks = 0\n **/","/* globals ActiveXObject */\n\n\"use strict\";\n\nvar RollbarJSON = null;\n\nfunction setupJSON(JSON) {\n  RollbarJSON = JSON;\n}\n\nvar XHR = {\n  XMLHttpFactories: [\n      function () {return new XMLHttpRequest();},\n      function () {return new ActiveXObject(\"Msxml2.XMLHTTP\");},\n      function () {return new ActiveXObject(\"Msxml3.XMLHTTP\");},\n      function () {return new ActiveXObject(\"Microsoft.XMLHTTP\");}\n  ],\n  createXMLHTTPObject: function() {\n    var xmlhttp = false;\n    var factories = XHR.XMLHttpFactories;\n    var i;\n    var numFactories = factories.length;\n    for (i = 0; i < numFactories; i++) {\n      try {\n        xmlhttp = factories[i]();\n        break;\n      } catch (e) {\n        // pass\n      }\n    }\n    return xmlhttp;\n  },\n  post: function(url, accessToken, payload, callback) {\n    if (typeof payload !== 'object') {\n      throw new Error('Expected an object to POST');\n    }\n    payload = RollbarJSON.stringify(payload);\n    callback = callback || function() {};\n    var request = XHR.createXMLHTTPObject();\n    if (request) {\n      try {\n        try {\n          var onreadystatechange = function(args) {\n            try {\n              if (onreadystatechange && request.readyState === 4) {\n                onreadystatechange = undefined;\n\n                // TODO(cory): have the notifier log an internal error on non-200 response codes\n                if (request.status === 200) {\n                  callback(null, RollbarJSON.parse(request.responseText));\n                } else if (typeof request.status === \"number\" &&\n                            request.status >= 400  && request.status < 600) {\n                  // return valid http status codes\n                  callback(new Error(request.status.toString()));\n                } else {\n                  // IE will return a status 12000+ on some sort of connection failure,\n                  // so we return a blank error\n                  // http://msdn.microsoft.com/en-us/library/aa383770%28VS.85%29.aspx\n                  callback(new Error());\n                }\n              }\n            } catch (ex) {\n              //jquery source mentions firefox may error out while accessing the\n              //request members if there is a network error\n              //https://github.com/jquery/jquery/blob/a938d7b1282fc0e5c52502c225ae8f0cef219f0a/src/ajax/xhr.js#L111\n              var exc;\n              if (typeof ex === 'object' && ex.stack) {\n                exc = ex;\n              } else {\n                exc = new Error(ex);\n              }\n              callback(exc);\n            }\n          };\n\n          request.open('POST', url, true);\n          if (request.setRequestHeader) {\n            request.setRequestHeader('Content-Type', 'application/json');\n            request.setRequestHeader('X-Rollbar-Access-Token', accessToken);\n          }\n          request.onreadystatechange = onreadystatechange;\n          request.send(payload);\n        } catch (e1) {\n          // Sending using the normal xmlhttprequest object didn't work, try XDomainRequest\n          if (typeof XDomainRequest !== \"undefined\") {\n            var ontimeout = function(args) {\n              callback(new Error());\n            };\n\n            var onerror = function(args) {\n              callback(new Error());\n            };\n\n            var onload = function(args) {\n              callback(null, RollbarJSON.parse(request.responseText));\n            };\n\n            request = new XDomainRequest();\n            request.onprogress = function() {};\n            request.ontimeout = ontimeout;\n            request.onerror = onerror;\n            request.onload = onload;\n            request.open('POST', url, true);\n            request.send(payload);\n          }\n        }\n      } catch (e2) {\n        callback(e2);\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  XHR: XHR,\n  setupJSON: setupJSON\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/xhr.js\n ** module id = 8\n ** module chunks = 0\n **/"],"sourceRoot":""}